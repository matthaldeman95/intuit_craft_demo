MarkupSafe
==========

Implements a unicode subclass that supports HTML strings:

>>> from markupsafe import Markup, escape
>>> escape("<script>alert(document.cookie***REMOVED***;</script>"***REMOVED***
Markup(u'&lt;script&gt;alert(document.cookie***REMOVED***;&lt;/script&gt;'***REMOVED***
>>> tmpl = Markup("<em>%s</em>"***REMOVED***
>>> tmpl % "Peter > Lustig"
Markup(u'<em>Peter &gt; Lustig</em>'***REMOVED***

If you want to make an object unicode that is not yet unicode
but don't want to lose the taint information, you can use the
`soft_unicode` function.  (On Python 3 you can also use `soft_str` which
is a different name for the same function***REMOVED***.

>>> from markupsafe import soft_unicode
>>> soft_unicode(42***REMOVED***
u'42'
>>> soft_unicode(Markup('foo'***REMOVED******REMOVED***
Markup(u'foo'***REMOVED***

HTML Representations
--------------------

Objects can customize their HTML markup equivalent by overriding
the `__html__` function:

>>> class Foo(object***REMOVED***:
...  def __html__(self***REMOVED***:
...   return '<strong>Nice</strong>'
...
>>> escape(Foo(***REMOVED******REMOVED***
Markup(u'<strong>Nice</strong>'***REMOVED***
>>> Markup(Foo(***REMOVED******REMOVED***
Markup(u'<strong>Nice</strong>'***REMOVED***

Silent Escapes
--------------

Since MarkupSafe 0.10 there is now also a separate escape function
called `escape_silent` that returns an empty string for `None` for
consistency with other systems that return empty strings for `None`
when escaping (for instance Pylons' webhelpers***REMOVED***.

If you also want to use this for the escape method of the Markup
object, you can create your own subclass that does that::

    from markupsafe import Markup, escape_silent as escape

    class SilentMarkup(Markup***REMOVED***:
        __slots__ = (***REMOVED***

        @classmethod
        def escape(cls, s***REMOVED***:
            return cls(escape(s***REMOVED******REMOVED***

New-Style String Formatting
---------------------------

Starting with MarkupSafe 0.21 new style string formats from Python 2.6 and
3.x are now fully supported.  Previously the escape behavior of those
functions was spotty at best.  The new implementations operates under the
following algorithm:

1.  if an object has an ``__html_format__`` method it is called as
    replacement for ``__format__`` with the format specifier.  It either
    has to return a string or markup object.
2.  if an object has an ``__html__`` method it is called.
3.  otherwise the default format system of Python kicks in and the result
    is HTML escaped.

Here is how you can implement your own formatting::

    class User(object***REMOVED***:

        def __init__(self, id, username***REMOVED***:
            self.id = id
            self.username = username

        def __html_format__(self, format_spec***REMOVED***:
            if format_spec == 'link':
                return Markup('<a href="/user/{0***REMOVED***">{1***REMOVED***</a>'***REMOVED***.format(
                    self.id,
                    self.__html__(***REMOVED***,
                ***REMOVED***
            elif format_spec:
                raise ValueError('Invalid format spec'***REMOVED***
            return self.__html__(***REMOVED***

        def __html__(self***REMOVED***:
            return Markup('<span class=user>{0***REMOVED***</span>'***REMOVED***.format(self.username***REMOVED***

And to format that user:

>>> user = User(1, 'foo'***REMOVED***
>>> Markup('<p>User: {0:link***REMOVED***'***REMOVED***.format(user***REMOVED***
Markup(u'<p>User: <a href="/user/1"><span class=user>foo</span></a>'***REMOVED***


