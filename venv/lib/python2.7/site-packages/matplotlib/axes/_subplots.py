from __future__ import (absolute_import, division, print_function,
                        unicode_literals***REMOVED***

from matplotlib.externals import six
from matplotlib.externals.six.moves import map

from matplotlib.gridspec import GridSpec, SubplotSpec
from matplotlib import docstring
import matplotlib.artist as martist
from matplotlib.axes._axes import Axes

import warnings
from matplotlib.cbook import mplDeprecation


class SubplotBase(object***REMOVED***:
    ***REMOVED***
    Base class for subplots, which are :class:`Axes` instances with
    additional methods to facilitate generating and manipulating a set
    of :class:`Axes` within a figure.
    ***REMOVED***

    def __init__(self, fig, *args, **kwargs***REMOVED***:
        ***REMOVED***
        *fig* is a :class:`matplotlib.figure.Figure` instance.

        *args* is the tuple (*numRows*, *numCols*, *plotNum****REMOVED***, where
        the array of subplots in the figure has dimensions *numRows*,
        *numCols*, and where *plotNum* is the number of the subplot
        being created.  *plotNum* starts at 1 in the upper left
        corner and increases to the right.


        If *numRows* <= *numCols* <= *plotNum* < 10, *args* can be the
        decimal integer *numRows* * 100 + *numCols* * 10 + *plotNum*.
        ***REMOVED***

        self.figure = fig

        if len(args***REMOVED*** == 1:
            if isinstance(args[0***REMOVED***, SubplotSpec***REMOVED***:
                self._subplotspec = args[0***REMOVED***
            else:
                ***REMOVED***
                    s = str(int(args[0***REMOVED******REMOVED******REMOVED***
                    rows, cols, num = list(map(int, s***REMOVED******REMOVED***
                except ValueError:
                    raise ValueError(
                        'Single argument to subplot must be a 3-digit '
                        'integer'***REMOVED***
                self._subplotspec = GridSpec(rows, cols***REMOVED***[num - 1***REMOVED***
                # num - 1 for converting from MATLAB to python indexing
        elif len(args***REMOVED*** == 3:
            rows, cols, num = args
            rows = int(rows***REMOVED***
            cols = int(cols***REMOVED***
            if isinstance(num, tuple***REMOVED*** and len(num***REMOVED*** == 2:
                num = [int(n***REMOVED*** for n in num***REMOVED***
                self._subplotspec = GridSpec(rows, cols***REMOVED***[num[0***REMOVED*** - 1:num[1***REMOVED******REMOVED***
            else:
                if num < 1 or num > rows*cols:
                    raise ValueError(
                        "num must be 1 <= num <= {maxn***REMOVED***, not {num***REMOVED***".format(
                            maxn=rows*cols, num=num***REMOVED******REMOVED***
                self._subplotspec = GridSpec(rows, cols***REMOVED***[int(num***REMOVED*** - 1***REMOVED***
                # num - 1 for converting from MATLAB to python indexing
        else:
            raise ValueError('Illegal argument(s***REMOVED*** to subplot: %s' % (args,***REMOVED******REMOVED***

        self.update_params(***REMOVED***

        # _axes_class is set in the subplot_class_factory
        self._axes_class.__init__(self, fig, self.figbox, **kwargs***REMOVED***

    def __reduce__(self***REMOVED***:
        # get the first axes class which does not
        # inherit from a subplotbase

        def not_subplotbase(c***REMOVED***:
            return issubclass(c, Axes***REMOVED*** and not issubclass(c, SubplotBase***REMOVED***

        axes_class = [c for c in self.__class__.mro(***REMOVED***
                      if not_subplotbase(c***REMOVED******REMOVED***[0***REMOVED***
        r = [_PicklableSubplotClassConstructor(***REMOVED***,
             (axes_class,***REMOVED***,
             self.__getstate__(***REMOVED******REMOVED***
        return tuple(r***REMOVED***

    def get_geometry(self***REMOVED***:
        ***REMOVED***get the subplot geometry, e.g., 2,2,3***REMOVED***
        rows, cols, num1, num2 = self.get_subplotspec(***REMOVED***.get_geometry(***REMOVED***
        return rows, cols, num1 + 1  # for compatibility

    # COVERAGE NOTE: Never used internally or from examples
    def change_geometry(self, numrows, numcols, num***REMOVED***:
        ***REMOVED***change subplot geometry, e.g., from 1,1,1 to 2,2,3***REMOVED***
        self._subplotspec = GridSpec(numrows, numcols***REMOVED***[num - 1***REMOVED***
        self.update_params(***REMOVED***
        self.set_position(self.figbox***REMOVED***

    def get_subplotspec(self***REMOVED***:
        ***REMOVED***get the SubplotSpec instance associated with the subplot***REMOVED***
        return self._subplotspec

    def set_subplotspec(self, subplotspec***REMOVED***:
        ***REMOVED***set the SubplotSpec instance associated with the subplot***REMOVED***
        self._subplotspec = subplotspec

    def update_params(self***REMOVED***:
        ***REMOVED***update the subplot position from fig.subplotpars***REMOVED***

        self.figbox, self.rowNum, self.colNum, self.numRows, self.numCols = \
            self.get_subplotspec(***REMOVED***.get_position(self.figure,
                                                return_all=True***REMOVED***

    def is_first_col(self***REMOVED***:
        return self.colNum == 0

    def is_first_row(self***REMOVED***:
        return self.rowNum == 0

    def is_last_row(self***REMOVED***:
        return self.rowNum == self.numRows - 1

    def is_last_col(self***REMOVED***:
        return self.colNum == self.numCols - 1

    # COVERAGE NOTE: Never used internally or from examples
    def label_outer(self***REMOVED***:
        ***REMOVED***
        set the visible property on ticklabels so xticklabels are
        visible only if the subplot is in the last row and yticklabels
        are visible only if the subplot is in the first column
        ***REMOVED***
        lastrow = self.is_last_row(***REMOVED***
        firstcol = self.is_first_col(***REMOVED***
        for label in self.get_xticklabels(***REMOVED***:
            label.set_visible(lastrow***REMOVED***

        for label in self.get_yticklabels(***REMOVED***:
            label.set_visible(firstcol***REMOVED***

    def _make_twin_axes(self, *kl, **kwargs***REMOVED***:
        ***REMOVED***
        make a twinx axes of self. This is used for twinx and twiny.
        ***REMOVED***
        from matplotlib.projections import process_projection_requirements
        kl = (self.get_subplotspec(***REMOVED***,***REMOVED*** + kl
        projection_class, kwargs, key = process_projection_requirements(
            self.figure, *kl, **kwargs***REMOVED***

        ax2 = subplot_class_factory(projection_class***REMOVED***(self.figure,
                                                      *kl, **kwargs***REMOVED***
        self.figure.add_subplot(ax2***REMOVED***
        return ax2

_subplot_classes = {***REMOVED***


def subplot_class_factory(axes_class=None***REMOVED***:
    # This makes a new class that inherits from SubplotBase and the
    # given axes_class (which is assumed to be a subclass of Axes***REMOVED***.
    # This is perhaps a little bit roundabout to make a new class on
    # the fly like this, but it means that a new Subplot class does
    # not have to be created for every type of Axes.
    if axes_class is None:
        axes_class = Axes

    new_class = _subplot_classes.get(axes_class***REMOVED***
    if new_class is None:
        new_class = type(str("%sSubplot"***REMOVED*** % (axes_class.__name__***REMOVED***,
                         (SubplotBase, axes_class***REMOVED***,
                     ***REMOVED***'_axes_class': axes_class***REMOVED******REMOVED***
        _subplot_classes[axes_class***REMOVED*** = new_class

    return new_class

# This is provided for backward compatibility
Subplot = subplot_class_factory(***REMOVED***


class _PicklableSubplotClassConstructor(object***REMOVED***:
    ***REMOVED***
    This stub class exists to return the appropriate subplot
    class when __call__-ed with an axes class. This is purely to
    allow Pickling of Axes and Subplots.
    ***REMOVED***
    def __call__(self, axes_class***REMOVED***:
        # create a dummy object instance
        subplot_instance = _PicklableSubplotClassConstructor(***REMOVED***
        subplot_class = subplot_class_factory(axes_class***REMOVED***
        # update the class to the desired subplot class
        subplot_instance.__class__ = subplot_class
        return subplot_instance


docstring.interpd.update(Axes=martist.kwdoc(Axes***REMOVED******REMOVED***
docstring.interpd.update(Subplot=martist.kwdoc(Axes***REMOVED******REMOVED***

***REMOVED***
# this is some discarded code I was using to find the minimum positive
# data point for some log scaling fixes.  I realized there was a
# cleaner way to do it, but am keeping this around as an example for
# how to get the data out of the axes.  Might want to make something
# like this a method one day, or better yet make get_verts an Artist
# method

            minx, maxx = self.get_xlim(***REMOVED***
            if minx<=0 or maxx<=0:
                # find the min pos value in the data
                xs = [***REMOVED***
                for line in self.lines:
                    xs.extend(line.get_xdata(orig=False***REMOVED******REMOVED***
                for patch in self.patches:
                    xs.extend([x for x,y in patch.get_verts(***REMOVED******REMOVED******REMOVED***
                for collection in self.collections:
                    xs.extend([x for x,y in collection.get_verts(***REMOVED******REMOVED******REMOVED***
                posx = [x for x in xs if x>0***REMOVED***
                if len(posx***REMOVED***:

                    minx = min(posx***REMOVED***
                    maxx = max(posx***REMOVED***
                    # warning, probably breaks inverted axis
                    self.set_xlim((0.1*minx, maxx***REMOVED******REMOVED***

***REMOVED***
