***REMOVED***
GUI neutral widgets
===================

Widgets that are designed to work for any of the GUI backends.
All of these widgets require you to predefine a :class:`matplotlib.axes.Axes`
instance and pass that as the first arg.  matplotlib doesn't try to
be too smart with respect to layout -- you will have to figure out how
wide and tall you want your Axes to be to accommodate your widget.
***REMOVED***

from __future__ import (absolute_import, division, print_function,
                        unicode_literals***REMOVED***

import copy
from matplotlib.externals import six
from matplotlib.externals.six.moves import zip

import numpy as np

from .mlab import dist
from .patches import Circle, Rectangle, Ellipse
from .lines import Line2D
from .transforms import blended_transform_factory


class LockDraw(object***REMOVED***:
    ***REMOVED***
    Some widgets, like the cursor, draw onto the canvas, and this is not
    desirable under all circumstances, like when the toolbar is in
    zoom-to-rect mode and drawing a rectangle.  The module level "lock"
    allows someone to grab the lock and prevent other widgets from
    drawing.  Use ``matplotlib.widgets.lock(someobj***REMOVED***`` to prevent
    other widgets from drawing while you're interacting with the canvas.
    ***REMOVED***

    def __init__(self***REMOVED***:
        self._owner = None

    def __call__(self, o***REMOVED***:
        ***REMOVED***reserve the lock for *o****REMOVED***
        if not self.available(o***REMOVED***:
            raise ValueError('already locked'***REMOVED***
        self._owner = o

    def release(self, o***REMOVED***:
        ***REMOVED***release the lock***REMOVED***
        if not self.available(o***REMOVED***:
            raise ValueError('you do not own this lock'***REMOVED***
        self._owner = None

    def available(self, o***REMOVED***:
        ***REMOVED***drawing is available to *o****REMOVED***
        return not self.locked(***REMOVED*** or self.isowner(o***REMOVED***

    def isowner(self, o***REMOVED***:
        ***REMOVED***Return True if *o* owns this lock***REMOVED***
        return self._owner is o

    def locked(self***REMOVED***:
        ***REMOVED***Return True if the lock is currently held by an owner***REMOVED***
        return self._owner is not None


class Widget(object***REMOVED***:
    ***REMOVED***
    Abstract base class for GUI neutral widgets
    ***REMOVED***
    drawon = True
    eventson = True
    _active = True

    def set_active(self, active***REMOVED***:
        ***REMOVED***Set whether the widget is active.
        ***REMOVED***
        self._active = active

    def get_active(self***REMOVED***:
        ***REMOVED***Get whether the widget is active.
        ***REMOVED***
        return self._active

    # set_active is overriden by SelectorWidgets.
    active = property(get_active, lambda self, active: self.set_active(active***REMOVED***,
                      doc="Is the widget active?"***REMOVED***

    def ignore(self, event***REMOVED***:
        ***REMOVED***Return True if event should be ignored.

        This method (or a version of it***REMOVED*** should be called at the beginning
        of any event callback.
        ***REMOVED***
        return not self.active


class AxesWidget(Widget***REMOVED***:
    ***REMOVED***Widget that is connected to a single
    :class:`~matplotlib.axes.Axes`.

    To guarantee that the widget remains responsive and not garbage-collected,
    a reference to the object should be maintained by the user.

    This is necessary because the callback registry
    maintains only weak-refs to the functions, which are member
    functions of the widget.  If there are no references to the widget
    object it may be garbage collected which will disconnect the
    callbacks.

    Attributes:

    *ax* : :class:`~matplotlib.axes.Axes`
        The parent axes for the widget
    *canvas* : :class:`~matplotlib.backend_bases.FigureCanvasBase` subclass
        The parent figure canvas for the widget.
    *active* : bool
        If False, the widget does not respond to events.
    ***REMOVED***
    def __init__(self, ax***REMOVED***:
        self.ax = ax
        self.canvas = ax.figure.canvas
        self.cids = [***REMOVED***

    def connect_event(self, event, callback***REMOVED***:
        ***REMOVED***Connect callback with an event.

        This should be used in lieu of `figure.canvas.mpl_connect` since this
        function stores callback ids for later clean up.
        ***REMOVED***
        cid = self.canvas.mpl_connect(event, callback***REMOVED***
        self.cids.append(cid***REMOVED***

    def disconnect_events(self***REMOVED***:
        ***REMOVED***Disconnect all events created by this widget.***REMOVED***
        for c in self.cids:
            self.canvas.mpl_disconnect(c***REMOVED***


class Button(AxesWidget***REMOVED***:
    ***REMOVED***
    A GUI neutral button.

    For the button to remain responsive you must keep a reference to it.

    The following attributes are accessible

      *ax*
        The :class:`matplotlib.axes.Axes` the button renders into.

      *label*
        A :class:`matplotlib.text.Text` instance.

      *color*
        The color of the button when not hovering.

      *hovercolor*
        The color of the button when hovering.

    Call :meth:`on_clicked` to connect to the button
    ***REMOVED***

    def __init__(self, ax, label, image=None,
                 color='0.85', hovercolor='0.95'***REMOVED***:
        ***REMOVED***
        Parameters
        ----------
        ax : matplotlib.axes.Axes
            The :class:`matplotlib.axes.Axes` instance the button
            will be placed into.

        label : str
            The button text. Accepts string.

        image : array, mpl image, Pillow Image
            The image to place in the button, if not *None*.
            Can be any legal arg to imshow (numpy array,
            matplotlib Image instance, or Pillow Image***REMOVED***.

        color : color
            The color of the button when not activated

        hovercolor : color
            The color of the button when the mouse is over it
        ***REMOVED***
        AxesWidget.__init__(self, ax***REMOVED***

        if image is not None:
            ax.imshow(image***REMOVED***
        self.label = ax.text(0.5, 0.5, label,
                             verticalalignment='center',
                             horizontalalignment='center',
                             transform=ax.transAxes***REMOVED***

        self.cnt = 0
        self.observers = {***REMOVED***

        self.connect_event('button_press_event', self._click***REMOVED***
        self.connect_event('button_release_event', self._release***REMOVED***
        self.connect_event('motion_notify_event', self._motion***REMOVED***
        ax.set_navigate(False***REMOVED***
        ax.set_axis_bgcolor(color***REMOVED***
        ax.set_xticks([***REMOVED******REMOVED***
        ax.set_yticks([***REMOVED******REMOVED***
        self.color = color
        self.hovercolor = hovercolor

        self._lastcolor = color

    def _click(self, event***REMOVED***:
        if self.ignore(event***REMOVED***:
            return
        if event.inaxes != self.ax:
            return
        if not self.eventson:
            return
        if event.canvas.mouse_grabber != self.ax:
            event.canvas.grab_mouse(self.ax***REMOVED***

    def _release(self, event***REMOVED***:
        if self.ignore(event***REMOVED***:
            return
        if event.canvas.mouse_grabber != self.ax:
            return
        event.canvas.release_mouse(self.ax***REMOVED***
        if not self.eventson:
            return
        if event.inaxes != self.ax:
            return
        for cid, func in six.iteritems(self.observers***REMOVED***:
            func(event***REMOVED***

    def _motion(self, event***REMOVED***:
        if self.ignore(event***REMOVED***:
            return
        if event.inaxes == self.ax:
            c = self.hovercolor
        else:
            c = self.color
        if c != self._lastcolor:
            self.ax.set_axis_bgcolor(c***REMOVED***
            self._lastcolor = c
            if self.drawon:
                self.ax.figure.canvas.draw(***REMOVED***

    def on_clicked(self, func***REMOVED***:
        ***REMOVED***
        When the button is clicked, call this *func* with event.

        A connection id is returned. It can be used to disconnect
        the button from its callback.
        ***REMOVED***
        cid = self.cnt
        self.observers[cid***REMOVED*** = func
        self.cnt += 1
        return cid

    def disconnect(self, cid***REMOVED***:
        ***REMOVED***remove the observer with connection id *cid****REMOVED***
        ***REMOVED***
            del self.observers[cid***REMOVED***
        except KeyError:
            pass


class Slider(AxesWidget***REMOVED***:
    ***REMOVED***
    A slider representing a floating point range.

    For the slider to remain responsive you must maintain a
    reference to it.

    The following attributes are defined
      *ax*        : the slider :class:`matplotlib.axes.Axes` instance

      *val*       : the current slider value

      *vline*     : a :class:`matplotlib.lines.Line2D` instance
                     representing the initial value of the slider

      *poly*      : A :class:`matplotlib.patches.Polygon` instance
                     which is the slider knob

      *valfmt*    : the format string for formatting the slider text

      *label*     : a :class:`matplotlib.text.Text` instance
                     for the slider label

      *closedmin* : whether the slider is closed on the minimum

      *closedmax* : whether the slider is closed on the maximum

      *slidermin* : another slider - if not *None*, this slider must be
                     greater than *slidermin*

      *slidermax* : another slider - if not *None*, this slider must be
                     less than *slidermax*

      *dragging*  : allow for mouse dragging on slider

    Call :meth:`on_changed` to connect to the slider event
    ***REMOVED***
    def __init__(self, ax, label, valmin, valmax, valinit=0.5, valfmt='%1.2f',
                 closedmin=True, closedmax=True, slidermin=None,
                 slidermax=None, dragging=True, **kwargs***REMOVED***:
        ***REMOVED***
        Create a slider from *valmin* to *valmax* in axes *ax*.

        Additional kwargs are passed on to ``self.poly`` which is the
        :class:`matplotlib.patches.Rectangle` that draws the slider
        knob.  See the :class:`matplotlib.patches.Rectangle` documentation for
        valid property names (e.g., *facecolor*, *edgecolor*, *alpha*, ...***REMOVED***.

        Parameters
        ----------
        ax : Axes
            The Axes to put the slider in

        label : str
            Slider label

        valmin : float
            The minimum value of the slider

        valmax : float
            The maximum value of the slider

        valinit : float
            The slider initial position

        label : str
            The slider label

        valfmt : str
            Used to format the slider value, fprint format string

        closedmin : bool
            Indicate whether the slider interval is closed on the bottom

        closedmax : bool
            Indicate whether the slider interval is closed on the top

        slidermin : Slider or None
            Do not allow the current slider to have a value less than
            `slidermin`

        slidermax : Slider or None
            Do not allow the current slider to have a value greater than
            `slidermax`


        dragging : bool
            if the slider can be dragged by the mouse

        ***REMOVED***
        AxesWidget.__init__(self, ax***REMOVED***

        self.valmin = valmin
        self.valmax = valmax
        self.val = valinit
        self.valinit = valinit
        self.poly = ax.axvspan(valmin, valinit, 0, 1, **kwargs***REMOVED***

        self.vline = ax.axvline(valinit, 0, 1, color='r', lw=1***REMOVED***

        self.valfmt = valfmt
        ax.set_yticks([***REMOVED******REMOVED***
        ax.set_xlim((valmin, valmax***REMOVED******REMOVED***
        ax.set_xticks([***REMOVED******REMOVED***
        ax.set_navigate(False***REMOVED***

        self.connect_event('button_press_event', self._update***REMOVED***
        self.connect_event('button_release_event', self._update***REMOVED***
        if dragging:
            self.connect_event('motion_notify_event', self._update***REMOVED***
        self.label = ax.text(-0.02, 0.5, label, transform=ax.transAxes,
                             verticalalignment='center',
                             horizontalalignment='right'***REMOVED***

        self.valtext = ax.text(1.02, 0.5, valfmt % valinit,
                               transform=ax.transAxes,
                               verticalalignment='center',
                               horizontalalignment='left'***REMOVED***

        self.cnt = 0
        self.observers = {***REMOVED***

        self.closedmin = closedmin
        self.closedmax = closedmax
        self.slidermin = slidermin
        self.slidermax = slidermax
        self.drag_active = False

    def _update(self, event***REMOVED***:
        ***REMOVED***update the slider position***REMOVED***
        if self.ignore(event***REMOVED***:
            return

        if event.button != 1:
            return

        if event.name == 'button_press_event' and event.inaxes == self.ax:
            self.drag_active = True
            event.canvas.grab_mouse(self.ax***REMOVED***

        if not self.drag_active:
            return

        elif ((event.name == 'button_release_event'***REMOVED*** or
              (event.name == 'button_press_event' and
               event.inaxes != self.ax***REMOVED******REMOVED***:
            self.drag_active = False
            event.canvas.release_mouse(self.ax***REMOVED***
            return

        val = event.xdata
        if val <= self.valmin:
            if not self.closedmin:
                return
            val = self.valmin
        elif val >= self.valmax:
            if not self.closedmax:
                return
            val = self.valmax

        if self.slidermin is not None and val <= self.slidermin.val:
            if not self.closedmin:
                return
            val = self.slidermin.val

        if self.slidermax is not None and val >= self.slidermax.val:
            if not self.closedmax:
                return
            val = self.slidermax.val

        self.set_val(val***REMOVED***

    def set_val(self, val***REMOVED***:
        xy = self.poly.xy
        xy[2***REMOVED*** = val, 1
        xy[3***REMOVED*** = val, 0
        self.poly.xy = xy
        self.valtext.set_text(self.valfmt % val***REMOVED***
        if self.drawon:
            self.ax.figure.canvas.draw_idle(***REMOVED***
        self.val = val
        if not self.eventson:
            return
        for cid, func in six.iteritems(self.observers***REMOVED***:
            func(val***REMOVED***

    def on_changed(self, func***REMOVED***:
        ***REMOVED***
        When the slider value is changed, call *func* with the new
        slider position

        A connection id is returned which can be used to disconnect
        ***REMOVED***
        cid = self.cnt
        self.observers[cid***REMOVED*** = func
        self.cnt += 1
        return cid

    def disconnect(self, cid***REMOVED***:
        ***REMOVED***remove the observer with connection id *cid****REMOVED***
        ***REMOVED***
            del self.observers[cid***REMOVED***
        except KeyError:
            pass

    def reset(self***REMOVED***:
        ***REMOVED***reset the slider to the initial value if needed***REMOVED***
        if (self.val != self.valinit***REMOVED***:
            self.set_val(self.valinit***REMOVED***


class CheckButtons(AxesWidget***REMOVED***:
    ***REMOVED***
    A GUI neutral radio button.

    For the check buttons to remain responsive you must keep a
    reference to this object.

    The following attributes are exposed

     *ax*
        The :class:`matplotlib.axes.Axes` instance the buttons are
        located in

     *labels*
        List of :class:`matplotlib.text.Text` instances

     *lines*
        List of (line1, line2***REMOVED*** tuples for the x's in the check boxes.
        These lines exist for each box, but have ``set_visible(False***REMOVED***``
        when its box is not checked.

     *rectangles*
        List of :class:`matplotlib.patches.Rectangle` instances

    Connect to the CheckButtons with the :meth:`on_clicked` method
    ***REMOVED***
    def __init__(self, ax, labels, actives***REMOVED***:
        ***REMOVED***
        Add check buttons to :class:`matplotlib.axes.Axes` instance *ax*

        *labels*
            A len(buttons***REMOVED*** list of labels as strings

        *actives*
            A len(buttons***REMOVED*** list of booleans indicating whether
             the button is active
        ***REMOVED***
        AxesWidget.__init__(self, ax***REMOVED***

        ax.set_xticks([***REMOVED******REMOVED***
        ax.set_yticks([***REMOVED******REMOVED***
        ax.set_navigate(False***REMOVED***

        if len(labels***REMOVED*** > 1:
            dy = 1. / (len(labels***REMOVED*** + 1***REMOVED***
            ys = np.linspace(1 - dy, dy, len(labels***REMOVED******REMOVED***
        else:
            dy = 0.25
            ys = [0.5***REMOVED***

        cnt = 0
        axcolor = ax.get_axis_bgcolor(***REMOVED***

        self.labels = [***REMOVED***
        self.lines = [***REMOVED***
        self.rectangles = [***REMOVED***

        lineparams = {'color': 'k', 'linewidth': 1.25,
                      'transform': ax.transAxes, 'solid_capstyle': 'butt'***REMOVED***
        for y, label in zip(ys, labels***REMOVED***:
            t = ax.text(0.25, y, label, transform=ax.transAxes,
                        horizontalalignment='left',
                        verticalalignment='center'***REMOVED***

            w, h = dy / 2., dy / 2.
            x, y = 0.05, y - h / 2.

            p = Rectangle(xy=(x, y***REMOVED***, width=w, height=h,
                          facecolor=axcolor,
                          transform=ax.transAxes***REMOVED***

            l1 = Line2D([x, x + w***REMOVED***, [y + h, y***REMOVED***, **lineparams***REMOVED***
            l2 = Line2D([x, x + w***REMOVED***, [y, y + h***REMOVED***, **lineparams***REMOVED***

            l1.set_visible(actives[cnt***REMOVED******REMOVED***
            l2.set_visible(actives[cnt***REMOVED******REMOVED***
            self.labels.append(t***REMOVED***
            self.rectangles.append(p***REMOVED***
            self.lines.append((l1, l2***REMOVED******REMOVED***
            ax.add_patch(p***REMOVED***
            ax.add_line(l1***REMOVED***
            ax.add_line(l2***REMOVED***
            cnt += 1

        self.connect_event('button_press_event', self._clicked***REMOVED***

        self.cnt = 0
        self.observers = {***REMOVED***

    def _clicked(self, event***REMOVED***:
        if self.ignore(event***REMOVED***:
            return
        if event.button != 1:
            return
        if event.inaxes != self.ax:
            return

        for i, (p, t***REMOVED*** in enumerate(zip(self.rectangles, self.labels***REMOVED******REMOVED***:
            if (t.get_window_extent(***REMOVED***.contains(event.x, event.y***REMOVED*** or
                    p.get_window_extent(***REMOVED***.contains(event.x, event.y***REMOVED******REMOVED***:
                self.set_active(i***REMOVED***
                break
        else:
            return

    def set_active(self, index***REMOVED***:
        ***REMOVED***
        Directly (de***REMOVED***activate a check button by index.

        *index* is an index into the original label list
            that this object was constructed with.
            Raises ValueError if *index* is invalid.

        Callbacks will be triggered if :attr:`eventson` is True.

        ***REMOVED***
        if 0 > index >= len(self.labels***REMOVED***:
            raise ValueError("Invalid CheckButton index: %d" % index***REMOVED***

        l1, l2 = self.lines[index***REMOVED***
        l1.set_visible(not l1.get_visible(***REMOVED******REMOVED***
        l2.set_visible(not l2.get_visible(***REMOVED******REMOVED***

        if self.drawon:
            self.ax.figure.canvas.draw(***REMOVED***

        if not self.eventson:
            return
        for cid, func in six.iteritems(self.observers***REMOVED***:
            func(self.labels[index***REMOVED***.get_text(***REMOVED******REMOVED***

    def on_clicked(self, func***REMOVED***:
        ***REMOVED***
        When the button is clicked, call *func* with button label

        A connection id is returned which can be used to disconnect
        ***REMOVED***
        cid = self.cnt
        self.observers[cid***REMOVED*** = func
        self.cnt += 1
        return cid

    def disconnect(self, cid***REMOVED***:
        ***REMOVED***remove the observer with connection id *cid****REMOVED***
        ***REMOVED***
            del self.observers[cid***REMOVED***
        except KeyError:
            pass


class RadioButtons(AxesWidget***REMOVED***:
    ***REMOVED***
    A GUI neutral radio button.

    For the buttons to remain responsive
    you must keep a reference to this object.

    The following attributes are exposed:

     *ax*
        The :class:`matplotlib.axes.Axes` instance the buttons are in

     *activecolor*
        The color of the button when clicked

     *labels*
        A list of :class:`matplotlib.text.Text` instances

     *circles*
        A list of :class:`matplotlib.patches.Circle` instances

     *value_selected*
        A string listing the current value selected

    Connect to the RadioButtons with the :meth:`on_clicked` method
    ***REMOVED***
    def __init__(self, ax, labels, active=0, activecolor='blue'***REMOVED***:
        ***REMOVED***
        Add radio buttons to :class:`matplotlib.axes.Axes` instance *ax*

        *labels*
            A len(buttons***REMOVED*** list of labels as strings

        *active*
            The index into labels for the button that is active

        *activecolor*
            The color of the button when clicked
        ***REMOVED***
        AxesWidget.__init__(self, ax***REMOVED***
        self.activecolor = activecolor
        self.value_selected = None

        ax.set_xticks([***REMOVED******REMOVED***
        ax.set_yticks([***REMOVED******REMOVED***
        ax.set_navigate(False***REMOVED***
        dy = 1. / (len(labels***REMOVED*** + 1***REMOVED***
        ys = np.linspace(1 - dy, dy, len(labels***REMOVED******REMOVED***
        cnt = 0
        axcolor = ax.get_axis_bgcolor(***REMOVED***

        self.labels = [***REMOVED***
        self.circles = [***REMOVED***
        for y, label in zip(ys, labels***REMOVED***:
            t = ax.text(0.25, y, label, transform=ax.transAxes,
                        horizontalalignment='left',
                        verticalalignment='center'***REMOVED***

            if cnt == active:
                self.value_selected = label
                facecolor = activecolor
            else:
                facecolor = axcolor

            p = Circle(xy=(0.15, y***REMOVED***, radius=0.05, facecolor=facecolor,
                       transform=ax.transAxes***REMOVED***

            self.labels.append(t***REMOVED***
            self.circles.append(p***REMOVED***
            ax.add_patch(p***REMOVED***
            cnt += 1

        self.connect_event('button_press_event', self._clicked***REMOVED***

        self.cnt = 0
        self.observers = {***REMOVED***

    def _clicked(self, event***REMOVED***:
        if self.ignore(event***REMOVED***:
            return
        if event.button != 1:
            return
        if event.inaxes != self.ax:
            return
        xy = self.ax.transAxes.inverted(***REMOVED***.transform_point((event.x, event.y***REMOVED******REMOVED***
        pclicked = np.array([xy[0***REMOVED***, xy[1***REMOVED******REMOVED******REMOVED***

        def inside(p***REMOVED***:
            pcirc = np.array([p.center[0***REMOVED***, p.center[1***REMOVED******REMOVED******REMOVED***
            return dist(pclicked, pcirc***REMOVED*** < p.radius

        for i, (p, t***REMOVED*** in enumerate(zip(self.circles, self.labels***REMOVED******REMOVED***:
            if t.get_window_extent(***REMOVED***.contains(event.x, event.y***REMOVED*** or inside(p***REMOVED***:
                self.set_active(i***REMOVED***
                break
        else:
            return

    def set_active(self, index***REMOVED***:
        ***REMOVED***
        Trigger which radio button to make active.

        *index* is an index into the original label list
            that this object was constructed with.
            Raise ValueError if the index is invalid.

        Callbacks will be triggered if :attr:`eventson` is True.

        ***REMOVED***
        if 0 > index >= len(self.labels***REMOVED***:
            raise ValueError("Invalid RadioButton index: %d" % index***REMOVED***

        self.value_selected = self.labels[index***REMOVED***.get_text(***REMOVED***

        for i, p in enumerate(self.circles***REMOVED***:
            if i == index:
                color = self.activecolor
            else:
                color = self.ax.get_axis_bgcolor(***REMOVED***
            p.set_facecolor(color***REMOVED***

        if self.drawon:
            self.ax.figure.canvas.draw(***REMOVED***

        if not self.eventson:
            return
        for cid, func in six.iteritems(self.observers***REMOVED***:
            func(self.labels[index***REMOVED***.get_text(***REMOVED******REMOVED***

    def on_clicked(self, func***REMOVED***:
        ***REMOVED***
        When the button is clicked, call *func* with button label

        A connection id is returned which can be used to disconnect
        ***REMOVED***
        cid = self.cnt
        self.observers[cid***REMOVED*** = func
        self.cnt += 1
        return cid

    def disconnect(self, cid***REMOVED***:
        ***REMOVED***remove the observer with connection id *cid****REMOVED***
        ***REMOVED***
            del self.observers[cid***REMOVED***
        except KeyError:
            pass


class SubplotTool(Widget***REMOVED***:
    ***REMOVED***
    A tool to adjust the subplot params of a :class:`matplotlib.figure.Figure`.
    ***REMOVED***
    def __init__(self, targetfig, toolfig***REMOVED***:
        ***REMOVED***
        *targetfig*
            The figure instance to adjust.

        *toolfig*
            The figure instance to embed the subplot tool into. If
            *None*, a default figure will be created. If you are using
            this from the GUI
        ***REMOVED***
        # FIXME: The docstring seems to just abruptly end without...

        self.targetfig = targetfig
        toolfig.subplots_adjust(left=0.2, right=0.9***REMOVED***

        class toolbarfmt:
            def __init__(self, slider***REMOVED***:
                self.slider = slider

            def __call__(self, x, y***REMOVED***:
                fmt = '%s=%s' % (self.slider.label.get_text(***REMOVED***,
                                 self.slider.valfmt***REMOVED***
                return fmt % x

        self.axleft = toolfig.add_subplot(711***REMOVED***
        self.axleft.set_title('Click on slider to adjust subplot param'***REMOVED***
        self.axleft.set_navigate(False***REMOVED***

        self.sliderleft = Slider(self.axleft, 'left',
                                 0, 1, targetfig.subplotpars.left,
                                 closedmax=False***REMOVED***
        self.sliderleft.on_changed(self.funcleft***REMOVED***

        self.axbottom = toolfig.add_subplot(712***REMOVED***
        self.axbottom.set_navigate(False***REMOVED***
        self.sliderbottom = Slider(self.axbottom,
                                   'bottom', 0, 1,
                                   targetfig.subplotpars.bottom,
                                   closedmax=False***REMOVED***
        self.sliderbottom.on_changed(self.funcbottom***REMOVED***

        self.axright = toolfig.add_subplot(713***REMOVED***
        self.axright.set_navigate(False***REMOVED***
        self.sliderright = Slider(self.axright, 'right', 0, 1,
                                  targetfig.subplotpars.right,
                                  closedmin=False***REMOVED***
        self.sliderright.on_changed(self.funcright***REMOVED***

        self.axtop = toolfig.add_subplot(714***REMOVED***
        self.axtop.set_navigate(False***REMOVED***
        self.slidertop = Slider(self.axtop, 'top', 0, 1,
                                targetfig.subplotpars.top,
                                closedmin=False***REMOVED***
        self.slidertop.on_changed(self.functop***REMOVED***

        self.axwspace = toolfig.add_subplot(715***REMOVED***
        self.axwspace.set_navigate(False***REMOVED***
        self.sliderwspace = Slider(self.axwspace, 'wspace',
                                   0, 1, targetfig.subplotpars.wspace,
                                   closedmax=False***REMOVED***
        self.sliderwspace.on_changed(self.funcwspace***REMOVED***

        self.axhspace = toolfig.add_subplot(716***REMOVED***
        self.axhspace.set_navigate(False***REMOVED***
        self.sliderhspace = Slider(self.axhspace, 'hspace',
                                   0, 1, targetfig.subplotpars.hspace,
                                   closedmax=False***REMOVED***
        self.sliderhspace.on_changed(self.funchspace***REMOVED***

        # constraints
        self.sliderleft.slidermax = self.sliderright
        self.sliderright.slidermin = self.sliderleft
        self.sliderbottom.slidermax = self.slidertop
        self.slidertop.slidermin = self.sliderbottom

        bax = toolfig.add_axes([0.8, 0.05, 0.15, 0.075***REMOVED******REMOVED***
        self.buttonreset = Button(bax, 'Reset'***REMOVED***

        sliders = (self.sliderleft, self.sliderbottom, self.sliderright,
                   self.slidertop, self.sliderwspace, self.sliderhspace,***REMOVED***

        def func(event***REMOVED***:
            thisdrawon = self.drawon

            self.drawon = False

            # store the drawon state of each slider
            bs = [***REMOVED***
            for slider in sliders:
                bs.append(slider.drawon***REMOVED***
                slider.drawon = False

            # reset the slider to the initial position
            for slider in sliders:
                slider.reset(***REMOVED***

            # reset drawon
            for slider, b in zip(sliders, bs***REMOVED***:
                slider.drawon = b

            # draw the canvas
            self.drawon = thisdrawon
            if self.drawon:
                toolfig.canvas.draw(***REMOVED***
                self.targetfig.canvas.draw(***REMOVED***

        # during reset there can be a temporary invalid state
        # depending on the order of the reset so we turn off
        # validation for the resetting
        validate = toolfig.subplotpars.validate
        toolfig.subplotpars.validate = False
        self.buttonreset.on_clicked(func***REMOVED***
        toolfig.subplotpars.validate = validate

    def funcleft(self, val***REMOVED***:
        self.targetfig.subplots_adjust(left=val***REMOVED***
        if self.drawon:
            self.targetfig.canvas.draw(***REMOVED***

    def funcright(self, val***REMOVED***:
        self.targetfig.subplots_adjust(right=val***REMOVED***
        if self.drawon:
            self.targetfig.canvas.draw(***REMOVED***

    def funcbottom(self, val***REMOVED***:
        self.targetfig.subplots_adjust(bottom=val***REMOVED***
        if self.drawon:
            self.targetfig.canvas.draw(***REMOVED***

    def functop(self, val***REMOVED***:
        self.targetfig.subplots_adjust(top=val***REMOVED***
        if self.drawon:
            self.targetfig.canvas.draw(***REMOVED***

    def funcwspace(self, val***REMOVED***:
        self.targetfig.subplots_adjust(wspace=val***REMOVED***
        if self.drawon:
            self.targetfig.canvas.draw(***REMOVED***

    def funchspace(self, val***REMOVED***:
        self.targetfig.subplots_adjust(hspace=val***REMOVED***
        if self.drawon:
            self.targetfig.canvas.draw(***REMOVED***


class Cursor(AxesWidget***REMOVED***:
    ***REMOVED***
    A horizontal and vertical line that spans the axes and moves with
    the pointer.  You can turn off the hline or vline respectively with
    the following attributes:

      *horizOn*
        Controls the visibility of the horizontal line

      *vertOn*
        Controls the visibility of the horizontal line

    and the visibility of the cursor itself with the *visible* attribute.

    For the cursor to remain responsive you must keep a reference to
    it.
    ***REMOVED***
    def __init__(self, ax, horizOn=True, vertOn=True, useblit=False,
                 **lineprops***REMOVED***:
        ***REMOVED***
        Add a cursor to *ax*.  If ``useblit=True``, use the backend-
        dependent blitting features for faster updates (GTKAgg
        only for now***REMOVED***.  *lineprops* is a dictionary of line properties.

        .. plot :: mpl_examples/widgets/cursor.py
        ***REMOVED***
        # TODO: Is the GTKAgg limitation still true?
        AxesWidget.__init__(self, ax***REMOVED***

        self.connect_event('motion_notify_event', self.onmove***REMOVED***
        self.connect_event('draw_event', self.clear***REMOVED***

        self.visible = True
        self.horizOn = horizOn
        self.vertOn = vertOn
        self.useblit = useblit and self.canvas.supports_blit

        if self.useblit:
            lineprops['animated'***REMOVED*** = True
        self.lineh = ax.axhline(ax.get_ybound(***REMOVED***[0***REMOVED***, visible=False, **lineprops***REMOVED***
        self.linev = ax.axvline(ax.get_xbound(***REMOVED***[0***REMOVED***, visible=False, **lineprops***REMOVED***

        self.background = None
        self.needclear = False

    def clear(self, event***REMOVED***:
        ***REMOVED***clear the cursor***REMOVED***
        if self.ignore(event***REMOVED***:
            return
        if self.useblit:
            self.background = self.canvas.copy_from_bbox(self.ax.bbox***REMOVED***
        self.linev.set_visible(False***REMOVED***
        self.lineh.set_visible(False***REMOVED***

    def onmove(self, event***REMOVED***:
        ***REMOVED***on mouse motion draw the cursor if visible***REMOVED***
        if self.ignore(event***REMOVED***:
            return
        if not self.canvas.widgetlock.available(self***REMOVED***:
            return
        if event.inaxes != self.ax:
            self.linev.set_visible(False***REMOVED***
            self.lineh.set_visible(False***REMOVED***

            if self.needclear:
                self.canvas.draw(***REMOVED***
                self.needclear = False
            return
        self.needclear = True
        if not self.visible:
            return
        self.linev.set_xdata((event.xdata, event.xdata***REMOVED******REMOVED***

        self.lineh.set_ydata((event.ydata, event.ydata***REMOVED******REMOVED***
        self.linev.set_visible(self.visible and self.vertOn***REMOVED***
        self.lineh.set_visible(self.visible and self.horizOn***REMOVED***

        self._update(***REMOVED***

    def _update(self***REMOVED***:

        if self.useblit:
            if self.background is not None:
                self.canvas.restore_region(self.background***REMOVED***
            self.ax.draw_artist(self.linev***REMOVED***
            self.ax.draw_artist(self.lineh***REMOVED***
            self.canvas.blit(self.ax.bbox***REMOVED***
        else:

            self.canvas.draw_idle(***REMOVED***

        return False


class MultiCursor(Widget***REMOVED***:
    ***REMOVED***
    Provide a vertical (default***REMOVED*** and/or horizontal line cursor shared between
    multiple axes.

    For the cursor to remain responsive you must keep a reference to
    it.

    Example usage::

        from matplotlib.widgets import MultiCursor
        from pylab import figure, show, np

        t = np.arange(0.0, 2.0, 0.01***REMOVED***
        s1 = np.sin(2*np.pi*t***REMOVED***
        s2 = np.sin(4*np.pi*t***REMOVED***
        fig = figure(***REMOVED***
        ax1 = fig.add_subplot(211***REMOVED***
        ax1.plot(t, s1***REMOVED***


        ax2 = fig.add_subplot(212, sharex=ax1***REMOVED***
        ax2.plot(t, s2***REMOVED***

        multi = MultiCursor(fig.canvas, (ax1, ax2***REMOVED***, color='r', lw=1,
                            horizOn=False, vertOn=True***REMOVED***
        show(***REMOVED***

    ***REMOVED***
    def __init__(self, canvas, axes, useblit=True, horizOn=False, vertOn=True,
                 **lineprops***REMOVED***:

        self.canvas = canvas
        self.axes = axes
        self.horizOn = horizOn
        self.vertOn = vertOn

        xmin, xmax = axes[-1***REMOVED***.get_xlim(***REMOVED***
        ymin, ymax = axes[-1***REMOVED***.get_ylim(***REMOVED***
        xmid = 0.5 * (xmin + xmax***REMOVED***
        ymid = 0.5 * (ymin + ymax***REMOVED***

        self.visible = True
        self.useblit = useblit and self.canvas.supports_blit
        self.background = None
        self.needclear = False

        if self.useblit:
            lineprops['animated'***REMOVED*** = True

        if vertOn:
            self.vlines = [ax.axvline(xmid, visible=False, **lineprops***REMOVED***
                           for ax in axes***REMOVED***
        else:
            self.vlines = [***REMOVED***

        if horizOn:
            self.hlines = [ax.axhline(ymid, visible=False, **lineprops***REMOVED***
                           for ax in axes***REMOVED***
        else:
            self.hlines = [***REMOVED***

        self.connect(***REMOVED***

    def connect(self***REMOVED***:
        ***REMOVED***connect events***REMOVED***
        self._cidmotion = self.canvas.mpl_connect('motion_notify_event',
                                                  self.onmove***REMOVED***
        self._ciddraw = self.canvas.mpl_connect('draw_event', self.clear***REMOVED***

    def disconnect(self***REMOVED***:
        ***REMOVED***disconnect events***REMOVED***
        self.canvas.mpl_disconnect(self._cidmotion***REMOVED***
        self.canvas.mpl_disconnect(self._ciddraw***REMOVED***

    def clear(self, event***REMOVED***:
        ***REMOVED***clear the cursor***REMOVED***
        if self.ignore(event***REMOVED***:
            return
        if self.useblit:
            self.background = (
                self.canvas.copy_from_bbox(self.canvas.figure.bbox***REMOVED******REMOVED***
        for line in self.vlines + self.hlines:
            line.set_visible(False***REMOVED***

    def onmove(self, event***REMOVED***:
        if self.ignore(event***REMOVED***:
            return
        if event.inaxes is None:
            return
        if not self.canvas.widgetlock.available(self***REMOVED***:
            return
        self.needclear = True
        if not self.visible:
            return
        if self.vertOn:
            for line in self.vlines:
                line.set_xdata((event.xdata, event.xdata***REMOVED******REMOVED***
                line.set_visible(self.visible***REMOVED***
        if self.horizOn:
            for line in self.hlines:
                line.set_ydata((event.ydata, event.ydata***REMOVED******REMOVED***
                line.set_visible(self.visible***REMOVED***
        self._update(***REMOVED***

    def _update(self***REMOVED***:
        if self.useblit:
            if self.background is not None:
                self.canvas.restore_region(self.background***REMOVED***
            if self.vertOn:
                for ax, line in zip(self.axes, self.vlines***REMOVED***:
                    ax.draw_artist(line***REMOVED***
            if self.horizOn:
                for ax, line in zip(self.axes, self.hlines***REMOVED***:
                    ax.draw_artist(line***REMOVED***
            self.canvas.blit(self.canvas.figure.bbox***REMOVED***
        else:
            self.canvas.draw_idle(***REMOVED***


class _SelectorWidget(AxesWidget***REMOVED***:

    def __init__(self, ax, onselect, useblit=False, button=None,
                 state_modifier_keys=None***REMOVED***:
        AxesWidget.__init__(self, ax***REMOVED***

        self.visible = True
        self.onselect = onselect
        self.useblit = useblit and self.canvas.supports_blit
        self.connect_default_events(***REMOVED***

        self.state_modifier_keys = dict(move=' ', clear='escape',
                                        square='shift', center='control'***REMOVED***
        self.state_modifier_keys.update(state_modifier_keys or {***REMOVED******REMOVED***

        self.background = None
        self.artists = [***REMOVED***

        if isinstance(button, int***REMOVED***:
            self.validButtons = [button***REMOVED***
        else:
            self.validButtons = button

        # will save the data (position at mouseclick***REMOVED***
        self.eventpress = None
        # will save the data (pos. at mouserelease***REMOVED***
        self.eventrelease = None
        self._prev_event = None
        self.state = set(***REMOVED***

    def set_active(self, active***REMOVED***:
        AxesWidget.set_active(self, active***REMOVED***
        if active:
            self.update_background(None***REMOVED***

    def update_background(self, event***REMOVED***:
        ***REMOVED***force an update of the background***REMOVED***
        # If you add a call to `ignore` here, you'll want to check edge case:
        # `release` can call a draw event even when `ignore` is True.
        if self.useblit:
            self.background = self.canvas.copy_from_bbox(self.ax.bbox***REMOVED***

    def connect_default_events(self***REMOVED***:
        ***REMOVED***Connect the major canvas events to methods.***REMOVED***
        self.connect_event('motion_notify_event', self.onmove***REMOVED***
        self.connect_event('button_press_event', self.press***REMOVED***
        self.connect_event('button_release_event', self.release***REMOVED***
        self.connect_event('draw_event', self.update_background***REMOVED***
        self.connect_event('key_press_event', self.on_key_press***REMOVED***
        self.connect_event('key_release_event', self.on_key_release***REMOVED***
        self.connect_event('scroll_event', self.on_scroll***REMOVED***

    def ignore(self, event***REMOVED***:
        ***REMOVED***return *True* if *event* should be ignored***REMOVED***
        if not self.active or not self.ax.get_visible(***REMOVED***:
            return True

        # If canvas was locked
        if not self.canvas.widgetlock.available(self***REMOVED***:
            return True

        if not hasattr(event, 'button'***REMOVED***:
            event.button = None

        # Only do rectangle selection if event was triggered
        # with a desired button
        if self.validButtons is not None:
            if event.button not in self.validButtons:
                return True

        # If no button was pressed yet ignore the event if it was out
        # of the axes
        if self.eventpress is None:
            return event.inaxes != self.ax

        # If a button was pressed, check if the release-button is the
        # same.
        if event.button == self.eventpress.button:
            return False

        # If a button was pressed, check if the release-button is the
        # same.
        return (event.inaxes != self.ax or
                event.button != self.eventpress.button***REMOVED***

    def update(self***REMOVED***:
        ***REMOVED***draw using newfangled blit or oldfangled draw depending on
        useblit

        ***REMOVED***
        if not self.ax.get_visible(***REMOVED***:
            return False

        if self.useblit:
            if self.background is not None:
                self.canvas.restore_region(self.background***REMOVED***
            for artist in self.artists:
                self.ax.draw_artist(artist***REMOVED***

            self.canvas.blit(self.ax.bbox***REMOVED***

        else:
            self.canvas.draw_idle(***REMOVED***
        return False

    def _get_data(self, event***REMOVED***:
        ***REMOVED***Get the xdata and ydata for event, with limits***REMOVED***
        if event.xdata is None:
            return None, None
        x0, x1 = self.ax.get_xbound(***REMOVED***
        y0, y1 = self.ax.get_ybound(***REMOVED***
        xdata = max(x0, event.xdata***REMOVED***
        xdata = min(x1, xdata***REMOVED***
        ydata = max(y0, event.ydata***REMOVED***
        ydata = min(y1, ydata***REMOVED***
        return xdata, ydata

    def _clean_event(self, event***REMOVED***:
        ***REMOVED***Clean up an event

        Use prev event if there is no xdata
        Limit the xdata and ydata to the axes limits
        Set the prev event
        ***REMOVED***
        if event.xdata is None:
            event = self._prev_event
        else:
            event = copy.copy(event***REMOVED***
        event.xdata, event.ydata = self._get_data(event***REMOVED***

        self._prev_event = event
        return event

    def press(self, event***REMOVED***:
        ***REMOVED***Button press handler and validator***REMOVED***
        if not self.ignore(event***REMOVED***:
            event = self._clean_event(event***REMOVED***
            self.eventpress = event
            self._prev_event = event
            key = event.key or ''
            key = key.replace('ctrl', 'control'***REMOVED***
            # move state is locked in on a button press
            if key == self.state_modifier_keys['move'***REMOVED***:
                self.state.add('move'***REMOVED***
            self._press(event***REMOVED***
            return True
        return False

    def _press(self, event***REMOVED***:
        ***REMOVED***Button press handler***REMOVED***
        pass

    def release(self, event***REMOVED***:
        ***REMOVED***Button release event handler and validator***REMOVED***
        if not self.ignore(event***REMOVED*** and self.eventpress:
            event = self._clean_event(event***REMOVED***
            self.eventrelease = event
            self._release(event***REMOVED***
            self.eventpress = None
            self.eventrelease = None
            self.state.discard('move'***REMOVED***
            return True
        return False

    def _release(self, event***REMOVED***:
        ***REMOVED***Button release event handler***REMOVED***
        pass

    def onmove(self, event***REMOVED***:
        ***REMOVED***Cursor move event handler and validator***REMOVED***
        if not self.ignore(event***REMOVED*** and self.eventpress:
            event = self._clean_event(event***REMOVED***
            self._onmove(event***REMOVED***
            return True
        return False

    def _onmove(self, event***REMOVED***:
        ***REMOVED***Cursor move event handler***REMOVED***
        pass

    def on_scroll(self, event***REMOVED***:
        ***REMOVED***Mouse scroll event handler and validator***REMOVED***
        if not self.ignore(event***REMOVED***:
            self._on_scroll(event***REMOVED***

    def _on_scroll(self, event***REMOVED***:
        ***REMOVED***Mouse scroll event handler***REMOVED***
        pass

    def on_key_press(self, event***REMOVED***:
        ***REMOVED***Key press event handler and validator for all selection widgets***REMOVED***
        if self.active:
            key = event.key or ''
            key = key.replace('ctrl', 'control'***REMOVED***
            if key == self.state_modifier_keys['clear'***REMOVED***:
                for artist in self.artists:
                    artist.set_visible(False***REMOVED***
                self.update(***REMOVED***
                return
            for (state, modifier***REMOVED*** in self.state_modifier_keys.items(***REMOVED***:
                if modifier in key:
                    self.state.add(state***REMOVED***
            self._on_key_press(event***REMOVED***

    def _on_key_press(self, event***REMOVED***:
        ***REMOVED***Key press event handler - use for widget-specific key press actions.
        ***REMOVED***
        pass

    def on_key_release(self, event***REMOVED***:
        ***REMOVED***Key release event handler and validator***REMOVED***
        if self.active:
            key = event.key or ''
            for (state, modifier***REMOVED*** in self.state_modifier_keys.items(***REMOVED***:
                if modifier in key:
                    self.state.discard(state***REMOVED***
            self._on_key_release(event***REMOVED***

    def _on_key_release(self, event***REMOVED***:
        ***REMOVED***Key release event handler***REMOVED***
        pass

    def set_visible(self, visible***REMOVED***:
        ***REMOVED*** Set the visibility of our artists ***REMOVED***
        self.visible = visible
        for artist in self.artists:
            artist.set_visible(visible***REMOVED***


class SpanSelector(_SelectorWidget***REMOVED***:
    ***REMOVED***
    Select a min/max range of the x or y axes for a matplotlib Axes.

    For the selector to remain responsive you must keep a reference to
    it.

    Example usage::

        ax = subplot(111***REMOVED***
        ax.plot(x,y***REMOVED***

        def onselect(vmin, vmax***REMOVED***:
            print(vmin, vmax***REMOVED***
        span = SpanSelector(ax, onselect, 'horizontal'***REMOVED***

    *onmove_callback* is an optional callback that is called on mouse
    move within the span range

    ***REMOVED***

    def __init__(self, ax, onselect, direction, minspan=None, useblit=False,
                 rectprops=None, onmove_callback=None, span_stays=False,
                 button=None***REMOVED***:
        ***REMOVED***
        Create a span selector in *ax*.  When a selection is made, clear
        the span and call *onselect* with::

            onselect(vmin, vmax***REMOVED***

        and clear the span.

        *direction* must be 'horizontal' or 'vertical'

        If *minspan* is not *None*, ignore events smaller than *minspan*

        The span rectangle is drawn with *rectprops*; default::

          rectprops = dict(facecolor='red', alpha=0.5***REMOVED***

        Set the visible attribute to *False* if you want to turn off
        the functionality of the span selector

        If *span_stays* is True, the span stays visble after making
        a valid selection.

        *button* is a list of integers indicating which mouse buttons should
        be used for selection.  You can also specify a single
        integer if only a single button is desired.  Default is *None*,
        which does not limit which button can be used.

        Note, typically:
         1 = left mouse button
         2 = center mouse button (scroll wheel***REMOVED***
         3 = right mouse button

        ***REMOVED***
        _SelectorWidget.__init__(self, ax, onselect, useblit=useblit,
                                 button=button***REMOVED***

        if rectprops is None:
            rectprops = dict(facecolor='red', alpha=0.5***REMOVED***

        rectprops['animated'***REMOVED*** = self.useblit

        if direction not in ['horizontal', 'vertical'***REMOVED***:
            msg = "direction must be in [ 'horizontal' | 'vertical' ***REMOVED***"
            raise ValueError(msg***REMOVED***
        self.direction = direction

        self.rect = None
        self.pressv = None

        self.rectprops = rectprops
        self.onmove_callback = onmove_callback
        self.minspan = minspan
        self.span_stays = span_stays

        # Needed when dragging out of axes
        self.prev = (0, 0***REMOVED***

        # Reset canvas so that `new_axes` connects events.
        self.canvas = None
        self.new_axes(ax***REMOVED***

    def new_axes(self, ax***REMOVED***:
        self.ax = ax
        if self.canvas is not ax.figure.canvas:
            if self.canvas is not None:
                self.disconnect_events(***REMOVED***

            self.canvas = ax.figure.canvas
            self.connect_default_events(***REMOVED***

        if self.direction == 'horizontal':
            trans = blended_transform_factory(self.ax.transData,
                                              self.ax.transAxes***REMOVED***
            w, h = 0, 1
        else:
            trans = blended_transform_factory(self.ax.transAxes,
                                              self.ax.transData***REMOVED***
            w, h = 1, 0
        self.rect = Rectangle((0, 0***REMOVED***, w, h,
                              transform=trans,
                              visible=False,
                              **self.rectprops***REMOVED***
        if self.span_stays:
            self.stay_rect = Rectangle((0, 0***REMOVED***, w, h,
                                       transform=trans,
                                       visible=False,
                                       **self.rectprops***REMOVED***
            self.stay_rect.set_animated(False***REMOVED***
            self.ax.add_patch(self.stay_rect***REMOVED***

        self.ax.add_patch(self.rect***REMOVED***
        self.artists = [self.rect***REMOVED***

    def ignore(self, event***REMOVED***:
        ***REMOVED***return *True* if *event* should be ignored***REMOVED***
        return _SelectorWidget.ignore(self, event***REMOVED*** or not self.visible

    def _press(self, event***REMOVED***:
        ***REMOVED***on button press event***REMOVED***
        self.rect.set_visible(self.visible***REMOVED***
        if self.span_stays:
            self.stay_rect.set_visible(False***REMOVED***
            # really force a draw so that the stay rect is not in
            # the blit background
            if self.useblit:
                self.canvas.draw(***REMOVED***
        xdata, ydata = self._get_data(event***REMOVED***
        if self.direction == 'horizontal':
            self.pressv = xdata
        else:
            self.pressv = ydata
        return False

    def _release(self, event***REMOVED***:
        ***REMOVED***on button release event***REMOVED***
        if self.pressv is None:
            return
        self.buttonDown = False

        self.rect.set_visible(False***REMOVED***

        if self.span_stays:
            self.stay_rect.set_x(self.rect.get_x(***REMOVED******REMOVED***
            self.stay_rect.set_y(self.rect.get_y(***REMOVED******REMOVED***
            self.stay_rect.set_width(self.rect.get_width(***REMOVED******REMOVED***
            self.stay_rect.set_height(self.rect.get_height(***REMOVED******REMOVED***
            self.stay_rect.set_visible(True***REMOVED***

        self.canvas.draw_idle(***REMOVED***
        vmin = self.pressv
        xdata, ydata = self._get_data(event***REMOVED***
        if self.direction == 'horizontal':
            vmax = xdata or self.prev[0***REMOVED***
        else:
            vmax = ydata or self.prev[1***REMOVED***

        if vmin > vmax:
            vmin, vmax = vmax, vmin
        span = vmax - vmin
        if self.minspan is not None and span < self.minspan:
            return
        self.onselect(vmin, vmax***REMOVED***
        self.pressv = None
        return False

    def _onmove(self, event***REMOVED***:
        ***REMOVED***on motion notify event***REMOVED***
        if self.pressv is None:
            return
        x, y = self._get_data(event***REMOVED***
        if x is None:
            return

        self.prev = x, y
        if self.direction == 'horizontal':
            v = x
        else:
            v = y

        minv, maxv = v, self.pressv
        if minv > maxv:
            minv, maxv = maxv, minv
        if self.direction == 'horizontal':
            self.rect.set_x(minv***REMOVED***
            self.rect.set_width(maxv - minv***REMOVED***
        else:
            self.rect.set_y(minv***REMOVED***
            self.rect.set_height(maxv - minv***REMOVED***

        if self.onmove_callback is not None:
            vmin = self.pressv
            xdata, ydata = self._get_data(event***REMOVED***
            if self.direction == 'horizontal':
                vmax = xdata or self.prev[0***REMOVED***
            else:
                vmax = ydata or self.prev[1***REMOVED***

            if vmin > vmax:
                vmin, vmax = vmax, vmin
            self.onmove_callback(vmin, vmax***REMOVED***

        self.update(***REMOVED***
        return False


class ToolHandles(object***REMOVED***:
    ***REMOVED***Control handles for canvas tools.

    Parameters
    ----------
    ax : :class:`matplotlib.axes.Axes`
        Matplotlib axes where tool handles are displayed.
    x, y : 1D arrays
        Coordinates of control handles.
    marker : str
        Shape of marker used to display handle. See `matplotlib.pyplot.plot`.
    marker_props : dict
        Additional marker properties. See :class:`matplotlib.lines.Line2D`.
    ***REMOVED***

    def __init__(self, ax, x, y, marker='o', marker_props=None, useblit=True***REMOVED***:
        self.ax = ax

        props = dict(marker=marker, markersize=7, mfc='w', ls='none',
                     alpha=0.5, visible=False, label='_nolegend_'***REMOVED***
        props.update(marker_props if marker_props is not None else {***REMOVED******REMOVED***
        self._markers = Line2D(x, y, animated=useblit, **props***REMOVED***
        self.ax.add_line(self._markers***REMOVED***
        self.artist = self._markers

    @property
    def x(self***REMOVED***:
        return self._markers.get_xdata(***REMOVED***

    @property
    def y(self***REMOVED***:
        return self._markers.get_ydata(***REMOVED***

    def set_data(self, pts, y=None***REMOVED***:
        ***REMOVED***Set x and y positions of handles***REMOVED***
        if y is not None:
            x = pts
            pts = np.array([x, y***REMOVED******REMOVED***
        self._markers.set_data(pts***REMOVED***

    def set_visible(self, val***REMOVED***:
        self._markers.set_visible(val***REMOVED***

    def set_animated(self, val***REMOVED***:
        self._markers.set_animated(val***REMOVED***

    def closest(self, x, y***REMOVED***:
        ***REMOVED***Return index and pixel distance to closest index.***REMOVED***
        pts = np.transpose((self.x, self.y***REMOVED******REMOVED***
        # Transform data coordinates to pixel coordinates.
        pts = self.ax.transData.transform(pts***REMOVED***
        diff = pts - ((x, y***REMOVED******REMOVED***
        if diff.ndim == 2:
            dist = np.sqrt(np.sum(diff ** 2, axis=1***REMOVED******REMOVED***
            return np.argmin(dist***REMOVED***, np.min(dist***REMOVED***
        else:
            return 0, np.sqrt(np.sum(diff ** 2***REMOVED******REMOVED***


class RectangleSelector(_SelectorWidget***REMOVED***:
    ***REMOVED***
    Select a rectangular region of an axes.

    For the cursor to remain responsive you must keep a reference to
    it.

    Example usage::

        from matplotlib.widgets import  RectangleSelector
        from pylab import *

        def onselect(eclick, erelease***REMOVED***:
          'eclick and erelease are matplotlib events at press and release'
          print(' startposition : (%f, %f***REMOVED***' % (eclick.xdata, eclick.ydata***REMOVED******REMOVED***
          print(' endposition   : (%f, %f***REMOVED***' % (erelease.xdata, erelease.ydata***REMOVED******REMOVED***
          print(' used button   : ', eclick.button***REMOVED***

        def toggle_selector(event***REMOVED***:
            print(' Key pressed.'***REMOVED***
            if event.key in ['Q', 'q'***REMOVED*** and toggle_selector.RS.active:
                print(' RectangleSelector deactivated.'***REMOVED***
                toggle_selector.RS.set_active(False***REMOVED***
            if event.key in ['A', 'a'***REMOVED*** and not toggle_selector.RS.active:
                print(' RectangleSelector activated.'***REMOVED***
                toggle_selector.RS.set_active(True***REMOVED***

        x = arange(100***REMOVED***/(99.0***REMOVED***
        y = sin(x***REMOVED***
        fig = figure
        ax = subplot(111***REMOVED***
        ax.plot(x,y***REMOVED***

        toggle_selector.RS = RectangleSelector(ax, onselect, drawtype='line'***REMOVED***
        connect('key_press_event', toggle_selector***REMOVED***
        show(***REMOVED***
    ***REMOVED***

    _shape_klass = Rectangle

    def __init__(self, ax, onselect, drawtype='box',
                 minspanx=None, minspany=None, useblit=False,
                 lineprops=None, rectprops=None, spancoords='data',
                 button=None, maxdist=10, marker_props=None,
                 interactive=False, state_modifier_keys=None***REMOVED***:

        ***REMOVED***
        Create a selector in *ax*.  When a selection is made, clear
        the span and call onselect with::

          onselect(pos_1, pos_2***REMOVED***

        and clear the drawn box/line. The ``pos_1`` and ``pos_2`` are
        arrays of length 2 containing the x- and y-coordinate.

        If *minspanx* is not *None* then events smaller than *minspanx*
        in x direction are ignored (it's the same for y***REMOVED***.

        The rectangle is drawn with *rectprops*; default::

          rectprops = dict(facecolor='red', edgecolor = 'black',
                           alpha=0.2, fill=True***REMOVED***

        The line is drawn with *lineprops*; default::

          lineprops = dict(color='black', linestyle='-',
                           linewidth = 2, alpha=0.5***REMOVED***

        Use *drawtype* if you want the mouse to draw a line,
        a box or nothing between click and actual position by setting

        ``drawtype = 'line'``, ``drawtype='box'`` or ``drawtype = 'none'``.

        *spancoords* is one of 'data' or 'pixels'.  If 'data', *minspanx*
        and *minspanx* will be interpreted in the same coordinates as
        the x and y axis. If 'pixels', they are in pixels.

        *button* is a list of integers indicating which mouse buttons should
        be used for rectangle selection.  You can also specify a single
        integer if only a single button is desired.  Default is *None*,
        which does not limit which button can be used.

        Note, typically:
         1 = left mouse button
         2 = center mouse button (scroll wheel***REMOVED***
         3 = right mouse button

        *interactive* will draw a set of handles and allow you interact
        with the widget after it is drawn.

        *state_modifier_keys* are keyboard modifiers that affect the behavior
        of the widget.

        The defaults are:
        dict(move=' ', clear='escape', square='shift', center='ctrl'***REMOVED***

        Keyboard modifiers, which:
        'move': Move the existing shape.
        'clear': Clear the current shape.
        'square': Makes the shape square.
        'center': Make the initial point the center of the shape.
        'square' and 'center' can be combined.
        ***REMOVED***
        _SelectorWidget.__init__(self, ax, onselect, useblit=useblit,
                                 button=button,
                                 state_modifier_keys=state_modifier_keys***REMOVED***

        self.to_draw = None
        self.visible = True
        self.interactive = interactive

        if drawtype == 'none':
            drawtype = 'line'                        # draw a line but make it
            self.visible = False                     # invisible

        if drawtype == 'box':
            if rectprops is None:
                rectprops = dict(facecolor='red', edgecolor='black',
                                 alpha=0.2, fill=True***REMOVED***
            rectprops['animated'***REMOVED*** = self.useblit
            self.rectprops = rectprops
            self.to_draw = self._shape_klass((0, 0***REMOVED***,
                                     0, 1, visible=False, **self.rectprops***REMOVED***
            self.ax.add_patch(self.to_draw***REMOVED***
        if drawtype == 'line':
            if lineprops is None:
                lineprops = dict(color='black', linestyle='-',
                                 linewidth=2, alpha=0.5***REMOVED***
            lineprops['animated'***REMOVED*** = self.useblit
            self.lineprops = lineprops
            self.to_draw = Line2D([0, 0***REMOVED***, [0, 0***REMOVED***, visible=False,
                                  **self.lineprops***REMOVED***
            self.ax.add_line(self.to_draw***REMOVED***

        self.minspanx = minspanx
        self.minspany = minspany

        if spancoords not in ('data', 'pixels'***REMOVED***:
            msg = "'spancoords' must be one of [ 'data' | 'pixels' ***REMOVED***"
            raise ValueError(msg***REMOVED***

        self.spancoords = spancoords
        self.drawtype = drawtype

        self.maxdist = maxdist

        if rectprops is None:
            props = dict(mec='r'***REMOVED***
        else:
            props = dict(mec=rectprops.get('edgecolor', 'r'***REMOVED******REMOVED***
        self._corner_order = ['NW', 'NE', 'SE', 'SW'***REMOVED***
        xc, yc = self.corners
        self._corner_handles = ToolHandles(self.ax, xc, yc, marker_props=props,
                                           useblit=self.useblit***REMOVED***

        self._edge_order = ['W', 'N', 'E', 'S'***REMOVED***
        xe, ye = self.edge_centers
        self._edge_handles = ToolHandles(self.ax, xe, ye, marker='s',
                                         marker_props=props,
                                         useblit=self.useblit***REMOVED***

        xc, yc = self.center
        self._center_handle = ToolHandles(self.ax, [xc***REMOVED***, [yc***REMOVED***, marker='s',
                                          marker_props=props,
                                          useblit=self.useblit***REMOVED***

        self.active_handle = None

        self.artists = [self.to_draw, self._center_handle.artist,
                        self._corner_handles.artist,
                        self._edge_handles.artist***REMOVED***

        if not self.interactive:
            self.artists = [self.to_draw***REMOVED***

        self._extents_on_press = None

    def _press(self, event***REMOVED***:
        ***REMOVED***on button press event***REMOVED***
        # make the drawed box/line visible get the click-coordinates,
        # button, ...
        if self.interactive and self.to_draw.get_visible(***REMOVED***:
            self._set_active_handle(event***REMOVED***
        else:
            self.active_handle = None

        if self.active_handle is None or not self.interactive:
            # Clear previous rectangle before drawing new rectangle.
            self.update(***REMOVED***

        self.set_visible(self.visible***REMOVED***

    def _release(self, event***REMOVED***:
        ***REMOVED***on button release event***REMOVED***
        if not self.interactive:
            self.to_draw.set_visible(False***REMOVED***

        # update the eventpress and eventrelease with the resulting extents
        x1, x2, y1, y2 = self.extents
        self.eventpress.xdata = x1
        self.eventpress.ydata = y1
        xy1 = self.ax.transData.transform_point([x1, y1***REMOVED******REMOVED***
        self.eventpress.x, self.eventpress.y = xy1

        self.eventrelease.xdata = x2
        self.eventrelease.ydata = y2
        xy2 = self.ax.transData.transform_point([x2, y2***REMOVED******REMOVED***
        self.eventrelease.x, self.eventrelease.y = xy2

        if self.spancoords == 'data':
            xmin, ymin = self.eventpress.xdata, self.eventpress.ydata
            xmax, ymax = self.eventrelease.xdata, self.eventrelease.ydata
            # calculate dimensions of box or line get values in the right
            # order
        elif self.spancoords == 'pixels':
            xmin, ymin = self.eventpress.x, self.eventpress.y
            xmax, ymax = self.eventrelease.x, self.eventrelease.y
        else:
            raise ValueError('spancoords must be "data" or "pixels"'***REMOVED***

        if xmin > xmax:
            xmin, xmax = xmax, xmin
        if ymin > ymax:
            ymin, ymax = ymax, ymin

        spanx = xmax - xmin
        spany = ymax - ymin
        xproblems = self.minspanx is not None and spanx < self.minspanx
        yproblems = self.minspany is not None and spany < self.minspany

        # check if drawn distance (if it exists***REMOVED*** is not too small in
        # either x or y-direction
        if self.drawtype != 'none' and (xproblems or yproblems***REMOVED***:
            for artist in self.artists:
                artist.set_visible(False***REMOVED***
            self.update(***REMOVED***
            return

        # call desired function
        self.onselect(self.eventpress, self.eventrelease***REMOVED***
        self.update(***REMOVED***

        return False

    def _onmove(self, event***REMOVED***:
        ***REMOVED***on motion notify event if box/line is wanted***REMOVED***
        # resize an existing shape
        if self.active_handle and not self.active_handle == 'C':
            x1, x2, y1, y2 = self._extents_on_press
            if self.active_handle in ['E', 'W'***REMOVED*** + self._corner_order:
                x2 = event.xdata
            if self.active_handle in ['N', 'S'***REMOVED*** + self._corner_order:
                y2 = event.ydata

        # move existing shape
        elif (('move' in self.state or self.active_handle == 'C'***REMOVED***
              and self._extents_on_press is not None***REMOVED***:
            x1, x2, y1, y2 = self._extents_on_press
            dx = event.xdata - self.eventpress.xdata
            dy = event.ydata - self.eventpress.ydata
            x1 += dx
            x2 += dx
            y1 += dy
            y2 += dy

        # new shape
        else:
            center = [self.eventpress.xdata, self.eventpress.ydata***REMOVED***
            center_pix = [self.eventpress.x, self.eventpress.y***REMOVED***
            dx = (event.xdata - center[0***REMOVED******REMOVED*** / 2.
            dy = (event.ydata - center[1***REMOVED******REMOVED*** / 2.

            # square shape
            if 'square' in self.state:
                dx_pix = abs(event.x - center_pix[0***REMOVED******REMOVED***
                dy_pix = abs(event.y - center_pix[1***REMOVED******REMOVED***
                if not dx_pix:
                    return
                maxd = max(abs(dx_pix***REMOVED***, abs(dy_pix***REMOVED******REMOVED***
                if abs(dx_pix***REMOVED*** < maxd:
                    dx *= maxd / (abs(dx_pix***REMOVED*** + 1e-6***REMOVED***
                if abs(dy_pix***REMOVED*** < maxd:
                    dy *= maxd / (abs(dy_pix***REMOVED*** + 1e-6***REMOVED***

            # from center
            if 'center' in self.state:
                dx *= 2
                dy *= 2

            # from corner
            else:
                center[0***REMOVED*** += dx
                center[1***REMOVED*** += dy

            x1, x2, y1, y2 = (center[0***REMOVED*** - dx, center[0***REMOVED*** + dx,
                              center[1***REMOVED*** - dy, center[1***REMOVED*** + dy***REMOVED***

        self.extents = x1, x2, y1, y2

    @property
    def _rect_bbox(self***REMOVED***:
        if self.drawtype == 'box':
            x0 = self.to_draw.get_x(***REMOVED***
            y0 = self.to_draw.get_y(***REMOVED***
            width = self.to_draw.get_width(***REMOVED***
            height = self.to_draw.get_height(***REMOVED***
            return x0, y0, width, height
        else:
            x, y = self.to_draw.get_data(***REMOVED***
            x0, x1 = min(x***REMOVED***, max(x***REMOVED***
            y0, y1 = min(y***REMOVED***, max(y***REMOVED***
            return x0, y0, x1 - x0, y1 - y0

    @property
    def corners(self***REMOVED***:
        ***REMOVED***Corners of rectangle from lower left, moving clockwise.***REMOVED***
        x0, y0, width, height = self._rect_bbox
        xc = x0, x0 + width, x0 + width, x0
        yc = y0, y0, y0 + height, y0 + height
        return xc, yc

    @property
    def edge_centers(self***REMOVED***:
        ***REMOVED***Midpoint of rectangle edges from left, moving clockwise.***REMOVED***
        x0, y0, width, height = self._rect_bbox
        w = width / 2.
        h = height / 2.
        xe = x0, x0 + w, x0 + width, x0 + w
        ye = y0 + h, y0, y0 + h, y0 + height
        return xe, ye

    @property
    def center(self***REMOVED***:
        ***REMOVED***Center of rectangle***REMOVED***
        x0, y0, width, height = self._rect_bbox
        return x0 + width / 2., y0 + height / 2.

    @property
    def extents(self***REMOVED***:
        ***REMOVED***Return (xmin, xmax, ymin, ymax***REMOVED***.***REMOVED***
        x0, y0, width, height = self._rect_bbox
        xmin, xmax = sorted([x0, x0 + width***REMOVED******REMOVED***
        ymin, ymax = sorted([y0, y0 + height***REMOVED******REMOVED***
        return xmin, xmax, ymin, ymax

    @extents.setter
    def extents(self, extents***REMOVED***:
        # Update displayed shape
        self.draw_shape(extents***REMOVED***
        # Update displayed handles
        self._corner_handles.set_data(*self.corners***REMOVED***
        self._edge_handles.set_data(*self.edge_centers***REMOVED***
        self._center_handle.set_data(*self.center***REMOVED***
        self.set_visible(self.visible***REMOVED***
        self.update(***REMOVED***

    def draw_shape(self, extents***REMOVED***:
        x0, x1, y0, y1 = extents
        xmin, xmax = sorted([x0, x1***REMOVED******REMOVED***
        ymin, ymax = sorted([y0, y1***REMOVED******REMOVED***
        xlim = sorted(self.ax.get_xlim(***REMOVED******REMOVED***
        ylim = sorted(self.ax.get_ylim(***REMOVED******REMOVED***

        xmin = max(xlim[0***REMOVED***, xmin***REMOVED***
        ymin = max(ylim[0***REMOVED***, ymin***REMOVED***
        xmax = min(xmax, xlim[1***REMOVED******REMOVED***
        ymax = min(ymax, ylim[1***REMOVED******REMOVED***

        if self.drawtype == 'box':
            self.to_draw.set_x(xmin***REMOVED***
            self.to_draw.set_y(ymin***REMOVED***
            self.to_draw.set_width(xmax - xmin***REMOVED***
            self.to_draw.set_height(ymax - ymin***REMOVED***

        elif self.drawtype == 'line':
            self.to_draw.set_data([xmin, xmax***REMOVED***, [ymin, ymax***REMOVED******REMOVED***

    def _set_active_handle(self, event***REMOVED***:
        ***REMOVED***Set active handle based on the location of the mouse event***REMOVED***
        # Note: event.xdata/ydata in data coordinates, event.x/y in pixels
        c_idx, c_dist = self._corner_handles.closest(event.x, event.y***REMOVED***
        e_idx, e_dist = self._edge_handles.closest(event.x, event.y***REMOVED***
        m_idx, m_dist = self._center_handle.closest(event.x, event.y***REMOVED***

        if 'move' in self.state:
            self.active_handle = 'C'
            self._extents_on_press = self.extents

        # Set active handle as closest handle, if mouse click is close enough.
        elif m_dist < self.maxdist * 2:
            self.active_handle = 'C'
        elif c_dist > self.maxdist and e_dist > self.maxdist:
            self.active_handle = None
            return
        elif c_dist < e_dist:
            self.active_handle = self._corner_order[c_idx***REMOVED***
        else:
            self.active_handle = self._edge_order[e_idx***REMOVED***

        # Save coordinates of rectangle at the start of handle movement.
        x1, x2, y1, y2 = self.extents
        # Switch variables so that only x2 and/or y2 are updated on move.
        if self.active_handle in ['W', 'SW', 'NW'***REMOVED***:
            x1, x2 = x2, event.xdata
        if self.active_handle in ['N', 'NW', 'NE'***REMOVED***:
            y1, y2 = y2, event.ydata
        self._extents_on_press = x1, x2, y1, y2

    @property
    def geometry(self***REMOVED***:
        if hasattr(self.to_draw, 'get_verts'***REMOVED***:
            xfm = self.ax.transData.inverted(***REMOVED***
            y, x = xfm.transform(self.to_draw.get_verts(***REMOVED******REMOVED***.T
            return np.array([x, y***REMOVED******REMOVED***
        else:
            return np.array(self.to_draw.get_data(***REMOVED******REMOVED***


class EllipseSelector(RectangleSelector***REMOVED***:
    ***REMOVED***
    Select an elliptical region of an axes.

    For the cursor to remain responsive you must keep a reference to
    it.

    Example usage::

        from matplotlib.widgets import  EllipseSelector
        from pylab import *

        def onselect(eclick, erelease***REMOVED***:
          'eclick and erelease are matplotlib events at press and release'
          print(' startposition : (%f, %f***REMOVED***' % (eclick.xdata, eclick.ydata***REMOVED******REMOVED***
          print(' endposition   : (%f, %f***REMOVED***' % (erelease.xdata, erelease.ydata***REMOVED******REMOVED***
          print(' used button   : ', eclick.button***REMOVED***

        def toggle_selector(event***REMOVED***:
            print(' Key pressed.'***REMOVED***
            if event.key in ['Q', 'q'***REMOVED*** and toggle_selector.ES.active:
                print(' EllipseSelector deactivated.'***REMOVED***
                toggle_selector.RS.set_active(False***REMOVED***
            if event.key in ['A', 'a'***REMOVED*** and not toggle_selector.ES.active:
                print(' EllipseSelector activated.'***REMOVED***
                toggle_selector.ES.set_active(True***REMOVED***

        x = arange(100***REMOVED***/(99.0***REMOVED***
        y = sin(x***REMOVED***
        fig = figure
        ax = subplot(111***REMOVED***
        ax.plot(x,y***REMOVED***

        toggle_selector.ES = EllipseSelector(ax, onselect, drawtype='line'***REMOVED***
        connect('key_press_event', toggle_selector***REMOVED***
        show(***REMOVED***
    ***REMOVED***
    _shape_klass = Ellipse

    def draw_shape(self, extents***REMOVED***:
        x1, x2, y1, y2 = extents
        xmin, xmax = sorted([x1, x2***REMOVED******REMOVED***
        ymin, ymax = sorted([y1, y2***REMOVED******REMOVED***
        center = [x1 + (x2 - x1***REMOVED*** / 2., y1 + (y2 - y1***REMOVED*** / 2.***REMOVED***
        a = (xmax - xmin***REMOVED*** / 2.
        b = (ymax - ymin***REMOVED*** / 2.

        if self.drawtype == 'box':
            self.to_draw.center = center
            self.to_draw.width = 2 * a
            self.to_draw.height = 2 * b
        else:
            rad = np.arange(31***REMOVED*** * 12 * np.pi / 180
            x = a * np.cos(rad***REMOVED*** + center[0***REMOVED***
            y = b * np.sin(rad***REMOVED*** + center[1***REMOVED***
            self.to_draw.set_data(x, y***REMOVED***

    @property
    def _rect_bbox(self***REMOVED***:
        if self.drawtype == 'box':
            x, y = self.to_draw.center
            width = self.to_draw.width
            height = self.to_draw.height
            return x - width / 2., y - height / 2., width, height
        else:
            x, y = self.to_draw.get_data(***REMOVED***
            x0, x1 = min(x***REMOVED***, max(x***REMOVED***
            y0, y1 = min(y***REMOVED***, max(y***REMOVED***
            return x0, y0, x1 - x0, y1 - y0


class LassoSelector(_SelectorWidget***REMOVED***:
    ***REMOVED***Selection curve of an arbitrary shape.

    For the selector to remain responsive you must keep a reference to
    it.

    The selected path can be used in conjunction with
    :func:`~matplotlib.path.Path.contains_point` to select
    data points from an image.

    In contrast to :class:`Lasso`, `LassoSelector` is written with an interface
    similar to :class:`RectangleSelector` and :class:`SpanSelector` and will
    continue to interact with the axes until disconnected.

    Parameters:

    *ax* : :class:`~matplotlib.axes.Axes`
        The parent axes for the widget.
    *onselect* : function
        Whenever the lasso is released, the `onselect` function is called and
        passed the vertices of the selected path.

    Example usage::

        ax = subplot(111***REMOVED***
        ax.plot(x,y***REMOVED***

        def onselect(verts***REMOVED***:
            print(verts***REMOVED***
        lasso = LassoSelector(ax, onselect***REMOVED***

     *button* is a list of integers indicating which mouse buttons should
        be used for rectangle selection.  You can also specify a single
        integer if only a single button is desired.  Default is *None*,
        which does not limit which button can be used.

        Note, typically:
         1 = left mouse button
         2 = center mouse button (scroll wheel***REMOVED***
         3 = right mouse button

    ***REMOVED***

    def __init__(self, ax, onselect=None, useblit=True, lineprops=None,
            button=None***REMOVED***:
        _SelectorWidget.__init__(self, ax, onselect, useblit=useblit, button=button***REMOVED***

        self.verts = None

        if lineprops is None:
            lineprops = dict(***REMOVED***
        if useblit:
            lineprops['animated'***REMOVED*** = True
        self.line = Line2D([***REMOVED***, [***REMOVED***, **lineprops***REMOVED***
        self.line.set_visible(False***REMOVED***
        self.ax.add_line(self.line***REMOVED***
        self.artists = [self.line***REMOVED***

    def onpress(self, event***REMOVED***:
        self.press(event***REMOVED***

    def _press(self, event***REMOVED***:
        self.verts = [self._get_data(event***REMOVED******REMOVED***
        self.line.set_visible(True***REMOVED***

    def onrelease(self, event***REMOVED***:
        self.release(event***REMOVED***

    def _release(self, event***REMOVED***:
        if self.verts is not None:
            self.verts.append(self._get_data(event***REMOVED******REMOVED***
            self.onselect(self.verts***REMOVED***
        self.line.set_data([[***REMOVED***, [***REMOVED******REMOVED******REMOVED***
        self.line.set_visible(False***REMOVED***
        self.verts = None

    def _onmove(self, event***REMOVED***:
        if self.verts is None:
            return
        self.verts.append(self._get_data(event***REMOVED******REMOVED***

        self.line.set_data(list(zip(*self.verts***REMOVED******REMOVED******REMOVED***

        self.update(***REMOVED***


class Lasso(AxesWidget***REMOVED***:
    ***REMOVED***Selection curve of an arbitrary shape.

    The selected path can be used in conjunction with
    :func:`~matplotlib.path.Path.contains_point` to select data points
    from an image.

    Unlike :class:`LassoSelector`, this must be initialized with a starting
    point `xy`, and the `Lasso` events are destroyed upon release.

    Parameters:

    *ax* : :class:`~matplotlib.axes.Axes`
        The parent axes for the widget.
    *xy* : array
        Coordinates of the start of the lasso.
    *callback* : function
        Whenever the lasso is released, the `callback` function is called and
        passed the vertices of the selected path.

    ***REMOVED***

    def __init__(self, ax, xy, callback=None, useblit=True***REMOVED***:
        AxesWidget.__init__(self, ax***REMOVED***

        self.useblit = useblit and self.canvas.supports_blit
        if self.useblit:
            self.background = self.canvas.copy_from_bbox(self.ax.bbox***REMOVED***

        x, y = xy
        self.verts = [(x, y***REMOVED******REMOVED***
        self.line = Line2D([x***REMOVED***, [y***REMOVED***, linestyle='-', color='black', lw=2***REMOVED***
        self.ax.add_line(self.line***REMOVED***
        self.callback = callback
        self.connect_event('button_release_event', self.onrelease***REMOVED***
        self.connect_event('motion_notify_event', self.onmove***REMOVED***

    def onrelease(self, event***REMOVED***:
        if self.ignore(event***REMOVED***:
            return
        if self.verts is not None:
            self.verts.append((event.xdata, event.ydata***REMOVED******REMOVED***
            if len(self.verts***REMOVED*** > 2:
                self.callback(self.verts***REMOVED***
            self.ax.lines.remove(self.line***REMOVED***
        self.verts = None
        self.disconnect_events(***REMOVED***

    def onmove(self, event***REMOVED***:
        if self.ignore(event***REMOVED***:
            return
        if self.verts is None:
            return
        if event.inaxes != self.ax:
            return
        if event.button != 1:
            return
        self.verts.append((event.xdata, event.ydata***REMOVED******REMOVED***

        self.line.set_data(list(zip(*self.verts***REMOVED******REMOVED******REMOVED***

        if self.useblit:
            self.canvas.restore_region(self.background***REMOVED***
            self.ax.draw_artist(self.line***REMOVED***
            self.canvas.blit(self.ax.bbox***REMOVED***
        else:
            self.canvas.draw_idle(***REMOVED***
