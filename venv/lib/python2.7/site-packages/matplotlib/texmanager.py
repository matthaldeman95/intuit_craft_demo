***REMOVED***
This module supports embedded TeX expressions in matplotlib via dvipng
and dvips for the raster and postscript backends.  The tex and
dvipng/dvips information is cached in ~/.matplotlib/tex.cache for reuse between
sessions

Requirements:

* latex
* \*Agg backends: dvipng
* PS backend: latex w/ psfrag, dvips, and Ghostscript 8.51
  (older versions do not work properly***REMOVED***

Backends:

* \*Agg
* PS
* PDF

For raster output, you can get RGBA numpy arrays from TeX expressions
as follows::

  texmanager = TexManager(***REMOVED***
  s = ('\\TeX\\ is Number '
       '$\\displaystyle\\sum_{n=1***REMOVED***^\\infty\\frac{-e^{i\pi***REMOVED******REMOVED***{2^n***REMOVED***$!'***REMOVED***
  Z = self.texmanager.get_rgba(s, size=12, dpi=80, rgb=(1,0,0***REMOVED******REMOVED***

To enable tex rendering of all text in your matplotlib figure, set
text.usetex in your matplotlibrc file or include these two lines in
your script::

  from matplotlib import rc
  rc('text', usetex=True***REMOVED***

***REMOVED***

from __future__ import (absolute_import, division, print_function,
                        unicode_literals***REMOVED***

from matplotlib.externals import six

import copy
import glob
***REMOVED***
import shutil
import sys
import warnings

from hashlib import md5

import distutils.version
import numpy as np
import matplotlib as mpl
from matplotlib import rcParams
from matplotlib._png import read_png
from matplotlib.cbook import mkdirs
from matplotlib.compat.subprocess import Popen, PIPE, STDOUT
import matplotlib.dviread as dviread
import re

DEBUG = False

if sys.platform.startswith('win'***REMOVED***:
    cmd_split = '&'
else:
    cmd_split = ';'


def dvipng_hack_alpha(***REMOVED***:
    ***REMOVED***
        p = Popen(['dvipng', '-version'***REMOVED***, stdin=PIPE, stdout=PIPE,
                  stderr=STDOUT, close_fds=(sys.platform != 'win32'***REMOVED******REMOVED***
        stdout, stderr = p.communicate(***REMOVED***
    except OSError:
        mpl.verbose.report('No dvipng was found', 'helpful'***REMOVED***
        return False
    lines = stdout.decode(sys.getdefaultencoding(***REMOVED******REMOVED***.split('\n'***REMOVED***
    for line in lines:
        if line.startswith('dvipng '***REMOVED***:
            version = line.split(***REMOVED***[-1***REMOVED***
            mpl.verbose.report('Found dvipng version %s' % version,
                               'helpful'***REMOVED***
            version = distutils.version.LooseVersion(version***REMOVED***
            return version < distutils.version.LooseVersion('1.6'***REMOVED***
    mpl.verbose.report('Unexpected response from dvipng -version', 'helpful'***REMOVED***
    return False


class TexManager(object***REMOVED***:
    ***REMOVED***
    Convert strings to dvi files using TeX, caching the results to a
    working dir
    ***REMOVED***

    oldpath = mpl.get_home(***REMOVED***
    if oldpath is None:
        oldpath = mpl.get_data_path(***REMOVED***
    oldcache = os.path.join(oldpath, '.tex.cache'***REMOVED***

    cachedir = mpl.get_cachedir(***REMOVED***
    if cachedir is not None:
        texcache = os.path.join(cachedir, 'tex.cache'***REMOVED***
    else:
        # Should only happen in a restricted environment (such as Google App
        # Engine***REMOVED***. Deal with this gracefully by not creating a cache directory.
        texcache = None

    if os.path.exists(oldcache***REMOVED***:
        if texcache is not None:
            ***REMOVED***
                shutil.move(oldcache, texcache***REMOVED***
            except IOError as e:
                warnings.warn('File could not be renamed: %s' % e***REMOVED***
            else:
                warnings.warn(***REMOVED***\
Found a TeX cache dir in the deprecated location "%s".
    Moving it to the new default location "%s".***REMOVED*** % (oldcache, texcache***REMOVED******REMOVED***
        else:
            warnings.warn(***REMOVED***\
Could not rename old TeX cache dir "%s": a suitable configuration
    directory could not be found.***REMOVED*** % oldcache***REMOVED***

    if texcache is not None:
        mkdirs(texcache***REMOVED***

    _dvipng_hack_alpha = None
    #_dvipng_hack_alpha = dvipng_hack_alpha(***REMOVED***
    # mappable cache of
    rgba_arrayd = {***REMOVED***
    grey_arrayd = {***REMOVED***
    postscriptd = {***REMOVED***
    pscnt = 0

    serif = ('cmr', ''***REMOVED***
    sans_serif = ('cmss', ''***REMOVED***
    monospace = ('cmtt', ''***REMOVED***
    cursive = ('pzc', '\\usepackage{chancery***REMOVED***'***REMOVED***
    font_family = 'serif'
    font_families = ('serif', 'sans-serif', 'cursive', 'monospace'***REMOVED***

    font_info = {'new century schoolbook': ('pnc',
                                            r'\renewcommand{\rmdefault***REMOVED***{pnc***REMOVED***'***REMOVED***,
                 'bookman': ('pbk', r'\renewcommand{\rmdefault***REMOVED***{pbk***REMOVED***'***REMOVED***,
                 'times': ('ptm', '\\usepackage{mathptmx***REMOVED***'***REMOVED***,
                 'palatino': ('ppl', '\\usepackage{mathpazo***REMOVED***'***REMOVED***,
                 'zapf chancery': ('pzc', '\\usepackage{chancery***REMOVED***'***REMOVED***,
                 'cursive': ('pzc', '\\usepackage{chancery***REMOVED***'***REMOVED***,
                 'charter': ('pch', '\\usepackage{charter***REMOVED***'***REMOVED***,
                 'serif': ('cmr', ''***REMOVED***,
                 'sans-serif': ('cmss', ''***REMOVED***,
                 'helvetica': ('phv', '\\usepackage{helvet***REMOVED***'***REMOVED***,
                 'avant garde': ('pag', '\\usepackage{avant***REMOVED***'***REMOVED***,
                 'courier': ('pcr', '\\usepackage{courier***REMOVED***'***REMOVED***,
                 'monospace': ('cmtt', ''***REMOVED***,
                 'computer modern roman': ('cmr', ''***REMOVED***,
                 'computer modern sans serif': ('cmss', ''***REMOVED***,
                 'computer modern typewriter': ('cmtt', ''***REMOVED******REMOVED***

    _rc_cache = None
    _rc_cache_keys = (('text.latex.preamble', ***REMOVED*** +
                      tuple(['font.' + n for n in ('family', ***REMOVED*** +
                             font_families***REMOVED******REMOVED******REMOVED***

    def __init__(self***REMOVED***:

        if self.texcache is None:
            raise RuntimeError(
                ('Cannot create TexManager, as there is no cache directory '
                 'available'***REMOVED******REMOVED***

        mkdirs(self.texcache***REMOVED***
        ff = rcParams['font.family'***REMOVED***
        if len(ff***REMOVED*** == 1 and ff[0***REMOVED***.lower(***REMOVED*** in self.font_families:
            self.font_family = ff[0***REMOVED***.lower(***REMOVED***
        elif isinstance(ff, six.string_types***REMOVED*** and ff.lower(***REMOVED*** in self.font_families:
            self.font_family = ff.lower(***REMOVED***
        else:
            mpl.verbose.report(
                'font.family must be one of (%s***REMOVED*** when text.usetex is True. '
                'serif will be used by default.' %
                   ', '.join(self.font_families***REMOVED***,
                'helpful'***REMOVED***
            self.font_family = 'serif'

        fontconfig = [self.font_family***REMOVED***
        for font_family, font_family_attr in [(ff, ff.replace('-', '_'***REMOVED******REMOVED***
                                              for ff in self.font_families***REMOVED***:
            for font in rcParams['font.' + font_family***REMOVED***:
                if font.lower(***REMOVED*** in self.font_info:
                    setattr(self, font_family_attr,
                            self.font_info[font.lower(***REMOVED******REMOVED******REMOVED***
                    if DEBUG:
                        print('family: %s, font: %s, info: %s' %
                              (font_family, font,
                               self.font_info[font.lower(***REMOVED******REMOVED******REMOVED******REMOVED***
                    break
                else:
                    if DEBUG:
                        print('$s font is not compatible with usetex'***REMOVED***
            else:
                mpl.verbose.report('No LaTeX-compatible font found for the '
                                   '%s font family in rcParams. Using '
                                   'default.' % ff, 'helpful'***REMOVED***
                setattr(self, font_family_attr, self.font_info[font_family***REMOVED******REMOVED***
            fontconfig.append(getattr(self, font_family_attr***REMOVED***[0***REMOVED******REMOVED***
        # Add a hash of the latex preamble to self._fontconfig so that the
        # correct png is selected for strings rendered with same font and dpi
        # even if the latex preamble changes within the session
        preamble_bytes = six.text_type(self.get_custom_preamble(***REMOVED******REMOVED***.encode('utf-8'***REMOVED***
        fontconfig.append(md5(preamble_bytes***REMOVED***.hexdigest(***REMOVED******REMOVED***
        self._fontconfig = ''.join(fontconfig***REMOVED***

        # The following packages and commands need to be included in the latex
        # file's preamble:
        cmd = [self.serif[1***REMOVED***, self.sans_serif[1***REMOVED***, self.monospace[1***REMOVED******REMOVED***
        if self.font_family == 'cursive':
            cmd.append(self.cursive[1***REMOVED******REMOVED***
        while '\\usepackage{type1cm***REMOVED***' in cmd:
            cmd.remove('\\usepackage{type1cm***REMOVED***'***REMOVED***
        cmd = '\n'.join(cmd***REMOVED***
        self._font_preamble = '\n'.join(['\\usepackage{type1cm***REMOVED***', cmd,
                                         '\\usepackage{textcomp***REMOVED***'***REMOVED******REMOVED***

    def get_basefile(self, tex, fontsize, dpi=None***REMOVED***:
        ***REMOVED***
        returns a filename based on a hash of the string, fontsize, and dpi
        ***REMOVED***
        s = ''.join([tex, self.get_font_config(***REMOVED***, '%f' % fontsize,
                     self.get_custom_preamble(***REMOVED***, str(dpi or ''***REMOVED******REMOVED******REMOVED***
        # make sure hash is consistent for all strings, regardless of encoding:
        bytes = six.text_type(s***REMOVED***.encode('utf-8'***REMOVED***
        return os.path.join(self.texcache, md5(bytes***REMOVED***.hexdigest(***REMOVED******REMOVED***

    def get_font_config(self***REMOVED***:
        ***REMOVED***Reinitializes self if relevant rcParams on have changed.***REMOVED***
        if self._rc_cache is None:
            self._rc_cache = dict([(k, None***REMOVED*** for k in self._rc_cache_keys***REMOVED******REMOVED***
        changed = [par for par in self._rc_cache_keys
                   if rcParams[par***REMOVED*** != self._rc_cache[par***REMOVED******REMOVED***
        if changed:
            if DEBUG:
                print('DEBUG following keys changed:', changed***REMOVED***
            for k in changed:
                if DEBUG:
                    print('DEBUG %-20s: %-10s -> %-10s' %
                          (k, self._rc_cache[k***REMOVED***, rcParams[k***REMOVED******REMOVED******REMOVED***
                # deepcopy may not be necessary, but feels more future-proof
                self._rc_cache[k***REMOVED*** = copy.deepcopy(rcParams[k***REMOVED******REMOVED***
            if DEBUG:
                print('DEBUG RE-INIT\nold fontconfig:', self._fontconfig***REMOVED***
            self.__init__(***REMOVED***
        if DEBUG:
            print('DEBUG fontconfig:', self._fontconfig***REMOVED***
        return self._fontconfig

    def get_font_preamble(self***REMOVED***:
        ***REMOVED***
        returns a string containing font configuration for the tex preamble
        ***REMOVED***
        return self._font_preamble

    def get_custom_preamble(self***REMOVED***:
        ***REMOVED***returns a string containing user additions to the tex preamble***REMOVED***
        return '\n'.join(rcParams['text.latex.preamble'***REMOVED******REMOVED***

    def _get_shell_cmd(self, *args***REMOVED***:
        ***REMOVED***
        On windows, changing directories can be complicated by the presence of
        multiple drives. get_shell_cmd deals with this issue.
        ***REMOVED***
        if sys.platform == 'win32':
            command = ['%s' % os.path.splitdrive(self.texcache***REMOVED***[0***REMOVED******REMOVED***
        else:
            command = [***REMOVED***
        command.extend(args***REMOVED***
        return ' && '.join(command***REMOVED***

    def make_tex(self, tex, fontsize***REMOVED***:
        ***REMOVED***
        Generate a tex file to render the tex string at a specific font size

        returns the file name
        ***REMOVED***
        basefile = self.get_basefile(tex, fontsize***REMOVED***
        texfile = '%s.tex' % basefile
        custom_preamble = self.get_custom_preamble(***REMOVED***
        fontcmd = {'sans-serif': r'{\sffamily %s***REMOVED***',
                   'monospace': r'{\ttfamily %s***REMOVED***'***REMOVED***.get(self.font_family,
                                                       r'{\rmfamily %s***REMOVED***'***REMOVED***
        tex = fontcmd % tex

        if rcParams['text.latex.unicode'***REMOVED***:
            unicode_preamble = ***REMOVED***\\usepackage{ucs***REMOVED***
\\usepackage[utf8x***REMOVED***{inputenc***REMOVED******REMOVED***
        else:
            unicode_preamble = ''

        s = ***REMOVED***\\documentclass{article***REMOVED***
%s
%s
%s
\\usepackage[papersize={72in,72in***REMOVED***,body={70in,70in***REMOVED***,margin={1in,1in***REMOVED******REMOVED***{geometry***REMOVED***
\\pagestyle{empty***REMOVED***
\\begin{document***REMOVED***
\\fontsize{%f***REMOVED***{%f***REMOVED***%s
\\end{document***REMOVED***
***REMOVED*** % (self._font_preamble, unicode_preamble, custom_preamble,
       fontsize, fontsize * 1.25, tex***REMOVED***
        with open(texfile, 'wb'***REMOVED*** as fh:
            if rcParams['text.latex.unicode'***REMOVED***:
                fh.write(s.encode('utf8'***REMOVED******REMOVED***
            else:
                ***REMOVED***
                    fh.write(s.encode('ascii'***REMOVED******REMOVED***
                except UnicodeEncodeError as err:
                    mpl.verbose.report("You are using unicode and latex, but "
                                       "have not enabled the matplotlib "
                                       "'text.latex.unicode' rcParam.",
                                       'helpful'***REMOVED***
                    raise

        return texfile

    _re_vbox = re.compile(
        r"MatplotlibBox:\(([\d.***REMOVED***+***REMOVED***pt\+([\d.***REMOVED***+***REMOVED***pt\***REMOVED***x([\d.***REMOVED***+***REMOVED***pt"***REMOVED***

    def make_tex_preview(self, tex, fontsize***REMOVED***:
        ***REMOVED***
        Generate a tex file to render the tex string at a specific
        font size.  It uses the preview.sty to determin the dimension
        (width, height, descent***REMOVED*** of the output.

        returns the file name
        ***REMOVED***
        basefile = self.get_basefile(tex, fontsize***REMOVED***
        texfile = '%s.tex' % basefile
        custom_preamble = self.get_custom_preamble(***REMOVED***
        fontcmd = {'sans-serif': r'{\sffamily %s***REMOVED***',
                   'monospace': r'{\ttfamily %s***REMOVED***'***REMOVED***.get(self.font_family,
                                                       r'{\rmfamily %s***REMOVED***'***REMOVED***
        tex = fontcmd % tex

        if rcParams['text.latex.unicode'***REMOVED***:
            unicode_preamble = ***REMOVED***\\usepackage{ucs***REMOVED***
\\usepackage[utf8x***REMOVED***{inputenc***REMOVED******REMOVED***
        else:
            unicode_preamble = ''

        # newbox, setbox, immediate, etc. are used to find the box
        # extent of the rendered text.

        s = ***REMOVED***\\documentclass{article***REMOVED***
%s
%s
%s
\\usepackage[active,showbox,tightpage***REMOVED***{preview***REMOVED***
\\usepackage[papersize={72in,72in***REMOVED***,body={70in,70in***REMOVED***,margin={1in,1in***REMOVED******REMOVED***{geometry***REMOVED***

%% we override the default showbox as it is treated as an error and makes
%% the exit status not zero
\\def\\showbox#1{\\immediate\\write16{MatplotlibBox:(\\the\\ht#1+\\the\\dp#1***REMOVED***x\\the\\wd#1***REMOVED******REMOVED***

\\begin{document***REMOVED***
\\begin{preview***REMOVED***
{\\fontsize{%f***REMOVED***{%f***REMOVED***%s***REMOVED***
\\end{preview***REMOVED***
\\end{document***REMOVED***
***REMOVED*** % (self._font_preamble, unicode_preamble, custom_preamble,
       fontsize, fontsize * 1.25, tex***REMOVED***
        with open(texfile, 'wb'***REMOVED*** as fh:
            if rcParams['text.latex.unicode'***REMOVED***:
                fh.write(s.encode('utf8'***REMOVED******REMOVED***
            else:
                ***REMOVED***
                    fh.write(s.encode('ascii'***REMOVED******REMOVED***
                except UnicodeEncodeError as err:
                    mpl.verbose.report("You are using unicode and latex, but "
                                       "have not enabled the matplotlib "
                                       "'text.latex.unicode' rcParam.",
                                       'helpful'***REMOVED***
                    raise

        return texfile

    def make_dvi(self, tex, fontsize***REMOVED***:
        ***REMOVED***
        generates a dvi file containing latex's layout of tex string

        returns the file name
        ***REMOVED***

        if rcParams['text.latex.preview'***REMOVED***:
            return self.make_dvi_preview(tex, fontsize***REMOVED***

        basefile = self.get_basefile(tex, fontsize***REMOVED***
        dvifile = '%s.dvi' % basefile

        if DEBUG or not os.path.exists(dvifile***REMOVED***:
            texfile = self.make_tex(tex, fontsize***REMOVED***
            outfile = basefile + '.output'
            command = self._get_shell_cmd(
                'cd "%s"' % self.texcache,
                'latex -interaction=nonstopmode %s > "%s"' %
                (os.path.split(texfile***REMOVED***[-1***REMOVED***, outfile***REMOVED******REMOVED***
            mpl.verbose.report(command, 'debug'***REMOVED***
            exit_status = os.system(command***REMOVED***
            ***REMOVED***
                with open(outfile***REMOVED*** as fh:
                    report = fh.read(***REMOVED***
            except IOError:
                report = 'No latex error report available.'
            ***REMOVED***
                os.stat(dvifile***REMOVED***
                exists = True
            except OSError:
                exists = False
            if exit_status or not exists:
                raise RuntimeError(
                    ('LaTeX was not able to process the following '
                     'string:\n%s\nHere is the full report generated by '
                     'LaTeX: \n\n' % repr(tex.encode('unicode_escape'***REMOVED******REMOVED*** +
                     report***REMOVED******REMOVED***
            else:
                mpl.verbose.report(report, 'debug'***REMOVED***
            for fname in glob.glob(basefile + '*'***REMOVED***:
                if fname.endswith('dvi'***REMOVED***:
                    pass
                elif fname.endswith('tex'***REMOVED***:
                    pass
                else:
                    ***REMOVED***
                        os.remove(fname***REMOVED***
                    except OSError:
                        pass

        return dvifile

    def make_dvi_preview(self, tex, fontsize***REMOVED***:
        ***REMOVED***
        generates a dvi file containing latex's layout of tex
        string. It calls make_tex_preview(***REMOVED*** method and store the size
        information (width, height, descent***REMOVED*** in a separte file.

        returns the file name
        ***REMOVED***
        basefile = self.get_basefile(tex, fontsize***REMOVED***
        dvifile = '%s.dvi' % basefile
        baselinefile = '%s.baseline' % basefile

        if (DEBUG or not os.path.exists(dvifile***REMOVED*** or
                not os.path.exists(baselinefile***REMOVED******REMOVED***:
            texfile = self.make_tex_preview(tex, fontsize***REMOVED***
            outfile = basefile + '.output'
            command = self._get_shell_cmd(
                'cd "%s"' % self.texcache,
                'latex -interaction=nonstopmode %s > "%s"' %
                (os.path.split(texfile***REMOVED***[-1***REMOVED***, outfile***REMOVED******REMOVED***
            mpl.verbose.report(command, 'debug'***REMOVED***
            exit_status = os.system(command***REMOVED***
            ***REMOVED***
                with open(outfile***REMOVED*** as fh:
                    report = fh.read(***REMOVED***

            except IOError:
                report = 'No latex error report available.'
            if exit_status:
                raise RuntimeError(
                    ('LaTeX was not able to process the following '
                     'string:\n%s\nHere is the full report generated by '
                     'LaTeX: \n\n' % repr(tex***REMOVED******REMOVED*** + report***REMOVED***
            else:
                mpl.verbose.report(report, 'debug'***REMOVED***

            # find the box extent information in the latex output
            # file and store them in ".baseline" file
            m = TexManager._re_vbox.search(report***REMOVED***
            with open(basefile + '.baseline', "w"***REMOVED*** as fh:
                fh.write(" ".join(m.groups(***REMOVED******REMOVED******REMOVED***

            for fname in glob.glob(basefile + '*'***REMOVED***:
                if fname.endswith('dvi'***REMOVED***:
                    pass
                elif fname.endswith('tex'***REMOVED***:
                    pass
                elif fname.endswith('baseline'***REMOVED***:
                    pass
                else:
                    ***REMOVED***
                        os.remove(fname***REMOVED***
                    except OSError:
                        pass

        return dvifile

    def make_png(self, tex, fontsize, dpi***REMOVED***:
        ***REMOVED***
        generates a png file containing latex's rendering of tex string

        returns the filename
        ***REMOVED***
        basefile = self.get_basefile(tex, fontsize, dpi***REMOVED***
        pngfile = '%s.png' % basefile

        # see get_rgba for a discussion of the background
        if DEBUG or not os.path.exists(pngfile***REMOVED***:
            dvifile = self.make_dvi(tex, fontsize***REMOVED***
            outfile = basefile + '.output'
            command = self._get_shell_cmd(
                'cd "%s"' % self.texcache,
                'dvipng -bg Transparent -D %s -T tight -o "%s" "%s" > "%s"' %
                (dpi, os.path.split(pngfile***REMOVED***[-1***REMOVED***,
                os.path.split(dvifile***REMOVED***[-1***REMOVED***, outfile***REMOVED******REMOVED***
            mpl.verbose.report(command, 'debug'***REMOVED***
            exit_status = os.system(command***REMOVED***
            ***REMOVED***
                with open(outfile***REMOVED*** as fh:
                    report = fh.read(***REMOVED***
            except IOError:
                report = 'No dvipng error report available.'
            if exit_status:
                raise RuntimeError(
                    'dvipng was not able to process the following '
                    'file:\n%s\nHere is the full report generated by '
                    'dvipng: \n\n' % dvifile + report***REMOVED***
            else:
                mpl.verbose.report(report, 'debug'***REMOVED***
            ***REMOVED***
                os.remove(outfile***REMOVED***
            except OSError:
                pass

        return pngfile

    def make_ps(self, tex, fontsize***REMOVED***:
        ***REMOVED***
        generates a postscript file containing latex's rendering of tex string

        returns the file name
        ***REMOVED***
        basefile = self.get_basefile(tex, fontsize***REMOVED***
        psfile = '%s.epsf' % basefile

        if DEBUG or not os.path.exists(psfile***REMOVED***:
            dvifile = self.make_dvi(tex, fontsize***REMOVED***
            outfile = basefile + '.output'
            command = self._get_shell_cmd(
                'cd "%s"' % self.texcache,
                'dvips -q -E -o "%s" "%s" > "%s"' %
                (os.path.split(psfile***REMOVED***[-1***REMOVED***,
                 os.path.split(dvifile***REMOVED***[-1***REMOVED***, outfile***REMOVED******REMOVED***
            mpl.verbose.report(command, 'debug'***REMOVED***
            exit_status = os.system(command***REMOVED***
            with open(outfile***REMOVED*** as fh:
                if exit_status:
                    raise RuntimeError(
                        'dvipng was not able to process the flowing '
                        'file:\n%s\nHere is the full report generated by '
                        'dvipng: \n\n' % dvifile + fh.read(***REMOVED******REMOVED***
                else:
                    mpl.verbose.report(fh.read(***REMOVED***, 'debug'***REMOVED***
            os.remove(outfile***REMOVED***

        return psfile

    def get_ps_bbox(self, tex, fontsize***REMOVED***:
        ***REMOVED***
        returns a list containing the postscript bounding box for latex's
        rendering of the tex string
        ***REMOVED***
        psfile = self.make_ps(tex, fontsize***REMOVED***
        with open(psfile***REMOVED*** as ps:
            for line in ps:
                if line.startswith('%%BoundingBox:'***REMOVED***:
                    return [int(val***REMOVED*** for val in line.split(***REMOVED***[1:***REMOVED******REMOVED***
        raise RuntimeError('Could not parse %s' % psfile***REMOVED***

    def get_grey(self, tex, fontsize=None, dpi=None***REMOVED***:
        ***REMOVED***returns the alpha channel***REMOVED***
        key = tex, self.get_font_config(***REMOVED***, fontsize, dpi
        alpha = self.grey_arrayd.get(key***REMOVED***

        if alpha is None:
            pngfile = self.make_png(tex, fontsize, dpi***REMOVED***
            X = read_png(os.path.join(self.texcache, pngfile***REMOVED******REMOVED***

            if rcParams['text.dvipnghack'***REMOVED*** is not None:
                hack = rcParams['text.dvipnghack'***REMOVED***
            else:
                if TexManager._dvipng_hack_alpha is None:
                    TexManager._dvipng_hack_alpha = dvipng_hack_alpha(***REMOVED***
                hack = TexManager._dvipng_hack_alpha

            if hack:
                # hack the alpha channel
                # dvipng assumed a constant background, whereas we want to
                # overlay these rasters with antialiasing over arbitrary
                # backgrounds that may have other figure elements under them.
                # When you set dvipng -bg Transparent, it actually makes the
                # alpha channel 1 and does the background compositing and
                # antialiasing itself and puts the blended data in the rgb
                # channels.  So what we do is extract the alpha information
                # from the red channel, which is a blend of the default dvipng
                # background (white***REMOVED*** and foreground (black***REMOVED***.  So the amount of
                # red (or green or blue for that matter since white and black
                # blend to a grayscale***REMOVED*** is the alpha intensity.  Once we
                # extract the correct alpha information, we assign it to the
                # alpha channel properly and let the users pick their rgb.  In
                # this way, we can overlay tex strings on arbitrary
                # backgrounds with antialiasing
                #
                # red = alpha*red_foreground + (1-alpha***REMOVED****red_background
                #
                # Since the foreground is black (0***REMOVED*** and the background is
                # white (1***REMOVED*** this reduces to red = 1-alpha or alpha = 1-red
                #alpha = npy.sqrt(1-X[:,:,0***REMOVED******REMOVED*** # should this be sqrt here?
                alpha = 1 - X[:, :, 0***REMOVED***
            else:
                alpha = X[:, :, -1***REMOVED***

            self.grey_arrayd[key***REMOVED*** = alpha
        return alpha

    def get_rgba(self, tex, fontsize=None, dpi=None, rgb=(0, 0, 0***REMOVED******REMOVED***:
        ***REMOVED***
        Returns latex's rendering of the tex string as an rgba array
        ***REMOVED***
        if not fontsize:
            fontsize = rcParams['font.size'***REMOVED***
        if not dpi:
            dpi = rcParams['savefig.dpi'***REMOVED***
        r, g, b = rgb
        key = tex, self.get_font_config(***REMOVED***, fontsize, dpi, tuple(rgb***REMOVED***
        Z = self.rgba_arrayd.get(key***REMOVED***

        if Z is None:
            alpha = self.get_grey(tex, fontsize, dpi***REMOVED***

            Z = np.zeros((alpha.shape[0***REMOVED***, alpha.shape[1***REMOVED***, 4***REMOVED***, np.float***REMOVED***

            Z[:, :, 0***REMOVED*** = r
            Z[:, :, 1***REMOVED*** = g
            Z[:, :, 2***REMOVED*** = b
            Z[:, :, 3***REMOVED*** = alpha
            self.rgba_arrayd[key***REMOVED*** = Z

        return Z

    def get_text_width_height_descent(self, tex, fontsize, renderer=None***REMOVED***:
        ***REMOVED***
        return width, heigth and descent of the text.
        ***REMOVED***
        if tex.strip(***REMOVED*** == '':
            return 0, 0, 0

        if renderer:
            dpi_fraction = renderer.points_to_pixels(1.***REMOVED***
        else:
            dpi_fraction = 1.

        if rcParams['text.latex.preview'***REMOVED***:
            # use preview.sty
            basefile = self.get_basefile(tex, fontsize***REMOVED***
            baselinefile = '%s.baseline' % basefile

            if DEBUG or not os.path.exists(baselinefile***REMOVED***:
                dvifile = self.make_dvi_preview(tex, fontsize***REMOVED***

            with open(baselinefile***REMOVED*** as fh:
                l = fh.read(***REMOVED***.split(***REMOVED***
            height, depth, width = [float(l1***REMOVED*** * dpi_fraction for l1 in l***REMOVED***
            return width, height + depth, depth

        else:
            # use dviread. It sometimes returns a wrong descent.
            dvifile = self.make_dvi(tex, fontsize***REMOVED***
            dvi = dviread.Dvi(dvifile, 72 * dpi_fraction***REMOVED***
            ***REMOVED***
                page = next(iter(dvi***REMOVED******REMOVED***
            finally:
                dvi.close(***REMOVED***
            # A total height (including the descent***REMOVED*** needs to be returned.
            return page.width, page.height + page.descent, page.descent
