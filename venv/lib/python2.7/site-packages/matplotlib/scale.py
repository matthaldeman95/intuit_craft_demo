from __future__ import (absolute_import, division, print_function,
                        unicode_literals***REMOVED***

from matplotlib.externals import six

import numpy as np
from numpy import ma

from matplotlib.cbook import dedent
from matplotlib.ticker import (NullFormatter, ScalarFormatter,
                               LogFormatterMathtext, LogitFormatter***REMOVED***
from matplotlib.ticker import (NullLocator, LogLocator, AutoLocator,
                               SymmetricalLogLocator, LogitLocator***REMOVED***
from matplotlib.transforms import Transform, IdentityTransform
from matplotlib import docstring


class ScaleBase(object***REMOVED***:
    ***REMOVED***
    The base class for all scales.

    Scales are separable transformations, working on a single dimension.

    Any subclasses will want to override:

      - :attr:`name`
      - :meth:`get_transform`
      - :meth:`set_default_locators_and_formatters`

    And optionally:
      - :meth:`limit_range_for_scale`
    ***REMOVED***
    def get_transform(self***REMOVED***:
        ***REMOVED***
        Return the :class:`~matplotlib.transforms.Transform` object
        associated with this scale.
        ***REMOVED***
        raise NotImplementedError(***REMOVED***

    def set_default_locators_and_formatters(self, axis***REMOVED***:
        ***REMOVED***
        Set the :class:`~matplotlib.ticker.Locator` and
        :class:`~matplotlib.ticker.Formatter` objects on the given
        axis to match this scale.
        ***REMOVED***
        raise NotImplementedError(***REMOVED***

    def limit_range_for_scale(self, vmin, vmax, minpos***REMOVED***:
        ***REMOVED***
        Returns the range *vmin*, *vmax*, possibly limited to the
        domain supported by this scale.

        *minpos* should be the minimum positive value in the data.
         This is used by log scales to determine a minimum value.
        ***REMOVED***
        return vmin, vmax


class LinearScale(ScaleBase***REMOVED***:
    ***REMOVED***
    The default linear scale.
    ***REMOVED***

    name = 'linear'

    def __init__(self, axis, **kwargs***REMOVED***:
        pass

    def set_default_locators_and_formatters(self, axis***REMOVED***:
        ***REMOVED***
        Set the locators and formatters to reasonable defaults for
        linear scaling.
        ***REMOVED***
        axis.set_major_locator(AutoLocator(***REMOVED******REMOVED***
        axis.set_major_formatter(ScalarFormatter(***REMOVED******REMOVED***
        axis.set_minor_locator(NullLocator(***REMOVED******REMOVED***
        axis.set_minor_formatter(NullFormatter(***REMOVED******REMOVED***

    def get_transform(self***REMOVED***:
        ***REMOVED***
        The transform for linear scaling is just the
        :class:`~matplotlib.transforms.IdentityTransform`.
        ***REMOVED***
        return IdentityTransform(***REMOVED***


def _mask_non_positives(a***REMOVED***:
    ***REMOVED***
    Return a Numpy array where all non-positive values are
    replaced with NaNs. If there are no non-positive values, the
    original array is returned.
    ***REMOVED***
    mask = a <= 0.0
    if mask.any(***REMOVED***:
        return np.where(mask, np.nan, a***REMOVED***
    return a


def _clip_non_positives(a***REMOVED***:
    a = np.array(a, float***REMOVED***
    a[a <= 0.0***REMOVED*** = 1e-300
    return a


class LogTransformBase(Transform***REMOVED***:
    input_dims = 1
    output_dims = 1
    is_separable = True
    has_inverse = True

    def __init__(self, nonpos***REMOVED***:
        Transform.__init__(self***REMOVED***
        if nonpos == 'mask':
            self._handle_nonpos = _mask_non_positives
        else:
            self._handle_nonpos = _clip_non_positives


class Log10Transform(LogTransformBase***REMOVED***:
    base = 10.0

    def transform_non_affine(self, a***REMOVED***:
        a = self._handle_nonpos(a * 10.0***REMOVED***
        return np.log10(a***REMOVED***

    def inverted(self***REMOVED***:
        return InvertedLog10Transform(***REMOVED***


class InvertedLog10Transform(Transform***REMOVED***:
    input_dims = 1
    output_dims = 1
    is_separable = True
    has_inverse = True
    base = 10.0

    def transform_non_affine(self, a***REMOVED***:
        return ma.power(10.0, a***REMOVED*** / 10.0

    def inverted(self***REMOVED***:
        return Log10Transform(***REMOVED***


class Log2Transform(LogTransformBase***REMOVED***:
    base = 2.0

    def transform_non_affine(self, a***REMOVED***:
        a = self._handle_nonpos(a * 2.0***REMOVED***
        return np.log2(a***REMOVED***

    def inverted(self***REMOVED***:
        return InvertedLog2Transform(***REMOVED***


class InvertedLog2Transform(Transform***REMOVED***:
    input_dims = 1
    output_dims = 1
    is_separable = True
    has_inverse = True
    base = 2.0

    def transform_non_affine(self, a***REMOVED***:
        return ma.power(2.0, a***REMOVED*** / 2.0

    def inverted(self***REMOVED***:
        return Log2Transform(***REMOVED***


class NaturalLogTransform(LogTransformBase***REMOVED***:
    base = np.e

    def transform_non_affine(self, a***REMOVED***:
        a = self._handle_nonpos(a * np.e***REMOVED***
        return np.log(a***REMOVED***

    def inverted(self***REMOVED***:
        return InvertedNaturalLogTransform(***REMOVED***


class InvertedNaturalLogTransform(Transform***REMOVED***:
    input_dims = 1
    output_dims = 1
    is_separable = True
    has_inverse = True
    base = np.e

    def transform_non_affine(self, a***REMOVED***:
        return ma.power(np.e, a***REMOVED*** / np.e

    def inverted(self***REMOVED***:
        return NaturalLogTransform(***REMOVED***


class LogTransform(Transform***REMOVED***:
    input_dims = 1
    output_dims = 1
    is_separable = True
    has_inverse = True

    def __init__(self, base, nonpos***REMOVED***:
        Transform.__init__(self***REMOVED***
        self.base = base
        if nonpos == 'mask':
            self._handle_nonpos = _mask_non_positives
        else:
            self._handle_nonpos = _clip_non_positives

    def transform_non_affine(self, a***REMOVED***:
        a = self._handle_nonpos(a * self.base***REMOVED***
        return np.log(a***REMOVED*** / np.log(self.base***REMOVED***

    def inverted(self***REMOVED***:
        return InvertedLogTransform(self.base***REMOVED***


class InvertedLogTransform(Transform***REMOVED***:
    input_dims = 1
    output_dims = 1
    is_separable = True
    has_inverse = True

    def __init__(self, base***REMOVED***:
        Transform.__init__(self***REMOVED***
        self.base = base

    def transform_non_affine(self, a***REMOVED***:
        return ma.power(self.base, a***REMOVED*** / self.base

    def inverted(self***REMOVED***:
        return LogTransform(self.base***REMOVED***


class LogScale(ScaleBase***REMOVED***:
    ***REMOVED***
    A standard logarithmic scale.  Care is taken so non-positive
    values are not plotted.

    For computational efficiency (to push as much as possible to Numpy
    C code in the common cases***REMOVED***, this scale provides different
    transforms depending on the base of the logarithm:

       - base 10 (:class:`Log10Transform`***REMOVED***
       - base 2 (:class:`Log2Transform`***REMOVED***
       - base e (:class:`NaturalLogTransform`***REMOVED***
       - arbitrary base (:class:`LogTransform`***REMOVED***
    ***REMOVED***
    name = 'log'

    # compatibility shim
    LogTransformBase = LogTransformBase
    Log10Transform = Log10Transform
    InvertedLog10Transform = InvertedLog10Transform
    Log2Transform = Log2Transform
    InvertedLog2Transform = InvertedLog2Transform
    NaturalLogTransform = NaturalLogTransform
    InvertedNaturalLogTransform = InvertedNaturalLogTransform
    LogTransform = LogTransform
    InvertedLogTransform = InvertedLogTransform

    def __init__(self, axis, **kwargs***REMOVED***:
        ***REMOVED***
        *basex*/*basey*:
           The base of the logarithm

        *nonposx*/*nonposy*: ['mask' | 'clip' ***REMOVED***
          non-positive values in *x* or *y* can be masked as
          invalid, or clipped to a very small positive number

        *subsx*/*subsy*:
           Where to place the subticks between each major tick.
           Should be a sequence of integers.  For example, in a log10
           scale: ``[2, 3, 4, 5, 6, 7, 8, 9***REMOVED***``

           will place 8 logarithmically spaced minor ticks between
           each major tick.
        ***REMOVED***
        if axis.axis_name == 'x':
            base = kwargs.pop('basex', 10.0***REMOVED***
            subs = kwargs.pop('subsx', None***REMOVED***
            nonpos = kwargs.pop('nonposx', 'mask'***REMOVED***
        else:
            base = kwargs.pop('basey', 10.0***REMOVED***
            subs = kwargs.pop('subsy', None***REMOVED***
            nonpos = kwargs.pop('nonposy', 'mask'***REMOVED***

        if nonpos not in ['mask', 'clip'***REMOVED***:
            raise ValueError("nonposx, nonposy kwarg must be 'mask' or 'clip'"***REMOVED***

        if base == 10.0:
            self._transform = self.Log10Transform(nonpos***REMOVED***
        elif base == 2.0:
            self._transform = self.Log2Transform(nonpos***REMOVED***
        elif base == np.e:
            self._transform = self.NaturalLogTransform(nonpos***REMOVED***
        else:
            self._transform = self.LogTransform(base, nonpos***REMOVED***

        self.base = base
        self.subs = subs

    def set_default_locators_and_formatters(self, axis***REMOVED***:
        ***REMOVED***
        Set the locators and formatters to specialized versions for
        log scaling.
        ***REMOVED***
        axis.set_major_locator(LogLocator(self.base***REMOVED******REMOVED***
        axis.set_major_formatter(LogFormatterMathtext(self.base***REMOVED******REMOVED***
        axis.set_minor_locator(LogLocator(self.base, self.subs***REMOVED******REMOVED***
        axis.set_minor_formatter(NullFormatter(***REMOVED******REMOVED***

    def get_transform(self***REMOVED***:
        ***REMOVED***
        Return a :class:`~matplotlib.transforms.Transform` instance
        appropriate for the given logarithm base.
        ***REMOVED***
        return self._transform

    def limit_range_for_scale(self, vmin, vmax, minpos***REMOVED***:
        ***REMOVED***
        Limit the domain to positive values.
        ***REMOVED***
        return (vmin <= 0.0 and minpos or vmin,
                vmax <= 0.0 and minpos or vmax***REMOVED***


class SymmetricalLogTransform(Transform***REMOVED***:
    input_dims = 1
    output_dims = 1
    is_separable = True
    has_inverse = True

    def __init__(self, base, linthresh, linscale***REMOVED***:
        Transform.__init__(self***REMOVED***
        self.base = base
        self.linthresh = linthresh
        self.linscale = linscale
        self._linscale_adj = (linscale / (1.0 - self.base ** -1***REMOVED******REMOVED***
        self._log_base = np.log(base***REMOVED***

    def transform_non_affine(self, a***REMOVED***:
        sign = np.sign(a***REMOVED***
        masked = ma.masked_inside(a,
                                  -self.linthresh,
                                  self.linthresh,
                                  copy=False***REMOVED***
        log = sign * self.linthresh * (
            self._linscale_adj +
            ma.log(np.abs(masked***REMOVED*** / self.linthresh***REMOVED*** / self._log_base***REMOVED***
        if masked.mask.any(***REMOVED***:
            return ma.where(masked.mask, a * self._linscale_adj, log***REMOVED***
        else:
            return log

    def inverted(self***REMOVED***:
        return InvertedSymmetricalLogTransform(self.base, self.linthresh,
                                               self.linscale***REMOVED***


class InvertedSymmetricalLogTransform(Transform***REMOVED***:
    input_dims = 1
    output_dims = 1
    is_separable = True
    has_inverse = True

    def __init__(self, base, linthresh, linscale***REMOVED***:
        Transform.__init__(self***REMOVED***
        symlog = SymmetricalLogTransform(base, linthresh, linscale***REMOVED***
        self.base = base
        self.linthresh = linthresh
        self.invlinthresh = symlog.transform(linthresh***REMOVED***
        self.linscale = linscale
        self._linscale_adj = (linscale / (1.0 - self.base ** -1***REMOVED******REMOVED***

    def transform_non_affine(self, a***REMOVED***:
        sign = np.sign(a***REMOVED***
        masked = ma.masked_inside(a, -self.invlinthresh,
                                  self.invlinthresh, copy=False***REMOVED***
        exp = sign * self.linthresh * (
            ma.power(self.base, (sign * (masked / self.linthresh***REMOVED******REMOVED***
            - self._linscale_adj***REMOVED******REMOVED***
        if masked.mask.any(***REMOVED***:
            return ma.where(masked.mask, a / self._linscale_adj, exp***REMOVED***
        else:
            return exp

    def inverted(self***REMOVED***:
        return SymmetricalLogTransform(self.base,
                                       self.linthresh, self.linscale***REMOVED***


class SymmetricalLogScale(ScaleBase***REMOVED***:
    ***REMOVED***
    The symmetrical logarithmic scale is logarithmic in both the
    positive and negative directions from the origin.

    Since the values close to zero tend toward infinity, there is a
    need to have a range around zero that is linear.  The parameter
    *linthresh* allows the user to specify the size of this range
    (-*linthresh*, *linthresh****REMOVED***.
    ***REMOVED***
    name = 'symlog'
    # compatibility shim
    SymmetricalLogTransform = SymmetricalLogTransform
    InvertedSymmetricalLogTransform = InvertedSymmetricalLogTransform

    def __init__(self, axis, **kwargs***REMOVED***:
        ***REMOVED***
        *basex*/*basey*:
           The base of the logarithm

        *linthreshx*/*linthreshy*:
          The range (-*x*, *x****REMOVED*** within which the plot is linear (to
          avoid having the plot go to infinity around zero***REMOVED***.

        *subsx*/*subsy*:
           Where to place the subticks between each major tick.
           Should be a sequence of integers.  For example, in a log10
           scale: ``[2, 3, 4, 5, 6, 7, 8, 9***REMOVED***``

           will place 8 logarithmically spaced minor ticks between
           each major tick.

        *linscalex*/*linscaley*:
           This allows the linear range (-*linthresh* to *linthresh****REMOVED***
           to be stretched relative to the logarithmic range.  Its
           value is the number of decades to use for each half of the
           linear range.  For example, when *linscale* == 1.0 (the
           default***REMOVED***, the space used for the positive and negative
           halves of the linear range will be equal to one decade in
           the logarithmic range.
        ***REMOVED***
        if axis.axis_name == 'x':
            base = kwargs.pop('basex', 10.0***REMOVED***
            linthresh = kwargs.pop('linthreshx', 2.0***REMOVED***
            subs = kwargs.pop('subsx', None***REMOVED***
            linscale = kwargs.pop('linscalex', 1.0***REMOVED***
        else:
            base = kwargs.pop('basey', 10.0***REMOVED***
            linthresh = kwargs.pop('linthreshy', 2.0***REMOVED***
            subs = kwargs.pop('subsy', None***REMOVED***
            linscale = kwargs.pop('linscaley', 1.0***REMOVED***

        if base <= 1.0:
            raise ValueError("'basex/basey' must be larger than 1"***REMOVED***
        if linthresh <= 0.0:
            raise ValueError("'linthreshx/linthreshy' must be positive"***REMOVED***
        if linscale <= 0.0:
            raise ValueError("'linscalex/linthreshy' must be positive"***REMOVED***

        self._transform = self.SymmetricalLogTransform(base,
                                                       linthresh,
                                                       linscale***REMOVED***

        self.base = base
        self.linthresh = linthresh
        self.linscale = linscale
        self.subs = subs

    def set_default_locators_and_formatters(self, axis***REMOVED***:
        ***REMOVED***
        Set the locators and formatters to specialized versions for
        symmetrical log scaling.
        ***REMOVED***
        axis.set_major_locator(SymmetricalLogLocator(self.get_transform(***REMOVED******REMOVED******REMOVED***
        axis.set_major_formatter(LogFormatterMathtext(self.base***REMOVED******REMOVED***
        axis.set_minor_locator(SymmetricalLogLocator(self.get_transform(***REMOVED***,
                                                     self.subs***REMOVED******REMOVED***
        axis.set_minor_formatter(NullFormatter(***REMOVED******REMOVED***

    def get_transform(self***REMOVED***:
        ***REMOVED***
        Return a :class:`SymmetricalLogTransform` instance.
        ***REMOVED***
        return self._transform


def _mask_non_logit(a***REMOVED***:
    ***REMOVED***
    Return a Numpy array where all values outside ***REMOVED***0, 1[ are
    replaced with NaNs. If all values are inside ***REMOVED***0, 1[, the original
    array is returned.
    ***REMOVED***
    mask = (a <= 0.0***REMOVED*** | (a >= 1.0***REMOVED***
    if mask.any(***REMOVED***:
        return np.where(mask, np.nan, a***REMOVED***
    return a


def _clip_non_logit(a***REMOVED***:
    a = np.array(a, float***REMOVED***
    a[a <= 0.0***REMOVED*** = 1e-300
    a[a >= 1.0***REMOVED*** = 1 - 1e-300
    return a


class LogitTransform(Transform***REMOVED***:
    input_dims = 1
    output_dims = 1
    is_separable = True
    has_inverse = True

    def __init__(self, nonpos***REMOVED***:
        Transform.__init__(self***REMOVED***
        if nonpos == 'mask':
            self._handle_nonpos = _mask_non_logit
        else:
            self._handle_nonpos = _clip_non_logit
        self._nonpos = nonpos

    def transform_non_affine(self, a***REMOVED***:
        ***REMOVED***logit transform (base 10***REMOVED***, masked or clipped***REMOVED***
        a = self._handle_nonpos(a***REMOVED***
        return np.log10(1.0 * a / (1.0 - a***REMOVED******REMOVED***

    def inverted(self***REMOVED***:
        return LogisticTransform(self._nonpos***REMOVED***


class LogisticTransform(Transform***REMOVED***:
    input_dims = 1
    output_dims = 1
    is_separable = True
    has_inverse = True

    def __init__(self, nonpos='mask'***REMOVED***:
        Transform.__init__(self***REMOVED***
        self._nonpos = nonpos

    def transform_non_affine(self, a***REMOVED***:
        ***REMOVED***logistic transform (base 10***REMOVED******REMOVED***
        return 1.0 / (1 + 10**(-a***REMOVED******REMOVED***

    def inverted(self***REMOVED***:
        return LogitTransform(self._nonpos***REMOVED***


class LogitScale(ScaleBase***REMOVED***:
    ***REMOVED***
    Logit scale for data between zero and one, both excluded.

    This scale is similar to a log scale close to zero and to one, and almost
    linear around 0.5. It maps the interval ***REMOVED***0, 1[ onto ***REMOVED***-infty, +infty[.
    ***REMOVED***
    name = 'logit'

    def __init__(self, axis, nonpos='mask'***REMOVED***:
        ***REMOVED***
        *nonpos*: ['mask' | 'clip' ***REMOVED***
          values beyond ***REMOVED***0, 1[ can be masked as invalid, or clipped to a number
          very close to 0 or 1
        ***REMOVED***
        if nonpos not in ['mask', 'clip'***REMOVED***:
            raise ValueError("nonposx, nonposy kwarg must be 'mask' or 'clip'"***REMOVED***

        self._transform = LogitTransform(nonpos***REMOVED***

    def get_transform(self***REMOVED***:
        ***REMOVED***
        Return a :class:`LogitTransform` instance.
        ***REMOVED***
        return self._transform

    def set_default_locators_and_formatters(self, axis***REMOVED***:
        # ..., 0.01, 0.1, 0.5, 0.9, 0.99, ...
        axis.set_major_locator(LogitLocator(***REMOVED******REMOVED***
        axis.set_major_formatter(LogitFormatter(***REMOVED******REMOVED***
        axis.set_minor_locator(LogitLocator(minor=True***REMOVED******REMOVED***
        axis.set_minor_formatter(LogitFormatter(***REMOVED******REMOVED***

    def limit_range_for_scale(self, vmin, vmax, minpos***REMOVED***:
        ***REMOVED***
        Limit the domain to values between 0 and 1 (excluded***REMOVED***.
        ***REMOVED***
        return (vmin <= 0 and minpos or vmin,
                vmax >= 1 and (1 - minpos***REMOVED*** or vmax***REMOVED***


_scale_mapping = {
    'linear': LinearScale,
    'log':    LogScale,
    'symlog': SymmetricalLogScale,
    'logit':  LogitScale,
***REMOVED***


def get_scale_names(***REMOVED***:
    names = list(six.iterkeys(_scale_mapping***REMOVED******REMOVED***
    names.sort(***REMOVED***
    return names


def scale_factory(scale, axis, **kwargs***REMOVED***:
    ***REMOVED***
    Return a scale class by name.

    ACCEPTS: [ %(names***REMOVED***s ***REMOVED***
    ***REMOVED***
    scale = scale.lower(***REMOVED***
    if scale is None:
        scale = 'linear'

    if scale not in _scale_mapping:
        raise ValueError("Unknown scale type '%s'" % scale***REMOVED***

    return _scale_mapping[scale***REMOVED***(axis, **kwargs***REMOVED***
scale_factory.__doc__ = dedent(scale_factory.__doc__***REMOVED*** % \
***REMOVED***'names': " | ".join(get_scale_names(***REMOVED******REMOVED******REMOVED***


def register_scale(scale_class***REMOVED***:
    ***REMOVED***
    Register a new kind of scale.

    *scale_class* must be a subclass of :class:`ScaleBase`.
    ***REMOVED***
    _scale_mapping[scale_class.name***REMOVED*** = scale_class


def get_scale_docs(***REMOVED***:
    ***REMOVED***
    Helper function for generating docstrings related to scales.
    ***REMOVED***
    docs = [***REMOVED***
    for name in get_scale_names(***REMOVED***:
        scale_class = _scale_mapping[name***REMOVED***
        docs.append("    '%s'" % name***REMOVED***
        docs.append(""***REMOVED***
        class_docs = dedent(scale_class.__init__.__doc__***REMOVED***
        class_docs = "".join(["        %s\n" %
                              x for x in class_docs.split("\n"***REMOVED******REMOVED******REMOVED***
        docs.append(class_docs***REMOVED***
        docs.append(""***REMOVED***
    return "\n".join(docs***REMOVED***


docstring.interpd.update(
    scale=' | '.join([repr(x***REMOVED*** for x in get_scale_names(***REMOVED******REMOVED******REMOVED***,
    scale_docs=get_scale_docs(***REMOVED***.rstrip(***REMOVED***,
    ***REMOVED***
