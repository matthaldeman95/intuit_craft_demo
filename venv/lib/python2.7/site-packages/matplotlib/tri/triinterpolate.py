***REMOVED***
Interpolation inside triangular grids.
***REMOVED***
from __future__ import (absolute_import, division, print_function,
                        unicode_literals***REMOVED***

from matplotlib.externals import six
from matplotlib.externals.six.moves import xrange

from matplotlib.tri import Triangulation
from matplotlib.tri.trifinder import TriFinder
from matplotlib.tri.tritools import TriAnalyzer
import numpy as np
import warnings

__all__ = ('TriInterpolator', 'LinearTriInterpolator', 'CubicTriInterpolator'***REMOVED***


class TriInterpolator(object***REMOVED***:
    ***REMOVED***
    Abstract base class for classes used to perform interpolation on
    triangular grids.

    Derived classes implement the following methods:

        - ``__call__(x, y***REMOVED***`` ,
          where x, y are array_like point coordinates of the same shape, and
          that returns a masked array of the same shape containing the
          interpolated z-values.

        - ``gradient(x, y***REMOVED***`` ,
          where x, y are array_like point coordinates of the same
          shape, and that returns a list of 2 masked arrays of the same shape
          containing the 2 derivatives of the interpolator (derivatives of
          interpolated z values with respect to x and y***REMOVED***.

    ***REMOVED***
    def __init__(self, triangulation, z, trifinder=None***REMOVED***:
        if not isinstance(triangulation, Triangulation***REMOVED***:
            raise ValueError("Expected a Triangulation object"***REMOVED***
        self._triangulation = triangulation

        self._z = np.asarray(z***REMOVED***
        if self._z.shape != self._triangulation.x.shape:
            raise ValueError("z array must have same length as triangulation x"
                             " and y arrays"***REMOVED***

        if trifinder is not None and not isinstance(trifinder, TriFinder***REMOVED***:
            raise ValueError("Expected a TriFinder object"***REMOVED***
        self._trifinder = trifinder or self._triangulation.get_trifinder(***REMOVED***

        # Default scaling factors : 1.0 (= no scaling***REMOVED***
        # Scaling may be used for interpolations for which the order of
        # magnitude of x, y has an impact on the interpolant definition.
        # Please refer to :meth:`_interpolate_multikeys` for details.
        self._unit_x = 1.0
        self._unit_y = 1.0

        # Default triangle renumbering: None (= no renumbering***REMOVED***
        # Renumbering may be used to avoid unecessary computations
        # if complex calculations are done inside the Interpolator.
        # Please refer to :meth:`_interpolate_multikeys` for details.
        self._tri_renum = None

    # __call__ and gradient docstrings are shared by all subclasses
    # (except, if needed, relevant additions***REMOVED***.
    # However these methods are only implemented in subclasses to avoid
    # confusion in the documentation.
    docstring__call__ = ***REMOVED***
        Returns a masked array containing interpolated values at the specified
        x,y points.

        Parameters
        ----------
        x, y : array-like
            x and y coordinates of the same shape and any number of
            dimensions.

        Returns
        -------
        z : np.ma.array
            Masked array of the same shape as *x* and *y* ; values
            corresponding to (*x*, *y****REMOVED*** points outside of the triangulation
            are masked out.

        ***REMOVED***

    docstringgradient = ***REMOVED***
        Returns a list of 2 masked arrays containing interpolated derivatives
        at the specified x,y points.

        Parameters
        ----------
        x, y : array-like
            x and y coordinates of the same shape and any number of
            dimensions.

        Returns
        -------
        dzdx, dzdy : np.ma.array
            2  masked arrays of the same shape as *x* and *y* ; values
            corresponding to (x,y***REMOVED*** points outside of the triangulation
            are masked out.
            The first returned array contains the values of
            :math:`\\frac{\\partial z***REMOVED***{\\partial x***REMOVED***` and the second those of
            :math:`\\frac{\\partial z***REMOVED***{\\partial y***REMOVED***`.

        ***REMOVED***

    def _interpolate_multikeys(self, x, y, tri_index=None,
                               return_keys=('z',***REMOVED******REMOVED***:
        ***REMOVED***
        Versatile (private***REMOVED*** method defined for all TriInterpolators.

        :meth:`_interpolate_multikeys` is a wrapper around method
        :meth:`_interpolate_single_key` (to be defined in the child
        subclasses***REMOVED***.
        :meth:`_interpolate_single_key actually performs the interpolation,
        but only for 1-dimensional inputs and at valid locations (inside
        unmasked triangles of the triangulation***REMOVED***.

        The purpose of :meth:`_interpolate_multikeys` is to implement the
        following common tasks needed in all subclasses implementations:

            - calculation of containing triangles
            - dealing with more than one interpolation request at the same
              location (e.g., if the 2 derivatives are requested, it is
              unnecessary to compute the containing triangles twice***REMOVED***
            - scaling according to self._unit_x, self._unit_y
            - dealing with points outside of the grid (with fill value np.nan***REMOVED***
            - dealing with multi-dimensionnal *x*, *y* arrays: flattening for
              :meth:`_interpolate_params` call and final reshaping.

        (Note that np.vectorize could do most of those things very well for
        you, but it does it by function evaluations over successive tuples of
        the input arrays. Therefore, this tends to be more time consuming than
        using optimized numpy functions - e.g., np.dot - which can be used
        easily on the flattened inputs, in the child-subclass methods
        :meth:`_interpolate_single_key`.***REMOVED***

        It is guaranteed that the calls to :meth:`_interpolate_single_key`
        will be done with flattened (1-d***REMOVED*** array_like input parameters `x`, `y`
        and with flattened, valid `tri_index` arrays (no -1 index allowed***REMOVED***.

        Parameters
        ----------
        x, y : array_like
            x and y coordinates indicating where interpolated values are
            requested.
        tri_index : integer array_like, optional
            Array of the containing triangle indices, same shape as
            *x* and *y*. Defaults to None. If None, these indices
            will be computed by a TriFinder instance.
            (Note: For point outside the grid, tri_index[ipt***REMOVED*** shall be -1***REMOVED***.
        return_keys : tuple of keys from {'z', 'dzdx', 'dzdy'***REMOVED***
            Defines the interpolation arrays to return, and in which order.

        Returns
        -------
        ret : list of arrays
            Each array-like contains the expected interpolated values in the
            order defined by *return_keys* parameter.
        ***REMOVED***
        # Flattening and rescaling inputs arrays x, y
        # (initial shape is stored for output***REMOVED***
        x = np.asarray(x, dtype=np.float64***REMOVED***
        y = np.asarray(y, dtype=np.float64***REMOVED***
        sh_ret = x.shape
        if (x.shape != y.shape***REMOVED***:
            raise ValueError("x and y shall have same shapes."
                             " Given: {0***REMOVED*** and {1***REMOVED***".format(x.shape, y.shape***REMOVED******REMOVED***
        x = np.ravel(x***REMOVED***
        y = np.ravel(y***REMOVED***
        x_scaled = x/self._unit_x
        y_scaled = y/self._unit_y
        size_ret = np.size(x_scaled***REMOVED***

        # Computes & ravels the element indexes, extract the valid ones.
        if tri_index is None:
            tri_index = self._trifinder(x, y***REMOVED***
        else:
            if (tri_index.shape != sh_ret***REMOVED***:
                raise ValueError(
                    "tri_index array is provided and shall"
                    " have same shape as x and y. Given: "
                    "{0***REMOVED*** and {1***REMOVED***".format(tri_index.shape, sh_ret***REMOVED******REMOVED***
            tri_index = np.ravel(tri_index***REMOVED***

        mask_in = (tri_index != -1***REMOVED***
        if self._tri_renum is None:
            valid_tri_index = tri_index[mask_in***REMOVED***
        else:
            valid_tri_index = self._tri_renum[tri_index[mask_in***REMOVED******REMOVED***
        valid_x = x_scaled[mask_in***REMOVED***
        valid_y = y_scaled[mask_in***REMOVED***

        ret = [***REMOVED***
        for return_key in return_keys:
            # Find the return index associated with the key.
            ***REMOVED***
                return_index = {'z': 0, 'dzdx': 1, 'dzdy': 2***REMOVED***[return_key***REMOVED***
            except KeyError:
                raise ValueError("return_keys items shall take values in"
                                 " {'z', 'dzdx', 'dzdy'***REMOVED***"***REMOVED***

            # Sets the scale factor for f & df components
            scale = [1., 1./self._unit_x, 1./self._unit_y***REMOVED***[return_index***REMOVED***

            # Computes the interpolation
            ret_loc = np.empty(size_ret, dtype=np.float64***REMOVED***
            ret_loc[~mask_in***REMOVED*** = np.nan
            ret_loc[mask_in***REMOVED*** = self._interpolate_single_key(
                return_key, valid_tri_index, valid_x, valid_y***REMOVED*** * scale
            ret += [np.ma.masked_invalid(ret_loc.reshape(sh_ret***REMOVED***, copy=False***REMOVED******REMOVED***

        return ret

    def _interpolate_single_key(self, return_key, tri_index, x, y***REMOVED***:
        ***REMOVED***
        Performs the interpolation at points belonging to the triangulation
        (inside an unmasked triangles***REMOVED***.

        Parameters
        ----------
        return_index : string key from {'z', 'dzdx', 'dzdy'***REMOVED***
            Identifies the requested values (z or its derivatives***REMOVED***
        tri_index : 1d integer array
            Valid triangle index (-1 prohibited***REMOVED***
        x, y : 1d arrays, same shape as `tri_index`
            Valid locations where interpolation is requested.

        Returns
        -------
        ret : 1-d array
            Returned array of the same size as *tri_index*
        ***REMOVED***
        raise NotImplementedError("TriInterpolator subclasses" +
                                  "should implement _interpolate_single_key!"***REMOVED***


class LinearTriInterpolator(TriInterpolator***REMOVED***:
    ***REMOVED***
    A LinearTriInterpolator performs linear interpolation on a triangular grid.

    Each triangle is represented by a plane so that an interpolated value at
    point (x,y***REMOVED*** lies on the plane of the triangle containing (x,y***REMOVED***.
    Interpolated values are therefore continuous across the triangulation, but
    their first derivatives are discontinuous at edges between triangles.

    Parameters
    ----------
    triangulation : :class:`~matplotlib.tri.Triangulation` object
        The triangulation to interpolate over.
    z : array_like of shape (npoints,***REMOVED***
        Array of values, defined at grid points, to interpolate between.
    trifinder : :class:`~matplotlib.tri.TriFinder` object, optional
          If this is not specified, the Triangulation's default TriFinder will
          be used by calling
          :func:`matplotlib.tri.Triangulation.get_trifinder`.

    Methods
    -------
    `__call__` (x, y***REMOVED*** :  Returns interpolated values at x,y points
    `gradient` (x, y***REMOVED*** : Returns interpolated derivatives at x,y points

    ***REMOVED***
    def __init__(self, triangulation, z, trifinder=None***REMOVED***:
        TriInterpolator.__init__(self, triangulation, z, trifinder***REMOVED***

        # Store plane coefficients for fast interpolation calculations.
        self._plane_coefficients = \
            self._triangulation.calculate_plane_coefficients(self._z***REMOVED***

    def __call__(self, x, y***REMOVED***:
        return self._interpolate_multikeys(x, y, tri_index=None,
                                           return_keys=('z',***REMOVED******REMOVED***[0***REMOVED***
    __call__.__doc__ = TriInterpolator.docstring__call__

    def gradient(self, x, y***REMOVED***:
        return self._interpolate_multikeys(x, y, tri_index=None,
                                           return_keys=('dzdx', 'dzdy'***REMOVED******REMOVED***
    gradient.__doc__ = TriInterpolator.docstringgradient

    def _interpolate_single_key(self, return_key, tri_index, x, y***REMOVED***:
        if return_key == 'z':
            return (self._plane_coefficients[tri_index, 0***REMOVED****x +
                    self._plane_coefficients[tri_index, 1***REMOVED****y +
                    self._plane_coefficients[tri_index, 2***REMOVED******REMOVED***
        elif return_key == 'dzdx':
            return self._plane_coefficients[tri_index, 0***REMOVED***
        elif return_key == 'dzdy':
            return self._plane_coefficients[tri_index, 1***REMOVED***
        else:
            raise ValueError("Invalid return_key: " + return_key***REMOVED***


class CubicTriInterpolator(TriInterpolator***REMOVED***:
    ***REMOVED***
    A CubicTriInterpolator performs cubic interpolation on triangular grids.

    In one-dimension - on a segment - a cubic interpolating function is
    defined by the values of the function and its derivative at both ends.
    This is almost the same in 2-d inside a triangle, except that the values
    of the function and its 2 derivatives have to be defined at each triangle
    node.

    The CubicTriInterpolator takes the value of the function at each node -
    provided by the user - and internally computes the value of the
    derivatives, resulting in a smooth interpolation.
    (As a special feature, the user can also impose the value of the
    derivatives at each node, but this is not supposed to be the common
    usage.***REMOVED***

    Parameters
    ----------
    triangulation : :class:`~matplotlib.tri.Triangulation` object
        The triangulation to interpolate over.
    z : array_like of shape (npoints,***REMOVED***
        Array of values, defined at grid points, to interpolate between.
    kind : {'min_E', 'geom', 'user'***REMOVED***, optional
        Choice of the smoothing algorithm, in order to compute
        the interpolant derivatives (defaults to 'min_E'***REMOVED***:

            - if 'min_E': (default***REMOVED*** The derivatives at each node is computed
              to minimize a bending energy.
            - if 'geom': The derivatives at each node is computed as a
              weighted average of relevant triangle normals. To be used for
              speed optimization (large grids***REMOVED***.
            - if 'user': The user provides the argument `dz`, no computation
              is hence needed.

    trifinder : :class:`~matplotlib.tri.TriFinder` object, optional
        If not specified, the Triangulation's default TriFinder will
        be used by calling
        :func:`matplotlib.tri.Triangulation.get_trifinder`.
    dz : tuple of array_likes (dzdx, dzdy***REMOVED***, optional
        Used only if  *kind* ='user'. In this case *dz* must be provided as
        (dzdx, dzdy***REMOVED*** where dzdx, dzdy are arrays of the same shape as *z* and
        are the interpolant first derivatives at the *triangulation* points.

    Methods
    -------
    `__call__` (x, y***REMOVED*** :  Returns interpolated values at x,y points
    `gradient` (x, y***REMOVED*** : Returns interpolated derivatives at x,y points

    Notes
    -----
    This note is a bit technical and details the way a
    :class:`~matplotlib.tri.CubicTriInterpolator` computes a cubic
    interpolation.

    The interpolation is based on a Clough-Tocher subdivision scheme of
    the *triangulation* mesh (to make it clearer, each triangle of the
    grid will be divided in 3 child-triangles, and on each child triangle
    the interpolated function is a cubic polynomial of the 2 coordinates***REMOVED***.
    This technique originates from FEM (Finite Element Method***REMOVED*** analysis;
    the element used is a reduced Hsieh-Clough-Tocher (HCT***REMOVED***
    element. Its shape functions are described in [1***REMOVED***_.
    The assembled function is guaranteed to be C1-smooth, i.e. it is
    continuous and its first derivatives are also continuous (this
    is easy to show inside the triangles but is also true when crossing the
    edges***REMOVED***.

    In the default case (*kind* ='min_E'***REMOVED***, the interpolant minimizes a
    curvature energy on the functional space generated by the HCT element
    shape functions - with imposed values but arbitrary derivatives at each
    node. The minimized functional is the integral of the so-called total
    curvature (implementation based on an algorithm from [2***REMOVED***_ - PCG sparse
    solver***REMOVED***:

        .. math::

            E(z***REMOVED*** = \\ \\frac{1***REMOVED***{2***REMOVED*** \\int_{\\Omega***REMOVED***   \\left(
            \\left( \\frac{\\partial^2{z***REMOVED******REMOVED***{\\partial{x***REMOVED***^2***REMOVED*** \\right***REMOVED***^2 +
            \\left( \\frac{\\partial^2{z***REMOVED******REMOVED***{\\partial{y***REMOVED***^2***REMOVED*** \\right***REMOVED***^2 +
            2\\left( \\frac{\\partial^2{z***REMOVED******REMOVED***{\\partial{y***REMOVED***\\partial{x***REMOVED******REMOVED***
            \\right***REMOVED***^2 \\right***REMOVED***  dx\\,dy

    If the case *kind* ='geom' is chosen by the user, a simple geometric
    approximation is used (weighted average of the triangle normal
    vectors***REMOVED***, which could improve speed on very large grids.

    References
    ----------
    .. [1***REMOVED*** Michel Bernadou, Kamal Hassan, "Basis functions for general
        Hsieh-Clough-Tocher triangles, complete or reduced.",
        International Journal for Numerical Methods in Engineering,
        17(5***REMOVED***:784 - 789. 2.01.
    .. [2***REMOVED*** C.T. Kelley, "Iterative Methods for Optimization".

    ***REMOVED***
    def __init__(self, triangulation, z, kind='min_E', trifinder=None,
                 dz=None***REMOVED***:
        TriInterpolator.__init__(self, triangulation, z, trifinder***REMOVED***

        # Loads the underlying c++ _triangulation.
        # (During loading, reordering of triangulation._triangles may occur so
        # that all final triangles are now anti-clockwise***REMOVED***
        self._triangulation.get_cpp_triangulation(***REMOVED***

        # To build the stiffness matrix and avoid zero-energy spurious modes
        # we will only store internally the valid (unmasked***REMOVED*** triangles and
        # the necessary (used***REMOVED*** points coordinates.
        # 2 renumbering tables need to be computed and stored:
        #  - a triangle renum table in order to translate the result from a
        #    TriFinder instance into the internal stored triangle number.
        #  - a node renum table to overwrite the self._z values into the new
        #    (used***REMOVED*** node numbering.
        tri_analyzer = TriAnalyzer(self._triangulation***REMOVED***
        (compressed_triangles, compressed_x, compressed_y, tri_renum,
         node_renum***REMOVED*** = tri_analyzer._get_compressed_triangulation(True, True***REMOVED***
        self._triangles = compressed_triangles
        self._tri_renum = tri_renum
        # Taking into account the node renumbering in self._z:
        node_mask = (node_renum == -1***REMOVED***
        self._z[node_renum[~node_mask***REMOVED******REMOVED*** = self._z
        self._z = self._z[~node_mask***REMOVED***

        # Computing scale factors
        self._unit_x = np.max(compressed_x***REMOVED*** - np.min(compressed_x***REMOVED***
        self._unit_y = np.max(compressed_y***REMOVED*** - np.min(compressed_y***REMOVED***
        self._pts = np.vstack((compressed_x/float(self._unit_x***REMOVED***,
                               compressed_y/float(self._unit_y***REMOVED******REMOVED******REMOVED***.T
        # Computing triangle points
        self._tris_pts = self._pts[self._triangles***REMOVED***
        # Computing eccentricities
        self._eccs = self._compute_tri_eccentricities(self._tris_pts***REMOVED***
        # Computing dof estimations for HCT triangle shape function
        self._dof = self._compute_dof(kind, dz=dz***REMOVED***
        # Loading HCT element
        self._ReferenceElement = _ReducedHCT_Element(***REMOVED***

    def __call__(self, x, y***REMOVED***:
        return self._interpolate_multikeys(x, y, tri_index=None,
                                           return_keys=('z',***REMOVED******REMOVED***[0***REMOVED***
    __call__.__doc__ = TriInterpolator.docstring__call__

    def gradient(self, x, y***REMOVED***:
        return self._interpolate_multikeys(x, y, tri_index=None,
                                           return_keys=('dzdx', 'dzdy'***REMOVED******REMOVED***
    gradient.__doc__ = TriInterpolator.docstringgradient + ***REMOVED***

        Examples
        --------
        An example of effective application is shown below (plot of the
        direction of the vector field derivated from a known potential field***REMOVED***:

        .. plot:: mpl_examples/pylab_examples/trigradient_demo.py

        ***REMOVED***

    def _interpolate_single_key(self, return_key, tri_index, x, y***REMOVED***:
        tris_pts = self._tris_pts[tri_index***REMOVED***
        alpha = self._get_alpha_vec(x, y, tris_pts***REMOVED***
        ecc = self._eccs[tri_index***REMOVED***
        dof = np.expand_dims(self._dof[tri_index***REMOVED***, axis=1***REMOVED***
        if return_key == 'z':
            return self._ReferenceElement.get_function_values(
                alpha, ecc, dof***REMOVED***
        elif return_key in ['dzdx', 'dzdy'***REMOVED***:
            J = self._get_jacobian(tris_pts***REMOVED***
            dzdx = self._ReferenceElement.get_function_derivatives(
                alpha, J, ecc, dof***REMOVED***
            if return_key == 'dzdx':
                return dzdx[:, 0, 0***REMOVED***
            else:
                return dzdx[:, 1, 0***REMOVED***
        else:
            raise ValueError("Invalid return_key: " + return_key***REMOVED***

    def _compute_dof(self, kind, dz=None***REMOVED***:
        ***REMOVED***
        Computes and returns nodal dofs according to kind

        Parameters
        ----------
        kind: {'min_E', 'geom', 'user'***REMOVED***
            Choice of the _DOF_estimator subclass to perform the gradient
            estimation.
        dz: tuple of array_likes (dzdx, dzdy***REMOVED***, optional
            Used only if *kind=user ; in this case passed to the
            :class:`_DOF_estimator_user`.

        Returns
        -------
        dof : array_like, shape (npts,2***REMOVED***
              Estimation of the gradient at triangulation nodes (stored as
              degree of freedoms of reduced-HCT triangle elements***REMOVED***.
        ***REMOVED***
        if kind == 'user':
            if dz is None:
                raise ValueError("For a CubicTriInterpolator with "
                                 "*kind*='user', a valid *dz* "
                                 "argument is expected."***REMOVED***
            TE = _DOF_estimator_user(self, dz=dz***REMOVED***
        elif kind == 'geom':
            TE = _DOF_estimator_geom(self***REMOVED***
        elif kind == 'min_E':
            TE = _DOF_estimator_min_E(self***REMOVED***
        else:
            raise ValueError("CubicTriInterpolator *kind* proposed: {0***REMOVED*** ; "
                             "should be one of: "
                             "'user', 'geom', 'min_E'".format(kind***REMOVED******REMOVED***
        return TE.compute_dof_from_df(***REMOVED***

    @staticmethod
    def _get_alpha_vec(x, y, tris_pts***REMOVED***:
        ***REMOVED***
        Fast (vectorized***REMOVED*** function to compute barycentric coordinates alpha.

        Parameters
        ----------
        x, y : array-like of dim 1 (shape (nx,***REMOVED******REMOVED***
                  Coordinates of the points whose points barycentric
                  coordinates are requested
        tris_pts : array like of dim 3 (shape: (nx,3,2***REMOVED******REMOVED***
                    Coordinates of the containing triangles apexes.

        Returns
        -------
        alpha : array of dim 2 (shape (nx,3***REMOVED******REMOVED***
                 Barycentric coordinates of the points inside the containing
                 triangles.
        ***REMOVED***
        ndim = tris_pts.ndim-2

        a = tris_pts[:, 1, :***REMOVED*** - tris_pts[:, 0, :***REMOVED***
        b = tris_pts[:, 2, :***REMOVED*** - tris_pts[:, 0, :***REMOVED***
        abT = np.concatenate([np.expand_dims(a, ndim+1***REMOVED***,
                              np.expand_dims(b, ndim+1***REMOVED******REMOVED***, ndim+1***REMOVED***
        ab = _transpose_vectorized(abT***REMOVED***
        x = np.expand_dims(x, ndim***REMOVED***
        y = np.expand_dims(y, ndim***REMOVED***
        OM = np.concatenate([x, y***REMOVED***, ndim***REMOVED*** - tris_pts[:, 0, :***REMOVED***

        metric = _prod_vectorized(ab, abT***REMOVED***
        # Here we try to deal with the colinear cases.
        # metric_inv is in this case set to the Moore-Penrose pseudo-inverse
        # meaning that we will still return a set of valid barycentric
        # coordinates.
        metric_inv = _pseudo_inv22sym_vectorized(metric***REMOVED***
        Covar = _prod_vectorized(ab, _transpose_vectorized(
            np.expand_dims(OM, ndim***REMOVED******REMOVED******REMOVED***
        ksi = _prod_vectorized(metric_inv, Covar***REMOVED***
        alpha = _to_matrix_vectorized([
            [1-ksi[:, 0, 0***REMOVED***-ksi[:, 1, 0***REMOVED******REMOVED***, [ksi[:, 0, 0***REMOVED******REMOVED***, [ksi[:, 1, 0***REMOVED******REMOVED******REMOVED******REMOVED***
        return alpha

    @staticmethod
    def _get_jacobian(tris_pts***REMOVED***:
        ***REMOVED***
        Fast (vectorized***REMOVED*** function to compute triangle jacobian matrix.

        Parameters
        ----------
        tris_pts : array like of dim 3 (shape: (nx,3,2***REMOVED******REMOVED***
                    Coordinates of the containing triangles apexes.

        Returns
        -------
        J : array of dim 3 (shape (nx,2,2***REMOVED******REMOVED***
                 Barycentric coordinates of the points inside the containing
                 triangles.
                 J[itri,:,:***REMOVED*** is the jacobian matrix at apex 0 of the triangle
                 itri, so that the following (matrix***REMOVED*** relationship holds:
                    [dz/dksi***REMOVED*** = [J***REMOVED*** x [dz/dx***REMOVED***
                    with x: global coordinates
                    ksi: element parametric coordinates in triangle first apex
                    local basis.
        ***REMOVED***
        a = np.array(tris_pts[:, 1, :***REMOVED*** - tris_pts[:, 0, :***REMOVED******REMOVED***
        b = np.array(tris_pts[:, 2, :***REMOVED*** - tris_pts[:, 0, :***REMOVED******REMOVED***
        J = _to_matrix_vectorized([[a[:, 0***REMOVED***, a[:, 1***REMOVED******REMOVED***,
                                   [b[:, 0***REMOVED***, b[:, 1***REMOVED******REMOVED******REMOVED******REMOVED***
        return J

    @staticmethod
    def _compute_tri_eccentricities(tris_pts***REMOVED***:
        ***REMOVED***
        Computes triangle eccentricities

        Parameters
        ----------
        tris_pts : array like of dim 3 (shape: (nx,3,2***REMOVED******REMOVED***
                   Coordinates of the triangles apexes.

        Returns
        -------
        ecc : array like of dim 2 (shape: (nx,3***REMOVED******REMOVED***
              The so-called eccentricity parameters [1***REMOVED*** needed for
              HCT triangular element.
        ***REMOVED***
        a = np.expand_dims(tris_pts[:, 2, :***REMOVED***-tris_pts[:, 1, :***REMOVED***, axis=2***REMOVED***
        b = np.expand_dims(tris_pts[:, 0, :***REMOVED***-tris_pts[:, 2, :***REMOVED***, axis=2***REMOVED***
        c = np.expand_dims(tris_pts[:, 1, :***REMOVED***-tris_pts[:, 0, :***REMOVED***, axis=2***REMOVED***
        # Do not use np.squeeze, this is dangerous if only one triangle
        # in the triangulation...
        dot_a = _prod_vectorized(_transpose_vectorized(a***REMOVED***, a***REMOVED***[:, 0, 0***REMOVED***
        dot_b = _prod_vectorized(_transpose_vectorized(b***REMOVED***, b***REMOVED***[:, 0, 0***REMOVED***
        dot_c = _prod_vectorized(_transpose_vectorized(c***REMOVED***, c***REMOVED***[:, 0, 0***REMOVED***
        # Note that this line will raise a warning for dot_a, dot_b or dot_c
        # zeros, but we choose not to support triangles with duplicate points.
        return _to_matrix_vectorized([[(dot_c-dot_b***REMOVED*** / dot_a***REMOVED***,
                                      [(dot_a-dot_c***REMOVED*** / dot_b***REMOVED***,
                                      [(dot_b-dot_a***REMOVED*** / dot_c***REMOVED******REMOVED******REMOVED***


# FEM element used for interpolation and for solving minimisation
# problem (Reduced HCT element***REMOVED***
class _ReducedHCT_Element(***REMOVED***:
    ***REMOVED***
    Implementation of reduced HCT triangular element with explicit shape
    functions.

    Computes z, dz, d2z and the element stiffness matrix for bending energy:
    E(f***REMOVED*** = integral( (d2z/dx2 + d2z/dy2***REMOVED*****2 dA***REMOVED***

    *** Reference for the shape functions: ***
    [1***REMOVED*** Basis functions for general Hsieh-Clough-Tocher _triangles, complete or
        reduced.
        Michel Bernadou, Kamal Hassan
        International Journal for Numerical Methods in Engineering.
        17(5***REMOVED***:784 - 789.  2.01

    *** Element description: ***
    9 dofs: z and dz given at 3 apex
    C1 (conform***REMOVED***

    ***REMOVED***
    # 1***REMOVED*** Loads matrices to generate shape functions as a function of
    #    triangle eccentricities - based on [1***REMOVED*** p.11 '''
    M = np.array([
        [ 0.00, 0.00, 0.00,  4.50,  4.50, 0.00, 0.00, 0.00, 0.00, 0.00***REMOVED***,
        [-0.25, 0.00, 0.00,  0.50,  1.25, 0.00, 0.00, 0.00, 0.00, 0.00***REMOVED***,
        [-0.25, 0.00, 0.00,  1.25,  0.50, 0.00, 0.00, 0.00, 0.00, 0.00***REMOVED***,
        [ 0.50, 1.00, 0.00, -1.50,  0.00, 3.00, 3.00, 0.00, 0.00, 3.00***REMOVED***,
        [ 0.00, 0.00, 0.00, -0.25,  0.25, 0.00, 1.00, 0.00, 0.00, 0.50***REMOVED***,
        [ 0.25, 0.00, 0.00, -0.50, -0.25, 1.00, 0.00, 0.00, 0.00, 1.00***REMOVED***,
        [ 0.50, 0.00, 1.00,  0.00, -1.50, 0.00, 0.00, 3.00, 3.00, 3.00***REMOVED***,
        [ 0.25, 0.00, 0.00, -0.25, -0.50, 0.00, 0.00, 0.00, 1.00, 1.00***REMOVED***,
        [ 0.00, 0.00, 0.00,  0.25, -0.25, 0.00, 0.00, 1.00, 0.00, 0.50***REMOVED******REMOVED******REMOVED***
    M0 = np.array([
        [ 0.00, 0.00, 0.00,  0.00,  0.00, 0.00, 0.00, 0.00, 0.00,  0.00***REMOVED***,
        [ 0.00, 0.00, 0.00,  0.00,  0.00, 0.00, 0.00, 0.00, 0.00,  0.00***REMOVED***,
        [ 0.00, 0.00, 0.00,  0.00,  0.00, 0.00, 0.00, 0.00, 0.00,  0.00***REMOVED***,
        [-1.00, 0.00, 0.00,  1.50,  1.50, 0.00, 0.00, 0.00, 0.00, -3.00***REMOVED***,
        [-0.50, 0.00, 0.00,  0.75,  0.75, 0.00, 0.00, 0.00, 0.00, -1.50***REMOVED***,
        [ 0.00, 0.00, 0.00,  0.00,  0.00, 0.00, 0.00, 0.00, 0.00,  0.00***REMOVED***,
        [ 1.00, 0.00, 0.00, -1.50, -1.50, 0.00, 0.00, 0.00, 0.00,  3.00***REMOVED***,
        [ 0.00, 0.00, 0.00,  0.00,  0.00, 0.00, 0.00, 0.00, 0.00,  0.00***REMOVED***,
        [ 0.50, 0.00, 0.00, -0.75, -0.75, 0.00, 0.00, 0.00, 0.00,  1.50***REMOVED******REMOVED******REMOVED***
    M1 = np.array([
        [-0.50, 0.00, 0.00,  1.50, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00***REMOVED***,
        [ 0.00, 0.00, 0.00,  0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00***REMOVED***,
        [-0.25, 0.00, 0.00,  0.75, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00***REMOVED***,
        [ 0.00, 0.00, 0.00,  0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00***REMOVED***,
        [ 0.00, 0.00, 0.00,  0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00***REMOVED***,
        [ 0.00, 0.00, 0.00,  0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00***REMOVED***,
        [ 0.50, 0.00, 0.00, -1.50, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00***REMOVED***,
        [ 0.25, 0.00, 0.00, -0.75, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00***REMOVED***,
        [ 0.00, 0.00, 0.00,  0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00***REMOVED******REMOVED******REMOVED***
    M2 = np.array([
        [ 0.50, 0.00, 0.00, 0.00, -1.50, 0.00, 0.00, 0.00, 0.00, 0.00***REMOVED***,
        [ 0.25, 0.00, 0.00, 0.00, -0.75, 0.00, 0.00, 0.00, 0.00, 0.00***REMOVED***,
        [ 0.00, 0.00, 0.00, 0.00,  0.00, 0.00, 0.00, 0.00, 0.00, 0.00***REMOVED***,
        [-0.50, 0.00, 0.00, 0.00,  1.50, 0.00, 0.00, 0.00, 0.00, 0.00***REMOVED***,
        [ 0.00, 0.00, 0.00, 0.00,  0.00, 0.00, 0.00, 0.00, 0.00, 0.00***REMOVED***,
        [-0.25, 0.00, 0.00, 0.00,  0.75, 0.00, 0.00, 0.00, 0.00, 0.00***REMOVED***,
        [ 0.00, 0.00, 0.00, 0.00,  0.00, 0.00, 0.00, 0.00, 0.00, 0.00***REMOVED***,
        [ 0.00, 0.00, 0.00, 0.00,  0.00, 0.00, 0.00, 0.00, 0.00, 0.00***REMOVED***,
        [ 0.00, 0.00, 0.00, 0.00,  0.00, 0.00, 0.00, 0.00, 0.00, 0.00***REMOVED******REMOVED******REMOVED***

    # 2***REMOVED*** Loads matrices to rotate components of gradient & Hessian
    #    vectors in the reference basis of triangle first apex (a0***REMOVED***
    rotate_dV = np.array([[ 1.,  0.***REMOVED***, [ 0.,  1.***REMOVED***,
                          [ 0.,  1.***REMOVED***, [-1., -1.***REMOVED***,
                          [-1., -1.***REMOVED***, [ 1.,  0.***REMOVED******REMOVED******REMOVED***

    rotate_d2V = np.array([[1., 0., 0.***REMOVED***, [0., 1., 0.***REMOVED***, [ 0.,  0.,  1.***REMOVED***,
                           [0., 1., 0.***REMOVED***, [1., 1., 1.***REMOVED***, [ 0., -2., -1.***REMOVED***,
                           [1., 1., 1.***REMOVED***, [1., 0., 0.***REMOVED***, [-2.,  0., -1.***REMOVED******REMOVED******REMOVED***

    # 3***REMOVED*** Loads Gauss points & weights on the 3 sub-_triangles for P2
    #    exact integral - 3 points on each subtriangles.
    # NOTE: as the 2nd derivative is discontinuous , we really need those 9
    # points!
    n_gauss = 9
    gauss_pts = np.array([[13./18.,  4./18.,  1./18.***REMOVED***,
                          [ 4./18., 13./18.,  1./18.***REMOVED***,
                          [ 7./18.,  7./18.,  4./18.***REMOVED***,
                          [ 1./18., 13./18.,  4./18.***REMOVED***,
                          [ 1./18.,  4./18., 13./18.***REMOVED***,
                          [ 4./18.,  7./18.,  7./18.***REMOVED***,
                          [ 4./18.,  1./18., 13./18.***REMOVED***,
                          [13./18.,  1./18.,  4./18.***REMOVED***,
                          [ 7./18.,  4./18.,  7./18.***REMOVED******REMOVED***, dtype=np.float64***REMOVED***
    gauss_w = np.ones([9***REMOVED***, dtype=np.float64***REMOVED*** / 9.

    #  4***REMOVED*** Stiffness matrix for curvature energy
    E = np.array([[1., 0., 0.***REMOVED***, [0., 1., 0.***REMOVED***, [0., 0., 2.***REMOVED******REMOVED******REMOVED***

    #  5***REMOVED*** Loads the matrix to compute DOF_rot from tri_J at apex 0
    J0_to_J1 = np.array([[-1.,  1.***REMOVED***, [-1.,  0.***REMOVED******REMOVED******REMOVED***
    J0_to_J2 = np.array([[ 0., -1.***REMOVED***, [ 1., -1.***REMOVED******REMOVED******REMOVED***

    def get_function_values(self, alpha, ecc, dofs***REMOVED***:
        ***REMOVED***
        Parameters
        ----------
        alpha : is a (N x 3 x 1***REMOVED*** array (array of column-matrices***REMOVED*** of
        barycentric coordinates,
        ecc : is a (N x 3 x 1***REMOVED*** array (array of column-matrices***REMOVED*** of triangle
        eccentricities,
        dofs : is a (N x 1 x 9***REMOVED*** arrays (arrays of row-matrices***REMOVED*** of computed
        degrees of freedom.

        Returns
        -------
        Returns the N-array of interpolated function values.
        ***REMOVED***
        subtri = np.argmin(alpha, axis=1***REMOVED***[:, 0***REMOVED***
        ksi = _roll_vectorized(alpha, -subtri, axis=0***REMOVED***
        E = _roll_vectorized(ecc, -subtri, axis=0***REMOVED***
        x = ksi[:, 0, 0***REMOVED***
        y = ksi[:, 1, 0***REMOVED***
        z = ksi[:, 2, 0***REMOVED***
        x_sq = x*x
        y_sq = y*y
        z_sq = z*z
        V = _to_matrix_vectorized([
            [x_sq*x***REMOVED***, [y_sq*y***REMOVED***, [z_sq*z***REMOVED***, [x_sq*z***REMOVED***, [x_sq*y***REMOVED***, [y_sq*x***REMOVED***,
            [y_sq*z***REMOVED***, [z_sq*y***REMOVED***, [z_sq*x***REMOVED***, [x*y*z***REMOVED******REMOVED******REMOVED***
        prod = _prod_vectorized(self.M, V***REMOVED***
        prod += _scalar_vectorized(E[:, 0, 0***REMOVED***,
                                   _prod_vectorized(self.M0, V***REMOVED******REMOVED***
        prod += _scalar_vectorized(E[:, 1, 0***REMOVED***,
                                   _prod_vectorized(self.M1, V***REMOVED******REMOVED***
        prod += _scalar_vectorized(E[:, 2, 0***REMOVED***,
                                   _prod_vectorized(self.M2, V***REMOVED******REMOVED***
        s = _roll_vectorized(prod, 3*subtri, axis=0***REMOVED***
        return _prod_vectorized(dofs, s***REMOVED***[:, 0, 0***REMOVED***

    def get_function_derivatives(self, alpha, J, ecc, dofs***REMOVED***:
        ***REMOVED***
        Parameters
        ----------
        *alpha* is a (N x 3 x 1***REMOVED*** array (array of column-matrices of
        barycentric coordinates***REMOVED***
        *J* is a (N x 2 x 2***REMOVED*** array of jacobian matrices (jacobian matrix at
        triangle first apex***REMOVED***
        *ecc* is a (N x 3 x 1***REMOVED*** array (array of column-matrices of triangle
        eccentricities***REMOVED***
        *dofs* is a (N x 1 x 9***REMOVED*** arrays (arrays of row-matrices***REMOVED*** of computed
        degrees of freedom.

        Returns
        -------
        Returns the values of interpolated function derivatives [dz/dx, dz/dy***REMOVED***
        in global coordinates at locations alpha, as a column-matrices of
        shape (N x 2 x 1***REMOVED***.
        ***REMOVED***
        subtri = np.argmin(alpha, axis=1***REMOVED***[:, 0***REMOVED***
        ksi = _roll_vectorized(alpha, -subtri, axis=0***REMOVED***
        E = _roll_vectorized(ecc, -subtri, axis=0***REMOVED***
        x = ksi[:, 0, 0***REMOVED***
        y = ksi[:, 1, 0***REMOVED***
        z = ksi[:, 2, 0***REMOVED***
        x_sq = x*x
        y_sq = y*y
        z_sq = z*z
        dV = _to_matrix_vectorized([
            [    -3.*x_sq,     -3.*x_sq***REMOVED***,
            [     3.*y_sq,           0.***REMOVED***,
            [          0.,      3.*z_sq***REMOVED***,
            [     -2.*x*z, -2.*x*z+x_sq***REMOVED***,
            [-2.*x*y+x_sq,      -2.*x*y***REMOVED***,
            [ 2.*x*y-y_sq,        -y_sq***REMOVED***,
            [      2.*y*z,         y_sq***REMOVED***,
            [        z_sq,       2.*y*z***REMOVED***,
            [       -z_sq,  2.*x*z-z_sq***REMOVED***,
            [     x*z-y*z,      x*y-y*z***REMOVED******REMOVED******REMOVED***
        # Puts back dV in first apex basis
        dV = _prod_vectorized(dV, _extract_submatrices(
            self.rotate_dV, subtri, block_size=2, axis=0***REMOVED******REMOVED***

        prod = _prod_vectorized(self.M, dV***REMOVED***
        prod += _scalar_vectorized(E[:, 0, 0***REMOVED***,
                                   _prod_vectorized(self.M0, dV***REMOVED******REMOVED***
        prod += _scalar_vectorized(E[:, 1, 0***REMOVED***,
                                   _prod_vectorized(self.M1, dV***REMOVED******REMOVED***
        prod += _scalar_vectorized(E[:, 2, 0***REMOVED***,
                                   _prod_vectorized(self.M2, dV***REMOVED******REMOVED***
        dsdksi = _roll_vectorized(prod, 3*subtri, axis=0***REMOVED***
        dfdksi = _prod_vectorized(dofs, dsdksi***REMOVED***
        # In global coordinates:
        # Here we try to deal with the simpliest colinear cases, returning a
        # null matrix.
        J_inv = _safe_inv22_vectorized(J***REMOVED***
        dfdx = _prod_vectorized(J_inv, _transpose_vectorized(dfdksi***REMOVED******REMOVED***
        return dfdx

    def get_function_hessians(self, alpha, J, ecc, dofs***REMOVED***:
        ***REMOVED***
        Parameters
        ----------
        *alpha* is a (N x 3 x 1***REMOVED*** array (array of column-matrices***REMOVED*** of
        barycentric coordinates
        *J* is a (N x 2 x 2***REMOVED*** array of jacobian matrices (jacobian matrix at
        triangle first apex***REMOVED***
        *ecc* is a (N x 3 x 1***REMOVED*** array (array of column-matrices***REMOVED*** of triangle
        eccentricities
        *dofs* is a (N x 1 x 9***REMOVED*** arrays (arrays of row-matrices***REMOVED*** of computed
        degrees of freedom.

        Returns
        -------
        Returns the values of interpolated function 2nd-derivatives
        [d2z/dx2, d2z/dy2, d2z/dxdy***REMOVED*** in global coordinates at locations alpha,
        as a column-matrices of shape (N x 3 x 1***REMOVED***.
        ***REMOVED***
        d2sdksi2 = self.get_d2Sidksij2(alpha, ecc***REMOVED***
        d2fdksi2 = _prod_vectorized(dofs, d2sdksi2***REMOVED***
        H_rot = self.get_Hrot_from_J(J***REMOVED***
        d2fdx2 = _prod_vectorized(d2fdksi2, H_rot***REMOVED***
        return _transpose_vectorized(d2fdx2***REMOVED***

    def get_d2Sidksij2(self, alpha, ecc***REMOVED***:
        ***REMOVED***
        Parameters
        ----------
        *alpha* is a (N x 3 x 1***REMOVED*** array (array of column-matrices***REMOVED*** of
        barycentric coordinates
        *ecc* is a (N x 3 x 1***REMOVED*** array (array of column-matrices***REMOVED*** of triangle
        eccentricities

        Returns
        -------
        Returns the arrays d2sdksi2 (N x 3 x 1***REMOVED*** Hessian of shape functions
        expressed in covariante coordinates in first apex basis.
        ***REMOVED***
        subtri = np.argmin(alpha, axis=1***REMOVED***[:, 0***REMOVED***
        ksi = _roll_vectorized(alpha, -subtri, axis=0***REMOVED***
        E = _roll_vectorized(ecc, -subtri, axis=0***REMOVED***
        x = ksi[:, 0, 0***REMOVED***
        y = ksi[:, 1, 0***REMOVED***
        z = ksi[:, 2, 0***REMOVED***
        d2V = _to_matrix_vectorized([
            [     6.*x,      6.*x,      6.*x***REMOVED***,
            [     6.*y,        0.,        0.***REMOVED***,
            [       0.,      6.*z,        0.***REMOVED***,
            [     2.*z, 2.*z-4.*x, 2.*z-2.*x***REMOVED***,
            [2.*y-4.*x,      2.*y, 2.*y-2.*x***REMOVED***,
            [2.*x-4.*y,        0.,     -2.*y***REMOVED***,
            [     2.*z,        0.,      2.*y***REMOVED***,
            [       0.,      2.*y,      2.*z***REMOVED***,
            [       0., 2.*x-4.*z,     -2.*z***REMOVED***,
            [    -2.*z,     -2.*y,     x-y-z***REMOVED******REMOVED******REMOVED***
        # Puts back d2V in first apex basis
        d2V = _prod_vectorized(d2V, _extract_submatrices(
            self.rotate_d2V, subtri, block_size=3, axis=0***REMOVED******REMOVED***
        prod = _prod_vectorized(self.M, d2V***REMOVED***
        prod += _scalar_vectorized(E[:, 0, 0***REMOVED***,
                                   _prod_vectorized(self.M0, d2V***REMOVED******REMOVED***
        prod += _scalar_vectorized(E[:, 1, 0***REMOVED***,
                                   _prod_vectorized(self.M1, d2V***REMOVED******REMOVED***
        prod += _scalar_vectorized(E[:, 2, 0***REMOVED***,
                                   _prod_vectorized(self.M2, d2V***REMOVED******REMOVED***
        d2sdksi2 = _roll_vectorized(prod, 3*subtri, axis=0***REMOVED***
        return d2sdksi2

    def get_bending_matrices(self, J, ecc***REMOVED***:
        ***REMOVED***
        Parameters
        ----------
        *J* is a (N x 2 x 2***REMOVED*** array of jacobian matrices (jacobian matrix at
        triangle first apex***REMOVED***
        *ecc* is a (N x 3 x 1***REMOVED*** array (array of column-matrices***REMOVED*** of triangle
        eccentricities

        Returns
        -------
        Returns the element K matrices for bending energy expressed in
        GLOBAL nodal coordinates.
        K_ij = integral [ (d2zi/dx2 + d2zi/dy2***REMOVED*** * (d2zj/dx2 + d2zj/dy2***REMOVED*** dA***REMOVED***
        tri_J is needed to rotate dofs from local basis to global basis
        ***REMOVED***
        n = np.size(ecc, 0***REMOVED***

        # 1***REMOVED*** matrix to rotate dofs in global coordinates
        J1 = _prod_vectorized(self.J0_to_J1, J***REMOVED***
        J2 = _prod_vectorized(self.J0_to_J2, J***REMOVED***
        DOF_rot = np.zeros([n, 9, 9***REMOVED***, dtype=np.float64***REMOVED***
        DOF_rot[:, 0, 0***REMOVED*** = 1
        DOF_rot[:, 3, 3***REMOVED*** = 1
        DOF_rot[:, 6, 6***REMOVED*** = 1
        DOF_rot[:, 1:3, 1:3***REMOVED*** = J
        DOF_rot[:, 4:6, 4:6***REMOVED*** = J1
        DOF_rot[:, 7:9, 7:9***REMOVED*** = J2

        # 2***REMOVED*** matrix to rotate Hessian in global coordinates.
        H_rot, area = self.get_Hrot_from_J(J, return_area=True***REMOVED***

        # 3***REMOVED*** Computes stiffness matrix
        # Gauss quadrature.
        K = np.zeros([n, 9, 9***REMOVED***, dtype=np.float64***REMOVED***
        weights = self.gauss_w
        pts = self.gauss_pts
        for igauss in range(self.n_gauss***REMOVED***:
            alpha = np.tile(pts[igauss, :***REMOVED***, n***REMOVED***.reshape(n, 3***REMOVED***
            alpha = np.expand_dims(alpha, 3***REMOVED***
            weight = weights[igauss***REMOVED***
            d2Skdksi2 = self.get_d2Sidksij2(alpha, ecc***REMOVED***
            d2Skdx2 = _prod_vectorized(d2Skdksi2, H_rot***REMOVED***
            K += weight * _prod_vectorized(_prod_vectorized(d2Skdx2, self.E***REMOVED***,
                                           _transpose_vectorized(d2Skdx2***REMOVED******REMOVED***

        # 4***REMOVED*** With nodal (not elem***REMOVED*** dofs
        K = _prod_vectorized(_prod_vectorized(_transpose_vectorized(DOF_rot***REMOVED***,
                                              K***REMOVED***, DOF_rot***REMOVED***

        # 5***REMOVED*** Need the area to compute total element energy
        return _scalar_vectorized(area, K***REMOVED***

    def get_Hrot_from_J(self, J, return_area=False***REMOVED***:
        ***REMOVED***
        Parameters
        ----------
        *J* is a (N x 2 x 2***REMOVED*** array of jacobian matrices (jacobian matrix at
        triangle first apex***REMOVED***

        Returns
        -------
        Returns H_rot used to rotate Hessian from local basis of first apex,
        to global coordinates.
        if *return_area* is True, returns also the triangle area (0.5*det(J***REMOVED******REMOVED***
        ***REMOVED***
        # Here we try to deal with the simpliest colinear cases ; a null
        # energy and area is imposed.
        J_inv = _safe_inv22_vectorized(J***REMOVED***
        Ji00 = J_inv[:, 0, 0***REMOVED***
        Ji11 = J_inv[:, 1, 1***REMOVED***
        Ji10 = J_inv[:, 1, 0***REMOVED***
        Ji01 = J_inv[:, 0, 1***REMOVED***
        H_rot = _to_matrix_vectorized([
            [Ji00*Ji00, Ji10*Ji10, Ji00*Ji10***REMOVED***,
            [Ji01*Ji01, Ji11*Ji11, Ji01*Ji11***REMOVED***,
            [2*Ji00*Ji01, 2*Ji11*Ji10, Ji00*Ji11+Ji10*Ji01***REMOVED******REMOVED******REMOVED***
        if not return_area:
            return H_rot
        else:
            area = 0.5 * (J[:, 0, 0***REMOVED****J[:, 1, 1***REMOVED*** - J[:, 0, 1***REMOVED****J[:, 1, 0***REMOVED******REMOVED***
            return H_rot, area

    def get_Kff_and_Ff(self, J, ecc, triangles, Uc***REMOVED***:
        ***REMOVED***
        Builds K and F for the following elliptic formulation:
        minimization of curvature energy with value of function at node
        imposed and derivatives 'free'.
        Builds the global Kff matrix in cco format.
        Builds the full Ff vec Ff = - Kfc x Uc

        Parameters
        ----------
        *J* is a (N x 2 x 2***REMOVED*** array of jacobian matrices (jacobian matrix at
        triangle first apex***REMOVED***
        *ecc* is a (N x 3 x 1***REMOVED*** array (array of column-matrices***REMOVED*** of triangle
        eccentricities
        *triangles* is a (N x 3***REMOVED*** array of nodes indexes.
        *Uc* is (N x 3***REMOVED*** array of imposed displacements at nodes

        Returns
        -------
        (Kff_rows, Kff_cols, Kff_vals***REMOVED*** Kff matrix in coo format - Duplicate
        (row, col***REMOVED*** entries must be summed.
        Ff: force vector - dim npts * 3
        ***REMOVED***
        ntri = np.size(ecc, 0***REMOVED***
        vec_range = np.arange(ntri, dtype=np.int32***REMOVED***
        c_indices = -np.ones(ntri, dtype=np.int32***REMOVED***  # for unused dofs, -1
        f_dof = [1, 2, 4, 5, 7, 8***REMOVED***
        c_dof = [0, 3, 6***REMOVED***

        # vals, rows and cols indices in global dof numbering
        f_dof_indices = _to_matrix_vectorized([[
            c_indices, triangles[:, 0***REMOVED****2, triangles[:, 0***REMOVED****2+1,
            c_indices, triangles[:, 1***REMOVED****2, triangles[:, 1***REMOVED****2+1,
            c_indices, triangles[:, 2***REMOVED****2, triangles[:, 2***REMOVED****2+1***REMOVED******REMOVED******REMOVED***

        expand_indices = np.ones([ntri, 9, 1***REMOVED***, dtype=np.int32***REMOVED***
        f_row_indices = _prod_vectorized(_transpose_vectorized(f_dof_indices***REMOVED***,
                                         _transpose_vectorized(expand_indices***REMOVED******REMOVED***
        f_col_indices = _prod_vectorized(expand_indices, f_dof_indices***REMOVED***
        K_elem = self.get_bending_matrices(J, ecc***REMOVED***

        # Extracting sub-matrices
        # Explanation & notations:
        # * Subscript f denotes 'free' degrees of freedom (i.e. dz/dx, dz/dx***REMOVED***
        # * Subscript c denotes 'condensated' (imposed***REMOVED*** degrees of freedom
        #    (i.e. z at all nodes***REMOVED***
        # * F = [Ff, Fc***REMOVED*** is the force vector
        # * U = [Uf, Uc***REMOVED*** is the imposed dof vector
        #        [ Kff Kfc ***REMOVED***
        # * K =  [         ***REMOVED***  is the laplacian stiffness matrix
        #        [ Kcf Kff ***REMOVED***
        # * As F = K x U one gets straightforwardly: Ff = - Kfc x Uc

        # Computing Kff stiffness matrix in sparse coo format
        Kff_vals = np.ravel(K_elem[np.ix_(vec_range, f_dof, f_dof***REMOVED******REMOVED******REMOVED***
        Kff_rows = np.ravel(f_row_indices[np.ix_(vec_range, f_dof, f_dof***REMOVED******REMOVED******REMOVED***
        Kff_cols = np.ravel(f_col_indices[np.ix_(vec_range, f_dof, f_dof***REMOVED******REMOVED******REMOVED***

        # Computing Ff force vector in sparse coo format
        Kfc_elem = K_elem[np.ix_(vec_range, f_dof, c_dof***REMOVED******REMOVED***
        Uc_elem = np.expand_dims(Uc, axis=2***REMOVED***
        Ff_elem = - _prod_vectorized(Kfc_elem, Uc_elem***REMOVED***[:, :, 0***REMOVED***
        Ff_indices = f_dof_indices[np.ix_(vec_range, [0***REMOVED***, f_dof***REMOVED******REMOVED***[:, 0, :***REMOVED***

        # Extracting Ff force vector in dense format
        # We have to sum duplicate indices -  using bincount
        Ff = np.bincount(np.ravel(Ff_indices***REMOVED***, weights=np.ravel(Ff_elem***REMOVED******REMOVED***
        return Kff_rows, Kff_cols, Kff_vals, Ff


# :class:_DOF_estimator, _DOF_estimator_user, _DOF_estimator_geom,
# _DOF_estimator_min_E
# Private classes used to compute the degree of freedom of each triangular
# element for the TriCubicInterpolator.
class _DOF_estimator(***REMOVED***:
    ***REMOVED***
    Abstract base class for classes used to perform estimation of a function
    first derivatives, and deduce the dofs for a CubicTriInterpolator using a
    reduced HCT element formulation.
    Derived classes implement compute_df(self,**kwargs***REMOVED***, returning
    np.vstack([dfx,dfy***REMOVED******REMOVED***.T where : dfx, dfy are the estimation of the 2
    gradient coordinates.
    ***REMOVED***
    def __init__(self, interpolator, **kwargs***REMOVED***:
        if not isinstance(interpolator, CubicTriInterpolator***REMOVED***:
            raise ValueError("Expected a CubicTriInterpolator object"***REMOVED***
        self._pts = interpolator._pts
        self._tris_pts = interpolator._tris_pts
        self.z = interpolator._z
        self._triangles = interpolator._triangles
        (self._unit_x, self._unit_y***REMOVED*** = (interpolator._unit_x,
                                        interpolator._unit_y***REMOVED***
        self.dz = self.compute_dz(**kwargs***REMOVED***
        self.compute_dof_from_df(***REMOVED***

    def compute_dz(self, **kwargs***REMOVED***:
        raise NotImplementedError

    def compute_dof_from_df(self***REMOVED***:
        ***REMOVED***
        Computes reduced-HCT elements degrees of freedom, knowing the
        gradient.
        ***REMOVED***
        J = CubicTriInterpolator._get_jacobian(self._tris_pts***REMOVED***
        tri_z = self.z[self._triangles***REMOVED***
        tri_dz = self.dz[self._triangles***REMOVED***
        tri_dof = self.get_dof_vec(tri_z, tri_dz, J***REMOVED***
        return tri_dof

    @staticmethod
    def get_dof_vec(tri_z, tri_dz, J***REMOVED***:
        ***REMOVED***
        Computes the dof vector of a triangle, knowing the value of f, df and
        of the local Jacobian at each node.

        *tri_z*: array of shape (3,***REMOVED*** of f nodal values
        *tri_dz*: array of shape (3,2***REMOVED*** of df/dx, df/dy nodal values
        *J*: Jacobian matrix in local basis of apex 0

        Returns dof array of shape (9,***REMOVED*** so that for each apex iapex:
            dof[iapex*3+0***REMOVED*** = f(Ai***REMOVED***
            dof[iapex*3+1***REMOVED*** = df(Ai***REMOVED***.(AiAi+***REMOVED***
            dof[iapex*3+2***REMOVED*** = df(Ai***REMOVED***.(AiAi-***REMOVED******REMOVED***
        ***REMOVED***
        npt = tri_z.shape[0***REMOVED***
        dof = np.zeros([npt, 9***REMOVED***, dtype=np.float64***REMOVED***
        J1 = _prod_vectorized(_ReducedHCT_Element.J0_to_J1, J***REMOVED***
        J2 = _prod_vectorized(_ReducedHCT_Element.J0_to_J2, J***REMOVED***

        col0 = _prod_vectorized(J, np.expand_dims(tri_dz[:, 0, :***REMOVED***, axis=3***REMOVED******REMOVED***
        col1 = _prod_vectorized(J1, np.expand_dims(tri_dz[:, 1, :***REMOVED***, axis=3***REMOVED******REMOVED***
        col2 = _prod_vectorized(J2, np.expand_dims(tri_dz[:, 2, :***REMOVED***, axis=3***REMOVED******REMOVED***

        dfdksi = _to_matrix_vectorized([
            [col0[:, 0, 0***REMOVED***, col1[:, 0, 0***REMOVED***, col2[:, 0, 0***REMOVED******REMOVED***,
            [col0[:, 1, 0***REMOVED***, col1[:, 1, 0***REMOVED***, col2[:, 1, 0***REMOVED******REMOVED******REMOVED******REMOVED***
        dof[:, 0:7:3***REMOVED*** = tri_z
        dof[:, 1:8:3***REMOVED*** = dfdksi[:, 0***REMOVED***
        dof[:, 2:9:3***REMOVED*** = dfdksi[:, 1***REMOVED***
        return dof


class _DOF_estimator_user(_DOF_estimator***REMOVED***:
    ***REMOVED*** dz is imposed by user / Accounts for scaling if any ***REMOVED***
    def compute_dz(self, dz***REMOVED***:
        (dzdx, dzdy***REMOVED*** = dz
        dzdx = dzdx * self._unit_x
        dzdy = dzdy * self._unit_y
        return np.vstack([dzdx, dzdy***REMOVED******REMOVED***.T


class _DOF_estimator_geom(_DOF_estimator***REMOVED***:
    ***REMOVED*** Fast 'geometric' approximation, recommended for large arrays. ***REMOVED***
    def compute_dz(self***REMOVED***:
        ***REMOVED***
        self.df is computed as weighted average of _triangles sharing a common
        node. On each triangle itri f is first assumed linear (= ~f***REMOVED***, which
        allows to compute d~f[itri***REMOVED***
        Then the following approximation of df nodal values is then proposed:
            f[ipt***REMOVED*** = SUM ( w[itri***REMOVED*** x d~f[itri***REMOVED*** , for itri sharing apex ipt***REMOVED***
        The weighted coeff. w[itri***REMOVED*** are proportional to the angle of the
        triangle itri at apex ipt
        ***REMOVED***
        el_geom_w = self.compute_geom_weights(***REMOVED***
        el_geom_grad = self.compute_geom_grads(***REMOVED***

        # Sum of weights coeffs
        w_node_sum = np.bincount(np.ravel(self._triangles***REMOVED***,
                                 weights=np.ravel(el_geom_w***REMOVED******REMOVED***

        # Sum of weighted df = (dfx, dfy***REMOVED***
        dfx_el_w = np.empty_like(el_geom_w***REMOVED***
        dfy_el_w = np.empty_like(el_geom_w***REMOVED***
        for iapex in range(3***REMOVED***:
            dfx_el_w[:, iapex***REMOVED*** = el_geom_w[:, iapex***REMOVED****el_geom_grad[:, 0***REMOVED***
            dfy_el_w[:, iapex***REMOVED*** = el_geom_w[:, iapex***REMOVED****el_geom_grad[:, 1***REMOVED***
        dfx_node_sum = np.bincount(np.ravel(self._triangles***REMOVED***,
                                   weights=np.ravel(dfx_el_w***REMOVED******REMOVED***
        dfy_node_sum = np.bincount(np.ravel(self._triangles***REMOVED***,
                                   weights=np.ravel(dfy_el_w***REMOVED******REMOVED***

        # Estimation of df
        dfx_estim = dfx_node_sum/w_node_sum
        dfy_estim = dfy_node_sum/w_node_sum
        return np.vstack([dfx_estim, dfy_estim***REMOVED******REMOVED***.T

    def compute_geom_weights(self***REMOVED***:
        ***REMOVED***
        Builds the (nelems x 3***REMOVED*** weights coeffs of _triangles angles,
        renormalized so that np.sum(weights, axis=1***REMOVED*** == np.ones(nelems***REMOVED***
        ***REMOVED***
        weights = np.zeros([np.size(self._triangles, 0***REMOVED***, 3***REMOVED******REMOVED***
        tris_pts = self._tris_pts
        for ipt in range(3***REMOVED***:
            p0 = tris_pts[:, (ipt***REMOVED*** % 3, :***REMOVED***
            p1 = tris_pts[:, (ipt+1***REMOVED*** % 3, :***REMOVED***
            p2 = tris_pts[:, (ipt-1***REMOVED*** % 3, :***REMOVED***
            alpha1 = np.arctan2(p1[:, 1***REMOVED***-p0[:, 1***REMOVED***, p1[:, 0***REMOVED***-p0[:, 0***REMOVED******REMOVED***
            alpha2 = np.arctan2(p2[:, 1***REMOVED***-p0[:, 1***REMOVED***, p2[:, 0***REMOVED***-p0[:, 0***REMOVED******REMOVED***
            # In the below formula we could take modulo 2. but
            # modulo 1. is safer regarding round-off errors (flat triangles***REMOVED***.
            angle = np.abs(np.mod((alpha2-alpha1***REMOVED*** / np.pi, 1.***REMOVED******REMOVED***
            # Weight proportional to angle up np.pi/2 ; null weight for
            # degenerated cases 0. and np.pi (Note that `angle` is normalized
            # by np.pi***REMOVED***
            weights[:, ipt***REMOVED*** = 0.5 - np.abs(angle-0.5***REMOVED***
        return weights

    def compute_geom_grads(self***REMOVED***:
        ***REMOVED***
        Compute the (global***REMOVED*** gradient component of f assumed linear (~f***REMOVED***.
        returns array df of shape (nelems,2***REMOVED***
        df[ielem***REMOVED***.dM[ielem***REMOVED*** = dz[ielem***REMOVED*** i.e. df = dz x dM = dM.T^-1 x dz
        ***REMOVED***
        tris_pts = self._tris_pts
        tris_f = self.z[self._triangles***REMOVED***

        dM1 = tris_pts[:, 1, :***REMOVED*** - tris_pts[:, 0, :***REMOVED***
        dM2 = tris_pts[:, 2, :***REMOVED*** - tris_pts[:, 0, :***REMOVED***
        dM = np.dstack([dM1, dM2***REMOVED******REMOVED***
        # Here we try to deal with the simpliest colinear cases: a null
        # gradient is assumed in this case.
        dM_inv = _safe_inv22_vectorized(dM***REMOVED***

        dZ1 = tris_f[:, 1***REMOVED*** - tris_f[:, 0***REMOVED***
        dZ2 = tris_f[:, 2***REMOVED*** - tris_f[:, 0***REMOVED***
        dZ = np.vstack([dZ1, dZ2***REMOVED******REMOVED***.T
        df = np.empty_like(dZ***REMOVED***

        # With np.einsum :  could be ej,eji -> ej
        df[:, 0***REMOVED*** = dZ[:, 0***REMOVED****dM_inv[:, 0, 0***REMOVED*** + dZ[:, 1***REMOVED****dM_inv[:, 1, 0***REMOVED***
        df[:, 1***REMOVED*** = dZ[:, 0***REMOVED****dM_inv[:, 0, 1***REMOVED*** + dZ[:, 1***REMOVED****dM_inv[:, 1, 1***REMOVED***
        return df


class _DOF_estimator_min_E(_DOF_estimator_geom***REMOVED***:
    ***REMOVED***
    The 'smoothest' approximation, df is computed through global minimization
    of the bending energy:
      E(f***REMOVED*** = integral[(d2z/dx2 + d2z/dy2 + 2 d2z/dxdy***REMOVED*****2 dA***REMOVED***
    ***REMOVED***
    def __init__(self, Interpolator***REMOVED***:
        self._eccs = Interpolator._eccs
        _DOF_estimator_geom.__init__(self, Interpolator***REMOVED***

    def compute_dz(self***REMOVED***:
        ***REMOVED***
        Elliptic solver for bending energy minimization.
        Uses a dedicated 'toy' sparse Jacobi PCG solver.
        ***REMOVED***
        # Initial guess for iterative PCG solver.
        dz_init = _DOF_estimator_geom.compute_dz(self***REMOVED***
        Uf0 = np.ravel(dz_init***REMOVED***

        reference_element = _ReducedHCT_Element(***REMOVED***
        J = CubicTriInterpolator._get_jacobian(self._tris_pts***REMOVED***
        eccs = self._eccs
        triangles = self._triangles
        Uc = self.z[self._triangles***REMOVED***

        # Building stiffness matrix and force vector in coo format
        Kff_rows, Kff_cols, Kff_vals, Ff = reference_element.get_Kff_and_Ff(
            J, eccs, triangles, Uc***REMOVED***

        # Building sparse matrix and solving minimization problem
        # We could use scipy.sparse direct solver ; however to avoid this
        # external dependency an implementation of a simple PCG solver with
        # a simplendiagonal Jocabi preconditioner is implemented.
        tol = 1.e-10
        n_dof = Ff.shape[0***REMOVED***
        Kff_coo = _Sparse_Matrix_coo(Kff_vals, Kff_rows, Kff_cols,
                                     shape=(n_dof, n_dof***REMOVED******REMOVED***
        Kff_coo.compress_csc(***REMOVED***
        Uf, err = _cg(A=Kff_coo, b=Ff, x0=Uf0, tol=tol***REMOVED***
        # If the PCG did not converge, we return the best guess between Uf0
        # and Uf.
        err0 = np.linalg.norm(Kff_coo.dot(Uf0***REMOVED*** - Ff***REMOVED***
        if err0 < err:
            # Maybe a good occasion to raise a warning here ?
            warnings.warn("In TriCubicInterpolator initialization, PCG sparse"
                          " solver did not converge after 1000 iterations. "
                          "`geom` approximation is used instead of `min_E`"***REMOVED***
            Uf = Uf0

        # Building dz from Uf
        dz = np.empty([self._pts.shape[0***REMOVED***, 2***REMOVED***, dtype=np.float64***REMOVED***
        dz[:, 0***REMOVED*** = Uf[::2***REMOVED***
        dz[:, 1***REMOVED*** = Uf[1::2***REMOVED***
        return dz


# The following private :class:_Sparse_Matrix_coo and :func:_cg provide
# a PCG sparse solver for (symmetric***REMOVED*** elliptic problems.
class _Sparse_Matrix_coo(object***REMOVED***:
    def __init__(self, vals, rows, cols, shape***REMOVED***:
        ***REMOVED***
        Creates a sparse matrix in coo format
        *vals*: arrays of values of non-null entries of the matrix
        *rows*: int arrays of rows of non-null entries of the matrix
        *cols*: int arrays of cols of non-null entries of the matrix
        *shape*: 2-tuple (n,m***REMOVED*** of matrix shape

        ***REMOVED***
        self.n, self.m = shape
        self.vals = np.asarray(vals, dtype=np.float64***REMOVED***
        self.rows = np.asarray(rows, dtype=np.int32***REMOVED***
        self.cols = np.asarray(cols, dtype=np.int32***REMOVED***

    def dot(self, V***REMOVED***:
        ***REMOVED***
        Dot product of self by a vector *V* in sparse-dense to dense format
        *V* dense vector of shape (self.m,***REMOVED***
        ***REMOVED***
        assert V.shape == (self.m,***REMOVED***
        # For a more generic implementation we could use below kw argument
        # minlength=self.m of bincount ; however:
        # - it is new in numpy 1.6
        # - it is unecessary when each row have at least 1 entry in global
        #   matrix, which is the case here.
        return np.bincount(self.rows, weights=self.vals*V[self.cols***REMOVED******REMOVED***

    def compress_csc(self***REMOVED***:
        ***REMOVED***
        Compress rows, cols, vals / summing duplicates. Sort for csc format.
        ***REMOVED***
        _, unique, indices = np.unique(
            self.rows + self.n*self.cols,
            return_index=True, return_inverse=True***REMOVED***
        self.rows = self.rows[unique***REMOVED***
        self.cols = self.cols[unique***REMOVED***
        self.vals = np.bincount(indices, weights=self.vals***REMOVED***

    def compress_csr(self***REMOVED***:
        ***REMOVED***
        Compress rows, cols, vals / summing duplicates. Sort for csr format.
        ***REMOVED***
        _, unique, indices = np.unique(
            self.m*self.rows + self.cols,
            return_index=True, return_inverse=True***REMOVED***
        self.rows = self.rows[unique***REMOVED***
        self.cols = self.cols[unique***REMOVED***
        self.vals = np.bincount(indices, weights=self.vals***REMOVED***

    def to_dense(self***REMOVED***:
        ***REMOVED***
        Returns a dense matrix representing self.
        Mainly for debugging purposes.
        ***REMOVED***
        ret = np.zeros([self.n, self.m***REMOVED***, dtype=np.float64***REMOVED***
        nvals = self.vals.size
        for i in range(nvals***REMOVED***:
            ret[self.rows[i***REMOVED***, self.cols[i***REMOVED******REMOVED*** += self.vals[i***REMOVED***
        return ret

    def __str__(self***REMOVED***:
        return self.to_dense(***REMOVED***.__str__(***REMOVED***

    @property
    def diag(self***REMOVED***:
        ***REMOVED***
        Returns the (dense***REMOVED*** vector of the diagonal elements.
        ***REMOVED***
        in_diag = (self.rows == self.cols***REMOVED***
        diag = np.zeros(min(self.n, self.n***REMOVED***, dtype=np.float64***REMOVED***  # default 0.
        diag[self.rows[in_diag***REMOVED******REMOVED*** = self.vals[in_diag***REMOVED***
        return diag


def _cg(A, b, x0=None, tol=1.e-10, maxiter=1000***REMOVED***:
    ***REMOVED***
    Use Preconditioned Conjugate Gradient iteration to solve A x = b
    A simple Jacobi (diagonal***REMOVED*** preconditionner is used.

    Parameters
    ----------
    A: _Sparse_Matrix_coo
        *A* must have been compressed before by compress_csc or
        compress_csr method.

    b: array
        Right hand side of the linear system.

    Returns
    ----------
    x: array.
        The converged solution.
    err: float
        The absolute error np.linalg.norm(A.dot(x***REMOVED*** - b***REMOVED***

    Other parameters
    ----------
    x0: array.
        Starting guess for the solution.
    tol: float.
        Tolerance to achieve. The algorithm terminates when the relative
        residual is below tol.
    maxiter: integer.
        Maximum number of iterations. Iteration will stop
        after maxiter steps even if the specified tolerance has not
        been achieved.
    ***REMOVED***
    n = b.size
    assert A.n == n
    assert A.m == n
    b_norm = np.linalg.norm(b***REMOVED***

    # Jacobi pre-conditioner
    kvec = A.diag
    # For diag elem < 1e-6 we keep 1e-6.
    kvec = np.where(kvec > 1.e-6, kvec, 1.e-6***REMOVED***

    # Initial guess
    if x0 is None:
        x = np.zeros(n***REMOVED***
    else:
        x = x0

    r = b - A.dot(x***REMOVED***
    w = r/kvec

    p = np.zeros(n***REMOVED***
    beta = 0.0
    rho = np.dot(r, w***REMOVED***
    k = 0

    # Following C. T. Kelley
    while (np.sqrt(abs(rho***REMOVED******REMOVED*** > tol*b_norm***REMOVED*** and (k < maxiter***REMOVED***:
        p = w + beta*p
        z = A.dot(p***REMOVED***
        alpha = rho/np.dot(p, z***REMOVED***
        r = r - alpha*z
        w = r/kvec
        rhoold = rho
        rho = np.dot(r, w***REMOVED***
        x = x + alpha*p
        beta = rho/rhoold
        #err = np.linalg.norm(A.dot(x***REMOVED*** - b***REMOVED*** # absolute accuracy - not used
        k += 1
    err = np.linalg.norm(A.dot(x***REMOVED*** - b***REMOVED***
    return x, err


# The following private functions:
#     :func:`_inv22_vectorized`
#     :func:`_safe_inv22_vectorized`
#     :func:`_pseudo_inv22sym_vectorized`
#     :func:`_prod_vectorized`
#     :func:`_scalar_vectorized`
#     :func:`_transpose_vectorized`
#     :func:`_roll_vectorized`
#     :func:`_to_matrix_vectorized`
#     :func:`_extract_submatrices`
# provide fast numpy implementation of some standard operations on arrays of
# matrices - stored as (:, n_rows, n_cols***REMOVED***-shaped np.arrays.
def _inv22_vectorized(M***REMOVED***:
    ***REMOVED***
    Inversion of arrays of (2,2***REMOVED*** matrices.
    ***REMOVED***
    assert (M.ndim == 3***REMOVED***
    assert (M.shape[-2:***REMOVED*** == (2, 2***REMOVED******REMOVED***
    M_inv = np.empty_like(M***REMOVED***
    delta_inv = np.reciprocal(M[:, 0, 0***REMOVED****M[:, 1, 1***REMOVED*** - M[:, 0, 1***REMOVED****M[:, 1, 0***REMOVED******REMOVED***
    M_inv[:, 0, 0***REMOVED*** = M[:, 1, 1***REMOVED****delta_inv
    M_inv[:, 0, 1***REMOVED*** = -M[:, 0, 1***REMOVED****delta_inv
    M_inv[:, 1, 0***REMOVED*** = -M[:, 1, 0***REMOVED****delta_inv
    M_inv[:, 1, 1***REMOVED*** = M[:, 0, 0***REMOVED****delta_inv
    return M_inv


# Development note: Dealing with pathologic 'flat' triangles in the
# CubicTriInterpolator code and impact on (2,2***REMOVED***-matrix inversion functions
# :func:`_safe_inv22_vectorized` and :func:`_pseudo_inv22sym_vectorized`.
#
# Goals:
# 1***REMOVED*** The CubicTriInterpolator should be able to handle flat or almost flat
#    triangles without raising an error,
# 2***REMOVED*** These degenerated triangles should have no impact on the automatic dof
#    calculation (associated with null weight for the _DOF_estimator_geom and
#    with null energy for the _DOF_estimator_min_E***REMOVED***,
# 3***REMOVED*** Linear patch test should be passed exactly on degenerated meshes,
# 4***REMOVED*** Interpolation (with :meth:`_interpolate_single_key` or
#    :meth:`_interpolate_multi_key`***REMOVED*** shall be correctly handled even *inside*
#    the pathologic triangles, to interact correctly with a TriRefiner class.
#
# Difficulties:
# Flat triangles have rank-deficient *J* (so-called jacobian matrix***REMOVED*** and
# *metric* (the metric tensor = J x J.T***REMOVED***. Computation of the local
# tangent plane is also problematic.
#
# Implementation:
# Most of the time, when computing the inverse of a rank-deficient matrix it
# is safe to simply return the null matrix (which is the implementation in
# :func:`_safe_inv22_vectorized`***REMOVED***. This is because of point 2***REMOVED***, itself
# enforced by:
#    - null area hence null energy in :class:`_DOF_estimator_min_E`
#    - angles close or equal to 0 or np.pi hence null weight in
#      :class:`_DOF_estimator_geom`.
#      Note that the function angle -> weight is continuous and maximum for an
#      angle np.pi/2 (refer to :meth:`compute_geom_weights`***REMOVED***
# The exception is the computation of barycentric coordinates, which is done
# by inversion of the *metric* matrix. In this case, we need to compute a set
# of valid coordinates (1 among numerous possibilities***REMOVED***, to ensure point 4***REMOVED***.
# We benefit here from the symmetry of metric = J x J.T, which makes it easier
# to compute a pseudo-inverse in :func:`_pseudo_inv22sym_vectorized`
def _safe_inv22_vectorized(M***REMOVED***:
    ***REMOVED***
    Inversion of arrays of (2,2***REMOVED*** matrices, returns 0 for rank-deficient
    matrices.

    *M* : array of (2,2***REMOVED*** matrices to inverse, shape (n,2,2***REMOVED***
    ***REMOVED***
    assert M.ndim == 3
    assert M.shape[-2:***REMOVED*** == (2, 2***REMOVED***
    M_inv = np.empty_like(M***REMOVED***
    prod1 = M[:, 0, 0***REMOVED****M[:, 1, 1***REMOVED***
    delta = prod1 - M[:, 0, 1***REMOVED****M[:, 1, 0***REMOVED***

    # We set delta_inv to 0. in case of a rank deficient matrix ; a
    # rank-deficient input matrix *M* will lead to a null matrix in output
    rank2 = (np.abs(delta***REMOVED*** > 1e-8*np.abs(prod1***REMOVED******REMOVED***
    if np.all(rank2***REMOVED***:
        # Normal 'optimized' flow.
        delta_inv = 1./delta
    else:
        # 'Pathologic' flow.
        delta_inv = np.zeros(M.shape[0***REMOVED******REMOVED***
        delta_inv[rank2***REMOVED*** = 1./delta[rank2***REMOVED***

    M_inv[:, 0, 0***REMOVED*** = M[:, 1, 1***REMOVED****delta_inv
    M_inv[:, 0, 1***REMOVED*** = -M[:, 0, 1***REMOVED****delta_inv
    M_inv[:, 1, 0***REMOVED*** = -M[:, 1, 0***REMOVED****delta_inv
    M_inv[:, 1, 1***REMOVED*** = M[:, 0, 0***REMOVED****delta_inv
    return M_inv


def _pseudo_inv22sym_vectorized(M***REMOVED***:
    ***REMOVED***
    Inversion of arrays of (2,2***REMOVED*** SYMMETRIC matrices ; returns the
    (Moore-Penrose***REMOVED*** pseudo-inverse for rank-deficient matrices.

    In case M is of rank 1, we have M = trace(M***REMOVED*** x P where P is the orthogonal
    projection on Im(M***REMOVED***, and we return trace(M***REMOVED***^-1 x P == M / trace(M***REMOVED*****2
    In case M is of rank 0, we return the null matrix.

    *M* : array of (2,2***REMOVED*** matrices to inverse, shape (n,2,2***REMOVED***
    ***REMOVED***
    assert M.ndim == 3
    assert M.shape[-2:***REMOVED*** == (2, 2***REMOVED***
    M_inv = np.empty_like(M***REMOVED***
    prod1 = M[:, 0, 0***REMOVED****M[:, 1, 1***REMOVED***
    delta = prod1 - M[:, 0, 1***REMOVED****M[:, 1, 0***REMOVED***
    rank2 = (np.abs(delta***REMOVED*** > 1e-8*np.abs(prod1***REMOVED******REMOVED***

    if np.all(rank2***REMOVED***:
        # Normal 'optimized' flow.
        M_inv[:, 0, 0***REMOVED*** = M[:, 1, 1***REMOVED*** / delta
        M_inv[:, 0, 1***REMOVED*** = -M[:, 0, 1***REMOVED*** / delta
        M_inv[:, 1, 0***REMOVED*** = -M[:, 1, 0***REMOVED*** / delta
        M_inv[:, 1, 1***REMOVED*** = M[:, 0, 0***REMOVED*** / delta
    else:
        # 'Pathologic' flow.
        # Here we have to deal with 2 sub-cases
        # 1***REMOVED*** First sub-case: matrices of rank 2:
        delta = delta[rank2***REMOVED***
        M_inv[rank2, 0, 0***REMOVED*** = M[rank2, 1, 1***REMOVED*** / delta
        M_inv[rank2, 0, 1***REMOVED*** = -M[rank2, 0, 1***REMOVED*** / delta
        M_inv[rank2, 1, 0***REMOVED*** = -M[rank2, 1, 0***REMOVED*** / delta
        M_inv[rank2, 1, 1***REMOVED*** = M[rank2, 0, 0***REMOVED*** / delta
        # 2***REMOVED*** Second sub-case: rank-deficient matrices of rank 0 and 1:
        rank01 = ~rank2
        tr = M[rank01, 0, 0***REMOVED*** + M[rank01, 1, 1***REMOVED***
        tr_zeros = (np.abs(tr***REMOVED*** < 1.e-8***REMOVED***
        sq_tr_inv = (1.-tr_zeros***REMOVED*** / (tr**2+tr_zeros***REMOVED***
        #sq_tr_inv = 1. / tr**2
        M_inv[rank01, 0, 0***REMOVED*** = M[rank01, 0, 0***REMOVED*** * sq_tr_inv
        M_inv[rank01, 0, 1***REMOVED*** = M[rank01, 0, 1***REMOVED*** * sq_tr_inv
        M_inv[rank01, 1, 0***REMOVED*** = M[rank01, 1, 0***REMOVED*** * sq_tr_inv
        M_inv[rank01, 1, 1***REMOVED*** = M[rank01, 1, 1***REMOVED*** * sq_tr_inv

    return M_inv


def _prod_vectorized(M1, M2***REMOVED***:
    ***REMOVED***
    Matrix product between arrays of matrices, or a matrix and an array of
    matrices (*M1* and *M2****REMOVED***
    ***REMOVED***
    sh1 = M1.shape
    sh2 = M2.shape
    assert len(sh1***REMOVED*** >= 2
    assert len(sh2***REMOVED*** >= 2
    assert sh1[-1***REMOVED*** == sh2[-2***REMOVED***

    ndim1 = len(sh1***REMOVED***
    t1_index = list(xrange(ndim1-2***REMOVED******REMOVED*** + [ndim1-1, ndim1-2***REMOVED***
    return np.sum(np.transpose(M1, t1_index***REMOVED***[..., np.newaxis***REMOVED*** *
                  M2[..., np.newaxis, :***REMOVED***, -3***REMOVED***


def _scalar_vectorized(scalar, M***REMOVED***:
    ***REMOVED***
    Scalar product between scalars and matrices.
    ***REMOVED***
    return scalar[:, np.newaxis, np.newaxis***REMOVED****M


def _transpose_vectorized(M***REMOVED***:
    ***REMOVED***
    Transposition of an array of matrices *M*.
    ***REMOVED***
    ndim = M.ndim
    assert ndim == 3
    return np.transpose(M, [0, ndim-1, ndim-2***REMOVED******REMOVED***


def _roll_vectorized(M, roll_indices, axis***REMOVED***:
    ***REMOVED***
    Rolls an array of matrices along an axis according to an array of indices
    *roll_indices*
    *axis* can be either 0 (rolls rows***REMOVED*** or 1 (rolls columns***REMOVED***.
    ***REMOVED***
    assert axis in [0, 1***REMOVED***
    ndim = M.ndim
    assert ndim == 3
    ndim_roll = roll_indices.ndim
    assert ndim_roll == 1
    sh = M.shape
    r, c = sh[-2:***REMOVED***
    assert sh[0***REMOVED*** == roll_indices.shape[0***REMOVED***
    vec_indices = np.arange(sh[0***REMOVED***, dtype=np.int32***REMOVED***

    # Builds the rolled matrix
    M_roll = np.empty_like(M***REMOVED***
    if axis == 0:
        for ir in range(r***REMOVED***:
            for ic in range(c***REMOVED***:
                M_roll[:, ir, ic***REMOVED*** = M[vec_indices, (-roll_indices+ir***REMOVED*** % r, ic***REMOVED***
    elif axis == 1:
        for ir in range(r***REMOVED***:
            for ic in range(c***REMOVED***:
                M_roll[:, ir, ic***REMOVED*** = M[vec_indices, ir, (-roll_indices+ic***REMOVED*** % c***REMOVED***
    return M_roll


def _to_matrix_vectorized(M***REMOVED***:
    ***REMOVED***
    Builds an array of matrices from individuals np.arrays of identical
    shapes.
    *M*: ncols-list of nrows-lists of shape sh.

    Returns M_res np.array of shape (sh, nrow, ncols***REMOVED*** so that:
        M_res[...,i,j***REMOVED*** = M[i***REMOVED***[j***REMOVED***
    ***REMOVED***
    assert isinstance(M, (tuple, list***REMOVED******REMOVED***
    assert all([isinstance(item, (tuple, list***REMOVED******REMOVED*** for item in M***REMOVED******REMOVED***
    c_vec = np.asarray([len(item***REMOVED*** for item in M***REMOVED******REMOVED***
    assert np.all(c_vec-c_vec[0***REMOVED*** == 0***REMOVED***
    r = len(M***REMOVED***
    c = c_vec[0***REMOVED***
    M00 = np.asarray(M[0***REMOVED***[0***REMOVED******REMOVED***
    dt = M00.dtype
    sh = [M00.shape[0***REMOVED***, r, c***REMOVED***
    M_ret = np.empty(sh, dtype=dt***REMOVED***
    for irow in range(r***REMOVED***:
        for icol in range(c***REMOVED***:
            M_ret[:, irow, icol***REMOVED*** = np.asarray(M[irow***REMOVED***[icol***REMOVED******REMOVED***
    return M_ret


def _extract_submatrices(M, block_indices, block_size, axis***REMOVED***:
    ***REMOVED***
    Extracts selected blocks of a matrices *M* depending on parameters
    *block_indices* and *block_size*.

    Returns the array of extracted matrices *Mres* so that:
        M_res[...,ir,:***REMOVED*** = M[(block_indices*block_size+ir***REMOVED***, :***REMOVED***
    ***REMOVED***
    assert block_indices.ndim == 1
    assert axis in [0, 1***REMOVED***

    r, c = M.shape
    if axis == 0:
        sh = [block_indices.shape[0***REMOVED***, block_size, c***REMOVED***
    elif axis == 1:
        sh = [block_indices.shape[0***REMOVED***, r, block_size***REMOVED***

    dt = M.dtype
    M_res = np.empty(sh, dtype=dt***REMOVED***
    if axis == 0:
        for ir in range(block_size***REMOVED***:
            M_res[:, ir, :***REMOVED*** = M[(block_indices*block_size+ir***REMOVED***, :***REMOVED***
    elif axis == 1:
        for ic in range(block_size***REMOVED***:
            M_res[:, :, ic***REMOVED*** = M[:, (block_indices*block_size+ic***REMOVED******REMOVED***

    return M_res
