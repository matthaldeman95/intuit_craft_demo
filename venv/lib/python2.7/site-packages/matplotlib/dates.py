#!/usr/bin/env python
***REMOVED***
Matplotlib provides sophisticated date plotting capabilities, standing on the
shoulders of python :mod:`datetime`, the add-on modules :mod:`pytz` and
:mod:`dateutil`.  :class:`datetime` objects are converted to floating point
numbers which represent time in days since 0001-01-01 UTC, plus 1.  For
example, 0001-01-01, 06:00 is 1.25, not 0.25.  The helper functions
:func:`date2num`, :func:`num2date` and :func:`drange` are used to facilitate
easy conversion to and from :mod:`datetime` and numeric ranges.

.. note::

   Like Python's datetime, mpl uses the Gregorian calendar for all
   conversions between dates and floating point numbers. This practice
   is not universal, and calendar differences can cause confusing
   differences between what Python and mpl give as the number of days
   since 0001-01-01 and what other software and databases yield.  For
   example, the US Naval Observatory uses a calendar that switches
   from Julian to Gregorian in October, 1582.  Hence, using their
   calculator, the number of days between 0001-01-01 and 2006-04-01 is
   732403, whereas using the Gregorian calendar via the datetime
   module we find::

     In [31***REMOVED***:date(2006,4,1***REMOVED***.toordinal(***REMOVED*** - date(1,1,1***REMOVED***.toordinal(***REMOVED***
     Out[31***REMOVED***:732401


A wide range of specific and general purpose date tick locators and
formatters are provided in this module.  See
:mod:`matplotlib.ticker` for general information on tick locators
and formatters.  These are described below.

All the matplotlib date converters, tickers and formatters are
timezone aware, and the default timezone is given by the timezone
parameter in your :file:`matplotlibrc` file.  If you leave out a
:class:`tz` timezone instance, the default from your rc file will be
assumed.  If you want to use a custom time zone, pass a
:class:`pytz.timezone` instance with the tz keyword argument to
:func:`num2date`, :func:`plot_date`, and any custom date tickers or
locators you create.  See `pytz <http://pythonhosted.org/pytz/>`_ for
information on :mod:`pytz` and timezone handling.

The `dateutil module <https://dateutil.readthedocs.org>`_ provides
additional code to handle date ticking, making it easy to place ticks
on any kinds of dates.  See examples below.

Date tickers
------------

Most of the date tickers can locate single or multiple values.  For
example::

    # import constants for the days of the week
    from matplotlib.dates import MO, TU, WE, TH, FR, SA, SU

    # tick on mondays every week
    loc = WeekdayLocator(byweekday=MO, tz=tz***REMOVED***

    # tick on mondays and saturdays
    loc = WeekdayLocator(byweekday=(MO, SA***REMOVED******REMOVED***

In addition, most of the constructors take an interval argument::

    # tick on mondays every second week
    loc = WeekdayLocator(byweekday=MO, interval=2***REMOVED***

The rrule locator allows completely general date ticking::

    # tick every 5th easter
    rule = rrulewrapper(YEARLY, byeaster=1, interval=5***REMOVED***
    loc = RRuleLocator(rule***REMOVED***

Here are all the date tickers:

    * :class:`MinuteLocator`: locate minutes

    * :class:`HourLocator`: locate hours

    * :class:`DayLocator`: locate specifed days of the month

    * :class:`WeekdayLocator`: Locate days of the week, e.g., MO, TU

    * :class:`MonthLocator`: locate months, e.g., 7 for july

    * :class:`YearLocator`: locate years that are multiples of base

    * :class:`RRuleLocator`: locate using a
      :class:`matplotlib.dates.rrulewrapper`.  The
      :class:`rrulewrapper` is a simple wrapper around a
      :class:`dateutil.rrule` (`dateutil
      <https://dateutil.readthedocs.org>`_***REMOVED*** which allow almost
      arbitrary date tick specifications.  See `rrule example
      <../examples/pylab_examples/date_demo_rrule.html>`_.

    * :class:`AutoDateLocator`: On autoscale, this class picks the best
      :class:`MultipleDateLocator` to set the view limits and the tick
      locations.

Date formatters
---------------

Here all all the date formatters:

    * :class:`AutoDateFormatter`: attempts to figure out the best format
      to use.  This is most useful when used with the :class:`AutoDateLocator`.

    * :class:`DateFormatter`: use :func:`strftime` format strings

    * :class:`IndexDateFormatter`: date plots with implicit *x*
      indexing.
***REMOVED***
from __future__ import (absolute_import, division, print_function,
                        unicode_literals***REMOVED***

from matplotlib.externals import six
from matplotlib.externals.six.moves import xrange, zip

import re
import time
import math
import datetime

import warnings


from dateutil.rrule import (rrule, MO, TU, WE, TH, FR, SA, SU, YEARLY,
                            MONTHLY, WEEKLY, DAILY, HOURLY, MINUTELY,
                            SECONDLY***REMOVED***
from dateutil.relativedelta import relativedelta
import dateutil.parser
import numpy as np


import matplotlib
import matplotlib.units as units
import matplotlib.cbook as cbook
import matplotlib.ticker as ticker


__all__ = ('date2num', 'num2date', 'drange', 'epoch2num',
           'num2epoch', 'mx2num', 'DateFormatter',
           'IndexDateFormatter', 'AutoDateFormatter', 'DateLocator',
           'RRuleLocator', 'AutoDateLocator', 'YearLocator',
           'MonthLocator', 'WeekdayLocator',
           'DayLocator', 'HourLocator', 'MinuteLocator',
           'SecondLocator', 'MicrosecondLocator',
           'rrule', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA', 'SU',
           'YEARLY', 'MONTHLY', 'WEEKLY', 'DAILY',
           'HOURLY', 'MINUTELY', 'SECONDLY', 'MICROSECONDLY', 'relativedelta',
           'seconds', 'minutes', 'hours', 'weeks'***REMOVED***


# Make a simple UTC instance so we don't always have to import
# pytz.  From the python datetime library docs:

class _UTC(datetime.tzinfo***REMOVED***:
    ***REMOVED***UTC***REMOVED***

    def utcoffset(self, dt***REMOVED***:
        return datetime.timedelta(0***REMOVED***

    def tzname(self, dt***REMOVED***:
        return "UTC"

    def dst(self, dt***REMOVED***:
        return datetime.timedelta(0***REMOVED***

UTC = _UTC(***REMOVED***


def _get_rc_timezone(***REMOVED***:
    ***REMOVED***
    Retrieve the preferred timeszone from the rcParams dictionary.
    ***REMOVED***
    s = matplotlib.rcParams['timezone'***REMOVED***
    if s == 'UTC':
        return UTC
    import pytz
    return pytz.timezone(s***REMOVED***

***REMOVED***
Time-related constants.
***REMOVED***
EPOCH_OFFSET = float(datetime.datetime(1970, 1, 1***REMOVED***.toordinal(***REMOVED******REMOVED***
JULIAN_OFFSET = 1721424.5                         # Julian date at 0001-01-01
MICROSECONDLY = SECONDLY + 1
HOURS_PER_DAY = 24.
MIN_PER_HOUR = 60.
SEC_PER_MIN = 60.
MONTHS_PER_YEAR = 12.

DAYS_PER_WEEK = 7.
DAYS_PER_MONTH = 30.
DAYS_PER_YEAR = 365.0

MINUTES_PER_DAY = MIN_PER_HOUR * HOURS_PER_DAY

SEC_PER_HOUR = SEC_PER_MIN * MIN_PER_HOUR
SEC_PER_DAY = SEC_PER_HOUR * HOURS_PER_DAY
SEC_PER_WEEK = SEC_PER_DAY * DAYS_PER_WEEK

MUSECONDS_PER_DAY = 1e6 * SEC_PER_DAY

MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY = (
    MO, TU, WE, TH, FR, SA, SU***REMOVED***
WEEKDAYS = (MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY***REMOVED***


def _to_ordinalf(dt***REMOVED***:
    ***REMOVED***
    Convert :mod:`datetime` or :mod:`date` to the Gregorian date as UTC float
    days, preserving hours, minutes, seconds and microseconds.  Return value
    is a :func:`float`.
    ***REMOVED***

    if hasattr(dt, 'tzinfo'***REMOVED*** and dt.tzinfo is not None:
        delta = dt.tzinfo.utcoffset(dt***REMOVED***
        if delta is not None:
            dt -= delta

    base = float(dt.toordinal(***REMOVED******REMOVED***
    if isinstance(dt, datetime.datetime***REMOVED***:
        # Get a datetime object at midnight in the same time zone as dt.
        cdate = dt.date(***REMOVED***
        midnight_time = datetime.time(0, 0, 0, tzinfo=dt.tzinfo***REMOVED***

        rdt = datetime.datetime.combine(cdate, midnight_time***REMOVED***
        td_remainder = _total_seconds(dt - rdt***REMOVED***

        if td_remainder > 0:
            base += td_remainder / SEC_PER_DAY

    return base


# a version of _to_ordinalf that can operate on numpy arrays
_to_ordinalf_np_vectorized = np.vectorize(_to_ordinalf***REMOVED***

***REMOVED***
    # Available as a native method in Python >= 2.7.
    _total_seconds = datetime.timedelta.total_seconds
except AttributeError:
    def _total_seconds(tdelta***REMOVED***:
        ***REMOVED***
        Alias providing support for datetime.timedelta.total_seconds(***REMOVED*** function
        calls even in Python < 2.7.

        The input `tdelta` is a datetime.timedelta object, and returns a float
        containing the total number of seconds representing the `tdelta`
        duration. For large durations (> 270 on most platforms***REMOVED***, this loses
        microsecond accuracy.
        ***REMOVED***
        return (tdelta.microseconds +
                (tdelta.seconds + tdelta.days * SEC_PER_DAY***REMOVED*** * 1e6***REMOVED*** * 1e-6


def _from_ordinalf(x, tz=None***REMOVED***:
    ***REMOVED***
    Convert Gregorian float of the date, preserving hours, minutes,
    seconds and microseconds.  Return value is a :class:`datetime`.

    The input date `x` is a float in ordinal days at UTC, and the output will
    be the specified :class:`datetime` object corresponding to that time in
    timezone `tz`, or if `tz` is `None`, in the timezone specified in
    `rcParams['timezone'***REMOVED***`.
    ***REMOVED***
    if tz is None:
        tz = _get_rc_timezone(***REMOVED***

    ix = int(x***REMOVED***
    dt = datetime.datetime.fromordinal(ix***REMOVED***.replace(tzinfo=UTC***REMOVED***

    remainder = float(x***REMOVED*** - ix

    # Round down to the nearest microsecond.
    dt += datetime.timedelta(microseconds=int(remainder * MUSECONDS_PER_DAY***REMOVED******REMOVED***

    # Compensate for rounding errors
    if dt.microsecond < 10:
        dt = dt.replace(microsecond=0***REMOVED***
    elif dt.microsecond > 999990:
        dt += datetime.timedelta(microseconds=1e6 - dt.microsecond***REMOVED***

    return dt.astimezone(tz***REMOVED***


# a version of _from_ordinalf that can operate on numpy arrays
_from_ordinalf_np_vectorized = np.vectorize(_from_ordinalf***REMOVED***


class strpdate2num(object***REMOVED***:
    ***REMOVED***
    Use this class to parse date strings to matplotlib datenums when
    you know the date format string of the date you are parsing.  See
    :file:`examples/load_demo.py`.
    ***REMOVED***
    def __init__(self, fmt***REMOVED***:
        ***REMOVED*** fmt: any valid strptime format is supported ***REMOVED***
        self.fmt = fmt

    def __call__(self, s***REMOVED***:
        ***REMOVED***s : string to be converted
           return value: a date2num float
        ***REMOVED***
        return date2num(datetime.datetime(*time.strptime(s, self.fmt***REMOVED***[:6***REMOVED******REMOVED******REMOVED***


class bytespdate2num(strpdate2num***REMOVED***:
    ***REMOVED***
    Use this class to parse date strings to matplotlib datenums when
    you know the date format string of the date you are parsing.  See
    :file:`examples/load_demo.py`.
    ***REMOVED***
    def __init__(self, fmt, encoding='utf-8'***REMOVED***:
        ***REMOVED***
        Args:
            fmt: any valid strptime format is supported
            encoding: encoding to use on byte input (default: 'utf-8'***REMOVED***
        ***REMOVED***
        super(bytespdate2num, self***REMOVED***.__init__(fmt***REMOVED***
        self.encoding = encoding

    def __call__(self, b***REMOVED***:
        ***REMOVED***
        Args:
            b: byte input to be converted
        Returns:
            A date2num float
        ***REMOVED***
        s = b.decode(self.encoding***REMOVED***
        return super(bytespdate2num, self***REMOVED***.__call__(s***REMOVED***


# a version of dateutil.parser.parse that can operate on nump0y arrays
_dateutil_parser_parse_np_vectorized = np.vectorize(dateutil.parser.parse***REMOVED***


def datestr2num(d, default=None***REMOVED***:
    ***REMOVED***
    Convert a date string to a datenum using
    :func:`dateutil.parser.parse`.

    Parameters
    ----------
    d : string or sequence of strings
        The dates to convert.

    default : datetime instance
        The default date to use when fields are missing in `d`.
    ***REMOVED***
    if cbook.is_string_like(d***REMOVED***:
        dt = dateutil.parser.parse(d, default=default***REMOVED***
        return date2num(dt***REMOVED***
    else:
        if default is not None:
            d = [dateutil.parser.parse(s, default=default***REMOVED*** for s in d***REMOVED***
        d = np.asarray(d***REMOVED***
        if not d.size:
            return d
        return date2num(_dateutil_parser_parse_np_vectorized(d***REMOVED******REMOVED***


def date2num(d***REMOVED***:
    ***REMOVED***
    *d* is either a :class:`datetime` instance or a sequence of datetimes.

    Return value is a floating point number (or sequence of floats***REMOVED***
    which gives the number of days (fraction part represents hours,
    minutes, seconds***REMOVED*** since 0001-01-01 00:00:00 UTC, *plus* *one*.
    The addition of one here is a historical artifact.  Also, note
    that the Gregorian calendar is assumed; this is not universal
    practice.  For details, see the module docstring.
    ***REMOVED***
    if not cbook.iterable(d***REMOVED***:
        return _to_ordinalf(d***REMOVED***
    else:
        d = np.asarray(d***REMOVED***
        if not d.size:
            return d
        return _to_ordinalf_np_vectorized(d***REMOVED***


def julian2num(j***REMOVED***:
    ***REMOVED***
    Convert a Julian date (or sequence***REMOVED*** to a matplotlib date (or sequence***REMOVED***.
    ***REMOVED***
    if cbook.iterable(j***REMOVED***:
        j = np.asarray(j***REMOVED***
    return j - JULIAN_OFFSET


def num2julian(n***REMOVED***:
    ***REMOVED***
    Convert a matplotlib date (or sequence***REMOVED*** to a Julian date (or sequence***REMOVED***.
    ***REMOVED***
    if cbook.iterable(n***REMOVED***:
        n = np.asarray(n***REMOVED***
    return n + JULIAN_OFFSET


def num2date(x, tz=None***REMOVED***:
    ***REMOVED***
    *x* is a float value which gives the number of days
    (fraction part represents hours, minutes, seconds***REMOVED*** since
    0001-01-01 00:00:00 UTC *plus* *one*.
    The addition of one here is a historical artifact.  Also, note
    that the Gregorian calendar is assumed; this is not universal
    practice.  For details, see the module docstring.

    Return value is a :class:`datetime` instance in timezone *tz* (default to
    rcparams TZ value***REMOVED***.

    If *x* is a sequence, a sequence of :class:`datetime` objects will
    be returned.
    ***REMOVED***
    if tz is None:
        tz = _get_rc_timezone(***REMOVED***
    if not cbook.iterable(x***REMOVED***:
        return _from_ordinalf(x, tz***REMOVED***
    else:
        x = np.asarray(x***REMOVED***
        if not x.size:
            return x
        return _from_ordinalf_np_vectorized(x, tz***REMOVED***.tolist(***REMOVED***


def drange(dstart, dend, delta***REMOVED***:
    ***REMOVED***
    Return a date range as float Gregorian ordinals.  *dstart* and
    *dend* are :class:`datetime` instances.  *delta* is a
    :class:`datetime.timedelta` instance.
    ***REMOVED***
    f1 = _to_ordinalf(dstart***REMOVED***
    f2 = _to_ordinalf(dend***REMOVED***
    step = _total_seconds(delta***REMOVED*** / SEC_PER_DAY

    # calculate the difference between dend and dstart in times of delta
    num = int(np.ceil((f2 - f1***REMOVED*** / step***REMOVED******REMOVED***

    # calculate end of the interval which will be generated
    dinterval_end = dstart + num * delta

    # ensure, that an half open interval will be generated [dstart, dend***REMOVED***
    if dinterval_end >= dend:
        # if the endpoint is greated than dend, just subtract one delta
        dinterval_end -= delta
        num -= 1

    f2 = _to_ordinalf(dinterval_end***REMOVED***  # new float-endpoint
    return np.linspace(f1, f2, num + 1***REMOVED***

### date tickers and formatters ###


class DateFormatter(ticker.Formatter***REMOVED***:
    ***REMOVED***
    Tick location is seconds since the epoch.  Use a :func:`strftime`
    format string.

    Python only supports :mod:`datetime` :func:`strftime` formatting
    for years greater than 1900.  Thanks to Andrew Dalke, Dalke
    Scientific Software who contributed the :func:`strftime` code
    below to include dates earlier than this year.
    ***REMOVED***

    illegal_s = re.compile(r"((^|[^%***REMOVED******REMOVED***(%%***REMOVED****%s***REMOVED***"***REMOVED***

    def __init__(self, fmt, tz=None***REMOVED***:
        ***REMOVED***
        *fmt* is a :func:`strftime` format string; *tz* is the
         :class:`tzinfo` instance.
        ***REMOVED***
        if tz is None:
            tz = _get_rc_timezone(***REMOVED***
        self.fmt = fmt
        self.tz = tz

    def __call__(self, x, pos=0***REMOVED***:
        if x == 0:
            raise ValueError('DateFormatter found a value of x=0, which is '
                             'an illegal date.  This usually occurs because '
                             'you have not informed the axis that it is '
                             'plotting dates, e.g., with ax.xaxis_date(***REMOVED***'***REMOVED***
        dt = num2date(x, self.tz***REMOVED***
        return self.strftime(dt, self.fmt***REMOVED***

    def set_tzinfo(self, tz***REMOVED***:
        self.tz = tz

    def _replace_common_substr(self, s1, s2, sub1, sub2, replacement***REMOVED***:
        ***REMOVED***Helper function for replacing substrings sub1 and sub2
        located at the same indexes in strings s1 and s2 respectively,
        with the string replacement.  It is expected that sub1 and sub2
        have the same length.  Returns the pair s1, s2 after the
        substitutions.
        ***REMOVED***
        # Find common indexes of substrings sub1 in s1 and sub2 in s2
        # and make substitutions inplace. Because this is inplace,
        # it is okay if len(replacement***REMOVED*** != len(sub1***REMOVED***, len(sub2***REMOVED***.
        i = 0
        while True:
            j = s1.find(sub1, i***REMOVED***
            if j == -1:
                break

            i = j + 1
            if s2[j:j + len(sub2***REMOVED******REMOVED*** != sub2:
                continue

            s1 = s1[:j***REMOVED*** + replacement + s1[j + len(sub1***REMOVED***:***REMOVED***
            s2 = s2[:j***REMOVED*** + replacement + s2[j + len(sub2***REMOVED***:***REMOVED***

        return s1, s2

    def strftime_pre_1900(self, dt, fmt=None***REMOVED***:
        ***REMOVED***Call time.strftime for years before 1900 by rolling
        forward a multiple of 28 years.

        *fmt* is a :func:`strftime` format string.

        Dalke: I hope I did this math right.  Every 28 years the
        calendar repeats, except through century leap years excepting
        the 400 year leap years.  But only if you're using the Gregorian
        calendar.
        ***REMOVED***
        if fmt is None:
            fmt = self.fmt

        # Since python's time module's strftime implementation does not
        # support %f microsecond (but the datetime module does***REMOVED***, use a
        # regular expression substitution to replace instances of %f.
        # Note that this can be useful since python's floating-point
        # precision representation for datetime causes precision to be
        # more accurate closer to year 0 (around the year 2000, precision
        # can be at 10s of microseconds***REMOVED***.
        fmt = re.sub(r'((^|[^%***REMOVED******REMOVED***(%%***REMOVED*******REMOVED***%f',
                     r'\g<1>{0:06d***REMOVED***'.format(dt.microsecond***REMOVED***, fmt***REMOVED***

        year = dt.year
        # For every non-leap year century, advance by
        # 6 years to get into the 28-year repeat cycle
        delta = 2000 - year
        off = 6 * (delta // 100 + delta // 400***REMOVED***
        year = year + off

        # Move to between the years 1973 and 2000
        year1 = year + ((2000 - year***REMOVED*** // 28***REMOVED*** * 28
        year2 = year1 + 28
        timetuple = dt.timetuple(***REMOVED***
        # Generate timestamp string for year and year+28
        s1 = time.strftime(fmt, (year1,***REMOVED*** + timetuple[1:***REMOVED******REMOVED***
        s2 = time.strftime(fmt, (year2,***REMOVED*** + timetuple[1:***REMOVED******REMOVED***

        # Replace instances of respective years (both 2-digit and 4-digit***REMOVED***
        # that are located at the same indexes of s1, s2 with dt's year.
        # Note that C++'s strftime implementation does not use padded
        # zeros or padded whitespace for %y or %Y for years before 100, but
        # uses padded zeros for %x. (For example, try the runnable examples
        # with .tm_year in the interval [-1900, -1800***REMOVED*** on
        # http://en.cppreference.com/w/c/chrono/strftime.***REMOVED*** For ease of
        # implementation, we always use padded zeros for %y, %Y, and %x.
        s1, s2 = self._replace_common_substr(s1, s2,
                                             "{0:04d***REMOVED***".format(year1***REMOVED***,
                                             "{0:04d***REMOVED***".format(year2***REMOVED***,
                                             "{0:04d***REMOVED***".format(dt.year***REMOVED******REMOVED***
        s1, s2 = self._replace_common_substr(s1, s2,
                                             "{0:02d***REMOVED***".format(year1 % 100***REMOVED***,
                                             "{0:02d***REMOVED***".format(year2 % 100***REMOVED***,
                                             "{0:02d***REMOVED***".format(dt.year % 100***REMOVED******REMOVED***
        return cbook.unicode_safe(s1***REMOVED***

    def strftime(self, dt, fmt=None***REMOVED***:
        ***REMOVED***Refer to documentation for datetime.strftime.

        *fmt* is a :func:`strftime` format string.

        Warning: For years before 1900, depending upon the current
        locale it is possible that the year displayed with %x might
        be incorrect. For years before 100, %y and %Y will yield
        zero-padded strings.
        ***REMOVED***
        if fmt is None:
            fmt = self.fmt
        fmt = self.illegal_s.sub(r"\1", fmt***REMOVED***
        fmt = fmt.replace("%s", "s"***REMOVED***
        if dt.year >= 1900:
            # Note: in python 3.3 this is okay for years >= 1000,
            # refer to http://bugs.python.org/issue177742
            return cbook.unicode_safe(dt.strftime(fmt***REMOVED******REMOVED***

        return self.strftime_pre_1900(dt, fmt***REMOVED***


class IndexDateFormatter(ticker.Formatter***REMOVED***:
    ***REMOVED***
    Use with :class:`~matplotlib.ticker.IndexLocator` to cycle format
    strings by index.
    ***REMOVED***
    def __init__(self, t, fmt, tz=None***REMOVED***:
        ***REMOVED***
        *t* is a sequence of dates (floating point days***REMOVED***.  *fmt* is a
        :func:`strftime` format string.
        ***REMOVED***
        if tz is None:
            tz = _get_rc_timezone(***REMOVED***
        self.t = t
        self.fmt = fmt
        self.tz = tz

    def __call__(self, x, pos=0***REMOVED***:
        'Return the label for time *x* at position *pos*'
        ind = int(round(x***REMOVED******REMOVED***
        if ind >= len(self.t***REMOVED*** or ind <= 0:
            return ''

        dt = num2date(self.t[ind***REMOVED***, self.tz***REMOVED***

        return cbook.unicode_safe(dt.strftime(self.fmt***REMOVED******REMOVED***


class AutoDateFormatter(ticker.Formatter***REMOVED***:
    ***REMOVED***
    This class attempts to figure out the best format to use.  This is
    most useful when used with the :class:`AutoDateLocator`.


    The AutoDateFormatter has a scale dictionary that maps the scale
    of the tick (the distance in days between one major tick***REMOVED*** and a
    format string.  The default looks like this::

        self.scaled = {
           365.0  : '%Y',
           30.    : '%b %Y',
           1.0    : '%b %d %Y',
           1./24. : '%H:%M:%S',
           1. / (24. * 60.***REMOVED***: '%H:%M:%S.%f',
       ***REMOVED***


    The algorithm picks the key in the dictionary that is >= the
    current scale and uses that format string.  You can customize this
    dictionary by doing::


    >>> locator = AutoDateLocator(***REMOVED***
    >>> formatter = AutoDateFormatter(locator***REMOVED***
    >>> formatter.scaled[1/(24.*60.***REMOVED******REMOVED*** = '%M:%S' # only show min and sec

    A custom :class:`~matplotlib.ticker.FuncFormatter` can also be used.
    The following example shows how to use a custom format function to strip
    trailing zeros from decimal seconds and adds the date to the first
    ticklabel::

        >>> def my_format_function(x, pos=None***REMOVED***:
        ...     x = matplotlib.dates.num2date(x***REMOVED***
        ...     if pos == 0:
        ...         fmt = '%D %H:%M:%S.%f'
        ...     else:
        ...         fmt = '%H:%M:%S.%f'
        ...     label = x.strftime(fmt***REMOVED***
        ...     label = label.rstrip("0"***REMOVED***
        ...     label = label.rstrip("."***REMOVED***
        ...     return label
        >>> from matplotlib.ticker import FuncFormatter
        >>> formatter.scaled[1/(24.*60.***REMOVED******REMOVED*** = FuncFormatter(my_format_function***REMOVED***
    ***REMOVED***

    # This can be improved by providing some user-level direction on
    # how to choose the best format (precedence, etc...***REMOVED***

    # Perhaps a 'struct' that has a field for each time-type where a
    # zero would indicate "don't show" and a number would indicate
    # "show" with some sort of priority.  Same priorities could mean
    # show all with the same priority.

    # Or more simply, perhaps just a format string for each
    # possibility...

    def __init__(self, locator, tz=None, defaultfmt='%Y-%m-%d'***REMOVED***:
        ***REMOVED***
        Autoformat the date labels.  The default format is the one to use
        if none of the values in ``self.scaled`` are greater than the unit
        returned by ``locator._get_unit(***REMOVED***``.
        ***REMOVED***
        self._locator = locator
        self._tz = tz
        self.defaultfmt = defaultfmt
        self._formatter = DateFormatter(self.defaultfmt, tz***REMOVED***
        self.scaled = {DAYS_PER_YEAR: '%Y',
                       DAYS_PER_MONTH: '%b %Y',
                       1.0: '%b %d %Y',
                       1. / HOURS_PER_DAY: '%H:%M:%S',
                       1. / (MINUTES_PER_DAY***REMOVED***: '%H:%M:%S.%f'***REMOVED***

    def __call__(self, x, pos=None***REMOVED***:
        locator_unit_scale = float(self._locator._get_unit(***REMOVED******REMOVED***
        fmt = self.defaultfmt

        # Pick the first scale which is greater than the locator unit.
        for possible_scale in sorted(self.scaled***REMOVED***:
            if possible_scale >= locator_unit_scale:
                fmt = self.scaled[possible_scale***REMOVED***
                break

        if isinstance(fmt, six.string_types***REMOVED***:
            self._formatter = DateFormatter(fmt, self._tz***REMOVED***
            result = self._formatter(x, pos***REMOVED***
        elif six.callable(fmt***REMOVED***:
            result = fmt(x, pos***REMOVED***
        else:
            raise TypeError('Unexpected type passed to {0!r***REMOVED***.'.format(self***REMOVED******REMOVED***

        return result


class rrulewrapper(object***REMOVED***:

    def __init__(self, freq, **kwargs***REMOVED***:
        self._construct = kwargs.copy(***REMOVED***
        self._construct["freq"***REMOVED*** = freq
        self._rrule = rrule(**self._construct***REMOVED***

    def set(self, **kwargs***REMOVED***:
        self._construct.update(kwargs***REMOVED***
        self._rrule = rrule(**self._construct***REMOVED***

    def __getattr__(self, name***REMOVED***:
        if name in self.__dict__:
            return self.__dict__[name***REMOVED***
        return getattr(self._rrule, name***REMOVED***


class DateLocator(ticker.Locator***REMOVED***:
    ***REMOVED***
    Determines the tick locations when plotting dates.
    ***REMOVED***
    hms0d = {'byhour': 0, 'byminute': 0, 'bysecond': 0***REMOVED***

    def __init__(self, tz=None***REMOVED***:
        ***REMOVED***
        *tz* is a :class:`tzinfo` instance.
        ***REMOVED***
        if tz is None:
            tz = _get_rc_timezone(***REMOVED***
        self.tz = tz

    def set_tzinfo(self, tz***REMOVED***:
        ***REMOVED***
        Set time zone info.
        ***REMOVED***
        self.tz = tz

    def datalim_to_dt(self***REMOVED***:
        ***REMOVED***
        Convert axis data interval to datetime objects.
        ***REMOVED***
        dmin, dmax = self.axis.get_data_interval(***REMOVED***
        if dmin > dmax:
            dmin, dmax = dmax, dmin

        return num2date(dmin, self.tz***REMOVED***, num2date(dmax, self.tz***REMOVED***

    def viewlim_to_dt(self***REMOVED***:
        ***REMOVED***
        Converts the view interval to datetime objects.
        ***REMOVED***
        vmin, vmax = self.axis.get_view_interval(***REMOVED***
        if vmin > vmax:
            vmin, vmax = vmax, vmin

        return num2date(vmin, self.tz***REMOVED***, num2date(vmax, self.tz***REMOVED***

    def _get_unit(self***REMOVED***:
        ***REMOVED***
        Return how many days a unit of the locator is; used for
        intelligent autoscaling.
        ***REMOVED***
        return 1

    def _get_interval(self***REMOVED***:
        ***REMOVED***
        Return the number of units for each tick.
        ***REMOVED***
        return 1

    def nonsingular(self, vmin, vmax***REMOVED***:
        ***REMOVED***
        Given the proposed upper and lower extent, adjust the range
        if it is too close to being singular (i.e. a range of ~0***REMOVED***.

        ***REMOVED***
        unit = self._get_unit(***REMOVED***
        interval = self._get_interval(***REMOVED***
        if abs(vmax - vmin***REMOVED*** < 1e-6:
            vmin -= 2 * unit * interval
            vmax += 2 * unit * interval
        return vmin, vmax


class RRuleLocator(DateLocator***REMOVED***:
    # use the dateutil rrule instance

    def __init__(self, o, tz=None***REMOVED***:
        DateLocator.__init__(self, tz***REMOVED***
        self.rule = o

    def __call__(self***REMOVED***:
        # if no data have been set, this will tank with a ValueError
        ***REMOVED***
            dmin, dmax = self.viewlim_to_dt(***REMOVED***
        except ValueError:
            return [***REMOVED***

        return self.tick_values(dmin, dmax***REMOVED***

    def tick_values(self, vmin, vmax***REMOVED***:
        delta = relativedelta(vmax, vmin***REMOVED***

        # We need to cap at the endpoints of valid datetime
        ***REMOVED***
            start = vmin - delta
        except ValueError:
            start = _from_ordinalf(1.0***REMOVED***

        ***REMOVED***
            stop = vmax + delta
        except ValueError:
            # The magic number!
            stop = _from_ordinalf(3652059.9999999***REMOVED***

        self.rule.set(dtstart=start, until=stop***REMOVED***

        # estimate the number of ticks very approximately so we don't
        # have to do a very expensive (and potentially near infinite***REMOVED***
        # 'between' calculation, only to find out it will fail.
        nmax, nmin = date2num((vmax, vmin***REMOVED******REMOVED***
        estimate = (nmax - nmin***REMOVED*** / (self._get_unit(***REMOVED*** * self._get_interval(***REMOVED******REMOVED***
        # This estimate is only an estimate, so be really conservative
        # about bailing...
        if estimate > self.MAXTICKS * 2:
            raise RuntimeError(
                'RRuleLocator estimated to generate %d ticks from %s to %s: '
                'exceeds Locator.MAXTICKS * 2 (%d***REMOVED*** ' % (estimate, vmin, vmax,
                                                        self.MAXTICKS * 2***REMOVED******REMOVED***

        dates = self.rule.between(vmin, vmax, True***REMOVED***
        if len(dates***REMOVED*** == 0:
            return date2num([vmin, vmax***REMOVED******REMOVED***
        return self.raise_if_exceeds(date2num(dates***REMOVED******REMOVED***

    def _get_unit(self***REMOVED***:
        ***REMOVED***
        Return how many days a unit of the locator is; used for
        intelligent autoscaling.
        ***REMOVED***
        freq = self.rule._rrule._freq
        return self.get_unit_generic(freq***REMOVED***

    @staticmethod
    def get_unit_generic(freq***REMOVED***:
        if freq == YEARLY:
            return DAYS_PER_YEAR
        elif freq == MONTHLY:
            return DAYS_PER_MONTH
        elif freq == WEEKLY:
            return DAYS_PER_WEEK
        elif freq == DAILY:
            return 1.0
        elif freq == HOURLY:
            return 1.0 / HOURS_PER_DAY
        elif freq == MINUTELY:
            return 1.0 / MINUTES_PER_DAY
        elif freq == SECONDLY:
            return 1.0 / SEC_PER_DAY
        else:
            # error
            return -1   # or should this just return '1'?

    def _get_interval(self***REMOVED***:
        return self.rule._rrule._interval

    def autoscale(self***REMOVED***:
        ***REMOVED***
        Set the view limits to include the data range.
        ***REMOVED***
        dmin, dmax = self.datalim_to_dt(***REMOVED***
        delta = relativedelta(dmax, dmin***REMOVED***

        # We need to cap at the endpoints of valid datetime
        ***REMOVED***
            start = dmin - delta
        except ValueError:
            start = _from_ordinalf(1.0***REMOVED***

        ***REMOVED***
            stop = dmax + delta
        except ValueError:
            # The magic number!
            stop = _from_ordinalf(3652059.9999999***REMOVED***

        self.rule.set(dtstart=start, until=stop***REMOVED***
        dmin, dmax = self.datalim_to_dt(***REMOVED***

        vmin = self.rule.before(dmin, True***REMOVED***
        if not vmin:
            vmin = dmin

        vmax = self.rule.after(dmax, True***REMOVED***
        if not vmax:
            vmax = dmax

        vmin = date2num(vmin***REMOVED***
        vmax = date2num(vmax***REMOVED***

        return self.nonsingular(vmin, vmax***REMOVED***


class AutoDateLocator(DateLocator***REMOVED***:
    ***REMOVED***
    On autoscale, this class picks the best
    :class:`DateLocator` to set the view limits and the tick
    locations.
    ***REMOVED***
    def __init__(self, tz=None, minticks=5, maxticks=None,
                 interval_multiples=False***REMOVED***:
        ***REMOVED***
        *minticks* is the minimum number of ticks desired, which is used to
        select the type of ticking (yearly, monthly, etc.***REMOVED***.

        *maxticks* is the maximum number of ticks desired, which controls
        any interval between ticks (ticking every other, every 3, etc.***REMOVED***.
        For really fine-grained control, this can be a dictionary mapping
        individual rrule frequency constants (YEARLY, MONTHLY, etc.***REMOVED***
        to their own maximum number of ticks.  This can be used to keep
        the number of ticks appropriate to the format chosen in
        :class:`AutoDateFormatter`. Any frequency not specified in this
        dictionary is given a default value.

        *tz* is a :class:`tzinfo` instance.

        *interval_multiples* is a boolean that indicates whether ticks
        should be chosen to be multiple of the interval. This will lock
        ticks to 'nicer' locations. For example, this will force the
        ticks to be at hours 0,6,12,18 when hourly ticking is done at
        6 hour intervals.

        The AutoDateLocator has an interval dictionary that maps the
        frequency of the tick (a constant from dateutil.rrule***REMOVED*** and a
        multiple allowed for that ticking.  The default looks like this::

          self.intervald = {
            YEARLY  : [1, 2, 4, 5, 10, 20, 40, 50, 100, 200, 400, 500,
                      1000, 2000, 4000, 5000, 10000***REMOVED***,
            MONTHLY : [1, 2, 3, 4, 6***REMOVED***,
            DAILY   : [1, 2, 3, 7, 14***REMOVED***,
            HOURLY  : [1, 2, 3, 4, 6, 12***REMOVED***,
            MINUTELY: [1, 5, 10, 15, 30***REMOVED***,
            SECONDLY: [1, 5, 10, 15, 30***REMOVED***,
            MICROSECONDLY: [1, 2, 5, 10, 20, 50, 100, 200, 500, 1000, 2000,
                           5000, 10000, 20000, 50000, 100000, 200000, 500000,
                           1000000***REMOVED***,
        ***REMOVED***

        The interval is used to specify multiples that are appropriate for
        the frequency of ticking. For instance, every 7 days is sensible
        for daily ticks, but for minutes/seconds, 15 or 30 make sense.
        You can customize this dictionary by doing::

          locator = AutoDateLocator(***REMOVED***
          locator.intervald[HOURLY***REMOVED*** = [3***REMOVED*** # only show every 3 hours
        ***REMOVED***
        DateLocator.__init__(self, tz***REMOVED***
        self._locator = YearLocator(***REMOVED***
        self._freq = YEARLY
        self._freqs = [YEARLY, MONTHLY, DAILY, HOURLY, MINUTELY,
                       SECONDLY, MICROSECONDLY***REMOVED***
        self.minticks = minticks

        self.maxticks = {YEARLY: 11, MONTHLY: 12, DAILY: 11, HOURLY: 12,
                         MINUTELY: 11, SECONDLY: 11, MICROSECONDLY: 8***REMOVED***
        if maxticks is not None:
            ***REMOVED***
                self.maxticks.update(maxticks***REMOVED***
            except TypeError:
                # Assume we were given an integer. Use this as the maximum
                # number of ticks for every frequency and create a
                # dictionary for this
                self.maxticks = dict(zip(self._freqs,
                                         [maxticks***REMOVED*** * len(self._freqs***REMOVED******REMOVED******REMOVED***
        self.interval_multiples = interval_multiples
        self.intervald = {
            YEARLY:   [1, 2, 4, 5, 10, 20, 40, 50, 100, 200, 400, 500,
                       1000, 2000, 4000, 5000, 10000***REMOVED***,
            MONTHLY:  [1, 2, 3, 4, 6***REMOVED***,
            DAILY:    [1, 2, 3, 7, 14, 21***REMOVED***,
            HOURLY:   [1, 2, 3, 4, 6, 12***REMOVED***,
            MINUTELY: [1, 5, 10, 15, 30***REMOVED***,
            SECONDLY: [1, 5, 10, 15, 30***REMOVED***,
            MICROSECONDLY: [1, 2, 5, 10, 20, 50, 100, 200, 500, 1000, 2000,
                            5000, 10000, 20000, 50000, 100000, 200000, 500000,
                            1000000***REMOVED******REMOVED***
        self._byranges = [None, range(1, 13***REMOVED***, range(1, 32***REMOVED***,
                          range(0, 24***REMOVED***, range(0, 60***REMOVED***, range(0, 60***REMOVED***, None***REMOVED***

    def __call__(self***REMOVED***:
        'Return the locations of the ticks'
        self.refresh(***REMOVED***
        return self._locator(***REMOVED***

    def tick_values(self, vmin, vmax***REMOVED***:
        return self.get_locator(vmin, vmax***REMOVED***.tick_values(vmin, vmax***REMOVED***

    def nonsingular(self, vmin, vmax***REMOVED***:
        # whatever is thrown at us, we can scale the unit.
        # But default nonsingular date plots at an ~4 year period.
        if vmin == vmax:
            vmin = vmin - DAYS_PER_YEAR * 2
            vmax = vmax + DAYS_PER_YEAR * 2
        return vmin, vmax

    def set_axis(self, axis***REMOVED***:
        DateLocator.set_axis(self, axis***REMOVED***
        self._locator.set_axis(axis***REMOVED***

    def refresh(self***REMOVED***:
        'Refresh internal information based on current limits.'
        dmin, dmax = self.viewlim_to_dt(***REMOVED***
        self._locator = self.get_locator(dmin, dmax***REMOVED***

    def _get_unit(self***REMOVED***:
        if self._freq in [MICROSECONDLY***REMOVED***:
            return 1. / MUSECONDS_PER_DAY
        else:
            return RRuleLocator.get_unit_generic(self._freq***REMOVED***

    def autoscale(self***REMOVED***:
        'Try to choose the view limits intelligently.'
        dmin, dmax = self.datalim_to_dt(***REMOVED***
        self._locator = self.get_locator(dmin, dmax***REMOVED***
        return self._locator.autoscale(***REMOVED***

    def get_locator(self, dmin, dmax***REMOVED***:
        'Pick the best locator based on a distance.'
        delta = relativedelta(dmax, dmin***REMOVED***
        tdelta = dmax - dmin

        # take absolute difference
        if dmin > dmax:
            delta = -delta
            tdelta = -tdelta

        # The following uses a mix of calls to relativedelta and timedelta
        # methods because there is incomplete overlap in the functionality of
        # these similar functions, and it's best to avoid doing our own math
        # whenever possible.
        numYears = float(delta.years***REMOVED***
        numMonths = (numYears * MONTHS_PER_YEAR***REMOVED*** + delta.months
        numDays = tdelta.days   # Avoids estimates of days/month, days/year
        numHours = (numDays * HOURS_PER_DAY***REMOVED*** + delta.hours
        numMinutes = (numHours * MIN_PER_HOUR***REMOVED*** + delta.minutes
        numSeconds = np.floor(_total_seconds(tdelta***REMOVED******REMOVED***
        numMicroseconds = np.floor(_total_seconds(tdelta***REMOVED*** * 1e6***REMOVED***

        nums = [numYears, numMonths, numDays, numHours, numMinutes,
                numSeconds, numMicroseconds***REMOVED***

        use_rrule_locator = [True***REMOVED*** * 6 + [False***REMOVED***

        # Default setting of bymonth, etc. to pass to rrule
        # [unused (for year***REMOVED***, bymonth, bymonthday, byhour, byminute,
        #  bysecond, unused (for microseconds***REMOVED******REMOVED***
        byranges = [None, 1, 1, 0, 0, 0, None***REMOVED***

        # Loop over all the frequencies and try to find one that gives at
        # least a minticks tick positions.  Once this is found, look for
        # an interval from an list specific to that frequency that gives no
        # more than maxticks tick positions. Also, set up some ranges
        # (bymonth, etc.***REMOVED*** as appropriate to be passed to rrulewrapper.
        for i, (freq, num***REMOVED*** in enumerate(zip(self._freqs, nums***REMOVED******REMOVED***:
            # If this particular frequency doesn't give enough ticks, continue
            if num < self.minticks:
                # Since we're not using this particular frequency, set
                # the corresponding by_ to None so the rrule can act as
                # appropriate
                byranges[i***REMOVED*** = None
                continue

            # Find the first available interval that doesn't give too many
            # ticks
            for interval in self.intervald[freq***REMOVED***:
                if num <= interval * (self.maxticks[freq***REMOVED*** - 1***REMOVED***:
                    break
            else:
                # We went through the whole loop without breaking, default to
                # the last interval in the list and raise a warning
                warnings.warn('AutoDateLocator was unable to pick an '
                              'appropriate interval for this date range. '
                              'It may be necessary to add an interval value '
                              "to the AutoDateLocator's intervald dictionary."
                              ' Defaulting to {0***REMOVED***.'.format(interval***REMOVED******REMOVED***

            # Set some parameters as appropriate
            self._freq = freq

            if self._byranges[i***REMOVED*** and self.interval_multiples:
                byranges[i***REMOVED*** = self._byranges[i***REMOVED***[::interval***REMOVED***
                interval = 1
            else:
                byranges[i***REMOVED*** = self._byranges[i***REMOVED***

            # We found what frequency to use
            break
        else:
            raise ValueError('No sensible date limit could be found in the '
                             'AutoDateLocator.'***REMOVED***

        if use_rrule_locator[i***REMOVED***:
            _, bymonth, bymonthday, byhour, byminute, bysecond, _ = byranges

            rrule = rrulewrapper(self._freq, interval=interval,
                                 dtstart=dmin, until=dmax,
                                 bymonth=bymonth, bymonthday=bymonthday,
                                 byhour=byhour, byminute=byminute,
                                 bysecond=bysecond***REMOVED***

            locator = RRuleLocator(rrule, self.tz***REMOVED***
        else:
            locator = MicrosecondLocator(interval, tz=self.tz***REMOVED***

        locator.set_axis(self.axis***REMOVED***

        locator.set_view_interval(*self.axis.get_view_interval(***REMOVED******REMOVED***
        locator.set_data_interval(*self.axis.get_data_interval(***REMOVED******REMOVED***
        return locator


class YearLocator(DateLocator***REMOVED***:
    ***REMOVED***
    Make ticks on a given day of each year that is a multiple of base.

    Examples::

      # Tick every year on Jan 1st
      locator = YearLocator(***REMOVED***

      # Tick every 5 years on July 4th
      locator = YearLocator(5, month=7, day=4***REMOVED***
    ***REMOVED***
    def __init__(self, base=1, month=1, day=1, tz=None***REMOVED***:
        ***REMOVED***
        Mark years that are multiple of base on a given month and day
        (default jan 1***REMOVED***.
        ***REMOVED***
        DateLocator.__init__(self, tz***REMOVED***
        self.base = ticker.Base(base***REMOVED***
        self.replaced = {'month':  month,
                         'day':    day,
                         'hour':   0,
                         'minute': 0,
                         'second': 0,
                         'tzinfo': tz
                     ***REMOVED***

    def __call__(self***REMOVED***:
        # if no data have been set, this will tank with a ValueError
        ***REMOVED***
            dmin, dmax = self.viewlim_to_dt(***REMOVED***
        except ValueError:
            return [***REMOVED***

        return self.tick_values(dmin, dmax***REMOVED***

    def tick_values(self, vmin, vmax***REMOVED***:
        ymin = self.base.le(vmin.year***REMOVED***
        ymax = self.base.ge(vmax.year***REMOVED***

        ticks = [vmin.replace(year=ymin, **self.replaced***REMOVED******REMOVED***
        while 1:
            dt = ticks[-1***REMOVED***
            if dt.year >= ymax:
                return date2num(ticks***REMOVED***
            year = dt.year + self.base.get_base(***REMOVED***
            ticks.append(dt.replace(year=year, **self.replaced***REMOVED******REMOVED***

    def autoscale(self***REMOVED***:
        ***REMOVED***
        Set the view limits to include the data range.
        ***REMOVED***
        dmin, dmax = self.datalim_to_dt(***REMOVED***

        ymin = self.base.le(dmin.year***REMOVED***
        ymax = self.base.ge(dmax.year***REMOVED***
        vmin = dmin.replace(year=ymin, **self.replaced***REMOVED***
        vmax = dmax.replace(year=ymax, **self.replaced***REMOVED***

        vmin = date2num(vmin***REMOVED***
        vmax = date2num(vmax***REMOVED***
        return self.nonsingular(vmin, vmax***REMOVED***


class MonthLocator(RRuleLocator***REMOVED***:
    ***REMOVED***
    Make ticks on occurances of each month month, e.g., 1, 3, 12.
    ***REMOVED***
    def __init__(self, bymonth=None, bymonthday=1, interval=1, tz=None***REMOVED***:
        ***REMOVED***
        Mark every month in *bymonth*; *bymonth* can be an int or
        sequence.  Default is ``range(1,13***REMOVED***``, i.e. every month.

        *interval* is the interval between each iteration.  For
        example, if ``interval=2``, mark every second occurance.
        ***REMOVED***
        if bymonth is None:
            bymonth = range(1, 13***REMOVED***
        elif isinstance(bymonth, np.ndarray***REMOVED***:
            # This fixes a bug in dateutil <= 2.3 which prevents the use of
            # numpy arrays in (among other things***REMOVED*** the bymonthday, byweekday
            # and bymonth parameters.
            bymonth = [x.item(***REMOVED*** for x in bymonth.astype(int***REMOVED******REMOVED***

        rule = rrulewrapper(MONTHLY, bymonth=bymonth, bymonthday=bymonthday,
                         interval=interval, **self.hms0d***REMOVED***
        RRuleLocator.__init__(self, rule, tz***REMOVED***


class WeekdayLocator(RRuleLocator***REMOVED***:
    ***REMOVED***
    Make ticks on occurances of each weekday.
    ***REMOVED***

    def __init__(self, byweekday=1, interval=1, tz=None***REMOVED***:
        ***REMOVED***
        Mark every weekday in *byweekday*; *byweekday* can be a number or
        sequence.

        Elements of *byweekday* must be one of MO, TU, WE, TH, FR, SA,
        SU, the constants from :mod:`dateutil.rrule`, which have been
        imported into the :mod:`matplotlib.dates` namespace.

        *interval* specifies the number of weeks to skip.  For example,
        ``interval=2`` plots every second week.
        ***REMOVED***
        if isinstance(byweekday, np.ndarray***REMOVED***:
            # This fixes a bug in dateutil <= 2.3 which prevents the use of
            # numpy arrays in (among other things***REMOVED*** the bymonthday, byweekday
            # and bymonth parameters.
            [x.item(***REMOVED*** for x in byweekday.astype(int***REMOVED******REMOVED***

        rule = rrulewrapper(DAILY, byweekday=byweekday,
                            interval=interval, **self.hms0d***REMOVED***
        RRuleLocator.__init__(self, rule, tz***REMOVED***


class DayLocator(RRuleLocator***REMOVED***:
    ***REMOVED***
    Make ticks on occurances of each day of the month.  For example,
    1, 15, 30.
    ***REMOVED***
    def __init__(self, bymonthday=None, interval=1, tz=None***REMOVED***:
        ***REMOVED***
        Mark every day in *bymonthday*; *bymonthday* can be an int or
        sequence.

        Default is to tick every day of the month: ``bymonthday=range(1,32***REMOVED***``
        ***REMOVED***
        if bymonthday is None:
            bymonthday = range(1, 32***REMOVED***
        elif isinstance(bymonthday, np.ndarray***REMOVED***:
            # This fixes a bug in dateutil <= 2.3 which prevents the use of
            # numpy arrays in (among other things***REMOVED*** the bymonthday, byweekday
            # and bymonth parameters.
            bymonthday = [x.item(***REMOVED*** for x in bymonthday.astype(int***REMOVED******REMOVED***

        rule = rrulewrapper(DAILY, bymonthday=bymonthday,
                            interval=interval, **self.hms0d***REMOVED***
        RRuleLocator.__init__(self, rule, tz***REMOVED***


class HourLocator(RRuleLocator***REMOVED***:
    ***REMOVED***
    Make ticks on occurances of each hour.
    ***REMOVED***
    def __init__(self, byhour=None, interval=1, tz=None***REMOVED***:
        ***REMOVED***
        Mark every hour in *byhour*; *byhour* can be an int or sequence.
        Default is to tick every hour: ``byhour=range(24***REMOVED***``

        *interval* is the interval between each iteration.  For
        example, if ``interval=2``, mark every second occurrence.
        ***REMOVED***
        if byhour is None:
            byhour = range(24***REMOVED***

        rule = rrulewrapper(HOURLY, byhour=byhour, interval=interval,
                            byminute=0, bysecond=0***REMOVED***
        RRuleLocator.__init__(self, rule, tz***REMOVED***


class MinuteLocator(RRuleLocator***REMOVED***:
    ***REMOVED***
    Make ticks on occurances of each minute.
    ***REMOVED***
    def __init__(self, byminute=None, interval=1, tz=None***REMOVED***:
        ***REMOVED***
        Mark every minute in *byminute*; *byminute* can be an int or
        sequence.  Default is to tick every minute: ``byminute=range(60***REMOVED***``

        *interval* is the interval between each iteration.  For
        example, if ``interval=2``, mark every second occurrence.
        ***REMOVED***
        if byminute is None:
            byminute = range(60***REMOVED***

        rule = rrulewrapper(MINUTELY, byminute=byminute, interval=interval,
                            bysecond=0***REMOVED***
        RRuleLocator.__init__(self, rule, tz***REMOVED***


class SecondLocator(RRuleLocator***REMOVED***:
    ***REMOVED***
    Make ticks on occurances of each second.
    ***REMOVED***
    def __init__(self, bysecond=None, interval=1, tz=None***REMOVED***:
        ***REMOVED***
        Mark every second in *bysecond*; *bysecond* can be an int or
        sequence.  Default is to tick every second: ``bysecond = range(60***REMOVED***``

        *interval* is the interval between each iteration.  For
        example, if ``interval=2``, mark every second occurrence.

        ***REMOVED***
        if bysecond is None:
            bysecond = range(60***REMOVED***

        rule = rrulewrapper(SECONDLY, bysecond=bysecond, interval=interval***REMOVED***
        RRuleLocator.__init__(self, rule, tz***REMOVED***


class MicrosecondLocator(DateLocator***REMOVED***:
    ***REMOVED***
    Make ticks on occurances of each microsecond.

    ***REMOVED***
    def __init__(self, interval=1, tz=None***REMOVED***:
        ***REMOVED***
        *interval* is the interval between each iteration.  For
        example, if ``interval=2``, mark every second microsecond.

        ***REMOVED***
        self._interval = interval
        self._wrapped_locator = ticker.MultipleLocator(interval***REMOVED***
        self.tz = tz

    def set_axis(self, axis***REMOVED***:
        self._wrapped_locator.set_axis(axis***REMOVED***
        return DateLocator.set_axis(self, axis***REMOVED***

    def set_view_interval(self, vmin, vmax***REMOVED***:
        self._wrapped_locator.set_view_interval(vmin, vmax***REMOVED***
        return DateLocator.set_view_interval(self, vmin, vmax***REMOVED***

    def set_data_interval(self, vmin, vmax***REMOVED***:
        self._wrapped_locator.set_data_interval(vmin, vmax***REMOVED***
        return DateLocator.set_data_interval(self, vmin, vmax***REMOVED***

    def __call__(self***REMOVED***:
        # if no data have been set, this will tank with a ValueError
        ***REMOVED***
            dmin, dmax = self.viewlim_to_dt(***REMOVED***
        except ValueError:
            return [***REMOVED***

        return self.tick_values(dmin, dmax***REMOVED***

    def tick_values(self, vmin, vmax***REMOVED***:
        nmin, nmax = date2num((vmin, vmax***REMOVED******REMOVED***
        nmin *= MUSECONDS_PER_DAY
        nmax *= MUSECONDS_PER_DAY
        ticks = self._wrapped_locator.tick_values(nmin, nmax***REMOVED***
        ticks = [tick / MUSECONDS_PER_DAY for tick in ticks***REMOVED***
        return ticks

    def _get_unit(self***REMOVED***:
        ***REMOVED***
        Return how many days a unit of the locator is; used for
        intelligent autoscaling.
        ***REMOVED***
        return 1. / MUSECONDS_PER_DAY

    def _get_interval(self***REMOVED***:
        ***REMOVED***
        Return the number of units for each tick.
        ***REMOVED***
        return self._interval


def _close_to_dt(d1, d2, epsilon=5***REMOVED***:
    ***REMOVED***
    Assert that datetimes *d1* and *d2* are within *epsilon* microseconds.
    ***REMOVED***
    delta = d2 - d1
    mus = abs(_total_seconds(delta***REMOVED*** * 1e6***REMOVED***
    assert mus < epsilon


def _close_to_num(o1, o2, epsilon=5***REMOVED***:
    ***REMOVED***
    Assert that float ordinals *o1* and *o2* are within *epsilon*
    microseconds.
    ***REMOVED***
    delta = abs((o2 - o1***REMOVED*** * MUSECONDS_PER_DAY***REMOVED***
    assert delta < epsilon


def epoch2num(e***REMOVED***:
    ***REMOVED***
    Convert an epoch or sequence of epochs to the new date format,
    that is days since 0001.
    ***REMOVED***
    return EPOCH_OFFSET + np.asarray(e***REMOVED*** / SEC_PER_DAY


def num2epoch(d***REMOVED***:
    ***REMOVED***
    Convert days since 0001 to epoch.  *d* can be a number or sequence.
    ***REMOVED***
    return (np.asarray(d***REMOVED*** - EPOCH_OFFSET***REMOVED*** * SEC_PER_DAY


def mx2num(mxdates***REMOVED***:
    ***REMOVED***
    Convert mx :class:`datetime` instance (or sequence of mx
    instances***REMOVED*** to the new date format.
    ***REMOVED***
    scalar = False
    if not cbook.iterable(mxdates***REMOVED***:
        scalar = True
        mxdates = [mxdates***REMOVED***
    ret = epoch2num([m.ticks(***REMOVED*** for m in mxdates***REMOVED******REMOVED***
    if scalar:
        return ret[0***REMOVED***
    else:
        return ret


def date_ticker_factory(span, tz=None, numticks=5***REMOVED***:
    ***REMOVED***
    Create a date locator with *numticks* (approx***REMOVED*** and a date formatter
    for *span* in days.  Return value is (locator, formatter***REMOVED***.
    ***REMOVED***

    if span == 0:
        span = 1 / HOURS_PER_DAY

    mins = span * MINUTES_PER_DAY
    hrs = span * HOURS_PER_DAY
    days = span
    wks = span / DAYS_PER_WEEK
    months = span / DAYS_PER_MONTH      # Approx
    years = span / DAYS_PER_YEAR        # Approx

    if years > numticks:
        locator = YearLocator(int(years / numticks***REMOVED***, tz=tz***REMOVED***  # define
        fmt = '%Y'
    elif months > numticks:
        locator = MonthLocator(tz=tz***REMOVED***
        fmt = '%b %Y'
    elif wks > numticks:
        locator = WeekdayLocator(tz=tz***REMOVED***
        fmt = '%a, %b %d'
    elif days > numticks:
        locator = DayLocator(interval=int(math.ceil(days / numticks***REMOVED******REMOVED***, tz=tz***REMOVED***
        fmt = '%b %d'
    elif hrs > numticks:
        locator = HourLocator(interval=int(math.ceil(hrs / numticks***REMOVED******REMOVED***, tz=tz***REMOVED***
        fmt = '%H:%M\n%b %d'
    elif mins > numticks:
        locator = MinuteLocator(interval=int(math.ceil(mins / numticks***REMOVED******REMOVED***,
                                tz=tz***REMOVED***
        fmt = '%H:%M:%S'
    else:
        locator = MinuteLocator(tz=tz***REMOVED***
        fmt = '%H:%M:%S'

    formatter = DateFormatter(fmt, tz=tz***REMOVED***
    return locator, formatter


def seconds(s***REMOVED***:
    ***REMOVED***
    Return seconds as days.
    ***REMOVED***
    return float(s***REMOVED*** / SEC_PER_DAY


def minutes(m***REMOVED***:
    ***REMOVED***
    Return minutes as days.
    ***REMOVED***
    return float(m***REMOVED*** / MINUTES_PER_DAY


def hours(h***REMOVED***:
    ***REMOVED***
    Return hours as days.
    ***REMOVED***
    return h / HOURS_PER_DAY


def weeks(w***REMOVED***:
    ***REMOVED***
    Return weeks as days.
    ***REMOVED***
    return w * DAYS_PER_WEEK


class DateConverter(units.ConversionInterface***REMOVED***:
    ***REMOVED***
    Converter for datetime.date and datetime.datetime data,
    or for date/time data represented as it would be converted
    by :func:`date2num`.

    The 'unit' tag for such data is None or a tzinfo instance.
    ***REMOVED***

    @staticmethod
    def axisinfo(unit, axis***REMOVED***:
        ***REMOVED***
        Return the :class:`~matplotlib.units.AxisInfo` for *unit*.

        *unit* is a tzinfo instance or None.
        The *axis* argument is required but not used.
        ***REMOVED***
        tz = unit

        majloc = AutoDateLocator(tz=tz***REMOVED***
        majfmt = AutoDateFormatter(majloc, tz=tz***REMOVED***
        datemin = datetime.date(2000, 1, 1***REMOVED***
        datemax = datetime.date(2010, 1, 1***REMOVED***

        return units.AxisInfo(majloc=majloc, majfmt=majfmt, label='',
                              default_limits=(datemin, datemax***REMOVED******REMOVED***

    @staticmethod
    def convert(value, unit, axis***REMOVED***:
        ***REMOVED***
        If *value* is not already a number or sequence of numbers,
        convert it with :func:`date2num`.

        The *unit* and *axis* arguments are not used.
        ***REMOVED***
        if units.ConversionInterface.is_numlike(value***REMOVED***:
            return value
        return date2num(value***REMOVED***

    @staticmethod
    def default_units(x, axis***REMOVED***:
        ***REMOVED***
        Return the tzinfo instance of *x* or of its first element, or None
        ***REMOVED***
        if isinstance(x, np.ndarray***REMOVED***:
            x = x.ravel(***REMOVED***

        ***REMOVED***
            x = cbook.safe_first_element(x***REMOVED***
        except (TypeError, StopIteration***REMOVED***:
            pass

        ***REMOVED***
            return x.tzinfo
        except AttributeError:
            pass
        return None


units.registry[datetime.date***REMOVED*** = DateConverter(***REMOVED***
units.registry[datetime.datetime***REMOVED*** = DateConverter(***REMOVED***
