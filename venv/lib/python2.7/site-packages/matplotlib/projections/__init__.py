from __future__ import (absolute_import, division, print_function,
                        unicode_literals***REMOVED***

from matplotlib.externals import six

from .geo import AitoffAxes, HammerAxes, LambertAxes, MollweideAxes
from .polar import PolarAxes
from matplotlib import axes

class ProjectionRegistry(object***REMOVED***:
    ***REMOVED***
    Manages the set of projections available to the system.
    ***REMOVED***
    def __init__(self***REMOVED***:
        self._all_projection_types = {***REMOVED***

    def register(self, *projections***REMOVED***:
        ***REMOVED***
        Register a new set of projection(s***REMOVED***.
        ***REMOVED***
        for projection in projections:
            name = projection.name
            self._all_projection_types[name***REMOVED*** = projection

    def get_projection_class(self, name***REMOVED***:
        ***REMOVED***
        Get a projection class from its *name*.
        ***REMOVED***
        return self._all_projection_types[name***REMOVED***

    def get_projection_names(self***REMOVED***:
        ***REMOVED***
        Get a list of the names of all projections currently
        registered.
        ***REMOVED***
        names = list(six.iterkeys(self._all_projection_types***REMOVED******REMOVED***
        names.sort(***REMOVED***
        return names
projection_registry = ProjectionRegistry(***REMOVED***

projection_registry.register(
    axes.Axes,
    PolarAxes,
    AitoffAxes,
    HammerAxes,
    LambertAxes,
    MollweideAxes***REMOVED***


def register_projection(cls***REMOVED***:
    projection_registry.register(cls***REMOVED***


def get_projection_class(projection=None***REMOVED***:
    ***REMOVED***
    Get a projection class from its name.

    If *projection* is None, a standard rectilinear projection is
    returned.
    ***REMOVED***
    if projection is None:
        projection = 'rectilinear'

    ***REMOVED***
        return projection_registry.get_projection_class(projection***REMOVED***
    except KeyError:
        raise ValueError("Unknown projection '%s'" % projection***REMOVED***


def process_projection_requirements(figure, *args, **kwargs***REMOVED***:
    ***REMOVED***
    Handle the args/kwargs to for add_axes/add_subplot/gca,
    returning::

        (axes_proj_class, proj_class_kwargs, proj_stack_key***REMOVED***

    Which can be used for new axes initialization/identification.

    .. note:: **kwargs** is modified in place.

    ***REMOVED***
    ispolar = kwargs.pop('polar', False***REMOVED***
    projection = kwargs.pop('projection', None***REMOVED***
    if ispolar:
        if projection is not None and projection != 'polar':
            raise ValueError(
                "polar=True, yet projection=%r. "
                "Only one of these arguments should be supplied." %
                projection***REMOVED***
        projection = 'polar'

    # ensure that the resolution keyword is always put into the key
    # for polar plots
    if projection == 'polar':
        kwargs.setdefault('resolution', 1***REMOVED***

    if isinstance(projection, six.string_types***REMOVED*** or projection is None:
        projection_class = get_projection_class(projection***REMOVED***
    elif hasattr(projection, '_as_mpl_axes'***REMOVED***:
        projection_class, extra_kwargs = projection._as_mpl_axes(***REMOVED***
        kwargs.update(**extra_kwargs***REMOVED***
    else:
        raise TypeError('projection must be a string, None or implement a '
                            '_as_mpl_axes method. Got %r' % projection***REMOVED***

    # Make the key without projection kwargs, this is used as a unique
    # lookup for axes instances
    key = figure._make_key(*args, **kwargs***REMOVED***

    return projection_class, kwargs, key


def get_projection_names(***REMOVED***:
    ***REMOVED***
    Get a list of acceptable projection names.
    ***REMOVED***
    return projection_registry.get_projection_names(***REMOVED***
