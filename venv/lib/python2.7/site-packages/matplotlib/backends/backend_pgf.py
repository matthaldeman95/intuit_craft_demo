from __future__ import (absolute_import, division, print_function,
                        unicode_literals***REMOVED***

from matplotlib.externals import six

import math
***REMOVED***
import sys
import errno
import re
import shutil
import tempfile
import codecs
import atexit
import weakref
import warnings

import numpy as np

import matplotlib as mpl
from matplotlib.backend_bases import RendererBase, GraphicsContextBase,\
    FigureManagerBase, FigureCanvasBase
from matplotlib.backends.backend_mixed import MixedModeRenderer
from matplotlib.figure import Figure
from matplotlib.text import Text
from matplotlib.path import Path
from matplotlib import _png, rcParams
from matplotlib.cbook import is_string_like, is_writable_file_like
from matplotlib.compat import subprocess
from matplotlib.compat.subprocess import check_output


###############################################################################

# create a list of system fonts, all of these should work with xe/lua-latex
system_fonts = [***REMOVED***
if sys.platform.startswith('win'***REMOVED***:
    from matplotlib import font_manager
    from matplotlib.ft2font import FT2Font
    for f in font_manager.win32InstalledFonts(***REMOVED***:
        ***REMOVED***
            system_fonts.append(FT2Font(str(f***REMOVED******REMOVED***.family_name***REMOVED***
        ***REMOVED***
            pass # unknown error, skip this font
else:
    # assuming fontconfig is installed and the command 'fc-list' exists
    ***REMOVED***
        # list scalable (non-bitmap***REMOVED*** fonts
        fc_list = check_output(['fc-list', ':outline,scalable', 'family'***REMOVED******REMOVED***
        fc_list = fc_list.decode('utf8'***REMOVED***
        system_fonts = [f.split(','***REMOVED***[0***REMOVED*** for f in fc_list.splitlines(***REMOVED******REMOVED***
        system_fonts = list(set(system_fonts***REMOVED******REMOVED***
    ***REMOVED***
        warnings.warn('error getting fonts from fc-list', UserWarning***REMOVED***

def get_texcommand(***REMOVED***:
    ***REMOVED***Get chosen TeX system from rc.***REMOVED***
    texsystem_options = ["xelatex", "lualatex", "pdflatex"***REMOVED***
    texsystem = rcParams.get("pgf.texsystem", "xelatex"***REMOVED***
    return texsystem if texsystem in texsystem_options else "xelatex"


def get_fontspec(***REMOVED***:
    ***REMOVED***Build fontspec preamble from rc.***REMOVED***
    latex_fontspec = [***REMOVED***
    texcommand = get_texcommand(***REMOVED***

    if texcommand != "pdflatex":
        latex_fontspec.append("\\usepackage{fontspec***REMOVED***"***REMOVED***

    if texcommand != "pdflatex" and rcParams.get("pgf.rcfonts", True***REMOVED***:
        # try to find fonts from rc parameters
        families = ["serif", "sans-serif", "monospace"***REMOVED***
        fontspecs = [r"\setmainfont{%s***REMOVED***", r"\setsansfont{%s***REMOVED***",
                     r"\setmonofont{%s***REMOVED***"***REMOVED***
        for family, fontspec in zip(families, fontspecs***REMOVED***:
            matches = [f for f in rcParams["font." + family***REMOVED***
                       if f in system_fonts***REMOVED***
            if matches:
                latex_fontspec.append(fontspec % matches[0***REMOVED******REMOVED***
            else:
                pass  # no fonts found, fallback to LaTeX defaule

    return "\n".join(latex_fontspec***REMOVED***


def get_preamble(***REMOVED***:
    ***REMOVED***Get LaTeX preamble from rc.***REMOVED***
    latex_preamble = rcParams.get("pgf.preamble", ""***REMOVED***
    if type(latex_preamble***REMOVED*** == list:
        latex_preamble = "\n".join(latex_preamble***REMOVED***
    return latex_preamble

###############################################################################

# This almost made me cry!!!
# In the end, it's better to use only one unit for all coordinates, since the
# arithmetic in latex seems to produce inaccurate conversions.
latex_pt_to_in = 1. / 72.27
latex_in_to_pt = 1. / latex_pt_to_in
mpl_pt_to_in = 1. / 72.
mpl_in_to_pt = 1. / mpl_pt_to_in

###############################################################################
# helper functions

NO_ESCAPE = r"(?<!\\***REMOVED***(?:\\\\***REMOVED****"
re_mathsep = re.compile(NO_ESCAPE + r"\$"***REMOVED***
re_escapetext = re.compile(NO_ESCAPE + "([_^$%***REMOVED******REMOVED***"***REMOVED***
repl_escapetext = lambda m: "\\" + m.group(1***REMOVED***
re_mathdefault = re.compile(NO_ESCAPE + r"(\\mathdefault***REMOVED***"***REMOVED***
repl_mathdefault = lambda m: m.group(0***REMOVED***[:-len(m.group(1***REMOVED******REMOVED******REMOVED***


def common_texification(text***REMOVED***:
    ***REMOVED***
    Do some necessary and/or useful substitutions for texts to be included in
    LaTeX documents.
    ***REMOVED***

    # Sometimes, matplotlib adds the unknown command \mathdefault.
    # Not using \mathnormal instead since this looks odd for the latex cm font.
    text = re_mathdefault.sub(repl_mathdefault, text***REMOVED***

    # split text into normaltext and inline math parts
    parts = re_mathsep.split(text***REMOVED***
    for i, s in enumerate(parts***REMOVED***:
        if not i % 2:
            # textmode replacements
            s = re_escapetext.sub(repl_escapetext, s***REMOVED***
        else:
            # mathmode replacements
            s = r"\(\displaystyle %s\***REMOVED***" % s
        parts[i***REMOVED*** = s

    return "".join(parts***REMOVED***


def writeln(fh, line***REMOVED***:
    # every line of a file included with \input must be terminated with %
    # if not, latex will create additional vertical spaces for some reason
    fh.write(line***REMOVED***
    fh.write("%\n"***REMOVED***


def _font_properties_str(prop***REMOVED***:
    # translate font properties to latex commands, return as string
    commands = [***REMOVED***

    families = {"serif": r"\rmfamily", "sans": r"\sffamily",
                "sans-serif": r"\sffamily", "monospace": r"\ttfamily"***REMOVED***
    family = prop.get_family(***REMOVED***[0***REMOVED***
    if family in families:
        commands.append(families[family***REMOVED******REMOVED***
    elif family in system_fonts and get_texcommand(***REMOVED*** != "pdflatex":
        commands.append(r"\setmainfont{%s***REMOVED***\rmfamily" % family***REMOVED***
    else:
        pass  # print warning?

    size = prop.get_size_in_points(***REMOVED***
    commands.append(r"\fontsize{%f***REMOVED***{%f***REMOVED***" % (size, size * 1.2***REMOVED******REMOVED***

    styles = {"normal": r"", "italic": r"\itshape", "oblique": r"\slshape"***REMOVED***
    commands.append(styles[prop.get_style(***REMOVED******REMOVED******REMOVED***

    boldstyles = ["semibold", "demibold", "demi", "bold", "heavy",
                  "extra bold", "black"***REMOVED***
    if prop.get_weight(***REMOVED*** in boldstyles:
        commands.append(r"\bfseries"***REMOVED***

    commands.append(r"\selectfont"***REMOVED***
    return "".join(commands***REMOVED***


def make_pdf_to_png_converter(***REMOVED***:
    ***REMOVED***
    Returns a function that converts a pdf file to a png file.
    ***REMOVED***

    tools_available = [***REMOVED***
    # check for pdftocairo
    ***REMOVED***
        check_output(["pdftocairo", "-v"***REMOVED***, stderr=subprocess.STDOUT***REMOVED***
        tools_available.append("pdftocairo"***REMOVED***
    ***REMOVED***
        pass
    # check for ghostscript
    gs, ver = mpl.checkdep_ghostscript(***REMOVED***
    if gs:
        tools_available.append("gs"***REMOVED***

    # pick converter
    if "pdftocairo" in tools_available:
        def cairo_convert(pdffile, pngfile, dpi***REMOVED***:
            cmd = ["pdftocairo", "-singlefile", "-png",
                   "-r %d" % dpi, pdffile, os.path.splitext(pngfile***REMOVED***[0***REMOVED******REMOVED***
            # for some reason this doesn't work without shell
            check_output(" ".join(cmd***REMOVED***, shell=True, stderr=subprocess.STDOUT***REMOVED***
        return cairo_convert
    elif "gs" in tools_available:
        def gs_convert(pdffile, pngfile, dpi***REMOVED***:
            cmd = [gs, '-dQUIET', '-dSAFER', '-dBATCH', '-dNOPAUSE', '-dNOPROMPT',
                   '-sDEVICE=png16m', '-dUseCIEColor', '-dTextAlphaBits=4',
                   '-dGraphicsAlphaBits=4', '-dDOINTERPOLATE', '-sOutputFile=%s' % pngfile,
                   '-r%d' % dpi, pdffile***REMOVED***
            check_output(cmd, stderr=subprocess.STDOUT***REMOVED***
        return gs_convert
    else:
        raise RuntimeError("No suitable pdf to png renderer found."***REMOVED***


class LatexError(Exception***REMOVED***:
    def __init__(self, message, latex_output=""***REMOVED***:
        Exception.__init__(self, message***REMOVED***
        self.latex_output = latex_output


class LatexManagerFactory(object***REMOVED***:
    previous_instance = None

    @staticmethod
    def get_latex_manager(***REMOVED***:
        texcommand = get_texcommand(***REMOVED***
        latex_header = LatexManager._build_latex_header(***REMOVED***
        prev = LatexManagerFactory.previous_instance

        # check if the previous instance of LatexManager can be reused
        if prev and prev.latex_header == latex_header and prev.texcommand == texcommand:
            if rcParams.get("pgf.debug", False***REMOVED***:
                print("reusing LatexManager"***REMOVED***
            return prev
        else:
            if rcParams.get("pgf.debug", False***REMOVED***:
                print("creating LatexManager"***REMOVED***
            new_inst = LatexManager(***REMOVED***
            LatexManagerFactory.previous_instance = new_inst
            return new_inst

class WeakSet(object***REMOVED***:
    # TODO: Poor man's weakref.WeakSet.
    #       Remove this once python 2.6 support is dropped from matplotlib.

    def __init__(self***REMOVED***:
        self.weak_key_dict = weakref.WeakKeyDictionary(***REMOVED***

    def add(self, item***REMOVED***:
        self.weak_key_dict[item***REMOVED*** = None

    def discard(self, item***REMOVED***:
        if item in self.weak_key_dict:
            del self.weak_key_dict[item***REMOVED***

    def __iter__(self***REMOVED***:
        return six.iterkeys(self.weak_key_dict***REMOVED***


class LatexManager(object***REMOVED***:
    ***REMOVED***
    The LatexManager opens an instance of the LaTeX application for
    determining the metrics of text elements. The LaTeX environment can be
    modified by setting fonts and/or a custem preamble in the rc parameters.
    ***REMOVED***
    _unclean_instances = WeakSet(***REMOVED***

    @staticmethod
    def _build_latex_header(***REMOVED***:
        latex_preamble = get_preamble(***REMOVED***
        latex_fontspec = get_fontspec(***REMOVED***
        # Create LaTeX header with some content, else LaTeX will load some
        # math fonts later when we don't expect the additional output on stdout.
        # TODO: is this sufficient?
        latex_header = [r"\documentclass{minimal***REMOVED***",
                        latex_preamble,
                        latex_fontspec,
                        r"\begin{document***REMOVED***",
                        r"text $math \mu$",  # force latex to load fonts now
                        r"\typeout{pgf_backend_query_start***REMOVED***"***REMOVED***
        return "\n".join(latex_header***REMOVED***

    @staticmethod
    def _cleanup_remaining_instances(***REMOVED***:
        unclean_instances = list(LatexManager._unclean_instances***REMOVED***
        for latex_manager in unclean_instances:
            latex_manager._cleanup(***REMOVED***

    def _stdin_writeln(self, s***REMOVED***:
        self.latex_stdin_utf8.write(s***REMOVED***
        self.latex_stdin_utf8.write("\n"***REMOVED***
        self.latex_stdin_utf8.flush(***REMOVED***

    def _expect(self, s***REMOVED***:
        exp = s.encode("utf8"***REMOVED***
        buf = bytearray(***REMOVED***
        while True:
            b = self.latex.stdout.read(1***REMOVED***
            buf += b
            if buf[-len(exp***REMOVED***:***REMOVED*** == exp:
                break
            if not len(b***REMOVED***:
                raise LatexError("LaTeX process halted", buf.decode("utf8"***REMOVED******REMOVED***
        return buf.decode("utf8"***REMOVED***

    def _expect_prompt(self***REMOVED***:
        return self._expect("\n*"***REMOVED***

    def __init__(self***REMOVED***:
        # store references for __del__
        self._os_path = os.path
        self._shutil = shutil
        self._debug = rcParams.get("pgf.debug", False***REMOVED***

        # create a tmp directory for running latex, remember to cleanup
        self.tmpdir = tempfile.mkdtemp(prefix="mpl_pgf_lm_"***REMOVED***
        LatexManager._unclean_instances.add(self***REMOVED***

        # test the LaTeX setup to ensure a clean startup of the subprocess
        self.texcommand = get_texcommand(***REMOVED***
        self.latex_header = LatexManager._build_latex_header(***REMOVED***
        latex_end = "\n\\makeatletter\n\\@@end\n"
        ***REMOVED***
            latex = subprocess.Popen([self.texcommand, "-halt-on-error"***REMOVED***,
                                     stdin=subprocess.PIPE,
                                     stdout=subprocess.PIPE,
                                     cwd=self.tmpdir***REMOVED***
        except OSError as e:
            if e.errno == errno.ENOENT:
                raise RuntimeError("Latex command not found. "
                    "Install '%s' or change pgf.texsystem to the desired command."
                    % self.texcommand
                ***REMOVED***
            else:
                raise RuntimeError("Error starting process '%s'" % self.texcommand***REMOVED***
        test_input = self.latex_header + latex_end
        stdout, stderr = latex.communicate(test_input.encode("utf-8"***REMOVED******REMOVED***
        if latex.returncode != 0:
            raise LatexError("LaTeX returned an error, probably missing font or error in preamble:\n%s" % stdout***REMOVED***

        # open LaTeX process for real work
        latex = subprocess.Popen([self.texcommand, "-halt-on-error"***REMOVED***,
                                 stdin=subprocess.PIPE, stdout=subprocess.PIPE,
                                 cwd=self.tmpdir***REMOVED***
        self.latex = latex
        self.latex_stdin_utf8 = codecs.getwriter("utf8"***REMOVED***(self.latex.stdin***REMOVED***
        # write header with 'pgf_backend_query_start' token
        self._stdin_writeln(self._build_latex_header(***REMOVED******REMOVED***
        # read all lines until our 'pgf_backend_query_start' token appears
        self._expect("*pgf_backend_query_start"***REMOVED***
        self._expect_prompt(***REMOVED***

        # cache for strings already processed
        self.str_cache = {***REMOVED***

    def _cleanup(self***REMOVED***:
        if not self._os_path.isdir(self.tmpdir***REMOVED***:
            return
        ***REMOVED***
            self.latex.communicate(***REMOVED***
            self.latex_stdin_utf8.close(***REMOVED***
            self.latex.stdout.close(***REMOVED***
        ***REMOVED***
            pass
        ***REMOVED***
            self._shutil.rmtree(self.tmpdir***REMOVED***
            LatexManager._unclean_instances.discard(self***REMOVED***
        ***REMOVED***
            sys.stderr.write("error deleting tmp directory %s\n" % self.tmpdir***REMOVED***

    def __del__(self***REMOVED***:
        if self._debug:
            print("deleting LatexManager"***REMOVED***
        self._cleanup(***REMOVED***

    def get_width_height_descent(self, text, prop***REMOVED***:
        ***REMOVED***
        Get the width, total height and descent for a text typesetted by the
        current LaTeX environment.
        ***REMOVED***

        # apply font properties and define textbox
        prop_cmds = _font_properties_str(prop***REMOVED***
        textbox = "\\sbox0{%s %s***REMOVED***" % (prop_cmds, text***REMOVED***

        # check cache
        if textbox in self.str_cache:
            return self.str_cache[textbox***REMOVED***

        # send textbox to LaTeX and wait for prompt
        self._stdin_writeln(textbox***REMOVED***
        ***REMOVED***
            self._expect_prompt(***REMOVED***
        except LatexError as e:
            msg = "Error processing '%s'\nLaTeX Output:\n%s"
            raise ValueError(msg % (text, e.latex_output***REMOVED******REMOVED***

        # typeout width, height and text offset of the last textbox
        self._stdin_writeln(r"\typeout{\the\wd0,\the\ht0,\the\dp0***REMOVED***"***REMOVED***
        # read answer from latex and advance to the next prompt
        ***REMOVED***
            answer = self._expect_prompt(***REMOVED***
        except LatexError as e:
            msg = "Error processing '%s'\nLaTeX Output:\n%s"
            raise ValueError(msg % (text, e.latex_output***REMOVED******REMOVED***

        # parse metrics from the answer string
        ***REMOVED***
            width, height, offset = answer.splitlines(***REMOVED***[0***REMOVED***.split(","***REMOVED***
        ***REMOVED***
            msg = "Error processing '%s'\nLaTeX Output:\n%s" % (text, answer***REMOVED***
            raise ValueError(msg***REMOVED***
        w, h, o = float(width[:-2***REMOVED******REMOVED***, float(height[:-2***REMOVED******REMOVED***, float(offset[:-2***REMOVED******REMOVED***

        # the height returned from LaTeX goes from base to top.
        # the height matplotlib expects goes from bottom to top.
        self.str_cache[textbox***REMOVED*** = (w, h + o, o***REMOVED***
        return w, h + o, o


class RendererPgf(RendererBase***REMOVED***:

    def __init__(self, figure, fh, dummy=False***REMOVED***:
        ***REMOVED***
        Creates a new PGF renderer that translates any drawing instruction
        into text commands to be interpreted in a latex pgfpicture environment.

        Attributes:
        * figure: Matplotlib figure to initialize height, width and dpi from.
        * fh: File handle for the output of the drawing commands.
        ***REMOVED***
        RendererBase.__init__(self***REMOVED***
        self.dpi = figure.dpi
        self.fh = fh
        self.figure = figure
        self.image_counter = 0

        # get LatexManager instance
        self.latexManager = LatexManagerFactory.get_latex_manager(***REMOVED***

        if dummy:
            # dummy==True deactivate all methods
            nop = lambda *args, **kwargs: None
            for m in RendererPgf.__dict__.keys(***REMOVED***:
                if m.startswith("draw_"***REMOVED***:
                    self.__dict__[m***REMOVED*** = nop
        else:
            # if fh does not belong to a filename, deactivate draw_image
            if not hasattr(fh, 'name'***REMOVED*** or not os.path.exists(fh.name***REMOVED***:
                warnings.warn("streamed pgf-code does not support raster "
                              "graphics, consider using the pgf-to-pdf option",
                              UserWarning***REMOVED***
                self.__dict__["draw_image"***REMOVED*** = lambda *args, **kwargs: None

    def draw_markers(self, gc, marker_path, marker_trans, path, trans, rgbFace=None***REMOVED***:
        writeln(self.fh, r"\begin{pgfscope***REMOVED***"***REMOVED***

        # convert from display units to in
        f = 1. / self.dpi

        # set style and clip
        self._print_pgf_clip(gc***REMOVED***
        self._print_pgf_path_styles(gc, rgbFace***REMOVED***

        # build marker definition
        bl, tr = marker_path.get_extents(marker_trans***REMOVED***.get_points(***REMOVED***
        coords = bl[0***REMOVED*** * f, bl[1***REMOVED*** * f, tr[0***REMOVED*** * f, tr[1***REMOVED*** * f
        writeln(self.fh, r"\pgfsys@defobject{currentmarker***REMOVED***{\pgfqpoint{%fin***REMOVED***{%fin***REMOVED******REMOVED***{\pgfqpoint{%fin***REMOVED***{%fin***REMOVED******REMOVED***{" % coords***REMOVED***
        self._print_pgf_path(None, marker_path, marker_trans***REMOVED***
        self._pgf_path_draw(stroke=gc.get_linewidth(***REMOVED*** != 0.0,
                            fill=rgbFace is not None***REMOVED***
        writeln(self.fh, r"***REMOVED***"***REMOVED***

        # draw marker for each vertex
        for point, code in path.iter_segments(trans, simplify=False***REMOVED***:
            x, y = point[0***REMOVED*** * f, point[1***REMOVED*** * f
            writeln(self.fh, r"\begin{pgfscope***REMOVED***"***REMOVED***
            writeln(self.fh, r"\pgfsys@transformshift{%fin***REMOVED***{%fin***REMOVED***" % (x, y***REMOVED******REMOVED***
            writeln(self.fh, r"\pgfsys@useobject{currentmarker***REMOVED***{***REMOVED***"***REMOVED***
            writeln(self.fh, r"\end{pgfscope***REMOVED***"***REMOVED***

        writeln(self.fh, r"\end{pgfscope***REMOVED***"***REMOVED***

    def draw_path(self, gc, path, transform, rgbFace=None***REMOVED***:
        writeln(self.fh, r"\begin{pgfscope***REMOVED***"***REMOVED***
        # draw the path
        self._print_pgf_clip(gc***REMOVED***
        self._print_pgf_path_styles(gc, rgbFace***REMOVED***
        self._print_pgf_path(gc, path, transform, rgbFace***REMOVED***
        self._pgf_path_draw(stroke=gc.get_linewidth(***REMOVED*** != 0.0,
                            fill=rgbFace is not None***REMOVED***
        writeln(self.fh, r"\end{pgfscope***REMOVED***"***REMOVED***

        # if present, draw pattern on top
        if gc.get_hatch(***REMOVED***:
            writeln(self.fh, r"\begin{pgfscope***REMOVED***"***REMOVED***
            self._print_pgf_path_styles(gc, rgbFace***REMOVED***

            # combine clip and path for clipping
            self._print_pgf_clip(gc***REMOVED***
            self._print_pgf_path(gc, path, transform, rgbFace***REMOVED***
            writeln(self.fh, r"\pgfusepath{clip***REMOVED***"***REMOVED***

            # build pattern definition
            writeln(self.fh, r"\pgfsys@defobject{currentpattern***REMOVED***{\pgfqpoint{0in***REMOVED***{0in***REMOVED******REMOVED***{\pgfqpoint{1in***REMOVED***{1in***REMOVED******REMOVED***{"***REMOVED***
            writeln(self.fh, r"\begin{pgfscope***REMOVED***"***REMOVED***
            writeln(self.fh, r"\pgfpathrectangle{\pgfqpoint{0in***REMOVED***{0in***REMOVED******REMOVED***{\pgfqpoint{1in***REMOVED***{1in***REMOVED******REMOVED***"***REMOVED***
            writeln(self.fh, r"\pgfusepath{clip***REMOVED***"***REMOVED***
            scale = mpl.transforms.Affine2D(***REMOVED***.scale(self.dpi***REMOVED***
            self._print_pgf_path(None, gc.get_hatch_path(***REMOVED***, scale***REMOVED***
            self._pgf_path_draw(stroke=True***REMOVED***
            writeln(self.fh, r"\end{pgfscope***REMOVED***"***REMOVED***
            writeln(self.fh, r"***REMOVED***"***REMOVED***
            # repeat pattern, filling the bounding rect of the path
            f = 1. / self.dpi
            (xmin, ymin***REMOVED***, (xmax, ymax***REMOVED*** = path.get_extents(transform***REMOVED***.get_points(***REMOVED***
            xmin, xmax = f * xmin, f * xmax
            ymin, ymax = f * ymin, f * ymax
            repx, repy = int(math.ceil(xmax-xmin***REMOVED******REMOVED***, int(math.ceil(ymax-ymin***REMOVED******REMOVED***
            writeln(self.fh, r"\pgfsys@transformshift{%fin***REMOVED***{%fin***REMOVED***" % (xmin, ymin***REMOVED******REMOVED***
            for iy in range(repy***REMOVED***:
                for ix in range(repx***REMOVED***:
                    writeln(self.fh, r"\pgfsys@useobject{currentpattern***REMOVED***{***REMOVED***"***REMOVED***
                    writeln(self.fh, r"\pgfsys@transformshift{1in***REMOVED***{0in***REMOVED***"***REMOVED***
                writeln(self.fh, r"\pgfsys@transformshift{-%din***REMOVED***{0in***REMOVED***" % repx***REMOVED***
                writeln(self.fh, r"\pgfsys@transformshift{0in***REMOVED***{1in***REMOVED***"***REMOVED***

            writeln(self.fh, r"\end{pgfscope***REMOVED***"***REMOVED***

    def _print_pgf_clip(self, gc***REMOVED***:
        f = 1. / self.dpi
        # check for clip box
        bbox = gc.get_clip_rectangle(***REMOVED***
        if bbox:
            p1, p2 = bbox.get_points(***REMOVED***
            w, h = p2 - p1
            coords = p1[0***REMOVED*** * f, p1[1***REMOVED*** * f, w * f, h * f
            writeln(self.fh, r"\pgfpathrectangle{\pgfqpoint{%fin***REMOVED***{%fin***REMOVED******REMOVED***{\pgfqpoint{%fin***REMOVED***{%fin***REMOVED******REMOVED*** " % coords***REMOVED***
            writeln(self.fh, r"\pgfusepath{clip***REMOVED***"***REMOVED***

        # check for clip path
        clippath, clippath_trans = gc.get_clip_path(***REMOVED***
        if clippath is not None:
            self._print_pgf_path(gc, clippath, clippath_trans***REMOVED***
            writeln(self.fh, r"\pgfusepath{clip***REMOVED***"***REMOVED***

    def _print_pgf_path_styles(self, gc, rgbFace***REMOVED***:
        # cap style
        capstyles = {"butt": r"\pgfsetbuttcap",
                     "round": r"\pgfsetroundcap",
                     "projecting": r"\pgfsetrectcap"***REMOVED***
        writeln(self.fh, capstyles[gc.get_capstyle(***REMOVED******REMOVED******REMOVED***

        # join style
        joinstyles = {"miter": r"\pgfsetmiterjoin",
                      "round": r"\pgfsetroundjoin",
                      "bevel": r"\pgfsetbeveljoin"***REMOVED***
        writeln(self.fh, joinstyles[gc.get_joinstyle(***REMOVED******REMOVED******REMOVED***

        # filling
        has_fill = rgbFace is not None

        if gc.get_forced_alpha(***REMOVED***:
            fillopacity = strokeopacity = gc.get_alpha(***REMOVED***
        else:
            strokeopacity = gc.get_rgb(***REMOVED***[3***REMOVED***
            fillopacity = rgbFace[3***REMOVED*** if has_fill and len(rgbFace***REMOVED*** > 3 else 1.0

        if has_fill:
            writeln(self.fh, r"\definecolor{currentfill***REMOVED***{rgb***REMOVED***{%f,%f,%f***REMOVED***" % tuple(rgbFace[:3***REMOVED******REMOVED******REMOVED***
            writeln(self.fh, r"\pgfsetfillcolor{currentfill***REMOVED***"***REMOVED***
        if has_fill and fillopacity != 1.0:
            writeln(self.fh, r"\pgfsetfillopacity{%f***REMOVED***" % fillopacity***REMOVED***

        # linewidth and color
        lw = gc.get_linewidth(***REMOVED*** * mpl_pt_to_in * latex_in_to_pt
        stroke_rgba = gc.get_rgb(***REMOVED***
        writeln(self.fh, r"\pgfsetlinewidth{%fpt***REMOVED***" % lw***REMOVED***
        writeln(self.fh, r"\definecolor{currentstroke***REMOVED***{rgb***REMOVED***{%f,%f,%f***REMOVED***" % stroke_rgba[:3***REMOVED******REMOVED***
        writeln(self.fh, r"\pgfsetstrokecolor{currentstroke***REMOVED***"***REMOVED***
        if strokeopacity != 1.0:
            writeln(self.fh, r"\pgfsetstrokeopacity{%f***REMOVED***" % strokeopacity***REMOVED***

        # line style
        dash_offset, dash_list = gc.get_dashes(***REMOVED***
        if dash_list is None:
            writeln(self.fh, r"\pgfsetdash{***REMOVED***{0pt***REMOVED***"***REMOVED***
        else:
            dash_str = r"\pgfsetdash{"
            for dash in dash_list:
                dash_str += r"{%fpt***REMOVED***" % dash
            dash_str += r"***REMOVED***{%fpt***REMOVED***" % dash_offset
            writeln(self.fh, dash_str***REMOVED***

    def _print_pgf_path(self, gc, path, transform, rgbFace=None***REMOVED***:
        f = 1. / self.dpi
        # check for clip box / ignore clip for filled paths
        bbox = gc.get_clip_rectangle(***REMOVED*** if gc else None
        if bbox and (rgbFace is None***REMOVED***:
            p1, p2 = bbox.get_points(***REMOVED***
            clip = (p1[0***REMOVED***, p1[1***REMOVED***, p2[0***REMOVED***, p2[1***REMOVED******REMOVED***
        else:
            clip = None
        # build path
        for points, code in path.iter_segments(transform, clip=clip***REMOVED***:
            if code == Path.MOVETO:
                x, y = tuple(points***REMOVED***
                writeln(self.fh, r"\pgfpathmoveto{\pgfqpoint{%fin***REMOVED***{%fin***REMOVED******REMOVED***" %
                        (f * x, f * y***REMOVED******REMOVED***
            elif code == Path.CLOSEPOLY:
                writeln(self.fh, r"\pgfpathclose"***REMOVED***
            elif code == Path.LINETO:
                x, y = tuple(points***REMOVED***
                writeln(self.fh, r"\pgfpathlineto{\pgfqpoint{%fin***REMOVED***{%fin***REMOVED******REMOVED***" %
                        (f * x, f * y***REMOVED******REMOVED***
            elif code == Path.CURVE3:
                cx, cy, px, py = tuple(points***REMOVED***
                coords = cx * f, cy * f, px * f, py * f
                writeln(self.fh, r"\pgfpathquadraticcurveto{\pgfqpoint{%fin***REMOVED***{%fin***REMOVED******REMOVED***{\pgfqpoint{%fin***REMOVED***{%fin***REMOVED******REMOVED***" % coords***REMOVED***
            elif code == Path.CURVE4:
                c1x, c1y, c2x, c2y, px, py = tuple(points***REMOVED***
                coords = c1x * f, c1y * f, c2x * f, c2y * f, px * f, py * f
                writeln(self.fh, r"\pgfpathcurveto{\pgfqpoint{%fin***REMOVED***{%fin***REMOVED******REMOVED***{\pgfqpoint{%fin***REMOVED***{%fin***REMOVED******REMOVED***{\pgfqpoint{%fin***REMOVED***{%fin***REMOVED******REMOVED***" % coords***REMOVED***

    def _pgf_path_draw(self, stroke=True, fill=False***REMOVED***:
        actions = [***REMOVED***
        if stroke:
            actions.append("stroke"***REMOVED***
        if fill:
            actions.append("fill"***REMOVED***
        writeln(self.fh, r"\pgfusepath{%s***REMOVED***" % ",".join(actions***REMOVED******REMOVED***

    def draw_image(self, gc, x, y, im***REMOVED***:
        # TODO: Almost no documentation for the behavior of this function.
        #       Something missing?

        # save the images to png files
        path = os.path.dirname(self.fh.name***REMOVED***
        fname = os.path.splitext(os.path.basename(self.fh.name***REMOVED******REMOVED***[0***REMOVED***
        fname_img = "%s-img%d.png" % (fname, self.image_counter***REMOVED***
        self.image_counter += 1
        _png.write_png(np.array(im***REMOVED***[::-1***REMOVED***, os.path.join(path, fname_img***REMOVED******REMOVED***

        # reference the image in the pgf picture
        writeln(self.fh, r"\begin{pgfscope***REMOVED***"***REMOVED***
        self._print_pgf_clip(gc***REMOVED***
        h, w = im.get_size_out(***REMOVED***
        f = 1. / self.dpi  # from display coords to inch
        writeln(self.fh, r"\pgftext[at=\pgfqpoint{%fin***REMOVED***{%fin***REMOVED***,left,bottom***REMOVED***{\pgfimage[interpolate=true,width=%fin,height=%fin***REMOVED***{%s***REMOVED******REMOVED***" % (x * f, y * f, w * f, h * f, fname_img***REMOVED******REMOVED***
        writeln(self.fh, r"\end{pgfscope***REMOVED***"***REMOVED***

    def draw_tex(self, gc, x, y, s, prop, angle, ismath="TeX!", mtext=None***REMOVED***:
        self.draw_text(gc, x, y, s, prop, angle, ismath, mtext***REMOVED***

    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None***REMOVED***:
        # prepare string for tex
        s = common_texification(s***REMOVED***
        prop_cmds = _font_properties_str(prop***REMOVED***
        s = r"%s %s" % (prop_cmds, s***REMOVED***


        writeln(self.fh, r"\begin{pgfscope***REMOVED***"***REMOVED***

        alpha = gc.get_alpha(***REMOVED***
        if alpha != 1.0:
            writeln(self.fh, r"\pgfsetfillopacity{%f***REMOVED***" % alpha***REMOVED***
            writeln(self.fh, r"\pgfsetstrokeopacity{%f***REMOVED***" % alpha***REMOVED***
        rgb = tuple(gc.get_rgb(***REMOVED******REMOVED***[:3***REMOVED***
        if rgb != (0, 0, 0***REMOVED***:
            writeln(self.fh, r"\definecolor{textcolor***REMOVED***{rgb***REMOVED***{%f,%f,%f***REMOVED***" % rgb***REMOVED***
            writeln(self.fh, r"\pgfsetstrokecolor{textcolor***REMOVED***"***REMOVED***
            writeln(self.fh, r"\pgfsetfillcolor{textcolor***REMOVED***"***REMOVED***
            s = r"\color{textcolor***REMOVED***" + s

        f = 1.0 / self.figure.dpi
        text_args = [***REMOVED***
        if mtext and (angle == 0 or mtext.get_rotation_mode(***REMOVED*** == "anchor"***REMOVED***:
            # if text anchoring can be supported, get the original coordinates
            # and add alignment information
            x, y = mtext.get_transform(***REMOVED***.transform_point(mtext.get_position(***REMOVED******REMOVED***
            text_args.append("x=%fin" % (x * f***REMOVED******REMOVED***
            text_args.append("y=%fin" % (y * f***REMOVED******REMOVED***

            halign = {"left": "left", "right": "right", "center": ""***REMOVED***
            valign = {"top": "top", "bottom": "bottom",
                      "baseline": "base", "center": ""***REMOVED***
            text_args.append(halign[mtext.get_ha(***REMOVED******REMOVED******REMOVED***
            text_args.append(valign[mtext.get_va(***REMOVED******REMOVED******REMOVED***
        else:
            # if not, use the text layout provided by matplotlib
            text_args.append("x=%fin" % (x * f***REMOVED******REMOVED***
            text_args.append("y=%fin" % (y * f***REMOVED******REMOVED***
            text_args.append("left"***REMOVED***
            text_args.append("base"***REMOVED***

        if angle != 0:
            text_args.append("rotate=%f" % angle***REMOVED***

        writeln(self.fh, r"\pgftext[%s***REMOVED***{%s***REMOVED***" % (",".join(text_args***REMOVED***, s***REMOVED******REMOVED***
        writeln(self.fh, r"\end{pgfscope***REMOVED***"***REMOVED***

    def get_text_width_height_descent(self, s, prop, ismath***REMOVED***:
        # check if the math is supposed to be displaystyled
        s = common_texification(s***REMOVED***

        # get text metrics in units of latex pt, convert to display units
        w, h, d = self.latexManager.get_width_height_descent(s, prop***REMOVED***
        # TODO: this should be latex_pt_to_in instead of mpl_pt_to_in
        # but having a little bit more space around the text looks better,
        # plus the bounding box reported by LaTeX is VERY narrow
        f = mpl_pt_to_in * self.dpi
        return w * f, h * f, d * f

    def flipy(self***REMOVED***:
        return False

    def get_canvas_width_height(self***REMOVED***:
        return self.figure.get_figwidth(***REMOVED***, self.figure.get_figheight(***REMOVED***

    def points_to_pixels(self, points***REMOVED***:
        return points * mpl_pt_to_in * self.dpi

    def new_gc(self***REMOVED***:
        return GraphicsContextPgf(***REMOVED***


class GraphicsContextPgf(GraphicsContextBase***REMOVED***:
    pass

########################################################################


def draw_if_interactive(***REMOVED***:
    pass


def new_figure_manager(num, *args, **kwargs***REMOVED***:
    ***REMOVED***
    Create a new figure manager instance
    ***REMOVED***
    # if a main-level app must be created, this is the usual place to
    # do it -- see backend_wx, backend_wxagg and backend_tkagg for
    # examples.  Not all GUIs require explicit instantiation of a
    # main-level app (egg backend_gtk, backend_gtkagg***REMOVED*** for pylab
    FigureClass = kwargs.pop('FigureClass', Figure***REMOVED***
    thisFig = FigureClass(*args, **kwargs***REMOVED***
    return new_figure_manager_given_figure(num, thisFig***REMOVED***


def new_figure_manager_given_figure(num, figure***REMOVED***:
    ***REMOVED***
    Create a new figure manager instance for the given figure.
    ***REMOVED***
    canvas = FigureCanvasPgf(figure***REMOVED***
    manager = FigureManagerPgf(canvas, num***REMOVED***
    return manager


class TmpDirCleaner(object***REMOVED***:
    remaining_tmpdirs = set(***REMOVED***

    @staticmethod
    def add(tmpdir***REMOVED***:
        TmpDirCleaner.remaining_tmpdirs.add(tmpdir***REMOVED***

    @staticmethod
    def cleanup_remaining_tmpdirs(***REMOVED***:
        for tmpdir in TmpDirCleaner.remaining_tmpdirs:
            ***REMOVED***
                shutil.rmtree(tmpdir***REMOVED***
            ***REMOVED***
                sys.stderr.write("error deleting tmp directory %s\n" % tmpdir***REMOVED***


class FigureCanvasPgf(FigureCanvasBase***REMOVED***:
    filetypes = {"pgf": "LaTeX PGF picture",
                 "pdf": "LaTeX compiled PGF picture",
                 "png": "Portable Network Graphics", ***REMOVED***

    def get_default_filetype(self***REMOVED***:
        return 'pdf'

    def _print_pgf_to_fh(self, fh, *args, **kwargs***REMOVED***:
        if kwargs.get("dryrun", False***REMOVED***:
            renderer = RendererPgf(self.figure, None, dummy=True***REMOVED***
            self.figure.draw(renderer***REMOVED***
            return

        header_text = ***REMOVED***%% Creator: Matplotlib, PGF backend
%%
%% To include the figure in your LaTeX document, write
%%   \\input{<filename>.pgf***REMOVED***
%%
%% Make sure the required packages are loaded in your preamble
%%   \\usepackage{pgf***REMOVED***
%%
%% Figures using additional raster images can only be included by \input if
%% they are in the same directory as the main LaTeX file. For loading figures
%% from other directories you can use the `import` package
%%   \\usepackage{import***REMOVED***
%% and then include the figures with
%%   \\import{<path to file>***REMOVED***{<filename>.pgf***REMOVED***
%%
***REMOVED***

        # append the preamble used by the backend as a comment for debugging
        header_info_preamble = ["%% Matplotlib used the following preamble"***REMOVED***
        for line in get_preamble(***REMOVED***.splitlines(***REMOVED***:
            header_info_preamble.append("%%   " + line***REMOVED***
        for line in get_fontspec(***REMOVED***.splitlines(***REMOVED***:
            header_info_preamble.append("%%   " + line***REMOVED***
        header_info_preamble.append("%%"***REMOVED***
        header_info_preamble = "\n".join(header_info_preamble***REMOVED***

        # get figure size in inch
        w, h = self.figure.get_figwidth(***REMOVED***, self.figure.get_figheight(***REMOVED***
        dpi = self.figure.get_dpi(***REMOVED***

        # create pgfpicture environment and write the pgf code
        fh.write(header_text***REMOVED***
        fh.write(header_info_preamble***REMOVED***
        fh.write("\n"***REMOVED***
        writeln(fh, r"\begingroup"***REMOVED***
        writeln(fh, r"\makeatletter"***REMOVED***
        writeln(fh, r"\begin{pgfpicture***REMOVED***"***REMOVED***
        writeln(fh, r"\pgfpathrectangle{\pgfpointorigin***REMOVED***{\pgfqpoint{%fin***REMOVED***{%fin***REMOVED******REMOVED***" % (w, h***REMOVED******REMOVED***
        writeln(fh, r"\pgfusepath{use as bounding box, clip***REMOVED***"***REMOVED***
        _bbox_inches_restore = kwargs.pop("bbox_inches_restore", None***REMOVED***
        renderer = MixedModeRenderer(self.figure, w, h, dpi,
                                     RendererPgf(self.figure, fh***REMOVED***,
                                     bbox_inches_restore=_bbox_inches_restore***REMOVED***
        self.figure.draw(renderer***REMOVED***

        # end the pgfpicture environment
        writeln(fh, r"\end{pgfpicture***REMOVED***"***REMOVED***
        writeln(fh, r"\makeatother"***REMOVED***
        writeln(fh, r"\endgroup"***REMOVED***

    def print_pgf(self, fname_or_fh, *args, **kwargs***REMOVED***:
        ***REMOVED***
        Output pgf commands for drawing the figure so it can be included and
        rendered in latex documents.
        ***REMOVED***
        if kwargs.get("dryrun", False***REMOVED***:
            self._print_pgf_to_fh(None, *args, **kwargs***REMOVED***
            return

        # figure out where the pgf is to be written to
        if is_string_like(fname_or_fh***REMOVED***:
            with codecs.open(fname_or_fh, "w", encoding="utf-8"***REMOVED*** as fh:
                self._print_pgf_to_fh(fh, *args, **kwargs***REMOVED***
        elif is_writable_file_like(fname_or_fh***REMOVED***:
            fh = codecs.getwriter("utf-8"***REMOVED***(fname_or_fh***REMOVED***
            self._print_pgf_to_fh(fh, *args, **kwargs***REMOVED***
        else:
            raise ValueError("filename must be a path"***REMOVED***

    def _print_pdf_to_fh(self, fh, *args, **kwargs***REMOVED***:
        w, h = self.figure.get_figwidth(***REMOVED***, self.figure.get_figheight(***REMOVED***

        ***REMOVED***
            # create temporary directory for compiling the figure
            tmpdir = tempfile.mkdtemp(prefix="mpl_pgf_"***REMOVED***
            fname_pgf = os.path.join(tmpdir, "figure.pgf"***REMOVED***
            fname_tex = os.path.join(tmpdir, "figure.tex"***REMOVED***
            fname_pdf = os.path.join(tmpdir, "figure.pdf"***REMOVED***

            # print figure to pgf and compile it with latex
            self.print_pgf(fname_pgf, *args, **kwargs***REMOVED***

            latex_preamble = get_preamble(***REMOVED***
            latex_fontspec = get_fontspec(***REMOVED***
            latexcode = ***REMOVED***
\\documentclass[12pt***REMOVED***{minimal***REMOVED***
\\usepackage[paperwidth=%fin, paperheight=%fin, margin=0in***REMOVED***{geometry***REMOVED***
%s
%s
\\usepackage{pgf***REMOVED***

\\begin{document***REMOVED***
\\centering
\\input{figure.pgf***REMOVED***
\\end{document***REMOVED******REMOVED*** % (w, h, latex_preamble, latex_fontspec***REMOVED***
            with codecs.open(fname_tex, "w", "utf-8"***REMOVED*** as fh_tex:
                fh_tex.write(latexcode***REMOVED***

            texcommand = get_texcommand(***REMOVED***
            cmdargs = [texcommand, "-interaction=nonstopmode",
                       "-halt-on-error", "figure.tex"***REMOVED***
            ***REMOVED***
                check_output(cmdargs, stderr=subprocess.STDOUT, cwd=tmpdir***REMOVED***
            except subprocess.CalledProcessError as e:
                raise RuntimeError("%s was not able to process your file.\n\nFull log:\n%s" % (texcommand, e.output***REMOVED******REMOVED***

            # copy file contents to target
            with open(fname_pdf, "rb"***REMOVED*** as fh_src:
                shutil.copyfileobj(fh_src, fh***REMOVED***
        finally:
            ***REMOVED***
                shutil.rmtree(tmpdir***REMOVED***
            ***REMOVED***
                TmpDirCleaner.add(tmpdir***REMOVED***

    def print_pdf(self, fname_or_fh, *args, **kwargs***REMOVED***:
        ***REMOVED***
        Use LaTeX to compile a Pgf generated figure to PDF.
        ***REMOVED***
        if kwargs.get("dryrun", False***REMOVED***:
            self._print_pgf_to_fh(None, *args, **kwargs***REMOVED***
            return

        # figure out where the pdf is to be written to
        if is_string_like(fname_or_fh***REMOVED***:
            with open(fname_or_fh, "wb"***REMOVED*** as fh:
                self._print_pdf_to_fh(fh, *args, **kwargs***REMOVED***
        elif is_writable_file_like(fname_or_fh***REMOVED***:
            self._print_pdf_to_fh(fname_or_fh, *args, **kwargs***REMOVED***
        else:
            raise ValueError("filename must be a path or a file-like object"***REMOVED***

    def _print_png_to_fh(self, fh, *args, **kwargs***REMOVED***:
        converter = make_pdf_to_png_converter(***REMOVED***

        ***REMOVED***
            # create temporary directory for pdf creation and png conversion
            tmpdir = tempfile.mkdtemp(prefix="mpl_pgf_"***REMOVED***
            fname_pdf = os.path.join(tmpdir, "figure.pdf"***REMOVED***
            fname_png = os.path.join(tmpdir, "figure.png"***REMOVED***
            # create pdf and try to convert it to png
            self.print_pdf(fname_pdf, *args, **kwargs***REMOVED***
            converter(fname_pdf, fname_png, dpi=self.figure.dpi***REMOVED***
            # copy file contents to target
            with open(fname_png, "rb"***REMOVED*** as fh_src:
                shutil.copyfileobj(fh_src, fh***REMOVED***
        finally:
            ***REMOVED***
                shutil.rmtree(tmpdir***REMOVED***
            ***REMOVED***
                TmpDirCleaner.add(tmpdir***REMOVED***

    def print_png(self, fname_or_fh, *args, **kwargs***REMOVED***:
        ***REMOVED***
        Use LaTeX to compile a pgf figure to pdf and convert it to png.
        ***REMOVED***
        if kwargs.get("dryrun", False***REMOVED***:
            self._print_pgf_to_fh(None, *args, **kwargs***REMOVED***
            return

        if is_string_like(fname_or_fh***REMOVED***:
            with open(fname_or_fh, "wb"***REMOVED*** as fh:
                self._print_png_to_fh(fh, *args, **kwargs***REMOVED***
        elif is_writable_file_like(fname_or_fh***REMOVED***:
            self._print_png_to_fh(fname_or_fh, *args, **kwargs***REMOVED***
        else:
            raise ValueError("filename must be a path or a file-like object"***REMOVED***

    def get_renderer(self***REMOVED***:
        return RendererPgf(self.figure, None, dummy=True***REMOVED***


class FigureManagerPgf(FigureManagerBase***REMOVED***:
    def __init__(self, *args***REMOVED***:
        FigureManagerBase.__init__(self, *args***REMOVED***


FigureCanvas = FigureCanvasPgf
FigureManager = FigureManagerPgf


def _cleanup_all(***REMOVED***:
    LatexManager._cleanup_remaining_instances(***REMOVED***
    TmpDirCleaner.cleanup_remaining_tmpdirs(***REMOVED***

atexit.register(_cleanup_all***REMOVED***
