# Todd Miller   jmiller@stsci.edu
from __future__ import (absolute_import, division, print_function,
                        unicode_literals***REMOVED***

from matplotlib.externals import six
from matplotlib.externals.six.moves import tkinter as Tk
from matplotlib.externals.six.moves import tkinter_filedialog as FileDialog

***REMOVED***, sys, math
***REMOVED***.path

# Paint image to Tk photo blitter extension
import matplotlib.backends.tkagg as tkagg

from matplotlib.backends.backend_agg import FigureCanvasAgg
import matplotlib.backends.windowing as windowing

import matplotlib
from matplotlib.cbook import is_string_like
from matplotlib.backend_bases import RendererBase, GraphicsContextBase
from matplotlib.backend_bases import FigureManagerBase, FigureCanvasBase
from matplotlib.backend_bases import NavigationToolbar2, cursors, TimerBase
from matplotlib.backend_bases import (ShowBase, ToolContainerBase,
                                      StatusbarBase***REMOVED***
from matplotlib.backend_managers import ToolManager
from matplotlib import backend_tools
from matplotlib._pylab_helpers import Gcf

from matplotlib.figure import Figure

from matplotlib.widgets import SubplotTool

import matplotlib.cbook as cbook

rcParams = matplotlib.rcParams
verbose = matplotlib.verbose


backend_version = Tk.TkVersion

# the true dots per inch on the screen; should be display dependent
# see http://groups.google.com/groups?q=screen+dpi+x11&hl=en&lr=&ie=UTF-8&oe=UTF-8&safe=off&selm=7077.26e81ad5%40swift.cs.tcd.ie&rnum=5 for some info about screen dpi
PIXELS_PER_INCH = 75

cursord = {
    cursors.MOVE: "fleur",
    cursors.HAND: "hand2",
    cursors.POINTER: "arrow",
    cursors.SELECT_REGION: "tcross",
***REMOVED***


def round(x***REMOVED***:
    return int(math.floor(x+0.5***REMOVED******REMOVED***

def raise_msg_to_str(msg***REMOVED***:
    ***REMOVED***msg is a return arg from a raise.  Join with new lines***REMOVED***
    if not is_string_like(msg***REMOVED***:
        msg = '\n'.join(map(str, msg***REMOVED******REMOVED***
    return msg

def error_msg_tkpaint(msg, parent=None***REMOVED***:
    from matplotlib.externals.six.moves import tkinter_messagebox as tkMessageBox
    tkMessageBox.showerror("matplotlib", msg***REMOVED***

def draw_if_interactive(***REMOVED***:
    if matplotlib.is_interactive(***REMOVED***:
        figManager =  Gcf.get_active(***REMOVED***
        if figManager is not None:
            figManager.show(***REMOVED***

class Show(ShowBase***REMOVED***:
    def mainloop(self***REMOVED***:
        Tk.mainloop(***REMOVED***

show = Show(***REMOVED***

def new_figure_manager(num, *args, **kwargs***REMOVED***:
    ***REMOVED***
    Create a new figure manager instance
    ***REMOVED***
    FigureClass = kwargs.pop('FigureClass', Figure***REMOVED***
    figure = FigureClass(*args, **kwargs***REMOVED***
    return new_figure_manager_given_figure(num, figure***REMOVED***


def new_figure_manager_given_figure(num, figure***REMOVED***:
    ***REMOVED***
    Create a new figure manager instance for the given figure.
    ***REMOVED***
    _focus = windowing.FocusManager(***REMOVED***
    window = Tk.Tk(***REMOVED***
    window.withdraw(***REMOVED***

    if Tk.TkVersion >= 8.5:
        # put a mpl icon on the window rather than the default tk icon. Tkinter
        # doesn't allow colour icons on linux systems, but tk >=8.5 has a iconphoto
        # command which we call directly. Source:
        # http://mail.python.org/pipermail/tkinter-discuss/2006-November/000954.html
        icon_fname = os.path.join(rcParams['datapath'***REMOVED***, 'images', 'matplotlib.gif'***REMOVED***
        icon_img = Tk.PhotoImage(file=icon_fname***REMOVED***
        ***REMOVED***
            window.tk.call('wm', 'iconphoto', window._w, icon_img***REMOVED***
        except (SystemExit, KeyboardInterrupt***REMOVED***:
            # re-raise exit type Exceptions
            raise
        ***REMOVED***
            # log the failure, but carry on
            verbose.report('Could not load matplotlib icon: %s' % sys.exc_info(***REMOVED***[1***REMOVED******REMOVED***

    canvas = FigureCanvasTkAgg(figure, master=window***REMOVED***
    figManager = FigureManagerTkAgg(canvas, num, window***REMOVED***
    if matplotlib.is_interactive(***REMOVED***:
        figManager.show(***REMOVED***
        canvas.draw_idle(***REMOVED***
    return figManager


class TimerTk(TimerBase***REMOVED***:
    '''
    Subclass of :class:`backend_bases.TimerBase` that uses Tk's timer events.

    Attributes:
    * interval: The time between timer events in milliseconds. Default
        is 1000 ms.
    * single_shot: Boolean flag indicating whether this timer should
        operate as single shot (run once and then stop***REMOVED***. Defaults to False.
    * callbacks: Stores list of (func, args***REMOVED*** tuples that will be called
        upon timer events. This list can be manipulated directly, or the
        functions add_callback and remove_callback can be used.
    '''
    def __init__(self, parent, *args, **kwargs***REMOVED***:
        TimerBase.__init__(self, *args, **kwargs***REMOVED***
        self.parent = parent
        self._timer = None

    def _timer_start(self***REMOVED***:
        self._timer_stop(***REMOVED***
        self._timer = self.parent.after(self._interval, self._on_timer***REMOVED***

    def _timer_stop(self***REMOVED***:
        if self._timer is not None:
            self.parent.after_cancel(self._timer***REMOVED***
        self._timer = None

    def _on_timer(self***REMOVED***:
        TimerBase._on_timer(self***REMOVED***

        # Tk after(***REMOVED*** is only a single shot, so we need to add code here to
        # reset the timer if we're not operating in single shot mode.
        if not self._single and len(self.callbacks***REMOVED*** > 0:
            self._timer = self.parent.after(self._interval, self._on_timer***REMOVED***
        else:
            self._timer = None


class FigureCanvasTkAgg(FigureCanvasAgg***REMOVED***:
    keyvald = {65507 : 'control',
               65505 : 'shift',
               65513 : 'alt',
               65515 : 'super',
               65508 : 'control',
               65506 : 'shift',
               65514 : 'alt',
               65361 : 'left',
               65362 : 'up',
               65363 : 'right',
               65364 : 'down',
               65307 : 'escape',
               65470 : 'f1',
               65471 : 'f2',
               65472 : 'f3',
               65473 : 'f4',
               65474 : 'f5',
               65475 : 'f6',
               65476 : 'f7',
               65477 : 'f8',
               65478 : 'f9',
               65479 : 'f10',
               65480 : 'f11',
               65481 : 'f12',
               65300 : 'scroll_lock',
               65299 : 'break',
               65288 : 'backspace',
               65293 : 'enter',
               65379 : 'insert',
               65535 : 'delete',
               65360 : 'home',
               65367 : 'end',
               65365 : 'pageup',
               65366 : 'pagedown',
               65438 : '0',
               65436 : '1',
               65433 : '2',
               65435 : '3',
               65430 : '4',
               65437 : '5',
               65432 : '6',
               65429 : '7',
               65431 : '8',
               65434 : '9',
               65451 : '+',
               65453 : '-',
               65450 : '*',
               65455 : '/',
               65439 : 'dec',
               65421 : 'enter',
           ***REMOVED***

    _keycode_lookup = {
                       262145: 'control',
                       524320: 'alt',
                       524352: 'alt',
                       1048584: 'super',
                       1048592: 'super',
                       131074: 'shift',
                       131076: 'shift',
                   ***REMOVED***
    ***REMOVED***_keycode_lookup is used for badly mapped (i.e. no event.key_sym set***REMOVED***
       keys on apple keyboards.***REMOVED***

    def __init__(self, figure, master=None, resize_callback=None***REMOVED***:
        FigureCanvasAgg.__init__(self, figure***REMOVED***
        self._idle = True
        self._idle_callback = None
        t1,t2,w,h = self.figure.bbox.bounds
        w, h = int(w***REMOVED***, int(h***REMOVED***
        self._tkcanvas = Tk.Canvas(
            master=master, width=w, height=h, borderwidth=0,
            highlightthickness=0***REMOVED***
        self._tkphoto = Tk.PhotoImage(
            master=self._tkcanvas, width=w, height=h***REMOVED***
        self._tkcanvas.create_image(w//2, h//2, image=self._tkphoto***REMOVED***
        self._resize_callback = resize_callback
        self._tkcanvas.bind("<Configure>", self.resize***REMOVED***
        self._tkcanvas.bind("<Key>", self.key_press***REMOVED***
        self._tkcanvas.bind("<Motion>", self.motion_notify_event***REMOVED***
        self._tkcanvas.bind("<KeyRelease>", self.key_release***REMOVED***
        for name in "<Button-1>", "<Button-2>", "<Button-3>":
            self._tkcanvas.bind(name, self.button_press_event***REMOVED***
        for name in "<Double-Button-1>", "<Double-Button-2>", "<Double-Button-3>":
            self._tkcanvas.bind(name, self.button_dblclick_event***REMOVED***
        for name in "<ButtonRelease-1>", "<ButtonRelease-2>", "<ButtonRelease-3>":
            self._tkcanvas.bind(name, self.button_release_event***REMOVED***

        # Mouse wheel on Linux generates button 4/5 events
        for name in "<Button-4>", "<Button-5>":
            self._tkcanvas.bind(name, self.scroll_event***REMOVED***
        # Mouse wheel for windows goes to the window with the focus.
        # Since the canvas won't usually have the focus, bind the
        # event to the window containing the canvas instead.
        # See http://wiki.tcl.tk/3893 (mousewheel***REMOVED*** for details
        root = self._tkcanvas.winfo_toplevel(***REMOVED***
        root.bind("<MouseWheel>", self.scroll_event_windows, "+"***REMOVED***

        # Can't get destroy events by binding to _tkcanvas. Therefore, bind
        # to the window and filter.
        def filter_destroy(evt***REMOVED***:
            if evt.widget is self._tkcanvas:
                self.close_event(***REMOVED***
        root.bind("<Destroy>", filter_destroy, "+"***REMOVED***

        self._master = master
        self._tkcanvas.focus_set(***REMOVED***

    def resize(self, event***REMOVED***:
        width, height = event.width, event.height
        if self._resize_callback is not None:
            self._resize_callback(event***REMOVED***

        # compute desired figure size in inches
        dpival = self.figure.dpi
        winch = width/dpival
        hinch = height/dpival
        self.figure.set_size_inches(winch, hinch***REMOVED***


        self._tkcanvas.delete(self._tkphoto***REMOVED***
        self._tkphoto = Tk.PhotoImage(
            master=self._tkcanvas, width=int(width***REMOVED***, height=int(height***REMOVED******REMOVED***
        self._tkcanvas.create_image(int(width/2***REMOVED***,int(height/2***REMOVED***,image=self._tkphoto***REMOVED***
        self.resize_event(***REMOVED***
        self.show(***REMOVED***

        # a resizing will in general move the pointer position
        # relative to the canvas, so process it as a motion notify
        # event.  An intended side effect of this call is to allow
        # window raises (which trigger a resize***REMOVED*** to get the cursor
        # position to the mpl event framework so key presses which are
        # over the axes will work w/o clicks or explicit motion
        self._update_pointer_position(event***REMOVED***

    def _update_pointer_position(self, guiEvent=None***REMOVED***:
        ***REMOVED***
        Figure out if we are inside the canvas or not and update the
        canvas enter/leave events
        ***REMOVED***
        # if the pointer if over the canvas, set the lastx and lasty
        # attrs of the canvas so it can process event w/o mouse click
        # or move

        # the window's upper, left coords in screen coords
        xw = self._tkcanvas.winfo_rootx(***REMOVED***
        yw = self._tkcanvas.winfo_rooty(***REMOVED***
        # the pointer's location in screen coords
        xp, yp = self._tkcanvas.winfo_pointerxy(***REMOVED***

        # not figure out the canvas coordinates of the pointer
        xc = xp - xw
        yc = yp - yw

        # flip top/bottom
        yc = self.figure.bbox.height - yc

        # JDH: this method was written originally to get the pointer
        # location to the backend lastx and lasty attrs so that events
        # like KeyEvent can be handled without mouse events.  e.g., if
        # the cursor is already above the axes, then key presses like
        # 'g' should toggle the grid.  In order for this to work in
        # backend_bases, the canvas needs to know _lastx and _lasty.
        # There are three ways to get this info the canvas:
        #
        # 1***REMOVED*** set it explicity
        #
        # 2***REMOVED*** call enter/leave events explicity.  The downside of this
        #    in the impl below is that enter could be repeatedly
        #    triggered if thes  mouse is over the axes and one is
        #    resizing with the keyboard.  This is not entirely bad,
        #    because the mouse position relative to the canvas is
        #    changing, but it may be surprising to get repeated entries
        #    without leaves
        #
        # 3***REMOVED*** process it as a motion notify event.  This also has pros
        #    and cons.  The mouse is moving relative to the window, but
        #    this may surpise an event handler writer who is getting
        #   motion_notify_events even if the mouse has not moved

        # here are the three scenarios
        if 1:
            # just manually set it
            self._lastx, self._lasty = xc, yc
        elif 0:
            # alternate implementation: process it as a motion
            FigureCanvasBase.motion_notify_event(self, xc, yc, guiEvent***REMOVED***
        elif 0:
            # alternate implementation -- process enter/leave events
            # instead of motion/notify
            if self.figure.bbox.contains(xc, yc***REMOVED***:
                self.enter_notify_event(guiEvent, xy=(xc,yc***REMOVED******REMOVED***
            else:
                self.leave_notify_event(guiEvent***REMOVED***

    def draw(self***REMOVED***:
        FigureCanvasAgg.draw(self***REMOVED***
        tkagg.blit(self._tkphoto, self.renderer._renderer, colormode=2***REMOVED***
        self._master.update_idletasks(***REMOVED***

    def blit(self, bbox=None***REMOVED***:
        tkagg.blit(self._tkphoto, self.renderer._renderer, bbox=bbox, colormode=2***REMOVED***
        self._master.update_idletasks(***REMOVED***

    show = draw

    def draw_idle(self***REMOVED***:
        'update drawing area only if idle'
        if self._idle is False:
            return

        self._idle = False

        def idle_draw(*args***REMOVED***:
            ***REMOVED***
                self.draw(***REMOVED***
            finally:
                self._idle = True

        self._idle_callback = self._tkcanvas.after_idle(idle_draw***REMOVED***

    def get_tk_widget(self***REMOVED***:
        ***REMOVED***returns the Tk widget used to implement FigureCanvasTkAgg.
        Although the initial implementation uses a Tk canvas,  this routine
        is intended to hide that fact.
        ***REMOVED***
        return self._tkcanvas

    def motion_notify_event(self, event***REMOVED***:
        x = event.x
        # flipy so y=0 is bottom of canvas
        y = self.figure.bbox.height - event.y
        FigureCanvasBase.motion_notify_event(self, x, y, guiEvent=event***REMOVED***


    def button_press_event(self, event, dblclick=False***REMOVED***:
        x = event.x
        # flipy so y=0 is bottom of canvas
        y = self.figure.bbox.height - event.y
        num = getattr(event, 'num', None***REMOVED***

        if sys.platform=='darwin':
            # 2 and 3 were reversed on the OSX platform I
            # tested under tkagg
            if   num==2: num=3
            elif num==3: num=2

        FigureCanvasBase.button_press_event(self, x, y, num, dblclick=dblclick, guiEvent=event***REMOVED***

    def button_dblclick_event(self,event***REMOVED***:
        self.button_press_event(event,dblclick=True***REMOVED***

    def button_release_event(self, event***REMOVED***:
        x = event.x
        # flipy so y=0 is bottom of canvas
        y = self.figure.bbox.height - event.y

        num = getattr(event, 'num', None***REMOVED***

        if sys.platform=='darwin':
            # 2 and 3 were reversed on the OSX platform I
            # tested under tkagg
            if   num==2: num=3
            elif num==3: num=2

        FigureCanvasBase.button_release_event(self, x, y, num, guiEvent=event***REMOVED***

    def scroll_event(self, event***REMOVED***:
        x = event.x
        y = self.figure.bbox.height - event.y
        num = getattr(event, 'num', None***REMOVED***
        if   num==4: step = +1
        elif num==5: step = -1
        else:        step =  0

        FigureCanvasBase.scroll_event(self, x, y, step, guiEvent=event***REMOVED***

    def scroll_event_windows(self, event***REMOVED***:
        ***REMOVED***MouseWheel event processor***REMOVED***
        # need to find the window that contains the mouse
        w = event.widget.winfo_containing(event.x_root, event.y_root***REMOVED***
        if w == self._tkcanvas:
            x = event.x_root - w.winfo_rootx(***REMOVED***
            y = event.y_root - w.winfo_rooty(***REMOVED***
            y = self.figure.bbox.height - y
            step = event.delta/120.
            FigureCanvasBase.scroll_event(self, x, y, step, guiEvent=event***REMOVED***

    def _get_key(self, event***REMOVED***:
        val = event.keysym_num
        if val in self.keyvald:
            key = self.keyvald[val***REMOVED***
        elif val == 0 and sys.platform == 'darwin' and \
                                        event.keycode in self._keycode_lookup:
            key = self._keycode_lookup[event.keycode***REMOVED***
        elif val < 256:
            key = chr(val***REMOVED***
        else:
            key = None

        # add modifier keys to the key string. Bit details originate from
        # http://effbot.org/tkinterbook/tkinter-events-and-bindings.htm
        # BIT_SHIFT = 0x001; BIT_CAPSLOCK = 0x002; BIT_CONTROL = 0x004;
        # BIT_LEFT_ALT = 0x008; BIT_NUMLOCK = 0x010; BIT_RIGHT_ALT = 0x080;
        # BIT_MB_1 = 0x100; BIT_MB_2 = 0x200; BIT_MB_3 = 0x400;
        # In general, the modifier key is excluded from the modifier flag,
        # however this is not the case on "darwin", so double check that
        # we aren't adding repeat modifier flags to a modifier key.
        if sys.platform == 'win32':
            modifiers = [(17, 'alt', 'alt'***REMOVED***,
                         (2, 'ctrl', 'control'***REMOVED***,
                         ***REMOVED***
        elif sys.platform == 'darwin':
            modifiers = [(3, 'super', 'super'***REMOVED***,
                         (4, 'alt', 'alt'***REMOVED***,
                         (2, 'ctrl', 'control'***REMOVED***,
                         ***REMOVED***
        else:
            modifiers = [(6, 'super', 'super'***REMOVED***,
                         (3, 'alt', 'alt'***REMOVED***,
                         (2, 'ctrl', 'control'***REMOVED***,
                         ***REMOVED***

        if key is not None:
            # note, shift is not added to the keys as this is already accounted for
            for bitmask, prefix, key_name in modifiers:
                if event.state & (1 << bitmask***REMOVED*** and key_name not in key:
                    key = '{0***REMOVED***+{1***REMOVED***'.format(prefix, key***REMOVED***

        return key

    def key_press(self, event***REMOVED***:
        key = self._get_key(event***REMOVED***
        FigureCanvasBase.key_press_event(self, key, guiEvent=event***REMOVED***

    def key_release(self, event***REMOVED***:
        key = self._get_key(event***REMOVED***
        FigureCanvasBase.key_release_event(self, key, guiEvent=event***REMOVED***

    def new_timer(self, *args, **kwargs***REMOVED***:
        ***REMOVED***
        Creates a new backend-specific subclass of :class:`backend_bases.Timer`.
        This is useful for getting periodic events through the backend's native
        event loop. Implemented only for backends with GUIs.

        optional arguments:

        *interval*
          Timer interval in milliseconds
        *callbacks*
          Sequence of (func, args, kwargs***REMOVED*** where func(*args, **kwargs***REMOVED*** will
          be executed by the timer every *interval*.
        ***REMOVED***
        return TimerTk(self._tkcanvas, *args, **kwargs***REMOVED***

    def flush_events(self***REMOVED***:
        self._master.update(***REMOVED***

    def start_event_loop(self,timeout***REMOVED***:
        FigureCanvasBase.start_event_loop_default(self,timeout***REMOVED***
    start_event_loop.__doc__=FigureCanvasBase.start_event_loop_default.__doc__

    def stop_event_loop(self***REMOVED***:
        FigureCanvasBase.stop_event_loop_default(self***REMOVED***
    stop_event_loop.__doc__=FigureCanvasBase.stop_event_loop_default.__doc__

class FigureManagerTkAgg(FigureManagerBase***REMOVED***:
    ***REMOVED***
    Public attributes

    canvas      : The FigureCanvas instance
    num         : The Figure number
    toolbar     : The tk.Toolbar
    window      : The tk.Window
    ***REMOVED***
    def __init__(self, canvas, num, window***REMOVED***:
        FigureManagerBase.__init__(self, canvas, num***REMOVED***
        self.window = window
        self.window.withdraw(***REMOVED***
        self.set_window_title("Figure %d" % num***REMOVED***
        self.canvas = canvas
        self.canvas._tkcanvas.pack(side=Tk.TOP, fill=Tk.BOTH, expand=1***REMOVED***
        self._num = num

        self.toolmanager = self._get_toolmanager(***REMOVED***
        self.toolbar = self._get_toolbar(***REMOVED***
        self.statusbar = None

        if self.toolmanager:
            backend_tools.add_tools_to_manager(self.toolmanager***REMOVED***
            if self.toolbar:
                backend_tools.add_tools_to_container(self.toolbar***REMOVED***
                self.statusbar = StatusbarTk(self.window, self.toolmanager***REMOVED***

        self._shown = False

        def notify_axes_change(fig***REMOVED***:
            'this will be called whenever the current axes is changed'
            if self.toolmanager is not None:
                pass
            elif self.toolbar is not None:
                self.toolbar.update(***REMOVED***
        self.canvas.figure.add_axobserver(notify_axes_change***REMOVED***

    def _get_toolbar(self***REMOVED***:
        if matplotlib.rcParams['toolbar'***REMOVED*** == 'toolbar2':
            toolbar = NavigationToolbar2TkAgg(self.canvas, self.window***REMOVED***
        elif matplotlib.rcParams['toolbar'***REMOVED*** == 'toolmanager':
            toolbar = ToolbarTk(self.toolmanager, self.window***REMOVED***
        else:
            toolbar = None
        return toolbar

    def _get_toolmanager(self***REMOVED***:
        if rcParams['toolbar'***REMOVED*** != 'toolbar2':
            toolmanager = ToolManager(self.canvas***REMOVED***
        else:
            toolmanager = None
        return toolmanager

    def resize(self, width, height=None***REMOVED***:
        # before 09-12-22, the resize method takes a single *event*
        # parameter. On the other hand, the resize method of other
        # FigureManager class takes *width* and *height* parameter,
        # which is used to change the size of the window. For the
        # Figure.set_size_inches with forward=True work with Tk
        # backend, I changed the function signature but tried to keep
        # it backward compatible. -JJL

        # when a single parameter is given, consider it as a event
        if height is None:
            width = width.width
        else:
            self.canvas._tkcanvas.master.geometry("%dx%d" % (width, height***REMOVED******REMOVED***

        if self.toolbar is not None:
            self.toolbar.configure(width=width***REMOVED***

    def show(self***REMOVED***:
        ***REMOVED***
        this function doesn't segfault but causes the
        PyEval_RestoreThread: NULL state bug on win32
        ***REMOVED***
        _focus = windowing.FocusManager(***REMOVED***
        if not self._shown:
            def destroy(*args***REMOVED***:
                self.window = None
                Gcf.destroy(self._num***REMOVED***
            self.canvas._tkcanvas.bind("<Destroy>", destroy***REMOVED***
            self.window.deiconify(***REMOVED***
            # anim.py requires this
            self.window.update(***REMOVED***
        else:
            self.canvas.draw_idle(***REMOVED***
        self._shown = True

    def destroy(self, *args***REMOVED***:
        if self.window is not None:
            #self.toolbar.destroy(***REMOVED***
            if self.canvas._idle_callback:
                self.canvas._tkcanvas.after_cancel(self.canvas._idle_callback***REMOVED***
            self.window.destroy(***REMOVED***
        if Gcf.get_num_fig_managers(***REMOVED***==0:
            if self.window is not None:
                self.window.quit(***REMOVED***
        self.window = None

    def get_window_title(self***REMOVED***:
        return self.window.wm_title(***REMOVED***

    def set_window_title(self, title***REMOVED***:
        self.window.wm_title(title***REMOVED***

    def full_screen_toggle(self***REMOVED***:
        is_fullscreen = bool(self.window.attributes('-fullscreen'***REMOVED******REMOVED***
        self.window.attributes('-fullscreen', not is_fullscreen***REMOVED***


class AxisMenu(object***REMOVED***:
    def __init__(self, master, naxes***REMOVED***:
        self._master = master
        self._naxes = naxes
        self._mbar = Tk.Frame(master=master, relief=Tk.RAISED, borderwidth=2***REMOVED***
        self._mbar.pack(side=Tk.LEFT***REMOVED***
        self._mbutton = Tk.Menubutton(
            master=self._mbar, text="Axes", underline=0***REMOVED***
        self._mbutton.pack(side=Tk.LEFT, padx="2m"***REMOVED***
        self._mbutton.menu = Tk.Menu(self._mbutton***REMOVED***
        self._mbutton.menu.add_command(
            label="Select All", command=self.select_all***REMOVED***
        self._mbutton.menu.add_command(
            label="Invert All", command=self.invert_all***REMOVED***
        self._axis_var = [***REMOVED***
        self._checkbutton = [***REMOVED***
        for i in range(naxes***REMOVED***:
            self._axis_var.append(Tk.IntVar(***REMOVED******REMOVED***
            self._axis_var[i***REMOVED***.set(1***REMOVED***
            self._checkbutton.append(self._mbutton.menu.add_checkbutton(
                label = "Axis %d" % (i+1***REMOVED***,
                variable=self._axis_var[i***REMOVED***,
                command=self.set_active***REMOVED******REMOVED***
            self._mbutton.menu.invoke(self._mbutton.menu.index("Select All"***REMOVED******REMOVED***
        self._mbutton['menu'***REMOVED*** = self._mbutton.menu
        self._mbar.tk_menuBar(self._mbutton***REMOVED***
        self.set_active(***REMOVED***

    def adjust(self, naxes***REMOVED***:
        if self._naxes < naxes:
            for i in range(self._naxes, naxes***REMOVED***:
                self._axis_var.append(Tk.IntVar(***REMOVED******REMOVED***
                self._axis_var[i***REMOVED***.set(1***REMOVED***
                self._checkbutton.append( self._mbutton.menu.add_checkbutton(
                    label = "Axis %d" % (i+1***REMOVED***,
                    variable=self._axis_var[i***REMOVED***,
                    command=self.set_active***REMOVED******REMOVED***
        elif self._naxes > naxes:
            for i in range(self._naxes-1, naxes-1, -1***REMOVED***:
                del self._axis_var[i***REMOVED***
                self._mbutton.menu.forget(self._checkbutton[i***REMOVED******REMOVED***
                del self._checkbutton[i***REMOVED***
        self._naxes = naxes
        self.set_active(***REMOVED***

    def get_indices(self***REMOVED***:
        a = [i for i in range(len(self._axis_var***REMOVED******REMOVED*** if self._axis_var[i***REMOVED***.get(***REMOVED******REMOVED***
        return a

    def set_active(self***REMOVED***:
        self._master.set_active(self.get_indices(***REMOVED******REMOVED***

    def invert_all(self***REMOVED***:
        for a in self._axis_var:
            a.set(not a.get(***REMOVED******REMOVED***
        self.set_active(***REMOVED***

    def select_all(self***REMOVED***:
        for a in self._axis_var:
            a.set(1***REMOVED***
        self.set_active(***REMOVED***


class NavigationToolbar2TkAgg(NavigationToolbar2, Tk.Frame***REMOVED***:
    ***REMOVED***
    Public attributes

      canvas   - the FigureCanvas  (gtk.DrawingArea***REMOVED***
      win   - the gtk.Window
    ***REMOVED***
    def __init__(self, canvas, window***REMOVED***:
        self.canvas = canvas
        self.window = window
        self._idle = True
        #Tk.Frame.__init__(self, master=self.canvas._tkcanvas***REMOVED***
        NavigationToolbar2.__init__(self, canvas***REMOVED***

    def destroy(self, *args***REMOVED***:
        del self.message
        Tk.Frame.destroy(self, *args***REMOVED***

    def set_message(self, s***REMOVED***:
        self.message.set(s***REMOVED***

    def draw_rubberband(self, event, x0, y0, x1, y1***REMOVED***:
        height = self.canvas.figure.bbox.height
        y0 =  height-y0
        y1 =  height-y1
        ***REMOVED*** self.lastrect
        except AttributeError: pass
        else: self.canvas._tkcanvas.delete(self.lastrect***REMOVED***
        self.lastrect = self.canvas._tkcanvas.create_rectangle(x0, y0, x1, y1***REMOVED***

        #self.canvas.draw(***REMOVED***

    def release(self, event***REMOVED***:
        ***REMOVED*** self.lastrect
        except AttributeError: pass
        else:
            self.canvas._tkcanvas.delete(self.lastrect***REMOVED***
            del self.lastrect

    def set_cursor(self, cursor***REMOVED***:
        self.window.configure(cursor=cursord[cursor***REMOVED******REMOVED***

    def _Button(self, text, file, command, extension='.ppm'***REMOVED***:
        img_file = os.path.join(rcParams['datapath'***REMOVED***, 'images', file + extension***REMOVED***
        im = Tk.PhotoImage(master=self, file=img_file***REMOVED***
        b = Tk.Button(
            master=self, text=text, padx=2, pady=2, image=im, command=command***REMOVED***
        b._ntimage = im
        b.pack(side=Tk.LEFT***REMOVED***
        return b

    def _init_toolbar(self***REMOVED***:
        xmin, xmax = self.canvas.figure.bbox.intervalx
        height, width = 50, xmax-xmin
        Tk.Frame.__init__(self, master=self.window,
                          width=int(width***REMOVED***, height=int(height***REMOVED***,
                          borderwidth=2***REMOVED***

        self.update(***REMOVED***  # Make axes menu

        for text, tooltip_text, image_file, callback in self.toolitems:
            if text is None:
                # spacer, unhandled in Tk
                pass
            else:
                button = self._Button(text=text, file=image_file,
                                   command=getattr(self, callback***REMOVED******REMOVED***
                if tooltip_text is not None:
                    ToolTip.createToolTip(button, tooltip_text***REMOVED***

        self.message = Tk.StringVar(master=self***REMOVED***
        self._message_label = Tk.Label(master=self, textvariable=self.message***REMOVED***
        self._message_label.pack(side=Tk.RIGHT***REMOVED***
        self.pack(side=Tk.BOTTOM, fill=Tk.X***REMOVED***


    def configure_subplots(self***REMOVED***:
        toolfig = Figure(figsize=(6,3***REMOVED******REMOVED***
        window = Tk.Tk(***REMOVED***
        canvas = FigureCanvasTkAgg(toolfig, master=window***REMOVED***
        toolfig.subplots_adjust(top=0.9***REMOVED***
        tool =  SubplotTool(self.canvas.figure, toolfig***REMOVED***
        canvas.show(***REMOVED***
        canvas.get_tk_widget(***REMOVED***.pack(side=Tk.TOP, fill=Tk.BOTH, expand=1***REMOVED***

    def save_figure(self, *args***REMOVED***:
        from matplotlib.externals.six.moves import tkinter_tkfiledialog, tkinter_messagebox
        filetypes = self.canvas.get_supported_filetypes(***REMOVED***.copy(***REMOVED***
        default_filetype = self.canvas.get_default_filetype(***REMOVED***

        # Tk doesn't provide a way to choose a default filetype,
        # so we just have to put it first
        default_filetype_name = filetypes[default_filetype***REMOVED***
        del filetypes[default_filetype***REMOVED***

        sorted_filetypes = list(six.iteritems(filetypes***REMOVED******REMOVED***
        sorted_filetypes.sort(***REMOVED***
        sorted_filetypes.insert(0, (default_filetype, default_filetype_name***REMOVED******REMOVED***

        tk_filetypes = [
            (name, '*.%s' % ext***REMOVED*** for (ext, name***REMOVED*** in sorted_filetypes***REMOVED***

        # adding a default extension seems to break the
        # asksaveasfilename dialog when you choose various save types
        # from the dropdown.  Passing in the empty string seems to
        # work - JDH!
        #defaultextension = self.canvas.get_default_filetype(***REMOVED***
        defaultextension = ''
        initialdir = rcParams.get('savefig.directory', ''***REMOVED***
        initialdir = os.path.expanduser(initialdir***REMOVED***
        initialfile = self.canvas.get_default_filename(***REMOVED***
        fname = tkinter_tkfiledialog.asksaveasfilename(
            master=self.window,
            title='Save the figure',
            filetypes=tk_filetypes,
            defaultextension=defaultextension,
            initialdir=initialdir,
            initialfile=initialfile,
            ***REMOVED***

        if fname == "" or fname == (***REMOVED***:
            return
        else:
            if initialdir == '':
                # explicitly missing key or empty str signals to use cwd
                rcParams['savefig.directory'***REMOVED*** = initialdir
            else:
                # save dir for next time
                rcParams['savefig.directory'***REMOVED*** = os.path.dirname(six.text_type(fname***REMOVED******REMOVED***
            ***REMOVED***
                # This method will handle the delegation to the correct type
                self.canvas.print_figure(fname***REMOVED***
            except Exception as e:
                tkinter_messagebox.showerror("Error saving file", str(e***REMOVED******REMOVED***

    def set_active(self, ind***REMOVED***:
        self._ind = ind
        self._active = [ self._axes[i***REMOVED*** for i in self._ind ***REMOVED***

    def update(self***REMOVED***:
        _focus = windowing.FocusManager(***REMOVED***
        self._axes = self.canvas.figure.axes
        naxes = len(self._axes***REMOVED***
        #if not hasattr(self, "omenu"***REMOVED***:
        #    self.set_active(range(naxes***REMOVED******REMOVED***
        #    self.omenu = AxisMenu(master=self, naxes=naxes***REMOVED***
        #else:
        #    self.omenu.adjust(naxes***REMOVED***
        NavigationToolbar2.update(self***REMOVED***

    def dynamic_update(self***REMOVED***:
        'update drawing area only if idle'
        # legacy method; new method is canvas.draw_idle
        self.canvas.draw_idle(***REMOVED***


class ToolTip(object***REMOVED***:
    ***REMOVED***
    Tooltip recipe from
    http://www.voidspace.org.uk/python/weblog/arch_d7_2006_07_01.shtml#e387
    ***REMOVED***
    @staticmethod
    def createToolTip(widget, text***REMOVED***:
        toolTip = ToolTip(widget***REMOVED***
        def enter(event***REMOVED***:
            toolTip.showtip(text***REMOVED***
        def leave(event***REMOVED***:
            toolTip.hidetip(***REMOVED***
        widget.bind('<Enter>', enter***REMOVED***
        widget.bind('<Leave>', leave***REMOVED***

    def __init__(self, widget***REMOVED***:
        self.widget = widget
        self.tipwindow = None
        self.id = None
        self.x = self.y = 0

    def showtip(self, text***REMOVED***:
        "Display text in tooltip window"
        self.text = text
        if self.tipwindow or not self.text:
            return
        x, y, _, _ = self.widget.bbox("insert"***REMOVED***
        x = x + self.widget.winfo_rootx(***REMOVED*** + 27
        y = y + self.widget.winfo_rooty(***REMOVED***
        self.tipwindow = tw = Tk.Toplevel(self.widget***REMOVED***
        tw.wm_overrideredirect(1***REMOVED***
        tw.wm_geometry("+%d+%d" % (x, y***REMOVED******REMOVED***
        ***REMOVED***
            # For Mac OS
            tw.tk.call("::tk::unsupported::MacWindowStyle",
                       "style", tw._w,
                       "help", "noActivates"***REMOVED***
        except Tk.TclError:
            pass
        label = Tk.Label(tw, text=self.text, justify=Tk.LEFT,
                      background="#ffffe0", relief=Tk.SOLID, borderwidth=1,
                      ***REMOVED***
        label.pack(ipadx=1***REMOVED***

    def hidetip(self***REMOVED***:
        tw = self.tipwindow
        self.tipwindow = None
        if tw:
            tw.destroy(***REMOVED***


class RubberbandTk(backend_tools.RubberbandBase***REMOVED***:
    def __init__(self, *args, **kwargs***REMOVED***:
        backend_tools.RubberbandBase.__init__(self, *args, **kwargs***REMOVED***

    def draw_rubberband(self, x0, y0, x1, y1***REMOVED***:
        height = self.figure.canvas.figure.bbox.height
        y0 = height - y0
        y1 = height - y1
        ***REMOVED***
            self.lastrect
        except AttributeError:
            pass
        else:
            self.figure.canvas._tkcanvas.delete(self.lastrect***REMOVED***
        self.lastrect = self.figure.canvas._tkcanvas.create_rectangle(x0, y0, x1, y1***REMOVED***

    def remove_rubberband(self***REMOVED***:
        ***REMOVED***
            self.lastrect
        except AttributeError:
            pass
        else:
            self.figure.canvas._tkcanvas.delete(self.lastrect***REMOVED***
            del self.lastrect


class SetCursorTk(backend_tools.SetCursorBase***REMOVED***:
    def set_cursor(self, cursor***REMOVED***:
        self.figure.canvas.manager.window.configure(cursor=cursord[cursor***REMOVED******REMOVED***


class ToolbarTk(ToolContainerBase, Tk.Frame***REMOVED***:
    def __init__(self, toolmanager, window***REMOVED***:
        ToolContainerBase.__init__(self, toolmanager***REMOVED***
        xmin, xmax = self.toolmanager.canvas.figure.bbox.intervalx
        height, width = 50, xmax - xmin
        Tk.Frame.__init__(self, master=window,
                          width=int(width***REMOVED***, height=int(height***REMOVED***,
                          borderwidth=2***REMOVED***
        self._toolitems = {***REMOVED***
        self.pack(side=Tk.TOP, fill=Tk.X***REMOVED***
        self._groups = {***REMOVED***

    def add_toolitem(self, name, group, position, image_file, description,
                     toggle***REMOVED***:
        frame = self._get_groupframe(group***REMOVED***
        button = self._Button(name, image_file, toggle, frame***REMOVED***
        if description is not None:
            ToolTip.createToolTip(button, description***REMOVED***
        self._toolitems.setdefault(name, [***REMOVED******REMOVED***
        self._toolitems[name***REMOVED***.append(button***REMOVED***

    def _get_groupframe(self, group***REMOVED***:
        if group not in self._groups:
            if self._groups:
                self._add_separator(***REMOVED***
            frame = Tk.Frame(master=self, borderwidth=0***REMOVED***
            frame.pack(side=Tk.LEFT, fill=Tk.Y***REMOVED***
            self._groups[group***REMOVED*** = frame
        return self._groups[group***REMOVED***

    def _add_separator(self***REMOVED***:
        separator = Tk.Frame(master=self, bd=5, width=1, bg='black'***REMOVED***
        separator.pack(side=Tk.LEFT, fill=Tk.Y, padx=2***REMOVED***

    def _Button(self, text, image_file, toggle, frame***REMOVED***:
        if image_file is not None:
            im = Tk.PhotoImage(master=self, file=image_file***REMOVED***
        else:
            im = None

        if not toggle:
            b = Tk.Button(master=frame, text=text, padx=2, pady=2, image=im,
                          command=lambda: self._button_click(text***REMOVED******REMOVED***
        else:
            b = Tk.Checkbutton(master=frame, text=text, padx=2, pady=2,
                               image=im, indicatoron=False,
                               command=lambda: self._button_click(text***REMOVED******REMOVED***
        b._ntimage = im
        b.pack(side=Tk.LEFT***REMOVED***
        return b

    def _button_click(self, name***REMOVED***:
        self.trigger_tool(name***REMOVED***

    def toggle_toolitem(self, name, toggled***REMOVED***:
        if name not in self._toolitems:
            return
        for toolitem in self._toolitems[name***REMOVED***:
            if toggled:
                toolitem.select(***REMOVED***
            else:
                toolitem.deselect(***REMOVED***

    def remove_toolitem(self, name***REMOVED***:
        for toolitem in self._toolitems[name***REMOVED***:
            toolitem.pack_forget(***REMOVED***
        del self._toolitems[name***REMOVED***


class StatusbarTk(StatusbarBase, Tk.Frame***REMOVED***:
    def __init__(self, window, *args, **kwargs***REMOVED***:
        StatusbarBase.__init__(self, *args, **kwargs***REMOVED***
        xmin, xmax = self.toolmanager.canvas.figure.bbox.intervalx
        height, width = 50, xmax - xmin
        Tk.Frame.__init__(self, master=window,
                          width=int(width***REMOVED***, height=int(height***REMOVED***,
                          borderwidth=2***REMOVED***
        self._message = Tk.StringVar(master=self***REMOVED***
        self._message_label = Tk.Label(master=self, textvariable=self._message***REMOVED***
        self._message_label.pack(side=Tk.RIGHT***REMOVED***
        self.pack(side=Tk.TOP, fill=Tk.X***REMOVED***

    def set_message(self, s***REMOVED***:
        self._message.set(s***REMOVED***


class SaveFigureTk(backend_tools.SaveFigureBase***REMOVED***:
    def trigger(self, *args***REMOVED***:
        from matplotlib.externals.six.moves import tkinter_tkfiledialog, tkinter_messagebox
        filetypes = self.figure.canvas.get_supported_filetypes(***REMOVED***.copy(***REMOVED***
        default_filetype = self.figure.canvas.get_default_filetype(***REMOVED***

        # Tk doesn't provide a way to choose a default filetype,
        # so we just have to put it first
        default_filetype_name = filetypes[default_filetype***REMOVED***
        del filetypes[default_filetype***REMOVED***

        sorted_filetypes = list(six.iteritems(filetypes***REMOVED******REMOVED***
        sorted_filetypes.sort(***REMOVED***
        sorted_filetypes.insert(0, (default_filetype, default_filetype_name***REMOVED******REMOVED***

        tk_filetypes = [
            (name, '*.%s' % ext***REMOVED*** for (ext, name***REMOVED*** in sorted_filetypes***REMOVED***

        # adding a default extension seems to break the
        # asksaveasfilename dialog when you choose various save types
        # from the dropdown.  Passing in the empty string seems to
        # work - JDH!
        # defaultextension = self.figure.canvas.get_default_filetype(***REMOVED***
        defaultextension = ''
        initialdir = rcParams.get('savefig.directory', ''***REMOVED***
        initialdir = os.path.expanduser(initialdir***REMOVED***
        initialfile = self.figure.canvas.get_default_filename(***REMOVED***
        fname = tkinter_tkfiledialog.asksaveasfilename(
            master=self.figure.canvas.manager.window,
            title='Save the figure',
            filetypes=tk_filetypes,
            defaultextension=defaultextension,
            initialdir=initialdir,
            initialfile=initialfile,
            ***REMOVED***

        if fname == "" or fname == (***REMOVED***:
            return
        else:
            if initialdir == '':
                # explicitly missing key or empty str signals to use cwd
                rcParams['savefig.directory'***REMOVED*** = initialdir
            else:
                # save dir for next time
                rcParams['savefig.directory'***REMOVED*** = os.path.dirname(
                    six.text_type(fname***REMOVED******REMOVED***
            ***REMOVED***
                # This method will handle the delegation to the correct type
                self.figure.canvas.print_figure(fname***REMOVED***
            except Exception as e:
                tkinter_messagebox.showerror("Error saving file", str(e***REMOVED******REMOVED***


class ConfigureSubplotsTk(backend_tools.ConfigureSubplotsBase***REMOVED***:
    def __init__(self, *args, **kwargs***REMOVED***:
        backend_tools.ConfigureSubplotsBase.__init__(self, *args, **kwargs***REMOVED***
        self.window = None

    def trigger(self, *args***REMOVED***:
        self.init_window(***REMOVED***
        self.window.lift(***REMOVED***

    def init_window(self***REMOVED***:
        if self.window:
            return

        toolfig = Figure(figsize=(6, 3***REMOVED******REMOVED***
        self.window = Tk.Tk(***REMOVED***

        canvas = FigureCanvasTkAgg(toolfig, master=self.window***REMOVED***
        toolfig.subplots_adjust(top=0.9***REMOVED***
        _tool = SubplotTool(self.figure, toolfig***REMOVED***
        canvas.show(***REMOVED***
        canvas.get_tk_widget(***REMOVED***.pack(side=Tk.TOP, fill=Tk.BOTH, expand=1***REMOVED***
        self.window.protocol("WM_DELETE_WINDOW", self.destroy***REMOVED***

    def destroy(self, *args, **kwargs***REMOVED***:
        self.window.destroy(***REMOVED***
        self.window = None


backend_tools.ToolSaveFigure = SaveFigureTk
backend_tools.ToolConfigureSubplots = ConfigureSubplotsTk
backend_tools.ToolSetCursor = SetCursorTk
backend_tools.ToolRubberband = RubberbandTk
Toolbar = ToolbarTk
FigureCanvas = FigureCanvasTkAgg
FigureManager = FigureManagerTkAgg
