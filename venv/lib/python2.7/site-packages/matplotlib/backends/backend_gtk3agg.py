from __future__ import (absolute_import, division, print_function,
                        unicode_literals***REMOVED***

from matplotlib.externals import six

import numpy as np
import sys
import warnings

from . import backend_agg
from . import backend_gtk3
from .backend_cairo import cairo, HAS_CAIRO_CFFI
from matplotlib.figure import Figure
from matplotlib import transforms

if six.PY3 and not HAS_CAIRO_CFFI:
    warnings.warn(
        "The Gtk3Agg backend is known to not work on Python 3.x with pycairo. "
        "Try installing cairocffi."***REMOVED***


class FigureCanvasGTK3Agg(backend_gtk3.FigureCanvasGTK3,
                          backend_agg.FigureCanvasAgg***REMOVED***:
    def __init__(self, figure***REMOVED***:
        backend_gtk3.FigureCanvasGTK3.__init__(self, figure***REMOVED***
        self._bbox_queue = [***REMOVED***

    def _renderer_init(self***REMOVED***:
        pass

    def _render_figure(self, width, height***REMOVED***:
        backend_agg.FigureCanvasAgg.draw(self***REMOVED***

    def on_draw_event(self, widget, ctx***REMOVED***:
        ***REMOVED*** GtkDrawable draw event, like expose_event in GTK 2.X
        ***REMOVED***
        allocation = self.get_allocation(***REMOVED***
        w, h = allocation.width, allocation.height

        if not len(self._bbox_queue***REMOVED***:
            if self._need_redraw:
                self._render_figure(w, h***REMOVED***
                bbox_queue = [transforms.Bbox([[0, 0***REMOVED***, [w, h***REMOVED******REMOVED******REMOVED******REMOVED***
            else:
                return
        else:
            bbox_queue = self._bbox_queue

        if HAS_CAIRO_CFFI:
            ctx = cairo.Context._from_pointer(
                cairo.ffi.cast('cairo_t **',
                               id(ctx***REMOVED*** + object.__basicsize__***REMOVED***[0***REMOVED***,
                incref=True***REMOVED***

        for bbox in bbox_queue:
            area = self.copy_from_bbox(bbox***REMOVED***
            buf = np.fromstring(area.to_string_argb(***REMOVED***, dtype='uint8'***REMOVED***

            x = int(bbox.x0***REMOVED***
            y = h - int(bbox.y1***REMOVED***
            width = int(bbox.x1***REMOVED*** - int(bbox.x0***REMOVED***
            height = int(bbox.y1***REMOVED*** - int(bbox.y0***REMOVED***

            if HAS_CAIRO_CFFI:
                image = cairo.ImageSurface.create_for_data(
                    buf.data, cairo.FORMAT_ARGB32, width, height***REMOVED***
            else:
                image = cairo.ImageSurface.create_for_data(
                    buf, cairo.FORMAT_ARGB32, width, height***REMOVED***
            ctx.set_source_surface(image, x, y***REMOVED***
            ctx.paint(***REMOVED***

        if len(self._bbox_queue***REMOVED***:
            self._bbox_queue = [***REMOVED***

        return False

    def blit(self, bbox=None***REMOVED***:
        # If bbox is None, blit the entire canvas to gtk. Otherwise
        # blit only the area defined by the bbox.
        if bbox is None:
            bbox = self.figure.bbox

        allocation = self.get_allocation(***REMOVED***
        w, h = allocation.width, allocation.height
        x = int(bbox.x0***REMOVED***
        y = h - int(bbox.y1***REMOVED***
        width = int(bbox.x1***REMOVED*** - int(bbox.x0***REMOVED***
        height = int(bbox.y1***REMOVED*** - int(bbox.y0***REMOVED***

        self._bbox_queue.append(bbox***REMOVED***
        self.queue_draw_area(x, y, width, height***REMOVED***

    def print_png(self, filename, *args, **kwargs***REMOVED***:
        # Do this so we can save the resolution of figure in the PNG file
        agg = self.switch_backends(backend_agg.FigureCanvasAgg***REMOVED***
        return agg.print_png(filename, *args, **kwargs***REMOVED***


class FigureManagerGTK3Agg(backend_gtk3.FigureManagerGTK3***REMOVED***:
    pass


def new_figure_manager(num, *args, **kwargs***REMOVED***:
    ***REMOVED***
    Create a new figure manager instance
    ***REMOVED***
    FigureClass = kwargs.pop('FigureClass', Figure***REMOVED***
    thisFig = FigureClass(*args, **kwargs***REMOVED***
    return new_figure_manager_given_figure(num, thisFig***REMOVED***


def new_figure_manager_given_figure(num, figure***REMOVED***:
    ***REMOVED***
    Create a new figure manager instance for the given figure.
    ***REMOVED***
    canvas = FigureCanvasGTK3Agg(figure***REMOVED***
    manager = FigureManagerGTK3Agg(canvas, num***REMOVED***
    return manager


FigureCanvas = FigureCanvasGTK3Agg
FigureManager = FigureManagerGTK3Agg
show = backend_gtk3.show
