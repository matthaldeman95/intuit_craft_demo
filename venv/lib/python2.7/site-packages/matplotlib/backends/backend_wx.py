***REMOVED***
 A wxPython backend for matplotlib, based (very heavily***REMOVED*** on
 backend_template.py and backend_gtk.py

 Author: Jeremy O'Donoghue (jeremy@o-donoghue.com***REMOVED***

 Derived from original copyright work by John Hunter
 (jdhunter@ace.bsd.uchicago.edu***REMOVED***

 Copyright (C***REMOVED*** Jeremy O'Donoghue & John Hunter, 2003-4

 License: This work is licensed under a PSF compatible license. A copy
 should be included with this source code.

***REMOVED***
from __future__ import (absolute_import, division, print_function,
                        unicode_literals***REMOVED***

from matplotlib.externals.six.moves import xrange

import sys
***REMOVED***
***REMOVED***.path
import math
import weakref
import warnings

import numpy as np

import matplotlib
from matplotlib.backend_bases import (RendererBase, GraphicsContextBase,
    FigureCanvasBase, FigureManagerBase, NavigationToolbar2,
    cursors, TimerBase***REMOVED***
from matplotlib.backend_bases import ShowBase
from matplotlib.backend_bases import _has_pil

from matplotlib._pylab_helpers import Gcf
from matplotlib.cbook import is_string_like, is_writable_file_like
from matplotlib.figure import Figure
from matplotlib.path import Path
from matplotlib.transforms import Affine2D
from matplotlib.widgets import SubplotTool
from matplotlib import rcParams

from . import wx_compat as wxc
import wx

# Debugging settings here...
# Debug level set here. If the debug level is less than 5, information
# messages (progressively more info for lower value***REMOVED*** are printed. In addition,
# traceback is performed, and pdb activated, for all uncaught exceptions in
# this case
_DEBUG = 5
if _DEBUG < 5:
    import traceback
    import pdb
_DEBUG_lvls = {1: 'Low ', 2: 'Med ', 3: 'High', 4: 'Error'***REMOVED***


def DEBUG_MSG(string, lvl=3, o=None***REMOVED***:
    if lvl >= _DEBUG:
        cls = o.__class__
        # Jeremy, often times the commented line won't print but the
        # one below does.  I think WX is redefining stderr, damned
        # beast
        #print >>sys.stderr, "%s- %s in %s" % (_DEBUG_lvls[lvl***REMOVED***, string, cls***REMOVED***
        print("%s- %s in %s" % (_DEBUG_lvls[lvl***REMOVED***, string, cls***REMOVED******REMOVED***


def debug_on_error(type, value, tb***REMOVED***:
    ***REMOVED***Code due to Thomas Heller - published in Python Cookbook (O'Reilley***REMOVED******REMOVED***
    traceback.print_exc(type, value, tb***REMOVED***
    print(***REMOVED***
    pdb.pm(***REMOVED***  # jdh uncomment


class fake_stderr(object***REMOVED***:
    ***REMOVED***
    Wx does strange things with stderr, as it makes the assumption that
    there is probably no console. This redirects stderr to the console, since
    we know that there is one!
    ***REMOVED***

    def write(self, msg***REMOVED***:
        print("Stderr: %s\n\r" % msg***REMOVED***

#if _DEBUG < 5:
    #sys.excepthook = debug_on_error
    #WxLogger =wx.LogStderr(***REMOVED***
    #sys.stderr = fake_stderr

# the True dots per inch on the screen; should be display dependent
# see
# http://groups.google.com/groups?q=screen+dpi+x11&hl=en&lr=&ie=UTF-8&oe=UTF-8&safe=off&selm=7077.26e81ad5%40swift.cs.tcd.ie&rnum=5
# for some info about screen dpi
PIXELS_PER_INCH = 75

# Delay time for idle checks
IDLE_DELAY = 5


def error_msg_wx(msg, parent=None***REMOVED***:
    ***REMOVED***
    Signal an error condition -- in a GUI, popup a error dialog
    ***REMOVED***
    dialog = wx.MessageDialog(parent=parent,
                              message=msg,
                              caption='Matplotlib backend_wx error',
                              style=wx.OK | wx.CENTRE***REMOVED***
    dialog.ShowModal(***REMOVED***
    dialog.Destroy(***REMOVED***
    return None


def raise_msg_to_str(msg***REMOVED***:
    ***REMOVED***msg is a return arg from a raise.  Join with new lines***REMOVED***
    if not is_string_like(msg***REMOVED***:
        msg = '\n'.join(map(str, msg***REMOVED******REMOVED***
    return msg


class TimerWx(TimerBase***REMOVED***:
    '''
    Subclass of :class:`backend_bases.TimerBase` that uses WxTimer events.

    Attributes:
    * interval: The time between timer events in milliseconds. Default
        is 1000 ms.
    * single_shot: Boolean flag indicating whether this timer should
        operate as single shot (run once and then stop***REMOVED***. Defaults to False.
    * callbacks: Stores list of (func, args***REMOVED*** tuples that will be called
        upon timer events. This list can be manipulated directly, or the
        functions add_callback and remove_callback can be used.
    '''

    def __init__(self, parent, *args, **kwargs***REMOVED***:
        TimerBase.__init__(self, *args, **kwargs***REMOVED***

        # Create a new timer and connect the timer event to our handler.
        # For WX, the events have to use a widget for binding.
        self.parent = parent
        self._timer = wx.Timer(self.parent, wx.NewId(***REMOVED******REMOVED***
        self.parent.Bind(wx.EVT_TIMER, self._on_timer, self._timer***REMOVED***

     # Unbinding causes Wx to stop for some reason. Disabling for now.
#    def __del__(self***REMOVED***:
#        TimerBase.__del__(self***REMOVED***
#        self.parent.Bind(wx.EVT_TIMER, None, self._timer***REMOVED***

    def _timer_start(self***REMOVED***:
        self._timer.Start(self._interval, self._single***REMOVED***

    def _timer_stop(self***REMOVED***:
        self._timer.Stop(***REMOVED***

    def _timer_set_interval(self***REMOVED***:
        self._timer_start(***REMOVED***

    def _timer_set_single_shot(self***REMOVED***:
        self._timer.Start(***REMOVED***

    def _on_timer(self, *args***REMOVED***:
        TimerBase._on_timer(self***REMOVED***


class RendererWx(RendererBase***REMOVED***:
    ***REMOVED***
    The renderer handles all the drawing primitives using a graphics
    context instance that controls the colors/styles. It acts as the
    'renderer' instance used by many classes in the hierarchy.
    ***REMOVED***
    # In wxPython, drawing is performed on a wxDC instance, which will
    # generally be mapped to the client aread of the window displaying
    # the plot. Under wxPython, the wxDC instance has a wx.Pen which
    # describes the colour and weight of any lines drawn, and a wxBrush
    # which describes the fill colour of any closed polygon.

    fontweights = wxc.fontweights
    fontangles = wxc.fontangles

    # wxPython allows for portable font styles, choosing them appropriately
    # for the target platform. Map some standard font names to the portable
    # styles
    # QUESTION: Is it be wise to agree standard fontnames across all backends?
    fontnames = wxc.fontnames

    def __init__(self, bitmap, dpi***REMOVED***:
        ***REMOVED***
        Initialise a wxWindows renderer instance.
        ***REMOVED***
        RendererBase.__init__(self***REMOVED***
        DEBUG_MSG("__init__(***REMOVED***", 1, self***REMOVED***
        self.width = bitmap.GetWidth(***REMOVED***
        self.height = bitmap.GetHeight(***REMOVED***
        self.bitmap = bitmap
        self.fontd = {***REMOVED***
        self.dpi = dpi
        self.gc = None

    def flipy(self***REMOVED***:
        return True

    def offset_text_height(self***REMOVED***:
        return True

    def get_text_width_height_descent(self, s, prop, ismath***REMOVED***:
        ***REMOVED***
        get the width and height in display coords of the string s
        with FontPropertry prop
        ***REMOVED***
        # return 1, 1
        if ismath:
            s = self.strip_math(s***REMOVED***

        if self.gc is None:
            gc = self.new_gc(***REMOVED***
        else:
            gc = self.gc
        gfx_ctx = gc.gfx_ctx
        font = self.get_wx_font(s, prop***REMOVED***
        gfx_ctx.SetFont(font, wx.BLACK***REMOVED***
        w, h, descent, leading = gfx_ctx.GetFullTextExtent(s***REMOVED***

        return w, h, descent

    def get_canvas_width_height(self***REMOVED***:
        'return the canvas width and height in display coords'
        return self.width, self.height

    def handle_clip_rectangle(self, gc***REMOVED***:
        new_bounds = gc.get_clip_rectangle(***REMOVED***
        if new_bounds is not None:
            new_bounds = new_bounds.bounds
        gfx_ctx = gc.gfx_ctx
        if gfx_ctx._lastcliprect != new_bounds:
            gfx_ctx._lastcliprect = new_bounds
            if new_bounds is None:
                gfx_ctx.ResetClip(***REMOVED***
            else:
                gfx_ctx.Clip(new_bounds[0***REMOVED***,
                             self.height - new_bounds[1***REMOVED*** - new_bounds[3***REMOVED***,
                             new_bounds[2***REMOVED***, new_bounds[3***REMOVED******REMOVED***

    @staticmethod
    def convert_path(gfx_ctx, path, transform***REMOVED***:
        wxpath = gfx_ctx.CreatePath(***REMOVED***
        for points, code in path.iter_segments(transform***REMOVED***:
            if code == Path.MOVETO:
                wxpath.MoveToPoint(*points***REMOVED***
            elif code == Path.LINETO:
                wxpath.AddLineToPoint(*points***REMOVED***
            elif code == Path.CURVE3:
                wxpath.AddQuadCurveToPoint(*points***REMOVED***
            elif code == Path.CURVE4:
                wxpath.AddCurveToPoint(*points***REMOVED***
            elif code == Path.CLOSEPOLY:
                wxpath.CloseSubpath(***REMOVED***
        return wxpath

    def draw_path(self, gc, path, transform, rgbFace=None***REMOVED***:
        gc.select(***REMOVED***
        self.handle_clip_rectangle(gc***REMOVED***
        gfx_ctx = gc.gfx_ctx
        transform = transform + \
            Affine2D(***REMOVED***.scale(1.0, -1.0***REMOVED***.translate(0.0, self.height***REMOVED***
        wxpath = self.convert_path(gfx_ctx, path, transform***REMOVED***
        if rgbFace is not None:
            gfx_ctx.SetBrush(wx.Brush(gc.get_wxcolour(rgbFace***REMOVED******REMOVED******REMOVED***
            gfx_ctx.DrawPath(wxpath***REMOVED***
        else:
            gfx_ctx.StrokePath(wxpath***REMOVED***
        gc.unselect(***REMOVED***

    def draw_image(self, gc, x, y, im***REMOVED***:
        bbox = gc.get_clip_rectangle(***REMOVED***
        if bbox is not None:
            l, b, w, h = bbox.bounds
        else:
            l = 0
            b = 0
            w = self.width
            h = self.height
        rows, cols, image_str = im.as_rgba_str(***REMOVED***
        image_array = np.fromstring(image_str, np.uint8***REMOVED***
        image_array.shape = rows, cols, 4
        bitmap = wxc.BitmapFromBuffer(cols, rows, image_array***REMOVED***
        gc = self.get_gc(***REMOVED***
        gc.select(***REMOVED***
        gc.gfx_ctx.DrawBitmap(bitmap, int(l***REMOVED***, int(self.height - b***REMOVED***,
                              int(w***REMOVED***, int(-h***REMOVED******REMOVED***
        gc.unselect(***REMOVED***

    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None***REMOVED***:
        if ismath:
            s = self.strip_math(s***REMOVED***
        DEBUG_MSG("draw_text(***REMOVED***", 1, self***REMOVED***
        gc.select(***REMOVED***
        self.handle_clip_rectangle(gc***REMOVED***
        gfx_ctx = gc.gfx_ctx

        font = self.get_wx_font(s, prop***REMOVED***
        color = gc.get_wxcolour(gc.get_rgb(***REMOVED******REMOVED***
        gfx_ctx.SetFont(font, color***REMOVED***

        w, h, d = self.get_text_width_height_descent(s, prop, ismath***REMOVED***
        x = int(x***REMOVED***
        y = int(y - h***REMOVED***

        if angle == 0.0:
            gfx_ctx.DrawText(s, x, y***REMOVED***
        else:
            rads = angle / 180.0 * math.pi
            xo = h * math.sin(rads***REMOVED***
            yo = h * math.cos(rads***REMOVED***
            gfx_ctx.DrawRotatedText(s, x - xo, y - yo, rads***REMOVED***

        gc.unselect(***REMOVED***

    def new_gc(self***REMOVED***:
        ***REMOVED***
        Return an instance of a GraphicsContextWx, and sets the current gc copy
        ***REMOVED***
        DEBUG_MSG('new_gc(***REMOVED***', 2, self***REMOVED***
        self.gc = GraphicsContextWx(self.bitmap, self***REMOVED***
        self.gc.select(***REMOVED***
        self.gc.unselect(***REMOVED***
        return self.gc

    def get_gc(self***REMOVED***:
        ***REMOVED***
        Fetch the locally cached gc.
        ***REMOVED***
        # This is a dirty hack to allow anything with access to a renderer to
        # access the current graphics context
        assert self.gc is not None, "gc must be defined"
        return self.gc

    def get_wx_font(self, s, prop***REMOVED***:
        ***REMOVED***
        Return a wx font.  Cache instances in a font dictionary for
        efficiency
        ***REMOVED***
        DEBUG_MSG("get_wx_font(***REMOVED***", 1, self***REMOVED***

        key = hash(prop***REMOVED***
        fontprop = prop
        fontname = fontprop.get_name(***REMOVED***

        font = self.fontd.get(key***REMOVED***
        if font is not None:
            return font

        # Allow use of platform independent and dependent font names
        wxFontname = self.fontnames.get(fontname, wx.ROMAN***REMOVED***
        wxFacename = ''  # Empty => wxPython chooses based on wx_fontname

        # Font colour is determined by the active wx.Pen
        # TODO: It may be wise to cache font information
        size = self.points_to_pixels(fontprop.get_size_in_points(***REMOVED******REMOVED***

        font = wx.Font(int(size + 0.5***REMOVED***,             # Size
                       wxFontname,                # 'Generic' name
                       self.fontangles[fontprop.get_style(***REMOVED******REMOVED***,   # Angle
                       self.fontweights[fontprop.get_weight(***REMOVED******REMOVED***,  # Weight
                       False,                     # Underline
                       wxFacename***REMOVED***                # Platform font name

        # cache the font and gc and return it
        self.fontd[key***REMOVED*** = font

        return font

    def points_to_pixels(self, points***REMOVED***:
        ***REMOVED***
        convert point measures to pixes using dpi and the pixels per
        inch of the display
        ***REMOVED***
        return points * (PIXELS_PER_INCH / 72.0 * self.dpi / 72.0***REMOVED***


class GraphicsContextWx(GraphicsContextBase***REMOVED***:
    ***REMOVED***
    The graphics context provides the color, line styles, etc...

    This class stores a reference to a wxMemoryDC, and a
    wxGraphicsContext that draws to it.  Creating a wxGraphicsContext
    seems to be fairly heavy, so these objects are cached based on the
    bitmap object that is passed in.

    The base GraphicsContext stores colors as a RGB tuple on the unit
    interval, e.g., (0.5, 0.0, 1.0***REMOVED***.  wxPython uses an int interval, but
    since wxPython colour management is rather simple, I have not chosen
    to implement a separate colour manager class.
    ***REMOVED***
    _capd = {'butt': wx.CAP_BUTT,
             'projecting': wx.CAP_PROJECTING,
             'round': wx.CAP_ROUND***REMOVED***

    _joind = {'bevel': wx.JOIN_BEVEL,
              'miter': wx.JOIN_MITER,
              'round': wx.JOIN_ROUND***REMOVED***

    _dashd_wx = wxc.dashd_wx

    _cache = weakref.WeakKeyDictionary(***REMOVED***

    def __init__(self, bitmap, renderer***REMOVED***:
        GraphicsContextBase.__init__(self***REMOVED***
        #assert self.Ok(***REMOVED***, "wxMemoryDC not OK to use"
        DEBUG_MSG("__init__(***REMOVED***", 1, self***REMOVED***
        DEBUG_MSG("__init__(***REMOVED*** 2: %s" % bitmap, 1, self***REMOVED***

        dc, gfx_ctx = self._cache.get(bitmap, (None, None***REMOVED******REMOVED***
        if dc is None:
            dc = wx.MemoryDC(***REMOVED***
            dc.SelectObject(bitmap***REMOVED***
            gfx_ctx = wx.GraphicsContext.Create(dc***REMOVED***
            gfx_ctx._lastcliprect = None
            self._cache[bitmap***REMOVED*** = dc, gfx_ctx

        self.bitmap = bitmap
        self.dc = dc
        self.gfx_ctx = gfx_ctx
        self._pen = wx.Pen('BLACK', 1, wx.SOLID***REMOVED***
        gfx_ctx.SetPen(self._pen***REMOVED***
        self._style = wx.SOLID
        self.renderer = renderer

    def select(self***REMOVED***:
        ***REMOVED***
        Select the current bitmap into this wxDC instance
        ***REMOVED***

        if sys.platform == 'win32':
            self.dc.SelectObject(self.bitmap***REMOVED***
            self.IsSelected = True

    def unselect(self***REMOVED***:
        ***REMOVED***
        Select a Null bitmasp into this wxDC instance
        ***REMOVED***
        if sys.platform == 'win32':
            self.dc.SelectObject(wx.NullBitmap***REMOVED***
            self.IsSelected = False

    def set_foreground(self, fg, isRGBA=None***REMOVED***:
        ***REMOVED***
        Set the foreground color.  fg can be a matlab format string, a
        html hex color string, an rgb unit tuple, or a float between 0
        and 1.  In the latter case, grayscale is used.
        ***REMOVED***
        # Implementation note: wxPython has a separate concept of pen and
        # brush - the brush fills any outline trace left by the pen.
        # Here we set both to the same colour - if a figure is not to be
        # filled, the renderer will set the brush to be transparent
        # Same goes for text foreground...
        DEBUG_MSG("set_foreground(***REMOVED***", 1, self***REMOVED***
        self.select(***REMOVED***
        GraphicsContextBase.set_foreground(self, fg, isRGBA***REMOVED***

        self._pen.SetColour(self.get_wxcolour(self.get_rgb(***REMOVED******REMOVED******REMOVED***
        self.gfx_ctx.SetPen(self._pen***REMOVED***
        self.unselect(***REMOVED***

    def set_graylevel(self, frac***REMOVED***:
        ***REMOVED***
        Set the foreground color.  fg can be a matlab format string, a
        html hex color string, an rgb unit tuple, or a float between 0
        and 1.  In the latter case, grayscale is used.
        ***REMOVED***
        DEBUG_MSG("set_graylevel(***REMOVED***", 1, self***REMOVED***
        self.select(***REMOVED***
        GraphicsContextBase.set_graylevel(self, frac***REMOVED***
        self._pen.SetColour(self.get_wxcolour(self.get_rgb(***REMOVED******REMOVED******REMOVED***
        self.gfx_ctx.SetPen(self._pen***REMOVED***
        self.unselect(***REMOVED***

    def set_linewidth(self, w***REMOVED***:
        ***REMOVED***
        Set the line width.
        ***REMOVED***
        w = float(w***REMOVED***
        DEBUG_MSG("set_linewidth(***REMOVED***", 1, self***REMOVED***
        self.select(***REMOVED***
        if w > 0 and w < 1:
            w = 1
        GraphicsContextBase.set_linewidth(self, w***REMOVED***
        lw = int(self.renderer.points_to_pixels(self._linewidth***REMOVED******REMOVED***
        if lw == 0:
            lw = 1
        self._pen.SetWidth(lw***REMOVED***
        self.gfx_ctx.SetPen(self._pen***REMOVED***
        self.unselect(***REMOVED***

    def set_capstyle(self, cs***REMOVED***:
        ***REMOVED***
        Set the capstyle as a string in ('butt', 'round', 'projecting'***REMOVED***
        ***REMOVED***
        DEBUG_MSG("set_capstyle(***REMOVED***", 1, self***REMOVED***
        self.select(***REMOVED***
        GraphicsContextBase.set_capstyle(self, cs***REMOVED***
        self._pen.SetCap(GraphicsContextWx._capd[self._capstyle***REMOVED******REMOVED***
        self.gfx_ctx.SetPen(self._pen***REMOVED***
        self.unselect(***REMOVED***

    def set_joinstyle(self, js***REMOVED***:
        ***REMOVED***
        Set the join style to be one of ('miter', 'round', 'bevel'***REMOVED***
        ***REMOVED***
        DEBUG_MSG("set_joinstyle(***REMOVED***", 1, self***REMOVED***
        self.select(***REMOVED***
        GraphicsContextBase.set_joinstyle(self, js***REMOVED***
        self._pen.SetJoin(GraphicsContextWx._joind[self._joinstyle***REMOVED******REMOVED***
        self.gfx_ctx.SetPen(self._pen***REMOVED***
        self.unselect(***REMOVED***

    def set_linestyle(self, ls***REMOVED***:
        ***REMOVED***
        Set the line style to be one of
        ***REMOVED***
        DEBUG_MSG("set_linestyle(***REMOVED***", 1, self***REMOVED***
        self.select(***REMOVED***
        GraphicsContextBase.set_linestyle(self, ls***REMOVED***
        ***REMOVED***
            self._style = GraphicsContextWx._dashd_wx[ls***REMOVED***
        except KeyError:
            self._style = wx.LONG_DASH  # Style not used elsewhere...

        # On MS Windows platform, only line width of 1 allowed for dash lines
        if wx.Platform == '__WXMSW__':
            self.set_linewidth(1***REMOVED***

        self._pen.SetStyle(self._style***REMOVED***
        self.gfx_ctx.SetPen(self._pen***REMOVED***
        self.unselect(***REMOVED***

    def get_wxcolour(self, color***REMOVED***:
        ***REMOVED***return a wx.Colour from RGB format***REMOVED***
        DEBUG_MSG("get_wx_color(***REMOVED***", 1, self***REMOVED***
        if len(color***REMOVED*** == 3:
            r, g, b = color
            r *= 255
            g *= 255
            b *= 255
            return wx.Colour(red=int(r***REMOVED***, green=int(g***REMOVED***, blue=int(b***REMOVED******REMOVED***
        else:
            r, g, b, a = color
            r *= 255
            g *= 255
            b *= 255
            a *= 255
            return wx.Colour(
                red=int(r***REMOVED***,
                green=int(g***REMOVED***,
                blue=int(b***REMOVED***,
                alpha=int(a***REMOVED******REMOVED***


class FigureCanvasWx(FigureCanvasBase, wx.Panel***REMOVED***:
    ***REMOVED***
    The FigureCanvas contains the figure and does event handling.

    In the wxPython backend, it is derived from wxPanel, and (usually***REMOVED*** lives
    inside a frame instantiated by a FigureManagerWx. The parent window
    probably implements a wx.Sizer to control the displayed control size - but
    we give a hint as to our preferred minimum size.
    ***REMOVED***

    keyvald = {
        wx.WXK_CONTROL: 'control',
        wx.WXK_SHIFT: 'shift',
        wx.WXK_ALT: 'alt',
        wx.WXK_LEFT: 'left',
        wx.WXK_UP: 'up',
        wx.WXK_RIGHT: 'right',
        wx.WXK_DOWN: 'down',
        wx.WXK_ESCAPE: 'escape',
        wx.WXK_F1: 'f1',
        wx.WXK_F2: 'f2',
        wx.WXK_F3: 'f3',
        wx.WXK_F4: 'f4',
        wx.WXK_F5: 'f5',
        wx.WXK_F6: 'f6',
        wx.WXK_F7: 'f7',
        wx.WXK_F8: 'f8',
        wx.WXK_F9: 'f9',
        wx.WXK_F10: 'f10',
        wx.WXK_F11: 'f11',
        wx.WXK_F12: 'f12',
        wx.WXK_SCROLL: 'scroll_lock',
        wx.WXK_PAUSE: 'break',
        wx.WXK_BACK: 'backspace',
        wx.WXK_RETURN: 'enter',
        wx.WXK_INSERT: 'insert',
        wx.WXK_DELETE: 'delete',
        wx.WXK_HOME: 'home',
        wx.WXK_END: 'end',
        wx.WXK_PAGEUP: 'pageup',
        wx.WXK_PAGEDOWN: 'pagedown',
        wx.WXK_NUMPAD0: '0',
        wx.WXK_NUMPAD1: '1',
        wx.WXK_NUMPAD2: '2',
        wx.WXK_NUMPAD3: '3',
        wx.WXK_NUMPAD4: '4',
        wx.WXK_NUMPAD5: '5',
        wx.WXK_NUMPAD6: '6',
        wx.WXK_NUMPAD7: '7',
        wx.WXK_NUMPAD8: '8',
        wx.WXK_NUMPAD9: '9',
        wx.WXK_NUMPAD_ADD: '+',
        wx.WXK_NUMPAD_SUBTRACT: '-',
        wx.WXK_NUMPAD_MULTIPLY: '*',
        wx.WXK_NUMPAD_DIVIDE: '/',
        wx.WXK_NUMPAD_DECIMAL: 'dec',
        wx.WXK_NUMPAD_ENTER: 'enter',
        wx.WXK_NUMPAD_UP: 'up',
        wx.WXK_NUMPAD_RIGHT: 'right',
        wx.WXK_NUMPAD_DOWN: 'down',
        wx.WXK_NUMPAD_LEFT: 'left',
        wx.WXK_NUMPAD_PAGEUP: 'pageup',
        wx.WXK_NUMPAD_PAGEDOWN: 'pagedown',
        wx.WXK_NUMPAD_HOME: 'home',
        wx.WXK_NUMPAD_END: 'end',
        wx.WXK_NUMPAD_INSERT: 'insert',
        wx.WXK_NUMPAD_DELETE: 'delete',
***REMOVED***

    def __init__(self, parent, id, figure***REMOVED***:
        ***REMOVED***
        Initialise a FigureWx instance.

        - Initialise the FigureCanvasBase and wxPanel parents.
        - Set event handlers for:
          EVT_SIZE  (Resize event***REMOVED***
          EVT_PAINT (Paint event***REMOVED***
        ***REMOVED***

        FigureCanvasBase.__init__(self, figure***REMOVED***
        # Set preferred window size hint - helps the sizer (if one is
        # connected***REMOVED***
        l, b, w, h = figure.bbox.bounds
        w = int(math.ceil(w***REMOVED******REMOVED***
        h = int(math.ceil(h***REMOVED******REMOVED***

        wx.Panel.__init__(self, parent, id, size=wx.Size(w, h***REMOVED******REMOVED***

        def do_nothing(*args, **kwargs***REMOVED***:
            warnings.warn(
                "could not find a setinitialsize function for backend_wx; "
                "please report your wxpython version=%s "
                "to the matplotlib developers list" %
                wxc.backend_version***REMOVED***
            pass

        # try to find the set size func across wx versions
        ***REMOVED***
            getattr(self, 'SetInitialSize'***REMOVED***
        except AttributeError:
            self.SetInitialSize = getattr(self, 'SetBestFittingSize',
                                          do_nothing***REMOVED***

        if not hasattr(self, 'IsShownOnScreen'***REMOVED***:
            self.IsShownOnScreen = getattr(self, 'IsVisible',
                                           lambda *args: True***REMOVED***

        # Create the drawing bitmap
        self.bitmap = wxc.EmptyBitmap(w, h***REMOVED***
        DEBUG_MSG("__init__(***REMOVED*** - bitmap w:%d h:%d" % (w, h***REMOVED***, 2, self***REMOVED***
        # TODO: Add support for 'point' inspection and plot navigation.
        self._isDrawn = False

        self.Bind(wx.EVT_SIZE, self._onSize***REMOVED***
        self.Bind(wx.EVT_PAINT, self._onPaint***REMOVED***
        self.Bind(wx.EVT_KEY_DOWN, self._onKeyDown***REMOVED***
        self.Bind(wx.EVT_KEY_UP, self._onKeyUp***REMOVED***
        self.Bind(wx.EVT_RIGHT_DOWN, self._onRightButtonDown***REMOVED***
        self.Bind(wx.EVT_RIGHT_DCLICK, self._onRightButtonDClick***REMOVED***
        self.Bind(wx.EVT_RIGHT_UP, self._onRightButtonUp***REMOVED***
        self.Bind(wx.EVT_MOUSEWHEEL, self._onMouseWheel***REMOVED***
        self.Bind(wx.EVT_LEFT_DOWN, self._onLeftButtonDown***REMOVED***
        self.Bind(wx.EVT_LEFT_DCLICK, self._onLeftButtonDClick***REMOVED***
        self.Bind(wx.EVT_LEFT_UP, self._onLeftButtonUp***REMOVED***
        self.Bind(wx.EVT_MOTION, self._onMotion***REMOVED***
        self.Bind(wx.EVT_LEAVE_WINDOW, self._onLeave***REMOVED***
        self.Bind(wx.EVT_ENTER_WINDOW, self._onEnter***REMOVED***
        self.Bind(wx.EVT_IDLE, self._onIdle***REMOVED***
        # Add middle button events
        self.Bind(wx.EVT_MIDDLE_DOWN, self._onMiddleButtonDown***REMOVED***
        self.Bind(wx.EVT_MIDDLE_DCLICK, self._onMiddleButtonDClick***REMOVED***
        self.Bind(wx.EVT_MIDDLE_UP, self._onMiddleButtonUp***REMOVED***

        if wx.VERSION_STRING < "2.9":
            # only needed in 2.8 to reduce flicker
            self.SetBackgroundStyle(wx.BG_STYLE_CUSTOM***REMOVED***
            self.Bind(wx.EVT_ERASE_BACKGROUND, self._onEraseBackground***REMOVED***
        else:
            # this does the same in 2.9+
            self.SetBackgroundStyle(wx.BG_STYLE_PAINT***REMOVED***

        self.macros = {***REMOVED***  # dict from wx id to seq of macros

    def Destroy(self, *args, **kwargs***REMOVED***:
        wx.Panel.Destroy(self, *args, **kwargs***REMOVED***

    def Copy_to_Clipboard(self, event=None***REMOVED***:
        "copy bitmap of canvas to system clipboard"
        bmp_obj = wx.BitmapDataObject(***REMOVED***
        bmp_obj.SetBitmap(self.bitmap***REMOVED***

        if not wx.TheClipboard.IsOpened(***REMOVED***:
            open_success = wx.TheClipboard.Open(***REMOVED***
            if open_success:
                wx.TheClipboard.SetData(bmp_obj***REMOVED***
                wx.TheClipboard.Close(***REMOVED***
                wx.TheClipboard.Flush(***REMOVED***

    def draw_idle(self***REMOVED***:
        ***REMOVED***
        Delay rendering until the GUI is idle.
        ***REMOVED***
        DEBUG_MSG("draw_idle(***REMOVED***", 1, self***REMOVED***
        self._isDrawn = False  # Force redraw

        # Triggering a paint event is all that is needed to defer drawing
        # until later. The platform will send the event when it thinks it is
        # a good time (usually as soon as there are no other events pending***REMOVED***.
        self.Refresh(eraseBackground=False***REMOVED***

    def draw(self, drawDC=None***REMOVED***:
        ***REMOVED***
        Render the figure using RendererWx instance renderer, or using a
        previously defined renderer if none is specified.
        ***REMOVED***
        DEBUG_MSG("draw(***REMOVED***", 1, self***REMOVED***
        self.renderer = RendererWx(self.bitmap, self.figure.dpi***REMOVED***
        self.figure.draw(self.renderer***REMOVED***
        self._isDrawn = True
        self.gui_repaint(drawDC=drawDC***REMOVED***

    def new_timer(self, *args, **kwargs***REMOVED***:
        ***REMOVED***
        Creates a new backend-specific subclass of
        :class:`backend_bases.Timer`. This is useful for getting periodic
        events through the backend's native event loop. Implemented only
        for backends with GUIs.

        optional arguments:

        *interval*
          Timer interval in milliseconds
        *callbacks*
          Sequence of (func, args, kwargs***REMOVED*** where func(*args, **kwargs***REMOVED*** will
          be executed by the timer every *interval*.
        ***REMOVED***
        return TimerWx(self, *args, **kwargs***REMOVED***

    def flush_events(self***REMOVED***:
        wx.Yield(***REMOVED***

    def start_event_loop(self, timeout=0***REMOVED***:
        ***REMOVED***
        Start an event loop.  This is used to start a blocking event
        loop so that interactive functions, such as ginput and
        waitforbuttonpress, can wait for events.  This should not be
        confused with the main GUI event loop, which is always running
        and has nothing to do with this.

        Call signature::

        start_event_loop(self,timeout=0***REMOVED***

        This call blocks until a callback function triggers
        stop_event_loop(***REMOVED*** or *timeout* is reached.  If *timeout* is
        <=0, never timeout.

        Raises RuntimeError if event loop is already running.
        ***REMOVED***
        if hasattr(self, '_event_loop'***REMOVED***:
            raise RuntimeError("Event loop already running"***REMOVED***
        id = wx.NewId(***REMOVED***
        timer = wx.Timer(self, id=id***REMOVED***
        if timeout > 0:
            timer.Start(timeout * 1000, oneShot=True***REMOVED***
            self.Bind(wx.EVT_TIMER, self.stop_event_loop, id=id***REMOVED***

        # Event loop handler for start/stop event loop
        self._event_loop = wxc.EventLoop(***REMOVED***
        self._event_loop.Run(***REMOVED***
        timer.Stop(***REMOVED***

    def stop_event_loop(self, event=None***REMOVED***:
        ***REMOVED***
        Stop an event loop.  This is used to stop a blocking event
        loop so that interactive functions, such as ginput and
        waitforbuttonpress, can wait for events.

        Call signature::

        stop_event_loop_default(self***REMOVED***
        ***REMOVED***
        if hasattr(self, '_event_loop'***REMOVED***:
            if self._event_loop.IsRunning(***REMOVED***:
                self._event_loop.Exit(***REMOVED***
            del self._event_loop

    def _get_imagesave_wildcards(self***REMOVED***:
        'return the wildcard string for the filesave dialog'
        default_filetype = self.get_default_filetype(***REMOVED***
        filetypes = self.get_supported_filetypes_grouped(***REMOVED***
        sorted_filetypes = sorted(filetypes.items(***REMOVED******REMOVED***
        wildcards = [***REMOVED***
        extensions = [***REMOVED***
        filter_index = 0
        for i, (name, exts***REMOVED*** in enumerate(sorted_filetypes***REMOVED***:
            ext_list = ';'.join(['*.%s' % ext for ext in exts***REMOVED******REMOVED***
            extensions.append(exts[0***REMOVED******REMOVED***
            wildcard = '%s (%s***REMOVED***|%s' % (name, ext_list, ext_list***REMOVED***
            if default_filetype in exts:
                filter_index = i
            wildcards.append(wildcard***REMOVED***
        wildcards = '|'.join(wildcards***REMOVED***
        return wildcards, extensions, filter_index

    def gui_repaint(self, drawDC=None, origin='WX'***REMOVED***:
        ***REMOVED***
        Performs update of the displayed image on the GUI canvas, using the
        supplied wx.PaintDC device context.

        The 'WXAgg' backend sets origin accordingly.
        ***REMOVED***
        DEBUG_MSG("gui_repaint(***REMOVED***", 1, self***REMOVED***
        if self.IsShownOnScreen(***REMOVED***:
            if not drawDC:
                # not called from OnPaint use a ClientDC
                drawDC = wx.ClientDC(self***REMOVED***

            # following is for 'WX' backend on Windows
            # the bitmap can not be in use by another DC,
            # see GraphicsContextWx._cache
            if wx.Platform == '__WXMSW__' and origin == 'WX':
                img = self.bitmap.ConvertToImage(***REMOVED***
                bmp = img.ConvertToBitmap(***REMOVED***
                drawDC.DrawBitmap(bmp, 0, 0***REMOVED***
            else:
                drawDC.DrawBitmap(self.bitmap, 0, 0***REMOVED***

    filetypes = FigureCanvasBase.filetypes.copy(***REMOVED***
    filetypes['bmp'***REMOVED*** = 'Windows bitmap'
    filetypes['jpeg'***REMOVED*** = 'JPEG'
    filetypes['jpg'***REMOVED*** = 'JPEG'
    filetypes['pcx'***REMOVED*** = 'PCX'
    filetypes['png'***REMOVED*** = 'Portable Network Graphics'
    filetypes['tif'***REMOVED*** = 'Tagged Image Format File'
    filetypes['tiff'***REMOVED*** = 'Tagged Image Format File'
    filetypes['xpm'***REMOVED*** = 'X pixmap'

    def print_figure(self, filename, *args, **kwargs***REMOVED***:
        # Use pure Agg renderer to draw
        FigureCanvasBase.print_figure(self, filename, *args, **kwargs***REMOVED***
        # Restore the current view; this is needed because the
        # artist contains methods rely on particular attributes
        # of the rendered figure for determining things like
        # bounding boxes.
        if self._isDrawn:
            self.draw(***REMOVED***

    def print_bmp(self, filename, *args, **kwargs***REMOVED***:
        return self._print_image(filename, wx.BITMAP_TYPE_BMP, *args, **kwargs***REMOVED***

    if not _has_pil:
        def print_jpeg(self, filename, *args, **kwargs***REMOVED***:
            return self._print_image(filename, wx.BITMAP_TYPE_JPEG,
                                     *args, **kwargs***REMOVED***
        print_jpg = print_jpeg

    def print_pcx(self, filename, *args, **kwargs***REMOVED***:
        return self._print_image(filename, wx.BITMAP_TYPE_PCX, *args, **kwargs***REMOVED***

    def print_png(self, filename, *args, **kwargs***REMOVED***:
        return self._print_image(filename, wx.BITMAP_TYPE_PNG, *args, **kwargs***REMOVED***

    if not _has_pil:
        def print_tiff(self, filename, *args, **kwargs***REMOVED***:
            return self._print_image(filename, wx.BITMAP_TYPE_TIF,
                                     *args, **kwargs***REMOVED***
        print_tif = print_tiff

    def print_xpm(self, filename, *args, **kwargs***REMOVED***:
        return self._print_image(filename, wx.BITMAP_TYPE_XPM, *args, **kwargs***REMOVED***

    def _print_image(self, filename, filetype, *args, **kwargs***REMOVED***:
        origBitmap = self.bitmap

        l, b, width, height = self.figure.bbox.bounds
        width = int(math.ceil(width***REMOVED******REMOVED***
        height = int(math.ceil(height***REMOVED******REMOVED***

        self.bitmap = wxc.EmptyBitmap(width, height***REMOVED***

        renderer = RendererWx(self.bitmap, self.figure.dpi***REMOVED***

        gc = renderer.new_gc(***REMOVED***

        self.figure.draw(renderer***REMOVED***

        # image is the object that we call SaveFile on.
        image = self.bitmap
        # set the JPEG quality appropriately.  Unfortunately, it is only
        # possible to set the quality on a wx.Image object.  So if we
        # are saving a JPEG, convert the wx.Bitmap to a wx.Image,
        # and set the quality.
        if filetype == wx.BITMAP_TYPE_JPEG:
            jpeg_quality = kwargs.get('quality',
                                      rcParams['savefig.jpeg_quality'***REMOVED******REMOVED***
            image = self.bitmap.ConvertToImage(***REMOVED***
            image.SetOption(wx.IMAGE_OPTION_QUALITY, str(jpeg_quality***REMOVED******REMOVED***

        # Now that we have rendered into the bitmap, save it
        # to the appropriate file type and clean up
        if is_string_like(filename***REMOVED***:
            if not image.SaveFile(filename, filetype***REMOVED***:
                DEBUG_MSG('print_figure(***REMOVED*** file save error', 4, self***REMOVED***
                raise RuntimeError(
                    'Could not save figure to %s\n' %
                    (filename***REMOVED******REMOVED***
        elif is_writable_file_like(filename***REMOVED***:
            if not isinstance(image, wx.Image***REMOVED***:
                image = image.ConvertToImage(***REMOVED***
            if not image.SaveStream(filename, filetype***REMOVED***:
                DEBUG_MSG('print_figure(***REMOVED*** file save error', 4, self***REMOVED***
                raise RuntimeError(
                    'Could not save figure to %s\n' %
                    (filename***REMOVED******REMOVED***

        # Restore everything to normal
        self.bitmap = origBitmap

        # Note: draw is required here since bits of state about the
        # last renderer are strewn about the artist draw methods.  Do
        # not remove the draw without first verifying that these have
        # been cleaned up.  The artist contains(***REMOVED*** methods will fail
        # otherwise.
        if self._isDrawn:
            self.draw(***REMOVED***
        self.Refresh(***REMOVED***

    def _onPaint(self, evt***REMOVED***:
        ***REMOVED***
        Called when wxPaintEvt is generated
        ***REMOVED***

        DEBUG_MSG("_onPaint(***REMOVED***", 1, self***REMOVED***
        drawDC = wx.PaintDC(self***REMOVED***
        if not self._isDrawn:
            self.draw(drawDC=drawDC***REMOVED***
        else:
            self.gui_repaint(drawDC=drawDC***REMOVED***
        evt.Skip(***REMOVED***

    def _onEraseBackground(self, evt***REMOVED***:
        ***REMOVED***
        Called when window is redrawn; since we are blitting the entire
        image, we can leave this blank to suppress flicker.
        ***REMOVED***
        pass

    def _onSize(self, evt***REMOVED***:
        ***REMOVED***
        Called when wxEventSize is generated.

        In this application we attempt to resize to fit the window, so it
        is better to take the performance hit and redraw the whole window.
        ***REMOVED***

        DEBUG_MSG("_onSize(***REMOVED***", 2, self***REMOVED***
        # Create a new, correctly sized bitmap
        self._width, self._height = self.GetClientSize(***REMOVED***
        self.bitmap = wxc.EmptyBitmap(self._width, self._height***REMOVED***

        self._isDrawn = False

        if self._width <= 1 or self._height <= 1:
            return  # Empty figure

        dpival = self.figure.dpi
        winch = self._width / dpival
        hinch = self._height / dpival
        self.figure.set_size_inches(winch, hinch***REMOVED***

        # Rendering will happen on the associated paint event
        # so no need to do anything here except to make sure
        # the whole background is repainted.
        self.Refresh(eraseBackground=False***REMOVED***
        FigureCanvasBase.resize_event(self***REMOVED***

    def _get_key(self, evt***REMOVED***:

        keyval = evt.KeyCode
        if keyval in self.keyvald:
            key = self.keyvald[keyval***REMOVED***
        elif keyval < 256:
            key = chr(keyval***REMOVED***
            # wx always returns an uppercase, so make it lowercase if the shift
            # key is not depressed (NOTE: this will not handle Caps Lock***REMOVED***
            if not evt.ShiftDown(***REMOVED***:
                key = key.lower(***REMOVED***
        else:
            key = None

        for meth, prefix in (
                [evt.AltDown, 'alt'***REMOVED***,
                [evt.ControlDown, 'ctrl'***REMOVED***, ***REMOVED***:
            if meth(***REMOVED***:
                key = '{0***REMOVED***+{1***REMOVED***'.format(prefix, key***REMOVED***

        return key

    def _onIdle(self, evt***REMOVED***:
        'a GUI idle event'
        evt.Skip(***REMOVED***
        FigureCanvasBase.idle_event(self, guiEvent=evt***REMOVED***

    def _onKeyDown(self, evt***REMOVED***:
        ***REMOVED***Capture key press.***REMOVED***
        key = self._get_key(evt***REMOVED***
        evt.Skip(***REMOVED***
        FigureCanvasBase.key_press_event(self, key, guiEvent=evt***REMOVED***

    def _onKeyUp(self, evt***REMOVED***:
        ***REMOVED***Release key.***REMOVED***
        key = self._get_key(evt***REMOVED***
        # print 'release key', key
        evt.Skip(***REMOVED***
        FigureCanvasBase.key_release_event(self, key, guiEvent=evt***REMOVED***

    def _onRightButtonDown(self, evt***REMOVED***:
        ***REMOVED***Start measuring on an axis.***REMOVED***
        x = evt.GetX(***REMOVED***
        y = self.figure.bbox.height - evt.GetY(***REMOVED***
        evt.Skip(***REMOVED***
        self.CaptureMouse(***REMOVED***
        FigureCanvasBase.button_press_event(self, x, y, 3, guiEvent=evt***REMOVED***

    def _onRightButtonDClick(self, evt***REMOVED***:
        ***REMOVED***Start measuring on an axis.***REMOVED***
        x = evt.GetX(***REMOVED***
        y = self.figure.bbox.height - evt.GetY(***REMOVED***
        evt.Skip(***REMOVED***
        self.CaptureMouse(***REMOVED***
        FigureCanvasBase.button_press_event(self, x, y, 3,
                                            dblclick=True, guiEvent=evt***REMOVED***

    def _onRightButtonUp(self, evt***REMOVED***:
        ***REMOVED***End measuring on an axis.***REMOVED***
        x = evt.GetX(***REMOVED***
        y = self.figure.bbox.height - evt.GetY(***REMOVED***
        evt.Skip(***REMOVED***
        if self.HasCapture(***REMOVED***:
            self.ReleaseMouse(***REMOVED***
        FigureCanvasBase.button_release_event(self, x, y, 3, guiEvent=evt***REMOVED***

    def _onLeftButtonDown(self, evt***REMOVED***:
        ***REMOVED***Start measuring on an axis.***REMOVED***
        x = evt.GetX(***REMOVED***
        y = self.figure.bbox.height - evt.GetY(***REMOVED***
        evt.Skip(***REMOVED***
        self.CaptureMouse(***REMOVED***
        FigureCanvasBase.button_press_event(self, x, y, 1, guiEvent=evt***REMOVED***

    def _onLeftButtonDClick(self, evt***REMOVED***:
        ***REMOVED***Start measuring on an axis.***REMOVED***
        x = evt.GetX(***REMOVED***
        y = self.figure.bbox.height - evt.GetY(***REMOVED***
        evt.Skip(***REMOVED***
        self.CaptureMouse(***REMOVED***
        FigureCanvasBase.button_press_event(self, x, y, 1,
                                            dblclick=True, guiEvent=evt***REMOVED***

    def _onLeftButtonUp(self, evt***REMOVED***:
        ***REMOVED***End measuring on an axis.***REMOVED***
        x = evt.GetX(***REMOVED***
        y = self.figure.bbox.height - evt.GetY(***REMOVED***
        # print 'release button', 1
        evt.Skip(***REMOVED***
        if self.HasCapture(***REMOVED***:
            self.ReleaseMouse(***REMOVED***
        FigureCanvasBase.button_release_event(self, x, y, 1, guiEvent=evt***REMOVED***

    # Add middle button events
    def _onMiddleButtonDown(self, evt***REMOVED***:
        ***REMOVED***Start measuring on an axis.***REMOVED***
        x = evt.GetX(***REMOVED***
        y = self.figure.bbox.height - evt.GetY(***REMOVED***
        evt.Skip(***REMOVED***
        self.CaptureMouse(***REMOVED***
        FigureCanvasBase.button_press_event(self, x, y, 2, guiEvent=evt***REMOVED***

    def _onMiddleButtonDClick(self, evt***REMOVED***:
        ***REMOVED***Start measuring on an axis.***REMOVED***
        x = evt.GetX(***REMOVED***
        y = self.figure.bbox.height - evt.GetY(***REMOVED***
        evt.Skip(***REMOVED***
        self.CaptureMouse(***REMOVED***
        FigureCanvasBase.button_press_event(self, x, y, 2,
                                            dblclick=True, guiEvent=evt***REMOVED***

    def _onMiddleButtonUp(self, evt***REMOVED***:
        ***REMOVED***End measuring on an axis.***REMOVED***
        x = evt.GetX(***REMOVED***
        y = self.figure.bbox.height - evt.GetY(***REMOVED***
        # print 'release button', 1
        evt.Skip(***REMOVED***
        if self.HasCapture(***REMOVED***:
            self.ReleaseMouse(***REMOVED***
        FigureCanvasBase.button_release_event(self, x, y, 2, guiEvent=evt***REMOVED***

    def _onMouseWheel(self, evt***REMOVED***:
        ***REMOVED***Translate mouse wheel events into matplotlib events***REMOVED***

        # Determine mouse location
        x = evt.GetX(***REMOVED***
        y = self.figure.bbox.height - evt.GetY(***REMOVED***

        # Convert delta/rotation/rate into a floating point step size
        delta = evt.GetWheelDelta(***REMOVED***
        rotation = evt.GetWheelRotation(***REMOVED***
        rate = evt.GetLinesPerAction(***REMOVED***
        # print "delta,rotation,rate",delta,rotation,rate
        step = rate * float(rotation***REMOVED*** / delta

        # Done handling event
        evt.Skip(***REMOVED***

        # Mac is giving two events for every wheel event
        # Need to skip every second one
        if wx.Platform == '__WXMAC__':
            if not hasattr(self, '_skipwheelevent'***REMOVED***:
                self._skipwheelevent = True
            elif self._skipwheelevent:
                self._skipwheelevent = False
                return  # Return without processing event
            else:
                self._skipwheelevent = True

        # Convert to mpl event
        FigureCanvasBase.scroll_event(self, x, y, step, guiEvent=evt***REMOVED***

    def _onMotion(self, evt***REMOVED***:
        ***REMOVED***Start measuring on an axis.***REMOVED***

        x = evt.GetX(***REMOVED***
        y = self.figure.bbox.height - evt.GetY(***REMOVED***
        evt.Skip(***REMOVED***
        FigureCanvasBase.motion_notify_event(self, x, y, guiEvent=evt***REMOVED***

    def _onLeave(self, evt***REMOVED***:
        ***REMOVED***Mouse has left the window.***REMOVED***

        evt.Skip(***REMOVED***
        FigureCanvasBase.leave_notify_event(self, guiEvent=evt***REMOVED***

    def _onEnter(self, evt***REMOVED***:
        ***REMOVED***Mouse has entered the window.***REMOVED***
        FigureCanvasBase.enter_notify_event(self, guiEvent=evt***REMOVED***


########################################################################
#
# The following functions and classes are for pylab compatibility
# mode (matplotlib.pylab***REMOVED*** and implement figure managers, etc...
#
########################################################################


def _create_wx_app(***REMOVED***:
    ***REMOVED***
    Creates a wx.App instance if it has not been created sofar.
    ***REMOVED***
    wxapp = wx.GetApp(***REMOVED***
    if wxapp is None:
        wxapp = wx.App(False***REMOVED***
        wxapp.SetExitOnFrameDelete(True***REMOVED***
        # retain a reference to the app object so it does not get garbage
        # collected and cause segmentation faults
        _create_wx_app.theWxApp = wxapp


def draw_if_interactive(***REMOVED***:
    ***REMOVED***
    This should be overriden in a windowing environment if drawing
    should be done in interactive python mode
    ***REMOVED***
    DEBUG_MSG("draw_if_interactive(***REMOVED***", 1, None***REMOVED***

    if matplotlib.is_interactive(***REMOVED***:

        figManager = Gcf.get_active(***REMOVED***
        if figManager is not None:
            figManager.canvas.draw_idle(***REMOVED***


class Show(ShowBase***REMOVED***:
    def mainloop(self***REMOVED***:
        needmain = not wx.App.IsMainLoopRunning(***REMOVED***
        if needmain:
            wxapp = wx.GetApp(***REMOVED***
            if wxapp is not None:
                wxapp.MainLoop(***REMOVED***

show = Show(***REMOVED***


def new_figure_manager(num, *args, **kwargs***REMOVED***:
    ***REMOVED***
    Create a new figure manager instance
    ***REMOVED***
    # in order to expose the Figure constructor to the pylab
    # interface we need to create the figure here
    DEBUG_MSG("new_figure_manager(***REMOVED***", 3, None***REMOVED***
    _create_wx_app(***REMOVED***

    FigureClass = kwargs.pop('FigureClass', Figure***REMOVED***
    fig = FigureClass(*args, **kwargs***REMOVED***
    return new_figure_manager_given_figure(num, fig***REMOVED***


def new_figure_manager_given_figure(num, figure***REMOVED***:
    ***REMOVED***
    Create a new figure manager instance for the given figure.
    ***REMOVED***
    fig = figure
    frame = FigureFrameWx(num, fig***REMOVED***
    figmgr = frame.get_figure_manager(***REMOVED***
    if matplotlib.is_interactive(***REMOVED***:
        figmgr.frame.Show(***REMOVED***
        figure.canvas.draw_idle(***REMOVED***

    return figmgr


class FigureFrameWx(wx.Frame***REMOVED***:
    def __init__(self, num, fig***REMOVED***:
        # On non-Windows platform, explicitly set the position - fix
        # positioning bug on some Linux platforms
        if wx.Platform == '__WXMSW__':
            pos = wx.DefaultPosition
        else:
            pos = wx.Point(20, 20***REMOVED***
        l, b, w, h = fig.bbox.bounds
        wx.Frame.__init__(self, parent=None, id=-1, pos=pos,
                          title="Figure %d" % num***REMOVED***
        # Frame will be sized later by the Fit method
        DEBUG_MSG("__init__(***REMOVED***", 1, self***REMOVED***
        self.num = num

        statbar = StatusBarWx(self***REMOVED***
        self.SetStatusBar(statbar***REMOVED***
        self.canvas = self.get_canvas(fig***REMOVED***
        self.canvas.SetInitialSize(wx.Size(fig.bbox.width, fig.bbox.height***REMOVED******REMOVED***
        self.canvas.SetFocus(***REMOVED***
        self.sizer = wx.BoxSizer(wx.VERTICAL***REMOVED***
        self.sizer.Add(self.canvas, 1, wx.TOP | wx.LEFT | wx.EXPAND***REMOVED***
        # By adding toolbar in sizer, we are able to put it at the bottom
        # of the frame - so appearance is closer to GTK version

        self.toolbar = self._get_toolbar(statbar***REMOVED***

        if self.toolbar is not None:
            self.toolbar.Realize(***REMOVED***
            # On Windows platform, default window size is incorrect, so set
            # toolbar width to figure width.
            if wxc.is_phoenix:
                tw, th = self.toolbar.GetSize(***REMOVED***
                fw, fh = self.canvas.GetSize(***REMOVED***
            else:
                tw, th = self.toolbar.GetSizeTuple(***REMOVED***
                fw, fh = self.canvas.GetSizeTuple(***REMOVED***
            # By adding toolbar in sizer, we are able to put it at the bottom
            # of the frame - so appearance is closer to GTK version.
            self.toolbar.SetSize(wx.Size(fw, th***REMOVED******REMOVED***
            self.sizer.Add(self.toolbar, 0, wx.LEFT | wx.EXPAND***REMOVED***
        self.SetSizer(self.sizer***REMOVED***
        self.Fit(***REMOVED***

        self.canvas.SetMinSize((2, 2***REMOVED******REMOVED***

        # give the window a matplotlib icon rather than the stock one.
        # This is not currently working on Linux and is untested elsewhere.
        # icon_path = os.path.join(matplotlib.rcParams['datapath'***REMOVED***,
        #                         'images', 'matplotlib.png'***REMOVED***
        #icon = wx.IconFromBitmap(wx.Bitmap(icon_path***REMOVED******REMOVED***
        # for xpm type icons ***REMOVED***
        #icon = wx.Icon(icon_path, wx.BITMAP_TYPE_XPM***REMOVED***
        # self.SetIcon(icon***REMOVED***

        self.figmgr = FigureManagerWx(self.canvas, num, self***REMOVED***

        self.Bind(wx.EVT_CLOSE, self._onClose***REMOVED***

    def _get_toolbar(self, statbar***REMOVED***:
        if rcParams['toolbar'***REMOVED*** == 'toolbar2':
            toolbar = NavigationToolbar2Wx(self.canvas***REMOVED***
            toolbar.set_status_bar(statbar***REMOVED***
        else:
            toolbar = None
        return toolbar

    def get_canvas(self, fig***REMOVED***:
        return FigureCanvasWx(self, -1, fig***REMOVED***

    def get_figure_manager(self***REMOVED***:
        DEBUG_MSG("get_figure_manager(***REMOVED***", 1, self***REMOVED***
        return self.figmgr

    def _onClose(self, evt***REMOVED***:
        DEBUG_MSG("onClose(***REMOVED***", 1, self***REMOVED***
        self.canvas.close_event(***REMOVED***
        self.canvas.stop_event_loop(***REMOVED***
        Gcf.destroy(self.num***REMOVED***
        # self.Destroy(***REMOVED***

    def GetToolBar(self***REMOVED***:
        ***REMOVED***Override wxFrame::GetToolBar as we don't have managed toolbar***REMOVED***
        return self.toolbar

    def Destroy(self, *args, **kwargs***REMOVED***:
        ***REMOVED***
            self.canvas.mpl_disconnect(self.toolbar._idDrag***REMOVED***
            # Rationale for line above: see issue 2941338.
        except AttributeError:
            pass  # classic toolbar lacks the attribute
        if not self.IsBeingDeleted(***REMOVED***:
            wx.Frame.Destroy(self, *args, **kwargs***REMOVED***
            if self.toolbar is not None:
                self.toolbar.Destroy(***REMOVED***
            wxapp = wx.GetApp(***REMOVED***
            if wxapp:
                wxapp.Yield(***REMOVED***
        return True


class FigureManagerWx(FigureManagerBase***REMOVED***:
    ***REMOVED***
    This class contains the FigureCanvas and GUI frame

    It is instantiated by GcfWx whenever a new figure is created. GcfWx is
    responsible for managing multiple instances of FigureManagerWx.

    public attrs

    canvas - a FigureCanvasWx(wx.Panel***REMOVED*** instance
    window - a wxFrame instance - wxpython.org/Phoenix/docs/html/Frame.html
    ***REMOVED***

    def __init__(self, canvas, num, frame***REMOVED***:
        DEBUG_MSG("__init__(***REMOVED***", 1, self***REMOVED***
        FigureManagerBase.__init__(self, canvas, num***REMOVED***
        self.frame = frame
        self.window = frame

        self.tb = frame.GetToolBar(***REMOVED***
        self.toolbar = self.tb  # consistent with other backends

        def notify_axes_change(fig***REMOVED***:
            'this will be called whenever the current axes is changed'
            if self.tb is not None:
                self.tb.update(***REMOVED***
        self.canvas.figure.add_axobserver(notify_axes_change***REMOVED***

    def show(self***REMOVED***:
        self.frame.Show(***REMOVED***
        self.canvas.draw(***REMOVED***

    def destroy(self, *args***REMOVED***:
        DEBUG_MSG("destroy(***REMOVED***", 1, self***REMOVED***
        self.frame.Destroy(***REMOVED***
        wxapp = wx.GetApp(***REMOVED***
        if wxapp:
            wxapp.Yield(***REMOVED***

    def get_window_title(self***REMOVED***:
        return self.window.GetTitle(***REMOVED***

    def set_window_title(self, title***REMOVED***:
        self.window.SetTitle(title***REMOVED***

    def resize(self, width, height***REMOVED***:
        'Set the canvas size in pixels'
        self.canvas.SetInitialSize(wx.Size(width, height***REMOVED******REMOVED***
        self.window.GetSizer(***REMOVED***.Fit(self.window***REMOVED***

# Identifiers for toolbar controls - images_wx contains bitmaps for the images
# used in the controls. wxWindows does not provide any stock images, so I've
# 'stolen' those from GTK2, and transformed them into the appropriate format.
#import images_wx

_NTB_AXISMENU = wx.NewId(***REMOVED***
_NTB_AXISMENU_BUTTON = wx.NewId(***REMOVED***
_NTB_X_PAN_LEFT = wx.NewId(***REMOVED***
_NTB_X_PAN_RIGHT = wx.NewId(***REMOVED***
_NTB_X_ZOOMIN = wx.NewId(***REMOVED***
_NTB_X_ZOOMOUT = wx.NewId(***REMOVED***
_NTB_Y_PAN_UP = wx.NewId(***REMOVED***
_NTB_Y_PAN_DOWN = wx.NewId(***REMOVED***
_NTB_Y_ZOOMIN = wx.NewId(***REMOVED***
_NTB_Y_ZOOMOUT = wx.NewId(***REMOVED***
#_NTB_SUBPLOT            =wx.NewId(***REMOVED***
_NTB_SAVE = wx.NewId(***REMOVED***
_NTB_CLOSE = wx.NewId(***REMOVED***


def _load_bitmap(filename***REMOVED***:
    ***REMOVED***
    Load a bitmap file from the backends/images subdirectory in which the
    matplotlib library is installed. The filename parameter should not
    contain any path information as this is determined automatically.

    Returns a wx.Bitmap object
    ***REMOVED***

    basedir = os.path.join(rcParams['datapath'***REMOVED***, 'images'***REMOVED***

    bmpFilename = os.path.normpath(os.path.join(basedir, filename***REMOVED******REMOVED***
    if not os.path.exists(bmpFilename***REMOVED***:
        raise IOError('Could not find bitmap file "%s"; dying' % bmpFilename***REMOVED***

    bmp = wx.Bitmap(bmpFilename***REMOVED***
    return bmp


class MenuButtonWx(wx.Button***REMOVED***:
    ***REMOVED***
    wxPython does not permit a menu to be incorporated directly into a toolbar.
    This class simulates the effect by associating a pop-up menu with a button
    in the toolbar, and managing this as though it were a menu.
    ***REMOVED***

    def __init__(self, parent***REMOVED***:

        wx.Button.__init__(self, parent, _NTB_AXISMENU_BUTTON, "Axes:        ",
                           style=wx.BU_EXACTFIT***REMOVED***
        self._toolbar = parent
        self._menu = wx.Menu(***REMOVED***
        self._axisId = [***REMOVED***
        # First two menu items never change...
        self._allId = wx.NewId(***REMOVED***
        self._invertId = wx.NewId(***REMOVED***
        self._menu.Append(self._allId, "All", "Select all axes", False***REMOVED***
        self._menu.Append(self._invertId, "Invert", "Invert axes selected",
                          False***REMOVED***
        self._menu.AppendSeparator(***REMOVED***

        self.Bind(wx.EVT_BUTTON, self._onMenuButton, id=_NTB_AXISMENU_BUTTON***REMOVED***
        self.Bind(wx.EVT_MENU, self._handleSelectAllAxes, id=self._allId***REMOVED***
        self.Bind(wx.EVT_MENU, self._handleInvertAxesSelected,
                  id=self._invertId***REMOVED***

    def Destroy(self***REMOVED***:
        self._menu.Destroy(***REMOVED***
        self.Destroy(***REMOVED***

    def _onMenuButton(self, evt***REMOVED***:
        ***REMOVED***Handle menu button pressed.***REMOVED***
        if wxc.is_phoenix:
            x, y = self.GetPosition(***REMOVED***
            w, h = self.GetSize(***REMOVED***
        else:
            x, y = self.GetPositionTuple(***REMOVED***
            w, h = self.GetSizeTuple(***REMOVED***
        self.PopupMenuXY(self._menu, x, y + h - 4***REMOVED***
        # When menu returned, indicate selection in button
        evt.Skip(***REMOVED***

    def _handleSelectAllAxes(self, evt***REMOVED***:
        ***REMOVED***Called when the 'select all axes' menu item is selected.***REMOVED***
        if len(self._axisId***REMOVED*** == 0:
            return
        for i in range(len(self._axisId***REMOVED******REMOVED***:
            self._menu.Check(self._axisId[i***REMOVED***, True***REMOVED***
        self._toolbar.set_active(self.getActiveAxes(***REMOVED******REMOVED***
        evt.Skip(***REMOVED***

    def _handleInvertAxesSelected(self, evt***REMOVED***:
        ***REMOVED***Called when the invert all menu item is selected***REMOVED***
        if len(self._axisId***REMOVED*** == 0:
            return
        for i in range(len(self._axisId***REMOVED******REMOVED***:
            if self._menu.IsChecked(self._axisId[i***REMOVED******REMOVED***:
                self._menu.Check(self._axisId[i***REMOVED***, False***REMOVED***
            else:
                self._menu.Check(self._axisId[i***REMOVED***, True***REMOVED***
        self._toolbar.set_active(self.getActiveAxes(***REMOVED******REMOVED***
        evt.Skip(***REMOVED***

    def _onMenuItemSelected(self, evt***REMOVED***:
        ***REMOVED***Called whenever one of the specific axis menu items is selected***REMOVED***
        current = self._menu.IsChecked(evt.GetId(***REMOVED******REMOVED***
        if current:
            new = False
        else:
            new = True
        self._menu.Check(evt.GetId(***REMOVED***, new***REMOVED***
        # Lines above would be deleted based on svn tracker ID 2841525;
        # not clear whether this matters or not.
        self._toolbar.set_active(self.getActiveAxes(***REMOVED******REMOVED***
        evt.Skip(***REMOVED***

    def updateAxes(self, maxAxis***REMOVED***:
        ***REMOVED***Ensures that there are entries for max_axis axes in the menu
        (selected by default***REMOVED***.***REMOVED***
        if maxAxis > len(self._axisId***REMOVED***:
            for i in range(len(self._axisId***REMOVED*** + 1, maxAxis + 1, 1***REMOVED***:
                menuId = wx.NewId(***REMOVED***
                self._axisId.append(menuId***REMOVED***
                self._menu.Append(menuId, "Axis %d" % i,
                                  "Select axis %d" % i,
                                  True***REMOVED***
                self._menu.Check(menuId, True***REMOVED***
                self.Bind(wx.EVT_MENU, self._onMenuItemSelected, id=menuId***REMOVED***
        elif maxAxis < len(self._axisId***REMOVED***:
            for menuId in self._axisId[maxAxis:***REMOVED***:
                self._menu.Delete(menuId***REMOVED***
            self._axisId = self._axisId[:maxAxis***REMOVED***
        self._toolbar.set_active(list(xrange(maxAxis***REMOVED******REMOVED******REMOVED***

    def getActiveAxes(self***REMOVED***:
        ***REMOVED***Return a list of the selected axes.***REMOVED***
        active = [***REMOVED***
        for i in range(len(self._axisId***REMOVED******REMOVED***:
            if self._menu.IsChecked(self._axisId[i***REMOVED******REMOVED***:
                active.append(i***REMOVED***
        return active

    def updateButtonText(self, lst***REMOVED***:
        ***REMOVED***Update the list of selected axes in the menu button***REMOVED***
        axis_txt = ''
        for e in lst:
            axis_txt += '%d,' % (e + 1***REMOVED***
        # remove trailing ',' and add to button string
        self.SetLabel("Axes: %s" % axis_txt[:-1***REMOVED******REMOVED***


cursord = {
    cursors.MOVE: wx.CURSOR_HAND,
    cursors.HAND: wx.CURSOR_HAND,
    cursors.POINTER: wx.CURSOR_ARROW,
    cursors.SELECT_REGION: wx.CURSOR_CROSS,
***REMOVED***


class SubplotToolWX(wx.Frame***REMOVED***:
    def __init__(self, targetfig***REMOVED***:
        wx.Frame.__init__(self, None, -1, "Configure subplots"***REMOVED***

        toolfig = Figure((6, 3***REMOVED******REMOVED***
        canvas = FigureCanvasWx(self, -1, toolfig***REMOVED***

        # Create a figure manager to manage things
        figmgr = FigureManager(canvas, 1, self***REMOVED***

        # Now put all into a sizer
        sizer = wx.BoxSizer(wx.VERTICAL***REMOVED***
        # This way of adding to sizer allows resizing
        sizer.Add(canvas, 1, wx.LEFT | wx.TOP | wx.GROW***REMOVED***
        self.SetSizer(sizer***REMOVED***
        self.Fit(***REMOVED***
        tool = SubplotTool(targetfig, toolfig***REMOVED***


class NavigationToolbar2Wx(NavigationToolbar2, wx.ToolBar***REMOVED***:
    def __init__(self, canvas***REMOVED***:
        wx.ToolBar.__init__(self, canvas.GetParent(***REMOVED***, -1***REMOVED***
        NavigationToolbar2.__init__(self, canvas***REMOVED***
        self.canvas = canvas
        self._idle = True
        self.statbar = None
        self.prevZoomRect = None
        # for now, use alternate zoom-rectangle drawing on all
        # Macs. N.B. In future versions of wx it may be possible to
        # detect Retina displays with window.GetContentScaleFactor(***REMOVED***
        # and/or dc.GetContentScaleFactor(***REMOVED***
        self.retinaFix = 'wxMac' in wx.PlatformInfo

    def get_canvas(self, frame, fig***REMOVED***:
        return FigureCanvasWx(frame, -1, fig***REMOVED***

    def _init_toolbar(self***REMOVED***:
        DEBUG_MSG("_init_toolbar", 1, self***REMOVED***

        self._parent = self.canvas.GetParent(***REMOVED***

        self.wx_ids = {***REMOVED***
        for text, tooltip_text, image_file, callback in self.toolitems:
            if text is None:
                self.AddSeparator(***REMOVED***
                continue
            self.wx_ids[text***REMOVED*** = wx.NewId(***REMOVED***
            wxc._AddTool(self, self.wx_ids, text,
                        _load_bitmap(image_file + '.png'***REMOVED***,
                        tooltip_text***REMOVED***

            self.Bind(wx.EVT_TOOL, getattr(self, callback***REMOVED***,
                      id=self.wx_ids[text***REMOVED******REMOVED***

        self.Realize(***REMOVED***

    def zoom(self, *args***REMOVED***:
        self.ToggleTool(self.wx_ids['Pan'***REMOVED***, False***REMOVED***
        NavigationToolbar2.zoom(self, *args***REMOVED***

    def pan(self, *args***REMOVED***:
        self.ToggleTool(self.wx_ids['Zoom'***REMOVED***, False***REMOVED***
        NavigationToolbar2.pan(self, *args***REMOVED***

    def configure_subplots(self, evt***REMOVED***:
        frame = wx.Frame(None, -1, "Configure subplots"***REMOVED***

        toolfig = Figure((6, 3***REMOVED******REMOVED***
        canvas = self.get_canvas(frame, toolfig***REMOVED***

        # Create a figure manager to manage things
        figmgr = FigureManager(canvas, 1, frame***REMOVED***

        # Now put all into a sizer
        sizer = wx.BoxSizer(wx.VERTICAL***REMOVED***
        # This way of adding to sizer allows resizing
        sizer.Add(canvas, 1, wx.LEFT | wx.TOP | wx.GROW***REMOVED***
        frame.SetSizer(sizer***REMOVED***
        frame.Fit(***REMOVED***
        tool = SubplotTool(self.canvas.figure, toolfig***REMOVED***
        frame.Show(***REMOVED***

    def save_figure(self, *args***REMOVED***:
        # Fetch the required filename and file type.
        filetypes, exts, filter_index = self.canvas._get_imagesave_wildcards(***REMOVED***
        default_file = self.canvas.get_default_filename(***REMOVED***
        dlg = wx.FileDialog(self._parent, "Save to file", "", default_file,
                            filetypes,
                            wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT***REMOVED***
        dlg.SetFilterIndex(filter_index***REMOVED***
        if dlg.ShowModal(***REMOVED*** == wx.ID_OK:
            dirname = dlg.GetDirectory(***REMOVED***
            filename = dlg.GetFilename(***REMOVED***
            DEBUG_MSG(
                'Save file dir:%s name:%s' %
                (dirname, filename***REMOVED***, 3, self***REMOVED***
            format = exts[dlg.GetFilterIndex(***REMOVED******REMOVED***
            basename, ext = os.path.splitext(filename***REMOVED***
            if ext.startswith('.'***REMOVED***:
                ext = ext[1:***REMOVED***
            if ext in ('svg', 'pdf', 'ps', 'eps', 'png'***REMOVED*** and format != ext:
                # looks like they forgot to set the image type drop
                # down, going with the extension.
                warnings.warn(
                    'extension %s did not match the selected '
                    'image type %s; going with %s' %
                    (ext, format, ext***REMOVED***, stacklevel=0***REMOVED***
                format = ext
            ***REMOVED***
                self.canvas.print_figure(
                    os.path.join(dirname, filename***REMOVED***, format=format***REMOVED***
            except Exception as e:
                error_msg_wx(str(e***REMOVED******REMOVED***

    def set_cursor(self, cursor***REMOVED***:
        cursor = wxc.Cursor(cursord[cursor***REMOVED******REMOVED***
        self.canvas.SetCursor(cursor***REMOVED***

    def release(self, event***REMOVED***:
        ***REMOVED***
            del self.lastrect
        except AttributeError:
            pass

    def dynamic_update(self***REMOVED***:
        d = self._idle
        self._idle = False
        if d:
            self.canvas.draw(***REMOVED***
            self._idle = True

    def press(self, event***REMOVED***:
        if self._active == 'ZOOM':
            if not self.retinaFix:
                self.wxoverlay = wx.Overlay(***REMOVED***
            else:
                self.savedRetinaImage = self.canvas.copy_from_bbox(
                    self.canvas.figure.gca(***REMOVED***.bbox***REMOVED***
                self.zoomStartX = event.xdata
                self.zoomStartY = event.ydata

    def release(self, event***REMOVED***:
        if self._active == 'ZOOM':
            # When the mouse is released we reset the overlay and it
            # restores the former content to the window.
            if not self.retinaFix:
                self.wxoverlay.Reset(***REMOVED***
                del self.wxoverlay
            else:
                del self.savedRetinaImage
                if self.prevZoomRect:
                    self.prevZoomRect.pop(0***REMOVED***.remove(***REMOVED***
                    self.prevZoomRect = None

    def draw_rubberband(self, event, x0, y0, x1, y1***REMOVED***:
        if self.retinaFix:  # On Macs, use the following code
            # wx.DCOverlay does not work properly on Retina displays.
            rubberBandColor = '#C0C0FF'
            if self.prevZoomRect:
                self.prevZoomRect.pop(0***REMOVED***.remove(***REMOVED***
            self.canvas.restore_region(self.savedRetinaImage***REMOVED***
            X0, X1 = self.zoomStartX, event.xdata
            Y0, Y1 = self.zoomStartY, event.ydata
            lineX = (X0, X0, X1, X1, X0***REMOVED***
            lineY = (Y0, Y1, Y1, Y0, Y0***REMOVED***
            self.prevZoomRect = self.canvas.figure.gca(***REMOVED***.plot(
                lineX, lineY, '-', color=rubberBandColor***REMOVED***
            self.canvas.figure.gca(***REMOVED***.draw_artist(self.prevZoomRect[0***REMOVED******REMOVED***
            self.canvas.blit(self.canvas.figure.gca(***REMOVED***.bbox***REMOVED***
            return

        # Use an Overlay to draw a rubberband-like bounding box.

        dc = wx.ClientDC(self.canvas***REMOVED***
        odc = wx.DCOverlay(self.wxoverlay, dc***REMOVED***
        odc.Clear(***REMOVED***

        # Mac's DC is already the same as a GCDC, and it causes
        # problems with the overlay if we try to use an actual
        # wx.GCDC so don't try it.
        if 'wxMac' not in wx.PlatformInfo:
            dc = wx.GCDC(dc***REMOVED***

        height = self.canvas.figure.bbox.height
        y1 = height - y1
        y0 = height - y0

        if y1 < y0:
            y0, y1 = y1, y0
        if x1 < y0:
            x0, x1 = x1, x0

        w = x1 - x0
        h = y1 - y0
        rect = wx.Rect(x0, y0, w, h***REMOVED***

        rubberBandColor = '#C0C0FF'  # or load from config?

        # Set a pen for the border
        color = wxc.NamedColour(rubberBandColor***REMOVED***
        dc.SetPen(wx.Pen(color, 1***REMOVED******REMOVED***

        # use the same color, plus alpha for the brush
        r, g, b, a = color.Get(True***REMOVED***
        color.Set(r, g, b, 0x60***REMOVED***
        dc.SetBrush(wx.Brush(color***REMOVED******REMOVED***
        if wxc.is_phoenix:
            dc.DrawRectangle(rect***REMOVED***
        else:
            dc.DrawRectangleRect(rect***REMOVED***

    def set_status_bar(self, statbar***REMOVED***:
        self.statbar = statbar

    def set_message(self, s***REMOVED***:
        if self.statbar is not None:
            self.statbar.set_function(s***REMOVED***

    def set_history_buttons(self***REMOVED***:
        can_backward = (self._views._pos > 0***REMOVED***
        can_forward = (self._views._pos < len(self._views._elements***REMOVED*** - 1***REMOVED***
        self.EnableTool(self.wx_ids['Back'***REMOVED***, can_backward***REMOVED***
        self.EnableTool(self.wx_ids['Forward'***REMOVED***, can_forward***REMOVED***


class StatusBarWx(wx.StatusBar***REMOVED***:
    ***REMOVED***
    A status bar is added to _FigureFrame to allow measurements and the
    previously selected scroll function to be displayed as a user
    convenience.
    ***REMOVED***

    def __init__(self, parent***REMOVED***:
        wx.StatusBar.__init__(self, parent, -1***REMOVED***
        self.SetFieldsCount(2***REMOVED***
        self.SetStatusText("None", 1***REMOVED***
        #self.SetStatusText("Measurement: None", 2***REMOVED***
        # self.Reposition(***REMOVED***

    def set_function(self, string***REMOVED***:
        self.SetStatusText("%s" % string, 1***REMOVED***

    # def set_measurement(self, string***REMOVED***:
    #    self.SetStatusText("Measurement: %s" % string, 2***REMOVED***


#< Additions for printing support: Matt Newville

class PrintoutWx(wx.Printout***REMOVED***:
    ***REMOVED***
    Simple wrapper around wx Printout class -- all the real work
    here is scaling the matplotlib canvas bitmap to the current
    printer's definition.
    ***REMOVED***

    def __init__(self, canvas, width=5.5, margin=0.5, title='matplotlib'***REMOVED***:
        wx.Printout.__init__(self, title=title***REMOVED***
        self.canvas = canvas
        # width, in inches of output figure (approximate***REMOVED***
        self.width = width
        self.margin = margin

    def HasPage(self, page***REMOVED***:
        # current only supports 1 page print
        return page == 1

    def GetPageInfo(self***REMOVED***:
        return (1, 1, 1, 1***REMOVED***

    def OnPrintPage(self, page***REMOVED***:
        self.canvas.draw(***REMOVED***

        dc = self.GetDC(***REMOVED***
        (ppw, pph***REMOVED*** = self.GetPPIPrinter(***REMOVED***      # printer's pixels per in
        (pgw, pgh***REMOVED*** = self.GetPageSizePixels(***REMOVED***  # page size in pixels
        (dcw, dch***REMOVED*** = dc.GetSize(***REMOVED***
        if wxc.is_phoenix:
            (grw, grh***REMOVED*** = self.canvas.GetSize(***REMOVED***
        else:
            (grw, grh***REMOVED*** = self.canvas.GetSizeTuple(***REMOVED***

        # save current figure dpi resolution and bg color,
        # so that we can temporarily set them to the dpi of
        # the printer, and the bg color to white
        bgcolor = self.canvas.figure.get_facecolor(***REMOVED***
        fig_dpi = self.canvas.figure.dpi

        # draw the bitmap, scaled appropriately
        vscale = float(ppw***REMOVED*** / fig_dpi

        # set figure resolution,bg color for printer
        self.canvas.figure.dpi = ppw
        self.canvas.figure.set_facecolor('#FFFFFF'***REMOVED***

        renderer = RendererWx(self.canvas.bitmap, self.canvas.figure.dpi***REMOVED***
        self.canvas.figure.draw(renderer***REMOVED***
        self.canvas.bitmap.SetWidth(
            int(self.canvas.bitmap.GetWidth(***REMOVED*** * vscale***REMOVED******REMOVED***
        self.canvas.bitmap.SetHeight(
            int(self.canvas.bitmap.GetHeight(***REMOVED*** * vscale***REMOVED******REMOVED***
        self.canvas.draw(***REMOVED***

        # page may need additional scaling on preview
        page_scale = 1.0
        if self.IsPreview(***REMOVED***:
            page_scale = float(dcw***REMOVED*** / pgw

        # get margin in pixels = (margin in in***REMOVED*** * (pixels/in***REMOVED***
        top_margin = int(self.margin * pph * page_scale***REMOVED***
        left_margin = int(self.margin * ppw * page_scale***REMOVED***

        # set scale so that width of output is self.width inches
        # (assuming grw is size of graph in inches....***REMOVED***
        user_scale = (self.width * fig_dpi * page_scale***REMOVED*** / float(grw***REMOVED***

        dc.SetDeviceOrigin(left_margin, top_margin***REMOVED***
        dc.SetUserScale(user_scale, user_scale***REMOVED***

        # this cute little number avoid API inconsistencies in wx
        ***REMOVED***
            dc.DrawBitmap(self.canvas.bitmap, 0, 0***REMOVED***
        ***REMOVED***
            ***REMOVED***
                dc.DrawBitmap(self.canvas.bitmap, (0, 0***REMOVED******REMOVED***
            ***REMOVED***
                pass

        # restore original figure  resolution
        self.canvas.figure.set_facecolor(bgcolor***REMOVED***
        self.canvas.figure.dpi = fig_dpi
        self.canvas.draw(***REMOVED***
        return True
#>

########################################################################
#
# Now just provide the standard names that backend.__init__ is expecting
#
########################################################################

FigureCanvas = FigureCanvasWx
FigureManager = FigureManagerWx
Toolbar = NavigationToolbar2Wx
