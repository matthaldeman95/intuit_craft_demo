***REMOVED***
Displays Agg images in the browser, with interactivity
***REMOVED***
# The WebAgg backend is divided into two modules:
#
# - `backend_webagg_core.py` contains code necessary to embed a WebAgg
#   plot inside of a web application, and communicate in an abstract
#   way over a web socket.
#
# - `backend_webagg.py` contains a concrete implementation of a basic
#   application, implemented with tornado.

from __future__ import (absolute_import, division, print_function,
                        unicode_literals***REMOVED***

from matplotlib.externals import six

import io
import json
***REMOVED***
import time
import warnings

import numpy as np
import tornado
import datetime

from matplotlib.backends import backend_agg
from matplotlib.figure import Figure
from matplotlib import backend_bases
from matplotlib import _png


def new_figure_manager(num, *args, **kwargs***REMOVED***:
    ***REMOVED***
    Create a new figure manager instance
    ***REMOVED***
    FigureClass = kwargs.pop('FigureClass', Figure***REMOVED***
    thisFig = FigureClass(*args, **kwargs***REMOVED***
    return new_figure_manager_given_figure(num, thisFig***REMOVED***


def new_figure_manager_given_figure(num, figure***REMOVED***:
    ***REMOVED***
    Create a new figure manager instance for the given figure.
    ***REMOVED***
    canvas = FigureCanvasWebAggCore(figure***REMOVED***
    manager = FigureManagerWebAgg(canvas, num***REMOVED***
    return manager


# http://www.cambiaresearch.com/articles/15/javascript-char-codes-key-codes
_SHIFT_LUT = {59: ':',
              61: '+',
              173: '_',
              186: ':',
              187: '+',
              188: '<',
              189: '_',
              190: '>',
              191: '?',
              192: '~',
              219: '{',
              220: '|',
              221: '***REMOVED***',
              222: '"'***REMOVED***

_LUT = {8: 'backspace',
        9: 'tab',
        13: 'enter',
        16: 'shift',
        17: 'control',
        18: 'alt',
        19: 'pause',
        20: 'caps',
        27: 'escape',
        32: ' ',
        33: 'pageup',
        34: 'pagedown',
        35: 'end',
        36: 'home',
        37: 'left',
        38: 'up',
        39: 'right',
        40: 'down',
        45: 'insert',
        46: 'delete',
        91: 'super',
        92: 'super',
        93: 'select',
        106: '*',
        107: '+',
        109: '-',
        110: '.',
        111: '/',
        144: 'num_lock',
        145: 'scroll_lock',
        186: ':',
        187: '=',
        188: ',',
        189: '-',
        190: '.',
        191: '/',
        192: '`',
        219: '[',
        220: '\\',
        221: '***REMOVED***',
        222: "'"***REMOVED***


def _handle_key(key***REMOVED***:
    ***REMOVED***Handle key codes***REMOVED***
    code = int(key[key.index('k'***REMOVED*** + 1:***REMOVED******REMOVED***
    value = chr(code***REMOVED***
    # letter keys
    if code >= 65 and code <= 90:
        if 'shift+' in key:
            key = key.replace('shift+', ''***REMOVED***
        else:
            value = value.lower(***REMOVED***
    # number keys
    elif code >= 48 and code <= 57:
        if 'shift+' in key:
            value = '***REMOVED***!@#$%^&*('[int(value***REMOVED******REMOVED***
            key = key.replace('shift+', ''***REMOVED***
    # function keys
    elif code >= 112 and code <= 123:
        value = 'f%s' % (code - 111***REMOVED***
    # number pad keys
    elif code >= 96 and code <= 105:
        value = '%s' % (code - 96***REMOVED***
    # keys with shift alternatives
    elif code in _SHIFT_LUT and 'shift+' in key:
        key = key.replace('shift+', ''***REMOVED***
        value = _SHIFT_LUT[code***REMOVED***
    elif code in _LUT:
        value = _LUT[code***REMOVED***
    key = key[:key.index('k'***REMOVED******REMOVED*** + value
    return key


class FigureCanvasWebAggCore(backend_agg.FigureCanvasAgg***REMOVED***:
    supports_blit = False

    def __init__(self, *args, **kwargs***REMOVED***:
        backend_agg.FigureCanvasAgg.__init__(self, *args, **kwargs***REMOVED***

        # A buffer to hold the PNG data for the last frame.  This is
        # retained so it can be resent to each client without
        # regenerating it.
        self._png_buffer = io.BytesIO(***REMOVED***

        # Set to True when the renderer contains data that is newer
        # than the PNG buffer.
        self._png_is_old = True

        # Set to True by the `refresh` message so that the next frame
        # sent to the clients will be a full frame.
        self._force_full = True

        # Store the current image mode so that at any point, clients can
        # request the information. This should be changed by calling
        # self.set_image_mode(mode***REMOVED*** so that the notification can be given
        # to the connected clients.
        self._current_image_mode = 'full'

    def show(self***REMOVED***:
        # show the figure window
        from matplotlib.pyplot import show
        show(***REMOVED***

    def draw(self***REMOVED***:
        renderer = self.get_renderer(cleared=True***REMOVED***

        self._png_is_old = True

        backend_agg.RendererAgg.lock.acquire(***REMOVED***
        ***REMOVED***
            self.figure.draw(renderer***REMOVED***
        finally:
            backend_agg.RendererAgg.lock.release(***REMOVED***
            # Swap the frames
            self.manager.refresh_all(***REMOVED***

    def draw_idle(self***REMOVED***:
        self.send_event("draw"***REMOVED***

    def set_image_mode(self, mode***REMOVED***:
        ***REMOVED***
        Set the image mode for any subsequent images which will be sent
        to the clients. The modes may currently be either 'full' or 'diff'.

        Note: diff images may not contain transparency, therefore upon
        draw this mode may be changed if the resulting image has any
        transparent component.

        ***REMOVED***
        if mode not in ['full', 'diff'***REMOVED***:
            raise ValueError('image mode must be either full or diff.'***REMOVED***
        if self._current_image_mode != mode:
            self._current_image_mode = mode
            self.handle_send_image_mode(None***REMOVED***

    def get_diff_image(self***REMOVED***:
        if self._png_is_old:
            renderer = self.get_renderer(***REMOVED***

            # The buffer is created as type uint32 so that entire
            # pixels can be compared in one numpy call, rather than
            # needing to compare each plane separately.
            buff = np.frombuffer(renderer.buffer_rgba(***REMOVED***, dtype=np.uint32***REMOVED***
            buff.shape = (renderer.height, renderer.width***REMOVED***

            # If any pixels have transparency, we need to force a full
            # draw as we cannot overlay new on top of old.
            pixels = buff.view(dtype=np.uint8***REMOVED***.reshape(buff.shape + (4,***REMOVED******REMOVED***

            if self._force_full or np.any(pixels[:, :, 3***REMOVED*** != 255***REMOVED***:
                self.set_image_mode('full'***REMOVED***
                output = buff
            else:
                self.set_image_mode('diff'***REMOVED***
                last_buffer = np.frombuffer(self._last_renderer.buffer_rgba(***REMOVED***,
                                            dtype=np.uint32***REMOVED***
                last_buffer.shape = (renderer.height, renderer.width***REMOVED***

                diff = buff != last_buffer
                output = np.where(diff, buff, 0***REMOVED***

            # Clear out the PNG data buffer rather than recreating it
            # each time.  This reduces the number of memory
            # (de***REMOVED***allocations.
            self._png_buffer.truncate(***REMOVED***
            self._png_buffer.seek(0***REMOVED***

            # TODO: We should write a new version of write_png that
            # handles the differencing inline
            _png.write_png(
                output.view(dtype=np.uint8***REMOVED***.reshape(output.shape + (4,***REMOVED******REMOVED***,
                self._png_buffer***REMOVED***

            # Swap the renderer frames
            self._renderer, self._last_renderer = (
                self._last_renderer, renderer***REMOVED***
            self._force_full = False
            self._png_is_old = False
        return self._png_buffer.getvalue(***REMOVED***

    def get_renderer(self, cleared=None***REMOVED***:
        # Mirrors super.get_renderer, but caches the old one
        # so that we can do things such as produce a diff image
        # in get_diff_image
        _, _, w, h = self.figure.bbox.bounds
        w, h = int(w***REMOVED***, int(h***REMOVED***
        key = w, h, self.figure.dpi
        ***REMOVED***
            self._lastKey, self._renderer
        except AttributeError:
            need_new_renderer = True
        else:
            need_new_renderer = (self._lastKey != key***REMOVED***

        if need_new_renderer:
            self._renderer = backend_agg.RendererAgg(
                w, h, self.figure.dpi***REMOVED***
            self._last_renderer = backend_agg.RendererAgg(
                w, h, self.figure.dpi***REMOVED***
            self._lastKey = key

        elif cleared:
            self._renderer.clear(***REMOVED***

        return self._renderer

    def handle_event(self, event***REMOVED***:
        e_type = event['type'***REMOVED***
        guiEvent = event.get('guiEvent', None***REMOVED***

        if e_type == 'ack':
            # Network latency tends to decrease if traffic is flowing
            # in both directions.  Therefore, the browser sends back
            # an "ack" message after each image frame is received.
            # This could also be used as a simple sanity check in the
            # future, but for now the performance increase is enough
            # to justify it, even if the server does nothing with it.
            pass
        elif e_type == 'draw':
            self.draw(***REMOVED***
        elif e_type in ('button_press', 'button_release', 'motion_notify',
                        'figure_enter', 'figure_leave', 'scroll'***REMOVED***:
            x = event['x'***REMOVED***
            y = event['y'***REMOVED***
            y = self.get_renderer(***REMOVED***.height - y

            # Javascript button numbers and matplotlib button numbers are
            # off by 1
            button = event['button'***REMOVED*** + 1

            # The right mouse button pops up a context menu, which
            # doesn't work very well, so use the middle mouse button
            # instead.  It doesn't seem that it's possible to disable
            # the context menu in recent versions of Chrome.  If this
            # is resolved, please also adjust the docstring in MouseEvent.
            if button == 2:
                button = 3

            if e_type == 'button_press':
                self.button_press_event(x, y, button, guiEvent=guiEvent***REMOVED***
            elif e_type == 'button_release':
                self.button_release_event(x, y, button, guiEvent=guiEvent***REMOVED***
            elif e_type == 'motion_notify':
                self.motion_notify_event(x, y, guiEvent=guiEvent***REMOVED***
            elif e_type == 'figure_enter':
                self.enter_notify_event(xy=(x, y***REMOVED***, guiEvent=guiEvent***REMOVED***
            elif e_type == 'figure_leave':
                self.leave_notify_event(***REMOVED***
            elif e_type == 'scroll':
                self.scroll_event(x, y, event['step'***REMOVED***, guiEvent=guiEvent***REMOVED***
        elif e_type in ('key_press', 'key_release'***REMOVED***:
            key = _handle_key(event['key'***REMOVED******REMOVED***
            if e_type == 'key_press':
                self.key_press_event(key, guiEvent=guiEvent***REMOVED***
            elif e_type == 'key_release':
                self.key_release_event(key, guiEvent=guiEvent***REMOVED***
        elif e_type == 'toolbar_button':
            # TODO: Be more suspicious of the input
            getattr(self.toolbar, event['name'***REMOVED******REMOVED***(***REMOVED***
        elif e_type == 'refresh':
            figure_label = self.figure.get_label(***REMOVED***
            if not figure_label:
                figure_label = "Figure {0***REMOVED***".format(self.manager.num***REMOVED***
            self.send_event('figure_label', label=figure_label***REMOVED***
            self._force_full = True
            self.draw_idle(***REMOVED***

        else:
            handler = getattr(self, 'handle_{0***REMOVED***'.format(e_type***REMOVED***, None***REMOVED***
            if handler is None:
                import warnings
                warnings.warn('Unhandled message type {0***REMOVED***. {1***REMOVED***'.format(
                                                        e_type, event***REMOVED******REMOVED***
            else:
                return handler(event***REMOVED***

    def handle_resize(self, event***REMOVED***:
        x, y = event.get('width', 800***REMOVED***, event.get('height', 800***REMOVED***
        x, y = int(x***REMOVED***, int(y***REMOVED***
        fig = self.figure
        # An attempt at approximating the figure size in pixels.
        fig.set_size_inches(x / fig.dpi, y / fig.dpi***REMOVED***

        _, _, w, h = self.figure.bbox.bounds
        # Acknowledge the resize, and force the viewer to update the
        # canvas size to the figure's new size (which is hopefully
        # identical or within a pixel or so***REMOVED***.
        self._png_is_old = True
        self.manager.resize(w, h***REMOVED***
        self.resize_event(***REMOVED***

    def handle_send_image_mode(self, event***REMOVED***:
        # The client requests notification of what the current image mode is.
        self.send_event('image_mode', mode=self._current_image_mode***REMOVED***

    def send_event(self, event_type, **kwargs***REMOVED***:
        self.manager._send_event(event_type, **kwargs***REMOVED***

    def start_event_loop(self, timeout***REMOVED***:
        backend_bases.FigureCanvasBase.start_event_loop_default(
            self, timeout***REMOVED***
    start_event_loop.__doc__ = \
        backend_bases.FigureCanvasBase.start_event_loop_default.__doc__

    def stop_event_loop(self***REMOVED***:
        backend_bases.FigureCanvasBase.stop_event_loop_default(self***REMOVED***
    stop_event_loop.__doc__ = \
        backend_bases.FigureCanvasBase.stop_event_loop_default.__doc__


_JQUERY_ICON_CLASSES = {
    'home': 'ui-icon ui-icon-home',
    'back': 'ui-icon ui-icon-circle-arrow-w',
    'forward': 'ui-icon ui-icon-circle-arrow-e',
    'zoom_to_rect': 'ui-icon ui-icon-search',
    'move': 'ui-icon ui-icon-arrow-4',
    'download': 'ui-icon ui-icon-disk',
    None: None,
***REMOVED***


class NavigationToolbar2WebAgg(backend_bases.NavigationToolbar2***REMOVED***:

    # Use the standard toolbar items + download button
    toolitems = [(text, tooltip_text, _JQUERY_ICON_CLASSES[image_file***REMOVED***,
                  name_of_method***REMOVED***
                 for text, tooltip_text, image_file, name_of_method
                 in (backend_bases.NavigationToolbar2.toolitems +
                     (('Download', 'Download plot', 'download', 'download'***REMOVED***,***REMOVED******REMOVED***
                 if image_file in _JQUERY_ICON_CLASSES***REMOVED***

    def _init_toolbar(self***REMOVED***:
        self.message = ''
        self.cursor = 0

    def set_message(self, message***REMOVED***:
        if message != self.message:
            self.canvas.send_event("message", message=message***REMOVED***
        self.message = message

    def set_cursor(self, cursor***REMOVED***:
        if cursor != self.cursor:
            self.canvas.send_event("cursor", cursor=cursor***REMOVED***
        self.cursor = cursor

    def dynamic_update(self***REMOVED***:
        self.canvas.draw_idle(***REMOVED***

    def draw_rubberband(self, event, x0, y0, x1, y1***REMOVED***:
        self.canvas.send_event(
            "rubberband", x0=x0, y0=y0, x1=x1, y1=y1***REMOVED***

    def release_zoom(self, event***REMOVED***:
        backend_bases.NavigationToolbar2.release_zoom(self, event***REMOVED***
        self.canvas.send_event(
            "rubberband", x0=-1, y0=-1, x1=-1, y1=-1***REMOVED***

    def save_figure(self, *args***REMOVED***:
        ***REMOVED***Save the current figure***REMOVED***
        self.canvas.send_event('save'***REMOVED***


class FigureManagerWebAgg(backend_bases.FigureManagerBase***REMOVED***:
    ToolbarCls = NavigationToolbar2WebAgg

    def __init__(self, canvas, num***REMOVED***:
        backend_bases.FigureManagerBase.__init__(self, canvas, num***REMOVED***

        self.web_sockets = set(***REMOVED***

        self.toolbar = self._get_toolbar(canvas***REMOVED***

    def show(self***REMOVED***:
        pass

    def _get_toolbar(self, canvas***REMOVED***:
        toolbar = self.ToolbarCls(canvas***REMOVED***
        return toolbar

    def resize(self, w, h***REMOVED***:
        self._send_event('resize', size=(w, h***REMOVED******REMOVED***

    def set_window_title(self, title***REMOVED***:
        self._send_event('figure_label', label=title***REMOVED***

    # The following methods are specific to FigureManagerWebAgg

    def add_web_socket(self, web_socket***REMOVED***:
        assert hasattr(web_socket, 'send_binary'***REMOVED***
        assert hasattr(web_socket, 'send_json'***REMOVED***

        self.web_sockets.add(web_socket***REMOVED***

        _, _, w, h = self.canvas.figure.bbox.bounds
        self.resize(w, h***REMOVED***
        self._send_event('refresh'***REMOVED***

    def remove_web_socket(self, web_socket***REMOVED***:
        self.web_sockets.remove(web_socket***REMOVED***

    def handle_json(self, content***REMOVED***:
        self.canvas.handle_event(content***REMOVED***

    def refresh_all(self***REMOVED***:
        if self.web_sockets:
            diff = self.canvas.get_diff_image(***REMOVED***
            for s in self.web_sockets:
                s.send_binary(diff***REMOVED***

    @classmethod
    def get_javascript(cls, stream=None***REMOVED***:
        if stream is None:
            output = io.StringIO(***REMOVED***
        else:
            output = stream

        with io.open(os.path.join(
                os.path.dirname(__file__***REMOVED***,
                "web_backend",
                "mpl.js"***REMOVED***, encoding='utf8'***REMOVED*** as fd:
            output.write(fd.read(***REMOVED******REMOVED***

        toolitems = [***REMOVED***
        for name, tooltip, image, method in cls.ToolbarCls.toolitems:
            if name is None:
                toolitems.append(['', '', '', ''***REMOVED******REMOVED***
            else:
                toolitems.append([name, tooltip, image, method***REMOVED******REMOVED***
        output.write("mpl.toolbar_items = {0***REMOVED***;\n\n".format(
            json.dumps(toolitems***REMOVED******REMOVED******REMOVED***

        extensions = [***REMOVED***
        for filetype, ext in sorted(FigureCanvasWebAggCore.
                                    get_supported_filetypes_grouped(***REMOVED***.
                                    items(***REMOVED******REMOVED***:
            if not ext[0***REMOVED*** == 'pgf':  # pgf does not support BytesIO
                extensions.append(ext[0***REMOVED******REMOVED***
        output.write("mpl.extensions = {0***REMOVED***;\n\n".format(
            json.dumps(extensions***REMOVED******REMOVED******REMOVED***

        output.write("mpl.default_extension = {0***REMOVED***;".format(
            json.dumps(FigureCanvasWebAggCore.get_default_filetype(***REMOVED******REMOVED******REMOVED******REMOVED***

        if stream is None:
            return output.getvalue(***REMOVED***

    @classmethod
    def get_static_file_path(cls***REMOVED***:
        return os.path.join(os.path.dirname(__file__***REMOVED***, 'web_backend'***REMOVED***

    def _send_event(self, event_type, **kwargs***REMOVED***:
        payload = {'type': event_type***REMOVED***
        payload.update(kwargs***REMOVED***
        for s in self.web_sockets:
            s.send_json(payload***REMOVED***


class TimerTornado(backend_bases.TimerBase***REMOVED***:
    def _timer_start(self***REMOVED***:
        self._timer_stop(***REMOVED***
        if self._single:
            ioloop = tornado.ioloop.IOLoop.instance(***REMOVED***
            self._timer = ioloop.add_timeout(
                datetime.timedelta(milliseconds=self.interval***REMOVED***,
                self._on_timer***REMOVED***
        else:
            self._timer = tornado.ioloop.PeriodicCallback(
                self._on_timer,
                self.interval***REMOVED***
            self._timer.start(***REMOVED***

    def _timer_stop(self***REMOVED***:
        if self._timer is None:
            return
        elif self._single:
            ioloop = tornado.ioloop.IOLoop.instance(***REMOVED***
            ioloop.remove_timeout(self._timer***REMOVED***
        else:
            self._timer.stop(***REMOVED***

        self._timer = None

    def _timer_set_interval(self***REMOVED***:
        # Only stop and restart it if the timer has already been started
        if self._timer is not None:
            self._timer_stop(***REMOVED***
            self._timer_start(***REMOVED***
