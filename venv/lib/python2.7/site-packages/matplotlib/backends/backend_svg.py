from __future__ import (absolute_import, division, print_function,
                        unicode_literals***REMOVED***

from matplotlib.externals import six
from matplotlib.externals.six.moves import xrange
from matplotlib.externals.six import unichr

***REMOVED***, base64, tempfile, gzip, io, sys, codecs, re

import numpy as np

from hashlib import md5
import uuid

from matplotlib import verbose, __version__, rcParams
from matplotlib.backend_bases import RendererBase, GraphicsContextBase,\
     FigureManagerBase, FigureCanvasBase
from matplotlib.backends.backend_mixed import MixedModeRenderer
from matplotlib.cbook import is_string_like, is_writable_file_like, maxdict
from matplotlib.colors import rgb2hex
from matplotlib.figure import Figure
from matplotlib.font_manager import findfont, FontProperties
from matplotlib.ft2font import FT2Font, KERNING_DEFAULT, LOAD_NO_HINTING
from matplotlib.mathtext import MathTextParser
from matplotlib.path import Path
from matplotlib import _path
from matplotlib.transforms import Affine2D, Affine2DBase
from matplotlib import _png

from xml.sax.saxutils import escape as escape_xml_text

backend_version = __version__

# ----------------------------------------------------------------------
# SimpleXMLWriter class
#
# Based on an original by Fredrik Lundh, but modified here to:
#   1. Support modern Python idioms
#   2. Remove encoding support (it's handled by the file writer instead***REMOVED***
#   3. Support proper indentation
#   4. Minify things a little bit

# --------------------------------------------------------------------
# The SimpleXMLWriter module is
#
# Copyright (c***REMOVED*** 2001-2004 by Fredrik Lundh
#
# By obtaining, using, and/or copying this software and/or its
# associated documentation, you agree that you have read, understood,
# and will comply with the following terms and conditions:
#
# Permission to use, copy, modify, and distribute this software and
# its associated documentation for any purpose and without fee is
# hereby granted, provided that the above copyright notice appears in
# all copies, and that both that copyright notice and this permission
# notice appear in supporting documentation, and that the name of
# Secret Labs AB or the author not be used in advertising or publicity
# pertaining to distribution of the software without specific, written
# prior permission.
#
# SECRET LABS AB AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD
# TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANT-
# ABILITY AND FITNESS.  IN NO EVENT SHALL SECRET LABS AB OR THE AUTHOR
# BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY
# DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
# OF THIS SOFTWARE.
# --------------------------------------------------------------------

def escape_cdata(s***REMOVED***:
    s = s.replace("&", "&amp;"***REMOVED***
    s = s.replace("<", "&lt;"***REMOVED***
    s = s.replace(">", "&gt;"***REMOVED***
    return s

_escape_xml_comment = re.compile(r'-(?=-***REMOVED***'***REMOVED***
def escape_comment(s***REMOVED***:
    s = escape_cdata(s***REMOVED***
    return _escape_xml_comment.sub('- ', s***REMOVED***

def escape_attrib(s***REMOVED***:
    s = s.replace("&", "&amp;"***REMOVED***
    s = s.replace("'", "&apos;"***REMOVED***
    s = s.replace("\"", "&quot;"***REMOVED***
    s = s.replace("<", "&lt;"***REMOVED***
    s = s.replace(">", "&gt;"***REMOVED***
    return s

##
# XML writer class.
#
# @param file A file or file-like object.  This object must implement
#    a <b>write</b> method that takes an 8-bit string.

class XMLWriter(object***REMOVED***:
    def __init__(self, file***REMOVED***:
        self.__write = file.write
        if hasattr(file, "flush"***REMOVED***:
            self.flush = file.flush
        self.__open = 0 # true if start tag is open
        self.__tags = [***REMOVED***
        self.__data = [***REMOVED***
        self.__indentation = " " * 64

    def __flush(self, indent=True***REMOVED***:
        # flush internal buffers
        if self.__open:
            if indent:
                self.__write(">\n"***REMOVED***
            else:
                self.__write(">"***REMOVED***
            self.__open = 0
        if self.__data:
            data = ''.join(self.__data***REMOVED***
            self.__write(escape_cdata(data***REMOVED******REMOVED***
            self.__data = [***REMOVED***

    ## Opens a new element.  Attributes can be given as keyword
    # arguments, or as a string/string dictionary. The method returns
    # an opaque identifier that can be passed to the <b>close</b>
    # method, to close all open elements up to and including this one.
    #
    # @param tag Element tag.
    # @param attrib Attribute dictionary.  Alternatively, attributes
    #    can be given as keyword arguments.
    # @return An element identifier.

    def start(self, tag, attrib={***REMOVED***, **extra***REMOVED***:
        self.__flush(***REMOVED***
        tag = escape_cdata(tag***REMOVED***
        self.__data = [***REMOVED***
        self.__tags.append(tag***REMOVED***
        self.__write(self.__indentation[:len(self.__tags***REMOVED*** - 1***REMOVED******REMOVED***
        self.__write("<%s" % tag***REMOVED***
        if attrib or extra:
            attrib = attrib.copy(***REMOVED***
            attrib.update(extra***REMOVED***
            attrib = list(six.iteritems(attrib***REMOVED******REMOVED***
            attrib.sort(***REMOVED***
            for k, v in attrib:
                if not v == '':
                    k = escape_cdata(k***REMOVED***
                    v = escape_attrib(v***REMOVED***
                    self.__write(" %s=\"%s\"" % (k, v***REMOVED******REMOVED***
        self.__open = 1
        return len(self.__tags***REMOVED***-1

    ##
    # Adds a comment to the output stream.
    #
    # @param comment Comment text, as a Unicode string.

    def comment(self, comment***REMOVED***:
        self.__flush(***REMOVED***
        self.__write(self.__indentation[:len(self.__tags***REMOVED******REMOVED******REMOVED***
        self.__write("<!-- %s -->\n" % escape_comment(comment***REMOVED******REMOVED***

    ##
    # Adds character data to the output stream.
    #
    # @param text Character data, as a Unicode string.

    def data(self, text***REMOVED***:
        self.__data.append(text***REMOVED***

    ##
    # Closes the current element (opened by the most recent call to
    # <b>start</b>***REMOVED***.
    #
    # @param tag Element tag.  If given, the tag must match the start
    #    tag.  If omitted, the current element is closed.

    def end(self, tag=None, indent=True***REMOVED***:
        if tag:
            assert self.__tags, "unbalanced end(%s***REMOVED***" % tag
            assert escape_cdata(tag***REMOVED*** == self.__tags[-1***REMOVED***,\
                   "expected end(%s***REMOVED***, got %s" % (self.__tags[-1***REMOVED***, tag***REMOVED***
        else:
            assert self.__tags, "unbalanced end(***REMOVED***"
        tag = self.__tags.pop(***REMOVED***
        if self.__data:
            self.__flush(indent***REMOVED***
        elif self.__open:
            self.__open = 0
            self.__write("/>\n"***REMOVED***
            return
        if indent:
            self.__write(self.__indentation[:len(self.__tags***REMOVED******REMOVED******REMOVED***
        self.__write("</%s>\n" % tag***REMOVED***

    ##
    # Closes open elements, up to (and including***REMOVED*** the element identified
    # by the given identifier.
    #
    # @param id Element identifier, as returned by the <b>start</b> method.

    def close(self, id***REMOVED***:
        while len(self.__tags***REMOVED*** > id:
            self.end(***REMOVED***

    ##
    # Adds an entire element.  This is the same as calling <b>start</b>,
    # <b>data</b>, and <b>end</b> in sequence. The <b>text</b> argument
    # can be omitted.

    def element(self, tag, text=None, attrib={***REMOVED***, **extra***REMOVED***:
        self.start(*(tag, attrib***REMOVED***, **extra***REMOVED***
        if text:
            self.data(text***REMOVED***
        self.end(indent=False***REMOVED***

    ##
    # Flushes the output stream.

    def flush(self***REMOVED***:
        pass # replaced by the constructor

# ----------------------------------------------------------------------

def generate_transform(transform_list=[***REMOVED******REMOVED***:
    if len(transform_list***REMOVED***:
        output = io.StringIO(***REMOVED***
        for type, value in transform_list:
            if type == 'scale' and (value == (1.0,***REMOVED*** or value == (1.0, 1.0***REMOVED******REMOVED***:
                continue
            if type == 'translate' and value == (0.0, 0.0***REMOVED***:
                continue
            if type == 'rotate' and value == (0.0,***REMOVED***:
                continue
            if type == 'matrix' and isinstance(value, Affine2DBase***REMOVED***:
                value = value.to_values(***REMOVED***

            output.write('%s(%s***REMOVED***' % (type, ' '.join(str(x***REMOVED*** for x in value***REMOVED******REMOVED******REMOVED***
        return output.getvalue(***REMOVED***
    return ''

def generate_css(attrib={***REMOVED******REMOVED***:
    if attrib:
        output = io.StringIO(***REMOVED***
        attrib = list(six.iteritems(attrib***REMOVED******REMOVED***
        attrib.sort(***REMOVED***
        for k, v in attrib:
            k = escape_attrib(k***REMOVED***
            v = escape_attrib(v***REMOVED***
            output.write("%s:%s;" % (k, v***REMOVED******REMOVED***
        return output.getvalue(***REMOVED***
    return ''

_capstyle_d = {'projecting' : 'square', 'butt' : 'butt', 'round': 'round',***REMOVED***
class RendererSVG(RendererBase***REMOVED***:
    FONT_SCALE = 100.0
    fontd = maxdict(50***REMOVED***

    def __init__(self, width, height, svgwriter, basename=None, image_dpi=72***REMOVED***:
        self.width = width
        self.height = height
        self.writer = XMLWriter(svgwriter***REMOVED***
        self.image_dpi = image_dpi  # the actual dpi we want to rasterize stuff with

        self._groupd = {***REMOVED***
        if not rcParams['svg.image_inline'***REMOVED***:
            assert basename is not None
            self.basename = basename
            self._imaged = {***REMOVED***
        self._clipd = {***REMOVED***
        self._char_defs = {***REMOVED***
        self._markers = {***REMOVED***
        self._path_collection_id = 0
        self._imaged = {***REMOVED***
        self._hatchd = {***REMOVED***
        self._has_gouraud = False
        self._n_gradients = 0
        self._fonts = {***REMOVED***
        self.mathtext_parser = MathTextParser('SVG'***REMOVED***

        RendererBase.__init__(self***REMOVED***
        self._glyph_map = dict(***REMOVED***

        svgwriter.write(svgProlog***REMOVED***
        self._start_id = self.writer.start(
            'svg',
            width='%ipt' % width, height='%ipt' % height,
            viewBox='0 0 %i %i' % (width, height***REMOVED***,
            xmlns="http://www.w3.org/2000/svg",
            version="1.1",
            attrib={'xmlns:xlink': "http://www.w3.org/1999/xlink"***REMOVED******REMOVED***
        self._write_default_style(***REMOVED***

    def finalize(self***REMOVED***:
        self._write_clips(***REMOVED***
        self._write_hatches(***REMOVED***
        self._write_svgfonts(***REMOVED***
        self.writer.close(self._start_id***REMOVED***
        self.writer.flush(***REMOVED***

    def _write_default_style(self***REMOVED***:
        writer = self.writer
        default_style = generate_css({
            'stroke-linejoin': 'round',
            'stroke-linecap': 'butt',
            # Disable the miter limit.  100000 seems to be close to
            # the maximum that renderers support before breaking.
            'stroke-miterlimit': '100000'***REMOVED******REMOVED***
        writer.start('defs'***REMOVED***
        writer.start('style', type='text/css'***REMOVED***
        writer.data('*{%s***REMOVED***\n' % default_style***REMOVED***
        writer.end('style'***REMOVED***
        writer.end('defs'***REMOVED***

    def _make_id(self, type, content***REMOVED***:
        content = str(content***REMOVED***
        salt = str(uuid.uuid4(***REMOVED******REMOVED***
        if six.PY3:
            content = content.encode('utf8'***REMOVED***
            salt = salt.encode('utf8'***REMOVED***
        m = md5(***REMOVED***
        m.update(salt***REMOVED***
        m.update(content***REMOVED***
        return '%s%s' % (type, m.hexdigest(***REMOVED***[:10***REMOVED******REMOVED***

    def _make_flip_transform(self, transform***REMOVED***:
        return (transform +
                Affine2D(***REMOVED***
                .scale(1.0, -1.0***REMOVED***
                .translate(0.0, self.height***REMOVED******REMOVED***

    def _get_font(self, prop***REMOVED***:
        key = hash(prop***REMOVED***
        font = self.fontd.get(key***REMOVED***
        if font is None:
            fname = findfont(prop***REMOVED***
            font = self.fontd.get(fname***REMOVED***
            if font is None:
                font = FT2Font(fname***REMOVED***
                self.fontd[fname***REMOVED*** = font
            self.fontd[key***REMOVED*** = font
        font.clear(***REMOVED***
        size = prop.get_size_in_points(***REMOVED***
        font.set_size(size, 72.0***REMOVED***
        return font

    def _get_hatch(self, gc, rgbFace***REMOVED***:
        ***REMOVED***
        Create a new hatch pattern
        ***REMOVED***
        if rgbFace is not None:
            rgbFace = tuple(rgbFace***REMOVED***
        edge = gc.get_rgb(***REMOVED***
        if edge is not None:
            edge = tuple(edge***REMOVED***
        dictkey = (gc.get_hatch(***REMOVED***, rgbFace, edge***REMOVED***
        oid = self._hatchd.get(dictkey***REMOVED***
        if oid is None:
            oid = self._make_id('h', dictkey***REMOVED***
            self._hatchd[dictkey***REMOVED*** = ((gc.get_hatch_path(***REMOVED***, rgbFace, edge***REMOVED***, oid***REMOVED***
        else:
            _, oid = oid
        return oid

    def _write_hatches(self***REMOVED***:
        if not len(self._hatchd***REMOVED***:
            return
        HATCH_SIZE = 72
        writer = self.writer
        writer.start('defs'***REMOVED***
        for ((path, face, stroke***REMOVED***, oid***REMOVED*** in six.itervalues(self._hatchd***REMOVED***:
            writer.start(
                'pattern',
                id=oid,
                patternUnits="userSpaceOnUse",
                x="0", y="0", width=six.text_type(HATCH_SIZE***REMOVED***,
                height=six.text_type(HATCH_SIZE***REMOVED******REMOVED***
            path_data = self._convert_path(
                path,
                Affine2D(***REMOVED***.scale(HATCH_SIZE***REMOVED***.scale(1.0, -1.0***REMOVED***.translate(0, HATCH_SIZE***REMOVED***,
                simplify=False***REMOVED***
            if face is None:
                fill = 'none'
            else:
                fill = rgb2hex(face***REMOVED***
            writer.element(
                'rect',
                x="0", y="0", width=six.text_type(HATCH_SIZE+1***REMOVED***,
                height=six.text_type(HATCH_SIZE+1***REMOVED***,
                fill=fill***REMOVED***
            writer.element(
                'path',
                d=path_data,
                style=generate_css({
                    'fill': rgb2hex(stroke***REMOVED***,
                    'stroke': rgb2hex(stroke***REMOVED***,
                    'stroke-width': '1.0',
                    'stroke-linecap': 'butt',
                    'stroke-linejoin': 'miter'
                ***REMOVED******REMOVED***
                ***REMOVED***
            writer.end('pattern'***REMOVED***
        writer.end('defs'***REMOVED***

    def _get_style_dict(self, gc, rgbFace***REMOVED***:
        ***REMOVED***
        return the style string.  style is generated from the
        GraphicsContext and rgbFace
        ***REMOVED***
        attrib = {***REMOVED***

        forced_alpha = gc.get_forced_alpha(***REMOVED***

        if gc.get_hatch(***REMOVED*** is not None:
            attrib['fill'***REMOVED*** = "url(#%s***REMOVED***" % self._get_hatch(gc, rgbFace***REMOVED***
            if rgbFace is not None and len(rgbFace***REMOVED*** == 4 and rgbFace[3***REMOVED*** != 1.0 and not forced_alpha:
                attrib['fill-opacity'***REMOVED*** = str(rgbFace[3***REMOVED******REMOVED***
        else:
            if rgbFace is None:
                attrib['fill'***REMOVED*** = 'none'
            else:
                if tuple(rgbFace[:3***REMOVED******REMOVED*** != (0, 0, 0***REMOVED***:
                    attrib['fill'***REMOVED*** = rgb2hex(rgbFace***REMOVED***
                if len(rgbFace***REMOVED*** == 4 and rgbFace[3***REMOVED*** != 1.0 and not forced_alpha:
                    attrib['fill-opacity'***REMOVED*** = str(rgbFace[3***REMOVED******REMOVED***

        if forced_alpha and gc.get_alpha(***REMOVED*** != 1.0:
            attrib['opacity'***REMOVED*** = str(gc.get_alpha(***REMOVED******REMOVED***

        offset, seq = gc.get_dashes(***REMOVED***
        if seq is not None:
            attrib['stroke-dasharray'***REMOVED*** = ','.join(['%f' % val for val in seq***REMOVED******REMOVED***
            attrib['stroke-dashoffset'***REMOVED*** = six.text_type(float(offset***REMOVED******REMOVED***

        linewidth = gc.get_linewidth(***REMOVED***
        if linewidth:
            rgb = gc.get_rgb(***REMOVED***
            attrib['stroke'***REMOVED*** = rgb2hex(rgb***REMOVED***
            if not forced_alpha and rgb[3***REMOVED*** != 1.0:
                attrib['stroke-opacity'***REMOVED*** = str(rgb[3***REMOVED******REMOVED***
            if linewidth != 1.0:
                attrib['stroke-width'***REMOVED*** = str(linewidth***REMOVED***
            if gc.get_joinstyle(***REMOVED*** != 'round':
                attrib['stroke-linejoin'***REMOVED*** = gc.get_joinstyle(***REMOVED***
            if gc.get_capstyle(***REMOVED*** != 'butt':
                attrib['stroke-linecap'***REMOVED*** = _capstyle_d[gc.get_capstyle(***REMOVED******REMOVED***

        return attrib

    def _get_style(self, gc, rgbFace***REMOVED***:
        return generate_css(self._get_style_dict(gc, rgbFace***REMOVED******REMOVED***

    def _get_clip(self, gc***REMOVED***:
        cliprect = gc.get_clip_rectangle(***REMOVED***
        clippath, clippath_trans = gc.get_clip_path(***REMOVED***
        if clippath is not None:
            clippath_trans = self._make_flip_transform(clippath_trans***REMOVED***
            dictkey = (id(clippath***REMOVED***, str(clippath_trans***REMOVED******REMOVED***
        elif cliprect is not None:
            x, y, w, h = cliprect.bounds
            y = self.height-(y+h***REMOVED***
            dictkey = (x, y, w, h***REMOVED***
        else:
            return None

        clip = self._clipd.get(dictkey***REMOVED***
        if clip is None:
            oid = self._make_id('p', dictkey***REMOVED***
            if clippath is not None:
                self._clipd[dictkey***REMOVED*** = ((clippath, clippath_trans***REMOVED***, oid***REMOVED***
            else:
                self._clipd[dictkey***REMOVED*** = (dictkey, oid***REMOVED***
        else:
            clip, oid = clip
        return oid

    def _write_clips(self***REMOVED***:
        if not len(self._clipd***REMOVED***:
            return
        writer = self.writer
        writer.start('defs'***REMOVED***
        for clip, oid in six.itervalues(self._clipd***REMOVED***:
            writer.start('clipPath', id=oid***REMOVED***
            if len(clip***REMOVED*** == 2:
                clippath, clippath_trans = clip
                path_data = self._convert_path(clippath, clippath_trans, simplify=False***REMOVED***
                writer.element('path', d=path_data***REMOVED***
            else:
                x, y, w, h = clip
                writer.element('rect', x=six.text_type(x***REMOVED***, y=six.text_type(y***REMOVED***,
                               width=six.text_type(w***REMOVED***, height=six.text_type(h***REMOVED******REMOVED***
            writer.end('clipPath'***REMOVED***
        writer.end('defs'***REMOVED***

    def _write_svgfonts(self***REMOVED***:
        if not rcParams['svg.fonttype'***REMOVED*** == 'svgfont':
            return

        writer = self.writer
        writer.start('defs'***REMOVED***
        for font_fname, chars in six.iteritems(self._fonts***REMOVED***:
            font = FT2Font(font_fname***REMOVED***
            font.set_size(72, 72***REMOVED***
            sfnt = font.get_sfnt(***REMOVED***
            writer.start('font', id=sfnt[(1, 0, 0, 4***REMOVED******REMOVED******REMOVED***
            writer.element(
                'font-face',
                attrib={
                    'font-family': font.family_name,
                    'font-style': font.style_name.lower(***REMOVED***,
                    'units-per-em': '72',
                    'bbox': ' '.join(six.text_type(x / 64.0***REMOVED*** for x in font.bbox***REMOVED******REMOVED******REMOVED***
            for char in chars:
                glyph = font.load_char(char, flags=LOAD_NO_HINTING***REMOVED***
                verts, codes = font.get_path(***REMOVED***
                path = Path(verts, codes***REMOVED***
                path_data = self._convert_path(path***REMOVED***
                # name = font.get_glyph_name(char***REMOVED***
                writer.element(
                    'glyph',
                    d=path_data,
                    attrib={
                        # 'glyph-name': name,
                        'unicode': unichr(char***REMOVED***,
                        'horiz-adv-x': six.text_type(glyph.linearHoriAdvance / 65536.0***REMOVED******REMOVED******REMOVED***
            writer.end('font'***REMOVED***
        writer.end('defs'***REMOVED***

    def open_group(self, s, gid=None***REMOVED***:
        ***REMOVED***
        Open a grouping element with label *s*. If *gid* is given, use
        *gid* as the id of the group.
        ***REMOVED***
        if gid:
            self.writer.start('g', id=gid***REMOVED***
        else:
            self._groupd[s***REMOVED*** = self._groupd.get(s, 0***REMOVED*** + 1
            self.writer.start('g', id="%s_%d" % (s, self._groupd[s***REMOVED******REMOVED******REMOVED***

    def close_group(self, s***REMOVED***:
        self.writer.end('g'***REMOVED***

    def option_image_nocomposite(self***REMOVED***:
        ***REMOVED***
        return whether to generate a composite image from multiple images on
        a set of axes
        ***REMOVED***
        if rcParams['svg.image_noscale'***REMOVED***:
            return True
        else:
            return not rcParams['image.composite_image'***REMOVED***

    def _convert_path(self, path, transform=None, clip=None, simplify=None,
                      sketch=None***REMOVED***:
        if clip:
            clip = (0.0, 0.0, self.width, self.height***REMOVED***
        else:
            clip = None
        return _path.convert_to_string(
            path, transform, clip, simplify, sketch, 6,
            [b'M', b'L', b'Q', b'C', b'z'***REMOVED***, False***REMOVED***.decode('ascii'***REMOVED***

    def draw_path(self, gc, path, transform, rgbFace=None***REMOVED***:
        trans_and_flip = self._make_flip_transform(transform***REMOVED***
        clip = (rgbFace is None and gc.get_hatch_path(***REMOVED*** is None***REMOVED***
        simplify = path.should_simplify and clip
        path_data = self._convert_path(
            path, trans_and_flip, clip=clip, simplify=simplify,
            sketch=gc.get_sketch_params(***REMOVED******REMOVED***

        attrib = {***REMOVED***
        attrib['style'***REMOVED*** = self._get_style(gc, rgbFace***REMOVED***

        clipid = self._get_clip(gc***REMOVED***
        if clipid is not None:
            attrib['clip-path'***REMOVED*** = 'url(#%s***REMOVED***' % clipid

        if gc.get_url(***REMOVED*** is not None:
            self.writer.start('a', {'xlink:href': gc.get_url(***REMOVED******REMOVED******REMOVED***
        self.writer.element('path', d=path_data, attrib=attrib***REMOVED***
        if gc.get_url(***REMOVED*** is not None:
            self.writer.end('a'***REMOVED***

    def draw_markers(self, gc, marker_path, marker_trans, path, trans, rgbFace=None***REMOVED***:
        if not len(path.vertices***REMOVED***:
            return

        writer = self.writer
        path_data = self._convert_path(
            marker_path,
            marker_trans + Affine2D(***REMOVED***.scale(1.0, -1.0***REMOVED***,
            simplify=False***REMOVED***
        style = self._get_style_dict(gc, rgbFace***REMOVED***
        dictkey = (path_data, generate_css(style***REMOVED******REMOVED***
        oid = self._markers.get(dictkey***REMOVED***
        for key in list(six.iterkeys(style***REMOVED******REMOVED***:
            if not key.startswith('stroke'***REMOVED***:
                del style[key***REMOVED***
        style = generate_css(style***REMOVED***

        if oid is None:
            oid = self._make_id('m', dictkey***REMOVED***
            writer.start('defs'***REMOVED***
            writer.element('path', id=oid, d=path_data, style=style***REMOVED***
            writer.end('defs'***REMOVED***
            self._markers[dictkey***REMOVED*** = oid

        attrib = {***REMOVED***
        clipid = self._get_clip(gc***REMOVED***
        if clipid is not None:
            attrib['clip-path'***REMOVED*** = 'url(#%s***REMOVED***' % clipid
        writer.start('g', attrib=attrib***REMOVED***

        trans_and_flip = self._make_flip_transform(trans***REMOVED***
        attrib = {'xlink:href': '#%s' % oid***REMOVED***
        clip = (0, 0, self.width*72, self.height*72***REMOVED***
        for vertices, code in path.iter_segments(
                trans_and_flip, clip=clip, simplify=False***REMOVED***:
            if len(vertices***REMOVED***:
                x, y = vertices[-2:***REMOVED***
                attrib['x'***REMOVED*** = six.text_type(x***REMOVED***
                attrib['y'***REMOVED*** = six.text_type(y***REMOVED***
                attrib['style'***REMOVED*** = self._get_style(gc, rgbFace***REMOVED***
                writer.element('use', attrib=attrib***REMOVED***
        writer.end('g'***REMOVED***

    def draw_path_collection(self, gc, master_transform, paths, all_transforms,
                             offsets, offsetTrans, facecolors, edgecolors,
                             linewidths, linestyles, antialiaseds, urls,
                             offset_position***REMOVED***:
        # Is the optimization worth it? Rough calculation:
        # cost of emitting a path in-line is
        #    (len_path + 5***REMOVED*** * uses_per_path
        # cost of definition+use is
        #    (len_path + 3***REMOVED*** + 9 * uses_per_path
        len_path = len(paths[0***REMOVED***.vertices***REMOVED*** if len(paths***REMOVED*** > 0 else 0
        uses_per_path = self._iter_collection_uses_per_path(
            paths, all_transforms, offsets, facecolors, edgecolors***REMOVED***
        should_do_optimization = \
            len_path + 9 * uses_per_path + 3 < (len_path + 5***REMOVED*** * uses_per_path
        if not should_do_optimization:
            return RendererBase.draw_path_collection(
                self, gc, master_transform, paths, all_transforms,
                offsets, offsetTrans, facecolors, edgecolors,
                linewidths, linestyles, antialiaseds, urls,
                offset_position***REMOVED***

        writer = self.writer
        path_codes = [***REMOVED***
        writer.start('defs'***REMOVED***
        for i, (path, transform***REMOVED*** in enumerate(self._iter_collection_raw_paths(
            master_transform, paths, all_transforms***REMOVED******REMOVED***:
            transform = Affine2D(transform.get_matrix(***REMOVED******REMOVED***.scale(1.0, -1.0***REMOVED***
            d = self._convert_path(path, transform, simplify=False***REMOVED***
            oid = 'C%x_%x_%s' % (self._path_collection_id, i,
                                  self._make_id('', d***REMOVED******REMOVED***
            writer.element('path', id=oid, d=d***REMOVED***
            path_codes.append(oid***REMOVED***
        writer.end('defs'***REMOVED***

        for xo, yo, path_id, gc0, rgbFace in self._iter_collection(
            gc, master_transform, all_transforms, path_codes, offsets,
            offsetTrans, facecolors, edgecolors, linewidths, linestyles,
            antialiaseds, urls, offset_position***REMOVED***:
            clipid = self._get_clip(gc0***REMOVED***
            url = gc0.get_url(***REMOVED***
            if url is not None:
                writer.start('a', attrib={'xlink:href': url***REMOVED******REMOVED***
            if clipid is not None:
                writer.start('g', attrib={'clip-path': 'url(#%s***REMOVED***' % clipid***REMOVED******REMOVED***
            attrib = {
                'xlink:href': '#%s' % path_id,
                'x': six.text_type(xo***REMOVED***,
                'y': six.text_type(self.height - yo***REMOVED***,
                'style': self._get_style(gc0, rgbFace***REMOVED***
            ***REMOVED***
            writer.element('use', attrib=attrib***REMOVED***
            if clipid is not None:
                writer.end('g'***REMOVED***
            if url is not None:
                writer.end('a'***REMOVED***

        self._path_collection_id += 1

    def draw_gouraud_triangle(self, gc, points, colors, trans***REMOVED***:
        # This uses a method described here:
        #
        #   http://www.svgopen.org/2005/papers/Converting3DFaceToSVG/index.html
        #
        # that uses three overlapping linear gradients to simulate a
        # Gouraud triangle.  Each gradient goes from fully opaque in
        # one corner to fully transparent along the opposite edge.
        # The line between the stop points is perpendicular to the
        # opposite edge.  Underlying these three gradients is a solid
        # triangle whose color is the average of all three points.

        writer = self.writer
        if not self._has_gouraud:
            self._has_gouraud = True
            writer.start(
                'filter',
                id='colorAdd'***REMOVED***
            writer.element(
                'feComposite',
                attrib={'in': 'SourceGraphic'***REMOVED***,
                in2='BackgroundImage',
                operator='arithmetic',
                k2="1", k3="1"***REMOVED***
            writer.end('filter'***REMOVED***

        avg_color = np.sum(colors[:, :***REMOVED***, axis=0***REMOVED*** / 3.0
        # Just skip fully-transparent triangles
        if avg_color[-1***REMOVED*** == 0.0:
            return

        trans_and_flip = self._make_flip_transform(trans***REMOVED***
        tpoints = trans_and_flip.transform(points***REMOVED***

        writer.start('defs'***REMOVED***
        for i in range(3***REMOVED***:
            x1, y1 = tpoints[i***REMOVED***
            x2, y2 = tpoints[(i + 1***REMOVED*** % 3***REMOVED***
            x3, y3 = tpoints[(i + 2***REMOVED*** % 3***REMOVED***
            c = colors[i***REMOVED***[:***REMOVED***

            if x2 == x3:
                xb = x2
                yb = y1
            elif y2 == y3:
                xb = x1
                yb = y2
            else:
                m1 = (y2 - y3***REMOVED*** / (x2 - x3***REMOVED***
                b1 = y2 - (m1 * x2***REMOVED***
                m2 = -(1.0 / m1***REMOVED***
                b2 = y1 - (m2 * x1***REMOVED***
                xb = (-b1 + b2***REMOVED*** / (m1 - m2***REMOVED***
                yb = m2 * xb + b2

            writer.start(
                'linearGradient',
                id="GR%x_%d" % (self._n_gradients, i***REMOVED***,
                x1=six.text_type(x1***REMOVED***, y1=six.text_type(y1***REMOVED***,
                x2=six.text_type(xb***REMOVED***, y2=six.text_type(yb***REMOVED******REMOVED***
            writer.element(
                'stop',
                offset='0',
                style=generate_css({'stop-color': rgb2hex(c***REMOVED***,
                                    'stop-opacity': six.text_type(c[-1***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***
            writer.element(
                'stop',
                offset='1',
                style=generate_css({'stop-color': rgb2hex(c***REMOVED***,
                                    'stop-opacity': "0"***REMOVED******REMOVED******REMOVED***
            writer.end('linearGradient'***REMOVED***

        writer.element(
            'polygon',
            id='GT%x' % self._n_gradients,
            points=" ".join([six.text_type(x***REMOVED***
                             for x in (x1, y1, x2, y2, x3, y3***REMOVED******REMOVED******REMOVED******REMOVED***
        writer.end('defs'***REMOVED***

        avg_color = np.sum(colors[:, :***REMOVED***, axis=0***REMOVED*** / 3.0
        href = '#GT%x' % self._n_gradients
        writer.element(
            'use',
            attrib={'xlink:href': href,
                    'fill': rgb2hex(avg_color***REMOVED***,
                    'fill-opacity': str(avg_color[-1***REMOVED******REMOVED******REMOVED******REMOVED***
        for i in range(3***REMOVED***:
            writer.element(
                'use',
                attrib={'xlink:href': href,
                        'fill': 'url(#GR%x_%d***REMOVED***' % (self._n_gradients, i***REMOVED***,
                        'fill-opacity': '1',
                        'filter': 'url(#colorAdd***REMOVED***'***REMOVED******REMOVED***

        self._n_gradients += 1

    def draw_gouraud_triangles(self, gc, triangles_array, colors_array,
                               transform***REMOVED***:
        attrib = {***REMOVED***
        clipid = self._get_clip(gc***REMOVED***
        if clipid is not None:
            attrib['clip-path'***REMOVED*** = 'url(#%s***REMOVED***' % clipid

        self.writer.start('g', attrib=attrib***REMOVED***

        transform = transform.frozen(***REMOVED***
        for tri, col in zip(triangles_array, colors_array***REMOVED***:
            self.draw_gouraud_triangle(gc, tri, col, transform***REMOVED***

        self.writer.end('g'***REMOVED***

    def option_scale_image(self***REMOVED***:
        return True

    def get_image_magnification(self***REMOVED***:
        return self.image_dpi / 72.0

    def draw_image(self, gc, x, y, im, dx=None, dy=None, transform=None***REMOVED***:
        attrib = {***REMOVED***
        clipid = self._get_clip(gc***REMOVED***
        if clipid is not None:
            # Can't apply clip-path directly to the image because the
            # image has a transformation, which would also be applied
            # to the clip-path
            self.writer.start('g', attrib={'clip-path': 'url(#%s***REMOVED***' % clipid***REMOVED******REMOVED***

        trans = [1,0,0,1,0,0***REMOVED***
        if rcParams['svg.image_noscale'***REMOVED***:
            trans = list(im.get_matrix(***REMOVED******REMOVED***
            trans[5***REMOVED*** = -trans[5***REMOVED***
            attrib['transform'***REMOVED*** = generate_transform([('matrix', tuple(trans***REMOVED******REMOVED******REMOVED******REMOVED***
            assert trans[1***REMOVED*** == 0
            assert trans[2***REMOVED*** == 0
            numrows, numcols = im.get_size(***REMOVED***
            im.reset_matrix(***REMOVED***
            im.set_interpolation(0***REMOVED***
            im.resize(numcols, numrows***REMOVED***

        h,w = im.get_size_out(***REMOVED***

        if dx is None:
            w = 72.0*w/self.image_dpi
        else:
            w = dx

        if dy is None:
            h = 72.0*h/self.image_dpi
        else:
            h = dy

        oid = getattr(im, '_gid', None***REMOVED***
        url = getattr(im, '_url', None***REMOVED***
        if url is not None:
            self.writer.start('a', attrib={'xlink:href': url***REMOVED******REMOVED***
        if rcParams['svg.image_inline'***REMOVED***:
            bytesio = io.BytesIO(***REMOVED***
            _png.write_png(np.array(im***REMOVED***[::-1***REMOVED***, bytesio***REMOVED***
            oid = oid or self._make_id('image', bytesio***REMOVED***
            attrib['xlink:href'***REMOVED*** = (
                "data:image/png;base64,\n" +
                base64.b64encode(bytesio.getvalue(***REMOVED******REMOVED***.decode('ascii'***REMOVED******REMOVED***
        else:
            self._imaged[self.basename***REMOVED*** = self._imaged.get(self.basename,0***REMOVED*** + 1
            filename = '%s.image%d.png'%(self.basename, self._imaged[self.basename***REMOVED******REMOVED***
            verbose.report( 'Writing image file for inclusion: %s' % filename***REMOVED***
            _png.write_png(np.array(im***REMOVED***[::-1***REMOVED***, filename***REMOVED***
            oid = oid or 'Im_' + self._make_id('image', filename***REMOVED***
            attrib['xlink:href'***REMOVED*** = filename

        alpha = gc.get_alpha(***REMOVED***
        if alpha != 1.0:
            attrib['opacity'***REMOVED*** = str(alpha***REMOVED***

        attrib['id'***REMOVED*** = oid

        if transform is None:
            self.writer.element(
                'image',
                x=six.text_type(x/trans[0***REMOVED******REMOVED***,
                y=six.text_type((self.height-y***REMOVED***/trans[3***REMOVED***-h***REMOVED***,
                width=six.text_type(w***REMOVED***, height=six.text_type(h***REMOVED***,
                attrib=attrib***REMOVED***
        else:
            flipped = self._make_flip_transform(transform***REMOVED***
            flipped = np.array(flipped.to_values(***REMOVED******REMOVED***
            y = y+dy
            if dy > 0.0:
                flipped[3***REMOVED*** *= -1.0
                y *= -1.0
            attrib['transform'***REMOVED*** = generate_transform(
                [('matrix', flipped***REMOVED******REMOVED******REMOVED***
            self.writer.element(
                'image',
                x=six.text_type(x***REMOVED***, y=six.text_type(y***REMOVED***,
                width=six.text_type(dx***REMOVED***, height=six.text_type(abs(dy***REMOVED******REMOVED***,
                attrib=attrib***REMOVED***

        if url is not None:
            self.writer.end('a'***REMOVED***
        if clipid is not None:
            self.writer.end('g'***REMOVED***

    def _adjust_char_id(self, char_id***REMOVED***:
        return char_id.replace("%20", "_"***REMOVED***

    def _draw_text_as_path(self, gc, x, y, s, prop, angle, ismath, mtext=None***REMOVED***:
        ***REMOVED***
        draw the text by converting them to paths using textpath module.

        *prop*
          font property

        *s*
          text to be converted

        *usetex*
          If True, use matplotlib usetex mode.

        *ismath*
          If True, use mathtext parser. If "TeX", use *usetex* mode.
        ***REMOVED***
        writer = self.writer

        writer.comment(s***REMOVED***

        glyph_map=self._glyph_map

        text2path = self._text2path
        color = rgb2hex(gc.get_rgb(***REMOVED******REMOVED***
        fontsize = prop.get_size_in_points(***REMOVED***

        style = {***REMOVED***
        if color != '#000000':
            style['fill'***REMOVED*** = color
        if gc.get_alpha(***REMOVED*** != 1.0:
            style['opacity'***REMOVED*** = six.text_type(gc.get_alpha(***REMOVED******REMOVED***

        if not ismath:
            font = text2path._get_font(prop***REMOVED***
            _glyphs = text2path.get_glyphs_with_font(
                font, s, glyph_map=glyph_map, return_new_glyphs_only=True***REMOVED***
            glyph_info, glyph_map_new, rects = _glyphs

            if glyph_map_new:
                writer.start('defs'***REMOVED***
                for char_id, glyph_path in six.iteritems(glyph_map_new***REMOVED***:
                    path = Path(*glyph_path***REMOVED***
                    path_data = self._convert_path(path, simplify=False***REMOVED***
                    writer.element('path', id=char_id, d=path_data***REMOVED***
                writer.end('defs'***REMOVED***

                glyph_map.update(glyph_map_new***REMOVED***

            attrib = {***REMOVED***
            attrib['style'***REMOVED*** = generate_css(style***REMOVED***
            font_scale = fontsize / text2path.FONT_SCALE
            attrib['transform'***REMOVED*** = generate_transform([
                ('translate', (x, y***REMOVED******REMOVED***,
                ('rotate', (-angle,***REMOVED******REMOVED***,
                ('scale', (font_scale, -font_scale***REMOVED******REMOVED******REMOVED******REMOVED***

            writer.start('g', attrib=attrib***REMOVED***
            for glyph_id, xposition, yposition, scale in glyph_info:
                attrib={'xlink:href': '#%s' % glyph_id***REMOVED***
                if xposition != 0.0:
                    attrib['x'***REMOVED*** = six.text_type(xposition***REMOVED***
                if yposition != 0.0:
                    attrib['y'***REMOVED*** = six.text_type(yposition***REMOVED***
                writer.element(
                    'use',
                    attrib=attrib***REMOVED***

            writer.end('g'***REMOVED***
        else:
            if ismath == "TeX":
                _glyphs = text2path.get_glyphs_tex(prop, s, glyph_map=glyph_map,
                                                   return_new_glyphs_only=True***REMOVED***
            else:
                _glyphs = text2path.get_glyphs_mathtext(prop, s, glyph_map=glyph_map,
                                                        return_new_glyphs_only=True***REMOVED***

            glyph_info, glyph_map_new, rects = _glyphs

            # we store the character glyphs w/o flipping. Instead, the
            # coordinate will be flipped when this characters are
            # used.
            if glyph_map_new:
                writer.start('defs'***REMOVED***
                for char_id, glyph_path in six.iteritems(glyph_map_new***REMOVED***:
                    char_id = self._adjust_char_id(char_id***REMOVED***
                    # Some characters are blank
                    if not len(glyph_path[0***REMOVED******REMOVED***:
                        path_data = ""
                    else:
                        path = Path(*glyph_path***REMOVED***
                        path_data = self._convert_path(path, simplify=False***REMOVED***
                    writer.element('path', id=char_id, d=path_data***REMOVED***
                writer.end('defs'***REMOVED***

                glyph_map.update(glyph_map_new***REMOVED***

            attrib = {***REMOVED***
            font_scale = fontsize / text2path.FONT_SCALE
            attrib['style'***REMOVED*** = generate_css(style***REMOVED***
            attrib['transform'***REMOVED*** = generate_transform([
                ('translate', (x, y***REMOVED******REMOVED***,
                ('rotate', (-angle,***REMOVED******REMOVED***,
                ('scale', (font_scale, -font_scale***REMOVED******REMOVED******REMOVED******REMOVED***

            writer.start('g', attrib=attrib***REMOVED***
            for char_id, xposition, yposition, scale in glyph_info:
                char_id = self._adjust_char_id(char_id***REMOVED***

                writer.element(
                    'use',
                    transform=generate_transform([
                        ('translate', (xposition, yposition***REMOVED******REMOVED***,
                        ('scale', (scale,***REMOVED******REMOVED***,
                        ***REMOVED******REMOVED***,
                    attrib={'xlink:href': '#%s' % char_id***REMOVED******REMOVED***

            for verts, codes in rects:
                path = Path(verts, codes***REMOVED***
                path_data = self._convert_path(path, simplify=False***REMOVED***
                writer.element('path', d=path_data***REMOVED***

            writer.end('g'***REMOVED***

    def _draw_text_as_text(self, gc, x, y, s, prop, angle, ismath, mtext=None***REMOVED***:
        writer = self.writer

        color = rgb2hex(gc.get_rgb(***REMOVED******REMOVED***
        style = {***REMOVED***
        if color != '#000000':
            style['fill'***REMOVED*** = color
        if gc.get_alpha(***REMOVED*** != 1.0:
            style['opacity'***REMOVED*** = six.text_type(gc.get_alpha(***REMOVED******REMOVED***

        if not ismath:
            font = self._get_font(prop***REMOVED***
            font.set_text(s, 0.0, flags=LOAD_NO_HINTING***REMOVED***

            fontsize = prop.get_size_in_points(***REMOVED***

            fontfamily = font.family_name
            fontstyle = prop.get_style(***REMOVED***

            attrib = {***REMOVED***
            # Must add "px" to workaround a Firefox bug
            style['font-size'***REMOVED*** = six.text_type(fontsize***REMOVED*** + 'px'
            style['font-family'***REMOVED*** = six.text_type(fontfamily***REMOVED***
            style['font-style'***REMOVED*** = prop.get_style(***REMOVED***.lower(***REMOVED***
            style['font-weight'***REMOVED*** = six.text_type(prop.get_weight(***REMOVED******REMOVED***.lower(***REMOVED***
            attrib['style'***REMOVED*** = generate_css(style***REMOVED***

            if mtext and (angle == 0 or mtext.get_rotation_mode(***REMOVED*** == "anchor"***REMOVED***:
                # If text anchoring can be supported, get the original
                # coordinates and add alignment information.

                # Get anchor coordinates.
                transform = mtext.get_transform(***REMOVED***
                ax, ay = transform.transform_point(mtext.get_position(***REMOVED******REMOVED***
                ay = self.height - ay

                # Don't do vertical anchor alignment. Most applications do not
                # support 'alignment-baseline' yet. Apply the vertical layout
                # to the anchor point manually for now.
                angle_rad = angle * np.pi / 180.
                dir_vert = np.array([np.sin(angle_rad***REMOVED***, np.cos(angle_rad***REMOVED******REMOVED******REMOVED***
                v_offset = np.dot(dir_vert, [(x - ax***REMOVED***, (y - ay***REMOVED******REMOVED******REMOVED***
                ax = ax + v_offset * dir_vert[0***REMOVED***
                ay = ay + v_offset * dir_vert[1***REMOVED***

                ha_mpl_to_svg = {'left': 'start', 'right': 'end',
                                 'center': 'middle'***REMOVED***
                style['text-anchor'***REMOVED*** = ha_mpl_to_svg[mtext.get_ha(***REMOVED******REMOVED***

                attrib['x'***REMOVED*** = str(ax***REMOVED***
                attrib['y'***REMOVED*** = str(ay***REMOVED***
                attrib['style'***REMOVED*** = generate_css(style***REMOVED***
                attrib['transform'***REMOVED*** = "rotate(%f, %f, %f***REMOVED***" % (-angle, ax, ay***REMOVED***
                writer.element('text', s, attrib=attrib***REMOVED***
            else:
                attrib['transform'***REMOVED*** = generate_transform([
                    ('translate', (x, y***REMOVED******REMOVED***,
                    ('rotate', (-angle,***REMOVED******REMOVED******REMOVED******REMOVED***

                writer.element('text', s, attrib=attrib***REMOVED***

            if rcParams['svg.fonttype'***REMOVED*** == 'svgfont':
                fontset = self._fonts.setdefault(font.fname, set(***REMOVED******REMOVED***
                for c in s:
                    fontset.add(ord(c***REMOVED******REMOVED***
        else:
            writer.comment(s***REMOVED***

            width, height, descent, svg_elements, used_characters = \
                   self.mathtext_parser.parse(s, 72, prop***REMOVED***
            svg_glyphs = svg_elements.svg_glyphs
            svg_rects = svg_elements.svg_rects

            attrib = {***REMOVED***
            attrib['style'***REMOVED*** = generate_css(style***REMOVED***
            attrib['transform'***REMOVED*** = generate_transform([
                ('translate', (x, y***REMOVED******REMOVED***,
                ('rotate', (-angle,***REMOVED******REMOVED******REMOVED******REMOVED***

            # Apply attributes to 'g', not 'text', because we likely
            # have some rectangles as well with the same style and
            # transformation
            writer.start('g', attrib=attrib***REMOVED***

            writer.start('text'***REMOVED***

            # Sort the characters by font, and output one tspan for
            # each
            spans = {***REMOVED***
            for font, fontsize, thetext, new_x, new_y, metrics in svg_glyphs:
                style = generate_css({
                    'font-size': six.text_type(fontsize***REMOVED*** + 'px',
                    'font-family': font.family_name,
                    'font-style': font.style_name.lower(***REMOVED***,
                    'font-weight': font.style_name.lower(***REMOVED******REMOVED******REMOVED***
                if thetext == 32:
                    thetext = 0xa0 # non-breaking space
                spans.setdefault(style, [***REMOVED******REMOVED***.append((new_x, -new_y, thetext***REMOVED******REMOVED***

            if rcParams['svg.fonttype'***REMOVED*** == 'svgfont':
                for font, fontsize, thetext, new_x, new_y, metrics in svg_glyphs:
                    fontset = self._fonts.setdefault(font.fname, set(***REMOVED******REMOVED***
                    fontset.add(thetext***REMOVED***

            for style, chars in list(six.iteritems(spans***REMOVED******REMOVED***:
                chars.sort(***REMOVED***

                same_y = True
                if len(chars***REMOVED*** > 1:
                    last_y = chars[0***REMOVED***[1***REMOVED***
                    for i in xrange(1, len(chars***REMOVED******REMOVED***:
                        if chars[i***REMOVED***[1***REMOVED*** != last_y:
                            same_y = False
                            break
                if same_y:
                    ys = six.text_type(chars[0***REMOVED***[1***REMOVED******REMOVED***
                else:
                    ys = ' '.join(six.text_type(c[1***REMOVED******REMOVED*** for c in chars***REMOVED***

                attrib = {
                    'style': style,
                    'x': ' '.join(six.text_type(c[0***REMOVED******REMOVED*** for c in chars***REMOVED***,
                    'y': ys
                ***REMOVED***

                writer.element(
                    'tspan',
                    ''.join(unichr(c[2***REMOVED******REMOVED*** for c in chars***REMOVED***,
                    attrib=attrib***REMOVED***

            writer.end('text'***REMOVED***

            if len(svg_rects***REMOVED***:
                for x, y, width, height in svg_rects:
                    writer.element(
                        'rect',
                        x=six.text_type(x***REMOVED***, y=six.text_type(-y + height***REMOVED***,
                        width=six.text_type(width***REMOVED***, height=six.text_type(height***REMOVED***
                        ***REMOVED***

            writer.end('g'***REMOVED***

    def draw_tex(self, gc, x, y, s, prop, angle, ismath='TeX!', mtext=None***REMOVED***:
        self._draw_text_as_path(gc, x, y, s, prop, angle, ismath="TeX"***REMOVED***

    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None***REMOVED***:
        clipid = self._get_clip(gc***REMOVED***
        if clipid is not None:
            # Cannot apply clip-path directly to the text, because
            # is has a transformation
            self.writer.start(
                'g', attrib={'clip-path': 'url(#%s***REMOVED***' % clipid***REMOVED******REMOVED***

        if gc.get_url(***REMOVED*** is not None:
            self.writer.start('a', {'xlink:href': gc.get_url(***REMOVED******REMOVED******REMOVED***

        if rcParams['svg.fonttype'***REMOVED*** == 'path':
            self._draw_text_as_path(gc, x, y, s, prop, angle, ismath, mtext***REMOVED***
        else:
            self._draw_text_as_text(gc, x, y, s, prop, angle, ismath, mtext***REMOVED***

        if gc.get_url(***REMOVED*** is not None:
            self.writer.end('a'***REMOVED***

        if clipid is not None:
            self.writer.end('g'***REMOVED***

    def flipy(self***REMOVED***:
        return True

    def get_canvas_width_height(self***REMOVED***:
        return self.width, self.height

    def get_text_width_height_descent(self, s, prop, ismath***REMOVED***:
        return self._text2path.get_text_width_height_descent(s, prop, ismath***REMOVED***


class FigureCanvasSVG(FigureCanvasBase***REMOVED***:
    filetypes = {'svg': 'Scalable Vector Graphics',
                 'svgz': 'Scalable Vector Graphics'***REMOVED***

    fixed_dpi = 72

    def print_svg(self, filename, *args, **kwargs***REMOVED***:
        if is_string_like(filename***REMOVED***:
            fh_to_close = svgwriter = io.open(filename, 'w', encoding='utf-8'***REMOVED***
        elif is_writable_file_like(filename***REMOVED***:
            if not isinstance(filename, io.TextIOBase***REMOVED***:
                if six.PY3:
                    svgwriter = io.TextIOWrapper(filename, 'utf-8'***REMOVED***
                else:
                    svgwriter = codecs.getwriter('utf-8'***REMOVED***(filename***REMOVED***
            else:
                svgwriter = filename
            fh_to_close = None
        else:
            raise ValueError("filename must be a path or a file-like object"***REMOVED***
        return self._print_svg(filename, svgwriter, fh_to_close, **kwargs***REMOVED***

    def print_svgz(self, filename, *args, **kwargs***REMOVED***:
        if is_string_like(filename***REMOVED***:
            fh_to_close = gzipwriter = gzip.GzipFile(filename, 'w'***REMOVED***
            svgwriter = io.TextIOWrapper(gzipwriter, 'utf-8'***REMOVED***
        elif is_writable_file_like(filename***REMOVED***:
            fh_to_close = gzipwriter = gzip.GzipFile(fileobj=filename, mode='w'***REMOVED***
            svgwriter = io.TextIOWrapper(gzipwriter, 'utf-8'***REMOVED***
        else:
            raise ValueError("filename must be a path or a file-like object"***REMOVED***
        return self._print_svg(filename, svgwriter, fh_to_close***REMOVED***

    def _print_svg(self, filename, svgwriter, fh_to_close=None, **kwargs***REMOVED***:
        ***REMOVED***
            image_dpi = kwargs.pop("dpi", 72***REMOVED***
            self.figure.set_dpi(72.0***REMOVED***
            width, height = self.figure.get_size_inches(***REMOVED***
            w, h = width*72, height*72

            if rcParams['svg.image_noscale'***REMOVED***:
                renderer = RendererSVG(w, h, svgwriter, filename, image_dpi***REMOVED***
            else:
                _bbox_inches_restore = kwargs.pop("bbox_inches_restore", None***REMOVED***
                renderer = MixedModeRenderer(self.figure,
                    width, height, image_dpi, RendererSVG(w, h, svgwriter, filename, image_dpi***REMOVED***,
                    bbox_inches_restore=_bbox_inches_restore***REMOVED***

            self.figure.draw(renderer***REMOVED***
            renderer.finalize(***REMOVED***
        finally:
            if fh_to_close is not None:
                svgwriter.close(***REMOVED***

    def get_default_filetype(self***REMOVED***:
        return 'svg'

class FigureManagerSVG(FigureManagerBase***REMOVED***:
    pass


def new_figure_manager(num, *args, **kwargs***REMOVED***:
    FigureClass = kwargs.pop('FigureClass', Figure***REMOVED***
    thisFig = FigureClass(*args, **kwargs***REMOVED***
    return new_figure_manager_given_figure(num, thisFig***REMOVED***


def new_figure_manager_given_figure(num, figure***REMOVED***:
    ***REMOVED***
    Create a new figure manager instance for the given figure.
    ***REMOVED***
    canvas  = FigureCanvasSVG(figure***REMOVED***
    manager = FigureManagerSVG(canvas, num***REMOVED***
    return manager


svgProlog = ***REMOVED***\
<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
  "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Created with matplotlib (http://matplotlib.org/***REMOVED*** -->
***REMOVED***


FigureCanvas = FigureCanvasSVG
FigureManager = FigureManagerSVG
