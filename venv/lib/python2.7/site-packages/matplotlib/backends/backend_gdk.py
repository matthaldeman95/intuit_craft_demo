from __future__ import (absolute_import, division, print_function,
                        unicode_literals***REMOVED***

from matplotlib.externals import six

import math
***REMOVED***
import sys
import warnings
def fn_name(***REMOVED***: return sys._getframe(1***REMOVED***.f_code.co_name

import gobject
import gtk; gdk = gtk.gdk
import pango
pygtk_version_required = (2,2,0***REMOVED***
if gtk.pygtk_version < pygtk_version_required:
    raise ImportError ("PyGTK %d.%d.%d is installed\n"
                      "PyGTK %d.%d.%d or later is required"
                      % (gtk.pygtk_version + pygtk_version_required***REMOVED******REMOVED***
del pygtk_version_required

import numpy as np

import matplotlib
from matplotlib import rcParams
from matplotlib._pylab_helpers import Gcf
from matplotlib.backend_bases import RendererBase, GraphicsContextBase, \
     FigureManagerBase, FigureCanvasBase
from matplotlib.cbook import is_string_like, restrict_dict
from matplotlib.figure import Figure
from matplotlib.mathtext import MathTextParser
from matplotlib.transforms import Affine2D
from matplotlib.backends._backend_gdk import pixbuf_get_pixels_array

backend_version = "%d.%d.%d" % gtk.pygtk_version
_debug = False

# Image formats that this backend supports - for FileChooser and print_figure(***REMOVED***
IMAGE_FORMAT  = ['eps', 'jpg', 'png', 'ps', 'svg'***REMOVED*** + ['bmp'***REMOVED*** # , 'raw', 'rgb'***REMOVED***
IMAGE_FORMAT.sort(***REMOVED***
IMAGE_FORMAT_DEFAULT  = 'png'


class RendererGDK(RendererBase***REMOVED***:
    fontweights = {
        100          : pango.WEIGHT_ULTRALIGHT,
        200          : pango.WEIGHT_LIGHT,
        300          : pango.WEIGHT_LIGHT,
        400          : pango.WEIGHT_NORMAL,
        500          : pango.WEIGHT_NORMAL,
        600          : pango.WEIGHT_BOLD,
        700          : pango.WEIGHT_BOLD,
        800          : pango.WEIGHT_HEAVY,
        900          : pango.WEIGHT_ULTRABOLD,
        'ultralight' : pango.WEIGHT_ULTRALIGHT,
        'light'      : pango.WEIGHT_LIGHT,
        'normal'     : pango.WEIGHT_NORMAL,
        'medium'     : pango.WEIGHT_NORMAL,
        'semibold'   : pango.WEIGHT_BOLD,
        'bold'       : pango.WEIGHT_BOLD,
        'heavy'      : pango.WEIGHT_HEAVY,
        'ultrabold'  : pango.WEIGHT_ULTRABOLD,
        'black'      : pango.WEIGHT_ULTRABOLD,
               ***REMOVED***

    # cache for efficiency, these must be at class, not instance level
    layoutd = {***REMOVED***  # a map from text prop tups to pango layouts
    rotated = {***REMOVED***  # a map from text prop tups to rotated text pixbufs

    def __init__(self, gtkDA, dpi***REMOVED***:
        # widget gtkDA is used for:
        #  '<widget>.create_pango_layout(s***REMOVED***'
        #  cmap line below***REMOVED***
        self.gtkDA = gtkDA
        self.dpi   = dpi
        self._cmap = gtkDA.get_colormap(***REMOVED***
        self.mathtext_parser = MathTextParser("Agg"***REMOVED***

    def set_pixmap (self, pixmap***REMOVED***:
        self.gdkDrawable = pixmap

    def set_width_height (self, width, height***REMOVED***:
        ***REMOVED***w,h is the figure w,h not the pixmap w,h
        ***REMOVED***
        self.width, self.height = width, height

    def draw_path(self, gc, path, transform, rgbFace=None***REMOVED***:
        transform = transform + Affine2D(***REMOVED***. \
            scale(1.0, -1.0***REMOVED***.translate(0, self.height***REMOVED***
        polygons = path.to_polygons(transform, self.width, self.height***REMOVED***
        for polygon in polygons:
            # draw_polygon won't take an arbitrary sequence -- it must be a list
            # of tuples
            polygon = [(int(round(x***REMOVED******REMOVED***, int(round(y***REMOVED******REMOVED******REMOVED*** for x, y in polygon***REMOVED***
            if rgbFace is not None:
                saveColor = gc.gdkGC.foreground
                gc.gdkGC.foreground = gc.rgb_to_gdk_color(rgbFace***REMOVED***
                self.gdkDrawable.draw_polygon(gc.gdkGC, True, polygon***REMOVED***
                gc.gdkGC.foreground = saveColor
            if gc.gdkGC.line_width > 0:
                self.gdkDrawable.draw_lines(gc.gdkGC, polygon***REMOVED***

    def draw_image(self, gc, x, y, im***REMOVED***:
        bbox = gc.get_clip_rectangle(***REMOVED***

        if bbox != None:
            l,b,w,h = bbox.bounds
            #rectangle = (int(l***REMOVED***, self.height-int(b+h***REMOVED***,
            #             int(w***REMOVED***, int(h***REMOVED******REMOVED***
            # set clip rect?

        rows, cols, image_str = im.as_rgba_str(***REMOVED***

        image_array = np.fromstring(image_str, np.uint8***REMOVED***
        image_array.shape = rows, cols, 4

        pixbuf = gtk.gdk.Pixbuf(gtk.gdk.COLORSPACE_RGB,
                                has_alpha=True, bits_per_sample=8,
                                width=cols, height=rows***REMOVED***

        array = pixbuf_get_pixels_array(pixbuf***REMOVED***
        array[:,:,:***REMOVED*** = image_array[::-1***REMOVED***

        gc = self.new_gc(***REMOVED***


        y = self.height-y-rows

        ***REMOVED*** # new in 2.2
            # can use None instead of gc.gdkGC, if don't need clipping
            self.gdkDrawable.draw_pixbuf (gc.gdkGC, pixbuf, 0, 0,
                                          int(x***REMOVED***, int(y***REMOVED***, cols, rows,
                                          gdk.RGB_DITHER_NONE, 0, 0***REMOVED***
        except AttributeError:
            # deprecated in 2.2
            pixbuf.render_to_drawable(self.gdkDrawable, gc.gdkGC, 0, 0,
                                  int(x***REMOVED***, int(y***REMOVED***, cols, rows,
                                  gdk.RGB_DITHER_NONE, 0, 0***REMOVED***


    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None***REMOVED***:
        x, y = int(x***REMOVED***, int(y***REMOVED***

        if x < 0 or y < 0: # window has shrunk and text is off the edge
            return

        if angle not in (0,90***REMOVED***:
            warnings.warn('backend_gdk: unable to draw text at angles ' +
                          'other than 0 or 90'***REMOVED***
        elif ismath:
            self._draw_mathtext(gc, x, y, s, prop, angle***REMOVED***

        elif angle==90:
            self._draw_rotated_text(gc, x, y, s, prop, angle***REMOVED***

        else:
            layout, inkRect, logicalRect = self._get_pango_layout(s, prop***REMOVED***
            l, b, w, h = inkRect
            if (x + w > self.width or y + h > self.height***REMOVED***:
                return

            self.gdkDrawable.draw_layout(gc.gdkGC, x, y-h-b, layout***REMOVED***


    def _draw_mathtext(self, gc, x, y, s, prop, angle***REMOVED***:
        ox, oy, width, height, descent, font_image, used_characters = \
            self.mathtext_parser.parse(s, self.dpi, prop***REMOVED***

        if angle==90:
            width, height = height, width
            x -= width
        y -= height

        imw = font_image.get_width(***REMOVED***
        imh = font_image.get_height(***REMOVED***
        N = imw * imh

        # a numpixels by num fonts array
        Xall = np.zeros((N,1***REMOVED***, np.uint8***REMOVED***

        image_str = font_image.as_str(***REMOVED***
        Xall[:,0***REMOVED*** = np.fromstring(image_str, np.uint8***REMOVED***

        # get the max alpha at each pixel
        Xs = np.amax(Xall,axis=1***REMOVED***

        # convert it to it's proper shape
        Xs.shape = imh, imw

        pixbuf = gtk.gdk.Pixbuf(gtk.gdk.COLORSPACE_RGB, has_alpha=True,
                                bits_per_sample=8, width=imw, height=imh***REMOVED***

        array = pixbuf_get_pixels_array(pixbuf***REMOVED***

        rgb = gc.get_rgb(***REMOVED***
        array[:,:,0***REMOVED***=int(rgb[0***REMOVED****255***REMOVED***
        array[:,:,1***REMOVED***=int(rgb[1***REMOVED****255***REMOVED***
        array[:,:,2***REMOVED***=int(rgb[2***REMOVED****255***REMOVED***
        array[:,:,3***REMOVED***=Xs

        ***REMOVED*** # new in 2.2
            # can use None instead of gc.gdkGC, if don't need clipping
            self.gdkDrawable.draw_pixbuf (gc.gdkGC, pixbuf, 0, 0,
                                          int(x***REMOVED***, int(y***REMOVED***, imw, imh,
                                          gdk.RGB_DITHER_NONE, 0, 0***REMOVED***
        except AttributeError:
            # deprecated in 2.2
            pixbuf.render_to_drawable(self.gdkDrawable, gc.gdkGC, 0, 0,
                                  int(x***REMOVED***, int(y***REMOVED***, imw, imh,
                                  gdk.RGB_DITHER_NONE, 0, 0***REMOVED***


    def _draw_rotated_text(self, gc, x, y, s, prop, angle***REMOVED***:
        ***REMOVED***
        Draw the text rotated 90 degrees, other angles are not supported
        ***REMOVED***
        # this function (and its called functions***REMOVED*** is a bottleneck
        # Pango 1.6 supports rotated text, but pygtk 2.4.0 does not yet have
        # wrapper functions
        # GTK+ 2.6 pixbufs support rotation

        gdrawable = self.gdkDrawable
        ggc = gc.gdkGC

        layout, inkRect, logicalRect = self._get_pango_layout(s, prop***REMOVED***
        l, b, w, h = inkRect
        x = int(x-h***REMOVED***
        y = int(y-w***REMOVED***

        if (x < 0 or y < 0 or # window has shrunk and text is off the edge
            x + w > self.width or y + h > self.height***REMOVED***:
            return

        key = (x,y,s,angle,hash(prop***REMOVED******REMOVED***
        imageVert = self.rotated.get(key***REMOVED***
        if imageVert != None:
            gdrawable.draw_image(ggc, imageVert, 0, 0, x, y, h, w***REMOVED***
            return

        imageBack = gdrawable.get_image(x, y, w, h***REMOVED***
        imageVert = gdrawable.get_image(x, y, h, w***REMOVED***
        imageFlip = gtk.gdk.Image(type=gdk.IMAGE_FASTEST,
                                  visual=gdrawable.get_visual(***REMOVED***,
                                  width=w, height=h***REMOVED***
        if imageFlip == None or imageBack == None or imageVert == None:
            warnings.warn("Could not renderer vertical text"***REMOVED***
            return
        imageFlip.set_colormap(self._cmap***REMOVED***
        for i in range(w***REMOVED***:
            for j in range(h***REMOVED***:
                imageFlip.put_pixel(i, j, imageVert.get_pixel(j,w-i-1***REMOVED*** ***REMOVED***

        gdrawable.draw_image(ggc, imageFlip, 0, 0, x, y, w, h***REMOVED***
        gdrawable.draw_layout(ggc, x, y-b, layout***REMOVED***

        imageIn  = gdrawable.get_image(x, y, w, h***REMOVED***
        for i in range(w***REMOVED***:
            for j in range(h***REMOVED***:
                imageVert.put_pixel(j, i, imageIn.get_pixel(w-i-1,j***REMOVED*** ***REMOVED***

        gdrawable.draw_image(ggc, imageBack, 0, 0, x, y, w, h***REMOVED***
        gdrawable.draw_image(ggc, imageVert, 0, 0, x, y, h, w***REMOVED***
        self.rotated[key***REMOVED*** = imageVert


    def _get_pango_layout(self, s, prop***REMOVED***:
        ***REMOVED***
        Create a pango layout instance for Text 's' with properties 'prop'.
        Return - pango layout (from cache if already exists***REMOVED***

        Note that pango assumes a logical DPI of 96
        Ref: pango/fonts.c/pango_font_description_set_size(***REMOVED*** manual page
        ***REMOVED***
        # problem? - cache gets bigger and bigger, is never cleared out
        # two (not one***REMOVED*** layouts are created for every text item s (then they
        # are cached***REMOVED*** - why?

        key = self.dpi, s, hash(prop***REMOVED***
        value = self.layoutd.get(key***REMOVED***
        if value != None:
            return value

        size = prop.get_size_in_points(***REMOVED*** * self.dpi / 96.0
        size = round(size***REMOVED***

        font_str = '%s, %s %i' % (prop.get_name(***REMOVED***, prop.get_style(***REMOVED***, size,***REMOVED***
        font = pango.FontDescription(font_str***REMOVED***

        # later - add fontweight to font_str
        font.set_weight(self.fontweights[prop.get_weight(***REMOVED******REMOVED******REMOVED***

        layout = self.gtkDA.create_pango_layout(s***REMOVED***
        layout.set_font_description(font***REMOVED***
        inkRect, logicalRect = layout.get_pixel_extents(***REMOVED***

        self.layoutd[key***REMOVED*** = layout, inkRect, logicalRect
        return layout, inkRect, logicalRect


    def flipy(self***REMOVED***:
        return True

    def get_canvas_width_height(self***REMOVED***:
        return self.width, self.height

    def get_text_width_height_descent(self, s, prop, ismath***REMOVED***:
        if ismath:
            ox, oy, width, height, descent, font_image, used_characters = \
                self.mathtext_parser.parse(s, self.dpi, prop***REMOVED***
            return width, height, descent

        layout, inkRect, logicalRect = self._get_pango_layout(s, prop***REMOVED***
        l, b, w, h = inkRect
        ll, lb, lw, lh = logicalRect

        return w, h + 1, h - lh

    def new_gc(self***REMOVED***:
        return GraphicsContextGDK(renderer=self***REMOVED***


    def points_to_pixels(self, points***REMOVED***:
        return points/72.0 * self.dpi


class GraphicsContextGDK(GraphicsContextBase***REMOVED***:
    # a cache shared by all class instances
    _cached = {***REMOVED***  # map: rgb color -> gdk.Color

    _joind = {
        'bevel' : gdk.JOIN_BEVEL,
        'miter' : gdk.JOIN_MITER,
        'round' : gdk.JOIN_ROUND,
    ***REMOVED***

    _capd = {
        'butt'       : gdk.CAP_BUTT,
        'projecting' : gdk.CAP_PROJECTING,
        'round'      : gdk.CAP_ROUND,
    ***REMOVED***


    def __init__(self, renderer***REMOVED***:
        GraphicsContextBase.__init__(self***REMOVED***
        self.renderer = renderer
        self.gdkGC    = gtk.gdk.GC(renderer.gdkDrawable***REMOVED***
        self._cmap    = renderer._cmap


    def rgb_to_gdk_color(self, rgb***REMOVED***:
        ***REMOVED***
        rgb - an RGB tuple (three 0.0-1.0 values***REMOVED***
        return an allocated gtk.gdk.Color
        ***REMOVED***
        ***REMOVED***
            return self._cached[tuple(rgb***REMOVED******REMOVED***
        except KeyError:
            color = self._cached[tuple(rgb***REMOVED******REMOVED*** = \
                    self._cmap.alloc_color(
                        int(rgb[0***REMOVED****65535***REMOVED***,int(rgb[1***REMOVED****65535***REMOVED***,int(rgb[2***REMOVED****65535***REMOVED******REMOVED***
            return color


    #def set_antialiased(self, b***REMOVED***:
        # anti-aliasing is not supported by GDK

    def set_capstyle(self, cs***REMOVED***:
        GraphicsContextBase.set_capstyle(self, cs***REMOVED***
        self.gdkGC.cap_style = self._capd[self._capstyle***REMOVED***


    def set_clip_rectangle(self, rectangle***REMOVED***:
        GraphicsContextBase.set_clip_rectangle(self, rectangle***REMOVED***
        if rectangle is None:
            return
        l,b,w,h = rectangle.bounds
        rectangle = (int(l***REMOVED***, self.renderer.height-int(b+h***REMOVED***+1,
                     int(w***REMOVED***, int(h***REMOVED******REMOVED***
        #rectangle = (int(l***REMOVED***, self.renderer.height-int(b+h***REMOVED***,
        #             int(w+1***REMOVED***, int(h+2***REMOVED******REMOVED***
        self.gdkGC.set_clip_rectangle(rectangle***REMOVED***

    def set_dashes(self, dash_offset, dash_list***REMOVED***:
        GraphicsContextBase.set_dashes(self, dash_offset, dash_list***REMOVED***

        if dash_list == None:
            self.gdkGC.line_style = gdk.LINE_SOLID
        else:
            pixels = self.renderer.points_to_pixels(np.asarray(dash_list***REMOVED******REMOVED***
            dl = [max(1, int(round(val***REMOVED******REMOVED******REMOVED*** for val in pixels***REMOVED***
            self.gdkGC.set_dashes(dash_offset, dl***REMOVED***
            self.gdkGC.line_style = gdk.LINE_ON_OFF_DASH


    def set_foreground(self, fg, isRGBA=False***REMOVED***:
        GraphicsContextBase.set_foreground(self, fg, isRGBA***REMOVED***
        self.gdkGC.foreground = self.rgb_to_gdk_color(self.get_rgb(***REMOVED******REMOVED***


    def set_graylevel(self, frac***REMOVED***:
        GraphicsContextBase.set_graylevel(self, frac***REMOVED***
        self.gdkGC.foreground = self.rgb_to_gdk_color(self.get_rgb(***REMOVED******REMOVED***


    def set_joinstyle(self, js***REMOVED***:
        GraphicsContextBase.set_joinstyle(self, js***REMOVED***
        self.gdkGC.join_style = self._joind[self._joinstyle***REMOVED***


    def set_linewidth(self, w***REMOVED***:
        GraphicsContextBase.set_linewidth(self, w***REMOVED***
        if w == 0:
            self.gdkGC.line_width = 0
        else:
            pixels = self.renderer.points_to_pixels(w***REMOVED***
            self.gdkGC.line_width = max(1, int(round(pixels***REMOVED******REMOVED******REMOVED***


def new_figure_manager(num, *args, **kwargs***REMOVED***:
    ***REMOVED***
    Create a new figure manager instance
    ***REMOVED***
    FigureClass = kwargs.pop('FigureClass', Figure***REMOVED***
    thisFig = FigureClass(*args, **kwargs***REMOVED***
    return new_figure_manager_given_figure(num, thisFig***REMOVED***


def new_figure_manager_given_figure(num, figure***REMOVED***:
    ***REMOVED***
    Create a new figure manager instance for the given figure.
    ***REMOVED***
    canvas  = FigureCanvasGDK(figure***REMOVED***
    manager = FigureManagerBase(canvas, num***REMOVED***
    return manager


class FigureCanvasGDK (FigureCanvasBase***REMOVED***:
    def __init__(self, figure***REMOVED***:
        FigureCanvasBase.__init__(self, figure***REMOVED***

        self._renderer_init(***REMOVED***

    def _renderer_init(self***REMOVED***:
        self._renderer = RendererGDK (gtk.DrawingArea(***REMOVED***, self.figure.dpi***REMOVED***

    def _render_figure(self, pixmap, width, height***REMOVED***:
        self._renderer.set_pixmap (pixmap***REMOVED***
        self._renderer.set_width_height (width, height***REMOVED***
        self.figure.draw (self._renderer***REMOVED***

    filetypes = FigureCanvasBase.filetypes.copy(***REMOVED***
    filetypes['jpg'***REMOVED*** = 'JPEG'
    filetypes['jpeg'***REMOVED*** = 'JPEG'

    def print_jpeg(self, filename, *args, **kwargs***REMOVED***:
        return self._print_image(filename, 'jpeg'***REMOVED***
    print_jpg = print_jpeg

    def print_png(self, filename, *args, **kwargs***REMOVED***:
        return self._print_image(filename, 'png'***REMOVED***

    def _print_image(self, filename, format, *args, **kwargs***REMOVED***:
        width, height = self.get_width_height(***REMOVED***
        pixmap = gtk.gdk.Pixmap (None, width, height, depth=24***REMOVED***
        self._render_figure(pixmap, width, height***REMOVED***

        # jpg colors don't match the display very well, png colors match
        # better
        pixbuf = gtk.gdk.Pixbuf(gtk.gdk.COLORSPACE_RGB, 0, 8,
                                width, height***REMOVED***
        pixbuf.get_from_drawable(pixmap, pixmap.get_colormap(***REMOVED***,
                                 0, 0, 0, 0, width, height***REMOVED***

        # set the default quality, if we are writing a JPEG.
        # http://www.pygtk.org/docs/pygtk/class-gdkpixbuf.html#method-gdkpixbuf--save
        options = restrict_dict(kwargs, ['quality'***REMOVED******REMOVED***
        if format in ['jpg','jpeg'***REMOVED***:
            if 'quality' not in options:
                options['quality'***REMOVED*** = rcParams['savefig.jpeg_quality'***REMOVED***
            options['quality'***REMOVED*** = str(options['quality'***REMOVED******REMOVED***

        pixbuf.save(filename, format, options=options***REMOVED***
