***REMOVED***
A Cairo backend for matplotlib
Author: Steve Chaplin

Cairo is a vector graphics library with cross-device output support.
Features of Cairo:
 * anti-aliasing
 * alpha channel
 * saves image files as PNG, PostScript, PDF

http://cairographics.org
Requires (in order, all available from Cairo website***REMOVED***:
    cairo, pycairo

Naming Conventions
  * classes MixedUpperCase
  * varables lowerUpper
  * functions underscore_separated
***REMOVED***

from __future__ import (absolute_import, division, print_function,
                        unicode_literals***REMOVED***

from matplotlib.externals import six

***REMOVED***, sys, warnings, gzip

import numpy as np

def _fn_name(***REMOVED***: return sys._getframe(1***REMOVED***.f_code.co_name

***REMOVED***
    import cairocffi as cairo
except ImportError:
    ***REMOVED***
        import cairo
    except ImportError:
        raise ImportError("Cairo backend requires that cairocffi or pycairo is installed."***REMOVED***
    else:
        HAS_CAIRO_CFFI = False
else:
    HAS_CAIRO_CFFI = True

_version_required = (1,2,0***REMOVED***
if cairo.version_info < _version_required:
    raise ImportError ("Pycairo %d.%d.%d is installed\n"
                       "Pycairo %d.%d.%d or later is required"
                        % (cairo.version_info + _version_required***REMOVED******REMOVED***
backend_version = cairo.version
del _version_required

from matplotlib.backend_bases import RendererBase, GraphicsContextBase,\
     FigureManagerBase, FigureCanvasBase
from matplotlib.cbook        import is_string_like
from matplotlib.figure       import Figure
from matplotlib.mathtext     import MathTextParser
from matplotlib.path         import Path
from matplotlib.transforms   import Bbox, Affine2D
from matplotlib.font_manager import ttfFontProperty

_debug = False
#_debug = True

# Image::color_conv(format***REMOVED*** for draw_image(***REMOVED***
if sys.byteorder == 'little':
    BYTE_FORMAT = 0 # BGRA
else:
    BYTE_FORMAT = 1 # ARGB


class RendererCairo(RendererBase***REMOVED***:
    fontweights = {
        100          : cairo.FONT_WEIGHT_NORMAL,
        200          : cairo.FONT_WEIGHT_NORMAL,
        300          : cairo.FONT_WEIGHT_NORMAL,
        400          : cairo.FONT_WEIGHT_NORMAL,
        500          : cairo.FONT_WEIGHT_NORMAL,
        600          : cairo.FONT_WEIGHT_BOLD,
        700          : cairo.FONT_WEIGHT_BOLD,
        800          : cairo.FONT_WEIGHT_BOLD,
        900          : cairo.FONT_WEIGHT_BOLD,
        'ultralight' : cairo.FONT_WEIGHT_NORMAL,
        'light'      : cairo.FONT_WEIGHT_NORMAL,
        'normal'     : cairo.FONT_WEIGHT_NORMAL,
        'medium'     : cairo.FONT_WEIGHT_NORMAL,
        'semibold'   : cairo.FONT_WEIGHT_BOLD,
        'bold'       : cairo.FONT_WEIGHT_BOLD,
        'heavy'      : cairo.FONT_WEIGHT_BOLD,
        'ultrabold'  : cairo.FONT_WEIGHT_BOLD,
        'black'      : cairo.FONT_WEIGHT_BOLD,
               ***REMOVED***
    fontangles = {
        'italic'  : cairo.FONT_SLANT_ITALIC,
        'normal'  : cairo.FONT_SLANT_NORMAL,
        'oblique' : cairo.FONT_SLANT_OBLIQUE,
    ***REMOVED***


    def __init__(self, dpi***REMOVED***:
        ***REMOVED***
        ***REMOVED***
        if _debug: print('%s.%s(***REMOVED***' % (self.__class__.__name__, _fn_name(***REMOVED******REMOVED******REMOVED***
        self.dpi = dpi
        self.gc = GraphicsContextCairo (renderer=self***REMOVED***
        self.text_ctx = cairo.Context (
           cairo.ImageSurface (cairo.FORMAT_ARGB32,1,1***REMOVED******REMOVED***
        self.mathtext_parser = MathTextParser('Cairo'***REMOVED***

        RendererBase.__init__(self***REMOVED***

    def set_ctx_from_surface (self, surface***REMOVED***:
        self.gc.ctx = cairo.Context (surface***REMOVED***


    def set_width_height(self, width, height***REMOVED***:
        self.width  = width
        self.height = height
        self.matrix_flipy = cairo.Matrix (yy=-1, y0=self.height***REMOVED***
        # use matrix_flipy for ALL rendering?
        # - problem with text? - will need to switch matrix_flipy off, or do a
        # font transform?


    def _fill_and_stroke (self, ctx, fill_c, alpha, alpha_overrides***REMOVED***:
        if fill_c is not None:
            ctx.save(***REMOVED***
            if len(fill_c***REMOVED*** == 3 or alpha_overrides:
                ctx.set_source_rgba (fill_c[0***REMOVED***, fill_c[1***REMOVED***, fill_c[2***REMOVED***, alpha***REMOVED***
            else:
                ctx.set_source_rgba (fill_c[0***REMOVED***, fill_c[1***REMOVED***, fill_c[2***REMOVED***, fill_c[3***REMOVED******REMOVED***
            ctx.fill_preserve(***REMOVED***
            ctx.restore(***REMOVED***
        ctx.stroke(***REMOVED***

    @staticmethod
    def convert_path(ctx, path, transform, clip=None***REMOVED***:
        for points, code in path.iter_segments(transform, clip=clip***REMOVED***:
            if code == Path.MOVETO:
                ctx.move_to(*points***REMOVED***
            elif code == Path.CLOSEPOLY:
                ctx.close_path(***REMOVED***
            elif code == Path.LINETO:
                ctx.line_to(*points***REMOVED***
            elif code == Path.CURVE3:
                ctx.curve_to(points[0***REMOVED***, points[1***REMOVED***,
                             points[0***REMOVED***, points[1***REMOVED***,
                             points[2***REMOVED***, points[3***REMOVED******REMOVED***
            elif code == Path.CURVE4:
                ctx.curve_to(*points***REMOVED***


    def draw_path(self, gc, path, transform, rgbFace=None***REMOVED***:
        ctx = gc.ctx

        # We'll clip the path to the actual rendering extents
        # if the path isn't filled.
        if rgbFace is None and gc.get_hatch(***REMOVED*** is None:
            clip = ctx.clip_extents(***REMOVED***
        else:
            clip = None

        transform = transform + \
            Affine2D(***REMOVED***.scale(1.0, -1.0***REMOVED***.translate(0, self.height***REMOVED***

        ctx.new_path(***REMOVED***
        self.convert_path(ctx, path, transform, clip***REMOVED***

        self._fill_and_stroke(ctx, rgbFace, gc.get_alpha(***REMOVED***, gc.get_forced_alpha(***REMOVED******REMOVED***

    def draw_image(self, gc, x, y, im***REMOVED***:
        # bbox - not currently used
        if _debug: print('%s.%s(***REMOVED***' % (self.__class__.__name__, _fn_name(***REMOVED******REMOVED******REMOVED***

        rows, cols, buf = im.color_conv (BYTE_FORMAT***REMOVED***
        surface = cairo.ImageSurface.create_for_data (
                      buf, cairo.FORMAT_ARGB32, cols, rows, cols*4***REMOVED***
        ctx = gc.ctx
        y = self.height - y - rows

        ctx.save(***REMOVED***
        ctx.set_source_surface (surface, x, y***REMOVED***
        if gc.get_alpha(***REMOVED*** != 1.0:
            ctx.paint_with_alpha(gc.get_alpha(***REMOVED******REMOVED***
        else:
            ctx.paint(***REMOVED***
        ctx.restore(***REMOVED***

    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None***REMOVED***:
        # Note: x,y are device/display coords, not user-coords, unlike other
        # draw_* methods
        if _debug: print('%s.%s(***REMOVED***' % (self.__class__.__name__, _fn_name(***REMOVED******REMOVED******REMOVED***

        if ismath:
            self._draw_mathtext(gc, x, y, s, prop, angle***REMOVED***

        else:
            ctx = gc.ctx
            ctx.new_path(***REMOVED***
            ctx.move_to (x, y***REMOVED***
            ctx.select_font_face (prop.get_name(***REMOVED***,
                                  self.fontangles [prop.get_style(***REMOVED******REMOVED***,
                                  self.fontweights[prop.get_weight(***REMOVED******REMOVED******REMOVED***

            size = prop.get_size_in_points(***REMOVED*** * self.dpi / 72.0

            ctx.save(***REMOVED***
            if angle:
                ctx.rotate (-angle * np.pi / 180***REMOVED***
            ctx.set_font_size (size***REMOVED***

            if HAS_CAIRO_CFFI:
                if not isinstance(s, six.text_type***REMOVED***:
                    s = six.text_type(s***REMOVED***
            else:
                if not six.PY3 and isinstance(s, six.text_type***REMOVED***:
                    s = s.encode("utf-8"***REMOVED***

            ctx.show_text(s***REMOVED***
            ctx.restore(***REMOVED***

    def _draw_mathtext(self, gc, x, y, s, prop, angle***REMOVED***:
        if _debug: print('%s.%s(***REMOVED***' % (self.__class__.__name__, _fn_name(***REMOVED******REMOVED******REMOVED***

        ctx = gc.ctx
        width, height, descent, glyphs, rects = self.mathtext_parser.parse(
            s, self.dpi, prop***REMOVED***

        ctx.save(***REMOVED***
        ctx.translate(x, y***REMOVED***
        if angle:
            ctx.rotate (-angle * np.pi / 180***REMOVED***

        for font, fontsize, s, ox, oy in glyphs:
            ctx.new_path(***REMOVED***
            ctx.move_to(ox, oy***REMOVED***

            fontProp = ttfFontProperty(font***REMOVED***
            ctx.save(***REMOVED***
            ctx.select_font_face (fontProp.name,
                                  self.fontangles [fontProp.style***REMOVED***,
                                  self.fontweights[fontProp.weight***REMOVED******REMOVED***

            size = fontsize * self.dpi / 72.0
            ctx.set_font_size(size***REMOVED***
            if not six.PY3 and isinstance(s, six.text_type***REMOVED***:
                s = s.encode("utf-8"***REMOVED***
            ctx.show_text(s***REMOVED***
            ctx.restore(***REMOVED***

        for ox, oy, w, h in rects:
            ctx.new_path(***REMOVED***
            ctx.rectangle (ox, oy, w, h***REMOVED***
            ctx.set_source_rgb (0, 0, 0***REMOVED***
            ctx.fill_preserve(***REMOVED***

        ctx.restore(***REMOVED***


    def flipy(self***REMOVED***:
        if _debug: print('%s.%s(***REMOVED***' % (self.__class__.__name__, _fn_name(***REMOVED******REMOVED******REMOVED***
        return True
        #return False # tried - all draw objects ok except text (and images?***REMOVED***
        # which comes out mirrored!


    def get_canvas_width_height(self***REMOVED***:
        if _debug: print('%s.%s(***REMOVED***' % (self.__class__.__name__, _fn_name(***REMOVED******REMOVED******REMOVED***
        return self.width, self.height


    def get_text_width_height_descent(self, s, prop, ismath***REMOVED***:
        if _debug: print('%s.%s(***REMOVED***' % (self.__class__.__name__, _fn_name(***REMOVED******REMOVED******REMOVED***
        if ismath:
            width, height, descent, fonts, used_characters = self.mathtext_parser.parse(
               s, self.dpi, prop***REMOVED***
            return width, height, descent

        ctx = self.text_ctx
        ctx.save(***REMOVED***
        ctx.select_font_face (prop.get_name(***REMOVED***,
                              self.fontangles [prop.get_style(***REMOVED******REMOVED***,
                              self.fontweights[prop.get_weight(***REMOVED******REMOVED******REMOVED***

        # Cairo (says it***REMOVED*** uses 1/96 inch user space units, ref: cairo_gstate.c
        # but if /96.0 is used the font is too small

        size = prop.get_size_in_points(***REMOVED*** * self.dpi / 72.0

        # problem - scale remembers last setting and font can become
        # enormous causing program to crash
        # save/restore prevents the problem
        ctx.set_font_size (size***REMOVED***

        y_bearing, w, h = ctx.text_extents (s***REMOVED***[1:4***REMOVED***
        ctx.restore(***REMOVED***

        return w, h, h + y_bearing


    def new_gc(self***REMOVED***:
        if _debug: print('%s.%s(***REMOVED***' % (self.__class__.__name__, _fn_name(***REMOVED******REMOVED******REMOVED***
        self.gc.ctx.save(***REMOVED***
        self.gc._alpha = 1.0
        self.gc._forced_alpha = False # if True, _alpha overrides A from RGBA
        return self.gc


    def points_to_pixels(self, points***REMOVED***:
        if _debug: print('%s.%s(***REMOVED***' % (self.__class__.__name__, _fn_name(***REMOVED******REMOVED******REMOVED***
        return points/72.0 * self.dpi


class GraphicsContextCairo(GraphicsContextBase***REMOVED***:
    _joind = {
        'bevel' : cairo.LINE_JOIN_BEVEL,
        'miter' : cairo.LINE_JOIN_MITER,
        'round' : cairo.LINE_JOIN_ROUND,
    ***REMOVED***

    _capd = {
        'butt'       : cairo.LINE_CAP_BUTT,
        'projecting' : cairo.LINE_CAP_SQUARE,
        'round'      : cairo.LINE_CAP_ROUND,
    ***REMOVED***


    def __init__(self, renderer***REMOVED***:
        GraphicsContextBase.__init__(self***REMOVED***
        self.renderer = renderer


    def restore(self***REMOVED***:
        self.ctx.restore(***REMOVED***


    def set_alpha(self, alpha***REMOVED***:
        GraphicsContextBase.set_alpha(self, alpha***REMOVED***
        _alpha = self.get_alpha(***REMOVED***
        rgb = self._rgb
        if self.get_forced_alpha(***REMOVED***:
            self.ctx.set_source_rgba (rgb[0***REMOVED***, rgb[1***REMOVED***, rgb[2***REMOVED***, _alpha***REMOVED***
        else:
            self.ctx.set_source_rgba (rgb[0***REMOVED***, rgb[1***REMOVED***, rgb[2***REMOVED***, rgb[3***REMOVED******REMOVED***


    #def set_antialiased(self, b***REMOVED***:
        # enable/disable anti-aliasing is not (yet***REMOVED*** supported by Cairo


    def set_capstyle(self, cs***REMOVED***:
        if cs in ('butt', 'round', 'projecting'***REMOVED***:
            self._capstyle = cs
            self.ctx.set_line_cap (self._capd[cs***REMOVED******REMOVED***
        else:
            raise ValueError('Unrecognized cap style.  Found %s' % cs***REMOVED***


    def set_clip_rectangle(self, rectangle***REMOVED***:
        if not rectangle: return
        x,y,w,h = rectangle.bounds
        # pixel-aligned clip-regions are faster
        x,y,w,h = round(x***REMOVED***, round(y***REMOVED***, round(w***REMOVED***, round(h***REMOVED***
        ctx = self.ctx
        ctx.new_path(***REMOVED***
        ctx.rectangle (x, self.renderer.height - h - y, w, h***REMOVED***
        ctx.clip (***REMOVED***

    def set_clip_path(self, path***REMOVED***:
        if not path: return
        tpath, affine = path.get_transformed_path_and_affine(***REMOVED***
        ctx = self.ctx
        ctx.new_path(***REMOVED***
        affine = affine + Affine2D(***REMOVED***.scale(1.0, -1.0***REMOVED***.translate(0.0, self.renderer.height***REMOVED***
        RendererCairo.convert_path(ctx, tpath, affine***REMOVED***
        ctx.clip(***REMOVED***

    def set_dashes(self, offset, dashes***REMOVED***:
        self._dashes = offset, dashes
        if dashes == None:
            self.ctx.set_dash([***REMOVED***, 0***REMOVED***  # switch dashes off
        else:
            self.ctx.set_dash(
                list(self.renderer.points_to_pixels(np.asarray(dashes***REMOVED******REMOVED******REMOVED***, offset***REMOVED***


    def set_foreground(self, fg, isRGBA=None***REMOVED***:
        GraphicsContextBase.set_foreground(self, fg, isRGBA***REMOVED***
        if len(self._rgb***REMOVED*** == 3:
            self.ctx.set_source_rgb(*self._rgb***REMOVED***
        else:
            self.ctx.set_source_rgba(*self._rgb***REMOVED***

    def set_graylevel(self, frac***REMOVED***:
        GraphicsContextBase.set_graylevel(self, frac***REMOVED***
        if len(self._rgb***REMOVED*** == 3:
            self.ctx.set_source_rgb(*self._rgb***REMOVED***
        else:
            self.ctx.set_source_rgba(*self._rgb***REMOVED***

    def get_rgb(self***REMOVED***:
        return self.ctx.get_source(***REMOVED***.get_rgba(***REMOVED***[:3***REMOVED***

    def set_joinstyle(self, js***REMOVED***:
        if js in ('miter', 'round', 'bevel'***REMOVED***:
            self._joinstyle = js
            self.ctx.set_line_join(self._joind[js***REMOVED******REMOVED***
        else:
            raise ValueError('Unrecognized join style.  Found %s' % js***REMOVED***


    def set_linewidth(self, w***REMOVED***:
        self._linewidth = float(w***REMOVED***
        self.ctx.set_line_width (self.renderer.points_to_pixels(w***REMOVED******REMOVED***


def new_figure_manager(num, *args, **kwargs***REMOVED***: # called by backends/__init__.py
    ***REMOVED***
    Create a new figure manager instance
    ***REMOVED***
    if _debug: print('%s(***REMOVED***' % (_fn_name(***REMOVED******REMOVED******REMOVED***
    FigureClass = kwargs.pop('FigureClass', Figure***REMOVED***
    thisFig = FigureClass(*args, **kwargs***REMOVED***
    return new_figure_manager_given_figure(num, thisFig***REMOVED***


def new_figure_manager_given_figure(num, figure***REMOVED***:
    ***REMOVED***
    Create a new figure manager instance for the given figure.
    ***REMOVED***
    canvas  = FigureCanvasCairo(figure***REMOVED***
    manager = FigureManagerBase(canvas, num***REMOVED***
    return manager


class FigureCanvasCairo (FigureCanvasBase***REMOVED***:
    def print_png(self, fobj, *args, **kwargs***REMOVED***:
        width, height = self.get_width_height(***REMOVED***

        renderer = RendererCairo (self.figure.dpi***REMOVED***
        renderer.set_width_height (width, height***REMOVED***
        surface = cairo.ImageSurface (cairo.FORMAT_ARGB32, width, height***REMOVED***
        renderer.set_ctx_from_surface (surface***REMOVED***

        self.figure.draw (renderer***REMOVED***
        surface.write_to_png (fobj***REMOVED***

    def print_pdf(self, fobj, *args, **kwargs***REMOVED***:
        return self._save(fobj, 'pdf', *args, **kwargs***REMOVED***

    def print_ps(self, fobj, *args, **kwargs***REMOVED***:
        return self._save(fobj, 'ps', *args, **kwargs***REMOVED***

    def print_svg(self, fobj, *args, **kwargs***REMOVED***:
        return self._save(fobj, 'svg', *args, **kwargs***REMOVED***

    def print_svgz(self, fobj, *args, **kwargs***REMOVED***:
        return self._save(fobj, 'svgz', *args, **kwargs***REMOVED***

    def _save (self, fo, format, **kwargs***REMOVED***:
        # save PDF/PS/SVG
        orientation = kwargs.get('orientation', 'portrait'***REMOVED***

        dpi = 72
        self.figure.dpi = dpi
        w_in, h_in = self.figure.get_size_inches(***REMOVED***
        width_in_points, height_in_points = w_in * dpi, h_in * dpi

        if orientation == 'landscape':
            width_in_points, height_in_points = (height_in_points,
                                                 width_in_points***REMOVED***

        if format == 'ps':
            if not hasattr(cairo, 'PSSurface'***REMOVED***:
                raise RuntimeError ('cairo has not been compiled with PS '
                                    'support enabled'***REMOVED***
            surface = cairo.PSSurface (fo, width_in_points, height_in_points***REMOVED***
        elif format == 'pdf':
            if not hasattr(cairo, 'PDFSurface'***REMOVED***:
                raise RuntimeError ('cairo has not been compiled with PDF '
                                    'support enabled'***REMOVED***
            surface = cairo.PDFSurface (fo, width_in_points, height_in_points***REMOVED***
        elif format in ('svg', 'svgz'***REMOVED***:
            if not hasattr(cairo, 'SVGSurface'***REMOVED***:
                raise RuntimeError ('cairo has not been compiled with SVG '
                                    'support enabled'***REMOVED***
            if format == 'svgz':
                if is_string_like(fo***REMOVED***:
                    fo = gzip.GzipFile(fo, 'wb'***REMOVED***
                else:
                    fo = gzip.GzipFile(None, 'wb', fileobj=fo***REMOVED***
            surface = cairo.SVGSurface (fo, width_in_points, height_in_points***REMOVED***
        else:
            warnings.warn ("unknown format: %s" % format***REMOVED***
            return

        # surface.set_dpi(***REMOVED*** can be used
        renderer = RendererCairo (self.figure.dpi***REMOVED***
        renderer.set_width_height (width_in_points, height_in_points***REMOVED***
        renderer.set_ctx_from_surface (surface***REMOVED***
        ctx = renderer.gc.ctx

        if orientation == 'landscape':
            ctx.rotate (np.pi/2***REMOVED***
            ctx.translate (0, -height_in_points***REMOVED***
            # cairo/src/cairo_ps_surface.c
            # '%%Orientation: Portrait' is always written to the file header
            # '%%Orientation: Landscape' would possibly cause problems
            # since some printers would rotate again ?
            # TODO:
            # add portrait/landscape checkbox to FileChooser

        self.figure.draw (renderer***REMOVED***

        show_fig_border = False  # for testing figure orientation and scaling
        if show_fig_border:
            ctx.new_path(***REMOVED***
            ctx.rectangle(0, 0, width_in_points, height_in_points***REMOVED***
            ctx.set_line_width(4.0***REMOVED***
            ctx.set_source_rgb(1,0,0***REMOVED***
            ctx.stroke(***REMOVED***
            ctx.move_to(30,30***REMOVED***
            ctx.select_font_face ('sans-serif'***REMOVED***
            ctx.set_font_size(20***REMOVED***
            ctx.show_text('Origin corner'***REMOVED***

        ctx.show_page(***REMOVED***
        surface.finish(***REMOVED***
        if format == 'svgz':
            fo.close(***REMOVED***


FigureCanvas = FigureCanvasCairo
