var comm_websocket_adapter = function(comm***REMOVED*** {
    // Create a "websocket"-like object which calls the given IPython comm
    // object with the appropriate methods. Currently this is a non binary
    // socket, so there is still some room for performance tuning.
    var ws = {***REMOVED***;

    ws.close = function(***REMOVED*** {
        comm.close(***REMOVED***
***REMOVED***;
    ws.send = function(m***REMOVED*** {
        //console.log('sending', m***REMOVED***;
        comm.send(m***REMOVED***;
***REMOVED***;
    // Register the callback with on_msg.
    comm.on_msg(function(msg***REMOVED*** {
        //console.log('receiving', msg['content'***REMOVED***['data'***REMOVED***, msg***REMOVED***;
        // Pass the mpl event to the overriden (by mpl***REMOVED*** onmessage function.
        ws.onmessage(msg['content'***REMOVED***['data'***REMOVED******REMOVED***
***REMOVED******REMOVED***;
    return ws;
***REMOVED***

mpl.mpl_figure_comm = function(comm, msg***REMOVED*** {
    // This is the function which gets called when the mpl process
    // starts-up an IPython Comm through the "matplotlib" channel.

    var id = msg.content.data.id;
    // Get hold of the div created by the display call when the Comm
    // socket was opened in Python.
    var element = $("#" + id***REMOVED***;
    var ws_proxy = comm_websocket_adapter(comm***REMOVED***

    function ondownload(figure, format***REMOVED*** {
        window.open(figure.imageObj.src***REMOVED***;
***REMOVED***

    var fig = new mpl.figure(id, ws_proxy,
                           ondownload,
                           element.get(0***REMOVED******REMOVED***;

    // Call onopen now - mpl needs it, as it is assuming we've passed it a real
    // web socket which is closed, not our websocket->open comm proxy.
    ws_proxy.onopen(***REMOVED***;

    fig.parent_element = element.get(0***REMOVED***;
    fig.cell_info = mpl.find_output_cell("<div id='" + id + "'></div>"***REMOVED***;
    if (!fig.cell_info***REMOVED*** {
        console.error("Failed to find cell for figure", id, fig***REMOVED***;
        return;
***REMOVED***

    var output_index = fig.cell_info[2***REMOVED***
    var cell = fig.cell_info[0***REMOVED***;

***REMOVED***;

mpl.figure.prototype.handle_close = function(fig, msg***REMOVED*** {
    fig.root.unbind('remove'***REMOVED***

    // Update the output cell to use the data from the current canvas.
    fig.push_to_output(***REMOVED***;
    var dataURL = fig.canvas.toDataURL(***REMOVED***;
    // Re-enable the keyboard manager in IPython - without this line, in FF,
    // the notebook keyboard shortcuts fail.
    IPython.keyboard_manager.enable(***REMOVED***
    $(fig.parent_element***REMOVED***.html('<img src="' + dataURL + '">'***REMOVED***;
    fig.close_ws(fig, msg***REMOVED***;
***REMOVED***

mpl.figure.prototype.close_ws = function(fig, msg***REMOVED***{
    fig.send_message('closing', msg***REMOVED***;
    // fig.ws.close(***REMOVED***
***REMOVED***

mpl.figure.prototype.push_to_output = function(remove_interactive***REMOVED*** {
    // Turn the data on the canvas into data in the output cell.
    var dataURL = this.canvas.toDataURL(***REMOVED***;
    this.cell_info[1***REMOVED***['text/html'***REMOVED*** = '<img src="' + dataURL + '">';
***REMOVED***

mpl.figure.prototype.updated_canvas_event = function(***REMOVED*** {
    // Tell IPython that the notebook contents must change.
    IPython.notebook.set_dirty(true***REMOVED***;
    this.send_message("ack", {***REMOVED******REMOVED***;
    var fig = this;
    // Wait a second, then push the new image to the DOM so
    // that it is saved nicely (might be nice to debounce this***REMOVED***.
    setTimeout(function (***REMOVED*** { fig.push_to_output(***REMOVED*** ***REMOVED***, 1000***REMOVED***;
***REMOVED***

mpl.figure.prototype._init_toolbar = function(***REMOVED*** {
    var fig = this;

    var nav_element = $('<div/>'***REMOVED***
    nav_element.attr('style', 'width: 100%'***REMOVED***;
    this.root.append(nav_element***REMOVED***;

    // Define a callback function for later on.
    function toolbar_event(event***REMOVED*** {
        return fig.toolbar_button_onclick(event['data'***REMOVED******REMOVED***;
***REMOVED***
    function toolbar_mouse_event(event***REMOVED*** {
        return fig.toolbar_button_onmouseover(event['data'***REMOVED******REMOVED***;
***REMOVED***

    for(var toolbar_ind in mpl.toolbar_items***REMOVED***{
        var name = mpl.toolbar_items[toolbar_ind***REMOVED***[0***REMOVED***;
        var tooltip = mpl.toolbar_items[toolbar_ind***REMOVED***[1***REMOVED***;
        var image = mpl.toolbar_items[toolbar_ind***REMOVED***[2***REMOVED***;
        var method_name = mpl.toolbar_items[toolbar_ind***REMOVED***[3***REMOVED***;

        if (!name***REMOVED*** { continue; ***REMOVED***;

        var button = $('<button class="btn btn-default" href="#" title="' + name + '"><i class="fa ' + image + ' fa-lg"></i></button>'***REMOVED***;
        button.click(method_name, toolbar_event***REMOVED***;
        button.mouseover(tooltip, toolbar_mouse_event***REMOVED***;
        nav_element.append(button***REMOVED***;
***REMOVED***

    // Add the status bar.
    var status_bar = $('<span class="mpl-message" style="text-align:right; float: right;"/>'***REMOVED***;
    nav_element.append(status_bar***REMOVED***;
    this.message = status_bar[0***REMOVED***;

    // Add the close button to the window.
    var buttongrp = $('<div class="btn-group inline pull-right"></div>'***REMOVED***;
    var button = $('<button class="btn btn-mini btn-primary" href="#" title="Stop Interaction"><i class="fa fa-power-off icon-remove icon-large"></i></button>'***REMOVED***;
    button.click(function (evt***REMOVED*** { fig.handle_close(fig, {***REMOVED******REMOVED***; ***REMOVED*** ***REMOVED***;
    button.mouseover('Stop Interaction', toolbar_mouse_event***REMOVED***;
    buttongrp.append(button***REMOVED***;
    var titlebar = this.root.find($('.ui-dialog-titlebar'***REMOVED******REMOVED***;
    titlebar.prepend(buttongrp***REMOVED***;
***REMOVED***

mpl.figure.prototype._root_extra_style = function(el***REMOVED***{
    var fig = this
    el.on("remove", function(***REMOVED***{
	fig.close_ws(fig, {***REMOVED******REMOVED***;
***REMOVED******REMOVED***;
***REMOVED***

mpl.figure.prototype._canvas_extra_style = function(el***REMOVED***{
    // this is important to make the div 'focusable
    el.attr('tabindex', 0***REMOVED***
    // reach out to IPython and tell the keyboard manager to turn it's self
    // off when our div gets focus

    // location in version 3
    if (IPython.notebook.keyboard_manager***REMOVED*** {
        IPython.notebook.keyboard_manager.register_events(el***REMOVED***;
***REMOVED***
    else {
        // location in version 2
        IPython.keyboard_manager.register_events(el***REMOVED***;
***REMOVED***

***REMOVED***

mpl.figure.prototype._key_event_extra = function(event, name***REMOVED*** {
    var manager = IPython.notebook.keyboard_manager;
    if (!manager***REMOVED***
        manager = IPython.keyboard_manager;

    // Check for shift+enter
    if (event.shiftKey && event.which == 13***REMOVED*** {
        this.canvas_div.blur(***REMOVED***;
        // select the cell after this one
        var index = IPython.notebook.find_cell_index(this.cell_info[0***REMOVED******REMOVED***;
        IPython.notebook.select(index + 1***REMOVED***;
***REMOVED***
***REMOVED***

mpl.figure.prototype.handle_save = function(fig, msg***REMOVED*** {
    fig.ondownload(fig, null***REMOVED***;
***REMOVED***


mpl.find_output_cell = function(html_output***REMOVED*** {
    // Return the cell and output element which can be found *uniquely* in the notebook.
    // Note - this is a bit hacky, but it is done because the "notebook_saving.Notebook"
    // IPython event is triggered only after the cells have been serialised, which for
    // our purposes (turning an active figure into a static one***REMOVED***, is too late.
    var cells = IPython.notebook.get_cells(***REMOVED***;
    var ncells = cells.length;
    for (var i=0; i<ncells; i++***REMOVED*** {
        var cell = cells[i***REMOVED***;
        if (cell.cell_type === 'code'***REMOVED***{
            for (var j=0; j<cell.output_area.outputs.length; j++***REMOVED*** {
                var data = cell.output_area.outputs[j***REMOVED***;
                if (data.data***REMOVED*** {
                    // IPython >= 3 moved mimebundle to data attribute of output
                    data = data.data;
            ***REMOVED***
                if (data['text/html'***REMOVED*** == html_output***REMOVED*** {
                    return [cell, data, j***REMOVED***;
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***
***REMOVED***
***REMOVED***

// Register the function which deals with the matplotlib target/channel.
// The kernel may be null if the page has been refreshed.
if (IPython.notebook.kernel != null***REMOVED*** {
    IPython.notebook.kernel.comm_manager.register_target('matplotlib', mpl.mpl_figure_comm***REMOVED***;
***REMOVED***
