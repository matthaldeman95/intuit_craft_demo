/* Put everything inside the global mpl namespace */
window.mpl = {***REMOVED***;

mpl.get_websocket_type = function(***REMOVED*** {
    if (typeof(WebSocket***REMOVED*** !== 'undefined'***REMOVED*** {
        return WebSocket;
***REMOVED*** else if (typeof(MozWebSocket***REMOVED*** !== 'undefined'***REMOVED*** {
        return MozWebSocket;
***REMOVED*** else {
        alert('Your browser does not have WebSocket support.' +
              'Please try Chrome, Safari or Firefox â‰¥ 6. ' +
              'Firefox 4 and 5 are also supported but you ' +
              'have to enable WebSockets in about:config.'***REMOVED***;
***REMOVED***;
***REMOVED***

mpl.figure = function(figure_id, websocket, ondownload, parent_element***REMOVED*** {
    this.id = figure_id;

    this.ws = websocket;

    this.supports_binary = (this.ws.binaryType != undefined***REMOVED***;

    if (!this.supports_binary***REMOVED*** {
        var warnings = document.getElementById("mpl-warnings"***REMOVED***;
        if (warnings***REMOVED*** {
            warnings.style.display = 'block';
            warnings.textContent = (
                "This browser does not support binary websocket messages. " +
                    "Performance may be slow."***REMOVED***;
    ***REMOVED***
***REMOVED***

    this.imageObj = new Image(***REMOVED***;

    this.context = undefined;
    this.message = undefined;
    this.canvas = undefined;
    this.rubberband_canvas = undefined;
    this.rubberband_context = undefined;
    this.format_dropdown = undefined;

    this.image_mode = 'full';

    this.root = $('<div/>'***REMOVED***;
    this._root_extra_style(this.root***REMOVED***
    this.root.attr('style', 'display: inline-block'***REMOVED***;

    $(parent_element***REMOVED***.append(this.root***REMOVED***;

    this._init_header(this***REMOVED***;
    this._init_canvas(this***REMOVED***;
    this._init_toolbar(this***REMOVED***;

    var fig = this;

    this.waiting = false;

    this.ws.onopen =  function (***REMOVED*** {
            fig.send_message("supports_binary", {value: fig.supports_binary***REMOVED******REMOVED***;
            fig.send_message("send_image_mode", {***REMOVED******REMOVED***;
            fig.send_message("refresh", {***REMOVED******REMOVED***;
    ***REMOVED***

    this.imageObj.onload = function(***REMOVED*** {
            if (fig.image_mode == 'full'***REMOVED*** {
                // Full images could contain transparency (where diff images
                // almost always do***REMOVED***, so we need to clear the canvas so that
                // there is no ghosting.
                fig.context.clearRect(0, 0, fig.canvas.width, fig.canvas.height***REMOVED***;
        ***REMOVED***
            fig.context.drawImage(fig.imageObj, 0, 0***REMOVED***;
    ***REMOVED***;

    this.imageObj.onunload = function(***REMOVED*** {
        this.ws.close(***REMOVED***;
***REMOVED***

    this.ws.onmessage = this._make_on_message_function(this***REMOVED***;

    this.ondownload = ondownload;
***REMOVED***

mpl.figure.prototype._init_header = function(***REMOVED*** {
    var titlebar = $(
        '<div class="ui-dialog-titlebar ui-widget-header ui-corner-all ' +
        'ui-helper-clearfix"/>'***REMOVED***;
    var titletext = $(
        '<div class="ui-dialog-title" style="width: 100%; ' +
        'text-align: center; padding: 3px;"/>'***REMOVED***;
    titlebar.append(titletext***REMOVED***
    this.root.append(titlebar***REMOVED***;
    this.header = titletext[0***REMOVED***;
***REMOVED***



mpl.figure.prototype._canvas_extra_style = function(canvas_div***REMOVED*** {

***REMOVED***


mpl.figure.prototype._root_extra_style = function(canvas_div***REMOVED*** {

***REMOVED***

mpl.figure.prototype._init_canvas = function(***REMOVED*** {
    var fig = this;

    var canvas_div = $('<div/>'***REMOVED***;

    canvas_div.attr('style', 'position: relative; clear: both; outline: 0'***REMOVED***;

    function canvas_keyboard_event(event***REMOVED*** {
        return fig.key_event(event, event['data'***REMOVED******REMOVED***;
***REMOVED***

    canvas_div.keydown('key_press', canvas_keyboard_event***REMOVED***;
    canvas_div.keyup('key_release', canvas_keyboard_event***REMOVED***;
    this.canvas_div = canvas_div
    this._canvas_extra_style(canvas_div***REMOVED***
    this.root.append(canvas_div***REMOVED***;

    var canvas = $('<canvas/>'***REMOVED***;
    canvas.addClass('mpl-canvas'***REMOVED***;
    canvas.attr('style', "left: 0; top: 0; z-index: 0; outline: 0"***REMOVED***

    this.canvas = canvas[0***REMOVED***;
    this.context = canvas[0***REMOVED***.getContext("2d"***REMOVED***;

    var rubberband = $('<canvas/>'***REMOVED***;
    rubberband.attr('style', "position: absolute; left: 0; top: 0; z-index: 1;"***REMOVED***

    var pass_mouse_events = true;

    canvas_div.resizable({
        start: function(event, ui***REMOVED*** {
            pass_mouse_events = false;
***REMOVED***
        resize: function(event, ui***REMOVED*** {
            fig.request_resize(ui.size.width, ui.size.height***REMOVED***;
***REMOVED***
        stop: function(event, ui***REMOVED*** {
            pass_mouse_events = true;
            fig.request_resize(ui.size.width, ui.size.height***REMOVED***;
***REMOVED***
***REMOVED******REMOVED***;

    function mouse_event_fn(event***REMOVED*** {
        if (pass_mouse_events***REMOVED***
            return fig.mouse_event(event, event['data'***REMOVED******REMOVED***;
***REMOVED***

    rubberband.mousedown('button_press', mouse_event_fn***REMOVED***;
    rubberband.mouseup('button_release', mouse_event_fn***REMOVED***;
    // Throttle sequential mouse events to 1 every 20ms.
    rubberband.mousemove('motion_notify', mouse_event_fn***REMOVED***;

    rubberband.mouseenter('figure_enter', mouse_event_fn***REMOVED***;
    rubberband.mouseleave('figure_leave', mouse_event_fn***REMOVED***;

    canvas_div.on("wheel", function (event***REMOVED*** {
        event = event.originalEvent;
        event['data'***REMOVED*** = 'scroll'
        if (event.deltaY < 0***REMOVED*** {
            event.step = 1;
    ***REMOVED*** else {
            event.step = -1;
    ***REMOVED***
        mouse_event_fn(event***REMOVED***;
***REMOVED******REMOVED***;

    canvas_div.append(canvas***REMOVED***;
    canvas_div.append(rubberband***REMOVED***;

    this.rubberband = rubberband;
    this.rubberband_canvas = rubberband[0***REMOVED***;
    this.rubberband_context = rubberband[0***REMOVED***.getContext("2d"***REMOVED***;
    this.rubberband_context.strokeStyle = "#000000";

    this._resize_canvas = function(width, height***REMOVED*** {
        // Keep the size of the canvas, canvas container, and rubber band
        // canvas in synch.
        canvas_div.css('width', width***REMOVED***
        canvas_div.css('height', height***REMOVED***

        canvas.attr('width', width***REMOVED***;
        canvas.attr('height', height***REMOVED***;

        rubberband.attr('width', width***REMOVED***;
        rubberband.attr('height', height***REMOVED***;
***REMOVED***

    // Set the figure to an initial 600x600px, this will subsequently be updated
    // upon first draw.
    this._resize_canvas(600, 600***REMOVED***;

    // Disable right mouse context menu.
    $(this.rubberband_canvas***REMOVED***.bind("contextmenu",function(e***REMOVED***{
        return false;
***REMOVED******REMOVED***;

    function set_focus (***REMOVED*** {
        canvas.focus(***REMOVED***;
        canvas_div.focus(***REMOVED***;
***REMOVED***

    window.setTimeout(set_focus, 100***REMOVED***;
***REMOVED***

mpl.figure.prototype._init_toolbar = function(***REMOVED*** {
    var fig = this;

    var nav_element = $('<div/>'***REMOVED***
    nav_element.attr('style', 'width: 100%'***REMOVED***;
    this.root.append(nav_element***REMOVED***;

    // Define a callback function for later on.
    function toolbar_event(event***REMOVED*** {
        return fig.toolbar_button_onclick(event['data'***REMOVED******REMOVED***;
***REMOVED***
    function toolbar_mouse_event(event***REMOVED*** {
        return fig.toolbar_button_onmouseover(event['data'***REMOVED******REMOVED***;
***REMOVED***

    for(var toolbar_ind in mpl.toolbar_items***REMOVED*** {
        var name = mpl.toolbar_items[toolbar_ind***REMOVED***[0***REMOVED***;
        var tooltip = mpl.toolbar_items[toolbar_ind***REMOVED***[1***REMOVED***;
        var image = mpl.toolbar_items[toolbar_ind***REMOVED***[2***REMOVED***;
        var method_name = mpl.toolbar_items[toolbar_ind***REMOVED***[3***REMOVED***;

        if (!name***REMOVED*** {
            // put a spacer in here.
            continue;
    ***REMOVED***
        var button = $('<button/>'***REMOVED***;
        button.addClass('ui-button ui-widget ui-state-default ui-corner-all ' +
                        'ui-button-icon-only'***REMOVED***;
        button.attr('role', 'button'***REMOVED***;
        button.attr('aria-disabled', 'false'***REMOVED***;
        button.click(method_name, toolbar_event***REMOVED***;
        button.mouseover(tooltip, toolbar_mouse_event***REMOVED***;

        var icon_img = $('<span/>'***REMOVED***;
        icon_img.addClass('ui-button-icon-primary ui-icon'***REMOVED***;
        icon_img.addClass(image***REMOVED***;
        icon_img.addClass('ui-corner-all'***REMOVED***;

        var tooltip_span = $('<span/>'***REMOVED***;
        tooltip_span.addClass('ui-button-text'***REMOVED***;
        tooltip_span.html(tooltip***REMOVED***;

        button.append(icon_img***REMOVED***;
        button.append(tooltip_span***REMOVED***;

        nav_element.append(button***REMOVED***;
***REMOVED***

    var fmt_picker_span = $('<span/>'***REMOVED***;

    var fmt_picker = $('<select/>'***REMOVED***;
    fmt_picker.addClass('mpl-toolbar-option ui-widget ui-widget-content'***REMOVED***;
    fmt_picker_span.append(fmt_picker***REMOVED***;
    nav_element.append(fmt_picker_span***REMOVED***;
    this.format_dropdown = fmt_picker[0***REMOVED***;

    for (var ind in mpl.extensions***REMOVED*** {
        var fmt = mpl.extensions[ind***REMOVED***;
        var option = $(
            '<option/>', {selected: fmt === mpl.default_extension***REMOVED******REMOVED***.html(fmt***REMOVED***;
        fmt_picker.append(option***REMOVED***
***REMOVED***

    // Add hover states to the ui-buttons
    $( ".ui-button" ***REMOVED***.hover(
        function(***REMOVED*** { $(this***REMOVED***.addClass("ui-state-hover"***REMOVED***;***REMOVED***,
        function(***REMOVED*** { $(this***REMOVED***.removeClass("ui-state-hover"***REMOVED***;***REMOVED***
    ***REMOVED***;

    var status_bar = $('<span class="mpl-message"/>'***REMOVED***;
    nav_element.append(status_bar***REMOVED***;
    this.message = status_bar[0***REMOVED***;
***REMOVED***

mpl.figure.prototype.request_resize = function(x_pixels, y_pixels***REMOVED*** {
    // Request matplotlib to resize the figure. Matplotlib will then trigger a resize in the client,
    // which will in turn request a refresh of the image.
    this.send_message('resize', {'width': x_pixels, 'height': y_pixels***REMOVED******REMOVED***;
***REMOVED***

mpl.figure.prototype.send_message = function(type, properties***REMOVED*** {
    properties['type'***REMOVED*** = type;
    properties['figure_id'***REMOVED*** = this.id;
    this.ws.send(JSON.stringify(properties***REMOVED******REMOVED***;
***REMOVED***

mpl.figure.prototype.send_draw_message = function(***REMOVED*** {
    if (!this.waiting***REMOVED*** {
        this.waiting = true;
        this.ws.send(JSON.stringify({type: "draw", figure_id: this.id***REMOVED******REMOVED******REMOVED***;
***REMOVED***
***REMOVED***


mpl.figure.prototype.handle_save = function(fig, msg***REMOVED*** {
    var format_dropdown = fig.format_dropdown;
    var format = format_dropdown.options[format_dropdown.selectedIndex***REMOVED***.value;
    fig.ondownload(fig, format***REMOVED***;
***REMOVED***


mpl.figure.prototype.handle_resize = function(fig, msg***REMOVED*** {
    var size = msg['size'***REMOVED***;
    if (size[0***REMOVED*** != fig.canvas.width || size[1***REMOVED*** != fig.canvas.height***REMOVED*** {
        fig._resize_canvas(size[0***REMOVED***, size[1***REMOVED******REMOVED***;
        fig.send_message("refresh", {***REMOVED******REMOVED***;
***REMOVED***;
***REMOVED***

mpl.figure.prototype.handle_rubberband = function(fig, msg***REMOVED*** {
    var x0 = msg['x0'***REMOVED***;
    var y0 = fig.canvas.height - msg['y0'***REMOVED***;
    var x1 = msg['x1'***REMOVED***;
    var y1 = fig.canvas.height - msg['y1'***REMOVED***;
    x0 = Math.floor(x0***REMOVED*** + 0.5;
    y0 = Math.floor(y0***REMOVED*** + 0.5;
    x1 = Math.floor(x1***REMOVED*** + 0.5;
    y1 = Math.floor(y1***REMOVED*** + 0.5;
    var min_x = Math.min(x0, x1***REMOVED***;
    var min_y = Math.min(y0, y1***REMOVED***;
    var width = Math.abs(x1 - x0***REMOVED***;
    var height = Math.abs(y1 - y0***REMOVED***;

    fig.rubberband_context.clearRect(
        0, 0, fig.canvas.width, fig.canvas.height***REMOVED***;

    fig.rubberband_context.strokeRect(min_x, min_y, width, height***REMOVED***;
***REMOVED***

mpl.figure.prototype.handle_figure_label = function(fig, msg***REMOVED*** {
    // Updates the figure title.
    fig.header.textContent = msg['label'***REMOVED***;
***REMOVED***

mpl.figure.prototype.handle_cursor = function(fig, msg***REMOVED*** {
    var cursor = msg['cursor'***REMOVED***;
    switch(cursor***REMOVED***
***REMOVED***
    case 0:
        cursor = 'pointer';
        break;
    case 1:
        cursor = 'default';
        break;
    case 2:
        cursor = 'crosshair';
        break;
    case 3:
        cursor = 'move';
        break;
***REMOVED***
    fig.rubberband_canvas.style.cursor = cursor;
***REMOVED***

mpl.figure.prototype.handle_message = function(fig, msg***REMOVED*** {
    fig.message.textContent = msg['message'***REMOVED***;
***REMOVED***

mpl.figure.prototype.handle_draw = function(fig, msg***REMOVED*** {
    // Request the server to send over a new figure.
    fig.send_draw_message(***REMOVED***;
***REMOVED***

mpl.figure.prototype.handle_image_mode = function(fig, msg***REMOVED*** {
    fig.image_mode = msg['mode'***REMOVED***;
***REMOVED***

mpl.figure.prototype.updated_canvas_event = function(***REMOVED*** {
    // Called whenever the canvas gets updated.
    this.send_message("ack", {***REMOVED******REMOVED***;
***REMOVED***

// A function to construct a web socket function for onmessage handling.
// Called in the figure constructor.
mpl.figure.prototype._make_on_message_function = function(fig***REMOVED*** {
    return function socket_on_message(evt***REMOVED*** {
        if (evt.data instanceof Blob***REMOVED*** {
            /* FIXME: We get "Resource interpreted as Image but
             * transferred with MIME type text/plain:" errors on
             * Chrome.  But how to set the MIME type?  It doesn't seem
             * to be part of the websocket stream */
            evt.data.type = "image/png";

            /* Free the memory for the previous frames */
            if (fig.imageObj.src***REMOVED*** {
                (window.URL || window.webkitURL***REMOVED***.revokeObjectURL(
                    fig.imageObj.src***REMOVED***;
        ***REMOVED***

            fig.imageObj.src = (window.URL || window.webkitURL***REMOVED***.createObjectURL(
                evt.data***REMOVED***;
            fig.updated_canvas_event(***REMOVED***;
            fig.waiting = false;
            return;
    ***REMOVED***
        else if (typeof evt.data === 'string' && evt.data.slice(0, 21***REMOVED*** == "data:image/png;base64"***REMOVED*** {
            fig.imageObj.src = evt.data;
            fig.updated_canvas_event(***REMOVED***;
            fig.waiting = false;
            return;
    ***REMOVED***

        var msg = JSON.parse(evt.data***REMOVED***;
        var msg_type = msg['type'***REMOVED***;

        // Call the  "handle_{type***REMOVED***" callback, which takes
        // the figure and JSON message as its only arguments.
        try {
            var callback = fig["handle_" + msg_type***REMOVED***;
    ***REMOVED*** catch (e***REMOVED*** {
            console.log("No handler for the '" + msg_type + "' message type: ", msg***REMOVED***;
            return;
    ***REMOVED***

        if (callback***REMOVED*** {
            try {
                // console.log("Handling '" + msg_type + "' message: ", msg***REMOVED***;
                callback(fig, msg***REMOVED***;
        ***REMOVED*** catch (e***REMOVED*** {
                console.log("Exception inside the 'handler_" + msg_type + "' callback:", e, e.stack, msg***REMOVED***;
        ***REMOVED***
    ***REMOVED***
***REMOVED***;
***REMOVED***

// from http://stackoverflow.com/questions/1114465/getting-mouse-location-in-canvas
mpl.findpos = function(e***REMOVED*** {
    //this section is from http://www.quirksmode.org/js/events_properties.html
    var targ;
    if (!e***REMOVED***
        e = window.event;
    if (e.target***REMOVED***
        targ = e.target;
    else if (e.srcElement***REMOVED***
        targ = e.srcElement;
    if (targ.nodeType == 3***REMOVED*** // defeat Safari bug
        targ = targ.parentNode;

    // jQuery normalizes the pageX and pageY
    // pageX,Y are the mouse positions relative to the document
    // offset(***REMOVED*** returns the position of the element relative to the document
    var x = e.pageX - $(targ***REMOVED***.offset(***REMOVED***.left;
    var y = e.pageY - $(targ***REMOVED***.offset(***REMOVED***.top;

    return {"x": x, "y": y***REMOVED***;
***REMOVED***;

/*
 * return a copy of an object with only non-object keys
 * we need this to avoid circular references
 * http://stackoverflow.com/a/24161582/3208463
 */
function simpleKeys (original***REMOVED*** {
  return Object.keys(original***REMOVED***.reduce(function (obj, key***REMOVED*** {
    if (typeof original[key***REMOVED*** !== 'object'***REMOVED***
        obj[key***REMOVED*** = original[key***REMOVED***
    return obj;
  ***REMOVED***, {***REMOVED******REMOVED***;
***REMOVED***

mpl.figure.prototype.mouse_event = function(event, name***REMOVED*** {
    var canvas_pos = mpl.findpos(event***REMOVED***

    if (name === 'button_press'***REMOVED***
***REMOVED***
        this.canvas.focus(***REMOVED***;
        this.canvas_div.focus(***REMOVED***;
***REMOVED***

    var x = canvas_pos.x;
    var y = canvas_pos.y;

    this.send_message(name, {x: x, y: y, button: event.button,
                             step: event.step,
                             guiEvent: simpleKeys(event***REMOVED******REMOVED******REMOVED***;

    /* This prevents the web browser from automatically changing to
     * the text insertion cursor when the button is pressed.  We want
     * to control all of the cursor setting manually through the
     * 'cursor' event from matplotlib */
    event.preventDefault(***REMOVED***;
    return false;
***REMOVED***

mpl.figure.prototype._key_event_extra = function(event, name***REMOVED*** {
    // Handle any extra behaviour associated with a key event
***REMOVED***

mpl.figure.prototype.key_event = function(event, name***REMOVED*** {

    // Prevent repeat events
    if (name == 'key_press'***REMOVED***
***REMOVED***
        if (event.which === this._key***REMOVED***
            return;
        else
            this._key = event.which;
***REMOVED***
    if (name == 'key_release'***REMOVED***
        this._key = null;

    var value = '';
    if (event.ctrlKey && event.which != 17***REMOVED***
        value += "ctrl+";
    if (event.altKey && event.which != 18***REMOVED***
        value += "alt+";
    if (event.shiftKey && event.which != 16***REMOVED***
        value += "shift+";

    value += 'k';
    value += event.which.toString(***REMOVED***;

    this._key_event_extra(event, name***REMOVED***;

    this.send_message(name, {key: value,
                             guiEvent: simpleKeys(event***REMOVED******REMOVED******REMOVED***;
    return false;
***REMOVED***

mpl.figure.prototype.toolbar_button_onclick = function(name***REMOVED*** {
    if (name == 'download'***REMOVED*** {
        this.handle_save(this, null***REMOVED***;
***REMOVED*** else {
        this.send_message("toolbar_button", {name: name***REMOVED******REMOVED***;
***REMOVED***
***REMOVED***;

mpl.figure.prototype.toolbar_button_onmouseover = function(tooltip***REMOVED*** {
    this.message.textContent = tooltip;
***REMOVED***;
