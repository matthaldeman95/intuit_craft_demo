***REMOVED***
An agg http://antigrain.com/ backend

Features that are implemented

 * capstyles and join styles
 * dashes
 * linewidth
 * lines, rectangles, ellipses
 * clipping to a rectangle
 * output to RGBA and PNG, optionally JPEG and TIFF
 * alpha blending
 * DPI scaling properly - everything scales properly (dashes, linewidths, etc***REMOVED***
 * draw polygon
 * freetype2 w/ ft2font

TODO:

  * integrate screen dpi w/ ppi and text

***REMOVED***
from __future__ import (absolute_import, division, print_function,
                        unicode_literals***REMOVED***

from matplotlib.externals import six

import threading
import numpy as np
from math import radians, cos, sin
from matplotlib import verbose, rcParams
from matplotlib.backend_bases import RendererBase,\
     FigureManagerBase, FigureCanvasBase
from matplotlib.cbook import is_string_like, maxdict, restrict_dict
from matplotlib.figure import Figure
from matplotlib.font_manager import findfont
from matplotlib.ft2font import FT2Font, LOAD_FORCE_AUTOHINT, LOAD_NO_HINTING, \
     LOAD_DEFAULT, LOAD_NO_AUTOHINT
from matplotlib.mathtext import MathTextParser
from matplotlib.path import Path
from matplotlib.transforms import Bbox, BboxBase

from matplotlib.backends._backend_agg import RendererAgg as _RendererAgg
from matplotlib import _png

***REMOVED***
    from PIL import Image
    _has_pil = True
except ImportError:
    _has_pil = False

backend_version = 'v2.2'

def get_hinting_flag(***REMOVED***:
    mapping = {
        True: LOAD_FORCE_AUTOHINT,
        False: LOAD_NO_HINTING,
        'either': LOAD_DEFAULT,
        'native': LOAD_NO_AUTOHINT,
        'auto': LOAD_FORCE_AUTOHINT,
        'none': LOAD_NO_HINTING
    ***REMOVED***
    return mapping[rcParams['text.hinting'***REMOVED******REMOVED***


class RendererAgg(RendererBase***REMOVED***:
    ***REMOVED***
    The renderer handles all the drawing primitives using a graphics
    context instance that controls the colors/styles
    ***REMOVED***
    debug=1

    # we want to cache the fonts at the class level so that when
    # multiple figures are created we can reuse them.  This helps with
    # a bug on windows where the creation of too many figures leads to
    # too many open file handles.  However, storing them at the class
    # level is not thread safe.  The solution here is to let the
    # FigureCanvas acquire a lock on the fontd at the start of the
    # draw, and release it when it is done.  This allows multiple
    # renderers to share the cached fonts, but only one figure can
    # draw at at time and so the font cache is used by only one
    # renderer at a time

    lock = threading.RLock(***REMOVED***
    _fontd = maxdict(50***REMOVED***
    def __init__(self, width, height, dpi***REMOVED***:
        if __debug__: verbose.report('RendererAgg.__init__', 'debug-annoying'***REMOVED***
        RendererBase.__init__(self***REMOVED***

        self.dpi = dpi
        self.width = width
        self.height = height
        if __debug__: verbose.report('RendererAgg.__init__ width=%s, height=%s'%(width, height***REMOVED***, 'debug-annoying'***REMOVED***
        self._renderer = _RendererAgg(int(width***REMOVED***, int(height***REMOVED***, dpi, debug=False***REMOVED***
        self._filter_renderers = [***REMOVED***

        if __debug__: verbose.report('RendererAgg.__init__ _RendererAgg done',
                                     'debug-annoying'***REMOVED***

        self._update_methods(***REMOVED***
        self.mathtext_parser = MathTextParser('Agg'***REMOVED***

        self.bbox = Bbox.from_bounds(0, 0, self.width, self.height***REMOVED***
        if __debug__: verbose.report('RendererAgg.__init__ done',
                                     'debug-annoying'***REMOVED***

    def __getstate__(self***REMOVED***:
        # We only want to preserve the init keywords of the Renderer.
        # Anything else can be re-created.
        return {'width': self.width, 'height': self.height, 'dpi': self.dpi***REMOVED***

    def __setstate__(self, state***REMOVED***:
        self.__init__(state['width'***REMOVED***, state['height'***REMOVED***, state['dpi'***REMOVED******REMOVED***

    def _get_hinting_flag(self***REMOVED***:
        if rcParams['text.hinting'***REMOVED***:
            return LOAD_FORCE_AUTOHINT
        else:
            return LOAD_NO_HINTING

    # for filtering to work with rasterization, methods needs to be wrapped.
    # maybe there is better way to do it.
    def draw_markers(self, *kl, **kw***REMOVED***:
        return self._renderer.draw_markers(*kl, **kw***REMOVED***

    def draw_path_collection(self, *kl, **kw***REMOVED***:
        return self._renderer.draw_path_collection(*kl, **kw***REMOVED***

    def _update_methods(self***REMOVED***:
        self.draw_quad_mesh = self._renderer.draw_quad_mesh
        self.draw_gouraud_triangle = self._renderer.draw_gouraud_triangle
        self.draw_gouraud_triangles = self._renderer.draw_gouraud_triangles
        self.draw_image = self._renderer.draw_image
        self.copy_from_bbox = self._renderer.copy_from_bbox
        self.get_content_extents = self._renderer.get_content_extents

    def tostring_rgba_minimized(self***REMOVED***:
        extents = self.get_content_extents(***REMOVED***
        bbox = [[extents[0***REMOVED***, self.height - (extents[1***REMOVED*** + extents[3***REMOVED******REMOVED******REMOVED***,
                [extents[0***REMOVED*** + extents[2***REMOVED***, self.height - extents[1***REMOVED******REMOVED******REMOVED***
        region = self.copy_from_bbox(bbox***REMOVED***
        return np.array(region***REMOVED***, extents

    def draw_path(self, gc, path, transform, rgbFace=None***REMOVED***:
        ***REMOVED***
        Draw the path
        ***REMOVED***
        nmax = rcParams['agg.path.chunksize'***REMOVED*** # here at least for testing
        npts = path.vertices.shape[0***REMOVED***
        if (nmax > 100 and npts > nmax and path.should_simplify and
                rgbFace is None and gc.get_hatch(***REMOVED*** is None***REMOVED***:
            nch = np.ceil(npts/float(nmax***REMOVED******REMOVED***
            chsize = int(np.ceil(npts/nch***REMOVED******REMOVED***
            i0 = np.arange(0, npts, chsize***REMOVED***
            i1 = np.zeros_like(i0***REMOVED***
            i1[:-1***REMOVED*** = i0[1:***REMOVED*** - 1
            i1[-1***REMOVED*** = npts
            for ii0, ii1 in zip(i0, i1***REMOVED***:
                v = path.vertices[ii0:ii1,:***REMOVED***
                c = path.codes
                if c is not None:
                    c = c[ii0:ii1***REMOVED***
                    c[0***REMOVED*** = Path.MOVETO # move to end of last chunk
                p = Path(v, c***REMOVED***
                self._renderer.draw_path(gc, p, transform, rgbFace***REMOVED***
        else:
            self._renderer.draw_path(gc, path, transform, rgbFace***REMOVED***

    def draw_mathtext(self, gc, x, y, s, prop, angle***REMOVED***:
        ***REMOVED***
        Draw the math text using matplotlib.mathtext
        ***REMOVED***
        if __debug__: verbose.report('RendererAgg.draw_mathtext',
                                     'debug-annoying'***REMOVED***
        ox, oy, width, height, descent, font_image, used_characters = \
            self.mathtext_parser.parse(s, self.dpi, prop***REMOVED***

        xd = descent * sin(radians(angle***REMOVED******REMOVED***
        yd = descent * cos(radians(angle***REMOVED******REMOVED***
        x = round(x + ox + xd***REMOVED***
        y = round(y - oy + yd***REMOVED***
        self._renderer.draw_text_image(font_image, x, y + 1, angle, gc***REMOVED***

    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None***REMOVED***:
        ***REMOVED***
        Render the text
        ***REMOVED***
        if __debug__: verbose.report('RendererAgg.draw_text', 'debug-annoying'***REMOVED***

        if ismath:
            return self.draw_mathtext(gc, x, y, s, prop, angle***REMOVED***

        flags = get_hinting_flag(***REMOVED***
        font = self._get_agg_font(prop***REMOVED***
        if font is None: return None
        if len(s***REMOVED*** == 1 and ord(s***REMOVED*** > 127:
            font.load_char(ord(s***REMOVED***, flags=flags***REMOVED***
        else:
            # We pass '0' for angle here, since it will be rotated (in raster
            # space***REMOVED*** in the following call to draw_text_image***REMOVED***.
            font.set_text(s, 0, flags=flags***REMOVED***
        font.draw_glyphs_to_bitmap(antialiased=rcParams['text.antialiased'***REMOVED******REMOVED***
        d = font.get_descent(***REMOVED*** / 64.0
        # The descent needs to be adjusted for the angle
        xo, yo = font.get_bitmap_offset(***REMOVED***
        xo /= 64.0
        yo /= 64.0
        xd = -d * sin(radians(angle***REMOVED******REMOVED***
        yd = d * cos(radians(angle***REMOVED******REMOVED***

        #print x, y, int(x***REMOVED***, int(y***REMOVED***, s
        self._renderer.draw_text_image(
            font, round(x - xd + xo***REMOVED***, round(y + yd + yo***REMOVED*** + 1, angle, gc***REMOVED***

    def get_text_width_height_descent(self, s, prop, ismath***REMOVED***:
        ***REMOVED***
        get the width and height in display coords of the string s
        with FontPropertry prop

        # passing rgb is a little hack to make caching in the
        # texmanager more efficient.  It is not meant to be used
        # outside the backend
        ***REMOVED***
        if rcParams['text.usetex'***REMOVED***:
            # todo: handle props
            size = prop.get_size_in_points(***REMOVED***
            texmanager = self.get_texmanager(***REMOVED***
            fontsize = prop.get_size_in_points(***REMOVED***
            w, h, d = texmanager.get_text_width_height_descent(s, fontsize,
                                                               renderer=self***REMOVED***
            return w, h, d

        if ismath:
            ox, oy, width, height, descent, fonts, used_characters = \
                self.mathtext_parser.parse(s, self.dpi, prop***REMOVED***
            return width, height, descent

        flags = get_hinting_flag(***REMOVED***
        font = self._get_agg_font(prop***REMOVED***
        font.set_text(s, 0.0, flags=flags***REMOVED***  # the width and height of unrotated string
        w, h = font.get_width_height(***REMOVED***
        d = font.get_descent(***REMOVED***
        w /= 64.0  # convert from subpixels
        h /= 64.0
        d /= 64.0
        return w, h, d

    def draw_tex(self, gc, x, y, s, prop, angle, ismath='TeX!', mtext=None***REMOVED***:
        # todo, handle props, angle, origins
        size = prop.get_size_in_points(***REMOVED***

        texmanager = self.get_texmanager(***REMOVED***

        Z = texmanager.get_grey(s, size, self.dpi***REMOVED***
        Z = np.array(Z * 255.0, np.uint8***REMOVED***

        w, h, d = self.get_text_width_height_descent(s, prop, ismath***REMOVED***
        xd = d * sin(radians(angle***REMOVED******REMOVED***
        yd = d * cos(radians(angle***REMOVED******REMOVED***
        x = round(x + xd***REMOVED***
        y = round(y + yd***REMOVED***

        self._renderer.draw_text_image(Z, x, y, angle, gc***REMOVED***

    def get_canvas_width_height(self***REMOVED***:
        'return the canvas width and height in display coords'
        return self.width, self.height

    def _get_agg_font(self, prop***REMOVED***:
        ***REMOVED***
        Get the font for text instance t, cacheing for efficiency
        ***REMOVED***
        if __debug__: verbose.report('RendererAgg._get_agg_font',
                                     'debug-annoying'***REMOVED***

        key = hash(prop***REMOVED***
        font = RendererAgg._fontd.get(key***REMOVED***

        if font is None:
            fname = findfont(prop***REMOVED***
            font = RendererAgg._fontd.get(fname***REMOVED***
            if font is None:
                font = FT2Font(
                    fname,
                    hinting_factor=rcParams['text.hinting_factor'***REMOVED******REMOVED***
                RendererAgg._fontd[fname***REMOVED*** = font
            RendererAgg._fontd[key***REMOVED*** = font

        font.clear(***REMOVED***
        size = prop.get_size_in_points(***REMOVED***
        font.set_size(size, self.dpi***REMOVED***

        return font

    def points_to_pixels(self, points***REMOVED***:
        ***REMOVED***
        convert point measures to pixes using dpi and the pixels per
        inch of the display
        ***REMOVED***
        if __debug__: verbose.report('RendererAgg.points_to_pixels',
                                     'debug-annoying'***REMOVED***
        return points*self.dpi/72.0

    def tostring_rgb(self***REMOVED***:
        if __debug__: verbose.report('RendererAgg.tostring_rgb',
                                     'debug-annoying'***REMOVED***
        return self._renderer.tostring_rgb(***REMOVED***

    def tostring_argb(self***REMOVED***:
        if __debug__: verbose.report('RendererAgg.tostring_argb',
                                     'debug-annoying'***REMOVED***
        return self._renderer.tostring_argb(***REMOVED***

    def buffer_rgba(self***REMOVED***:
        if __debug__: verbose.report('RendererAgg.buffer_rgba',
                                     'debug-annoying'***REMOVED***
        return self._renderer.buffer_rgba(***REMOVED***

    def clear(self***REMOVED***:
        self._renderer.clear(***REMOVED***

    def option_image_nocomposite(self***REMOVED***:
        # It is generally faster to composite each image directly to
        # the Figure, and there's no file size benefit to compositing
        # with the Agg backend
        return True

    def option_scale_image(self***REMOVED***:
        ***REMOVED***
        agg backend support arbitrary scaling of image.
        ***REMOVED***
        return True

    def restore_region(self, region, bbox=None, xy=None***REMOVED***:
        ***REMOVED***
        Restore the saved region. If bbox (instance of BboxBase, or
        its extents***REMOVED*** is given, only the region specified by the bbox
        will be restored. *xy* (a tuple of two floasts***REMOVED*** optionally
        specifies the new position (the LLC of the original region,
        not the LLC of the bbox***REMOVED*** where the region will be restored.

        >>> region = renderer.copy_from_bbox(***REMOVED***
        >>> x1, y1, x2, y2 = region.get_extents(***REMOVED***
        >>> renderer.restore_region(region, bbox=(x1+dx, y1, x2, y2***REMOVED***,
        ...                         xy=(x1-dx, y1***REMOVED******REMOVED***

        ***REMOVED***
        if bbox is not None or xy is not None:
            if bbox is None:
                x1, y1, x2, y2 = region.get_extents(***REMOVED***
            elif isinstance(bbox, BboxBase***REMOVED***:
                x1, y1, x2, y2 = bbox.extents
            else:
                x1, y1, x2, y2 = bbox

            if xy is None:
                ox, oy = x1, y1
            else:
                ox, oy = xy

            # The incoming data is float, but the _renderer type-checking wants
            # to see integers.
            self._renderer.restore_region(region, int(x1***REMOVED***, int(y1***REMOVED***,
                                          int(x2***REMOVED***, int(y2***REMOVED***, int(ox***REMOVED***, int(oy***REMOVED******REMOVED***

        else:
            self._renderer.restore_region(region***REMOVED***

    def start_filter(self***REMOVED***:
        ***REMOVED***
        Start filtering. It simply create a new canvas (the old one is saved***REMOVED***.
        ***REMOVED***
        self._filter_renderers.append(self._renderer***REMOVED***
        self._renderer = _RendererAgg(int(self.width***REMOVED***, int(self.height***REMOVED***,
                                      self.dpi***REMOVED***
        self._update_methods(***REMOVED***

    def stop_filter(self, post_processing***REMOVED***:
        ***REMOVED***
        Save the plot in the current canvas as a image and apply
        the *post_processing* function.

           def post_processing(image, dpi***REMOVED***:
             # ny, nx, depth = image.shape
             # image (numpy array***REMOVED*** has RGBA channels and has a depth of 4.
             ...
             # create a new_image (numpy array of 4 channels, size can be
             # different***REMOVED***. The resulting image may have offsets from
             # lower-left corner of the original image
             return new_image, offset_x, offset_y

        The saved renderer is restored and the returned image from
        post_processing is plotted (using draw_image***REMOVED*** on it.
        ***REMOVED***

        # WARNING.
        # For agg_filter to work, the rendere's method need
        # to overridden in the class. See draw_markers, and draw_path_collections

        from matplotlib._image import fromarray

        width, height = int(self.width***REMOVED***, int(self.height***REMOVED***

        buffer, bounds = self.tostring_rgba_minimized(***REMOVED***

        l, b, w, h = bounds


        self._renderer = self._filter_renderers.pop(***REMOVED***
        self._update_methods(***REMOVED***

        if w > 0 and h > 0:
            img = np.fromstring(buffer, np.uint8***REMOVED***
            img, ox, oy = post_processing(img.reshape((h, w, 4***REMOVED******REMOVED*** / 255.,
                                          self.dpi***REMOVED***
            image = fromarray(img, 1***REMOVED***

            gc = self.new_gc(***REMOVED***
            self._renderer.draw_image(gc,
                                      l+ox, height - b - h +oy,
                                      image***REMOVED***


def new_figure_manager(num, *args, **kwargs***REMOVED***:
    ***REMOVED***
    Create a new figure manager instance
    ***REMOVED***
    if __debug__: verbose.report('backend_agg.new_figure_manager',
                                 'debug-annoying'***REMOVED***


    FigureClass = kwargs.pop('FigureClass', Figure***REMOVED***
    thisFig = FigureClass(*args, **kwargs***REMOVED***
    return new_figure_manager_given_figure(num, thisFig***REMOVED***


def new_figure_manager_given_figure(num, figure***REMOVED***:
    ***REMOVED***
    Create a new figure manager instance for the given figure.
    ***REMOVED***
    canvas = FigureCanvasAgg(figure***REMOVED***
    manager = FigureManagerBase(canvas, num***REMOVED***
    return manager


class FigureCanvasAgg(FigureCanvasBase***REMOVED***:
    ***REMOVED***
    The canvas the figure renders into.  Calls the draw and print fig
    methods, creates the renderers, etc...

    Public attribute

      figure - A Figure instance
    ***REMOVED***

    def copy_from_bbox(self, bbox***REMOVED***:
        renderer = self.get_renderer(***REMOVED***
        return renderer.copy_from_bbox(bbox***REMOVED***

    def restore_region(self, region, bbox=None, xy=None***REMOVED***:
        renderer = self.get_renderer(***REMOVED***
        return renderer.restore_region(region, bbox, xy***REMOVED***

    def draw(self***REMOVED***:
        ***REMOVED***
        Draw the figure using the renderer
        ***REMOVED***
        if __debug__: verbose.report('FigureCanvasAgg.draw', 'debug-annoying'***REMOVED***

        self.renderer = self.get_renderer(cleared=True***REMOVED***
        # acquire a lock on the shared font cache
        RendererAgg.lock.acquire(***REMOVED***

        ***REMOVED***
            self.figure.draw(self.renderer***REMOVED***
        finally:
            RendererAgg.lock.release(***REMOVED***

    def get_renderer(self, cleared=False***REMOVED***:
        l, b, w, h = self.figure.bbox.bounds
        key = w, h, self.figure.dpi
        ***REMOVED*** self._lastKey, self.renderer
        except AttributeError: need_new_renderer = True
        else:  need_new_renderer = (self._lastKey != key***REMOVED***

        if need_new_renderer:
            self.renderer = RendererAgg(w, h, self.figure.dpi***REMOVED***
            self._lastKey = key
        elif cleared:
            self.renderer.clear(***REMOVED***
        return self.renderer

    def tostring_rgb(self***REMOVED***:
        if __debug__: verbose.report('FigureCanvasAgg.tostring_rgb',
                                     'debug-annoying'***REMOVED***
        return self.renderer.tostring_rgb(***REMOVED***

    def tostring_argb(self***REMOVED***:
        if __debug__: verbose.report('FigureCanvasAgg.tostring_argb',
                                     'debug-annoying'***REMOVED***
        return self.renderer.tostring_argb(***REMOVED***

    def buffer_rgba(self***REMOVED***:
        if __debug__: verbose.report('FigureCanvasAgg.buffer_rgba',
                                     'debug-annoying'***REMOVED***
        return self.renderer.buffer_rgba(***REMOVED***

    def print_raw(self, filename_or_obj, *args, **kwargs***REMOVED***:
        FigureCanvasAgg.draw(self***REMOVED***
        renderer = self.get_renderer(***REMOVED***
        original_dpi = renderer.dpi
        renderer.dpi = self.figure.dpi
        if is_string_like(filename_or_obj***REMOVED***:
            fileobj = open(filename_or_obj, 'wb'***REMOVED***
            close = True
        else:
            fileobj = filename_or_obj
            close = False
        ***REMOVED***
            fileobj.write(renderer._renderer.buffer_rgba(***REMOVED******REMOVED***
        finally:
            if close:
                fileobj.close(***REMOVED***
            renderer.dpi = original_dpi
    print_rgba = print_raw

    def print_png(self, filename_or_obj, *args, **kwargs***REMOVED***:
        FigureCanvasAgg.draw(self***REMOVED***
        renderer = self.get_renderer(***REMOVED***
        original_dpi = renderer.dpi
        renderer.dpi = self.figure.dpi
        if is_string_like(filename_or_obj***REMOVED***:
            filename_or_obj = open(filename_or_obj, 'wb'***REMOVED***
            close = True
        else:
            close = False
        ***REMOVED***
            _png.write_png(renderer._renderer, filename_or_obj, self.figure.dpi***REMOVED***
        finally:
            if close:
                filename_or_obj.close(***REMOVED***
        renderer.dpi = original_dpi

    def print_to_buffer(self***REMOVED***:
        FigureCanvasAgg.draw(self***REMOVED***
        renderer = self.get_renderer(***REMOVED***
        original_dpi = renderer.dpi
        renderer.dpi = self.figure.dpi
        result = (renderer._renderer.buffer_rgba(***REMOVED***,
                  (int(renderer.width***REMOVED***, int(renderer.height***REMOVED******REMOVED******REMOVED***
        renderer.dpi = original_dpi
        return result

    if _has_pil:

        # add JPEG support
        def print_jpg(self, filename_or_obj, *args, **kwargs***REMOVED***:
            ***REMOVED***
            Supported kwargs:

            *quality*: The image quality, on a scale from 1 (worst***REMOVED*** to
                95 (best***REMOVED***. The default is 95, if not given in the
                matplotlibrc file in the savefig.jpeg_quality parameter.
                Values above 95 should be avoided; 100 completely
                disables the JPEG quantization stage.

            *optimize*: If present, indicates that the encoder should
                make an extra pass over the image in order to select
                optimal encoder settings.

            *progressive*: If present, indicates that this image
                should be stored as a progressive JPEG file.
            ***REMOVED***
            buf, size = self.print_to_buffer(***REMOVED***
            if kwargs.pop("dryrun", False***REMOVED***:
                return
            image = Image.frombuffer('RGBA', size, buf, 'raw', 'RGBA', 0, 1***REMOVED***
            options = restrict_dict(kwargs, ['quality', 'optimize',
                                             'progressive'***REMOVED******REMOVED***

            if 'quality' not in options:
                options['quality'***REMOVED*** = rcParams['savefig.jpeg_quality'***REMOVED***

            return image.save(filename_or_obj, format='jpeg', **options***REMOVED***
        print_jpeg = print_jpg

        # add TIFF support
        def print_tif(self, filename_or_obj, *args, **kwargs***REMOVED***:
            buf, size = self.print_to_buffer(***REMOVED***
            if kwargs.pop("dryrun", False***REMOVED***:
                return
            image = Image.frombuffer('RGBA', size, buf, 'raw', 'RGBA', 0, 1***REMOVED***
            dpi = (self.figure.dpi, self.figure.dpi***REMOVED***
            return image.save(filename_or_obj, format='tiff',
                              dpi=dpi***REMOVED***
        print_tiff = print_tif


FigureCanvas = FigureCanvasAgg
