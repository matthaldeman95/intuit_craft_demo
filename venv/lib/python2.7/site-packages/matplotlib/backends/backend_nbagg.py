***REMOVED***Interactive figures in the IPython notebook***REMOVED***
# Note: There is a notebook in
# lib/matplotlib/backends/web_backend/nbagg_uat.ipynb to help verify
# that changes made maintain expected behaviour.

import datetime
from base64 import b64encode
import json
import io
***REMOVED***
from matplotlib.externals import six
from uuid import uuid4 as uuid

import tornado.ioloop

from IPython.display import display, Javascript, HTML
***REMOVED***
    # Jupyter/IPython 4.x or later
    from ipykernel.comm import Comm
except ImportError:
    # Jupyter/IPython 3.x or earlier
    from IPython.kernel.comm import Comm

from matplotlib import rcParams
from matplotlib.figure import Figure
from matplotlib import is_interactive
from matplotlib.backends.backend_webagg_core import (FigureManagerWebAgg,
                                                     FigureCanvasWebAggCore,
                                                     NavigationToolbar2WebAgg,
                                                     TimerTornado***REMOVED***
from matplotlib.backend_bases import (ShowBase, NavigationToolbar2,
                                      FigureCanvasBase***REMOVED***


class Show(ShowBase***REMOVED***:
    def __call__(self, block=None***REMOVED***:
        from matplotlib._pylab_helpers import Gcf

        managers = Gcf.get_all_fig_managers(***REMOVED***
        if not managers:
            return

        interactive = is_interactive(***REMOVED***

        for manager in managers:
            manager.show(***REMOVED***

            # plt.figure adds an event which puts the figure in focus
            # in the activeQue. Disable this behaviour, as it results in
            # figures being put as the active figure after they have been
            # shown, even in non-interactive mode.
            if hasattr(manager, '_cidgcf'***REMOVED***:
                manager.canvas.mpl_disconnect(manager._cidgcf***REMOVED***

            if not interactive and manager in Gcf._activeQue:
                Gcf._activeQue.remove(manager***REMOVED***

show = Show(***REMOVED***


def draw_if_interactive(***REMOVED***:
    import matplotlib._pylab_helpers as pylab_helpers

    if is_interactive(***REMOVED***:
        manager = pylab_helpers.Gcf.get_active(***REMOVED***
        if manager is not None:
            manager.show(***REMOVED***


def connection_info(***REMOVED***:
    ***REMOVED***
    Return a string showing the figure and connection status for
    the backend. This is intended as a diagnostic tool, and not for general
    use.

    ***REMOVED***
    from matplotlib._pylab_helpers import Gcf
    result = [***REMOVED***
    for manager in Gcf.get_all_fig_managers(***REMOVED***:
        fig = manager.canvas.figure
        result.append('{0***REMOVED*** - {0***REMOVED***'.format((fig.get_label(***REMOVED*** or
                                          "Figure {0***REMOVED***".format(manager.num***REMOVED******REMOVED***,
                                         manager.web_sockets***REMOVED******REMOVED***
    if not is_interactive(***REMOVED***:
        result.append('Figures pending show: {0***REMOVED***'.format(len(Gcf._activeQue***REMOVED******REMOVED******REMOVED***
    return '\n'.join(result***REMOVED***


# Note: Version 3.2 and 4.x icons
# http://fontawesome.io/3.2.1/icons/
# http://fontawesome.io/
# the `fa fa-xxx` part targets font-awesome 4, (IPython 3.x***REMOVED***
# the icon-xxx targets font awesome 3.21 (IPython 2.x***REMOVED***
_FONT_AWESOME_CLASSES = {
    'home': 'fa fa-home icon-home',
    'back': 'fa fa-arrow-left icon-arrow-left',
    'forward': 'fa fa-arrow-right icon-arrow-right',
    'zoom_to_rect': 'fa fa-square-o icon-check-empty',
    'move': 'fa fa-arrows icon-move',
    'download': 'fa fa-floppy-o icon-save',
    None: None
***REMOVED***


class NavigationIPy(NavigationToolbar2WebAgg***REMOVED***:

    # Use the standard toolbar items + download button
    toolitems = [(text, tooltip_text,
                  _FONT_AWESOME_CLASSES[image_file***REMOVED***, name_of_method***REMOVED***
                 for text, tooltip_text, image_file, name_of_method
                 in (NavigationToolbar2.toolitems +
                     (('Download', 'Download plot', 'download', 'download'***REMOVED***,***REMOVED******REMOVED***
                 if image_file in _FONT_AWESOME_CLASSES***REMOVED***


class FigureManagerNbAgg(FigureManagerWebAgg***REMOVED***:
    ToolbarCls = NavigationIPy

    def __init__(self, canvas, num***REMOVED***:
        self._shown = False
        FigureManagerWebAgg.__init__(self, canvas, num***REMOVED***

    def display_js(self***REMOVED***:
        # XXX How to do this just once? It has to deal with multiple
        # browser instances using the same kernel (require.js - but the
        # file isn't static?***REMOVED***.
        display(Javascript(FigureManagerNbAgg.get_javascript(***REMOVED******REMOVED******REMOVED***

    def show(self***REMOVED***:
        if not self._shown:
            self.display_js(***REMOVED***
            self._create_comm(***REMOVED***
        else:
            self.canvas.draw_idle(***REMOVED***
        self._shown = True

    def reshow(self***REMOVED***:
        ***REMOVED***
        A special method to re-show the figure in the notebook.

        ***REMOVED***
        self._shown = False
        self.show(***REMOVED***

    @property
    def connected(self***REMOVED***:
        return bool(self.web_sockets***REMOVED***

    @classmethod
    def get_javascript(cls, stream=None***REMOVED***:
        if stream is None:
            output = io.StringIO(***REMOVED***
        else:
            output = stream
        super(FigureManagerNbAgg, cls***REMOVED***.get_javascript(stream=output***REMOVED***
        with io.open(os.path.join(
                os.path.dirname(__file__***REMOVED***,
                "web_backend",
                "nbagg_mpl.js"***REMOVED***, encoding='utf8'***REMOVED*** as fd:
            output.write(fd.read(***REMOVED******REMOVED***
        if stream is None:
            return output.getvalue(***REMOVED***

    def _create_comm(self***REMOVED***:
        comm = CommSocket(self***REMOVED***
        self.add_web_socket(comm***REMOVED***
        return comm

    def destroy(self***REMOVED***:
        self._send_event('close'***REMOVED***
        # need to copy comms as callbacks will modify this list
        for comm in list(self.web_sockets***REMOVED***:
            comm.on_close(***REMOVED***
        self.clearup_closed(***REMOVED***

    def clearup_closed(self***REMOVED***:
        ***REMOVED***Clear up any closed Comms.***REMOVED***
        self.web_sockets = set([socket for socket in self.web_sockets
                                if socket.is_open(***REMOVED******REMOVED******REMOVED***

        if len(self.web_sockets***REMOVED*** == 0:
            self.canvas.close_event(***REMOVED***

    def remove_comm(self, comm_id***REMOVED***:
        self.web_sockets = set([socket for socket in self.web_sockets
                                if not socket.comm.comm_id == comm_id***REMOVED******REMOVED***


class FigureCanvasNbAgg(FigureCanvasWebAggCore***REMOVED***:
    def new_timer(self, *args, **kwargs***REMOVED***:
        return TimerTornado(*args, **kwargs***REMOVED***

    def start_event_loop(self, timeout***REMOVED***:
        FigureCanvasBase.start_event_loop_default(self, timeout***REMOVED***

    def stop_event_loop(self***REMOVED***:
        FigureCanvasBase.stop_event_loop_default(self***REMOVED***


def new_figure_manager(num, *args, **kwargs***REMOVED***:
    ***REMOVED***
    Create a new figure manager instance
    ***REMOVED***
    FigureClass = kwargs.pop('FigureClass', Figure***REMOVED***
    thisFig = FigureClass(*args, **kwargs***REMOVED***
    return new_figure_manager_given_figure(num, thisFig***REMOVED***


def new_figure_manager_given_figure(num, figure***REMOVED***:
    ***REMOVED***
    Create a new figure manager instance for the given figure.
    ***REMOVED***
    from .._pylab_helpers import Gcf

    def closer(event***REMOVED***:
        Gcf.destroy(num***REMOVED***

    canvas = FigureCanvasNbAgg(figure***REMOVED***
    if rcParams['nbagg.transparent'***REMOVED***:
        figure.patch.set_alpha(0***REMOVED***
    manager = FigureManagerNbAgg(canvas, num***REMOVED***

    if is_interactive(***REMOVED***:
        manager.show(***REMOVED***
        figure.canvas.draw_idle(***REMOVED***

    canvas.mpl_connect('close_event', closer***REMOVED***

    return manager


class CommSocket(object***REMOVED***:
    ***REMOVED***
    Manages the Comm connection between IPython and the browser (client***REMOVED***.

    Comms are 2 way, with the CommSocket being able to publish a message
    via the send_json method, and handle a message with on_message. On the
    JS side figure.send_message and figure.ws.onmessage do the sending and
    receiving respectively.

    ***REMOVED***
    def __init__(self, manager***REMOVED***:
        self.supports_binary = None
        self.manager = manager
        self.uuid = str(uuid(***REMOVED******REMOVED***
        # Publish an output area with a unique ID. The javascript can then
        # hook into this area.
        display(HTML("<div id=%r></div>" % self.uuid***REMOVED******REMOVED***
        ***REMOVED***
            self.comm = Comm('matplotlib', data={'id': self.uuid***REMOVED******REMOVED***
        except AttributeError:
            raise RuntimeError('Unable to create an IPython notebook Comm '
                               'instance. Are you in the IPython notebook?'***REMOVED***
        self.comm.on_msg(self.on_message***REMOVED***

        manager = self.manager
        self._ext_close = False

        def _on_close(close_message***REMOVED***:
            self._ext_close = True
            manager.remove_comm(close_message['content'***REMOVED***['comm_id'***REMOVED******REMOVED***
            manager.clearup_closed(***REMOVED***

        self.comm.on_close(_on_close***REMOVED***

    def is_open(self***REMOVED***:
        return not (self._ext_close or self.comm._closed***REMOVED***

    def on_close(self***REMOVED***:
        # When the socket is closed, deregister the websocket with
        # the FigureManager.
        if self.is_open(***REMOVED***:
            ***REMOVED***
                self.comm.close(***REMOVED***
            except KeyError:
                # apparently already cleaned it up?
                pass

    def send_json(self, content***REMOVED***:
        self.comm.send({'data': json.dumps(content***REMOVED******REMOVED******REMOVED***

    def send_binary(self, blob***REMOVED***:
        # The comm is ascii, so we always send the image in base64
        # encoded data URL form.
        data = b64encode(blob***REMOVED***
        if six.PY3:
            data = data.decode('ascii'***REMOVED***
        data_uri = "data:image/png;base64,{0***REMOVED***".format(data***REMOVED***
        self.comm.send({'data': data_uri***REMOVED******REMOVED***

    def on_message(self, message***REMOVED***:
        # The 'supports_binary' message is relevant to the
        # websocket itself.  The other messages get passed along
        # to matplotlib as-is.

        # Every message has a "type" and a "figure_id".
        message = json.loads(message['content'***REMOVED***['data'***REMOVED******REMOVED***
        if message['type'***REMOVED*** == 'closing':
            self.on_close(***REMOVED***
            self.manager.clearup_closed(***REMOVED***
        elif message['type'***REMOVED*** == 'supports_binary':
            self.supports_binary = message['value'***REMOVED***
        else:
            self.manager.handle_json(message***REMOVED***
