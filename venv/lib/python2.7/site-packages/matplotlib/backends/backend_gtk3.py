from __future__ import (absolute_import, division, print_function,
                        unicode_literals***REMOVED***

from matplotlib.externals import six

***REMOVED***, sys
def fn_name(***REMOVED***: return sys._getframe(1***REMOVED***.f_code.co_name

***REMOVED***
    import gi
except ImportError:
    raise ImportError("Gtk3 backend requires pygobject to be installed."***REMOVED***

***REMOVED***
    gi.require_version("Gtk", "3.0"***REMOVED***
except AttributeError:
    raise ImportError(
        "pygobject version too old -- it must have require_version"***REMOVED***
except ValueError:
    raise ImportError(
        "Gtk3 backend requires the GObject introspection bindings for Gtk 3 "
        "to be installed."***REMOVED***

***REMOVED***
    from gi.repository import Gtk, Gdk, GObject, GLib
except ImportError:
    raise ImportError("Gtk3 backend requires pygobject to be installed."***REMOVED***

import matplotlib
from matplotlib._pylab_helpers import Gcf
from matplotlib.backend_bases import RendererBase, GraphicsContextBase, \
     FigureManagerBase, FigureCanvasBase, NavigationToolbar2, cursors, TimerBase
from matplotlib.backend_bases import (ShowBase, ToolContainerBase,
                                      StatusbarBase***REMOVED***
from matplotlib.backend_managers import ToolManager
from matplotlib import backend_tools

from matplotlib.cbook import is_string_like, is_writable_file_like
from matplotlib.colors import colorConverter
from matplotlib.figure import Figure
from matplotlib.widgets import SubplotTool

from matplotlib import lines
from matplotlib import cbook
from matplotlib import verbose
from matplotlib import rcParams

backend_version = "%s.%s.%s" % (Gtk.get_major_version(***REMOVED***, Gtk.get_micro_version(***REMOVED***, Gtk.get_minor_version(***REMOVED******REMOVED***

_debug = False
#_debug = True

# the true dots per inch on the screen; should be display dependent
# see http://groups.google.com/groups?q=screen+dpi+x11&hl=en&lr=&ie=UTF-8&oe=UTF-8&safe=off&selm=7077.26e81ad5%40swift.cs.tcd.ie&rnum=5 for some info about screen dpi
PIXELS_PER_INCH = 96

cursord = {
    cursors.MOVE          : Gdk.Cursor.new(Gdk.CursorType.FLEUR***REMOVED***,
    cursors.HAND          : Gdk.Cursor.new(Gdk.CursorType.HAND2***REMOVED***,
    cursors.POINTER       : Gdk.Cursor.new(Gdk.CursorType.LEFT_PTR***REMOVED***,
    cursors.SELECT_REGION : Gdk.Cursor.new(Gdk.CursorType.TCROSS***REMOVED***,
***REMOVED***

def draw_if_interactive(***REMOVED***:
    ***REMOVED***
    Is called after every pylab drawing command
    ***REMOVED***
    if matplotlib.is_interactive(***REMOVED***:
        figManager =  Gcf.get_active(***REMOVED***
        if figManager is not None:
            figManager.canvas.draw_idle(***REMOVED***

class Show(ShowBase***REMOVED***:
    def mainloop(self***REMOVED***:
        if Gtk.main_level(***REMOVED*** == 0:
            Gtk.main(***REMOVED***

show = Show(***REMOVED***


class TimerGTK3(TimerBase***REMOVED***:
    '''
    Subclass of :class:`backend_bases.TimerBase` that uses GTK3 for timer events.

    Attributes:
    * interval: The time between timer events in milliseconds. Default
        is 1000 ms.
    * single_shot: Boolean flag indicating whether this timer should
        operate as single shot (run once and then stop***REMOVED***. Defaults to False.
    * callbacks: Stores list of (func, args***REMOVED*** tuples that will be called
        upon timer events. This list can be manipulated directly, or the
        functions add_callback and remove_callback can be used.
    '''
    def _timer_start(self***REMOVED***:
        # Need to stop it, otherwise we potentially leak a timer id that will
        # never be stopped.
        self._timer_stop(***REMOVED***
        self._timer = GLib.timeout_add(self._interval, self._on_timer***REMOVED***

    def _timer_stop(self***REMOVED***:
        if self._timer is not None:
            GLib.source_remove(self._timer***REMOVED***
            self._timer = None

    def _timer_set_interval(self***REMOVED***:
        # Only stop and restart it if the timer has already been started
        if self._timer is not None:
            self._timer_stop(***REMOVED***
            self._timer_start(***REMOVED***

    def _on_timer(self***REMOVED***:
        TimerBase._on_timer(self***REMOVED***

        # Gtk timeout_add(***REMOVED*** requires that the callback returns True if it
        # is to be called again.
        if len(self.callbacks***REMOVED*** > 0 and not self._single:
            return True
        else:
            self._timer = None
            return False

class FigureCanvasGTK3 (Gtk.DrawingArea, FigureCanvasBase***REMOVED***:
    keyvald = {65507 : 'control',
               65505 : 'shift',
               65513 : 'alt',
               65508 : 'control',
               65506 : 'shift',
               65514 : 'alt',
               65361 : 'left',
               65362 : 'up',
               65363 : 'right',
               65364 : 'down',
               65307 : 'escape',
               65470 : 'f1',
               65471 : 'f2',
               65472 : 'f3',
               65473 : 'f4',
               65474 : 'f5',
               65475 : 'f6',
               65476 : 'f7',
               65477 : 'f8',
               65478 : 'f9',
               65479 : 'f10',
               65480 : 'f11',
               65481 : 'f12',
               65300 : 'scroll_lock',
               65299 : 'break',
               65288 : 'backspace',
               65293 : 'enter',
               65379 : 'insert',
               65535 : 'delete',
               65360 : 'home',
               65367 : 'end',
               65365 : 'pageup',
               65366 : 'pagedown',
               65438 : '0',
               65436 : '1',
               65433 : '2',
               65435 : '3',
               65430 : '4',
               65437 : '5',
               65432 : '6',
               65429 : '7',
               65431 : '8',
               65434 : '9',
               65451 : '+',
               65453 : '-',
               65450 : '*',
               65455 : '/',
               65439 : 'dec',
               65421 : 'enter',
           ***REMOVED***

    # Setting this as a static constant prevents
    # this resulting expression from leaking
    event_mask = (Gdk.EventMask.BUTTON_PRESS_MASK   |
                  Gdk.EventMask.BUTTON_RELEASE_MASK |
                  Gdk.EventMask.EXPOSURE_MASK       |
                  Gdk.EventMask.KEY_PRESS_MASK      |
                  Gdk.EventMask.KEY_RELEASE_MASK    |
                  Gdk.EventMask.ENTER_NOTIFY_MASK   |
                  Gdk.EventMask.LEAVE_NOTIFY_MASK   |
                  Gdk.EventMask.POINTER_MOTION_MASK |
                  Gdk.EventMask.POINTER_MOTION_HINT_MASK|
                  Gdk.EventMask.SCROLL_MASK***REMOVED***

    def __init__(self, figure***REMOVED***:
        if _debug: print('FigureCanvasGTK3.%s' % fn_name(***REMOVED******REMOVED***
        FigureCanvasBase.__init__(self, figure***REMOVED***
        GObject.GObject.__init__(self***REMOVED***

        self._idle_draw_id  = 0
        self._need_redraw   = True
        self._lastCursor    = None

        self.connect('scroll_event',         self.scroll_event***REMOVED***
        self.connect('button_press_event',   self.button_press_event***REMOVED***
        self.connect('button_release_event', self.button_release_event***REMOVED***
        self.connect('configure_event',      self.configure_event***REMOVED***
        self.connect('draw',                 self.on_draw_event***REMOVED***
        self.connect('key_press_event',      self.key_press_event***REMOVED***
        self.connect('key_release_event',    self.key_release_event***REMOVED***
        self.connect('motion_notify_event',  self.motion_notify_event***REMOVED***
        self.connect('leave_notify_event',   self.leave_notify_event***REMOVED***
        self.connect('enter_notify_event',   self.enter_notify_event***REMOVED***
        self.connect('size_allocate',        self.size_allocate***REMOVED***

        self.set_events(self.__class__.event_mask***REMOVED***

        self.set_double_buffered(True***REMOVED***
        self.set_can_focus(True***REMOVED***
        self._renderer_init(***REMOVED***
        default_context = GLib.main_context_get_thread_default(***REMOVED*** or GLib.main_context_default(***REMOVED***

    def destroy(self***REMOVED***:
        #Gtk.DrawingArea.destroy(self***REMOVED***
        self.close_event(***REMOVED***
        if self._idle_draw_id != 0:
            GLib.source_remove(self._idle_draw_id***REMOVED***

    def scroll_event(self, widget, event***REMOVED***:
        if _debug: print('FigureCanvasGTK3.%s' % fn_name(***REMOVED******REMOVED***
        x = event.x
        # flipy so y=0 is bottom of canvas
        y = self.get_allocation(***REMOVED***.height - event.y
        if event.direction==Gdk.ScrollDirection.UP:
            step = 1
        else:
            step = -1
        FigureCanvasBase.scroll_event(self, x, y, step, guiEvent=event***REMOVED***
        return False  # finish event propagation?

    def button_press_event(self, widget, event***REMOVED***:
        if _debug: print('FigureCanvasGTK3.%s' % fn_name(***REMOVED******REMOVED***
        x = event.x
        # flipy so y=0 is bottom of canvas
        y = self.get_allocation(***REMOVED***.height - event.y
        FigureCanvasBase.button_press_event(self, x, y, event.button, guiEvent=event***REMOVED***
        return False  # finish event propagation?

    def button_release_event(self, widget, event***REMOVED***:
        if _debug: print('FigureCanvasGTK3.%s' % fn_name(***REMOVED******REMOVED***
        x = event.x
        # flipy so y=0 is bottom of canvas
        y = self.get_allocation(***REMOVED***.height - event.y
        FigureCanvasBase.button_release_event(self, x, y, event.button, guiEvent=event***REMOVED***
        return False  # finish event propagation?

    def key_press_event(self, widget, event***REMOVED***:
        if _debug: print('FigureCanvasGTK3.%s' % fn_name(***REMOVED******REMOVED***
        key = self._get_key(event***REMOVED***
        if _debug: print("hit", key***REMOVED***
        FigureCanvasBase.key_press_event(self, key, guiEvent=event***REMOVED***
        return False  # finish event propagation?

    def key_release_event(self, widget, event***REMOVED***:
        if _debug: print('FigureCanvasGTK3.%s' % fn_name(***REMOVED******REMOVED***
        key = self._get_key(event***REMOVED***
        if _debug: print("release", key***REMOVED***
        FigureCanvasBase.key_release_event(self, key, guiEvent=event***REMOVED***
        return False  # finish event propagation?

    def motion_notify_event(self, widget, event***REMOVED***:
        if _debug: print('FigureCanvasGTK3.%s' % fn_name(***REMOVED******REMOVED***
        if event.is_hint:
            t, x, y, state = event.window.get_pointer(***REMOVED***
        else:
            x, y, state = event.x, event.y, event.get_state(***REMOVED***

        # flipy so y=0 is bottom of canvas
        y = self.get_allocation(***REMOVED***.height - y
        FigureCanvasBase.motion_notify_event(self, x, y, guiEvent=event***REMOVED***
        return False  # finish event propagation?

    def leave_notify_event(self, widget, event***REMOVED***:
        FigureCanvasBase.leave_notify_event(self, event***REMOVED***

    def enter_notify_event(self, widget, event***REMOVED***:
        FigureCanvasBase.enter_notify_event(self, event***REMOVED***

    def size_allocate(self, widget, allocation***REMOVED***:
        if _debug:
            print("FigureCanvasGTK3.%s" % fn_name(***REMOVED******REMOVED***
            print("size_allocate (%d x %d***REMOVED***" % (allocation.width, allocation.height***REMOVED******REMOVED***
        dpival = self.figure.dpi
        winch = allocation.width / dpival
        hinch = allocation.height / dpival
        self.figure.set_size_inches(winch, hinch***REMOVED***
        FigureCanvasBase.resize_event(self***REMOVED***
        self.draw_idle(***REMOVED***

    def _get_key(self, event***REMOVED***:
        if event.keyval in self.keyvald:
            key = self.keyvald[event.keyval***REMOVED***
        elif event.keyval < 256:
            key = chr(event.keyval***REMOVED***
        else:
            key = None

        modifiers = [
                     (Gdk.ModifierType.MOD4_MASK, 'super'***REMOVED***,
                     (Gdk.ModifierType.MOD1_MASK, 'alt'***REMOVED***,
                     (Gdk.ModifierType.CONTROL_MASK, 'ctrl'***REMOVED***,
                    ***REMOVED***
        for key_mask, prefix in modifiers:
            if event.state & key_mask:
                key = '{0***REMOVED***+{1***REMOVED***'.format(prefix, key***REMOVED***

        return key

    def configure_event(self, widget, event***REMOVED***:
        if _debug: print('FigureCanvasGTK3.%s' % fn_name(***REMOVED******REMOVED***
        if widget.get_property("window"***REMOVED*** is None:
            return
        w, h = event.width, event.height
        if w < 3 or h < 3:
            return # empty fig

        # resize the figure (in inches***REMOVED***
        dpi = self.figure.dpi
        self.figure.set_size_inches (w/dpi, h/dpi***REMOVED***
        self._need_redraw = True

        return False  # finish event propagation?

    def on_draw_event(self, widget, ctx***REMOVED***:
        # to be overwritten by GTK3Agg or GTK3Cairo
        pass

    def draw(self***REMOVED***:
        self._need_redraw = True
        if self.get_visible(***REMOVED*** and self.get_mapped(***REMOVED***:
            self.queue_draw(***REMOVED***
            # do a synchronous draw (its less efficient than an async draw,
            # but is required if/when animation is used***REMOVED***
            self.get_property("window"***REMOVED***.process_updates (False***REMOVED***

    def draw_idle(self***REMOVED***:
        if self._idle_draw_id != 0:
            return
        def idle_draw(*args***REMOVED***:
            ***REMOVED***
                self.draw(***REMOVED***
            finally:
                self._idle_draw_id = 0
            return False
        self._idle_draw_id = GLib.idle_add(idle_draw***REMOVED***

    def new_timer(self, *args, **kwargs***REMOVED***:
        ***REMOVED***
        Creates a new backend-specific subclass of :class:`backend_bases.Timer`.
        This is useful for getting periodic events through the backend's native
        event loop. Implemented only for backends with GUIs.

        optional arguments:

        *interval*
          Timer interval in milliseconds
        *callbacks*
          Sequence of (func, args, kwargs***REMOVED*** where func(*args, **kwargs***REMOVED*** will
          be executed by the timer every *interval*.
        ***REMOVED***
        return TimerGTK3(*args, **kwargs***REMOVED***

    def flush_events(self***REMOVED***:
        Gdk.threads_enter(***REMOVED***
        while Gtk.events_pending(***REMOVED***:
            Gtk.main_iteration(***REMOVED***
        Gdk.flush(***REMOVED***
        Gdk.threads_leave(***REMOVED***

    def start_event_loop(self,timeout***REMOVED***:
        FigureCanvasBase.start_event_loop_default(self,timeout***REMOVED***
    start_event_loop.__doc__=FigureCanvasBase.start_event_loop_default.__doc__

    def stop_event_loop(self***REMOVED***:
        FigureCanvasBase.stop_event_loop_default(self***REMOVED***
    stop_event_loop.__doc__=FigureCanvasBase.stop_event_loop_default.__doc__


class FigureManagerGTK3(FigureManagerBase***REMOVED***:
    ***REMOVED***
    Public attributes

    canvas      : The FigureCanvas instance
    num         : The Figure number
    toolbar     : The Gtk.Toolbar  (gtk only***REMOVED***
    vbox        : The Gtk.VBox containing the canvas and toolbar (gtk only***REMOVED***
    window      : The Gtk.Window   (gtk only***REMOVED***
    ***REMOVED***
    def __init__(self, canvas, num***REMOVED***:
        if _debug: print('FigureManagerGTK3.%s' % fn_name(***REMOVED******REMOVED***
        FigureManagerBase.__init__(self, canvas, num***REMOVED***

        self.window = Gtk.Window(***REMOVED***
        self.set_window_title("Figure %d" % num***REMOVED***
        ***REMOVED***
            self.window.set_icon_from_file(window_icon***REMOVED***
        except (SystemExit, KeyboardInterrupt***REMOVED***:
            # re-raise exit type Exceptions
            raise
        ***REMOVED***
            # some versions of gtk throw a glib.GError but not
            # all, so I am not sure how to catch it.  I am unhappy
            # doing a blanket catch here, but am not sure what a
            # better way is - JDH
            verbose.report('Could not load matplotlib icon: %s' % sys.exc_info(***REMOVED***[1***REMOVED******REMOVED***

        self.vbox = Gtk.Box(***REMOVED***
        self.vbox.set_property("orientation", Gtk.Orientation.VERTICAL***REMOVED***
        self.window.add(self.vbox***REMOVED***
        self.vbox.show(***REMOVED***

        self.canvas.show(***REMOVED***

        self.vbox.pack_start(self.canvas, True, True, 0***REMOVED***
        # calculate size for window
        w = int (self.canvas.figure.bbox.width***REMOVED***
        h = int (self.canvas.figure.bbox.height***REMOVED***

        self.toolmanager = self._get_toolmanager(***REMOVED***
        self.toolbar = self._get_toolbar(***REMOVED***
        self.statusbar = None

        def add_widget(child, expand, fill, padding***REMOVED***:
            child.show(***REMOVED***
            self.vbox.pack_end(child, False, False, 0***REMOVED***
            size_request = child.size_request(***REMOVED***
            return size_request.height

        if self.toolmanager:
            backend_tools.add_tools_to_manager(self.toolmanager***REMOVED***
            if self.toolbar:
                backend_tools.add_tools_to_container(self.toolbar***REMOVED***
                self.statusbar = StatusbarGTK3(self.toolmanager***REMOVED***
                h += add_widget(self.statusbar, False, False, 0***REMOVED***
                h += add_widget(Gtk.HSeparator(***REMOVED***, False, False, 0***REMOVED***

        if self.toolbar is not None:
            self.toolbar.show(***REMOVED***
            h += add_widget(self.toolbar, False, False, 0***REMOVED***

        self.window.set_default_size (w, h***REMOVED***

        def destroy(*args***REMOVED***:
            Gcf.destroy(num***REMOVED***
        self.window.connect("destroy", destroy***REMOVED***
        self.window.connect("delete_event", destroy***REMOVED***
        if matplotlib.is_interactive(***REMOVED***:
            self.window.show(***REMOVED***
            self.canvas.draw_idle(***REMOVED***

        def notify_axes_change(fig***REMOVED***:
            'this will be called whenever the current axes is changed'
            if self.toolmanager is not None:
                pass
            elif self.toolbar is not None:
                self.toolbar.update(***REMOVED***
        self.canvas.figure.add_axobserver(notify_axes_change***REMOVED***

        self.canvas.grab_focus(***REMOVED***

    def destroy(self, *args***REMOVED***:
        if _debug: print('FigureManagerGTK3.%s' % fn_name(***REMOVED******REMOVED***
        self.vbox.destroy(***REMOVED***
        self.window.destroy(***REMOVED***
        self.canvas.destroy(***REMOVED***
        if self.toolbar:
            self.toolbar.destroy(***REMOVED***

        if Gcf.get_num_fig_managers(***REMOVED***==0 and \
               not matplotlib.is_interactive(***REMOVED*** and \
               Gtk.main_level(***REMOVED*** >= 1:
            Gtk.main_quit(***REMOVED***

    def show(self***REMOVED***:
        # show the figure window
        self.window.show(***REMOVED***

    def full_screen_toggle (self***REMOVED***:
        self._full_screen_flag = not self._full_screen_flag
        if self._full_screen_flag:
            self.window.fullscreen(***REMOVED***
        else:
            self.window.unfullscreen(***REMOVED***
    _full_screen_flag = False


    def _get_toolbar(self***REMOVED***:
        # must be inited after the window, drawingArea and figure
        # attrs are set
        if rcParams['toolbar'***REMOVED*** == 'toolbar2':
            toolbar = NavigationToolbar2GTK3 (self.canvas, self.window***REMOVED***
        elif rcParams['toolbar'***REMOVED*** == 'toolmanager':
            toolbar = ToolbarGTK3(self.toolmanager***REMOVED***
        else:
            toolbar = None
        return toolbar

    def _get_toolmanager(self***REMOVED***:
        # must be initialised after toolbar has been setted
        if rcParams['toolbar'***REMOVED*** != 'toolbar2':
            toolmanager = ToolManager(self.canvas***REMOVED***
        else:
            toolmanager = None
        return toolmanager

    def get_window_title(self***REMOVED***:
        return self.window.get_title(***REMOVED***

    def set_window_title(self, title***REMOVED***:
        self.window.set_title(title***REMOVED***

    def resize(self, width, height***REMOVED***:
        'set the canvas size in pixels'
        #_, _, cw, ch = self.canvas.allocation
        #_, _, ww, wh = self.window.allocation
        #self.window.resize (width-cw+ww, height-ch+wh***REMOVED***
        self.window.resize(width, height***REMOVED***


class NavigationToolbar2GTK3(NavigationToolbar2, Gtk.Toolbar***REMOVED***:
    def __init__(self, canvas, window***REMOVED***:
        self.win = window
        GObject.GObject.__init__(self***REMOVED***
        NavigationToolbar2.__init__(self, canvas***REMOVED***
        self.ctx = None

    def set_message(self, s***REMOVED***:
        self.message.set_label(s***REMOVED***

    def set_cursor(self, cursor***REMOVED***:
        self.canvas.get_property("window"***REMOVED***.set_cursor(cursord[cursor***REMOVED******REMOVED***
        #self.canvas.set_cursor(cursord[cursor***REMOVED******REMOVED***

    def release(self, event***REMOVED***:
        ***REMOVED*** del self._pixmapBack
        except AttributeError: pass

    def dynamic_update(self***REMOVED***:
        # legacy method; new method is canvas.draw_idle
        self.canvas.draw_idle(***REMOVED***

    def draw_rubberband(self, event, x0, y0, x1, y1***REMOVED***:
        'adapted from http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/189744'
        self.ctx = self.canvas.get_property("window"***REMOVED***.cairo_create(***REMOVED***

        # todo: instead of redrawing the entire figure, copy the part of
        # the figure that was covered by the previous rubberband rectangle
        self.canvas.draw(***REMOVED***

        height = self.canvas.figure.bbox.height
        y1 = height - y1
        y0 = height - y0
        w = abs(x1 - x0***REMOVED***
        h = abs(y1 - y0***REMOVED***
        rect = [int(val***REMOVED*** for val in (min(x0,x1***REMOVED***, min(y0, y1***REMOVED***, w, h***REMOVED******REMOVED***

        self.ctx.new_path(***REMOVED***
        self.ctx.set_line_width(0.5***REMOVED***
        self.ctx.rectangle(rect[0***REMOVED***, rect[1***REMOVED***, rect[2***REMOVED***, rect[3***REMOVED******REMOVED***
        self.ctx.set_source_rgb(0, 0, 0***REMOVED***
        self.ctx.stroke(***REMOVED***

    def _init_toolbar(self***REMOVED***:
        self.set_style(Gtk.ToolbarStyle.ICONS***REMOVED***
        basedir = os.path.join(rcParams['datapath'***REMOVED***,'images'***REMOVED***

        for text, tooltip_text, image_file, callback in self.toolitems:
            if text is None:
                self.insert( Gtk.SeparatorToolItem(***REMOVED***, -1 ***REMOVED***
                continue
            fname = os.path.join(basedir, image_file + '.png'***REMOVED***
            image = Gtk.Image(***REMOVED***
            image.set_from_file(fname***REMOVED***
            tbutton = Gtk.ToolButton(***REMOVED***
            tbutton.set_label(text***REMOVED***
            tbutton.set_icon_widget(image***REMOVED***
            self.insert(tbutton, -1***REMOVED***
            tbutton.connect('clicked', getattr(self, callback***REMOVED******REMOVED***
            tbutton.set_tooltip_text(tooltip_text***REMOVED***

        toolitem = Gtk.SeparatorToolItem(***REMOVED***
        self.insert(toolitem, -1***REMOVED***
        toolitem.set_draw(False***REMOVED***
        toolitem.set_expand(True***REMOVED***

        toolitem = Gtk.ToolItem(***REMOVED***
        self.insert(toolitem, -1***REMOVED***
        self.message = Gtk.Label(***REMOVED***
        toolitem.add(self.message***REMOVED***

        self.show_all(***REMOVED***

    def get_filechooser(self***REMOVED***:
        fc = FileChooserDialog(
            title='Save the figure',
            parent=self.win,
            path=os.path.expanduser(rcParams.get('savefig.directory', ''***REMOVED******REMOVED***,
            filetypes=self.canvas.get_supported_filetypes(***REMOVED***,
            default_filetype=self.canvas.get_default_filetype(***REMOVED******REMOVED***
        fc.set_current_name(self.canvas.get_default_filename(***REMOVED******REMOVED***
        return fc

    def save_figure(self, *args***REMOVED***:
        chooser = self.get_filechooser(***REMOVED***
        fname, format = chooser.get_filename_from_user(***REMOVED***
        chooser.destroy(***REMOVED***
        if fname:
            startpath = os.path.expanduser(rcParams.get('savefig.directory', ''***REMOVED******REMOVED***
            if startpath == '':
                # explicitly missing key or empty str signals to use cwd
                rcParams['savefig.directory'***REMOVED*** = startpath
            else:
                # save dir for next time
                rcParams['savefig.directory'***REMOVED*** = os.path.dirname(six.text_type(fname***REMOVED******REMOVED***
            ***REMOVED***
                self.canvas.print_figure(fname, format=format***REMOVED***
            except Exception as e:
                error_msg_gtk(str(e***REMOVED***, parent=self***REMOVED***

    def configure_subplots(self, button***REMOVED***:
        toolfig = Figure(figsize=(6,3***REMOVED******REMOVED***
        canvas = self._get_canvas(toolfig***REMOVED***
        toolfig.subplots_adjust(top=0.9***REMOVED***
        tool =  SubplotTool(self.canvas.figure, toolfig***REMOVED***

        w = int (toolfig.bbox.width***REMOVED***
        h = int (toolfig.bbox.height***REMOVED***


        window = Gtk.Window(***REMOVED***
        ***REMOVED***
            window.set_icon_from_file(window_icon***REMOVED***
        except (SystemExit, KeyboardInterrupt***REMOVED***:
            # re-raise exit type Exceptions
            raise
        ***REMOVED***
            # we presumably already logged a message on the
            # failure of the main plot, don't keep reporting
            pass
        window.set_title("Subplot Configuration Tool"***REMOVED***
        window.set_default_size(w, h***REMOVED***
        vbox = Gtk.Box(***REMOVED***
        vbox.set_property("orientation", Gtk.Orientation.VERTICAL***REMOVED***
        window.add(vbox***REMOVED***
        vbox.show(***REMOVED***

        canvas.show(***REMOVED***
        vbox.pack_start(canvas, True, True, 0***REMOVED***
        window.show(***REMOVED***

    def _get_canvas(self, fig***REMOVED***:
        return self.canvas.__class__(fig***REMOVED***


class FileChooserDialog(Gtk.FileChooserDialog***REMOVED***:
    ***REMOVED***GTK+ file selector which remembers the last file/directory
    selected and presents the user with a menu of supported image formats
    ***REMOVED***
    def __init__ (self,
                  title   = 'Save file',
                  parent  = None,
                  action  = Gtk.FileChooserAction.SAVE,
                  buttons = (Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL,
                             Gtk.STOCK_SAVE,   Gtk.ResponseType.OK***REMOVED***,
                  path    = None,
                  filetypes = [***REMOVED***,
                  default_filetype = None
                  ***REMOVED***:
        super (FileChooserDialog, self***REMOVED***.__init__ (title, parent, action,
                                                  buttons***REMOVED***
        self.set_default_response (Gtk.ResponseType.OK***REMOVED***

        if not path: path = os.getcwd(***REMOVED*** + os.sep

        # create an extra widget to list supported image formats
        self.set_current_folder (path***REMOVED***
        self.set_current_name ('image.' + default_filetype***REMOVED***

        hbox = Gtk.Box(spacing=10***REMOVED***
        hbox.pack_start(Gtk.Label(label="File Format:"***REMOVED***, False, False, 0***REMOVED***

        liststore = Gtk.ListStore(GObject.TYPE_STRING***REMOVED***
        cbox = Gtk.ComboBox(***REMOVED*** #liststore***REMOVED***
        cbox.set_model(liststore***REMOVED***
        cell = Gtk.CellRendererText(***REMOVED***
        cbox.pack_start(cell, True***REMOVED***
        cbox.add_attribute(cell, 'text', 0***REMOVED***
        hbox.pack_start(cbox, False, False, 0***REMOVED***

        self.filetypes = filetypes
        self.sorted_filetypes = list(six.iteritems(filetypes***REMOVED******REMOVED***
        self.sorted_filetypes.sort(***REMOVED***
        default = 0
        for i, (ext, name***REMOVED*** in enumerate(self.sorted_filetypes***REMOVED***:
            liststore.append(["%s (*.%s***REMOVED***" % (name, ext***REMOVED******REMOVED******REMOVED***
            if ext == default_filetype:
                default = i
        cbox.set_active(default***REMOVED***
        self.ext = default_filetype

        def cb_cbox_changed (cbox, data=None***REMOVED***:
            ***REMOVED***File extension changed***REMOVED***
            head, filename = os.path.split(self.get_filename(***REMOVED******REMOVED***
            root, ext = os.path.splitext(filename***REMOVED***
            ext = ext[1:***REMOVED***
            new_ext = self.sorted_filetypes[cbox.get_active(***REMOVED******REMOVED***[0***REMOVED***
            self.ext = new_ext

            if ext in self.filetypes:
                filename = root + '.' + new_ext
            elif ext == '':
                filename = filename.rstrip('.'***REMOVED*** + '.' + new_ext

            self.set_current_name (filename***REMOVED***
        cbox.connect ("changed", cb_cbox_changed***REMOVED***

        hbox.show_all(***REMOVED***
        self.set_extra_widget(hbox***REMOVED***

    def get_filename_from_user (self***REMOVED***:
        while True:
            filename = None
            if self.run(***REMOVED*** != int(Gtk.ResponseType.OK***REMOVED***:
                break
            filename = self.get_filename(***REMOVED***
            break

        return filename, self.ext


class RubberbandGTK3(backend_tools.RubberbandBase***REMOVED***:
    def __init__(self, *args, **kwargs***REMOVED***:
        backend_tools.RubberbandBase.__init__(self, *args, **kwargs***REMOVED***
        self.ctx = None

    def draw_rubberband(self, x0, y0, x1, y1***REMOVED***:
        # 'adapted from http://aspn.activestate.com/ASPN/Cookbook/Python/
        # Recipe/189744'
        self.ctx = self.figure.canvas.get_property("window"***REMOVED***.cairo_create(***REMOVED***

        # todo: instead of redrawing the entire figure, copy the part of
        # the figure that was covered by the previous rubberband rectangle
        self.figure.canvas.draw(***REMOVED***

        height = self.figure.bbox.height
        y1 = height - y1
        y0 = height - y0
        w = abs(x1 - x0***REMOVED***
        h = abs(y1 - y0***REMOVED***
        rect = [int(val***REMOVED*** for val in (min(x0, x1***REMOVED***, min(y0, y1***REMOVED***, w, h***REMOVED******REMOVED***

        self.ctx.new_path(***REMOVED***
        self.ctx.set_line_width(0.5***REMOVED***
        self.ctx.rectangle(rect[0***REMOVED***, rect[1***REMOVED***, rect[2***REMOVED***, rect[3***REMOVED******REMOVED***
        self.ctx.set_source_rgb(0, 0, 0***REMOVED***
        self.ctx.stroke(***REMOVED***


class ToolbarGTK3(ToolContainerBase, Gtk.Box***REMOVED***:
    def __init__(self, toolmanager***REMOVED***:
        ToolContainerBase.__init__(self, toolmanager***REMOVED***
        Gtk.Box.__init__(self***REMOVED***
        self.set_property("orientation", Gtk.Orientation.VERTICAL***REMOVED***

        self._toolarea = Gtk.Box(***REMOVED***
        self._toolarea.set_property('orientation', Gtk.Orientation.HORIZONTAL***REMOVED***
        self.pack_start(self._toolarea, False, False, 0***REMOVED***
        self._toolarea.show_all(***REMOVED***
        self._groups = {***REMOVED***
        self._toolitems = {***REMOVED***

    def add_toolitem(self, name, group, position, image_file, description,
                     toggle***REMOVED***:
        if toggle:
            tbutton = Gtk.ToggleToolButton(***REMOVED***
        else:
            tbutton = Gtk.ToolButton(***REMOVED***
        tbutton.set_label(name***REMOVED***

        if image_file is not None:
            image = Gtk.Image(***REMOVED***
            image.set_from_file(image_file***REMOVED***
            tbutton.set_icon_widget(image***REMOVED***

        if position is None:
            position = -1

        self._add_button(tbutton, group, position***REMOVED***
        signal = tbutton.connect('clicked', self._call_tool, name***REMOVED***
        tbutton.set_tooltip_text(description***REMOVED***
        tbutton.show_all(***REMOVED***
        self._toolitems.setdefault(name, [***REMOVED******REMOVED***
        self._toolitems[name***REMOVED***.append((tbutton, signal***REMOVED******REMOVED***

    def _add_button(self, button, group, position***REMOVED***:
        if group not in self._groups:
            if self._groups:
                self._add_separator(***REMOVED***
            toolbar = Gtk.Toolbar(***REMOVED***
            toolbar.set_style(Gtk.ToolbarStyle.ICONS***REMOVED***
            self._toolarea.pack_start(toolbar, False, False, 0***REMOVED***
            toolbar.show_all(***REMOVED***
            self._groups[group***REMOVED*** = toolbar
        self._groups[group***REMOVED***.insert(button, position***REMOVED***

    def _call_tool(self, btn, name***REMOVED***:
        self.trigger_tool(name***REMOVED***

    def toggle_toolitem(self, name, toggled***REMOVED***:
        if name not in self._toolitems:
            return
        for toolitem, signal in self._toolitems[name***REMOVED***:
            toolitem.handler_block(signal***REMOVED***
            toolitem.set_active(toggled***REMOVED***
            toolitem.handler_unblock(signal***REMOVED***

    def remove_toolitem(self, name***REMOVED***:
        if name not in self._toolitems:
            self.toolmanager.message_event('%s Not in toolbar' % name, self***REMOVED***
            return

        for group in self._groups:
            for toolitem, _signal in self._toolitems[name***REMOVED***:
                if toolitem in self._groups[group***REMOVED***:
                    self._groups[group***REMOVED***.remove(toolitem***REMOVED***
        del self._toolitems[name***REMOVED***

    def _add_separator(self***REMOVED***:
        sep = Gtk.Separator(***REMOVED***
        sep.set_property("orientation", Gtk.Orientation.VERTICAL***REMOVED***
        self._toolarea.pack_start(sep, False, True, 0***REMOVED***
        sep.show_all(***REMOVED***


class StatusbarGTK3(StatusbarBase, Gtk.Statusbar***REMOVED***:
    def __init__(self, *args, **kwargs***REMOVED***:
        StatusbarBase.__init__(self, *args, **kwargs***REMOVED***
        Gtk.Statusbar.__init__(self***REMOVED***
        self._context = self.get_context_id('message'***REMOVED***

    def set_message(self, s***REMOVED***:
        self.pop(self._context***REMOVED***
        self.push(self._context, s***REMOVED***


class SaveFigureGTK3(backend_tools.SaveFigureBase***REMOVED***:

    def get_filechooser(self***REMOVED***:
        fc = FileChooserDialog(
            title='Save the figure',
            parent=self.figure.canvas.manager.window,
            path=os.path.expanduser(rcParams.get('savefig.directory', ''***REMOVED******REMOVED***,
            filetypes=self.figure.canvas.get_supported_filetypes(***REMOVED***,
            default_filetype=self.figure.canvas.get_default_filetype(***REMOVED******REMOVED***
        fc.set_current_name(self.figure.canvas.get_default_filename(***REMOVED******REMOVED***
        return fc

    def trigger(self, *args, **kwargs***REMOVED***:
        chooser = self.get_filechooser(***REMOVED***
        fname, format_ = chooser.get_filename_from_user(***REMOVED***
        chooser.destroy(***REMOVED***
        if fname:
            startpath = os.path.expanduser(
                rcParams.get('savefig.directory', ''***REMOVED******REMOVED***
            if startpath == '':
                # explicitly missing key or empty str signals to use cwd
                rcParams['savefig.directory'***REMOVED*** = startpath
            else:
                # save dir for next time
                rcParams['savefig.directory'***REMOVED*** = os.path.dirname(
                    six.text_type(fname***REMOVED******REMOVED***
            ***REMOVED***
                self.figure.canvas.print_figure(fname, format=format_***REMOVED***
            except Exception as e:
                error_msg_gtk(str(e***REMOVED***, parent=self***REMOVED***


class SetCursorGTK3(backend_tools.SetCursorBase***REMOVED***:
    def set_cursor(self, cursor***REMOVED***:
        self.figure.canvas.get_property("window"***REMOVED***.set_cursor(cursord[cursor***REMOVED******REMOVED***


class ConfigureSubplotsGTK3(backend_tools.ConfigureSubplotsBase, Gtk.Window***REMOVED***:
    def __init__(self, *args, **kwargs***REMOVED***:
        backend_tools.ConfigureSubplotsBase.__init__(self, *args, **kwargs***REMOVED***
        self.window = None

    def init_window(self***REMOVED***:
        if self.window:
            return
        self.window = Gtk.Window(title="Subplot Configuration Tool"***REMOVED***

        ***REMOVED***
            self.window.window.set_icon_from_file(window_icon***REMOVED***
        except (SystemExit, KeyboardInterrupt***REMOVED***:
            # re-raise exit type Exceptions
            raise
        ***REMOVED***
            # we presumably already logged a message on the
            # failure of the main plot, don't keep reporting
            pass

        self.vbox = Gtk.Box(***REMOVED***
        self.vbox.set_property("orientation", Gtk.Orientation.VERTICAL***REMOVED***
        self.window.add(self.vbox***REMOVED***
        self.vbox.show(***REMOVED***
        self.window.connect('destroy', self.destroy***REMOVED***

        toolfig = Figure(figsize=(6, 3***REMOVED******REMOVED***
        canvas = self.figure.canvas.__class__(toolfig***REMOVED***

        toolfig.subplots_adjust(top=0.9***REMOVED***
        SubplotTool(self.figure, toolfig***REMOVED***

        w = int(toolfig.bbox.width***REMOVED***
        h = int(toolfig.bbox.height***REMOVED***

        self.window.set_default_size(w, h***REMOVED***

        canvas.show(***REMOVED***
        self.vbox.pack_start(canvas, True, True, 0***REMOVED***
        self.window.show(***REMOVED***

    def destroy(self, *args***REMOVED***:
        self.window.destroy(***REMOVED***
        self.window = None

    def _get_canvas(self, fig***REMOVED***:
        return self.canvas.__class__(fig***REMOVED***

    def trigger(self, sender, event, data=None***REMOVED***:
        self.init_window(***REMOVED***
        self.window.present(***REMOVED***


class DialogLineprops(object***REMOVED***:
    ***REMOVED***
    A GUI dialog for controlling lineprops
    ***REMOVED***
    signals = (
        'on_combobox_lineprops_changed',
        'on_combobox_linestyle_changed',
        'on_combobox_marker_changed',
        'on_colorbutton_linestyle_color_set',
        'on_colorbutton_markerface_color_set',
        'on_dialog_lineprops_okbutton_clicked',
        'on_dialog_lineprops_cancelbutton_clicked',
        ***REMOVED***

    linestyles = [ls for ls in lines.Line2D.lineStyles if ls.strip(***REMOVED******REMOVED***
    linestyled = dict([ (s,i***REMOVED*** for i,s in enumerate(linestyles***REMOVED******REMOVED******REMOVED***


    markers =  [m for m in lines.Line2D.markers if cbook.is_string_like(m***REMOVED******REMOVED***

    markerd = dict([(s,i***REMOVED*** for i,s in enumerate(markers***REMOVED******REMOVED******REMOVED***

    def __init__(self, lines***REMOVED***:
        import Gtk.glade

        datadir = matplotlib.get_data_path(***REMOVED***
        gladefile = os.path.join(datadir, 'lineprops.glade'***REMOVED***
        if not os.path.exists(gladefile***REMOVED***:
            raise IOError('Could not find gladefile lineprops.glade in %s'%datadir***REMOVED***

        self._inited = False
        self._updateson = True # suppress updates when setting widgets manually
        self.wtree = Gtk.glade.XML(gladefile, 'dialog_lineprops'***REMOVED***
        self.wtree.signal_autoconnect(dict([(s, getattr(self, s***REMOVED******REMOVED*** for s in self.signals***REMOVED******REMOVED******REMOVED***

        self.dlg = self.wtree.get_widget('dialog_lineprops'***REMOVED***

        self.lines = lines

        cbox = self.wtree.get_widget('combobox_lineprops'***REMOVED***
        cbox.set_active(0***REMOVED***
        self.cbox_lineprops = cbox

        cbox = self.wtree.get_widget('combobox_linestyles'***REMOVED***
        for ls in self.linestyles:
            cbox.append_text(ls***REMOVED***
        cbox.set_active(0***REMOVED***
        self.cbox_linestyles = cbox

        cbox = self.wtree.get_widget('combobox_markers'***REMOVED***
        for m in self.markers:
            cbox.append_text(m***REMOVED***
        cbox.set_active(0***REMOVED***
        self.cbox_markers = cbox
        self._lastcnt = 0
        self._inited = True


    def show(self***REMOVED***:
        'populate the combo box'
        self._updateson = False
        # flush the old
        cbox = self.cbox_lineprops
        for i in range(self._lastcnt-1,-1,-1***REMOVED***:
            cbox.remove_text(i***REMOVED***

        # add the new
        for line in self.lines:
            cbox.append_text(line.get_label(***REMOVED******REMOVED***
        cbox.set_active(0***REMOVED***

        self._updateson = True
        self._lastcnt = len(self.lines***REMOVED***
        self.dlg.show(***REMOVED***

    def get_active_line(self***REMOVED***:
        'get the active line'
        ind = self.cbox_lineprops.get_active(***REMOVED***
        line = self.lines[ind***REMOVED***
        return line

    def get_active_linestyle(self***REMOVED***:
        'get the active lineinestyle'
        ind = self.cbox_linestyles.get_active(***REMOVED***
        ls = self.linestyles[ind***REMOVED***
        return ls

    def get_active_marker(self***REMOVED***:
        'get the active lineinestyle'
        ind = self.cbox_markers.get_active(***REMOVED***
        m = self.markers[ind***REMOVED***
        return m

    def _update(self***REMOVED***:
        'update the active line props from the widgets'
        if not self._inited or not self._updateson: return
        line = self.get_active_line(***REMOVED***
        ls = self.get_active_linestyle(***REMOVED***
        marker = self.get_active_marker(***REMOVED***
        line.set_linestyle(ls***REMOVED***
        line.set_marker(marker***REMOVED***

        button = self.wtree.get_widget('colorbutton_linestyle'***REMOVED***
        color = button.get_color(***REMOVED***
        r, g, b = [val/65535. for val in (color.red, color.green, color.blue***REMOVED******REMOVED***
        line.set_color((r,g,b***REMOVED******REMOVED***

        button = self.wtree.get_widget('colorbutton_markerface'***REMOVED***
        color = button.get_color(***REMOVED***
        r, g, b = [val/65535. for val in (color.red, color.green, color.blue***REMOVED******REMOVED***
        line.set_markerfacecolor((r,g,b***REMOVED******REMOVED***

        line.figure.canvas.draw(***REMOVED***

    def on_combobox_lineprops_changed(self, item***REMOVED***:
        'update the widgets from the active line'
        if not self._inited: return
        self._updateson = False
        line = self.get_active_line(***REMOVED***

        ls = line.get_linestyle(***REMOVED***
        if ls is None: ls = 'None'
        self.cbox_linestyles.set_active(self.linestyled[ls***REMOVED******REMOVED***

        marker = line.get_marker(***REMOVED***
        if marker is None: marker = 'None'
        self.cbox_markers.set_active(self.markerd[marker***REMOVED******REMOVED***

        r,g,b = colorConverter.to_rgb(line.get_color(***REMOVED******REMOVED***
        color = Gdk.Color(*[int(val*65535***REMOVED*** for val in (r,g,b***REMOVED******REMOVED******REMOVED***
        button = self.wtree.get_widget('colorbutton_linestyle'***REMOVED***
        button.set_color(color***REMOVED***

        r,g,b = colorConverter.to_rgb(line.get_markerfacecolor(***REMOVED******REMOVED***
        color = Gdk.Color(*[int(val*65535***REMOVED*** for val in (r,g,b***REMOVED******REMOVED******REMOVED***
        button = self.wtree.get_widget('colorbutton_markerface'***REMOVED***
        button.set_color(color***REMOVED***
        self._updateson = True

    def on_combobox_linestyle_changed(self, item***REMOVED***:
        self._update(***REMOVED***

    def on_combobox_marker_changed(self, item***REMOVED***:
        self._update(***REMOVED***

    def on_colorbutton_linestyle_color_set(self, button***REMOVED***:
        self._update(***REMOVED***

    def on_colorbutton_markerface_color_set(self, button***REMOVED***:
        'called colorbutton marker clicked'
        self._update(***REMOVED***

    def on_dialog_lineprops_okbutton_clicked(self, button***REMOVED***:
        self._update(***REMOVED***
        self.dlg.hide(***REMOVED***

    def on_dialog_lineprops_cancelbutton_clicked(self, button***REMOVED***:
        self.dlg.hide(***REMOVED***


# Define the file to use as the GTk icon
if sys.platform == 'win32':
    icon_filename = 'matplotlib.png'
else:
    icon_filename = 'matplotlib.svg'
window_icon = os.path.join(matplotlib.rcParams['datapath'***REMOVED***, 'images', icon_filename***REMOVED***


def error_msg_gtk(msg, parent=None***REMOVED***:
    if parent is not None: # find the toplevel Gtk.Window
        parent = parent.get_toplevel(***REMOVED***
        if not parent.is_toplevel(***REMOVED***:
            parent = None

    if not is_string_like(msg***REMOVED***:
        msg = ','.join(map(str,msg***REMOVED******REMOVED***

    dialog = Gtk.MessageDialog(
        parent         = parent,
        type           = Gtk.MessageType.ERROR,
        buttons        = Gtk.ButtonsType.OK,
        message_format = msg***REMOVED***
    dialog.run(***REMOVED***
    dialog.destroy(***REMOVED***


backend_tools.ToolSaveFigure = SaveFigureGTK3
backend_tools.ToolConfigureSubplots = ConfigureSubplotsGTK3
backend_tools.ToolSetCursor = SetCursorGTK3
backend_tools.ToolRubberband = RubberbandGTK3

Toolbar = ToolbarGTK3
FigureCanvas = FigureCanvasGTK3
FigureManager = FigureManagerGTK3
