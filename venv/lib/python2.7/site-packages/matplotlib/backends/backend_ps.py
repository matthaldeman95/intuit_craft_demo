***REMOVED***
A PostScript backend, which can produce both PostScript .ps and .eps
***REMOVED***

from __future__ import (absolute_import, division, print_function,
                        unicode_literals***REMOVED***

from matplotlib.externals import six
from matplotlib.externals.six.moves import StringIO

import glob, math, os, shutil, sys, time
def _fn_name(***REMOVED***: return sys._getframe(1***REMOVED***.f_code.co_name
import io

***REMOVED***
    from hashlib import md5
except ImportError:
    from md5 import md5 #Deprecated in 2.5

from tempfile import mkstemp
from matplotlib import verbose, __version__, rcParams, checkdep_ghostscript
from matplotlib._pylab_helpers import Gcf
from matplotlib.afm import AFM
from matplotlib.backend_bases import RendererBase, GraphicsContextBase,\
     FigureManagerBase, FigureCanvasBase

from matplotlib.cbook import is_string_like, get_realpath_and_stat, \
    is_writable_file_like, maxdict, file_requires_unicode
from matplotlib.figure import Figure

from matplotlib.font_manager import findfont, is_opentype_cff_font
from matplotlib.ft2font import FT2Font, KERNING_DEFAULT, LOAD_NO_HINTING
from matplotlib.ttconv import convert_ttf_to_ps
from matplotlib.mathtext import MathTextParser
from matplotlib._mathtext_data import uni2type1
from matplotlib.text import Text
from matplotlib.path import Path
from matplotlib import _path
from matplotlib.transforms import Affine2D

from matplotlib.backends.backend_mixed import MixedModeRenderer


import numpy as np
import binascii
import re
***REMOVED***
    set
except NameError:
    from sets import Set as set

if sys.platform.startswith('win'***REMOVED***: cmd_split = '&'
else: cmd_split = ';'

backend_version = 'Level II'

debugPS = 0


class PsBackendHelper(object***REMOVED***:

    def __init__(self***REMOVED***:
        self._cached = {***REMOVED***

    @property
    def gs_exe(self***REMOVED***:
        ***REMOVED***
        excutable name of ghostscript.
        ***REMOVED***
        ***REMOVED***
            return self._cached["gs_exe"***REMOVED***
        except KeyError:
            pass

        gs_exe, gs_version = checkdep_ghostscript(***REMOVED***
        if gs_exe is None:
            gs_exe = 'gs'

        self._cached["gs_exe"***REMOVED*** = gs_exe
        return gs_exe

    @property
    def gs_version(self***REMOVED***:
        ***REMOVED***
        version of ghostscript.
        ***REMOVED***
        ***REMOVED***
            return self._cached["gs_version"***REMOVED***
        except KeyError:
            pass

        from matplotlib.compat.subprocess import Popen, PIPE
        s = Popen(self.gs_exe + " --version",
                     shell=True, stdout=PIPE***REMOVED***
        pipe, stderr = s.communicate(***REMOVED***
        if six.PY3:
            ver = pipe.decode('ascii'***REMOVED***
        else:
            ver = pipe
        ***REMOVED***
            gs_version = tuple(map(int, ver.strip(***REMOVED***.split("."***REMOVED******REMOVED******REMOVED***
        except ValueError:
            # if something went wrong parsing return null version number
            gs_version = (0, 0***REMOVED***
        self._cached["gs_version"***REMOVED*** = gs_version
        return gs_version

    @property
    def supports_ps2write(self***REMOVED***:
        ***REMOVED***
        True if the installed ghostscript supports ps2write device.
        ***REMOVED***
        return self.gs_version[0***REMOVED*** >= 9

ps_backend_helper = PsBackendHelper(***REMOVED***

papersize = {'letter': (8.5,11***REMOVED***,
             'legal': (8.5,14***REMOVED***,
             'ledger': (11,17***REMOVED***,
             'a0': (33.11,46.81***REMOVED***,
             'a1': (23.39,33.11***REMOVED***,
             'a2': (16.54,23.39***REMOVED***,
             'a3': (11.69,16.54***REMOVED***,
             'a4': (8.27,11.69***REMOVED***,
             'a5': (5.83,8.27***REMOVED***,
             'a6': (4.13,5.83***REMOVED***,
             'a7': (2.91,4.13***REMOVED***,
             'a8': (2.07,2.91***REMOVED***,
             'a9': (1.457,2.05***REMOVED***,
             'a10': (1.02,1.457***REMOVED***,
             'b0': (40.55,57.32***REMOVED***,
             'b1': (28.66,40.55***REMOVED***,
             'b2': (20.27,28.66***REMOVED***,
             'b3': (14.33,20.27***REMOVED***,
             'b4': (10.11,14.33***REMOVED***,
             'b5': (7.16,10.11***REMOVED***,
             'b6': (5.04,7.16***REMOVED***,
             'b7': (3.58,5.04***REMOVED***,
             'b8': (2.51,3.58***REMOVED***,
             'b9': (1.76,2.51***REMOVED***,
             'b10': (1.26,1.76***REMOVED******REMOVED***

def _get_papertype(w, h***REMOVED***:
    keys = list(six.iterkeys(papersize***REMOVED******REMOVED***
    keys.sort(***REMOVED***
    keys.reverse(***REMOVED***
    for key in keys:
        if key.startswith('l'***REMOVED***: continue
        pw, ph = papersize[key***REMOVED***
        if (w < pw***REMOVED*** and (h < ph***REMOVED***: return key
    else:
        return 'a0'

def _num_to_str(val***REMOVED***:
    if is_string_like(val***REMOVED***: return val

    ival = int(val***REMOVED***
    if val==ival: return str(ival***REMOVED***

    s = "%1.3f"%val
    s = s.rstrip("0"***REMOVED***
    s = s.rstrip("."***REMOVED***
    return s

def _nums_to_str(*args***REMOVED***:
    return ' '.join(map(_num_to_str,args***REMOVED******REMOVED***


def quote_ps_string(s***REMOVED***:
    "Quote dangerous characters of S for use in a PostScript string constant."
    s = s.replace(b"\\", b"\\\\"***REMOVED***
    s = s.replace(b"(", b"\\("***REMOVED***
    s = s.replace(b"***REMOVED***", b"\\***REMOVED***"***REMOVED***
    s = s.replace(b"'", b"\\251"***REMOVED***
    s = s.replace(b"`", b"\\301"***REMOVED***
    s = re.sub(br"[^ -~\n***REMOVED***", lambda x: br"\%03o" % ord(x.group(***REMOVED******REMOVED***, s***REMOVED***
    return s.decode('ascii'***REMOVED***


def seq_allequal(seq1, seq2***REMOVED***:
    ***REMOVED***
    seq1 and seq2 are either None or sequences or arrays
    Return True if both are None or both are seqs with identical
    elements
    ***REMOVED***
    if seq1 is None:
        return seq2 is None

    if seq2 is None:
        return False
    #ok, neither are None:, assuming iterable

    if len(seq1***REMOVED*** != len(seq2***REMOVED***: return False
    return np.alltrue(np.equal(seq1, seq2***REMOVED******REMOVED***


class RendererPS(RendererBase***REMOVED***:
    ***REMOVED***
    The renderer handles all the drawing primitives using a graphics
    context instance that controls the colors/styles.
    ***REMOVED***

    fontd = maxdict(50***REMOVED***
    afmfontd = maxdict(50***REMOVED***

    def __init__(self, width, height, pswriter, imagedpi=72***REMOVED***:
        ***REMOVED***
        Although postscript itself is dpi independent, we need to
        imform the image code about a requested dpi to generate high
        res images and them scale them before embeddin them
        ***REMOVED***
        RendererBase.__init__(self***REMOVED***
        self.width = width
        self.height = height
        self._pswriter = pswriter
        if rcParams['text.usetex'***REMOVED***:
            self.textcnt = 0
            self.psfrag = [***REMOVED***
        self.imagedpi = imagedpi

        # current renderer state (None=uninitialised***REMOVED***
        self.color = None
        self.linewidth = None
        self.linejoin = None
        self.linecap = None
        self.linedash = None
        self.fontname = None
        self.fontsize = None
        self._hatches = {***REMOVED***
        self.image_magnification = imagedpi/72.0
        self._clip_paths = {***REMOVED***
        self._path_collection_id = 0

        self.used_characters = {***REMOVED***
        self.mathtext_parser = MathTextParser("PS"***REMOVED***

        self._afm_font_dir = os.path.join(
            rcParams['datapath'***REMOVED***, 'fonts', 'afm'***REMOVED***

    def track_characters(self, font, s***REMOVED***:
        ***REMOVED***Keeps track of which characters are required from
        each font.***REMOVED***
        realpath, stat_key = get_realpath_and_stat(font.fname***REMOVED***
        used_characters = self.used_characters.setdefault(
            stat_key, (realpath, set(***REMOVED******REMOVED******REMOVED***
        used_characters[1***REMOVED***.update([ord(x***REMOVED*** for x in s***REMOVED******REMOVED***

    def merge_used_characters(self, other***REMOVED***:
        for stat_key, (realpath, charset***REMOVED*** in six.iteritems(other***REMOVED***:
            used_characters = self.used_characters.setdefault(
                stat_key, (realpath, set(***REMOVED******REMOVED******REMOVED***
            used_characters[1***REMOVED***.update(charset***REMOVED***

    def set_color(self, r, g, b, store=1***REMOVED***:
        if (r,g,b***REMOVED*** != self.color:
            if r==g and r==b:
                self._pswriter.write("%1.3f setgray\n"%r***REMOVED***
            else:
                self._pswriter.write("%1.3f %1.3f %1.3f setrgbcolor\n"%(r,g,b***REMOVED******REMOVED***
            if store: self.color = (r,g,b***REMOVED***

    def set_linewidth(self, linewidth, store=1***REMOVED***:
        linewidth = float(linewidth***REMOVED***
        if linewidth != self.linewidth:
            self._pswriter.write("%1.3f setlinewidth\n"%linewidth***REMOVED***
            if store: self.linewidth = linewidth

    def set_linejoin(self, linejoin, store=1***REMOVED***:
        if linejoin != self.linejoin:
            self._pswriter.write("%d setlinejoin\n"%linejoin***REMOVED***
            if store: self.linejoin = linejoin

    def set_linecap(self, linecap, store=1***REMOVED***:
        if linecap != self.linecap:
            self._pswriter.write("%d setlinecap\n"%linecap***REMOVED***
            if store: self.linecap = linecap

    def set_linedash(self, offset, seq, store=1***REMOVED***:
        if self.linedash is not None:
            oldo, oldseq = self.linedash
            if seq_allequal(seq, oldseq***REMOVED***: return

        if seq is not None and len(seq***REMOVED***:
            s="[%s***REMOVED*** %d setdash\n"%(_nums_to_str(*seq***REMOVED***, offset***REMOVED***
            self._pswriter.write(s***REMOVED***
        else:
            self._pswriter.write("[***REMOVED*** 0 setdash\n"***REMOVED***
        if store: self.linedash = (offset,seq***REMOVED***

    def set_font(self, fontname, fontsize, store=1***REMOVED***:
        if rcParams['ps.useafm'***REMOVED***: return
        if (fontname,fontsize***REMOVED*** != (self.fontname,self.fontsize***REMOVED***:
            out = ("/%s findfont\n"
                   "%1.3f scalefont\n"
                   "setfont\n" % (fontname, fontsize***REMOVED******REMOVED***

            self._pswriter.write(out***REMOVED***
            if store: self.fontname = fontname
            if store: self.fontsize = fontsize

    def create_hatch(self, hatch***REMOVED***:
        sidelen = 72
        if hatch in self._hatches:
            return self._hatches[hatch***REMOVED***
        name = 'H%d' % len(self._hatches***REMOVED***
        self._pswriter.write(***REMOVED***\
  << /PatternType 1
     /PaintType 2
     /TilingType 2
     /BBox[0 0 %(sidelen***REMOVED***d %(sidelen***REMOVED***d***REMOVED***
     /XStep %(sidelen***REMOVED***d
     /YStep %(sidelen***REMOVED***d

     /PaintProc {
        pop
        0 setlinewidth
***REMOVED*** % locals(***REMOVED******REMOVED***
        self._pswriter.write(
            self._convert_path(Path.hatch(hatch***REMOVED***, Affine2D(***REMOVED***.scale(72.0***REMOVED***,
                               simplify=False***REMOVED******REMOVED***
        self._pswriter.write(***REMOVED***\
          stroke
 ***REMOVED*** bind
   >>
   matrix
   makepattern
   /%(name***REMOVED***s exch def
***REMOVED*** % locals(***REMOVED******REMOVED***
        self._hatches[hatch***REMOVED*** = name
        return name

    def get_canvas_width_height(self***REMOVED***:
        'return the canvas width and height in display coords'
        return self.width, self.height

    def get_text_width_height_descent(self, s, prop, ismath***REMOVED***:
        ***REMOVED***
        get the width and height in display coords of the string s
        with FontPropertry prop

        ***REMOVED***
        if rcParams['text.usetex'***REMOVED***:
            texmanager = self.get_texmanager(***REMOVED***
            fontsize = prop.get_size_in_points(***REMOVED***
            w, h, d = texmanager.get_text_width_height_descent(s, fontsize,
                                                               renderer=self***REMOVED***
            return w, h, d

        if ismath:
            width, height, descent, pswriter, used_characters = \
                self.mathtext_parser.parse(s, 72, prop***REMOVED***
            return width, height, descent

        if rcParams['ps.useafm'***REMOVED***:
            if ismath: s = s[1:-1***REMOVED***
            font = self._get_font_afm(prop***REMOVED***
            l,b,w,h,d = font.get_str_bbox_and_descent(s***REMOVED***

            fontsize = prop.get_size_in_points(***REMOVED***
            scale = 0.001*fontsize
            w *= scale
            h *= scale
            d *= scale
            return w, h, d

        font = self._get_font_ttf(prop***REMOVED***
        font.set_text(s, 0.0, flags=LOAD_NO_HINTING***REMOVED***
        w, h = font.get_width_height(***REMOVED***
        w /= 64.0  # convert from subpixels
        h /= 64.0
        d = font.get_descent(***REMOVED***
        d /= 64.0
        #print s, w, h
        return w, h, d

    def flipy(self***REMOVED***:
        'return true if small y numbers are top for renderer'
        return False

    def _get_font_afm(self, prop***REMOVED***:
        key = hash(prop***REMOVED***
        font = self.afmfontd.get(key***REMOVED***
        if font is None:
            fname = findfont(prop, fontext='afm', directory=self._afm_font_dir***REMOVED***
            if fname is None:
                fname = findfont(
                    "Helvetica", fontext='afm', directory=self._afm_font_dir***REMOVED***
            font = self.afmfontd.get(fname***REMOVED***
            if font is None:
                with io.open(fname, 'rb'***REMOVED*** as fh:
                    font = AFM(fh***REMOVED***
                self.afmfontd[fname***REMOVED*** = font
            self.afmfontd[key***REMOVED*** = font
        return font

    def _get_font_ttf(self, prop***REMOVED***:
        key = hash(prop***REMOVED***
        font = self.fontd.get(key***REMOVED***
        if font is None:
            fname = findfont(prop***REMOVED***
            font = self.fontd.get(fname***REMOVED***
            if font is None:
                font = FT2Font(fname***REMOVED***
                self.fontd[fname***REMOVED*** = font
            self.fontd[key***REMOVED*** = font
        font.clear(***REMOVED***
        size = prop.get_size_in_points(***REMOVED***
        font.set_size(size, 72.0***REMOVED***
        return font

    def _rgba(self, im***REMOVED***:
        return im.as_rgba_str(***REMOVED***

    def _rgb(self, im***REMOVED***:
        h,w,s = im.as_rgba_str(***REMOVED***

        rgba = np.fromstring(s, np.uint8***REMOVED***
        rgba.shape = (h, w, 4***REMOVED***
        rgb = rgba[::-1,:,:3***REMOVED***
        return h, w, rgb.tostring(***REMOVED***

    def _gray(self, im, rc=0.3, gc=0.59, bc=0.11***REMOVED***:
        rgbat = im.as_rgba_str(***REMOVED***
        rgba = np.fromstring(rgbat[2***REMOVED***, np.uint8***REMOVED***
        rgba.shape = (rgbat[0***REMOVED***, rgbat[1***REMOVED***, 4***REMOVED***
        rgba = rgba[::-1***REMOVED***
        rgba_f = rgba.astype(np.float32***REMOVED***
        r = rgba_f[:,:,0***REMOVED***
        g = rgba_f[:,:,1***REMOVED***
        b = rgba_f[:,:,2***REMOVED***
        gray = (r*rc + g*gc + b*bc***REMOVED***.astype(np.uint8***REMOVED***
        return rgbat[0***REMOVED***, rgbat[1***REMOVED***, gray.tostring(***REMOVED***

    def _hex_lines(self, s, chars_per_line=128***REMOVED***:
        s = binascii.b2a_hex(s***REMOVED***
        nhex = len(s***REMOVED***
        lines = [***REMOVED***
        for i in range(0,nhex,chars_per_line***REMOVED***:
            limit = min(i+chars_per_line, nhex***REMOVED***
            lines.append(s[i:limit***REMOVED******REMOVED***
        return lines

    def get_image_magnification(self***REMOVED***:
        ***REMOVED***
        Get the factor by which to magnify images passed to draw_image.
        Allows a backend to have images at a different resolution to other
        artists.
        ***REMOVED***
        return self.image_magnification

    def option_scale_image(self***REMOVED***:
        ***REMOVED***
        ps backend support arbitrary scaling of image.
        ***REMOVED***
        return True

    def option_image_nocomposite(self***REMOVED***:
        ***REMOVED***
        return whether to generate a composite image from multiple images on
        a set of axes
        ***REMOVED***
        return not rcParams['image.composite_image'***REMOVED***

    def _get_image_h_w_bits_command(self, im***REMOVED***:
        if im.is_grayscale:
            h, w, bits = self._gray(im***REMOVED***
            imagecmd = "image"
        else:
            h, w, bits = self._rgb(im***REMOVED***
            imagecmd = "false 3 colorimage"

        return h, w, bits, imagecmd

    def draw_image(self, gc, x, y, im, dx=None, dy=None, transform=None***REMOVED***:
        ***REMOVED***
        Draw the Image instance into the current axes; x is the
        distance in pixels from the left hand side of the canvas and y
        is the distance from bottom

        dx, dy is the width and height of the image.  If a transform
        (which must be an affine transform***REMOVED*** is given, x, y, dx, dy are
        interpreted as the coordinate of the transform.
        ***REMOVED***

        h, w, bits, imagecmd = self._get_image_h_w_bits_command(im***REMOVED***
        hexlines = b'\n'.join(self._hex_lines(bits***REMOVED******REMOVED***.decode('ascii'***REMOVED***

        if dx is None:
            xscale = w / self.image_magnification
        else:
            xscale = dx

        if dy is None:
            yscale = h/self.image_magnification
        else:
            yscale = dy


        if transform is None:
            matrix = "1 0 0 1 0 0"
        else:
            matrix = " ".join(map(str, transform.to_values(***REMOVED******REMOVED******REMOVED***

        figh = self.height*72
        #print 'values', origin, flipud, figh, h, y

        bbox = gc.get_clip_rectangle(***REMOVED***
        clippath, clippath_trans = gc.get_clip_path(***REMOVED***

        clip = [***REMOVED***
        if bbox is not None:
            clipx,clipy,clipw,cliph = bbox.bounds
            clip.append('%s clipbox' % _nums_to_str(clipw, cliph, clipx, clipy***REMOVED******REMOVED***
        if clippath is not None:
            id = self._get_clip_path(clippath, clippath_trans***REMOVED***
            clip.append('%s' % id***REMOVED***
        clip = '\n'.join(clip***REMOVED***

        #y = figh-(y+h***REMOVED***
        ps = ***REMOVED***gsave
%(clip***REMOVED***s
[%(matrix***REMOVED***s***REMOVED*** concat
%(x***REMOVED***s %(y***REMOVED***s translate
%(xscale***REMOVED***s %(yscale***REMOVED***s scale
/DataString %(w***REMOVED***s string def
%(w***REMOVED***s %(h***REMOVED***s 8 [ %(w***REMOVED***s 0 0 -%(h***REMOVED***s 0 %(h***REMOVED***s ***REMOVED***
{
currentfile DataString readhexstring pop
***REMOVED*** bind %(imagecmd***REMOVED***s
%(hexlines***REMOVED***s
grestore
***REMOVED*** % locals(***REMOVED***
        self._pswriter.write(ps***REMOVED***

    def _convert_path(self, path, transform, clip=False, simplify=None***REMOVED***:
        ps = [***REMOVED***
        last_points = None
        if clip:
            clip = (0.0, 0.0, self.width * 72.0,
                    self.height * 72.0***REMOVED***
        else:
            clip = None
        return _path.convert_to_string(
            path, transform, clip, simplify, None,
            6, [b'm', b'l', b'', b'c', b'cl'***REMOVED***, True***REMOVED***.decode('ascii'***REMOVED***

    def _get_clip_path(self, clippath, clippath_transform***REMOVED***:
        key = (clippath, id(clippath_transform***REMOVED******REMOVED***
        pid = self._clip_paths.get(key***REMOVED***
        if pid is None:
            pid = 'c%x' % len(self._clip_paths***REMOVED***
            ps_cmd = ['/%s {' % pid***REMOVED***
            ps_cmd.append(self._convert_path(clippath, clippath_transform,
                                             simplify=False***REMOVED******REMOVED***
            ps_cmd.extend(['clip', 'newpath', '***REMOVED*** bind def\n'***REMOVED******REMOVED***
            self._pswriter.write('\n'.join(ps_cmd***REMOVED******REMOVED***
            self._clip_paths[key***REMOVED*** = pid
        return pid

    def draw_path(self, gc, path, transform, rgbFace=None***REMOVED***:
        ***REMOVED***
        Draws a Path instance using the given affine transform.
        ***REMOVED***
        clip = (rgbFace is None and gc.get_hatch_path(***REMOVED*** is None***REMOVED***
        simplify = path.should_simplify and clip
        ps = self._convert_path(
            path, transform, clip=clip, simplify=simplify***REMOVED***
        self._draw_ps(ps, gc, rgbFace***REMOVED***

    def draw_markers(self, gc, marker_path, marker_trans, path, trans, rgbFace=None***REMOVED***:
        ***REMOVED***
        Draw the markers defined by path at each of the positions in x
        and y.  path coordinates are points, x and y coords will be
        transformed by the transform
        ***REMOVED***
        if debugPS: self._pswriter.write('% draw_markers \n'***REMOVED***

        write = self._pswriter.write

        if rgbFace:
            if rgbFace[0***REMOVED***==rgbFace[1***REMOVED*** and rgbFace[0***REMOVED***==rgbFace[2***REMOVED***:
                ps_color = '%1.3f setgray' % rgbFace[0***REMOVED***
            else:
                ps_color = '%1.3f %1.3f %1.3f setrgbcolor' % rgbFace[:3***REMOVED***

        # construct the generic marker command:
        ps_cmd = ['/o {', 'gsave', 'newpath', 'translate'***REMOVED*** # dont want the translate to be global

        lw = gc.get_linewidth(***REMOVED***
        stroke = lw != 0.0
        if stroke:
            ps_cmd.append('%.1f setlinewidth' % lw***REMOVED***
            jint = gc.get_joinstyle(***REMOVED***
            ps_cmd.append('%d setlinejoin' % jint***REMOVED***
            cint = gc.get_capstyle(***REMOVED***
            ps_cmd.append('%d setlinecap' % cint***REMOVED***

        ps_cmd.append(self._convert_path(marker_path, marker_trans,
                                         simplify=False***REMOVED******REMOVED***

        if rgbFace:
            if stroke:
                ps_cmd.append('gsave'***REMOVED***
            ps_cmd.extend([ps_color, 'fill'***REMOVED******REMOVED***
            if stroke:
                ps_cmd.append('grestore'***REMOVED***

        if stroke:
            ps_cmd.append('stroke'***REMOVED***
        ps_cmd.extend(['grestore', '***REMOVED*** bind def'***REMOVED******REMOVED***

        for vertices, code in path.iter_segments(
                trans,
                clip=(0, 0, self.width*72, self.height*72***REMOVED***,
                simplify=False***REMOVED***:
            if len(vertices***REMOVED***:
                x, y = vertices[-2:***REMOVED***
                ps_cmd.append("%g %g o" % (x, y***REMOVED******REMOVED***

        ps = '\n'.join(ps_cmd***REMOVED***
        self._draw_ps(ps, gc, rgbFace, fill=False, stroke=False***REMOVED***

    def draw_path_collection(self, gc, master_transform, paths, all_transforms,
                             offsets, offsetTrans, facecolors, edgecolors,
                             linewidths, linestyles, antialiaseds, urls,
                             offset_position***REMOVED***:
        # Is the optimization worth it? Rough calculation:
        # cost of emitting a path in-line is
        #     (len_path + 2***REMOVED*** * uses_per_path
        # cost of definition+use is
        #     (len_path + 3***REMOVED*** + 3 * uses_per_path
        len_path = len(paths[0***REMOVED***.vertices***REMOVED*** if len(paths***REMOVED*** > 0 else 0
        uses_per_path = self._iter_collection_uses_per_path(
            paths, all_transforms, offsets, facecolors, edgecolors***REMOVED***
        should_do_optimization = \
            len_path + 3 * uses_per_path + 3 < (len_path + 2***REMOVED*** * uses_per_path
        if not should_do_optimization:
            return RendererBase.draw_path_collection(
                self, gc, master_transform, paths, all_transforms,
                offsets, offsetTrans, facecolors, edgecolors,
                linewidths, linestyles, antialiaseds, urls,
                offset_position***REMOVED***

        write = self._pswriter.write

        path_codes = [***REMOVED***
        for i, (path, transform***REMOVED*** in enumerate(self._iter_collection_raw_paths(
            master_transform, paths, all_transforms***REMOVED******REMOVED***:
            name = 'p%x_%x' % (self._path_collection_id, i***REMOVED***
            ps_cmd = ['/%s {' % name,
                      'newpath', 'translate'***REMOVED***
            ps_cmd.append(self._convert_path(path, transform, simplify=False***REMOVED******REMOVED***
            ps_cmd.extend(['***REMOVED*** bind def\n'***REMOVED******REMOVED***
            write('\n'.join(ps_cmd***REMOVED******REMOVED***
            path_codes.append(name***REMOVED***

        for xo, yo, path_id, gc0, rgbFace in self._iter_collection(
            gc, master_transform, all_transforms, path_codes, offsets,
            offsetTrans, facecolors, edgecolors, linewidths, linestyles,
            antialiaseds, urls, offset_position***REMOVED***:
            ps = "%g %g %s" % (xo, yo, path_id***REMOVED***
            self._draw_ps(ps, gc0, rgbFace***REMOVED***

        self._path_collection_id += 1

    def draw_tex(self, gc, x, y, s, prop, angle, ismath='TeX!', mtext=None***REMOVED***:
        ***REMOVED***
        draw a Text instance
        ***REMOVED***
        w, h, bl = self.get_text_width_height_descent(s, prop, ismath***REMOVED***
        fontsize = prop.get_size_in_points(***REMOVED***
        thetext = 'psmarker%d' % self.textcnt
        color = '%1.3f,%1.3f,%1.3f'% gc.get_rgb(***REMOVED***[:3***REMOVED***
        fontcmd = {'sans-serif' : r'{\sffamily %s***REMOVED***',
               'monospace'  : r'{\ttfamily %s***REMOVED***'***REMOVED***.get(
                rcParams['font.family'***REMOVED***[0***REMOVED***, r'{\rmfamily %s***REMOVED***'***REMOVED***
        s = fontcmd % s
        tex = r'\color[rgb***REMOVED***{%s***REMOVED*** %s' % (color, s***REMOVED***

        corr = 0#w/2*(fontsize-10***REMOVED***/10
        if rcParams['text.latex.preview'***REMOVED***:
            # use baseline alignment!
            pos = _nums_to_str(x-corr, y***REMOVED***
            self.psfrag.append(r'\psfrag{%s***REMOVED***[Bl***REMOVED***[Bl***REMOVED***[1***REMOVED***[%f***REMOVED***{\fontsize{%f***REMOVED***{%f***REMOVED***%s***REMOVED***'%(thetext, angle, fontsize, fontsize*1.25, tex***REMOVED******REMOVED***
        else:
            # stick to the bottom alignment, but this may give incorrect baseline some times.
            pos = _nums_to_str(x-corr, y-bl***REMOVED***
            self.psfrag.append(r'\psfrag{%s***REMOVED***[bl***REMOVED***[bl***REMOVED***[1***REMOVED***[%f***REMOVED***{\fontsize{%f***REMOVED***{%f***REMOVED***%s***REMOVED***'%(thetext, angle, fontsize, fontsize*1.25, tex***REMOVED******REMOVED***

        ps = ***REMOVED***\
gsave
%(pos***REMOVED***s moveto
(%(thetext***REMOVED***s***REMOVED***
show
grestore
    ***REMOVED*** % locals(***REMOVED***

        self._pswriter.write(ps***REMOVED***
        self.textcnt += 1

    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None***REMOVED***:
        ***REMOVED***
        draw a Text instance
        ***REMOVED***
        # local to avoid repeated attribute lookups
        write = self._pswriter.write
        if debugPS:
            write("% text\n"***REMOVED***

        if ismath=='TeX':
            return self.tex(gc, x, y, s, prop, angle***REMOVED***

        elif ismath:
            return self.draw_mathtext(gc, x, y, s, prop, angle***REMOVED***

        elif rcParams['ps.useafm'***REMOVED***:
            self.set_color(*gc.get_rgb(***REMOVED******REMOVED***

            font = self._get_font_afm(prop***REMOVED***
            fontname = font.get_fontname(***REMOVED***
            fontsize = prop.get_size_in_points(***REMOVED***
            scale = 0.001*fontsize

            thisx = 0
            thisy = font.get_str_bbox_and_descent(s***REMOVED***[4***REMOVED*** * scale
            last_name = None
            lines = [***REMOVED***
            for c in s:
                name = uni2type1.get(ord(c***REMOVED***, 'question'***REMOVED***
                ***REMOVED***
                    width = font.get_width_from_char_name(name***REMOVED***
                except KeyError:
                    name = 'question'
                    width = font.get_width_char('?'***REMOVED***
                if last_name is not None:
                    kern = font.get_kern_dist_from_name(last_name, name***REMOVED***
                else:
                    kern = 0
                last_name = name
                thisx += kern * scale

                lines.append('%f %f m /%s glyphshow'%(thisx, thisy, name***REMOVED******REMOVED***

                thisx += width * scale

            thetext = "\n".join(lines***REMOVED***
            ps = ***REMOVED***\
gsave
/%(fontname***REMOVED***s findfont
%(fontsize***REMOVED***s scalefont
setfont
%(x***REMOVED***f %(y***REMOVED***f translate
%(angle***REMOVED***f rotate
%(thetext***REMOVED***s
grestore
    ***REMOVED*** % locals(***REMOVED***
            self._pswriter.write(ps***REMOVED***

        else:
            font = self._get_font_ttf(prop***REMOVED***
            font.set_text(s, 0, flags=LOAD_NO_HINTING***REMOVED***
            self.track_characters(font, s***REMOVED***

            self.set_color(*gc.get_rgb(***REMOVED******REMOVED***
            sfnt = font.get_sfnt(***REMOVED***
            ***REMOVED***
                ps_name = sfnt[(1,0,0,6***REMOVED******REMOVED***.decode('macroman'***REMOVED***
            except KeyError:
                ps_name = sfnt[(3,1,0x0409,6***REMOVED******REMOVED***.decode(
                    'utf-16be'***REMOVED***
            ps_name = ps_name.encode('ascii', 'replace'***REMOVED***.decode('ascii'***REMOVED***
            self.set_font(ps_name, prop.get_size_in_points(***REMOVED******REMOVED***

            cmap = font.get_charmap(***REMOVED***
            lastgind = None
            #print 'text', s
            lines = [***REMOVED***
            thisx = 0
            thisy = 0
            for c in s:
                ccode = ord(c***REMOVED***
                gind = cmap.get(ccode***REMOVED***
                if gind is None:
                    ccode = ord('?'***REMOVED***
                    name = '.notdef'
                    gind = 0
                else:
                    name = font.get_glyph_name(gind***REMOVED***
                glyph = font.load_char(ccode, flags=LOAD_NO_HINTING***REMOVED***

                if lastgind is not None:
                    kern = font.get_kerning(lastgind, gind, KERNING_DEFAULT***REMOVED***
                else:
                    kern = 0
                lastgind = gind
                thisx += kern/64.0

                lines.append('%f %f m /%s glyphshow'%(thisx, thisy, name***REMOVED******REMOVED***
                thisx += glyph.linearHoriAdvance/65536.0


            thetext = '\n'.join(lines***REMOVED***
            ps = ***REMOVED***gsave
%(x***REMOVED***f %(y***REMOVED***f translate
%(angle***REMOVED***f rotate
%(thetext***REMOVED***s
grestore
***REMOVED*** % locals(***REMOVED***
            self._pswriter.write(ps***REMOVED***

    def new_gc(self***REMOVED***:
        return GraphicsContextPS(***REMOVED***

    def draw_mathtext(self, gc,
        x, y, s, prop, angle***REMOVED***:
        ***REMOVED***
        Draw the math text using matplotlib.mathtext
        ***REMOVED***
        if debugPS:
            self._pswriter.write("% mathtext\n"***REMOVED***

        width, height, descent, pswriter, used_characters = \
            self.mathtext_parser.parse(s, 72, prop***REMOVED***
        self.merge_used_characters(used_characters***REMOVED***
        self.set_color(*gc.get_rgb(***REMOVED******REMOVED***
        thetext = pswriter.getvalue(***REMOVED***
        ps = ***REMOVED***gsave
%(x***REMOVED***f %(y***REMOVED***f translate
%(angle***REMOVED***f rotate
%(thetext***REMOVED***s
grestore
***REMOVED*** % locals(***REMOVED***
        self._pswriter.write(ps***REMOVED***

    def draw_gouraud_triangle(self, gc, points, colors, trans***REMOVED***:
        self.draw_gouraud_triangles(gc, points.reshape((1, 3, 2***REMOVED******REMOVED***,
                                    colors.reshape((1, 3, 4***REMOVED******REMOVED***, trans***REMOVED***

    def draw_gouraud_triangles(self, gc, points, colors, trans***REMOVED***:
        assert len(points***REMOVED*** == len(colors***REMOVED***
        assert points.ndim == 3
        assert points.shape[1***REMOVED*** == 3
        assert points.shape[2***REMOVED*** == 2
        assert colors.ndim == 3
        assert colors.shape[1***REMOVED*** == 3
        assert colors.shape[2***REMOVED*** == 4

        shape = points.shape
        flat_points = points.reshape((shape[0***REMOVED*** * shape[1***REMOVED***, 2***REMOVED******REMOVED***
        flat_points = trans.transform(flat_points***REMOVED***
        flat_colors = colors.reshape((shape[0***REMOVED*** * shape[1***REMOVED***, 4***REMOVED******REMOVED***
        points_min = np.min(flat_points, axis=0***REMOVED*** - (1 << 12***REMOVED***
        points_max = np.max(flat_points, axis=0***REMOVED*** + (1 << 12***REMOVED***
        factor = np.ceil(float(2 ** 32 - 1***REMOVED*** / (points_max - points_min***REMOVED******REMOVED***

        xmin, ymin = points_min
        xmax, ymax = points_max

        streamarr = np.empty(
            (shape[0***REMOVED*** * shape[1***REMOVED***,***REMOVED***,
            dtype=[('flags', 'u1'***REMOVED***,
                   ('points', '>u4', (2,***REMOVED******REMOVED***,
                   ('colors', 'u1', (3,***REMOVED******REMOVED******REMOVED******REMOVED***
        streamarr['flags'***REMOVED*** = 0
        streamarr['points'***REMOVED*** = (flat_points - points_min***REMOVED*** * factor
        streamarr['colors'***REMOVED*** = flat_colors[:, :3***REMOVED*** * 255.0

        stream = quote_ps_string(streamarr.tostring(***REMOVED******REMOVED***

        self._pswriter.write(***REMOVED***
gsave
<< /ShadingType 4
   /ColorSpace [/DeviceRGB***REMOVED***
   /BitsPerCoordinate 32
   /BitsPerComponent 8
   /BitsPerFlag 8
   /AntiAlias true
   /Decode [ %(xmin***REMOVED***f %(xmax***REMOVED***f %(ymin***REMOVED***f %(ymax***REMOVED***f 0 1 0 1 0 1 ***REMOVED***
   /DataSource (%(stream***REMOVED***s***REMOVED***
>>
shfill
grestore
***REMOVED*** % locals(***REMOVED******REMOVED***

    def _draw_ps(self, ps, gc, rgbFace, fill=True, stroke=True, command=None***REMOVED***:
        ***REMOVED***
        Emit the PostScript sniplet 'ps' with all the attributes from 'gc'
        applied.  'ps' must consist of PostScript commands to construct a path.

        The fill and/or stroke kwargs can be set to False if the
        'ps' string already includes filling and/or stroking, in
        which case _draw_ps is just supplying properties and
        clipping.
        ***REMOVED***
        # local variable eliminates all repeated attribute lookups
        write = self._pswriter.write
        if debugPS and command:
            write("% "+command+"\n"***REMOVED***
        mightstroke = gc.shouldstroke(***REMOVED***
        stroke = stroke and mightstroke
        fill = (fill and rgbFace is not None and
                (len(rgbFace***REMOVED*** <= 3 or rgbFace[3***REMOVED*** != 0.0***REMOVED******REMOVED***

        if mightstroke:
            self.set_linewidth(gc.get_linewidth(***REMOVED******REMOVED***
            jint = gc.get_joinstyle(***REMOVED***
            self.set_linejoin(jint***REMOVED***
            cint = gc.get_capstyle(***REMOVED***
            self.set_linecap(cint***REMOVED***
            self.set_linedash(*gc.get_dashes(***REMOVED******REMOVED***
            self.set_color(*gc.get_rgb(***REMOVED***[:3***REMOVED******REMOVED***
        write('gsave\n'***REMOVED***

        cliprect = gc.get_clip_rectangle(***REMOVED***
        if cliprect:
            x,y,w,h=cliprect.bounds
            write('%1.4g %1.4g %1.4g %1.4g clipbox\n' % (w,h,x,y***REMOVED******REMOVED***
        clippath, clippath_trans = gc.get_clip_path(***REMOVED***
        if clippath:
            id = self._get_clip_path(clippath, clippath_trans***REMOVED***
            write('%s\n' % id***REMOVED***

        # Jochen, is the strip necessary? - this could be a honking big string
        write(ps.strip(***REMOVED******REMOVED***
        write("\n"***REMOVED***

        if fill:
            if stroke:
                write("gsave\n"***REMOVED***
            self.set_color(store=0, *rgbFace[:3***REMOVED******REMOVED***
            write("fill\n"***REMOVED***
            if stroke:
                write("grestore\n"***REMOVED***

        hatch = gc.get_hatch(***REMOVED***
        if hatch:
            hatch_name = self.create_hatch(hatch***REMOVED***
            write("gsave\n"***REMOVED***
            write("[/Pattern [/DeviceRGB***REMOVED******REMOVED*** setcolorspace %f %f %f " % gc.get_rgb(***REMOVED***[:3***REMOVED******REMOVED***
            write("%s setcolor fill grestore\n" % hatch_name***REMOVED***

        if stroke:
            write("stroke\n"***REMOVED***

        write("grestore\n"***REMOVED***



class GraphicsContextPS(GraphicsContextBase***REMOVED***:
    def get_capstyle(self***REMOVED***:
        return {'butt':0,
                'round':1,
                'projecting':2***REMOVED***[GraphicsContextBase.get_capstyle(self***REMOVED******REMOVED***

    def get_joinstyle(self***REMOVED***:
        return {'miter':0,
                'round':1,
                'bevel':2***REMOVED***[GraphicsContextBase.get_joinstyle(self***REMOVED******REMOVED***

    def shouldstroke(self***REMOVED***:
        return (self.get_linewidth(***REMOVED*** > 0.0 and
                (len(self.get_rgb(***REMOVED******REMOVED*** <= 3 or self.get_rgb(***REMOVED***[3***REMOVED*** != 0.0***REMOVED******REMOVED***

def new_figure_manager(num, *args, **kwargs***REMOVED***:
    FigureClass = kwargs.pop('FigureClass', Figure***REMOVED***
    thisFig = FigureClass(*args, **kwargs***REMOVED***
    return new_figure_manager_given_figure(num, thisFig***REMOVED***


def new_figure_manager_given_figure(num, figure***REMOVED***:
    ***REMOVED***
    Create a new figure manager instance for the given figure.
    ***REMOVED***
    canvas = FigureCanvasPS(figure***REMOVED***
    manager = FigureManagerPS(canvas, num***REMOVED***
    return manager

class FigureCanvasPS(FigureCanvasBase***REMOVED***:
    _renderer_class = RendererPS

    fixed_dpi = 72

    def draw(self***REMOVED***:
        pass

    filetypes = {'ps'  : 'Postscript',
                 'eps' : 'Encapsulated Postscript'***REMOVED***

    def get_default_filetype(self***REMOVED***:
        return 'ps'

    def print_ps(self, outfile, *args, **kwargs***REMOVED***:
        return self._print_ps(outfile, 'ps', *args, **kwargs***REMOVED***

    def print_eps(self, outfile, *args, **kwargs***REMOVED***:
        return self._print_ps(outfile, 'eps', *args, **kwargs***REMOVED***

    def _print_ps(self, outfile, format, *args, **kwargs***REMOVED***:
        papertype = kwargs.pop("papertype", rcParams['ps.papersize'***REMOVED******REMOVED***
        papertype = papertype.lower(***REMOVED***
        if papertype == 'auto':
            pass
        elif papertype not in papersize:
            raise RuntimeError( '%s is not a valid papertype. Use one \
                    of %s'% (papertype, ', '.join(six.iterkeys(papersize***REMOVED******REMOVED******REMOVED******REMOVED***

        orientation = kwargs.pop("orientation", "portrait"***REMOVED***.lower(***REMOVED***
        if orientation == 'landscape': isLandscape = True
        elif orientation == 'portrait': isLandscape = False
        else: raise RuntimeError('Orientation must be "portrait" or "landscape"'***REMOVED***

        self.figure.set_dpi(72***REMOVED*** # Override the dpi kwarg
        imagedpi = kwargs.pop("dpi", 72***REMOVED***
        facecolor = kwargs.pop("facecolor", "w"***REMOVED***
        edgecolor = kwargs.pop("edgecolor", "w"***REMOVED***

        if rcParams['text.usetex'***REMOVED***:
            self._print_figure_tex(outfile, format, imagedpi, facecolor, edgecolor,
                                   orientation, isLandscape, papertype,
                                   **kwargs***REMOVED***
        else:
            self._print_figure(outfile, format, imagedpi, facecolor, edgecolor,
                               orientation, isLandscape, papertype,
                               **kwargs***REMOVED***

    def _print_figure(self, outfile, format, dpi=72, facecolor='w', edgecolor='w',
                      orientation='portrait', isLandscape=False, papertype=None,
                      **kwargs***REMOVED***:
        ***REMOVED***
        Render the figure to hardcopy.  Set the figure patch face and
        edge colors.  This is useful because some of the GUIs have a
        gray figure face color background and you'll probably want to
        override this on hardcopy

        If outfile is a string, it is interpreted as a file name.
        If the extension matches .ep* write encapsulated postscript,
        otherwise write a stand-alone PostScript file.

        If outfile is a file object, a stand-alone PostScript file is
        written into this file object.
        ***REMOVED***
        isEPSF = format == 'eps'
        passed_in_file_object = False
        if is_string_like(outfile***REMOVED***:
            title = outfile
        elif is_writable_file_like(outfile***REMOVED***:
            title = None
            passed_in_file_object = True
        else:
            raise ValueError("outfile must be a path or a file-like object"***REMOVED***

        # find the appropriate papertype
        width, height = self.figure.get_size_inches(***REMOVED***
        if papertype == 'auto':
            if isLandscape: papertype = _get_papertype(height, width***REMOVED***
            else: papertype = _get_papertype(width, height***REMOVED***

        if isLandscape: paperHeight, paperWidth = papersize[papertype***REMOVED***
        else: paperWidth, paperHeight = papersize[papertype***REMOVED***

        if rcParams['ps.usedistiller'***REMOVED*** and not papertype == 'auto':
            # distillers will improperly clip eps files if the pagesize is
            # too small
            if width>paperWidth or height>paperHeight:
                if isLandscape:
                    papertype = _get_papertype(height, width***REMOVED***
                    paperHeight, paperWidth = papersize[papertype***REMOVED***
                else:
                    papertype = _get_papertype(width, height***REMOVED***
                    paperWidth, paperHeight = papersize[papertype***REMOVED***

        # center the figure on the paper
        xo = 72*0.5*(paperWidth - width***REMOVED***
        yo = 72*0.5*(paperHeight - height***REMOVED***

        l, b, w, h = self.figure.bbox.bounds
        llx = xo
        lly = yo
        urx = llx + w
        ury = lly + h
        rotation = 0
        if isLandscape:
            llx, lly, urx, ury = lly, llx, ury, urx
            xo, yo = 72*paperHeight - yo, xo
            rotation = 90
        bbox = (llx, lly, urx, ury***REMOVED***

        # generate PostScript code for the figure and store it in a string
        origfacecolor = self.figure.get_facecolor(***REMOVED***
        origedgecolor = self.figure.get_edgecolor(***REMOVED***
        self.figure.set_facecolor(facecolor***REMOVED***
        self.figure.set_edgecolor(edgecolor***REMOVED***


        dryrun = kwargs.get("dryrun", False***REMOVED***
        if dryrun:
            class NullWriter(object***REMOVED***:
                def write(self, *kl, **kwargs***REMOVED***:
                    pass

            self._pswriter = NullWriter(***REMOVED***
        else:
            self._pswriter = io.StringIO(***REMOVED***


        # mixed mode rendering
        _bbox_inches_restore = kwargs.pop("bbox_inches_restore", None***REMOVED***
        ps_renderer = self._renderer_class(width, height, self._pswriter,
                                           imagedpi=dpi***REMOVED***
        renderer = MixedModeRenderer(self.figure,
            width, height, dpi, ps_renderer,
            bbox_inches_restore=_bbox_inches_restore***REMOVED***

        self.figure.draw(renderer***REMOVED***

        if dryrun: # return immediately if dryrun (tightbbox=True***REMOVED***
            return

        self.figure.set_facecolor(origfacecolor***REMOVED***
        self.figure.set_edgecolor(origedgecolor***REMOVED***

        def print_figure_impl(***REMOVED***:
            # write the PostScript headers
            if isEPSF: print("%!PS-Adobe-3.0 EPSF-3.0", file=fh***REMOVED***
            else: print("%!PS-Adobe-3.0", file=fh***REMOVED***
            if title: print("%%Title: "+title, file=fh***REMOVED***
            print(("%%Creator: matplotlib version "
                         +__version__+", http://matplotlib.org/"***REMOVED***, file=fh***REMOVED***
            print("%%CreationDate: "+time.ctime(time.time(***REMOVED******REMOVED***, file=fh***REMOVED***
            print("%%Orientation: " + orientation, file=fh***REMOVED***
            if not isEPSF: print("%%DocumentPaperSizes: "+papertype, file=fh***REMOVED***
            print("%%%%BoundingBox: %d %d %d %d" % bbox, file=fh***REMOVED***
            if not isEPSF: print("%%Pages: 1", file=fh***REMOVED***
            print("%%EndComments", file=fh***REMOVED***

            Ndict = len(psDefs***REMOVED***
            print("%%BeginProlog", file=fh***REMOVED***
            if not rcParams['ps.useafm'***REMOVED***:
                Ndict += len(ps_renderer.used_characters***REMOVED***
            print("/mpldict %d dict def"%Ndict, file=fh***REMOVED***
            print("mpldict begin", file=fh***REMOVED***
            for d in psDefs:
                d=d.strip(***REMOVED***
                for l in d.split('\n'***REMOVED***:
                    print(l.strip(***REMOVED***, file=fh***REMOVED***
            if not rcParams['ps.useafm'***REMOVED***:
                for font_filename, chars in six.itervalues(ps_renderer.used_characters***REMOVED***:
                    if len(chars***REMOVED***:
                        font = FT2Font(font_filename***REMOVED***
                        cmap = font.get_charmap(***REMOVED***
                        glyph_ids = [***REMOVED***
                        for c in chars:
                            gind = cmap.get(c***REMOVED*** or 0
                            glyph_ids.append(gind***REMOVED***

                        fonttype = rcParams['ps.fonttype'***REMOVED***

                        # Can not use more than 255 characters from a
                        # single font for Type 3
                        if len(glyph_ids***REMOVED*** > 255:
                            fonttype = 42

                        # The ttf to ps (subsetting***REMOVED*** support doesn't work for
                        # OpenType fonts that are Postscript inside (like the
                        # STIX fonts***REMOVED***.  This will simply turn that off to avoid
                        # errors.
                        if is_opentype_cff_font(font_filename***REMOVED***:
                            raise RuntimeError("OpenType CFF fonts can not be saved using the internal Postscript backend at this time.\nConsider using the Cairo backend."***REMOVED***
                        else:
                            fh.flush(***REMOVED***
                            convert_ttf_to_ps(
                                font_filename.encode(sys.getfilesystemencoding(***REMOVED******REMOVED***,
                                fh, fonttype, glyph_ids***REMOVED***
            print("end", file=fh***REMOVED***
            print("%%EndProlog", file=fh***REMOVED***

            if not isEPSF: print("%%Page: 1 1", file=fh***REMOVED***
            print("mpldict begin", file=fh***REMOVED***
            #print >>fh, "gsave"
            print("%s translate"%_nums_to_str(xo, yo***REMOVED***, file=fh***REMOVED***
            if rotation: print("%d rotate"%rotation, file=fh***REMOVED***
            print("%s clipbox"%_nums_to_str(width*72, height*72, 0, 0***REMOVED***, file=fh***REMOVED***
            # Disable any sort of miter limit
            print("%s setmiterlimit" % 100000, file=fh***REMOVED***

            # write the figure
            content = self._pswriter.getvalue(***REMOVED***
            if not isinstance(content, six.text_type***REMOVED***:
                content = content.decode('ascii'***REMOVED***
            print(content, file=fh***REMOVED***

            # write the trailer
            #print >>fh, "grestore"
            print("end", file=fh***REMOVED***
            print("showpage", file=fh***REMOVED***
            if not isEPSF: print("%%EOF", file=fh***REMOVED***
            fh.flush(***REMOVED***

        if rcParams['ps.usedistiller'***REMOVED***:
            # We are going to use an external program to process the output.
            # Write to a temporary file.
            fd, tmpfile = mkstemp(***REMOVED***
            with io.open(fd, 'w', encoding='latin-1'***REMOVED*** as fh:
                print_figure_impl(***REMOVED***
        else:
            # Write directly to outfile.
            if passed_in_file_object:
                requires_unicode = file_requires_unicode(outfile***REMOVED***

                if (not requires_unicode and
                    (six.PY3 or not isinstance(outfile, StringIO***REMOVED******REMOVED******REMOVED***:
                    fh = io.TextIOWrapper(outfile, encoding="latin-1"***REMOVED***
                    # Prevent the io.TextIOWrapper from closing the
                    # underlying file
                    def do_nothing(***REMOVED***:
                        pass
                    fh.close = do_nothing
                else:
                    fh = outfile

                print_figure_impl(***REMOVED***
            else:
                with io.open(outfile, 'w', encoding='latin-1'***REMOVED*** as fh:
                    print_figure_impl(***REMOVED***

        if rcParams['ps.usedistiller'***REMOVED***:
            if rcParams['ps.usedistiller'***REMOVED*** == 'ghostscript':
                gs_distill(tmpfile, isEPSF, ptype=papertype, bbox=bbox***REMOVED***
            elif rcParams['ps.usedistiller'***REMOVED*** == 'xpdf':
                xpdf_distill(tmpfile, isEPSF, ptype=papertype, bbox=bbox***REMOVED***

            if passed_in_file_object:
                if file_requires_unicode(outfile***REMOVED***:
                    with io.open(tmpfile, 'rb'***REMOVED*** as fh:
                        outfile.write(fh.read(***REMOVED***.decode('latin-1'***REMOVED******REMOVED***
                else:
                    with io.open(tmpfile, 'rb'***REMOVED*** as fh:
                        outfile.write(fh.read(***REMOVED******REMOVED***
            else:
                with io.open(outfile, 'w'***REMOVED*** as fh:
                    pass
                mode = os.stat(outfile***REMOVED***.st_mode
                shutil.move(tmpfile, outfile***REMOVED***
                os.chmod(outfile, mode***REMOVED***

    def _print_figure_tex(self, outfile, format, dpi, facecolor, edgecolor,
                          orientation, isLandscape, papertype,
                          **kwargs***REMOVED***:
        ***REMOVED***
        If text.usetex is True in rc, a temporary pair of tex/eps files
        are created to allow tex to manage the text layout via the PSFrags
        package. These files are processed to yield the final ps or eps file.
        ***REMOVED***
        isEPSF = format == 'eps'
        if is_string_like(outfile***REMOVED***:
            title = outfile
        elif is_writable_file_like(outfile***REMOVED***:
            title = None
        else:
            raise ValueError("outfile must be a path or a file-like object"***REMOVED***

        self.figure.dpi = 72 # ignore the dpi kwarg
        width, height = self.figure.get_size_inches(***REMOVED***
        xo = 0
        yo = 0

        l, b, w, h = self.figure.bbox.bounds
        llx = xo
        lly = yo
        urx = llx + w
        ury = lly + h
        bbox = (llx, lly, urx, ury***REMOVED***

        # generate PostScript code for the figure and store it in a string
        origfacecolor = self.figure.get_facecolor(***REMOVED***
        origedgecolor = self.figure.get_edgecolor(***REMOVED***
        self.figure.set_facecolor(facecolor***REMOVED***
        self.figure.set_edgecolor(edgecolor***REMOVED***

        dryrun = kwargs.get("dryrun", False***REMOVED***
        if dryrun:
            class NullWriter(object***REMOVED***:
                def write(self, *kl, **kwargs***REMOVED***:
                    pass

            self._pswriter = NullWriter(***REMOVED***
        else:
            self._pswriter = io.StringIO(***REMOVED***


        # mixed mode rendering
        _bbox_inches_restore = kwargs.pop("bbox_inches_restore", None***REMOVED***
        ps_renderer = self._renderer_class(width, height,
                                           self._pswriter, imagedpi=dpi***REMOVED***
        renderer = MixedModeRenderer(self.figure,
            width, height, dpi, ps_renderer,
            bbox_inches_restore=_bbox_inches_restore***REMOVED***

        self.figure.draw(renderer***REMOVED***

        if dryrun: # return immediately if dryrun (tightbbox=True***REMOVED***
            return

        self.figure.set_facecolor(origfacecolor***REMOVED***
        self.figure.set_edgecolor(origedgecolor***REMOVED***

        # write to a temp file, we'll move it to outfile when done
        fd, tmpfile = mkstemp(***REMOVED***
        with io.open(fd, 'w', encoding='latin-1'***REMOVED*** as fh:
            # write the Encapsulated PostScript headers
            print("%!PS-Adobe-3.0 EPSF-3.0", file=fh***REMOVED***
            if title: print("%%Title: "+title, file=fh***REMOVED***
            print(("%%Creator: matplotlib version "
                         +__version__+", http://matplotlib.org/"***REMOVED***, file=fh***REMOVED***
            print("%%CreationDate: "+time.ctime(time.time(***REMOVED******REMOVED***, file=fh***REMOVED***
            print("%%%%BoundingBox: %d %d %d %d" % bbox, file=fh***REMOVED***
            print("%%EndComments", file=fh***REMOVED***

            Ndict = len(psDefs***REMOVED***
            print("%%BeginProlog", file=fh***REMOVED***
            print("/mpldict %d dict def"%Ndict, file=fh***REMOVED***
            print("mpldict begin", file=fh***REMOVED***
            for d in psDefs:
                d=d.strip(***REMOVED***
                for l in d.split('\n'***REMOVED***:
                    print(l.strip(***REMOVED***, file=fh***REMOVED***
            print("end", file=fh***REMOVED***
            print("%%EndProlog", file=fh***REMOVED***

            print("mpldict begin", file=fh***REMOVED***
            #print >>fh, "gsave"
            print("%s translate"%_nums_to_str(xo, yo***REMOVED***, file=fh***REMOVED***
            print("%s clipbox"%_nums_to_str(width*72, height*72, 0, 0***REMOVED***, file=fh***REMOVED***
            # Disable any sort of miter limit
            print("%d setmiterlimit" % 100000, file=fh***REMOVED***

            # write the figure
            print(self._pswriter.getvalue(***REMOVED***, file=fh***REMOVED***

            # write the trailer
            #print >>fh, "grestore"
            print("end", file=fh***REMOVED***
            print("showpage", file=fh***REMOVED***
            fh.flush(***REMOVED***

        if isLandscape: # now we are ready to rotate
            isLandscape = True
            width, height = height, width
            bbox = (lly, llx, ury, urx***REMOVED***

        # set the paper size to the figure size if isEPSF. The
        # resulting ps file has the given size with correct bounding
        # box so that there is no need to call 'pstoeps'
        if isEPSF:
            paperWidth, paperHeight = self.figure.get_size_inches(***REMOVED***
            if isLandscape:
                paperWidth, paperHeight = paperHeight, paperWidth
        else:
            temp_papertype = _get_papertype(width, height***REMOVED***
            if papertype=='auto':
                papertype = temp_papertype
                paperWidth, paperHeight = papersize[temp_papertype***REMOVED***
            else:
                paperWidth, paperHeight = papersize[papertype***REMOVED***
                if (width>paperWidth or height>paperHeight***REMOVED*** and isEPSF:
                    paperWidth, paperHeight = papersize[temp_papertype***REMOVED***
                    verbose.report('Your figure is too big to fit on %s paper. %s \
    paper will be used to prevent clipping.'%(papertype, temp_papertype***REMOVED***, 'helpful'***REMOVED***


        texmanager = ps_renderer.get_texmanager(***REMOVED***
        font_preamble = texmanager.get_font_preamble(***REMOVED***
        custom_preamble = texmanager.get_custom_preamble(***REMOVED***

        psfrag_rotated = convert_psfrags(tmpfile, ps_renderer.psfrag,
                                         font_preamble,
                                         custom_preamble, paperWidth, paperHeight,
                                         orientation***REMOVED***

        if rcParams['ps.usedistiller'***REMOVED*** == 'ghostscript':
            gs_distill(tmpfile, isEPSF, ptype=papertype, bbox=bbox,
                       rotated=psfrag_rotated***REMOVED***
        elif rcParams['ps.usedistiller'***REMOVED*** == 'xpdf':
            xpdf_distill(tmpfile, isEPSF, ptype=papertype, bbox=bbox,
                         rotated=psfrag_rotated***REMOVED***
        elif rcParams['text.usetex'***REMOVED***:
            if False: pass # for debugging
            else: gs_distill(tmpfile, isEPSF, ptype=papertype, bbox=bbox,
                             rotated=psfrag_rotated***REMOVED***

        if is_writable_file_like(outfile***REMOVED***:
            if file_requires_unicode(outfile***REMOVED***:
                with io.open(tmpfile, 'rb'***REMOVED*** as fh:
                    outfile.write(fh.read(***REMOVED***.decode('latin-1'***REMOVED******REMOVED***
            else:
                with io.open(tmpfile, 'rb'***REMOVED*** as fh:
                    outfile.write(fh.read(***REMOVED******REMOVED***
        else:
            with io.open(outfile, 'wb'***REMOVED*** as fh:
                pass
            mode = os.stat(outfile***REMOVED***.st_mode
            shutil.move(tmpfile, outfile***REMOVED***
            os.chmod(outfile, mode***REMOVED***

def convert_psfrags(tmpfile, psfrags, font_preamble, custom_preamble,
                    paperWidth, paperHeight, orientation***REMOVED***:
    ***REMOVED***
    When we want to use the LaTeX backend with postscript, we write PSFrag tags
    to a temporary postscript file, each one marking a position for LaTeX to
    render some text. convert_psfrags generates a LaTeX document containing the
    commands to convert those tags to text. LaTeX/dvips produces the postscript
    file that includes the actual text.
    ***REMOVED***
    tmpdir = os.path.split(tmpfile***REMOVED***[0***REMOVED***
    epsfile = tmpfile+'.eps'
    shutil.move(tmpfile, epsfile***REMOVED***
    latexfile = tmpfile+'.tex'
    outfile = tmpfile+'.output'
    dvifile = tmpfile+'.dvi'
    psfile = tmpfile+'.ps'

    if orientation=='landscape': angle = 90
    else: angle = 0

    if rcParams['text.latex.unicode'***REMOVED***:
        unicode_preamble = ***REMOVED***\\usepackage{ucs***REMOVED***
\\usepackage[utf8x***REMOVED***{inputenc***REMOVED******REMOVED***
    else:
        unicode_preamble = ''

    s = ***REMOVED***\\documentclass{article***REMOVED***
%s
%s
%s
\\usepackage[dvips, papersize={%sin,%sin***REMOVED***, body={%sin,%sin***REMOVED***, margin={0in,0in***REMOVED******REMOVED***{geometry***REMOVED***
\\usepackage{psfrag***REMOVED***
\\usepackage[dvips***REMOVED***{graphicx***REMOVED***
\\usepackage{color***REMOVED***
\\pagestyle{empty***REMOVED***
\\begin{document***REMOVED***
\\begin{figure***REMOVED***
\\centering
\\leavevmode
%s
\\includegraphics*[angle=%s***REMOVED***{%s***REMOVED***
\\end{figure***REMOVED***
\\end{document***REMOVED***
***REMOVED***% (font_preamble, unicode_preamble, custom_preamble, paperWidth, paperHeight,
      paperWidth, paperHeight,
      '\n'.join(psfrags***REMOVED***, angle, os.path.split(epsfile***REMOVED***[-1***REMOVED******REMOVED***

    with io.open(latexfile, 'wb'***REMOVED*** as latexh:
        if rcParams['text.latex.unicode'***REMOVED***:
            latexh.write(s.encode('utf8'***REMOVED******REMOVED***
        else:
            ***REMOVED***
                latexh.write(s.encode('ascii'***REMOVED******REMOVED***
            except UnicodeEncodeError:
                verbose.report("You are using unicode and latex, but have "
                               "not enabled the matplotlib 'text.latex.unicode' "
                               "rcParam.", 'helpful'***REMOVED***
                raise

    # the split drive part of the command is necessary for windows users with
    # multiple
    if sys.platform == 'win32': precmd = '%s &&'% os.path.splitdrive(tmpdir***REMOVED***[0***REMOVED***
    else: precmd = ''
    #Replace \\ for / so latex does not think there is a function call
    latexfile = latexfile.replace("\\", "/"***REMOVED***
    # Replace ~ so Latex does not think it is line break
    latexfile = latexfile.replace("~", "\\string~"***REMOVED***
    command = '%s cd "%s" && latex -interaction=nonstopmode "%s" > "%s"'\
                %(precmd, tmpdir, latexfile, outfile***REMOVED***
    verbose.report(command, 'debug'***REMOVED***
    exit_status = os.system(command***REMOVED***

    with io.open(outfile, 'rb'***REMOVED*** as fh:
        if exit_status:
            raise RuntimeError('LaTeX was not able to process your file:\
    \nHere is the full report generated by LaTeX: \n\n%s'% fh.read(***REMOVED******REMOVED***
        else:
            verbose.report(fh.read(***REMOVED***, 'debug'***REMOVED***
    os.remove(outfile***REMOVED***

    command = '%s cd "%s" && dvips -q -R0 -o "%s" "%s" > "%s"'%(precmd, tmpdir,
                os.path.split(psfile***REMOVED***[-1***REMOVED***, os.path.split(dvifile***REMOVED***[-1***REMOVED***, outfile***REMOVED***
    verbose.report(command, 'debug'***REMOVED***
    exit_status = os.system(command***REMOVED***

    with io.open(outfile, 'rb'***REMOVED*** as fh:
        if exit_status:
            raise RuntimeError('dvips was not able to \
    process the following file:\n%s\nHere is the full report generated by dvips: \
    \n\n'% dvifile + fh.read(***REMOVED******REMOVED***
        else:
            verbose.report(fh.read(***REMOVED***, 'debug'***REMOVED***
    os.remove(outfile***REMOVED***
    os.remove(epsfile***REMOVED***
    shutil.move(psfile, tmpfile***REMOVED***

    # check if the dvips created a ps in landscape paper.  Somehow,
    # above latex+dvips results in a ps file in a landscape mode for a
    # certain figure sizes (e.g., 8.3in,5.8in which is a5***REMOVED***. And the
    # bounding box of the final output got messed up. We check see if
    # the generated ps file is in landscape and return this
    # information. The return value is used in pstoeps step to recover
    # the correct bounding box. 2010-06-05 JJL
    with io.open(tmpfile***REMOVED*** as fh:
        if "Landscape" in fh.read(1000***REMOVED***:
            psfrag_rotated = True
        else:
            psfrag_rotated = False

    if not debugPS:
        for fname in glob.glob(tmpfile+'.*'***REMOVED***:
            os.remove(fname***REMOVED***

    return psfrag_rotated

def gs_distill(tmpfile, eps=False, ptype='letter', bbox=None, rotated=False***REMOVED***:
    ***REMOVED***
    Use ghostscript's pswrite or epswrite device to distill a file.
    This yields smaller files without illegal encapsulated postscript
    operators. The output is low-level, converting text to outlines.
    ***REMOVED***

    if eps: paper_option = "-dEPSCrop"
    else: paper_option = "-sPAPERSIZE=%s" % ptype

    psfile = tmpfile + '.ps'
    outfile = tmpfile + '.output'
    dpi = rcParams['ps.distiller.res'***REMOVED***


    gs_exe = ps_backend_helper.gs_exe
    if ps_backend_helper.supports_ps2write: # gs version >= 9
        device_name = "ps2write"
    else:
        device_name = "pswrite"

    command = '%s -dBATCH -dNOPAUSE -r%d -sDEVICE=%s %s -sOutputFile="%s" \
                "%s" > "%s"'% (gs_exe, dpi, device_name,
                               paper_option, psfile, tmpfile, outfile***REMOVED***

    verbose.report(command, 'debug'***REMOVED***
    exit_status = os.system(command***REMOVED***

    with io.open(outfile, 'rb'***REMOVED*** as fh:
        if exit_status:
            raise RuntimeError('ghostscript was not able to process \
    your image.\nHere is the full report generated by ghostscript:\n\n' + fh.read(***REMOVED******REMOVED***
        else:
            verbose.report(fh.read(***REMOVED***, 'debug'***REMOVED***
    os.remove(outfile***REMOVED***
    os.remove(tmpfile***REMOVED***
    shutil.move(psfile, tmpfile***REMOVED***


    # While it is best if above steps preserve the original bounding
    # box, there seem to be cases when it is not. For those cases,
    # the original bbox can be restored during the pstoeps step.

    if eps:
        # For some versions of gs, above steps result in an ps file
        # where the original bbox is no more correct. Do not adjust
        # bbox for now.
        if ps_backend_helper.supports_ps2write:
            # fo gs version >= 9 w/ ps2write device
            pstoeps(tmpfile, bbox, rotated=rotated***REMOVED***
        else:
            pstoeps(tmpfile***REMOVED***


def xpdf_distill(tmpfile, eps=False, ptype='letter', bbox=None, rotated=False***REMOVED***:
    ***REMOVED***
    Use ghostscript's ps2pdf and xpdf's/poppler's pdftops to distill a file.
    This yields smaller files without illegal encapsulated postscript
    operators. This distiller is preferred, generating high-level postscript
    output that treats text as text.
    ***REMOVED***
    pdffile = tmpfile + '.pdf'
    psfile = tmpfile + '.ps'
    outfile = tmpfile + '.output'

    if eps: paper_option = "-dEPSCrop"
    else: paper_option = "-sPAPERSIZE=%s" % ptype

    command = 'ps2pdf -dAutoFilterColorImages=false \
-dAutoFilterGrayImages=false -sGrayImageFilter=FlateEncode \
-sColorImageFilter=FlateEncode %s "%s" "%s" > "%s"'% \
(paper_option, tmpfile, pdffile, outfile***REMOVED***
    if sys.platform == 'win32': command = command.replace('=', '#'***REMOVED***
    verbose.report(command, 'debug'***REMOVED***
    exit_status = os.system(command***REMOVED***
    with io.open(outfile, 'rb'***REMOVED*** as fh:
        if exit_status:
            raise RuntimeError('ps2pdf was not able to process your \
image.\n\Here is the report generated by ghostscript:\n\n' + fh.read(***REMOVED******REMOVED***
        else:
            verbose.report(fh.read(***REMOVED***, 'debug'***REMOVED***
    os.remove(outfile***REMOVED***
    command = 'pdftops -paper match -level2 "%s" "%s" > "%s"'% \
                (pdffile, psfile, outfile***REMOVED***
    verbose.report(command, 'debug'***REMOVED***
    exit_status = os.system(command***REMOVED***

    with io.open(outfile, 'rb'***REMOVED*** as fh:
        if exit_status:
            raise RuntimeError('pdftops was not able to process your \
image.\nHere is the full report generated by pdftops: \n\n' + fh.read(***REMOVED******REMOVED***
        else:
            verbose.report(fh.read(***REMOVED***, 'debug'***REMOVED***
    os.remove(outfile***REMOVED***
    os.remove(tmpfile***REMOVED***
    shutil.move(psfile, tmpfile***REMOVED***

    if eps:
        pstoeps(tmpfile***REMOVED***

    for fname in glob.glob(tmpfile+'.*'***REMOVED***:
        os.remove(fname***REMOVED***

def get_bbox_header(lbrt, rotated=False***REMOVED***:
    ***REMOVED***
    return a postscript header stringfor the given bbox lbrt=(l, b, r, t***REMOVED***.
    Optionally, return rotate command.
    ***REMOVED***

    l, b, r, t = lbrt
    if  rotated:
        rotate = "%.2f %.2f  translate\n90 rotate" % (l+r, 0***REMOVED***
    else:
        rotate = ""
    bbox_info = '%%%%BoundingBox: %d %d %d %d' % (l, b, np.ceil(r***REMOVED***, np.ceil(t***REMOVED******REMOVED***
    hires_bbox_info = '%%%%HiResBoundingBox: %.6f %.6f %.6f %.6f' % (l, b, r, t***REMOVED***

    return '\n'.join([bbox_info, hires_bbox_info***REMOVED******REMOVED***, rotate


# get_bbox is deprecated. I don't see any reason to use ghostscript to
# find the bounding box, as the required bounding box is alread known.
def get_bbox(tmpfile, bbox***REMOVED***:
    ***REMOVED***
    Use ghostscript's bbox device to find the center of the bounding box. Return
    an appropriately sized bbox centered around that point. A bit of a hack.
    ***REMOVED***

    outfile = tmpfile + '.output'
    gs_exe = ps_backend_helper.gs_exe
    command = '%s -dBATCH -dNOPAUSE -sDEVICE=bbox "%s"' %\
                (gs_exe, tmpfile***REMOVED***
    verbose.report(command, 'debug'***REMOVED***
    stdin, stdout, stderr = os.popen3(command***REMOVED***
    verbose.report(stdout.read(***REMOVED***, 'debug-annoying'***REMOVED***
    bbox_info = stderr.read(***REMOVED***
    verbose.report(bbox_info, 'helpful'***REMOVED***
    bbox_found = re.search('%%HiResBoundingBox: .*', bbox_info***REMOVED***
    if bbox_found:
        bbox_info = bbox_found.group(***REMOVED***
    else:
        raise RuntimeError('Ghostscript was not able to extract a bounding box.\
Here is the Ghostscript output:\n\n%s'% bbox_info***REMOVED***
    l, b, r, t = [float(i***REMOVED*** for i in bbox_info.split(***REMOVED***[-4:***REMOVED******REMOVED***

    # this is a hack to deal with the fact that ghostscript does not return the
    # intended bbox, but a tight bbox. For now, we just center the ink in the
    # intended bbox. This is not ideal, users may intend the ink to not be
    # centered.
    if bbox is None:
        l, b, r, t = (l-1, b-1, r+1, t+1***REMOVED***
    else:
        x = (l+r***REMOVED***/2
        y = (b+t***REMOVED***/2
        dx = (bbox[2***REMOVED***-bbox[0***REMOVED******REMOVED***/2
        dy = (bbox[3***REMOVED***-bbox[1***REMOVED******REMOVED***/2
        l,b,r,t = (x-dx, y-dy, x+dx, y+dy***REMOVED***

    bbox_info = '%%%%BoundingBox: %d %d %d %d' % (l, b, np.ceil(r***REMOVED***, np.ceil(t***REMOVED******REMOVED***
    hires_bbox_info = '%%%%HiResBoundingBox: %.6f %.6f %.6f %.6f' % (l, b, r, t***REMOVED***

    return '\n'.join([bbox_info, hires_bbox_info***REMOVED******REMOVED***


def pstoeps(tmpfile, bbox=None, rotated=False***REMOVED***:
    ***REMOVED***
    Convert the postscript to encapsulated postscript.  The bbox of
    the eps file will be replaced with the given *bbox* argument. If
    None, original bbox will be used.
    ***REMOVED***

    # if rotated==True, the output eps file need to be rotated
    if bbox:
        bbox_info, rotate = get_bbox_header(bbox, rotated=rotated***REMOVED***
    else:
        bbox_info, rotate = None, None

    epsfile = tmpfile + '.eps'
    with io.open(epsfile, 'wb'***REMOVED*** as epsh:
        write = epsh.write
        with io.open(tmpfile, 'rb'***REMOVED*** as tmph:
            line = tmph.readline(***REMOVED***
            # Modify the header:
            while line:
                if line.startswith(b'%!PS'***REMOVED***:
                    write(b"%!PS-Adobe-3.0 EPSF-3.0\n"***REMOVED***
                    if bbox:
                        write(bbox_info.encode('ascii'***REMOVED*** + b'\n'***REMOVED***
                elif line.startswith(b'%%EndComments'***REMOVED***:
                    write(line***REMOVED***
                    write(b'%%BeginProlog\n'***REMOVED***
                    write(b'save\n'***REMOVED***
                    write(b'countdictstack\n'***REMOVED***
                    write(b'mark\n'***REMOVED***
                    write(b'newpath\n'***REMOVED***
                    write(b'/showpage {***REMOVED*** def\n'***REMOVED***
                    write(b'/setpagedevice {pop***REMOVED*** def\n'***REMOVED***
                    write(b'%%EndProlog\n'***REMOVED***
                    write(b'%%Page 1 1\n'***REMOVED***
                    if rotate:
                        write(rotate.encode('ascii'***REMOVED*** + b'\n'***REMOVED***
                    break
                elif bbox and (line.startswith(b'%%Bound'***REMOVED*** \
                               or line.startswith(b'%%HiResBound'***REMOVED*** \
                               or line.startswith(b'%%DocumentMedia'***REMOVED*** \
                               or line.startswith(b'%%Pages'***REMOVED******REMOVED***:
                    pass
                else:
                    write(line***REMOVED***
                line = tmph.readline(***REMOVED***
            # Now rewrite the rest of the file, and modify the trailer.
            # This is done in a second loop such that the header of the embedded
            # eps file is not modified.
            line = tmph.readline(***REMOVED***
            while line:
                if line.startswith(b'%%EOF'***REMOVED***:
                    write(b'cleartomark\n'***REMOVED***
                    write(b'countdictstack\n'***REMOVED***
                    write(b'exch sub { end ***REMOVED*** repeat\n'***REMOVED***
                    write(b'restore\n'***REMOVED***
                    write(b'showpage\n'***REMOVED***
                    write(b'%%EOF\n'***REMOVED***
                elif line.startswith(b'%%PageBoundingBox'***REMOVED***:
                    pass
                else:
                    write(line***REMOVED***
                line = tmph.readline(***REMOVED***

    os.remove(tmpfile***REMOVED***
    shutil.move(epsfile, tmpfile***REMOVED***


class FigureManagerPS(FigureManagerBase***REMOVED***:
    pass


# The following Python dictionary psDefs contains the entries for the
# PostScript dictionary mpldict.  This dictionary implements most of
# the matplotlib primitives and some abbreviations.
#
# References:
# http://www.adobe.com/products/postscript/pdfs/PLRM.pdf
# http://www.mactech.com/articles/mactech/Vol.09/09.04/PostscriptTutorial/
# http://www.math.ubc.ca/people/faculty/cass/graphics/text/www/
#

# The usage comments use the notation of the operator summary
# in the PostScript Language reference manual.
psDefs = [
    # x y  *m*  -
    "/m { moveto ***REMOVED*** bind def",
    # x y  *l*  -
    "/l { lineto ***REMOVED*** bind def",
    # x y  *r*  -
    "/r { rlineto ***REMOVED*** bind def",
    # x1 y1 x2 y2 x y *c*  -
    "/c { curveto ***REMOVED*** bind def",
    # *closepath*  -
    "/cl { closepath ***REMOVED*** bind def",
    # w h x y  *box*  -
    ***REMOVED***/box {
      m
      1 index 0 r
      0 exch r
      neg 0 r
      cl
***REMOVED*** bind def***REMOVED***,
    # w h x y  *clipbox*  -
    ***REMOVED***/clipbox {
      box
      clip
      newpath
***REMOVED*** bind def***REMOVED***,
***REMOVED***

FigureCanvas = FigureCanvasPS
FigureManager = FigureManagerPS
