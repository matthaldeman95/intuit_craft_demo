from __future__ import (absolute_import, division, print_function,
                        unicode_literals***REMOVED***
from matplotlib.externals import six

***REMOVED***
import re
import signal
import sys
from matplotlib.externals.six import unichr

import matplotlib

from matplotlib.cbook import is_string_like
from matplotlib.backend_bases import FigureManagerBase
from matplotlib.backend_bases import FigureCanvasBase
from matplotlib.backend_bases import NavigationToolbar2

from matplotlib.backend_bases import cursors
from matplotlib.backend_bases import TimerBase
from matplotlib.backend_bases import ShowBase

from matplotlib._pylab_helpers import Gcf
from matplotlib.figure import Figure

from matplotlib.widgets import SubplotTool
***REMOVED***
    import matplotlib.backends.qt_editor.figureoptions as figureoptions
except ImportError:
    figureoptions = None

from .qt_compat import QtCore, QtGui, QtWidgets, _getSaveFileName, __version__
from matplotlib.backends.qt_editor.formsubplottool import UiSubplotTool

backend_version = __version__

# SPECIAL_KEYS are keys that do *not* return their unicode name
# instead they have manually specified names
SPECIAL_KEYS = {QtCore.Qt.Key_Control: 'control',
                QtCore.Qt.Key_Shift: 'shift',
                QtCore.Qt.Key_Alt: 'alt',
                QtCore.Qt.Key_Meta: 'super',
                QtCore.Qt.Key_Return: 'enter',
                QtCore.Qt.Key_Left: 'left',
                QtCore.Qt.Key_Up: 'up',
                QtCore.Qt.Key_Right: 'right',
                QtCore.Qt.Key_Down: 'down',
                QtCore.Qt.Key_Escape: 'escape',
                QtCore.Qt.Key_F1: 'f1',
                QtCore.Qt.Key_F2: 'f2',
                QtCore.Qt.Key_F3: 'f3',
                QtCore.Qt.Key_F4: 'f4',
                QtCore.Qt.Key_F5: 'f5',
                QtCore.Qt.Key_F6: 'f6',
                QtCore.Qt.Key_F7: 'f7',
                QtCore.Qt.Key_F8: 'f8',
                QtCore.Qt.Key_F9: 'f9',
                QtCore.Qt.Key_F10: 'f10',
                QtCore.Qt.Key_F11: 'f11',
                QtCore.Qt.Key_F12: 'f12',
                QtCore.Qt.Key_Home: 'home',
                QtCore.Qt.Key_End: 'end',
                QtCore.Qt.Key_PageUp: 'pageup',
                QtCore.Qt.Key_PageDown: 'pagedown',
                QtCore.Qt.Key_Tab: 'tab',
                QtCore.Qt.Key_Backspace: 'backspace',
                QtCore.Qt.Key_Enter: 'enter',
                QtCore.Qt.Key_Insert: 'insert',
                QtCore.Qt.Key_Delete: 'delete',
                QtCore.Qt.Key_Pause: 'pause',
                QtCore.Qt.Key_SysReq: 'sysreq',
                QtCore.Qt.Key_Clear: 'clear', ***REMOVED***

# define which modifier keys are collected on keyboard events.
# elements are (mpl names, Modifier Flag, Qt Key***REMOVED*** tuples
SUPER = 0
ALT = 1
CTRL = 2
SHIFT = 3
MODIFIER_KEYS = [('super', QtCore.Qt.MetaModifier, QtCore.Qt.Key_Meta***REMOVED***,
                 ('alt', QtCore.Qt.AltModifier, QtCore.Qt.Key_Alt***REMOVED***,
                 ('ctrl', QtCore.Qt.ControlModifier, QtCore.Qt.Key_Control***REMOVED***,
                 ('shift', QtCore.Qt.ShiftModifier, QtCore.Qt.Key_Shift***REMOVED***,
                 ***REMOVED***

if sys.platform == 'darwin':
    # in OSX, the control and super (aka cmd/apple***REMOVED*** keys are switched, so
    # switch them back.
    SPECIAL_KEYS.update({QtCore.Qt.Key_Control: 'super',  # cmd/apple key
                         QtCore.Qt.Key_Meta: 'control',
                     ***REMOVED******REMOVED***
    MODIFIER_KEYS[0***REMOVED*** = ('super', QtCore.Qt.ControlModifier,
                        QtCore.Qt.Key_Control***REMOVED***
    MODIFIER_KEYS[2***REMOVED*** = ('ctrl', QtCore.Qt.MetaModifier,
                        QtCore.Qt.Key_Meta***REMOVED***


def fn_name(***REMOVED***:
    return sys._getframe(1***REMOVED***.f_code.co_name

DEBUG = False

cursord = {
    cursors.MOVE: QtCore.Qt.SizeAllCursor,
    cursors.HAND: QtCore.Qt.PointingHandCursor,
    cursors.POINTER: QtCore.Qt.ArrowCursor,
    cursors.SELECT_REGION: QtCore.Qt.CrossCursor,
***REMOVED***


def draw_if_interactive(***REMOVED***:
    ***REMOVED***
    Is called after every pylab drawing command
    ***REMOVED***
    if matplotlib.is_interactive(***REMOVED***:
        figManager = Gcf.get_active(***REMOVED***
        if figManager is not None:
            figManager.canvas.draw_idle(***REMOVED***

# make place holder
qApp = None


def _create_qApp(***REMOVED***:
    ***REMOVED***
    Only one qApp can exist at a time, so check before creating one.
    ***REMOVED***
    global qApp

    if qApp is None:
        if DEBUG:
            print("Starting up QApplication"***REMOVED***
        app = QtWidgets.QApplication.instance(***REMOVED***
        if app is None:
            # check for DISPLAY env variable on X11 build of Qt
            if hasattr(QtGui, "QX11Info"***REMOVED***:
                display = os.environ.get('DISPLAY'***REMOVED***
                if display is None or not re.search(':\d', display***REMOVED***:
                    raise RuntimeError('Invalid DISPLAY variable'***REMOVED***

            qApp = QtWidgets.QApplication([str(" "***REMOVED******REMOVED******REMOVED***
            qApp.lastWindowClosed.connect(qApp.quit***REMOVED***
        else:
            qApp = app


class Show(ShowBase***REMOVED***:
    def mainloop(self***REMOVED***:
        # allow KeyboardInterrupt exceptions to close the plot window.
        signal.signal(signal.SIGINT, signal.SIG_DFL***REMOVED***
        global qApp
        qApp.exec_(***REMOVED***

show = Show(***REMOVED***


def new_figure_manager(num, *args, **kwargs***REMOVED***:
    ***REMOVED***
    Create a new figure manager instance
    ***REMOVED***
    thisFig = Figure(*args, **kwargs***REMOVED***
    return new_figure_manager_given_figure(num, thisFig***REMOVED***


def new_figure_manager_given_figure(num, figure***REMOVED***:
    ***REMOVED***
    Create a new figure manager instance for the given figure.
    ***REMOVED***
    canvas = FigureCanvasQT(figure***REMOVED***
    manager = FigureManagerQT(canvas, num***REMOVED***
    return manager


class TimerQT(TimerBase***REMOVED***:
    '''
    Subclass of :class:`backend_bases.TimerBase` that uses Qt4 timer events.

    Attributes:
    * interval: The time between timer events in milliseconds. Default
        is 1000 ms.
    * single_shot: Boolean flag indicating whether this timer should
        operate as single shot (run once and then stop***REMOVED***. Defaults to False.
    * callbacks: Stores list of (func, args***REMOVED*** tuples that will be called
        upon timer events. This list can be manipulated directly, or the
        functions add_callback and remove_callback can be used.
    '''

    def __init__(self, *args, **kwargs***REMOVED***:
        TimerBase.__init__(self, *args, **kwargs***REMOVED***

        # Create a new timer and connect the timeout(***REMOVED*** signal to the
        # _on_timer method.
        self._timer = QtCore.QTimer(***REMOVED***
        self._timer.timeout.connect(self._on_timer***REMOVED***
        self._timer_set_interval(***REMOVED***

    def __del__(self***REMOVED***:
        # Probably not necessary in practice, but is good behavior to
        # disconnect
        ***REMOVED***
            TimerBase.__del__(self***REMOVED***
            self._timer.timeout.disconnect(self._on_timer***REMOVED***
        except RuntimeError:
            # Timer C++ object already deleted
            pass

    def _timer_set_single_shot(self***REMOVED***:
        self._timer.setSingleShot(self._single***REMOVED***

    def _timer_set_interval(self***REMOVED***:
        self._timer.setInterval(self._interval***REMOVED***

    def _timer_start(self***REMOVED***:
        self._timer.start(***REMOVED***

    def _timer_stop(self***REMOVED***:
        self._timer.stop(***REMOVED***


class FigureCanvasQT(QtWidgets.QWidget, FigureCanvasBase***REMOVED***:

    # map Qt button codes to MouseEvent's ones:
    buttond = {QtCore.Qt.LeftButton: 1,
               QtCore.Qt.MidButton: 2,
               QtCore.Qt.RightButton: 3,
               # QtCore.Qt.XButton1: None,
               # QtCore.Qt.XButton2: None,
           ***REMOVED***

    def __init__(self, figure***REMOVED***:
        if DEBUG:
            print('FigureCanvasQt qt5: ', figure***REMOVED***
        _create_qApp(***REMOVED***

        # NB: Using super for this call to avoid a TypeError:
        # __init__(***REMOVED*** takes exactly 2 arguments (1 given***REMOVED*** on QWidget
        # PyQt5
        # The need for this change is documented here
        # http://pyqt.sourceforge.net/Docs/PyQt5/pyqt4_differences.html#cooperative-multi-inheritance
        super(FigureCanvasQT, self***REMOVED***.__init__(figure=figure***REMOVED***
        self.figure = figure
        self.setMouseTracking(True***REMOVED***
        w, h = self.get_width_height(***REMOVED***
        self.resize(w, h***REMOVED***

    def enterEvent(self, event***REMOVED***:
        FigureCanvasBase.enter_notify_event(self, guiEvent=event***REMOVED***

    def leaveEvent(self, event***REMOVED***:
        QtWidgets.QApplication.restoreOverrideCursor(***REMOVED***
        FigureCanvasBase.leave_notify_event(self, guiEvent=event***REMOVED***

    def mousePressEvent(self, event***REMOVED***:
        x = event.pos(***REMOVED***.x(***REMOVED***
        # flipy so y=0 is bottom of canvas
        y = self.figure.bbox.height - event.pos(***REMOVED***.y(***REMOVED***
        button = self.buttond.get(event.button(***REMOVED******REMOVED***
        if button is not None:
            FigureCanvasBase.button_press_event(self, x, y, button,
                                                guiEvent=event***REMOVED***
        if DEBUG:
            print('button pressed:', event.button(***REMOVED******REMOVED***

    def mouseDoubleClickEvent(self, event***REMOVED***:
        x = event.pos(***REMOVED***.x(***REMOVED***
        # flipy so y=0 is bottom of canvas
        y = self.figure.bbox.height - event.pos(***REMOVED***.y(***REMOVED***
        button = self.buttond.get(event.button(***REMOVED******REMOVED***
        if button is not None:
            FigureCanvasBase.button_press_event(self, x, y,
                                                button, dblclick=True,
                                                guiEvent=event***REMOVED***
        if DEBUG:
            print('button doubleclicked:', event.button(***REMOVED******REMOVED***

    def mouseMoveEvent(self, event***REMOVED***:
        x = event.x(***REMOVED***
        # flipy so y=0 is bottom of canvas
        y = self.figure.bbox.height - event.y(***REMOVED***
        FigureCanvasBase.motion_notify_event(self, x, y, guiEvent=event***REMOVED***
        # if DEBUG: print('mouse move'***REMOVED***

    def mouseReleaseEvent(self, event***REMOVED***:
        x = event.x(***REMOVED***
        # flipy so y=0 is bottom of canvas
        y = self.figure.bbox.height - event.y(***REMOVED***
        button = self.buttond.get(event.button(***REMOVED******REMOVED***
        if button is not None:
            FigureCanvasBase.button_release_event(self, x, y, button,
                                                  guiEvent=event***REMOVED***
        if DEBUG:
            print('button released'***REMOVED***

    def wheelEvent(self, event***REMOVED***:
        x = event.x(***REMOVED***
        # flipy so y=0 is bottom of canvas
        y = self.figure.bbox.height - event.y(***REMOVED***
        # from QWheelEvent::delta doc
        if event.pixelDelta(***REMOVED***.x(***REMOVED*** == 0 and event.pixelDelta(***REMOVED***.y(***REMOVED*** == 0:
            steps = event.angleDelta(***REMOVED***.y(***REMOVED*** / 120
        else:
            steps = event.pixelDelta(***REMOVED***.y(***REMOVED***

        if steps != 0:
            FigureCanvasBase.scroll_event(self, x, y, steps, guiEvent=event***REMOVED***
            if DEBUG:
                print('scroll event: delta = %i, '
                      'steps = %i ' % (event.delta(***REMOVED***, steps***REMOVED******REMOVED***

    def keyPressEvent(self, event***REMOVED***:
        key = self._get_key(event***REMOVED***
        if key is None:
            return
        FigureCanvasBase.key_press_event(self, key, guiEvent=event***REMOVED***
        if DEBUG:
            print('key press', key***REMOVED***

    def keyReleaseEvent(self, event***REMOVED***:
        key = self._get_key(event***REMOVED***
        if key is None:
            return
        FigureCanvasBase.key_release_event(self, key, guiEvent=event***REMOVED***
        if DEBUG:
            print('key release', key***REMOVED***

    def resizeEvent(self, event***REMOVED***:
        w = event.size(***REMOVED***.width(***REMOVED***
        h = event.size(***REMOVED***.height(***REMOVED***
        if DEBUG:
            print('resize (%d x %d***REMOVED***' % (w, h***REMOVED******REMOVED***
            print("FigureCanvasQt.resizeEvent(%d, %d***REMOVED***" % (w, h***REMOVED******REMOVED***
        dpival = self.figure.dpi
        winch = w / dpival
        hinch = h / dpival
        self.figure.set_size_inches(winch, hinch***REMOVED***
        FigureCanvasBase.resize_event(self***REMOVED***
        self.draw_idle(***REMOVED***
        QtWidgets.QWidget.resizeEvent(self, event***REMOVED***

    def sizeHint(self***REMOVED***:
        w, h = self.get_width_height(***REMOVED***
        return QtCore.QSize(w, h***REMOVED***

    def minumumSizeHint(self***REMOVED***:
        return QtCore.QSize(10, 10***REMOVED***

    def _get_key(self, event***REMOVED***:
        if event.isAutoRepeat(***REMOVED***:
            return None

        event_key = event.key(***REMOVED***
        event_mods = int(event.modifiers(***REMOVED******REMOVED***  # actually a bitmask

        # get names of the pressed modifier keys
        # bit twiddling to pick out modifier keys from event_mods bitmask,
        # if event_key is a MODIFIER, it should not be duplicated in mods
        mods = [name for name, mod_key, qt_key in MODIFIER_KEYS
                if event_key != qt_key and (event_mods & mod_key***REMOVED*** == mod_key***REMOVED***
        ***REMOVED***
            # for certain keys (enter, left, backspace, etc***REMOVED*** use a word for the
            # key, rather than unicode
            key = SPECIAL_KEYS[event_key***REMOVED***
        except KeyError:
            # unicode defines code points up to 0x0010ffff
            # QT will use Key_Codes larger than that for keyboard keys that are
            # are not unicode characters (like multimedia keys***REMOVED***
            # skip these
            # if you really want them, you should add them to SPECIAL_KEYS
            MAX_UNICODE = 0x10ffff
            if event_key > MAX_UNICODE:
                return None

            key = unichr(event_key***REMOVED***
            # qt delivers capitalized letters.  fix capitalization
            # note that capslock is ignored
            if 'shift' in mods:
                mods.remove('shift'***REMOVED***
            else:
                key = key.lower(***REMOVED***

        mods.reverse(***REMOVED***
        return '+'.join(mods + [key***REMOVED******REMOVED***

    def new_timer(self, *args, **kwargs***REMOVED***:
        ***REMOVED***
        Creates a new backend-specific subclass of
        :class:`backend_bases.Timer`.  This is useful for getting
        periodic events through the backend's native event
        loop. Implemented only for backends with GUIs.

        optional arguments:

        *interval*
            Timer interval in milliseconds

        *callbacks*
            Sequence of (func, args, kwargs***REMOVED*** where func(*args, **kwargs***REMOVED***
            will be executed by the timer every *interval*.

    ***REMOVED***
        return TimerQT(*args, **kwargs***REMOVED***

    def flush_events(self***REMOVED***:
        global qApp
        qApp.processEvents(***REMOVED***

    def start_event_loop(self, timeout***REMOVED***:
        FigureCanvasBase.start_event_loop_default(self, timeout***REMOVED***

    start_event_loop.__doc__ = \
                             FigureCanvasBase.start_event_loop_default.__doc__

    def stop_event_loop(self***REMOVED***:
        FigureCanvasBase.stop_event_loop_default(self***REMOVED***

    stop_event_loop.__doc__ = FigureCanvasBase.stop_event_loop_default.__doc__


class MainWindow(QtWidgets.QMainWindow***REMOVED***:
    closing = QtCore.Signal(***REMOVED***

    def closeEvent(self, event***REMOVED***:
        self.closing.emit(***REMOVED***
        QtWidgets.QMainWindow.closeEvent(self, event***REMOVED***


class FigureManagerQT(FigureManagerBase***REMOVED***:
    ***REMOVED***
    Public attributes

    canvas      : The FigureCanvas instance
    num         : The Figure number
    toolbar     : The qt.QToolBar
    window      : The qt.QMainWindow
    ***REMOVED***

    def __init__(self, canvas, num***REMOVED***:
        if DEBUG:
            print('FigureManagerQT.%s' % fn_name(***REMOVED******REMOVED***
        FigureManagerBase.__init__(self, canvas, num***REMOVED***
        self.canvas = canvas
        self.window = MainWindow(***REMOVED***
        self.window.closing.connect(canvas.close_event***REMOVED***
        self.window.closing.connect(self._widgetclosed***REMOVED***

        self.window.setWindowTitle("Figure %d" % num***REMOVED***
        image = os.path.join(matplotlib.rcParams['datapath'***REMOVED***,
                             'images', 'matplotlib.png'***REMOVED***
        self.window.setWindowIcon(QtGui.QIcon(image***REMOVED******REMOVED***

        # Give the keyboard focus to the figure instead of the
        # manager; StrongFocus accepts both tab and click to focus and
        # will enable the canvas to process event w/o clicking.
        # ClickFocus only takes the focus is the window has been
        # clicked
        # on. http://qt-project.org/doc/qt-4.8/qt.html#FocusPolicy-enum or
        # http://doc.qt.digia.com/qt/qt.html#FocusPolicy-enum
        self.canvas.setFocusPolicy(QtCore.Qt.StrongFocus***REMOVED***
        self.canvas.setFocus(***REMOVED***

        self.window._destroying = False

        # add text label to status bar
        self.statusbar_label = QtWidgets.QLabel(***REMOVED***
        self.window.statusBar(***REMOVED***.addWidget(self.statusbar_label***REMOVED***

        self.toolbar = self._get_toolbar(self.canvas, self.window***REMOVED***
        if self.toolbar is not None:
            self.window.addToolBar(self.toolbar***REMOVED***
            self.toolbar.message.connect(self.statusbar_label.setText***REMOVED***
            tbs_height = self.toolbar.sizeHint(***REMOVED***.height(***REMOVED***
        else:
            tbs_height = 0

        # resize the main window so it will display the canvas with the
        # requested size:
        cs = canvas.sizeHint(***REMOVED***
        sbs = self.window.statusBar(***REMOVED***.sizeHint(***REMOVED***
        self._status_and_tool_height = tbs_height + sbs.height(***REMOVED***
        height = cs.height(***REMOVED*** + self._status_and_tool_height
        self.window.resize(cs.width(***REMOVED***, height***REMOVED***

        self.window.setCentralWidget(self.canvas***REMOVED***

        if matplotlib.is_interactive(***REMOVED***:
            self.window.show(***REMOVED***
            self.canvas.draw_idle(***REMOVED***

        def notify_axes_change(fig***REMOVED***:
            # This will be called whenever the current axes is changed
            if self.toolbar is not None:
                self.toolbar.update(***REMOVED***
        self.canvas.figure.add_axobserver(notify_axes_change***REMOVED***

    def full_screen_toggle(self***REMOVED***:
        if self.window.isFullScreen(***REMOVED***:
            self.window.showNormal(***REMOVED***
        else:
            self.window.showFullScreen(***REMOVED***

    def _widgetclosed(self***REMOVED***:
        if self.window._destroying:
            return
        self.window._destroying = True
        ***REMOVED***
            Gcf.destroy(self.num***REMOVED***
        except AttributeError:
            pass
            # It seems that when the python session is killed,
            # Gcf can get destroyed before the Gcf.destroy
            # line is run, leading to a useless AttributeError.

    def _get_toolbar(self, canvas, parent***REMOVED***:
        # must be inited after the window, drawingArea and figure
        # attrs are set
        if matplotlib.rcParams['toolbar'***REMOVED*** == 'toolbar2':
            toolbar = NavigationToolbar2QT(canvas, parent, False***REMOVED***
        else:
            toolbar = None
        return toolbar

    def resize(self, width, height***REMOVED***:
        'set the canvas size in pixels'
        self.window.resize(width, height + self._status_and_tool_height***REMOVED***

    def show(self***REMOVED***:
        self.window.show(***REMOVED***

    def destroy(self, *args***REMOVED***:
        # check for qApp first, as PySide deletes it in its atexit handler
        if QtWidgets.QApplication.instance(***REMOVED*** is None:
            return
        if self.window._destroying:
            return
        self.window._destroying = True
        self.window.destroyed.connect(self._widgetclosed***REMOVED***

        if self.toolbar:
            self.toolbar.destroy(***REMOVED***
        if DEBUG:
            print("destroy figure manager"***REMOVED***
        self.window.close(***REMOVED***

    def get_window_title(self***REMOVED***:
        return six.text_type(self.window.windowTitle(***REMOVED******REMOVED***

    def set_window_title(self, title***REMOVED***:
        self.window.setWindowTitle(title***REMOVED***


class NavigationToolbar2QT(NavigationToolbar2, QtWidgets.QToolBar***REMOVED***:
    message = QtCore.Signal(str***REMOVED***

    def __init__(self, canvas, parent, coordinates=True***REMOVED***:
        ***REMOVED*** coordinates: should we show the coordinates on the right? ***REMOVED***
        self.canvas = canvas
        self.parent = parent
        self.coordinates = coordinates
        self._actions = {***REMOVED***
        ***REMOVED***A mapping of toolitem method names to their QActions***REMOVED***

        QtWidgets.QToolBar.__init__(self, parent***REMOVED***
        NavigationToolbar2.__init__(self, canvas***REMOVED***

    def _icon(self, name***REMOVED***:
        return QtGui.QIcon(os.path.join(self.basedir, name***REMOVED******REMOVED***

    def _init_toolbar(self***REMOVED***:
        self.basedir = os.path.join(matplotlib.rcParams['datapath'***REMOVED***, 'images'***REMOVED***

        for text, tooltip_text, image_file, callback in self.toolitems:
            if text is None:
                self.addSeparator(***REMOVED***
            else:
                a = self.addAction(self._icon(image_file + '.png'***REMOVED***,
                                         text, getattr(self, callback***REMOVED******REMOVED***
                self._actions[callback***REMOVED*** = a
                if callback in ['zoom', 'pan'***REMOVED***:
                    a.setCheckable(True***REMOVED***
                if tooltip_text is not None:
                    a.setToolTip(tooltip_text***REMOVED***

        if figureoptions is not None:
            a = self.addAction(self._icon("qt4_editor_options.png"***REMOVED***,
                               'Customize', self.edit_parameters***REMOVED***
            a.setToolTip('Edit curves line and axes parameters'***REMOVED***

        self.buttons = {***REMOVED***

        # Add the x,y location widget at the right side of the toolbar
        # The stretch factor is 1 which means any resizing of the toolbar
        # will resize this label instead of the buttons.
        if self.coordinates:
            self.locLabel = QtWidgets.QLabel("", self***REMOVED***
            self.locLabel.setAlignment(
                    QtCore.Qt.AlignRight | QtCore.Qt.AlignTop***REMOVED***
            self.locLabel.setSizePolicy(
                QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding,
                                  QtWidgets.QSizePolicy.Ignored***REMOVED******REMOVED***
            labelAction = self.addWidget(self.locLabel***REMOVED***
            labelAction.setVisible(True***REMOVED***

        # reference holder for subplots_adjust window
        self.adj_window = None

    if figureoptions is not None:
        def edit_parameters(self***REMOVED***:
            allaxes = self.canvas.figure.get_axes(***REMOVED***
            if not allaxes:
                QtWidgets.QMessageBox.warning(
                    self.parent, "Error", "There are no axes to edit."***REMOVED***
                return
            if len(allaxes***REMOVED*** == 1:
                axes = allaxes[0***REMOVED***
            else:
                titles = [***REMOVED***
                for axes in allaxes:
                    title = axes.get_title(***REMOVED***
                    ylabel = axes.get_ylabel(***REMOVED***
                    label = axes.get_label(***REMOVED***
                    if title:
                        fmt = "%(title***REMOVED***s"
                        if ylabel:
                            fmt += ": %(ylabel***REMOVED***s"
                        fmt += " (%(axes_repr***REMOVED***s***REMOVED***"
                    elif ylabel:
                        fmt = "%(axes_repr***REMOVED***s (%(ylabel***REMOVED***s***REMOVED***"
                    elif label:
                        fmt = "%(axes_repr***REMOVED***s (%(label***REMOVED***s***REMOVED***"
                    else:
                        fmt = "%(axes_repr***REMOVED***s"
                    titles.append(fmt % dict(title=title,
                                         ylabel=ylabel, label=label,
                                         axes_repr=repr(axes***REMOVED******REMOVED******REMOVED***
                item, ok = QtWidgets.QInputDialog.getItem(
                    self.parent, 'Customize', 'Select axes:', titles, 0, False***REMOVED***
                if ok:
                    axes = allaxes[titles.index(six.text_type(item***REMOVED******REMOVED******REMOVED***
                else:
                    return

            figureoptions.figure_edit(axes, self***REMOVED***

    def _update_buttons_checked(self***REMOVED***:
        # sync button checkstates to match active mode
        self._actions['pan'***REMOVED***.setChecked(self._active == 'PAN'***REMOVED***
        self._actions['zoom'***REMOVED***.setChecked(self._active == 'ZOOM'***REMOVED***

    def pan(self, *args***REMOVED***:
        super(NavigationToolbar2QT, self***REMOVED***.pan(*args***REMOVED***
        self._update_buttons_checked(***REMOVED***

    def zoom(self, *args***REMOVED***:
        super(NavigationToolbar2QT, self***REMOVED***.zoom(*args***REMOVED***
        self._update_buttons_checked(***REMOVED***

    def dynamic_update(self***REMOVED***:
        self.canvas.draw_idle(***REMOVED***

    def set_message(self, s***REMOVED***:
        self.message.emit(s***REMOVED***
        if self.coordinates:
            self.locLabel.setText(s***REMOVED***

    def set_cursor(self, cursor***REMOVED***:
        if DEBUG:
            print('Set cursor', cursor***REMOVED***
        self.canvas.setCursor(cursord[cursor***REMOVED******REMOVED***

    def draw_rubberband(self, event, x0, y0, x1, y1***REMOVED***:
        height = self.canvas.figure.bbox.height
        y1 = height - y1
        y0 = height - y0

        w = abs(x1 - x0***REMOVED***
        h = abs(y1 - y0***REMOVED***

        rect = [int(val***REMOVED***for val in (min(x0, x1***REMOVED***, min(y0, y1***REMOVED***, w, h***REMOVED******REMOVED***
        self.canvas.drawRectangle(rect***REMOVED***

    def remove_rubberband(self***REMOVED***:
        self.canvas.drawRectangle(None***REMOVED***

    def configure_subplots(self***REMOVED***:
        image = os.path.join(matplotlib.rcParams['datapath'***REMOVED***,
                             'images', 'matplotlib.png'***REMOVED***
        dia = SubplotToolQt(self.canvas.figure, self.parent***REMOVED***
        dia.setWindowIcon(QtGui.QIcon(image***REMOVED******REMOVED***
        dia.exec_(***REMOVED***

    def save_figure(self, *args***REMOVED***:
        filetypes = self.canvas.get_supported_filetypes_grouped(***REMOVED***
        sorted_filetypes = list(six.iteritems(filetypes***REMOVED******REMOVED***
        sorted_filetypes.sort(***REMOVED***
        default_filetype = self.canvas.get_default_filetype(***REMOVED***

        startpath = matplotlib.rcParams.get('savefig.directory', ''***REMOVED***
        startpath = os.path.expanduser(startpath***REMOVED***
        start = os.path.join(startpath, self.canvas.get_default_filename(***REMOVED******REMOVED***
        filters = [***REMOVED***
        selectedFilter = None
        for name, exts in sorted_filetypes:
            exts_list = " ".join(['*.%s' % ext for ext in exts***REMOVED******REMOVED***
            filter = '%s (%s***REMOVED***' % (name, exts_list***REMOVED***
            if default_filetype in exts:
                selectedFilter = filter
            filters.append(filter***REMOVED***
        filters = ';;'.join(filters***REMOVED***

        fname, filter = _getSaveFileName(self.parent,
                                         "Choose a filename to save to",
                                 start, filters, selectedFilter***REMOVED***
        if fname:
            if startpath == '':
                # explicitly missing key or empty str signals to use cwd
                matplotlib.rcParams['savefig.directory'***REMOVED*** = startpath
            else:
                # save dir for next time
                savefig_dir = os.path.dirname(six.text_type(fname***REMOVED******REMOVED***
                matplotlib.rcParams['savefig.directory'***REMOVED*** = savefig_dir
            ***REMOVED***
                self.canvas.print_figure(six.text_type(fname***REMOVED******REMOVED***
            except Exception as e:
                QtWidgets.QMessageBox.critical(
                    self, "Error saving file", six.text_type(e***REMOVED***,
                    QtWidgets.QMessageBox.Ok, QtWidgets.QMessageBox.NoButton***REMOVED***


class SubplotToolQt(SubplotTool, UiSubplotTool***REMOVED***:
    def __init__(self, targetfig, parent***REMOVED***:
        UiSubplotTool.__init__(self, None***REMOVED***

        self.targetfig = targetfig
        self.parent = parent
        self.donebutton.clicked.connect(self.close***REMOVED***
        self.resetbutton.clicked.connect(self.reset***REMOVED***
        self.tightlayout.clicked.connect(self.functight***REMOVED***

        # constraints
        self.sliderleft.valueChanged.connect(self.sliderright.setMinimum***REMOVED***
        self.sliderright.valueChanged.connect(self.sliderleft.setMaximum***REMOVED***
        self.sliderbottom.valueChanged.connect(self.slidertop.setMinimum***REMOVED***
        self.slidertop.valueChanged.connect(self.sliderbottom.setMaximum***REMOVED***

        self.defaults = {***REMOVED***
        for attr in ('left', 'bottom', 'right', 'top', 'wspace', 'hspace', ***REMOVED***:
            val = getattr(self.targetfig.subplotpars, attr***REMOVED***
            self.defaults[attr***REMOVED*** = val
            slider = getattr(self, 'slider' + attr***REMOVED***
            txt = getattr(self, attr + 'value'***REMOVED***
            slider.setMinimum(0***REMOVED***
            slider.setMaximum(1000***REMOVED***
            slider.setSingleStep(5***REMOVED***
            # do this before hooking up the callbacks
            slider.setSliderPosition(int(val * 1000***REMOVED******REMOVED***
            txt.setText("%.2f" % val***REMOVED***
            slider.valueChanged.connect(getattr(self, 'func' + attr***REMOVED******REMOVED***
        self._setSliderPositions(***REMOVED***

    def _setSliderPositions(self***REMOVED***:
        for attr in ('left', 'bottom', 'right', 'top', 'wspace', 'hspace', ***REMOVED***:
            slider = getattr(self, 'slider' + attr***REMOVED***
            slider.setSliderPosition(int(self.defaults[attr***REMOVED*** * 1000***REMOVED******REMOVED***

    def funcleft(self, val***REMOVED***:
        if val == self.sliderright.value(***REMOVED***:
            val -= 1
        val /= 1000.
        self.targetfig.subplots_adjust(left=val***REMOVED***
        self.leftvalue.setText("%.2f" % val***REMOVED***
        if self.drawon:
            self.targetfig.canvas.draw_idle(***REMOVED***

    def funcright(self, val***REMOVED***:
        if val == self.sliderleft.value(***REMOVED***:
            val += 1
        val /= 1000.
        self.targetfig.subplots_adjust(right=val***REMOVED***
        self.rightvalue.setText("%.2f" % val***REMOVED***
        if self.drawon:
            self.targetfig.canvas.draw_idle(***REMOVED***

    def funcbottom(self, val***REMOVED***:
        if val == self.slidertop.value(***REMOVED***:
            val -= 1
        val /= 1000.
        self.targetfig.subplots_adjust(bottom=val***REMOVED***
        self.bottomvalue.setText("%.2f" % val***REMOVED***
        if self.drawon:
            self.targetfig.canvas.draw_idle(***REMOVED***

    def functop(self, val***REMOVED***:
        if val == self.sliderbottom.value(***REMOVED***:
            val += 1
        val /= 1000.
        self.targetfig.subplots_adjust(top=val***REMOVED***
        self.topvalue.setText("%.2f" % val***REMOVED***
        if self.drawon:
            self.targetfig.canvas.draw_idle(***REMOVED***

    def funcwspace(self, val***REMOVED***:
        val /= 1000.
        self.targetfig.subplots_adjust(wspace=val***REMOVED***
        self.wspacevalue.setText("%.2f" % val***REMOVED***
        if self.drawon:
            self.targetfig.canvas.draw_idle(***REMOVED***

    def funchspace(self, val***REMOVED***:
        val /= 1000.
        self.targetfig.subplots_adjust(hspace=val***REMOVED***
        self.hspacevalue.setText("%.2f" % val***REMOVED***
        if self.drawon:
            self.targetfig.canvas.draw_idle(***REMOVED***

    def functight(self***REMOVED***:
        self.targetfig.tight_layout(***REMOVED***
        self._setSliderPositions(***REMOVED***
        self.targetfig.canvas.draw_idle(***REMOVED***

    def reset(self***REMOVED***:
        self.targetfig.subplots_adjust(**self.defaults***REMOVED***
        self._setSliderPositions(***REMOVED***
        self.targetfig.canvas.draw_idle(***REMOVED***


def error_msg_qt(msg, parent=None***REMOVED***:
    if not is_string_like(msg***REMOVED***:
        msg = ','.join(map(str, msg***REMOVED******REMOVED***

    QtWidgets.QMessageBox.warning(None, "Matplotlib",
                                  msg, QtGui.QMessageBox.Ok***REMOVED***


def exception_handler(type, value, tb***REMOVED***:
    ***REMOVED***Handle uncaught exceptions
    It does not catch SystemExit
    ***REMOVED***
    msg = ''
    # get the filename attribute if available (for IOError***REMOVED***
    if hasattr(value, 'filename'***REMOVED*** and value.filename is not None:
        msg = value.filename + ': '
    if hasattr(value, 'strerror'***REMOVED*** and value.strerror is not None:
        msg += value.strerror
    else:
        msg += six.text_type(value***REMOVED***

    if len(msg***REMOVED***:
        error_msg_qt(msg***REMOVED***

FigureCanvas = FigureCanvasQT
FigureManager = FigureManagerQT
