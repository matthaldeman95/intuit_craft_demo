***REMOVED***
Manage figures for pyplot interface.
***REMOVED***
from __future__ import (absolute_import, division, print_function,
                        unicode_literals***REMOVED***

from matplotlib.externals import six
import sys
import gc
import atexit


def error_msg(msg***REMOVED***:
    print(msg, file=sys.stderr***REMOVED***


class Gcf(object***REMOVED***:
    ***REMOVED***
    Singleton to manage a set of integer-numbered figures.

    This class is never instantiated; it consists of two class
    attributes (a list and a dictionary***REMOVED***, and a set of static
    methods that operate on those attributes, accessing them
    directly as class attributes.

    Attributes:

        *figs*:
          dictionary of the form {*num*: *manager*, ...***REMOVED***

        *_activeQue*:
          list of *managers*, with active one at the end

    ***REMOVED***
    _activeQue = [***REMOVED***
    figs = {***REMOVED***

    @classmethod
    def get_fig_manager(cls, num***REMOVED***:
        ***REMOVED***
        If figure manager *num* exists, make it the active
        figure and return the manager; otherwise return *None*.
        ***REMOVED***
        manager = cls.figs.get(num, None***REMOVED***
        if manager is not None:
            cls.set_active(manager***REMOVED***
        return manager

    @classmethod
    def destroy(cls, num***REMOVED***:
        ***REMOVED***
        Try to remove all traces of figure *num*.

        In the interactive backends, this is bound to the
        window "destroy" and "delete" events.
        ***REMOVED***
        if not cls.has_fignum(num***REMOVED***:
            return
        manager = cls.figs[num***REMOVED***
        manager.canvas.mpl_disconnect(manager._cidgcf***REMOVED***

        # There must be a good reason for the following careful
        # rebuilding of the activeQue; what is it?
        oldQue = cls._activeQue[:***REMOVED***
        cls._activeQue = [***REMOVED***
        for f in oldQue:
            if f != manager:
                cls._activeQue.append(f***REMOVED***

        del cls.figs[num***REMOVED***
        manager.destroy(***REMOVED***
        gc.collect(1***REMOVED***

    @classmethod
    def destroy_fig(cls, fig***REMOVED***:
        "*fig* is a Figure instance"
        num = None
        for manager in six.itervalues(cls.figs***REMOVED***:
            if manager.canvas.figure == fig:
                num = manager.num
                break
        if num is not None:
            cls.destroy(num***REMOVED***

    @classmethod
    def destroy_all(cls***REMOVED***:
        # this is need to ensure that gc is available in corner cases
        # where modules are being torn down after install with easy_install
        import gc  # noqa
        for manager in list(cls.figs.values(***REMOVED******REMOVED***:
            manager.canvas.mpl_disconnect(manager._cidgcf***REMOVED***
            manager.destroy(***REMOVED***

        cls._activeQue = [***REMOVED***
        cls.figs.clear(***REMOVED***
        gc.collect(1***REMOVED***

    @classmethod
    def has_fignum(cls, num***REMOVED***:
        ***REMOVED***
        Return *True* if figure *num* exists.
        ***REMOVED***
        return num in cls.figs

    @classmethod
    def get_all_fig_managers(cls***REMOVED***:
        ***REMOVED***
        Return a list of figure managers.
        ***REMOVED***
        return list(cls.figs.values(***REMOVED******REMOVED***

    @classmethod
    def get_num_fig_managers(cls***REMOVED***:
        ***REMOVED***
        Return the number of figures being managed.
        ***REMOVED***
        return len(cls.figs***REMOVED***

    @classmethod
    def get_active(cls***REMOVED***:
        ***REMOVED***
        Return the manager of the active figure, or *None*.
        ***REMOVED***
        if len(cls._activeQue***REMOVED*** == 0:
            return None
        else:
            return cls._activeQue[-1***REMOVED***

    @classmethod
    def set_active(cls, manager***REMOVED***:
        ***REMOVED***
        Make the figure corresponding to *manager* the active one.
        ***REMOVED***
        oldQue = cls._activeQue[:***REMOVED***
        cls._activeQue = [***REMOVED***
        for m in oldQue:
            if m != manager:
                cls._activeQue.append(m***REMOVED***
        cls._activeQue.append(manager***REMOVED***
        cls.figs[manager.num***REMOVED*** = manager

    @classmethod
    def draw_all(cls, force=False***REMOVED***:
        ***REMOVED***
        Redraw all figures registered with the pyplot
        state machine.
        ***REMOVED***
        for f_mgr in cls.get_all_fig_managers(***REMOVED***:
            if force or f_mgr.canvas.figure.stale:
                f_mgr.canvas.draw_idle(***REMOVED***

atexit.register(Gcf.destroy_all***REMOVED***
