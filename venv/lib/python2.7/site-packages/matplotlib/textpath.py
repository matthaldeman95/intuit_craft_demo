# -*- coding: utf-8 -*-

from __future__ import (absolute_import, division, print_function,
                        unicode_literals***REMOVED***

from matplotlib.externals import six
from matplotlib.externals.six.moves import zip

import warnings

import numpy as np

from matplotlib.path import Path
from matplotlib import rcParams
import matplotlib.font_manager as font_manager
from matplotlib.ft2font import FT2Font, KERNING_DEFAULT, LOAD_NO_HINTING
from matplotlib.ft2font import LOAD_TARGET_LIGHT
from matplotlib.mathtext import MathTextParser
import matplotlib.dviread as dviread
from matplotlib.font_manager import FontProperties
from matplotlib.transforms import Affine2D
from matplotlib.externals.six.moves.urllib.parse import quote as urllib_quote


class TextToPath(object***REMOVED***:
    ***REMOVED***
    A class that convert a given text to a path using ttf fonts.
    ***REMOVED***

    FONT_SCALE = 100.
    DPI = 72

    def __init__(self***REMOVED***:
        ***REMOVED***
        Initialization
        ***REMOVED***
        self.mathtext_parser = MathTextParser('path'***REMOVED***
        self.tex_font_map = None

        from matplotlib.cbook import maxdict
        self._ps_fontd = maxdict(50***REMOVED***

        self._texmanager = None

        self._adobe_standard_encoding = None

    def _get_adobe_standard_encoding(self***REMOVED***:
        enc_name = dviread.find_tex_file('8a.enc'***REMOVED***
        enc = dviread.Encoding(enc_name***REMOVED***
        return dict([(c, i***REMOVED*** for i, c in enumerate(enc.encoding***REMOVED******REMOVED******REMOVED***

    def _get_font(self, prop***REMOVED***:
        ***REMOVED***
        find a ttf font.
        ***REMOVED***
        fname = font_manager.findfont(prop***REMOVED***
        font = FT2Font(fname***REMOVED***
        font.set_size(self.FONT_SCALE, self.DPI***REMOVED***

        return font

    def _get_hinting_flag(self***REMOVED***:
        return LOAD_NO_HINTING

    def _get_char_id(self, font, ccode***REMOVED***:
        ***REMOVED***
        Return a unique id for the given font and character-code set.
        ***REMOVED***
        sfnt = font.get_sfnt(***REMOVED***
        ***REMOVED***
            ps_name = sfnt[(1, 0, 0, 6***REMOVED******REMOVED***.decode('macroman'***REMOVED***
        except KeyError:
            ps_name = sfnt[(3, 1, 0x0409, 6***REMOVED******REMOVED***.decode('utf-16be'***REMOVED***
        char_id = urllib_quote('%s-%x' % (ps_name, ccode***REMOVED******REMOVED***
        return char_id

    def _get_char_id_ps(self, font, ccode***REMOVED***:
        ***REMOVED***
        Return a unique id for the given font and character-code set (for tex***REMOVED***.
        ***REMOVED***
        ps_name = font.get_ps_font_info(***REMOVED***[2***REMOVED***
        char_id = urllib_quote('%s-%d' % (ps_name, ccode***REMOVED******REMOVED***
        return char_id

    def glyph_to_path(self, font, currx=0.***REMOVED***:
        ***REMOVED***
        convert the ft2font glyph to vertices and codes.
        ***REMOVED***
        verts, codes = font.get_path(***REMOVED***
        if currx != 0.0:
            verts[:, 0***REMOVED*** += currx
        return verts, codes

    def get_text_width_height_descent(self, s, prop, ismath***REMOVED***:
        if rcParams['text.usetex'***REMOVED***:
            texmanager = self.get_texmanager(***REMOVED***
            fontsize = prop.get_size_in_points(***REMOVED***
            w, h, d = texmanager.get_text_width_height_descent(s, fontsize,
                                                               renderer=None***REMOVED***
            return w, h, d

        fontsize = prop.get_size_in_points(***REMOVED***
        scale = float(fontsize***REMOVED*** / self.FONT_SCALE

        if ismath:
            prop = prop.copy(***REMOVED***
            prop.set_size(self.FONT_SCALE***REMOVED***

            width, height, descent, trash, used_characters = \
                self.mathtext_parser.parse(s, 72, prop***REMOVED***
            return width * scale, height * scale, descent * scale

        font = self._get_font(prop***REMOVED***
        font.set_text(s, 0.0, flags=LOAD_NO_HINTING***REMOVED***
        w, h = font.get_width_height(***REMOVED***
        w /= 64.0  # convert from subpixels
        h /= 64.0
        d = font.get_descent(***REMOVED***
        d /= 64.0
        return w * scale, h * scale, d * scale

    def get_text_path(self, prop, s, ismath=False, usetex=False***REMOVED***:
        ***REMOVED***
        convert text *s* to path (a tuple of vertices and codes for
        matplotlib.path.Path***REMOVED***.

        *prop*
          font property

        *s*
          text to be converted

        *usetex*
          If True, use matplotlib usetex mode.

        *ismath*
          If True, use mathtext parser. Effective only if usetex == False.


        ***REMOVED***
        if not usetex:
            if not ismath:
                font = self._get_font(prop***REMOVED***
                glyph_info, glyph_map, rects = self.get_glyphs_with_font(
                                                    font, s***REMOVED***
            else:
                glyph_info, glyph_map, rects = self.get_glyphs_mathtext(
                                                    prop, s***REMOVED***
        else:
            glyph_info, glyph_map, rects = self.get_glyphs_tex(prop, s***REMOVED***

        verts, codes = [***REMOVED***, [***REMOVED***

        for glyph_id, xposition, yposition, scale in glyph_info:
            verts1, codes1 = glyph_map[glyph_id***REMOVED***
            if len(verts1***REMOVED***:
                verts1 = np.array(verts1***REMOVED*** * scale + [xposition, yposition***REMOVED***
                verts.extend(verts1***REMOVED***
                codes.extend(codes1***REMOVED***

        for verts1, codes1 in rects:
            verts.extend(verts1***REMOVED***
            codes.extend(codes1***REMOVED***

        return verts, codes

    def get_glyphs_with_font(self, font, s, glyph_map=None,
                             return_new_glyphs_only=False***REMOVED***:
        ***REMOVED***
        convert the string *s* to vertices and codes using the
        provided ttf font.
        ***REMOVED***

        # Mostly copied from backend_svg.py.

        cmap = font.get_charmap(***REMOVED***
        lastgind = None

        currx = 0
        xpositions = [***REMOVED***
        glyph_ids = [***REMOVED***

        if glyph_map is None:
            glyph_map = dict(***REMOVED***

        if return_new_glyphs_only:
            glyph_map_new = dict(***REMOVED***
        else:
            glyph_map_new = glyph_map

        # I'm not sure if I get kernings right. Needs to be verified. -JJL

        for c in s:
            ccode = ord(c***REMOVED***
            gind = cmap.get(ccode***REMOVED***
            if gind is None:
                ccode = ord('?'***REMOVED***
                gind = 0

            if lastgind is not None:
                kern = font.get_kerning(lastgind, gind, KERNING_DEFAULT***REMOVED***
            else:
                kern = 0

            glyph = font.load_char(ccode, flags=LOAD_NO_HINTING***REMOVED***
            horiz_advance = (glyph.linearHoriAdvance / 65536.0***REMOVED***

            char_id = self._get_char_id(font, ccode***REMOVED***
            if char_id not in glyph_map:
                glyph_map_new[char_id***REMOVED*** = self.glyph_to_path(font***REMOVED***

            currx += (kern / 64.0***REMOVED***

            xpositions.append(currx***REMOVED***
            glyph_ids.append(char_id***REMOVED***

            currx += horiz_advance

            lastgind = gind

        ypositions = [0***REMOVED*** * len(xpositions***REMOVED***
        sizes = [1.***REMOVED*** * len(xpositions***REMOVED***

        rects = [***REMOVED***

        return (list(zip(glyph_ids, xpositions, ypositions, sizes***REMOVED******REMOVED***,
                     glyph_map_new, rects***REMOVED***

    def get_glyphs_mathtext(self, prop, s, glyph_map=None,
                            return_new_glyphs_only=False***REMOVED***:
        ***REMOVED***
        convert the string *s* to vertices and codes by parsing it with
        mathtext.
        ***REMOVED***

        prop = prop.copy(***REMOVED***
        prop.set_size(self.FONT_SCALE***REMOVED***

        width, height, descent, glyphs, rects = self.mathtext_parser.parse(
            s, self.DPI, prop***REMOVED***

        if not glyph_map:
            glyph_map = dict(***REMOVED***

        if return_new_glyphs_only:
            glyph_map_new = dict(***REMOVED***
        else:
            glyph_map_new = glyph_map

        xpositions = [***REMOVED***
        ypositions = [***REMOVED***
        glyph_ids = [***REMOVED***
        sizes = [***REMOVED***

        currx, curry = 0, 0
        for font, fontsize, ccode, ox, oy in glyphs:
            char_id = self._get_char_id(font, ccode***REMOVED***
            if char_id not in glyph_map:
                font.clear(***REMOVED***
                font.set_size(self.FONT_SCALE, self.DPI***REMOVED***
                glyph = font.load_char(ccode, flags=LOAD_NO_HINTING***REMOVED***
                glyph_map_new[char_id***REMOVED*** = self.glyph_to_path(font***REMOVED***

            xpositions.append(ox***REMOVED***
            ypositions.append(oy***REMOVED***
            glyph_ids.append(char_id***REMOVED***
            size = fontsize / self.FONT_SCALE
            sizes.append(size***REMOVED***

        myrects = [***REMOVED***
        for ox, oy, w, h in rects:
            vert1 = [(ox, oy***REMOVED***, (ox, oy + h***REMOVED***, (ox + w, oy + h***REMOVED***,
                     (ox + w, oy***REMOVED***, (ox, oy***REMOVED***, (0, 0***REMOVED******REMOVED***
            code1 = [Path.MOVETO,
                     Path.LINETO, Path.LINETO, Path.LINETO, Path.LINETO,
                     Path.CLOSEPOLY***REMOVED***
            myrects.append((vert1, code1***REMOVED******REMOVED***

        return (list(zip(glyph_ids, xpositions, ypositions, sizes***REMOVED******REMOVED***,
                glyph_map_new, myrects***REMOVED***

    def get_texmanager(self***REMOVED***:
        ***REMOVED***
        return the :class:`matplotlib.texmanager.TexManager` instance
        ***REMOVED***
        if self._texmanager is None:
            from matplotlib.texmanager import TexManager
            self._texmanager = TexManager(***REMOVED***
        return self._texmanager

    def get_glyphs_tex(self, prop, s, glyph_map=None,
                       return_new_glyphs_only=False***REMOVED***:
        ***REMOVED***
        convert the string *s* to vertices and codes using matplotlib's usetex
        mode.
        ***REMOVED***

        # codes are modstly borrowed from pdf backend.

        texmanager = self.get_texmanager(***REMOVED***

        if self.tex_font_map is None:
            self.tex_font_map = dviread.PsfontsMap(
                                    dviread.find_tex_file('pdftex.map'***REMOVED******REMOVED***

        if self._adobe_standard_encoding is None:
            self._adobe_standard_encoding = self._get_adobe_standard_encoding(***REMOVED***

        fontsize = prop.get_size_in_points(***REMOVED***
        if hasattr(texmanager, "get_dvi"***REMOVED***:
            dvifilelike = texmanager.get_dvi(s, self.FONT_SCALE***REMOVED***
            dvi = dviread.DviFromFileLike(dvifilelike, self.DPI***REMOVED***
        else:
            dvifile = texmanager.make_dvi(s, self.FONT_SCALE***REMOVED***
            dvi = dviread.Dvi(dvifile, self.DPI***REMOVED***
        ***REMOVED***
            page = next(iter(dvi***REMOVED******REMOVED***
        finally:
            dvi.close(***REMOVED***

        if glyph_map is None:
            glyph_map = dict(***REMOVED***

        if return_new_glyphs_only:
            glyph_map_new = dict(***REMOVED***
        else:
            glyph_map_new = glyph_map

        glyph_ids, xpositions, ypositions, sizes = [***REMOVED***, [***REMOVED***, [***REMOVED***, [***REMOVED***

        # Gather font information and do some setup for combining
        # characters into strings.
        # oldfont, seq = None, [***REMOVED***
        for x1, y1, dvifont, glyph, width in page.text:
            font_and_encoding = self._ps_fontd.get(dvifont.texname***REMOVED***
            font_bunch = self.tex_font_map[dvifont.texname***REMOVED***

            if font_and_encoding is None:
                font = FT2Font(font_bunch.filename***REMOVED***

                for charmap_name, charmap_code in [("ADOBE_CUSTOM",
                                                    1094992451***REMOVED***,
                                                   ("ADOBE_STANDARD",
                                                    1094995778***REMOVED******REMOVED***:
                    ***REMOVED***
                        font.select_charmap(charmap_code***REMOVED***
                    except (ValueError, RuntimeError***REMOVED***:
                        pass
                    else:
                        break
                else:
                    charmap_name = ""
                    warnings.warn("No supported encoding in font (%s***REMOVED***." %
                                  font_bunch.filename***REMOVED***

                if charmap_name == "ADOBE_STANDARD" and font_bunch.encoding:
                    enc0 = dviread.Encoding(font_bunch.encoding***REMOVED***
                    enc = dict([(i, self._adobe_standard_encoding.get(c, None***REMOVED******REMOVED***
                                for i, c in enumerate(enc0.encoding***REMOVED******REMOVED******REMOVED***
                else:
                    enc = dict(***REMOVED***
                self._ps_fontd[dvifont.texname***REMOVED*** = font, enc

            else:
                font, enc = font_and_encoding

            ft2font_flag = LOAD_TARGET_LIGHT

            char_id = self._get_char_id_ps(font, glyph***REMOVED***

            if char_id not in glyph_map:
                font.clear(***REMOVED***
                font.set_size(self.FONT_SCALE, self.DPI***REMOVED***
                if enc:
                    charcode = enc.get(glyph, None***REMOVED***
                else:
                    charcode = glyph

                if charcode is not None:
                    glyph0 = font.load_char(charcode, flags=ft2font_flag***REMOVED***
                else:
                    warnings.warn("The glyph (%d***REMOVED*** of font (%s***REMOVED*** cannot be "
                                  "converted with the encoding. Glyph may "
                                  "be wrong" % (glyph, font_bunch.filename***REMOVED******REMOVED***

                    glyph0 = font.load_char(glyph, flags=ft2font_flag***REMOVED***

                glyph_map_new[char_id***REMOVED*** = self.glyph_to_path(font***REMOVED***

            glyph_ids.append(char_id***REMOVED***
            xpositions.append(x1***REMOVED***
            ypositions.append(y1***REMOVED***
            sizes.append(dvifont.size / self.FONT_SCALE***REMOVED***

        myrects = [***REMOVED***

        for ox, oy, h, w in page.boxes:
            vert1 = [(ox, oy***REMOVED***, (ox + w, oy***REMOVED***, (ox + w, oy + h***REMOVED***,
                     (ox, oy + h***REMOVED***, (ox, oy***REMOVED***, (0, 0***REMOVED******REMOVED***
            code1 = [Path.MOVETO,
                     Path.LINETO, Path.LINETO, Path.LINETO, Path.LINETO,
                     Path.CLOSEPOLY***REMOVED***
            myrects.append((vert1, code1***REMOVED******REMOVED***

        return (list(zip(glyph_ids, xpositions, ypositions, sizes***REMOVED******REMOVED***,
                glyph_map_new, myrects***REMOVED***


text_to_path = TextToPath(***REMOVED***


class TextPath(Path***REMOVED***:
    ***REMOVED***
    Create a path from the text.
    ***REMOVED***

    def __init__(self, xy, s, size=None, prop=None,
                 _interpolation_steps=1, usetex=False,
                 *kl, **kwargs***REMOVED***:
        ***REMOVED***
        Create a path from the text. No support for TeX yet. Note that
        it simply is a path, not an artist. You need to use the
        PathPatch (or other artists***REMOVED*** to draw this path onto the
        canvas.

        xy : position of the text.
        s : text
        size : font size
        prop : font property
        ***REMOVED***

        if prop is None:
            prop = FontProperties(***REMOVED***

        if size is None:
            size = prop.get_size_in_points(***REMOVED***

        self._xy = xy
        self.set_size(size***REMOVED***

        self._cached_vertices = None

        self._vertices, self._codes = self.text_get_vertices_codes(
                                            prop, s,
                                            usetex=usetex***REMOVED***

        self._should_simplify = False
        self._simplify_threshold = rcParams['path.simplify_threshold'***REMOVED***
        self._has_nonfinite = False
        self._interpolation_steps = _interpolation_steps

    def set_size(self, size***REMOVED***:
        ***REMOVED***
        set the size of the text
        ***REMOVED***
        self._size = size
        self._invalid = True

    def get_size(self***REMOVED***:
        ***REMOVED***
        get the size of the text
        ***REMOVED***
        return self._size

    def _get_vertices(self***REMOVED***:
        ***REMOVED***
        Return the cached path after updating it if necessary.
        ***REMOVED***
        self._revalidate_path(***REMOVED***
        return self._cached_vertices

    def _get_codes(self***REMOVED***:
        ***REMOVED***
        Return the codes
        ***REMOVED***
        return self._codes

    vertices = property(_get_vertices***REMOVED***
    codes = property(_get_codes***REMOVED***

    def _revalidate_path(self***REMOVED***:
        ***REMOVED***
        update the path if necessary.

        The path for the text is initially create with the font size
        of FONT_SCALE, and this path is rescaled to other size when
        necessary.

        ***REMOVED***
        if (self._invalid or
            (self._cached_vertices is None***REMOVED******REMOVED***:
            tr = Affine2D(***REMOVED***.scale(
                    self._size / text_to_path.FONT_SCALE,
                    self._size / text_to_path.FONT_SCALE***REMOVED***.translate(*self._xy***REMOVED***
            self._cached_vertices = tr.transform(self._vertices***REMOVED***
            self._invalid = False

    def is_math_text(self, s***REMOVED***:
        ***REMOVED***
        Returns True if the given string *s* contains any mathtext.
        ***REMOVED***
        # copied from Text.is_math_text -JJL

        # Did we find an even number of non-escaped dollar signs?
        # If so, treat is as math text.
        dollar_count = s.count(r'$'***REMOVED*** - s.count(r'\$'***REMOVED***
        even_dollars = (dollar_count > 0 and dollar_count % 2 == 0***REMOVED***

        if rcParams['text.usetex'***REMOVED***:
            return s, 'TeX'

        if even_dollars:
            return s, True
        else:
            return s.replace(r'\$', '$'***REMOVED***, False

    def text_get_vertices_codes(self, prop, s, usetex***REMOVED***:
        ***REMOVED***
        convert the string *s* to vertices and codes using the
        provided font property *prop*. Mostly copied from
        backend_svg.py.
        ***REMOVED***

        if usetex:
            verts, codes = text_to_path.get_text_path(prop, s, usetex=True***REMOVED***
        else:
            clean_line, ismath = self.is_math_text(s***REMOVED***
            verts, codes = text_to_path.get_text_path(prop, clean_line,
                                                      ismath=ismath***REMOVED***

        return verts, codes
