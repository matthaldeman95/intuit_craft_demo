***REMOVED***
This module contains functions to handle markers.  Used by both the
marker functionality of `~matplotlib.axes.Axes.plot` and
`~matplotlib.axes.Axes.scatter`.

All possible markers are defined here:

============================== ===============================================
marker                         description
============================== ===============================================
"."                            point
","                            pixel
"o"                            circle
"v"                            triangle_down
"^"                            triangle_up
"<"                            triangle_left
">"                            triangle_right
"1"                            tri_down
"2"                            tri_up
"3"                            tri_left
"4"                            tri_right
"8"                            octagon
"s"                            square
"p"                            pentagon
"*"                            star
"h"                            hexagon1
"H"                            hexagon2
"+"                            plus
"x"                            x
"D"                            diamond
"d"                            thin_diamond
"|"                            vline
"_"                            hline
TICKLEFT                       tickleft
TICKRIGHT                      tickright
TICKUP                         tickup
TICKDOWN                       tickdown
CARETLEFT                      caretleft
CARETRIGHT                     caretright
CARETUP                        caretup
CARETDOWN                      caretdown
"None"                         nothing
None                           nothing
" "                            nothing
""                             nothing
``'$...$'``                    render the string using mathtext.
`verts`                        a list of (x, y***REMOVED*** pairs used for Path vertices.
                               The center of the marker is located at (0,0***REMOVED*** and
                               the size is normalized.
path                           a `~matplotlib.path.Path` instance.
(`numsides`, `style`, `angle`***REMOVED*** see below
============================== ===============================================

The marker can also be a tuple (`numsides`, `style`, `angle`***REMOVED***, which
will create a custom, regular symbol.

    `numsides`:
      the number of sides

    `style`:
      the style of the regular symbol:

      =====   =============================================
      Value   Description
      =====   =============================================
      0       a regular polygon
      1       a star-like symbol
      2       an asterisk
      3       a circle (`numsides` and `angle` is ignored***REMOVED***
      =====   =============================================

    `angle`:
      the angle of rotation of the symbol, in degrees

For backward compatibility, the form (`verts`, 0***REMOVED*** is also accepted,
but it is equivalent to just `verts` for giving a raw set of vertices
that define the shape.
***REMOVED***
from __future__ import (absolute_import, division, print_function,
                        unicode_literals***REMOVED***

from matplotlib.externals import six
from matplotlib.externals.six.moves import xrange

import numpy as np

from .cbook import is_math_text, is_string_like, is_numlike, iterable
from matplotlib import rcParams
from .path import Path
from .transforms import IdentityTransform, Affine2D

# special-purpose marker identifiers:
(TICKLEFT, TICKRIGHT, TICKUP, TICKDOWN,
 CARETLEFT, CARETRIGHT, CARETUP, CARETDOWN***REMOVED*** = list(xrange(8***REMOVED******REMOVED***


class MarkerStyle(object***REMOVED***:

    markers = {
        '.': 'point',
        ',': 'pixel',
        'o': 'circle',
        'v': 'triangle_down',
        '^': 'triangle_up',
        '<': 'triangle_left',
        '>': 'triangle_right',
        '1': 'tri_down',
        '2': 'tri_up',
        '3': 'tri_left',
        '4': 'tri_right',
        '8': 'octagon',
        's': 'square',
        'p': 'pentagon',
        '*': 'star',
        'h': 'hexagon1',
        'H': 'hexagon2',
        '+': 'plus',
        'x': 'x',
        'D': 'diamond',
        'd': 'thin_diamond',
        '|': 'vline',
        '_': 'hline',
        TICKLEFT: 'tickleft',
        TICKRIGHT: 'tickright',
        TICKUP: 'tickup',
        TICKDOWN: 'tickdown',
        CARETLEFT: 'caretleft',
        CARETRIGHT: 'caretright',
        CARETUP: 'caretup',
        CARETDOWN: 'caretdown',
        "None": 'nothing',
        None: 'nothing',
        ' ': 'nothing',
        '': 'nothing'
***REMOVED***

    # Just used for informational purposes.  is_filled(***REMOVED***
    # is calculated in the _set_* functions.
    filled_markers = (
        'o', 'v', '^', '<', '>', '8', 's', 'p', '*', 'h', 'H', 'D', 'd'***REMOVED***

    fillstyles = ('full', 'left', 'right', 'bottom', 'top', 'none'***REMOVED***
    _half_fillstyles = ('left', 'right', 'bottom', 'top'***REMOVED***

    # TODO: Is this ever used as a non-constant?
    _point_size_reduction = 0.5

    def __init__(self, marker=None, fillstyle=None***REMOVED***:
        ***REMOVED***
        MarkerStyle

        Attributes
        ----------
        markers : list of known markes

        fillstyles : list of known fillstyles

        filled_markers : list of known filled markers.

        Parameters
        ----------
        marker : string or array_like, optional, default: None
            See the descriptions of possible markers in the module docstring.

        fillstyle : string, optional, default: 'full'
            'full', 'left", 'right', 'bottom', 'top', 'none'
        ***REMOVED***
        # The fillstyle has to be set here as it might be accessed by calls to
        # _recache(***REMOVED*** in set_marker.
        self._fillstyle = fillstyle
        self.set_marker(marker***REMOVED***
        self.set_fillstyle(fillstyle***REMOVED***

    def __getstate__(self***REMOVED***:
        d = self.__dict__.copy(***REMOVED***
        d.pop('_marker_function'***REMOVED***
        return d

    def __setstate__(self, statedict***REMOVED***:
        self.__dict__ = statedict
        self.set_marker(self._marker***REMOVED***
        self._recache(***REMOVED***

    def _recache(self***REMOVED***:
        self._path = Path(np.empty((0, 2***REMOVED******REMOVED******REMOVED***
        self._transform = IdentityTransform(***REMOVED***
        self._alt_path = None
        self._alt_transform = None
        self._snap_threshold = None
        self._joinstyle = 'round'
        self._capstyle = 'butt'
        self._filled = True
        self._marker_function(***REMOVED***

    if six.PY3:
        def __bool__(self***REMOVED***:
            return bool(len(self._path.vertices***REMOVED******REMOVED***
    else:
        def __nonzero__(self***REMOVED***:
            return bool(len(self._path.vertices***REMOVED******REMOVED***

    def is_filled(self***REMOVED***:
        return self._filled

    def get_fillstyle(self***REMOVED***:
        return self._fillstyle

    def set_fillstyle(self, fillstyle***REMOVED***:
        ***REMOVED***
        Sets fillstyle

        Parameters
        ----------
        fillstyle : string amongst known fillstyles
        ***REMOVED***
        if fillstyle is None:
            fillstyle = rcParams['markers.fillstyle'***REMOVED***
        if fillstyle not in self.fillstyles:
            raise ValueError("Unrecognized fillstyle %s"
                             % ' '.join(self.fillstyles***REMOVED******REMOVED***
        self._fillstyle = fillstyle
        self._recache(***REMOVED***

    def get_joinstyle(self***REMOVED***:
        return self._joinstyle

    def get_capstyle(self***REMOVED***:
        return self._capstyle

    def get_marker(self***REMOVED***:
        return self._marker

    def set_marker(self, marker***REMOVED***:
        if (iterable(marker***REMOVED*** and len(marker***REMOVED*** in (2, 3***REMOVED*** and
                marker[1***REMOVED*** in (0, 1, 2, 3***REMOVED******REMOVED***:
            self._marker_function = self._set_tuple_marker
        elif isinstance(marker, np.ndarray***REMOVED***:
            self._marker_function = self._set_vertices
        elif not isinstance(marker, list***REMOVED*** and marker in self.markers:
            self._marker_function = getattr(
                self, '_set_' + self.markers[marker***REMOVED******REMOVED***
        elif is_string_like(marker***REMOVED*** and is_math_text(marker***REMOVED***:
            self._marker_function = self._set_mathtext_path
        elif isinstance(marker, Path***REMOVED***:
            self._marker_function = self._set_path_marker
        else:
            ***REMOVED***
                Path(marker***REMOVED***
                self._marker_function = self._set_vertices
            except ValueError:
                raise ValueError('Unrecognized marker style'
                                 ' {0***REMOVED***'.format(marker***REMOVED******REMOVED***

        self._marker = marker
        self._recache(***REMOVED***

    def get_path(self***REMOVED***:
        return self._path

    def get_transform(self***REMOVED***:
        return self._transform.frozen(***REMOVED***

    def get_alt_path(self***REMOVED***:
        return self._alt_path

    def get_alt_transform(self***REMOVED***:
        return self._alt_transform.frozen(***REMOVED***

    def get_snap_threshold(self***REMOVED***:
        return self._snap_threshold

    def _set_nothing(self***REMOVED***:
        self._filled = False

    def _set_custom_marker(self, path***REMOVED***:
        verts = path.vertices
        rescale = max(np.max(np.abs(verts[:, 0***REMOVED******REMOVED******REMOVED***,
                      np.max(np.abs(verts[:, 1***REMOVED******REMOVED******REMOVED******REMOVED***
        self._transform = Affine2D(***REMOVED***.scale(0.5 / rescale***REMOVED***
        self._path = path

    def _set_path_marker(self***REMOVED***:
        self._set_custom_marker(self._marker***REMOVED***

    def _set_vertices(self***REMOVED***:
        verts = self._marker
        marker = Path(verts***REMOVED***
        self._set_custom_marker(marker***REMOVED***

    def _set_tuple_marker(self***REMOVED***:
        marker = self._marker
        if is_numlike(marker[0***REMOVED******REMOVED***:
            if len(marker***REMOVED*** == 2:
                numsides, rotation = marker[0***REMOVED***, 0.0
            elif len(marker***REMOVED*** == 3:
                numsides, rotation = marker[0***REMOVED***, marker[2***REMOVED***
            symstyle = marker[1***REMOVED***
            if symstyle == 0:
                self._path = Path.unit_regular_polygon(numsides***REMOVED***
                self._joinstyle = 'miter'
            elif symstyle == 1:
                self._path = Path.unit_regular_star(numsides***REMOVED***
                self._joinstyle = 'bevel'
            elif symstyle == 2:
                self._path = Path.unit_regular_asterisk(numsides***REMOVED***
                self._filled = False
                self._joinstyle = 'bevel'
            elif symstyle == 3:
                self._path = Path.unit_circle(***REMOVED***
            self._transform = Affine2D(***REMOVED***.scale(0.5***REMOVED***.rotate_deg(rotation***REMOVED***
        else:
            verts = np.asarray(marker[0***REMOVED******REMOVED***
            path = Path(verts***REMOVED***
            self._set_custom_marker(path***REMOVED***

    def _set_mathtext_path(self***REMOVED***:
        ***REMOVED***
        Draws mathtext markers '$...$' using TextPath object.

        Submitted by tcb
        ***REMOVED***
        from matplotlib.text import TextPath
        from matplotlib.font_manager import FontProperties

        # again, the properties could be initialised just once outside
        # this function
        # Font size is irrelevant here, it will be rescaled based on
        # the drawn size later
        props = FontProperties(size=1.0***REMOVED***
        text = TextPath(xy=(0, 0***REMOVED***, s=self.get_marker(***REMOVED***, fontproperties=props,
                        usetex=rcParams['text.usetex'***REMOVED******REMOVED***
        if len(text.vertices***REMOVED*** == 0:
            return

        xmin, ymin = text.vertices.min(axis=0***REMOVED***
        xmax, ymax = text.vertices.max(axis=0***REMOVED***
        width = xmax - xmin
        height = ymax - ymin
        max_dim = max(width, height***REMOVED***
        self._transform = Affine2D(***REMOVED*** \
            .translate(-xmin + 0.5 * -width, -ymin + 0.5 * -height***REMOVED*** \
            .scale(1.0 / max_dim***REMOVED***
        self._path = text
        self._snap = False

    def _half_fill(self***REMOVED***:
        fs = self.get_fillstyle(***REMOVED***
        result = fs in self._half_fillstyles
        return result

    def _set_circle(self, reduction=1.0***REMOVED***:
        self._transform = Affine2D(***REMOVED***.scale(0.5 * reduction***REMOVED***
        self._snap_threshold = np.inf
        fs = self.get_fillstyle(***REMOVED***
        if not self._half_fill(***REMOVED***:
            self._path = Path.unit_circle(***REMOVED***
        else:
            # build a right-half circle
            if fs == 'bottom':
                rotate = 270.
            elif fs == 'top':
                rotate = 90.
            elif fs == 'left':
                rotate = 180.
            else:
                rotate = 0.

            self._path = self._alt_path = Path.unit_circle_righthalf(***REMOVED***
            self._transform.rotate_deg(rotate***REMOVED***
            self._alt_transform = self._transform.frozen(***REMOVED***.rotate_deg(180.***REMOVED***

    def _set_pixel(self***REMOVED***:
        self._path = Path.unit_rectangle(***REMOVED***
        # Ideally, you'd want -0.5, -0.5 here, but then the snapping
        # algorithm in the Agg backend will round this to a 2x2
        # rectangle from (-1, -1***REMOVED*** to (1, 1***REMOVED***.  By offsetting it
        # slightly, we can force it to be (0, 0***REMOVED*** to (1, 1***REMOVED***, which both
        # makes it only be a single pixel and places it correctly
        # aligned to 1-width stroking (i.e. the ticks***REMOVED***.  This hack is
        # the best of a number of bad alternatives, mainly because the
        # backends are not aware of what marker is actually being used
        # beyond just its path data.
        self._transform = Affine2D(***REMOVED***.translate(-0.49999, -0.49999***REMOVED***
        self._snap_threshold = None

    def _set_point(self***REMOVED***:
        self._set_circle(reduction=self._point_size_reduction***REMOVED***

    _triangle_path = Path(
        [[0.0, 1.0***REMOVED***, [-1.0, -1.0***REMOVED***, [1.0, -1.0***REMOVED***, [0.0, 1.0***REMOVED******REMOVED***,
        [Path.MOVETO, Path.LINETO, Path.LINETO, Path.CLOSEPOLY***REMOVED******REMOVED***
    # Going down halfway looks to small.  Golden ratio is too far.
    _triangle_path_u = Path(
        [[0.0, 1.0***REMOVED***, [-3 / 5., -1 / 5.***REMOVED***, [3 / 5., -1 / 5.***REMOVED***, [0.0, 1.0***REMOVED******REMOVED***,
        [Path.MOVETO, Path.LINETO, Path.LINETO, Path.CLOSEPOLY***REMOVED******REMOVED***
    _triangle_path_d = Path(
        [[-3 / 5., -1 / 5.***REMOVED***, [3 / 5., -1 / 5.***REMOVED***, [1.0, -1.0***REMOVED***, [-1.0, -1.0***REMOVED***,
         [-3 / 5., -1 / 5.***REMOVED******REMOVED***,
        [Path.MOVETO, Path.LINETO, Path.LINETO, Path.LINETO, Path.CLOSEPOLY***REMOVED******REMOVED***
    _triangle_path_l = Path(
        [[0.0, 1.0***REMOVED***, [0.0, -1.0***REMOVED***, [-1.0, -1.0***REMOVED***, [0.0, 1.0***REMOVED******REMOVED***,
        [Path.MOVETO, Path.LINETO, Path.LINETO, Path.CLOSEPOLY***REMOVED******REMOVED***
    _triangle_path_r = Path(
        [[0.0, 1.0***REMOVED***, [0.0, -1.0***REMOVED***, [1.0, -1.0***REMOVED***, [0.0, 1.0***REMOVED******REMOVED***,
        [Path.MOVETO, Path.LINETO, Path.LINETO, Path.CLOSEPOLY***REMOVED******REMOVED***

    def _set_triangle(self, rot, skip***REMOVED***:
        self._transform = Affine2D(***REMOVED***.scale(0.5, 0.5***REMOVED***.rotate_deg(rot***REMOVED***
        self._snap_threshold = 5.0
        fs = self.get_fillstyle(***REMOVED***

        if not self._half_fill(***REMOVED***:
            self._path = self._triangle_path
        else:
            mpaths = [self._triangle_path_u,
                      self._triangle_path_l,
                      self._triangle_path_d,
                      self._triangle_path_r***REMOVED***

            if fs == 'top':
                self._path = mpaths[(0 + skip***REMOVED*** % 4***REMOVED***
                self._alt_path = mpaths[(2 + skip***REMOVED*** % 4***REMOVED***
            elif fs == 'bottom':
                self._path = mpaths[(2 + skip***REMOVED*** % 4***REMOVED***
                self._alt_path = mpaths[(0 + skip***REMOVED*** % 4***REMOVED***
            elif fs == 'left':
                self._path = mpaths[(1 + skip***REMOVED*** % 4***REMOVED***
                self._alt_path = mpaths[(3 + skip***REMOVED*** % 4***REMOVED***
            else:
                self._path = mpaths[(3 + skip***REMOVED*** % 4***REMOVED***
                self._alt_path = mpaths[(1 + skip***REMOVED*** % 4***REMOVED***

            self._alt_transform = self._transform

        self._joinstyle = 'miter'

    def _set_triangle_up(self***REMOVED***:
        return self._set_triangle(0.0, 0***REMOVED***

    def _set_triangle_down(self***REMOVED***:
        return self._set_triangle(180.0, 2***REMOVED***

    def _set_triangle_left(self***REMOVED***:
        return self._set_triangle(90.0, 3***REMOVED***

    def _set_triangle_right(self***REMOVED***:
        return self._set_triangle(270.0, 1***REMOVED***

    def _set_square(self***REMOVED***:
        self._transform = Affine2D(***REMOVED***.translate(-0.5, -0.5***REMOVED***
        self._snap_threshold = 2.0
        fs = self.get_fillstyle(***REMOVED***
        if not self._half_fill(***REMOVED***:
            self._path = Path.unit_rectangle(***REMOVED***
        else:
            # build a bottom filled square out of two rectangles, one
            # filled.  Use the rotation to support left, right, bottom
            # or top
            if fs == 'bottom':
                rotate = 0.
            elif fs == 'top':
                rotate = 180.
            elif fs == 'left':
                rotate = 270.
            else:
                rotate = 90.

            self._path = Path([[0.0, 0.0***REMOVED***, [1.0, 0.0***REMOVED***, [1.0, 0.5***REMOVED***,
                               [0.0, 0.5***REMOVED***, [0.0, 0.0***REMOVED******REMOVED******REMOVED***
            self._alt_path = Path([[0.0, 0.5***REMOVED***, [1.0, 0.5***REMOVED***, [1.0, 1.0***REMOVED***,
                                   [0.0, 1.0***REMOVED***, [0.0, 0.5***REMOVED******REMOVED******REMOVED***
            self._transform.rotate_deg(rotate***REMOVED***
            self._alt_transform = self._transform

        self._joinstyle = 'miter'

    def _set_diamond(self***REMOVED***:
        self._transform = Affine2D(***REMOVED***.translate(-0.5, -0.5***REMOVED***.rotate_deg(45***REMOVED***
        self._snap_threshold = 5.0
        fs = self.get_fillstyle(***REMOVED***
        if not self._half_fill(***REMOVED***:
            self._path = Path.unit_rectangle(***REMOVED***
        else:
            self._path = Path([[0.0, 0.0***REMOVED***, [1.0, 0.0***REMOVED***, [1.0, 1.0***REMOVED***, [0.0, 0.0***REMOVED******REMOVED******REMOVED***
            self._alt_path = Path([[0.0, 0.0***REMOVED***, [0.0, 1.0***REMOVED***,
                                   [1.0, 1.0***REMOVED***, [0.0, 0.0***REMOVED******REMOVED******REMOVED***

            if fs == 'bottom':
                rotate = 270.
            elif fs == 'top':
                rotate = 90.
            elif fs == 'left':
                rotate = 180.
            else:
                rotate = 0.

            self._transform.rotate_deg(rotate***REMOVED***
            self._alt_transform = self._transform

        self._joinstyle = 'miter'

    def _set_thin_diamond(self***REMOVED***:
        self._set_diamond(***REMOVED***
        self._transform.scale(0.6, 1.0***REMOVED***

    def _set_pentagon(self***REMOVED***:
        self._transform = Affine2D(***REMOVED***.scale(0.5***REMOVED***
        self._snap_threshold = 5.0

        polypath = Path.unit_regular_polygon(5***REMOVED***
        fs = self.get_fillstyle(***REMOVED***

        if not self._half_fill(***REMOVED***:
            self._path = polypath
        else:
            verts = polypath.vertices

            y = (1 + np.sqrt(5***REMOVED******REMOVED*** / 4.
            top = Path([verts[0***REMOVED***, verts[1***REMOVED***, verts[4***REMOVED***, verts[0***REMOVED******REMOVED******REMOVED***
            bottom = Path([verts[1***REMOVED***, verts[2***REMOVED***, verts[3***REMOVED***, verts[4***REMOVED***, verts[1***REMOVED******REMOVED******REMOVED***
            left = Path([verts[0***REMOVED***, verts[1***REMOVED***, verts[2***REMOVED***, [0, -y***REMOVED***, verts[0***REMOVED******REMOVED******REMOVED***
            right = Path([verts[0***REMOVED***, verts[4***REMOVED***, verts[3***REMOVED***, [0, -y***REMOVED***, verts[0***REMOVED******REMOVED******REMOVED***

            if fs == 'top':
                mpath, mpath_alt = top, bottom
            elif fs == 'bottom':
                mpath, mpath_alt = bottom, top
            elif fs == 'left':
                mpath, mpath_alt = left, right
            else:
                mpath, mpath_alt = right, left
            self._path = mpath
            self._alt_path = mpath_alt
            self._alt_transform = self._transform

        self._joinstyle = 'miter'

    def _set_star(self***REMOVED***:
        self._transform = Affine2D(***REMOVED***.scale(0.5***REMOVED***
        self._snap_threshold = 5.0

        fs = self.get_fillstyle(***REMOVED***
        polypath = Path.unit_regular_star(5, innerCircle=0.381966***REMOVED***

        if not self._half_fill(***REMOVED***:
            self._path = polypath
        else:
            verts = polypath.vertices

            top = Path(np.vstack((verts[0:4, :***REMOVED***, verts[7:10, :***REMOVED***, verts[0***REMOVED******REMOVED******REMOVED******REMOVED***
            bottom = Path(np.vstack((verts[3:8, :***REMOVED***, verts[3***REMOVED******REMOVED******REMOVED******REMOVED***
            left = Path(np.vstack((verts[0:6, :***REMOVED***, verts[0***REMOVED******REMOVED******REMOVED******REMOVED***
            right = Path(np.vstack((verts[0***REMOVED***, verts[5:10, :***REMOVED***, verts[0***REMOVED******REMOVED******REMOVED******REMOVED***

            if fs == 'top':
                mpath, mpath_alt = top, bottom
            elif fs == 'bottom':
                mpath, mpath_alt = bottom, top
            elif fs == 'left':
                mpath, mpath_alt = left, right
            else:
                mpath, mpath_alt = right, left
            self._path = mpath
            self._alt_path = mpath_alt
            self._alt_transform = self._transform

        self._joinstyle = 'bevel'

    def _set_hexagon1(self***REMOVED***:
        self._transform = Affine2D(***REMOVED***.scale(0.5***REMOVED***
        self._snap_threshold = None

        fs = self.get_fillstyle(***REMOVED***
        polypath = Path.unit_regular_polygon(6***REMOVED***

        if not self._half_fill(***REMOVED***:
            self._path = polypath
        else:
            verts = polypath.vertices

            # not drawing inside lines
            x = np.abs(np.cos(5 * np.pi / 6.***REMOVED******REMOVED***
            top = Path(np.vstack(([-x, 0***REMOVED***, verts[(1, 0, 5***REMOVED***, :***REMOVED***, [x, 0***REMOVED******REMOVED******REMOVED******REMOVED***
            bottom = Path(np.vstack(([-x, 0***REMOVED***, verts[2:5, :***REMOVED***, [x, 0***REMOVED******REMOVED******REMOVED******REMOVED***
            left = Path(verts[(0, 1, 2, 3***REMOVED***, :***REMOVED******REMOVED***
            right = Path(verts[(0, 5, 4, 3***REMOVED***, :***REMOVED******REMOVED***

            if fs == 'top':
                mpath, mpath_alt = top, bottom
            elif fs == 'bottom':
                mpath, mpath_alt = bottom, top
            elif fs == 'left':
                mpath, mpath_alt = left, right
            else:
                mpath, mpath_alt = right, left

            self._path = mpath
            self._alt_path = mpath_alt
            self._alt_transform = self._transform

        self._joinstyle = 'miter'

    def _set_hexagon2(self***REMOVED***:
        self._transform = Affine2D(***REMOVED***.scale(0.5***REMOVED***.rotate_deg(30***REMOVED***
        self._snap_threshold = None

        fs = self.get_fillstyle(***REMOVED***
        polypath = Path.unit_regular_polygon(6***REMOVED***

        if not self._half_fill(***REMOVED***:
            self._path = polypath
        else:
            verts = polypath.vertices

            # not drawing inside lines
            x, y = np.sqrt(3***REMOVED*** / 4, 3 / 4.
            top = Path(verts[(1, 0, 5, 4, 1***REMOVED***, :***REMOVED******REMOVED***
            bottom = Path(verts[(1, 2, 3, 4***REMOVED***, :***REMOVED******REMOVED***
            left = Path(np.vstack(([x, y***REMOVED***, verts[(0, 1, 2***REMOVED***, :***REMOVED***,
                                   [-x, -y***REMOVED***, [x, y***REMOVED******REMOVED******REMOVED******REMOVED***
            right = Path(np.vstack(([x, y***REMOVED***, verts[(5, 4, 3***REMOVED***, :***REMOVED***, [-x, -y***REMOVED******REMOVED******REMOVED******REMOVED***

            if fs == 'top':
                mpath, mpath_alt = top, bottom
            elif fs == 'bottom':
                mpath, mpath_alt = bottom, top
            elif fs == 'left':
                mpath, mpath_alt = left, right
            else:
                mpath, mpath_alt = right, left

            self._path = mpath
            self._alt_path = mpath_alt
            self._alt_transform = self._transform

        self._joinstyle = 'miter'

    def _set_octagon(self***REMOVED***:
        self._transform = Affine2D(***REMOVED***.scale(0.5***REMOVED***
        self._snap_threshold = 5.0

        fs = self.get_fillstyle(***REMOVED***
        polypath = Path.unit_regular_polygon(8***REMOVED***

        if not self._half_fill(***REMOVED***:
            self._transform.rotate_deg(22.5***REMOVED***
            self._path = polypath
        else:
            x = np.sqrt(2.***REMOVED*** / 4.
            half = Path([[0, -1***REMOVED***, [0, 1***REMOVED***, [-x, 1***REMOVED***, [-1, x***REMOVED***,
                         [-1, -x***REMOVED***, [-x, -1***REMOVED***, [0, -1***REMOVED******REMOVED******REMOVED***

            if fs == 'bottom':
                rotate = 90.
            elif fs == 'top':
                rotate = 270.
            elif fs == 'right':
                rotate = 180.
            else:
                rotate = 0.

            self._transform.rotate_deg(rotate***REMOVED***
            self._path = self._alt_path = half
            self._alt_transform = self._transform.frozen(***REMOVED***.rotate_deg(180.0***REMOVED***

        self._joinstyle = 'miter'

    _line_marker_path = Path([[0.0, -1.0***REMOVED***, [0.0, 1.0***REMOVED******REMOVED******REMOVED***

    def _set_vline(self***REMOVED***:
        self._transform = Affine2D(***REMOVED***.scale(0.5***REMOVED***
        self._snap_threshold = 1.0
        self._filled = False
        self._path = self._line_marker_path

    def _set_hline(self***REMOVED***:
        self._transform = Affine2D(***REMOVED***.scale(0.5***REMOVED***.rotate_deg(90***REMOVED***
        self._snap_threshold = 1.0
        self._filled = False
        self._path = self._line_marker_path

    _tickhoriz_path = Path([[0.0, 0.0***REMOVED***, [1.0, 0.0***REMOVED******REMOVED******REMOVED***

    def _set_tickleft(self***REMOVED***:
        self._transform = Affine2D(***REMOVED***.scale(-1.0, 1.0***REMOVED***
        self._snap_threshold = 1.0
        self._filled = False
        self._path = self._tickhoriz_path

    def _set_tickright(self***REMOVED***:
        self._transform = Affine2D(***REMOVED***.scale(1.0, 1.0***REMOVED***
        self._snap_threshold = 1.0
        self._filled = False
        self._path = self._tickhoriz_path

    _tickvert_path = Path([[-0.0, 0.0***REMOVED***, [-0.0, 1.0***REMOVED******REMOVED******REMOVED***

    def _set_tickup(self***REMOVED***:
        self._transform = Affine2D(***REMOVED***.scale(1.0, 1.0***REMOVED***
        self._snap_threshold = 1.0
        self._filled = False
        self._path = self._tickvert_path

    def _set_tickdown(self***REMOVED***:
        self._transform = Affine2D(***REMOVED***.scale(1.0, -1.0***REMOVED***
        self._snap_threshold = 1.0
        self._filled = False
        self._path = self._tickvert_path

    _plus_path = Path([[-1.0, 0.0***REMOVED***, [1.0, 0.0***REMOVED***,
                       [0.0, -1.0***REMOVED***, [0.0, 1.0***REMOVED******REMOVED***,
                      [Path.MOVETO, Path.LINETO,
                       Path.MOVETO, Path.LINETO***REMOVED******REMOVED***

    def _set_plus(self***REMOVED***:
        self._transform = Affine2D(***REMOVED***.scale(0.5***REMOVED***
        self._snap_threshold = 1.0
        self._filled = False
        self._path = self._plus_path

    _tri_path = Path([[0.0, 0.0***REMOVED***, [0.0, -1.0***REMOVED***,
                      [0.0, 0.0***REMOVED***, [0.8, 0.5***REMOVED***,
                      [0.0, 0.0***REMOVED***, [-0.8, 0.5***REMOVED******REMOVED***,
                     [Path.MOVETO, Path.LINETO,
                      Path.MOVETO, Path.LINETO,
                      Path.MOVETO, Path.LINETO***REMOVED******REMOVED***

    def _set_tri_down(self***REMOVED***:
        self._transform = Affine2D(***REMOVED***.scale(0.5***REMOVED***
        self._snap_threshold = 5.0
        self._filled = False
        self._path = self._tri_path

    def _set_tri_up(self***REMOVED***:
        self._transform = Affine2D(***REMOVED***.scale(0.5***REMOVED***.rotate_deg(180***REMOVED***
        self._snap_threshold = 5.0
        self._filled = False
        self._path = self._tri_path

    def _set_tri_left(self***REMOVED***:
        self._transform = Affine2D(***REMOVED***.scale(0.5***REMOVED***.rotate_deg(270***REMOVED***
        self._snap_threshold = 5.0
        self._filled = False
        self._path = self._tri_path

    def _set_tri_right(self***REMOVED***:
        self._transform = Affine2D(***REMOVED***.scale(0.5***REMOVED***.rotate_deg(90***REMOVED***
        self._snap_threshold = 5.0
        self._filled = False
        self._path = self._tri_path

    _caret_path = Path([[-1.0, 1.5***REMOVED***, [0.0, 0.0***REMOVED***, [1.0, 1.5***REMOVED******REMOVED******REMOVED***

    def _set_caretdown(self***REMOVED***:
        self._transform = Affine2D(***REMOVED***.scale(0.5***REMOVED***
        self._snap_threshold = 3.0
        self._filled = False
        self._path = self._caret_path
        self._joinstyle = 'miter'

    def _set_caretup(self***REMOVED***:
        self._transform = Affine2D(***REMOVED***.scale(0.5***REMOVED***.rotate_deg(180***REMOVED***
        self._snap_threshold = 3.0
        self._filled = False
        self._path = self._caret_path
        self._joinstyle = 'miter'

    def _set_caretleft(self***REMOVED***:
        self._transform = Affine2D(***REMOVED***.scale(0.5***REMOVED***.rotate_deg(270***REMOVED***
        self._snap_threshold = 3.0
        self._filled = False
        self._path = self._caret_path
        self._joinstyle = 'miter'

    def _set_caretright(self***REMOVED***:
        self._transform = Affine2D(***REMOVED***.scale(0.5***REMOVED***.rotate_deg(90***REMOVED***
        self._snap_threshold = 3.0
        self._filled = False
        self._path = self._caret_path
        self._joinstyle = 'miter'

    _x_path = Path([[-1.0, -1.0***REMOVED***, [1.0, 1.0***REMOVED***,
                    [-1.0, 1.0***REMOVED***, [1.0, -1.0***REMOVED******REMOVED***,
                   [Path.MOVETO, Path.LINETO,
                    Path.MOVETO, Path.LINETO***REMOVED******REMOVED***

    def _set_x(self***REMOVED***:
        self._transform = Affine2D(***REMOVED***.scale(0.5***REMOVED***
        self._snap_threshold = 3.0
        self._filled = False
        self._path = self._x_path
