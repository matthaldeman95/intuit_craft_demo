from __future__ import (absolute_import, division, print_function,
                        unicode_literals***REMOVED***

from matplotlib.externals import six

import io
***REMOVED***

import numpy as np
from numpy.testing import assert_array_almost_equal

from nose.tools import assert_raises

from matplotlib.image import imread
from matplotlib.backends.backend_agg import FigureCanvasAgg as FigureCanvas
from matplotlib.figure import Figure
from matplotlib.testing.decorators import cleanup
from matplotlib import pyplot as plt
from matplotlib import collections
from matplotlib import path


@cleanup
def test_repeated_save_with_alpha(***REMOVED***:
    # We want an image which has a background color of bluish green, with an
    # alpha of 0.25.

    fig = Figure([1, 0.4***REMOVED******REMOVED***
    canvas = FigureCanvas(fig***REMOVED***
    fig.set_facecolor((0, 1, 0.4***REMOVED******REMOVED***
    fig.patch.set_alpha(0.25***REMOVED***

    # The target color is fig.patch.get_facecolor(***REMOVED***

    buf = io.BytesIO(***REMOVED***

    fig.savefig(buf,
                facecolor=fig.get_facecolor(***REMOVED***,
                edgecolor='none'***REMOVED***

    # Save the figure again to check that the
    # colors don't bleed from the previous renderer.
    buf.seek(0***REMOVED***
    fig.savefig(buf,
                facecolor=fig.get_facecolor(***REMOVED***,
                edgecolor='none'***REMOVED***

    # Check the first pixel has the desired color & alpha
    # (approx: 0, 1.0, 0.4, 0.25***REMOVED***
    buf.seek(0***REMOVED***
    assert_array_almost_equal(tuple(imread(buf***REMOVED***[0, 0***REMOVED******REMOVED***,
                              (0.0, 1.0, 0.4, 0.250***REMOVED***,
                              decimal=3***REMOVED***


@cleanup
def test_large_single_path_collection(***REMOVED***:
    buff = io.BytesIO(***REMOVED***

    # Generates a too-large single path in a path collection that
    # would cause a segfault if the draw_markers optimization is
    # applied.
    f, ax = plt.subplots(***REMOVED***
    collection = collections.PathCollection(
        [path.Path([[-10, 5***REMOVED***, [10, 5***REMOVED***, [10, -5***REMOVED***, [-10, -5***REMOVED***, [-10, 5***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***
    ax.add_artist(collection***REMOVED***
    ax.set_xlim(10**-3, 1***REMOVED***
    plt.savefig(buff***REMOVED***


def report_memory(i***REMOVED***:
    pid = os.getpid(***REMOVED***
    a2 = os.popen('ps -p %d -o rss,sz' % pid***REMOVED***.readlines(***REMOVED***
    print(i, '  ', a2[1***REMOVED***, end=' '***REMOVED***
    return int(a2[1***REMOVED***.split(***REMOVED***[0***REMOVED******REMOVED***

# This test is disabled -- it uses old API. -ADS 2009-09-07
## def test_memleak(***REMOVED***:
##     ***REMOVED***Test agg backend for memory leaks.***REMOVED***
##     from matplotlib.ft2font import FT2Font
##     from numpy.random import rand
##     from matplotlib.backend_bases import GraphicsContextBase
##     from matplotlib.backends._backend_agg import RendererAgg

##     fontname = '/usr/local/share/matplotlib/Vera.ttf'

##     N = 200
##     for i in range( N ***REMOVED***:
##         gc = GraphicsContextBase(***REMOVED***
##         gc.set_clip_rectangle( [20, 20, 20, 20***REMOVED*** ***REMOVED***
##         o = RendererAgg( 400, 400, 72 ***REMOVED***

##         for j in range( 50 ***REMOVED***:
##             xs = [ 400*int(rand(***REMOVED******REMOVED*** for k in range(8***REMOVED*** ***REMOVED***
##             ys = [ 400*int(rand(***REMOVED******REMOVED*** for k in range(8***REMOVED*** ***REMOVED***
##             rgb = (1, 0, 0***REMOVED***
##             pnts = zip( xs, ys ***REMOVED***
##             o.draw_polygon( gc, rgb, pnts ***REMOVED***
##             o.draw_polygon( gc, None, pnts ***REMOVED***

##         for j in range( 50 ***REMOVED***:
##             x = [ 400*int(rand(***REMOVED******REMOVED*** for k in range(4***REMOVED*** ***REMOVED***
##             y = [ 400*int(rand(***REMOVED******REMOVED*** for k in range(4***REMOVED*** ***REMOVED***
##             o.draw_lines( gc, x, y ***REMOVED***

##         for j in range( 50 ***REMOVED***:
##             args = [ 400*int(rand(***REMOVED******REMOVED*** for k in range(4***REMOVED*** ***REMOVED***
##             rgb = (1, 0, 0***REMOVED***
##             o.draw_rectangle( gc, rgb, *args ***REMOVED***

##         if 1: # add text
##             font = FT2Font( fontname ***REMOVED***
##             font.clear(***REMOVED***
##             font.set_text( 'hi mom', 60 ***REMOVED***
##             font.set_size( 12, 72 ***REMOVED***
##             o.draw_text_image( font.get_image(***REMOVED***, 30, 40, gc ***REMOVED***

##         fname = "agg_memleak_%05d.png"
##         o.write_png( fname % i ***REMOVED***
##         val = report_memory( i ***REMOVED***
##         if i==1: start = val

##     end = val
##     avgMem = (end - start***REMOVED*** / float(N***REMOVED***
##     print 'Average memory consumed per loop: %1.4f\n' % (avgMem***REMOVED***

##     #TODO: Verify the expected mem usage and approximate tolerance that
##     # should be used
##     #self.checkClose( 0.32, avgMem, absTol = 0.1 ***REMOVED***

##     # w/o text and w/o write_png: Average memory consumed per loop: 0.02
##     # w/o text and w/ write_png : Average memory consumed per loop: 0.3400
##     # w/ text and w/ write_png  : Average memory consumed per loop: 0.32


@cleanup
def test_marker_with_nan(***REMOVED***:
    # This creates a marker with nans in it, which was segfaulting the
    # Agg backend (see #3722***REMOVED***
    fig, ax = plt.subplots(1***REMOVED***
    steps = 1000
    data = np.arange(steps***REMOVED***
    ax.semilogx(data***REMOVED***
    ax.fill_between(data, data*0.8, data*1.2***REMOVED***
    buf = io.BytesIO(***REMOVED***
    fig.savefig(buf, format='png'***REMOVED***


@cleanup
def test_long_path(***REMOVED***:
    buff = io.BytesIO(***REMOVED***

    fig, ax = plt.subplots(***REMOVED***
    np.random.seed(0***REMOVED***
    points = np.random.rand(70000***REMOVED***
    ax.plot(points***REMOVED***
    fig.savefig(buff, format='png'***REMOVED***


@cleanup
def test_too_large_image(***REMOVED***:
    fig = plt.figure(figsize=(300, 1000***REMOVED******REMOVED***
    buff = io.BytesIO(***REMOVED***
    assert_raises(ValueError, fig.savefig, buff***REMOVED***


if __name__ == "__main__":
    import nose
    nose.runmodule(argv=['-s', '--with-doctest'***REMOVED***, exit=False***REMOVED***
