from __future__ import (absolute_import, division, print_function,
                        unicode_literals***REMOVED***
from distutils.version import LooseVersion

from matplotlib.externals import six
from matplotlib.externals.six.moves import xrange

import numpy as np

from matplotlib import rcParams
from matplotlib.testing.decorators import image_comparison
from matplotlib.testing.noseclasses import KnownFailureTest
import matplotlib.pyplot as plt
import matplotlib.path as mpath
import matplotlib.patches as mpatches
from matplotlib.ticker import FuncFormatter


@image_comparison(baseline_images=['bbox_inches_tight'***REMOVED***, remove_text=True,
                  savefig_kwarg=dict(bbox_inches='tight'***REMOVED***, tol=15***REMOVED***
def test_bbox_inches_tight(***REMOVED***:
    #: Test that a figure saved using bbox_inches='tight' is clipped correctly
    data = [[ 66386, 174296,  75131, 577908,  32015***REMOVED***,
            [ 58230, 381139,  78045,  99308, 160454***REMOVED***,
            [ 89135,  80552, 152558, 497981, 603535***REMOVED***,
            [ 78415,  81858, 150656, 193263,  69638***REMOVED***,
            [139361, 331509, 343164, 781380,  52269***REMOVED******REMOVED***

    colLabels = rowLabels = [''***REMOVED*** * 5

    rows = len(data***REMOVED***
    ind = np.arange(len(colLabels***REMOVED******REMOVED*** + 0.3  # the x locations for the groups
    cellText = [***REMOVED***
    width = 0.4     # the width of the bars
    yoff = np.array([0.0***REMOVED*** * len(colLabels***REMOVED******REMOVED***
    # the bottom values for stacked bar chart
    fig, ax = plt.subplots(1, 1***REMOVED***
    for row in xrange(rows***REMOVED***:
        plt.bar(ind, data[row***REMOVED***, width, bottom=yoff***REMOVED***
        yoff = yoff + data[row***REMOVED***
        cellText.append([''***REMOVED******REMOVED***
    plt.xticks([***REMOVED******REMOVED***
    plt.legend([''***REMOVED*** * 5, loc=(1.2, 0.2***REMOVED******REMOVED***
    # Add a table at the bottom of the axes
    cellText.reverse(***REMOVED***
    the_table = plt.table(cellText=cellText,
                          rowLabels=rowLabels,
                          colLabels=colLabels, loc='bottom'***REMOVED***


@image_comparison(baseline_images=['bbox_inches_tight_suptile_legend'***REMOVED***,
                  remove_text=False, savefig_kwarg={'bbox_inches': 'tight'***REMOVED******REMOVED***
def test_bbox_inches_tight_suptile_legend(***REMOVED***:
    plt.plot(list(xrange(10***REMOVED******REMOVED***, label='a straight line'***REMOVED***
    plt.legend(bbox_to_anchor=(0.9, 1***REMOVED***, loc=2, ***REMOVED***
    plt.title('Axis title'***REMOVED***
    plt.suptitle('Figure title'***REMOVED***

    # put an extra long y tick on to see that the bbox is accounted for
    def y_formatter(y, pos***REMOVED***:
        if int(y***REMOVED*** == 4:
            return 'The number 4'
        else:
            return str(y***REMOVED***
    plt.gca(***REMOVED***.yaxis.set_major_formatter(FuncFormatter(y_formatter***REMOVED******REMOVED***

    plt.xlabel('X axis'***REMOVED***


@image_comparison(baseline_images=['bbox_inches_tight_clipping'***REMOVED***,
                  remove_text=True, savefig_kwarg={'bbox_inches': 'tight'***REMOVED******REMOVED***
def test_bbox_inches_tight_clipping(***REMOVED***:
    # tests bbox clipping on scatter points, and path clipping on a patch
    # to generate an appropriately tight bbox
    plt.scatter(list(xrange(10***REMOVED******REMOVED***, list(xrange(10***REMOVED******REMOVED******REMOVED***
    ax = plt.gca(***REMOVED***
    ax.set_xlim([0, 5***REMOVED******REMOVED***
    ax.set_ylim([0, 5***REMOVED******REMOVED***

    # make a massive rectangle and clip it with a path
    patch = mpatches.Rectangle([-50, -50***REMOVED***, 100, 100,
                               transform=ax.transData,
                               facecolor='blue', alpha=0.5***REMOVED***

    path = mpath.Path.unit_regular_star(5***REMOVED***.deepcopy(***REMOVED***
    path.vertices *= 0.25
    patch.set_clip_path(path, transform=ax.transAxes***REMOVED***
    plt.gcf(***REMOVED***.artists.append(patch***REMOVED***
    
    
@image_comparison(baseline_images=['bbox_inches_tight_raster'***REMOVED***,
                  remove_text=True, savefig_kwarg={'bbox_inches': 'tight'***REMOVED******REMOVED***
def test_bbox_inches_tight_raster(***REMOVED***:
    ***REMOVED***Test rasterization with tight_layout***REMOVED***
    if LooseVersion(np.__version__***REMOVED*** >= LooseVersion('1.11.0'***REMOVED***:
        raise KnownFailureTest("Fall out from a fixed numpy bug"***REMOVED***
    fig = plt.figure(***REMOVED***
    ax = fig.add_subplot(111***REMOVED***
    ax.plot([1.0, 2.0***REMOVED***, rasterized=True***REMOVED***

if __name__ == '__main__':
    import nose
    nose.runmodule(argv=['-s', '--with-doctest'***REMOVED***, exit=False***REMOVED***
