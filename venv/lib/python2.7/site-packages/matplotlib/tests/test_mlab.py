from __future__ import (absolute_import, division, print_function,
                        unicode_literals***REMOVED***

from matplotlib.externals import six

import tempfile

from numpy.testing import assert_allclose, assert_array_equal
import numpy.ma.testutils as matest
import numpy as np
import datetime as datetime
from nose.tools import (assert_equal, assert_almost_equal, assert_not_equal,
                        assert_true, assert_raises***REMOVED***

import matplotlib.mlab as mlab
import matplotlib.cbook as cbook
from matplotlib.testing.decorators import knownfailureif, CleanupTestCase


***REMOVED***
    from mpl_toolkits.natgrid import _natgrid
    HAS_NATGRID = True
except ImportError:
    HAS_NATGRID = False


class general_testcase(CleanupTestCase***REMOVED***:
    def test_colinear_pca(self***REMOVED***:
        a = mlab.PCA._get_colinear(***REMOVED***
        pca = mlab.PCA(a***REMOVED***

        assert_allclose(pca.fracs[2:***REMOVED***, 0., atol=1e-8***REMOVED***
        assert_allclose(pca.Y[:, 2:***REMOVED***, 0., atol=1e-8***REMOVED***

    def test_prctile(self***REMOVED***:
        # test odd lengths
        x = [1, 2, 3***REMOVED***
        assert_equal(mlab.prctile(x, 50***REMOVED***, np.median(x***REMOVED******REMOVED***

        # test even lengths
        x = [1, 2, 3, 4***REMOVED***
        assert_equal(mlab.prctile(x, 50***REMOVED***, np.median(x***REMOVED******REMOVED***

        # derived from email sent by jason-sage to MPL-user on 20090914
        ob1 = [1, 1, 2, 2, 1, 2, 4, 3, 2, 2, 2, 3,
               4, 5, 6, 7, 8, 9, 7, 6, 4, 5, 5***REMOVED***
        p = [0, 75, 100***REMOVED***
        expected = [1, 5.5, 9***REMOVED***

        # test vectorized
        actual = mlab.prctile(ob1, p***REMOVED***
        assert_allclose(expected, actual***REMOVED***

        # test scalar
        for pi, expectedi in zip(p, expected***REMOVED***:
            actuali = mlab.prctile(ob1, pi***REMOVED***
            assert_allclose(expectedi, actuali***REMOVED***

    def test_norm(self***REMOVED***:
        np.random.seed(0***REMOVED***
        N = 1000
        x = np.random.standard_normal(N***REMOVED***
        targ = np.linalg.norm(x***REMOVED***
        res = mlab._norm(x***REMOVED***
        assert_almost_equal(targ, res***REMOVED***


class spacing_testcase(CleanupTestCase***REMOVED***:
    def test_logspace_tens(self***REMOVED***:
        xmin = .01
        xmax = 1000.
        N = 6
        res = mlab.logspace(xmin, xmax, N***REMOVED***
        targ = np.logspace(np.log10(xmin***REMOVED***, np.log10(xmax***REMOVED***, N***REMOVED***
        assert_allclose(targ, res***REMOVED***

    def test_logspace_primes(self***REMOVED***:
        xmin = .03
        xmax = 1313.
        N = 7
        res = mlab.logspace(xmin, xmax, N***REMOVED***
        targ = np.logspace(np.log10(xmin***REMOVED***, np.log10(xmax***REMOVED***, N***REMOVED***
        assert_allclose(targ, res***REMOVED***

    def test_logspace_none(self***REMOVED***:
        xmin = .03
        xmax = 1313.
        N = 0
        res = mlab.logspace(xmin, xmax, N***REMOVED***
        targ = np.logspace(np.log10(xmin***REMOVED***, np.log10(xmax***REMOVED***, N***REMOVED***
        assert_array_equal(targ, res***REMOVED***
        assert_equal(res.size, 0***REMOVED***

    def test_logspace_single(self***REMOVED***:
        xmin = .03
        xmax = 1313.
        N = 1
        res = mlab.logspace(xmin, xmax, N***REMOVED***
        targ = np.logspace(np.log10(xmin***REMOVED***, np.log10(xmax***REMOVED***, N***REMOVED***
        assert_array_equal(targ, res***REMOVED***
        assert_equal(res.size, 1***REMOVED***


class stride_testcase(CleanupTestCase***REMOVED***:
    def get_base(self, x***REMOVED***:
        y = x
        while y.base is not None:
            y = y.base
        return y

    def calc_window_target(self, x, NFFT, noverlap=0***REMOVED***:
        '''This is an adaptation of the original window extraction
        algorithm.  This is here to test to make sure the new implementation
        has the same result'''
        step = NFFT - noverlap
        ind = np.arange(0, len(x***REMOVED*** - NFFT + 1, step***REMOVED***
        n = len(ind***REMOVED***
        result = np.zeros((NFFT, n***REMOVED******REMOVED***

        # do the ffts of the slices
        for i in range(n***REMOVED***:
            result[:, i***REMOVED*** = x[ind[i***REMOVED***:ind[i***REMOVED***+NFFT***REMOVED***
        return result

    def test_stride_windows_2D_ValueError(self***REMOVED***:
        x = np.arange(10***REMOVED***[np.newaxis***REMOVED***
        assert_raises(ValueError, mlab.stride_windows, x, 5***REMOVED***

    def test_stride_windows_0D_ValueError(self***REMOVED***:
        x = np.array(0***REMOVED***
        assert_raises(ValueError, mlab.stride_windows, x, 5***REMOVED***

    def test_stride_windows_noverlap_gt_n_ValueError(self***REMOVED***:
        x = np.arange(10***REMOVED***
        assert_raises(ValueError, mlab.stride_windows, x, 2, 3***REMOVED***

    def test_stride_windows_noverlap_eq_n_ValueError(self***REMOVED***:
        x = np.arange(10***REMOVED***
        assert_raises(ValueError, mlab.stride_windows, x, 2, 2***REMOVED***

    def test_stride_windows_n_gt_lenx_ValueError(self***REMOVED***:
        x = np.arange(10***REMOVED***
        assert_raises(ValueError, mlab.stride_windows, x, 11***REMOVED***

    def test_stride_windows_n_lt_1_ValueError(self***REMOVED***:
        x = np.arange(10***REMOVED***
        assert_raises(ValueError, mlab.stride_windows, x, 0***REMOVED***

    def test_stride_repeat_2D_ValueError(self***REMOVED***:
        x = np.arange(10***REMOVED***[np.newaxis***REMOVED***
        assert_raises(ValueError, mlab.stride_repeat, x, 5***REMOVED***

    def test_stride_repeat_axis_lt_0_ValueError(self***REMOVED***:
        x = np.array(0***REMOVED***
        assert_raises(ValueError, mlab.stride_repeat, x, 5, axis=-1***REMOVED***

    def test_stride_repeat_axis_gt_1_ValueError(self***REMOVED***:
        x = np.array(0***REMOVED***
        assert_raises(ValueError, mlab.stride_repeat, x, 5, axis=2***REMOVED***

    def test_stride_repeat_n_lt_1_ValueError(self***REMOVED***:
        x = np.arange(10***REMOVED***
        assert_raises(ValueError, mlab.stride_repeat, x, 0***REMOVED***

    def test_stride_repeat_n1_axis0(self***REMOVED***:
        x = np.arange(10***REMOVED***
        y = mlab.stride_repeat(x, 1***REMOVED***
        assert_equal((1, ***REMOVED*** + x.shape, y.shape***REMOVED***
        assert_array_equal(x, y.flat***REMOVED***
        assert_true(self.get_base(y***REMOVED*** is x***REMOVED***

    def test_stride_repeat_n1_axis1(self***REMOVED***:
        x = np.arange(10***REMOVED***
        y = mlab.stride_repeat(x, 1, axis=1***REMOVED***
        assert_equal(x.shape + (1, ***REMOVED***, y.shape***REMOVED***
        assert_array_equal(x, y.flat***REMOVED***
        assert_true(self.get_base(y***REMOVED*** is x***REMOVED***

    def test_stride_repeat_n5_axis0(self***REMOVED***:
        x = np.arange(10***REMOVED***
        y = mlab.stride_repeat(x, 5***REMOVED***
        yr = np.repeat(x[np.newaxis***REMOVED***, 5, axis=0***REMOVED***
        assert_equal(yr.shape, y.shape***REMOVED***
        assert_array_equal(yr, y***REMOVED***
        assert_equal((5, ***REMOVED*** + x.shape, y.shape***REMOVED***
        assert_true(self.get_base(y***REMOVED*** is x***REMOVED***

    def test_stride_repeat_n5_axis1(self***REMOVED***:
        x = np.arange(10***REMOVED***
        y = mlab.stride_repeat(x, 5, axis=1***REMOVED***
        yr = np.repeat(x[np.newaxis***REMOVED***, 5, axis=0***REMOVED***.T
        assert_equal(yr.shape, y.shape***REMOVED***
        assert_array_equal(yr, y***REMOVED***
        assert_equal(x.shape + (5, ***REMOVED***, y.shape***REMOVED***
        assert_true(self.get_base(y***REMOVED*** is x***REMOVED***

    def test_stride_windows_n1_noverlap0_axis0(self***REMOVED***:
        x = np.arange(10***REMOVED***
        y = mlab.stride_windows(x, 1***REMOVED***
        yt = self.calc_window_target(x, 1***REMOVED***
        assert_equal(yt.shape, y.shape***REMOVED***
        assert_array_equal(yt, y***REMOVED***
        assert_equal((1, ***REMOVED*** + x.shape, y.shape***REMOVED***
        assert_true(self.get_base(y***REMOVED*** is x***REMOVED***

    def test_stride_windows_n1_noverlap0_axis1(self***REMOVED***:
        x = np.arange(10***REMOVED***
        y = mlab.stride_windows(x, 1, axis=1***REMOVED***
        yt = self.calc_window_target(x, 1***REMOVED***.T
        assert_equal(yt.shape, y.shape***REMOVED***
        assert_array_equal(yt, y***REMOVED***
        assert_equal(x.shape + (1, ***REMOVED***, y.shape***REMOVED***
        assert_true(self.get_base(y***REMOVED*** is x***REMOVED***

    def test_stride_windows_n5_noverlap0_axis0(self***REMOVED***:
        x = np.arange(100***REMOVED***
        y = mlab.stride_windows(x, 5***REMOVED***
        yt = self.calc_window_target(x, 5***REMOVED***
        assert_equal(yt.shape, y.shape***REMOVED***
        assert_array_equal(yt, y***REMOVED***
        assert_equal((5, 20***REMOVED***, y.shape***REMOVED***
        assert_true(self.get_base(y***REMOVED*** is x***REMOVED***

    def test_stride_windows_n5_noverlap0_axis1(self***REMOVED***:
        x = np.arange(100***REMOVED***
        y = mlab.stride_windows(x, 5, axis=1***REMOVED***
        yt = self.calc_window_target(x, 5***REMOVED***.T
        assert_equal(yt.shape, y.shape***REMOVED***
        assert_array_equal(yt, y***REMOVED***
        assert_equal((20, 5***REMOVED***, y.shape***REMOVED***
        assert_true(self.get_base(y***REMOVED*** is x***REMOVED***

    def test_stride_windows_n15_noverlap2_axis0(self***REMOVED***:
        x = np.arange(100***REMOVED***
        y = mlab.stride_windows(x, 15, 2***REMOVED***
        yt = self.calc_window_target(x, 15, 2***REMOVED***
        assert_equal(yt.shape, y.shape***REMOVED***
        assert_array_equal(yt, y***REMOVED***
        assert_equal((15, 7***REMOVED***, y.shape***REMOVED***
        assert_true(self.get_base(y***REMOVED*** is x***REMOVED***

    def test_stride_windows_n15_noverlap2_axis1(self***REMOVED***:
        x = np.arange(100***REMOVED***
        y = mlab.stride_windows(x, 15, 2, axis=1***REMOVED***
        yt = self.calc_window_target(x, 15, 2***REMOVED***.T
        assert_equal(yt.shape, y.shape***REMOVED***
        assert_array_equal(yt, y***REMOVED***
        assert_equal((7, 15***REMOVED***, y.shape***REMOVED***
        assert_true(self.get_base(y***REMOVED*** is x***REMOVED***

    def test_stride_windows_n13_noverlapn3_axis0(self***REMOVED***:
        x = np.arange(100***REMOVED***
        y = mlab.stride_windows(x, 13, -3***REMOVED***
        yt = self.calc_window_target(x, 13, -3***REMOVED***
        assert_equal(yt.shape, y.shape***REMOVED***
        assert_array_equal(yt, y***REMOVED***
        assert_equal((13, 6***REMOVED***, y.shape***REMOVED***
        assert_true(self.get_base(y***REMOVED*** is x***REMOVED***

    def test_stride_windows_n13_noverlapn3_axis1(self***REMOVED***:
        x = np.arange(100***REMOVED***
        y = mlab.stride_windows(x, 13, -3, axis=1***REMOVED***
        yt = self.calc_window_target(x, 13, -3***REMOVED***.T
        assert_equal(yt.shape, y.shape***REMOVED***
        assert_array_equal(yt, y***REMOVED***
        assert_equal((6, 13***REMOVED***, y.shape***REMOVED***
        assert_true(self.get_base(y***REMOVED*** is x***REMOVED***

    def test_stride_windows_n32_noverlap0_axis0_unflatten(self***REMOVED***:
        n = 32
        x = np.arange(n***REMOVED***[np.newaxis***REMOVED***
        x1 = np.tile(x, (21, 1***REMOVED******REMOVED***
        x2 = x1.flatten(***REMOVED***
        y = mlab.stride_windows(x2, n***REMOVED***
        assert_equal(y.shape, x1.T.shape***REMOVED***
        assert_array_equal(y, x1.T***REMOVED***

    def test_stride_windows_n32_noverlap0_axis1_unflatten(self***REMOVED***:
        n = 32
        x = np.arange(n***REMOVED***[np.newaxis***REMOVED***
        x1 = np.tile(x, (21, 1***REMOVED******REMOVED***
        x2 = x1.flatten(***REMOVED***
        y = mlab.stride_windows(x2, n, axis=1***REMOVED***
        assert_equal(y.shape, x1.shape***REMOVED***
        assert_array_equal(y, x1***REMOVED***

    def test_stride_ensure_integer_type(self***REMOVED***:
        N = 100
        x = np.empty(N + 20, dtype='>f4'***REMOVED***
        x.fill(np.NaN***REMOVED***
        y = x[10:-10***REMOVED***
        y.fill(0.3***REMOVED***
        # previous to #3845 lead to corrupt access
        y_strided = mlab.stride_windows(y, n=33, noverlap=0.6***REMOVED***
        assert_array_equal(y_strided, 0.3***REMOVED***
        # previous to #3845 lead to corrupt access
        y_strided = mlab.stride_windows(y, n=33.3, noverlap=0***REMOVED***
        assert_array_equal(y_strided, 0.3***REMOVED***
        # even previous to #3845 could not find any problematic
        # configuration however, let's be sure it's not accidentally
        # introduced
        y_strided = mlab.stride_repeat(y, n=33.815***REMOVED***
        assert_array_equal(y_strided, 0.3***REMOVED***


class csv_testcase(CleanupTestCase***REMOVED***:
    def setUp(self***REMOVED***:
        if six.PY3:
            self.fd = tempfile.TemporaryFile(suffix='csv', mode="w+",
                                             newline=''***REMOVED***
        else:
            self.fd = tempfile.TemporaryFile(suffix='csv', mode="wb+"***REMOVED***

    def tearDown(self***REMOVED***:
        self.fd.close(***REMOVED***

    def test_recarray_csv_roundtrip(self***REMOVED***:
        expected = np.recarray((99,***REMOVED***,
                               [(str('x'***REMOVED***, np.float***REMOVED***,
                                (str('y'***REMOVED***, np.float***REMOVED***,
                                (str('t'***REMOVED***, np.float***REMOVED******REMOVED******REMOVED***
        # initialising all values: uninitialised memory sometimes produces
        # floats that do not round-trip to string and back.
        expected['x'***REMOVED***[:***REMOVED*** = np.linspace(-1e9, -1, 99***REMOVED***
        expected['y'***REMOVED***[:***REMOVED*** = np.linspace(1, 1e9, 99***REMOVED***
        expected['t'***REMOVED***[:***REMOVED*** = np.linspace(0, 0.01, 99***REMOVED***

        mlab.rec2csv(expected, self.fd***REMOVED***
        self.fd.seek(0***REMOVED***
        actual = mlab.csv2rec(self.fd***REMOVED***

        assert_allclose(expected['x'***REMOVED***, actual['x'***REMOVED******REMOVED***
        assert_allclose(expected['y'***REMOVED***, actual['y'***REMOVED******REMOVED***
        assert_allclose(expected['t'***REMOVED***, actual['t'***REMOVED******REMOVED***

    def test_rec2csv_bad_shape_ValueError(self***REMOVED***:
        bad = np.recarray((99, 4***REMOVED***, [(str('x'***REMOVED***, np.float***REMOVED***,
                                    (str('y'***REMOVED***, np.float***REMOVED******REMOVED******REMOVED***

        # the bad recarray should trigger a ValueError for having ndim > 1.
        assert_raises(ValueError, mlab.rec2csv, bad, self.fd***REMOVED***

    def test_csv2rec_names_with_comments(self***REMOVED***:
        self.fd.write('# comment\n1,2,3\n4,5,6\n'***REMOVED***
        self.fd.seek(0***REMOVED***
        array = mlab.csv2rec(self.fd, names='a,b,c'***REMOVED***
        assert len(array***REMOVED*** == 2
        assert len(array.dtype***REMOVED*** == 3

    def test_csv2rec_usdate(self***REMOVED***:
        self.fd.write('01/11/14\n' +
                '03/05/76 12:00:01 AM\n' +
                '07/09/83 5:17:34 PM\n' +
                '06/20/2054 2:31:45 PM\n' +
                '10/31/00 11:50:23 AM\n'***REMOVED***
        expected = [datetime.datetime(2014, 1, 11, 0, 0***REMOVED***,
                datetime.datetime(1976, 3, 5, 0, 0, 1***REMOVED***,
                datetime.datetime(1983, 7, 9, 17, 17, 34***REMOVED***,
                datetime.datetime(2054, 6, 20, 14, 31, 45***REMOVED***,
                datetime.datetime(2000, 10, 31, 11, 50, 23***REMOVED******REMOVED***
        self.fd.seek(0***REMOVED***
        array = mlab.csv2rec(self.fd, names='a'***REMOVED***
        assert_array_equal(array['a'***REMOVED***.tolist(***REMOVED***, expected***REMOVED***

    def test_csv2rec_dayfirst(self***REMOVED***:
        self.fd.write('11/01/14\n' +
                '05/03/76 12:00:01 AM\n' +
                '09/07/83 5:17:34 PM\n' +
                '20/06/2054 2:31:45 PM\n' +
                '31/10/00 11:50:23 AM\n'***REMOVED***
        expected = [datetime.datetime(2014, 1, 11, 0, 0***REMOVED***,
                datetime.datetime(1976, 3, 5, 0, 0, 1***REMOVED***,
                datetime.datetime(1983, 7, 9, 17, 17, 34***REMOVED***,
                datetime.datetime(2054, 6, 20, 14, 31, 45***REMOVED***,
                datetime.datetime(2000, 10, 31, 11, 50, 23***REMOVED******REMOVED***
        self.fd.seek(0***REMOVED***
        array = mlab.csv2rec(self.fd, names='a', dayfirst=True***REMOVED***
        assert_array_equal(array['a'***REMOVED***.tolist(***REMOVED***, expected***REMOVED***

    def test_csv2rec_yearfirst(self***REMOVED***:
        self.fd.write('14/01/11\n' +
                '76/03/05 12:00:01 AM\n' +
                '83/07/09 5:17:34 PM\n' +
                '2054/06/20 2:31:45 PM\n' +
                '00/10/31 11:50:23 AM\n'***REMOVED***
        expected = [datetime.datetime(2014, 1, 11, 0, 0***REMOVED***,
                datetime.datetime(1976, 3, 5, 0, 0, 1***REMOVED***,
                datetime.datetime(1983, 7, 9, 17, 17, 34***REMOVED***,
                datetime.datetime(2054, 6, 20, 14, 31, 45***REMOVED***,
                datetime.datetime(2000, 10, 31, 11, 50, 23***REMOVED******REMOVED***
        self.fd.seek(0***REMOVED***
        array = mlab.csv2rec(self.fd, names='a', yearfirst=True***REMOVED***
        assert_array_equal(array['a'***REMOVED***.tolist(***REMOVED***, expected***REMOVED***


class rec2txt_testcase(CleanupTestCase***REMOVED***:
    def test_csv2txt_basic(self***REMOVED***:
        # str(***REMOVED*** calls around field names necessary b/c as of numpy 1.11
        # dtype doesn't like unicode names (caused by unicode_literals import***REMOVED***
        a = np.array([(1.0, 2, 'foo', 'bing'***REMOVED***,
                      (2.0, 3, 'bar', 'blah'***REMOVED******REMOVED***,
                     dtype=np.dtype([(str('x'***REMOVED***, np.float32***REMOVED***,
                                     (str('y'***REMOVED***, np.int8***REMOVED***,
                                     (str('s'***REMOVED***, str, 3***REMOVED***,
                                     (str('s2'***REMOVED***, str, 4***REMOVED******REMOVED******REMOVED******REMOVED***
        truth = ('       x   y   s     s2\n'
                 '   1.000   2   foo   bing   \n'
                 '   2.000   3   bar   blah   '***REMOVED***.splitlines(***REMOVED***
        assert_equal(mlab.rec2txt(a***REMOVED***.splitlines(***REMOVED***, truth***REMOVED***


class window_testcase(CleanupTestCase***REMOVED***:
    def setUp(self***REMOVED***:
        np.random.seed(0***REMOVED***
        self.n = 1000
        self.x = np.arange(0., self.n***REMOVED***

        self.sig_rand = np.random.standard_normal(self.n***REMOVED*** + 100.
        self.sig_ones = np.ones_like(self.x***REMOVED***
        self.sig_slope = np.linspace(-10., 90., self.n***REMOVED***

    def check_window_apply_repeat(self, x, window, NFFT, noverlap***REMOVED***:
        '''This is an adaptation of the original window application
        algorithm.  This is here to test to make sure the new implementation
        has the same result'''
        step = NFFT - noverlap
        ind = np.arange(0, len(x***REMOVED*** - NFFT + 1, step***REMOVED***
        n = len(ind***REMOVED***
        result = np.zeros((NFFT, n***REMOVED******REMOVED***

        if cbook.iterable(window***REMOVED***:
            windowVals = window
        else:
            windowVals = window(np.ones((NFFT,***REMOVED***, x.dtype***REMOVED******REMOVED***

        # do the ffts of the slices
        for i in range(n***REMOVED***:
            result[:, i***REMOVED*** = windowVals * x[ind[i***REMOVED***:ind[i***REMOVED***+NFFT***REMOVED***
        return result

    def test_window_none_rand(self***REMOVED***:
        res = mlab.window_none(self.sig_ones***REMOVED***
        assert_array_equal(res, self.sig_ones***REMOVED***

    def test_window_none_ones(self***REMOVED***:
        res = mlab.window_none(self.sig_rand***REMOVED***
        assert_array_equal(res, self.sig_rand***REMOVED***

    def test_window_hanning_rand(self***REMOVED***:
        targ = np.hanning(len(self.sig_rand***REMOVED******REMOVED*** * self.sig_rand
        res = mlab.window_hanning(self.sig_rand***REMOVED***

        assert_allclose(targ, res, atol=1e-06***REMOVED***

    def test_window_hanning_ones(self***REMOVED***:
        targ = np.hanning(len(self.sig_ones***REMOVED******REMOVED***
        res = mlab.window_hanning(self.sig_ones***REMOVED***

        assert_allclose(targ, res, atol=1e-06***REMOVED***

    def test_apply_window_1D_axis1_ValueError(self***REMOVED***:
        x = self.sig_rand
        window = mlab.window_hanning
        assert_raises(ValueError, mlab.apply_window, x, window, axis=1,
                      return_window=False***REMOVED***

    def test_apply_window_1D_els_wrongsize_ValueError(self***REMOVED***:
        x = self.sig_rand
        window = mlab.window_hanning(np.ones(x.shape[0***REMOVED***-1***REMOVED******REMOVED***
        assert_raises(ValueError, mlab.apply_window, x, window***REMOVED***

    def test_apply_window_0D_ValueError(self***REMOVED***:
        x = np.array(0***REMOVED***
        window = mlab.window_hanning
        assert_raises(ValueError, mlab.apply_window, x, window, axis=1,
                      return_window=False***REMOVED***

    def test_apply_window_3D_ValueError(self***REMOVED***:
        x = self.sig_rand[np.newaxis***REMOVED***[np.newaxis***REMOVED***
        window = mlab.window_hanning
        assert_raises(ValueError, mlab.apply_window, x, window, axis=1,
                      return_window=False***REMOVED***

    def test_apply_window_hanning_1D(self***REMOVED***:
        x = self.sig_rand
        window = mlab.window_hanning
        window1 = mlab.window_hanning(np.ones(x.shape[0***REMOVED******REMOVED******REMOVED***
        y, window2 = mlab.apply_window(x, window, return_window=True***REMOVED***
        yt = window(x***REMOVED***
        assert_equal(yt.shape, y.shape***REMOVED***
        assert_equal(x.shape, y.shape***REMOVED***
        assert_allclose(yt, y, atol=1e-06***REMOVED***
        assert_array_equal(window1, window2***REMOVED***

    def test_apply_window_hanning_1D_axis0(self***REMOVED***:
        x = self.sig_rand
        window = mlab.window_hanning
        y = mlab.apply_window(x, window, axis=0, return_window=False***REMOVED***
        yt = window(x***REMOVED***
        assert_equal(yt.shape, y.shape***REMOVED***
        assert_equal(x.shape, y.shape***REMOVED***
        assert_allclose(yt, y, atol=1e-06***REMOVED***

    def test_apply_window_hanning_els_1D_axis0(self***REMOVED***:
        x = self.sig_rand
        window = mlab.window_hanning(np.ones(x.shape[0***REMOVED******REMOVED******REMOVED***
        window1 = mlab.window_hanning
        y = mlab.apply_window(x, window, axis=0, return_window=False***REMOVED***
        yt = window1(x***REMOVED***
        assert_equal(yt.shape, y.shape***REMOVED***
        assert_equal(x.shape, y.shape***REMOVED***
        assert_allclose(yt, y, atol=1e-06***REMOVED***

    def test_apply_window_hanning_2D_axis0(self***REMOVED***:
        x = np.random.standard_normal([1000, 10***REMOVED******REMOVED*** + 100.
        window = mlab.window_hanning
        y = mlab.apply_window(x, window, axis=0, return_window=False***REMOVED***
        yt = np.zeros_like(x***REMOVED***
        for i in range(x.shape[1***REMOVED******REMOVED***:
            yt[:, i***REMOVED*** = window(x[:, i***REMOVED******REMOVED***
        assert_equal(yt.shape, y.shape***REMOVED***
        assert_equal(x.shape, y.shape***REMOVED***
        assert_allclose(yt, y, atol=1e-06***REMOVED***

    def test_apply_window_hanning_els1_2D_axis0(self***REMOVED***:
        x = np.random.standard_normal([1000, 10***REMOVED******REMOVED*** + 100.
        window = mlab.window_hanning(np.ones(x.shape[0***REMOVED******REMOVED******REMOVED***
        window1 = mlab.window_hanning
        y = mlab.apply_window(x, window, axis=0, return_window=False***REMOVED***
        yt = np.zeros_like(x***REMOVED***
        for i in range(x.shape[1***REMOVED******REMOVED***:
            yt[:, i***REMOVED*** = window1(x[:, i***REMOVED******REMOVED***
        assert_equal(yt.shape, y.shape***REMOVED***
        assert_equal(x.shape, y.shape***REMOVED***
        assert_allclose(yt, y, atol=1e-06***REMOVED***

    def test_apply_window_hanning_els2_2D_axis0(self***REMOVED***:
        x = np.random.standard_normal([1000, 10***REMOVED******REMOVED*** + 100.
        window = mlab.window_hanning
        window1 = mlab.window_hanning(np.ones(x.shape[0***REMOVED******REMOVED******REMOVED***
        y, window2 = mlab.apply_window(x, window, axis=0, return_window=True***REMOVED***
        yt = np.zeros_like(x***REMOVED***
        for i in range(x.shape[1***REMOVED******REMOVED***:
            yt[:, i***REMOVED*** = window1*x[:, i***REMOVED***
        assert_equal(yt.shape, y.shape***REMOVED***
        assert_equal(x.shape, y.shape***REMOVED***
        assert_allclose(yt, y, atol=1e-06***REMOVED***
        assert_array_equal(window1, window2***REMOVED***

    def test_apply_window_hanning_els3_2D_axis0(self***REMOVED***:
        x = np.random.standard_normal([1000, 10***REMOVED******REMOVED*** + 100.
        window = mlab.window_hanning
        window1 = mlab.window_hanning(np.ones(x.shape[0***REMOVED******REMOVED******REMOVED***
        y, window2 = mlab.apply_window(x, window, axis=0, return_window=True***REMOVED***
        yt = mlab.apply_window(x, window1, axis=0, return_window=False***REMOVED***
        assert_equal(yt.shape, y.shape***REMOVED***
        assert_equal(x.shape, y.shape***REMOVED***
        assert_allclose(yt, y, atol=1e-06***REMOVED***
        assert_array_equal(window1, window2***REMOVED***

    def test_apply_window_hanning_2D_axis1(self***REMOVED***:
        x = np.random.standard_normal([10, 1000***REMOVED******REMOVED*** + 100.
        window = mlab.window_hanning
        y = mlab.apply_window(x, window, axis=1, return_window=False***REMOVED***
        yt = np.zeros_like(x***REMOVED***
        for i in range(x.shape[0***REMOVED******REMOVED***:
            yt[i, :***REMOVED*** = window(x[i, :***REMOVED******REMOVED***
        assert_equal(yt.shape, y.shape***REMOVED***
        assert_equal(x.shape, y.shape***REMOVED***
        assert_allclose(yt, y, atol=1e-06***REMOVED***

    def test_apply_window_hanning_2D__els1_axis1(self***REMOVED***:
        x = np.random.standard_normal([10, 1000***REMOVED******REMOVED*** + 100.
        window = mlab.window_hanning(np.ones(x.shape[1***REMOVED******REMOVED******REMOVED***
        window1 = mlab.window_hanning
        y = mlab.apply_window(x, window, axis=1, return_window=False***REMOVED***
        yt = np.zeros_like(x***REMOVED***
        for i in range(x.shape[0***REMOVED******REMOVED***:
            yt[i, :***REMOVED*** = window1(x[i, :***REMOVED******REMOVED***
        assert_equal(yt.shape, y.shape***REMOVED***
        assert_equal(x.shape, y.shape***REMOVED***
        assert_allclose(yt, y, atol=1e-06***REMOVED***

    def test_apply_window_hanning_2D_els2_axis1(self***REMOVED***:
        x = np.random.standard_normal([10, 1000***REMOVED******REMOVED*** + 100.
        window = mlab.window_hanning
        window1 = mlab.window_hanning(np.ones(x.shape[1***REMOVED******REMOVED******REMOVED***
        y, window2 = mlab.apply_window(x, window, axis=1, return_window=True***REMOVED***
        yt = np.zeros_like(x***REMOVED***
        for i in range(x.shape[0***REMOVED******REMOVED***:
            yt[i, :***REMOVED*** = window1 * x[i, :***REMOVED***
        assert_equal(yt.shape, y.shape***REMOVED***
        assert_equal(x.shape, y.shape***REMOVED***
        assert_allclose(yt, y, atol=1e-06***REMOVED***
        assert_array_equal(window1, window2***REMOVED***

    def test_apply_window_hanning_2D_els3_axis1(self***REMOVED***:
        x = np.random.standard_normal([10, 1000***REMOVED******REMOVED*** + 100.
        window = mlab.window_hanning
        window1 = mlab.window_hanning(np.ones(x.shape[1***REMOVED******REMOVED******REMOVED***
        y = mlab.apply_window(x, window, axis=1, return_window=False***REMOVED***
        yt = mlab.apply_window(x, window1, axis=1, return_window=False***REMOVED***
        assert_equal(yt.shape, y.shape***REMOVED***
        assert_equal(x.shape, y.shape***REMOVED***
        assert_allclose(yt, y, atol=1e-06***REMOVED***

    def test_apply_window_stride_windows_hanning_2D_n13_noverlapn3_axis0(self***REMOVED***:
        x = self.sig_rand
        window = mlab.window_hanning
        yi = mlab.stride_windows(x, n=13, noverlap=2, axis=0***REMOVED***
        y = mlab.apply_window(yi, window, axis=0, return_window=False***REMOVED***
        yt = self.check_window_apply_repeat(x, window, 13, 2***REMOVED***
        assert_equal(yt.shape, y.shape***REMOVED***
        assert_not_equal(x.shape, y.shape***REMOVED***
        assert_allclose(yt, y, atol=1e-06***REMOVED***

    def test_apply_window_hanning_2D_stack_axis1(self***REMOVED***:
        ydata = np.arange(32***REMOVED***
        ydata1 = ydata+5
        ydata2 = ydata+3.3
        ycontrol1 = mlab.apply_window(ydata1, mlab.window_hanning***REMOVED***
        ycontrol2 = mlab.window_hanning(ydata2***REMOVED***
        ydata = np.vstack([ydata1, ydata2***REMOVED******REMOVED***
        ycontrol = np.vstack([ycontrol1, ycontrol2***REMOVED******REMOVED***
        ydata = np.tile(ydata, (20, 1***REMOVED******REMOVED***
        ycontrol = np.tile(ycontrol, (20, 1***REMOVED******REMOVED***
        result = mlab.apply_window(ydata, mlab.window_hanning, axis=1,
                                   return_window=False***REMOVED***
        assert_allclose(ycontrol, result, atol=1e-08***REMOVED***

    def test_apply_window_hanning_2D_stack_windows_axis1(self***REMOVED***:
        ydata = np.arange(32***REMOVED***
        ydata1 = ydata+5
        ydata2 = ydata+3.3
        ycontrol1 = mlab.apply_window(ydata1, mlab.window_hanning***REMOVED***
        ycontrol2 = mlab.window_hanning(ydata2***REMOVED***
        ydata = np.vstack([ydata1, ydata2***REMOVED******REMOVED***
        ycontrol = np.vstack([ycontrol1, ycontrol2***REMOVED******REMOVED***
        ydata = np.tile(ydata, (20, 1***REMOVED******REMOVED***
        ycontrol = np.tile(ycontrol, (20, 1***REMOVED******REMOVED***
        result = mlab.apply_window(ydata, mlab.window_hanning, axis=1,
                                   return_window=False***REMOVED***
        assert_allclose(ycontrol, result, atol=1e-08***REMOVED***

    def test_apply_window_hanning_2D_stack_windows_axis1_unflatten(self***REMOVED***:
        n = 32
        ydata = np.arange(n***REMOVED***
        ydata1 = ydata+5
        ydata2 = ydata+3.3
        ycontrol1 = mlab.apply_window(ydata1, mlab.window_hanning***REMOVED***
        ycontrol2 = mlab.window_hanning(ydata2***REMOVED***
        ydata = np.vstack([ydata1, ydata2***REMOVED******REMOVED***
        ycontrol = np.vstack([ycontrol1, ycontrol2***REMOVED******REMOVED***
        ydata = np.tile(ydata, (20, 1***REMOVED******REMOVED***
        ycontrol = np.tile(ycontrol, (20, 1***REMOVED******REMOVED***
        ydata = ydata.flatten(***REMOVED***
        ydata1 = mlab.stride_windows(ydata, 32, noverlap=0, axis=0***REMOVED***
        result = mlab.apply_window(ydata1, mlab.window_hanning, axis=0,
                                   return_window=False***REMOVED***
        assert_allclose(ycontrol.T, result, atol=1e-08***REMOVED***


class detrend_testcase(CleanupTestCase***REMOVED***:
    def setUp(self***REMOVED***:
        np.random.seed(0***REMOVED***
        n = 1000
        x = np.linspace(0., 100, n***REMOVED***

        self.sig_zeros = np.zeros(n***REMOVED***

        self.sig_off = self.sig_zeros + 100.
        self.sig_slope = np.linspace(-10., 90., n***REMOVED***

        self.sig_slope_mean = x - x.mean(***REMOVED***

        sig_rand = np.random.standard_normal(n***REMOVED***
        sig_sin = np.sin(x*2*np.pi/(n/100***REMOVED******REMOVED***

        sig_rand -= sig_rand.mean(***REMOVED***
        sig_sin -= sig_sin.mean(***REMOVED***

        self.sig_base = sig_rand + sig_sin

        self.atol = 1e-08

    def test_detrend_none_0D_zeros(self***REMOVED***:
        input = 0.
        targ = input
        res = mlab.detrend_none(input***REMOVED***
        assert_equal(input, targ***REMOVED***

    def test_detrend_none_0D_zeros_axis1(self***REMOVED***:
        input = 0.
        targ = input
        res = mlab.detrend_none(input, axis=1***REMOVED***
        assert_equal(input, targ***REMOVED***

    def test_detrend_str_none_0D_zeros(self***REMOVED***:
        input = 0.
        targ = input
        res = mlab.detrend(input, key='none'***REMOVED***
        assert_equal(input, targ***REMOVED***

    def test_detrend_detrend_none_0D_zeros(self***REMOVED***:
        input = 0.
        targ = input
        res = mlab.detrend(input, key=mlab.detrend_none***REMOVED***
        assert_equal(input, targ***REMOVED***

    def test_detrend_none_0D_off(self***REMOVED***:
        input = 5.5
        targ = input
        res = mlab.detrend_none(input***REMOVED***
        assert_equal(input, targ***REMOVED***

    def test_detrend_none_1D_off(self***REMOVED***:
        input = self.sig_off
        targ = input
        res = mlab.detrend_none(input***REMOVED***
        assert_array_equal(res, targ***REMOVED***

    def test_detrend_none_1D_slope(self***REMOVED***:
        input = self.sig_slope
        targ = input
        res = mlab.detrend_none(input***REMOVED***
        assert_array_equal(res, targ***REMOVED***

    def test_detrend_none_1D_base(self***REMOVED***:
        input = self.sig_base
        targ = input
        res = mlab.detrend_none(input***REMOVED***
        assert_array_equal(res, targ***REMOVED***

    def test_detrend_none_1D_base_slope_off_list(self***REMOVED***:
        input = self.sig_base + self.sig_slope + self.sig_off
        targ = input.tolist(***REMOVED***
        res = mlab.detrend_none(input.tolist(***REMOVED******REMOVED***
        assert_equal(res, targ***REMOVED***

    def test_detrend_none_2D(self***REMOVED***:
        arri = [self.sig_base,
                self.sig_base + self.sig_off,
                self.sig_base + self.sig_slope,
                self.sig_base + self.sig_off + self.sig_slope***REMOVED***
        input = np.vstack(arri***REMOVED***
        targ = input
        res = mlab.detrend_none(input***REMOVED***
        assert_array_equal(res, targ***REMOVED***

    def test_detrend_none_2D_T(self***REMOVED***:
        arri = [self.sig_base,
                self.sig_base + self.sig_off,
                self.sig_base + self.sig_slope,
                self.sig_base + self.sig_off + self.sig_slope***REMOVED***
        input = np.vstack(arri***REMOVED***
        targ = input
        res = mlab.detrend_none(input.T***REMOVED***
        assert_array_equal(res.T, targ***REMOVED***

    def test_detrend_mean_0D_zeros(self***REMOVED***:
        input = 0.
        targ = 0.
        res = mlab.detrend_mean(input***REMOVED***
        assert_almost_equal(res, targ***REMOVED***

    def test_detrend_str_mean_0D_zeros(self***REMOVED***:
        input = 0.
        targ = 0.
        res = mlab.detrend(input, key='mean'***REMOVED***
        assert_almost_equal(res, targ***REMOVED***

    def test_detrend_detrend_mean_0D_zeros(self***REMOVED***:
        input = 0.
        targ = 0.
        res = mlab.detrend(input, key=mlab.detrend_mean***REMOVED***
        assert_almost_equal(res, targ***REMOVED***

    def test_detrend_mean_0D_off(self***REMOVED***:
        input = 5.5
        targ = 0.
        res = mlab.detrend_mean(input***REMOVED***
        assert_almost_equal(res, targ***REMOVED***

    def test_detrend_str_mean_0D_off(self***REMOVED***:
        input = 5.5
        targ = 0.
        res = mlab.detrend(input, key='mean'***REMOVED***
        assert_almost_equal(res, targ***REMOVED***

    def test_detrend_detrend_mean_0D_off(self***REMOVED***:
        input = 5.5
        targ = 0.
        res = mlab.detrend(input, key=mlab.detrend_mean***REMOVED***
        assert_almost_equal(res, targ***REMOVED***

    def test_detrend_mean_1D_zeros(self***REMOVED***:
        input = self.sig_zeros
        targ = self.sig_zeros
        res = mlab.detrend_mean(input***REMOVED***
        assert_allclose(res, targ, atol=self.atol***REMOVED***

    def test_detrend_mean_1D_base(self***REMOVED***:
        input = self.sig_base
        targ = self.sig_base
        res = mlab.detrend_mean(input***REMOVED***
        assert_allclose(res, targ, atol=self.atol***REMOVED***

    def test_detrend_mean_1D_base_off(self***REMOVED***:
        input = self.sig_base + self.sig_off
        targ = self.sig_base
        res = mlab.detrend_mean(input***REMOVED***
        assert_allclose(res, targ, atol=self.atol***REMOVED***

    def test_detrend_mean_1D_base_slope(self***REMOVED***:
        input = self.sig_base + self.sig_slope
        targ = self.sig_base + self.sig_slope_mean
        res = mlab.detrend_mean(input***REMOVED***
        assert_allclose(res, targ, atol=self.atol***REMOVED***

    def test_detrend_mean_1D_base_slope_off(self***REMOVED***:
        input = self.sig_base + self.sig_slope + self.sig_off
        targ = self.sig_base + self.sig_slope_mean
        res = mlab.detrend_mean(input***REMOVED***
        assert_allclose(res, targ, atol=1e-08***REMOVED***

    def test_detrend_mean_1D_base_slope_off_axis0(self***REMOVED***:
        input = self.sig_base + self.sig_slope + self.sig_off
        targ = self.sig_base + self.sig_slope_mean
        res = mlab.detrend_mean(input, axis=0***REMOVED***
        assert_allclose(res, targ, atol=1e-08***REMOVED***

    def test_detrend_mean_1D_base_slope_off_list(self***REMOVED***:
        input = self.sig_base + self.sig_slope + self.sig_off
        targ = self.sig_base + self.sig_slope_mean
        res = mlab.detrend_mean(input.tolist(***REMOVED******REMOVED***
        assert_allclose(res, targ, atol=1e-08***REMOVED***

    def test_detrend_mean_1D_base_slope_off_list_axis0(self***REMOVED***:
        input = self.sig_base + self.sig_slope + self.sig_off
        targ = self.sig_base + self.sig_slope_mean
        res = mlab.detrend_mean(input.tolist(***REMOVED***, axis=0***REMOVED***
        assert_allclose(res, targ, atol=1e-08***REMOVED***

    def test_demean_0D_off(self***REMOVED***:
        input = 5.5
        targ = 0.
        res = mlab.demean(input, axis=None***REMOVED***
        assert_almost_equal(res, targ***REMOVED***

    def test_demean_1D_base_slope_off(self***REMOVED***:
        input = self.sig_base + self.sig_slope + self.sig_off
        targ = self.sig_base + self.sig_slope_mean
        res = mlab.demean(input***REMOVED***
        assert_allclose(res, targ, atol=1e-08***REMOVED***

    def test_demean_1D_base_slope_off_axis0(self***REMOVED***:
        input = self.sig_base + self.sig_slope + self.sig_off
        targ = self.sig_base + self.sig_slope_mean
        res = mlab.demean(input, axis=0***REMOVED***
        assert_allclose(res, targ, atol=1e-08***REMOVED***

    def test_demean_1D_base_slope_off_list(self***REMOVED***:
        input = self.sig_base + self.sig_slope + self.sig_off
        targ = self.sig_base + self.sig_slope_mean
        res = mlab.demean(input.tolist(***REMOVED******REMOVED***
        assert_allclose(res, targ, atol=1e-08***REMOVED***

    def test_detrend_mean_2D_default(self***REMOVED***:
        arri = [self.sig_off,
                self.sig_base + self.sig_off***REMOVED***
        arrt = [self.sig_zeros,
                self.sig_base***REMOVED***
        input = np.vstack(arri***REMOVED***
        targ = np.vstack(arrt***REMOVED***
        res = mlab.detrend_mean(input***REMOVED***
        assert_allclose(res, targ, atol=1e-08***REMOVED***

    def test_detrend_mean_2D_none(self***REMOVED***:
        arri = [self.sig_off,
                self.sig_base + self.sig_off***REMOVED***
        arrt = [self.sig_zeros,
                self.sig_base***REMOVED***
        input = np.vstack(arri***REMOVED***
        targ = np.vstack(arrt***REMOVED***
        res = mlab.detrend_mean(input, axis=None***REMOVED***
        assert_allclose(res, targ,
                        atol=1e-08***REMOVED***

    def test_detrend_mean_2D_none_T(self***REMOVED***:
        arri = [self.sig_off,
                self.sig_base + self.sig_off***REMOVED***
        arrt = [self.sig_zeros,
                self.sig_base***REMOVED***
        input = np.vstack(arri***REMOVED***.T
        targ = np.vstack(arrt***REMOVED***
        res = mlab.detrend_mean(input, axis=None***REMOVED***
        assert_allclose(res.T, targ,
                        atol=1e-08***REMOVED***

    def test_detrend_mean_2D_axis0(self***REMOVED***:
        arri = [self.sig_base,
                self.sig_base + self.sig_off,
                self.sig_base + self.sig_slope,
                self.sig_base + self.sig_off + self.sig_slope***REMOVED***
        arrt = [self.sig_base,
                self.sig_base,
                self.sig_base + self.sig_slope_mean,
                self.sig_base + self.sig_slope_mean***REMOVED***
        input = np.vstack(arri***REMOVED***.T
        targ = np.vstack(arrt***REMOVED***.T
        res = mlab.detrend_mean(input, axis=0***REMOVED***
        assert_allclose(res, targ,
                        atol=1e-08***REMOVED***

    def test_detrend_mean_2D_axis1(self***REMOVED***:
        arri = [self.sig_base,
                self.sig_base + self.sig_off,
                self.sig_base + self.sig_slope,
                self.sig_base + self.sig_off + self.sig_slope***REMOVED***
        arrt = [self.sig_base,
                self.sig_base,
                self.sig_base + self.sig_slope_mean,
                self.sig_base + self.sig_slope_mean***REMOVED***
        input = np.vstack(arri***REMOVED***
        targ = np.vstack(arrt***REMOVED***
        res = mlab.detrend_mean(input, axis=1***REMOVED***
        assert_allclose(res, targ,
                        atol=1e-08***REMOVED***

    def test_detrend_mean_2D_axism1(self***REMOVED***:
        arri = [self.sig_base,
                self.sig_base + self.sig_off,
                self.sig_base + self.sig_slope,
                self.sig_base + self.sig_off + self.sig_slope***REMOVED***
        arrt = [self.sig_base,
                self.sig_base,
                self.sig_base + self.sig_slope_mean,
                self.sig_base + self.sig_slope_mean***REMOVED***
        input = np.vstack(arri***REMOVED***
        targ = np.vstack(arrt***REMOVED***
        res = mlab.detrend_mean(input, axis=-1***REMOVED***
        assert_allclose(res, targ,
                        atol=1e-08***REMOVED***

    def test_detrend_mean_2D_none(self***REMOVED***:
        arri = [self.sig_off,
                self.sig_base + self.sig_off***REMOVED***
        arrt = [self.sig_zeros,
                self.sig_base***REMOVED***
        input = np.vstack(arri***REMOVED***
        targ = np.vstack(arrt***REMOVED***
        res = mlab.detrend_mean(input, axis=None***REMOVED***
        assert_allclose(res, targ,
                        atol=1e-08***REMOVED***

    def test_detrend_mean_2D_none_T(self***REMOVED***:
        arri = [self.sig_off,
                self.sig_base + self.sig_off***REMOVED***
        arrt = [self.sig_zeros,
                self.sig_base***REMOVED***
        input = np.vstack(arri***REMOVED***.T
        targ = np.vstack(arrt***REMOVED***
        res = mlab.detrend_mean(input, axis=None***REMOVED***
        assert_allclose(res.T, targ,
                        atol=1e-08***REMOVED***

    def test_detrend_mean_2D_axis0(self***REMOVED***:
        arri = [self.sig_base,
                self.sig_base + self.sig_off,
                self.sig_base + self.sig_slope,
                self.sig_base + self.sig_off + self.sig_slope***REMOVED***
        arrt = [self.sig_base,
                self.sig_base,
                self.sig_base + self.sig_slope_mean,
                self.sig_base + self.sig_slope_mean***REMOVED***
        input = np.vstack(arri***REMOVED***.T
        targ = np.vstack(arrt***REMOVED***.T
        res = mlab.detrend_mean(input, axis=0***REMOVED***
        assert_allclose(res, targ,
                        atol=1e-08***REMOVED***

    def test_detrend_mean_2D_axis1(self***REMOVED***:
        arri = [self.sig_base,
                self.sig_base + self.sig_off,
                self.sig_base + self.sig_slope,
                self.sig_base + self.sig_off + self.sig_slope***REMOVED***
        arrt = [self.sig_base,
                self.sig_base,
                self.sig_base + self.sig_slope_mean,
                self.sig_base + self.sig_slope_mean***REMOVED***
        input = np.vstack(arri***REMOVED***
        targ = np.vstack(arrt***REMOVED***
        res = mlab.detrend_mean(input, axis=1***REMOVED***
        assert_allclose(res, targ,
                        atol=1e-08***REMOVED***

    def test_detrend_mean_2D_axism1(self***REMOVED***:
        arri = [self.sig_base,
                self.sig_base + self.sig_off,
                self.sig_base + self.sig_slope,
                self.sig_base + self.sig_off + self.sig_slope***REMOVED***
        arrt = [self.sig_base,
                self.sig_base,
                self.sig_base + self.sig_slope_mean,
                self.sig_base + self.sig_slope_mean***REMOVED***
        input = np.vstack(arri***REMOVED***
        targ = np.vstack(arrt***REMOVED***
        res = mlab.detrend_mean(input, axis=-1***REMOVED***
        assert_allclose(res, targ,
                        atol=1e-08***REMOVED***

    def test_detrend_2D_default(self***REMOVED***:
        arri = [self.sig_off,
                self.sig_base + self.sig_off***REMOVED***
        arrt = [self.sig_zeros,
                self.sig_base***REMOVED***
        input = np.vstack(arri***REMOVED***
        targ = np.vstack(arrt***REMOVED***
        res = mlab.detrend(input***REMOVED***
        assert_allclose(res, targ, atol=1e-08***REMOVED***

    def test_detrend_2D_none(self***REMOVED***:
        arri = [self.sig_off,
                self.sig_base + self.sig_off***REMOVED***
        arrt = [self.sig_zeros,
                self.sig_base***REMOVED***
        input = np.vstack(arri***REMOVED***
        targ = np.vstack(arrt***REMOVED***
        res = mlab.detrend(input, axis=None***REMOVED***
        assert_allclose(res, targ, atol=1e-08***REMOVED***

    def test_detrend_str_mean_2D_axis0(self***REMOVED***:
        arri = [self.sig_base,
                self.sig_base + self.sig_off,
                self.sig_base + self.sig_slope,
                self.sig_base + self.sig_off + self.sig_slope***REMOVED***
        arrt = [self.sig_base,
                self.sig_base,
                self.sig_base + self.sig_slope_mean,
                self.sig_base + self.sig_slope_mean***REMOVED***
        input = np.vstack(arri***REMOVED***.T
        targ = np.vstack(arrt***REMOVED***.T
        res = mlab.detrend(input, key='mean', axis=0***REMOVED***
        assert_allclose(res, targ,
                        atol=1e-08***REMOVED***

    def test_detrend_str_constant_2D_none_T(self***REMOVED***:
        arri = [self.sig_off,
                self.sig_base + self.sig_off***REMOVED***
        arrt = [self.sig_zeros,
                self.sig_base***REMOVED***
        input = np.vstack(arri***REMOVED***.T
        targ = np.vstack(arrt***REMOVED***
        res = mlab.detrend(input, key='constant', axis=None***REMOVED***
        assert_allclose(res.T, targ,
                        atol=1e-08***REMOVED***

    def test_detrend_str_default_2D_axis1(self***REMOVED***:
        arri = [self.sig_base,
                self.sig_base + self.sig_off,
                self.sig_base + self.sig_slope,
                self.sig_base + self.sig_off + self.sig_slope***REMOVED***
        arrt = [self.sig_base,
                self.sig_base,
                self.sig_base + self.sig_slope_mean,
                self.sig_base + self.sig_slope_mean***REMOVED***
        input = np.vstack(arri***REMOVED***
        targ = np.vstack(arrt***REMOVED***
        res = mlab.detrend(input, key='default', axis=1***REMOVED***
        assert_allclose(res, targ,
                        atol=1e-08***REMOVED***

    def test_detrend_detrend_mean_2D_axis0(self***REMOVED***:
        arri = [self.sig_base,
                self.sig_base + self.sig_off,
                self.sig_base + self.sig_slope,
                self.sig_base + self.sig_off + self.sig_slope***REMOVED***
        arrt = [self.sig_base,
                self.sig_base,
                self.sig_base + self.sig_slope_mean,
                self.sig_base + self.sig_slope_mean***REMOVED***
        input = np.vstack(arri***REMOVED***.T
        targ = np.vstack(arrt***REMOVED***.T
        res = mlab.detrend(input, key=mlab.detrend_mean, axis=0***REMOVED***
        assert_allclose(res, targ,
                        atol=1e-08***REMOVED***

    def test_demean_2D_default(self***REMOVED***:
        arri = [self.sig_base,
                self.sig_base + self.sig_off,
                self.sig_base + self.sig_slope,
                self.sig_base + self.sig_off + self.sig_slope***REMOVED***
        arrt = [self.sig_base,
                self.sig_base,
                self.sig_base + self.sig_slope_mean,
                self.sig_base + self.sig_slope_mean***REMOVED***
        input = np.vstack(arri***REMOVED***.T
        targ = np.vstack(arrt***REMOVED***.T
        res = mlab.demean(input***REMOVED***
        assert_allclose(res, targ,
                        atol=1e-08***REMOVED***

    def test_demean_2D_none(self***REMOVED***:
        arri = [self.sig_off,
                self.sig_base + self.sig_off***REMOVED***
        arrt = [self.sig_zeros,
                self.sig_base***REMOVED***
        input = np.vstack(arri***REMOVED***
        targ = np.vstack(arrt***REMOVED***
        res = mlab.demean(input, axis=None***REMOVED***
        assert_allclose(res, targ,
                        atol=1e-08***REMOVED***

    def test_demean_2D_axis0(self***REMOVED***:
        arri = [self.sig_base,
                self.sig_base + self.sig_off,
                self.sig_base + self.sig_slope,
                self.sig_base + self.sig_off + self.sig_slope***REMOVED***
        arrt = [self.sig_base,
                self.sig_base,
                self.sig_base + self.sig_slope_mean,
                self.sig_base + self.sig_slope_mean***REMOVED***
        input = np.vstack(arri***REMOVED***.T
        targ = np.vstack(arrt***REMOVED***.T
        res = mlab.demean(input, axis=0***REMOVED***
        assert_allclose(res, targ,
                        atol=1e-08***REMOVED***

    def test_demean_2D_axis1(self***REMOVED***:
        arri = [self.sig_base,
                self.sig_base + self.sig_off,
                self.sig_base + self.sig_slope,
                self.sig_base + self.sig_off + self.sig_slope***REMOVED***
        arrt = [self.sig_base,
                self.sig_base,
                self.sig_base + self.sig_slope_mean,
                self.sig_base + self.sig_slope_mean***REMOVED***
        input = np.vstack(arri***REMOVED***
        targ = np.vstack(arrt***REMOVED***
        res = mlab.demean(input, axis=1***REMOVED***
        assert_allclose(res, targ,
                        atol=1e-08***REMOVED***

    def test_demean_2D_axism1(self***REMOVED***:
        arri = [self.sig_base,
                self.sig_base + self.sig_off,
                self.sig_base + self.sig_slope,
                self.sig_base + self.sig_off + self.sig_slope***REMOVED***
        arrt = [self.sig_base,
                self.sig_base,
                self.sig_base + self.sig_slope_mean,
                self.sig_base + self.sig_slope_mean***REMOVED***
        input = np.vstack(arri***REMOVED***
        targ = np.vstack(arrt***REMOVED***
        res = mlab.demean(input, axis=-1***REMOVED***
        assert_allclose(res, targ,
                        atol=1e-08***REMOVED***

    def test_detrend_bad_key_str_ValueError(self***REMOVED***:
        input = self.sig_slope[np.newaxis***REMOVED***
        assert_raises(ValueError, mlab.detrend, input, key='spam'***REMOVED***

    def test_detrend_bad_key_var_ValueError(self***REMOVED***:
        input = self.sig_slope[np.newaxis***REMOVED***
        assert_raises(ValueError, mlab.detrend, input, key=5***REMOVED***

    def test_detrend_mean_0D_d0_ValueError(self***REMOVED***:
        input = 5.5
        assert_raises(ValueError, mlab.detrend_mean, input, axis=0***REMOVED***

    def test_detrend_0D_d0_ValueError(self***REMOVED***:
        input = 5.5
        assert_raises(ValueError, mlab.detrend, input, axis=0***REMOVED***

    def test_detrend_mean_1D_d1_ValueError(self***REMOVED***:
        input = self.sig_slope
        assert_raises(ValueError, mlab.detrend_mean, input, axis=1***REMOVED***

    def test_detrend_1D_d1_ValueError(self***REMOVED***:
        input = self.sig_slope
        assert_raises(ValueError, mlab.detrend, input, axis=1***REMOVED***

    def test_demean_1D_d1_ValueError(self***REMOVED***:
        input = self.sig_slope
        assert_raises(ValueError, mlab.demean, input, axis=1***REMOVED***

    def test_detrend_mean_2D_d2_ValueError(self***REMOVED***:
        input = self.sig_slope[np.newaxis***REMOVED***
        assert_raises(ValueError, mlab.detrend_mean, input, axis=2***REMOVED***

    def test_detrend_2D_d2_ValueError(self***REMOVED***:
        input = self.sig_slope[np.newaxis***REMOVED***
        assert_raises(ValueError, mlab.detrend, input, axis=2***REMOVED***

    def test_demean_2D_d2_ValueError(self***REMOVED***:
        input = self.sig_slope[np.newaxis***REMOVED***
        assert_raises(ValueError, mlab.demean, input, axis=2***REMOVED***

    def test_detrend_linear_0D_zeros(self***REMOVED***:
        input = 0.
        targ = 0.
        res = mlab.detrend_linear(input***REMOVED***
        assert_almost_equal(res, targ***REMOVED***

    def test_detrend_linear_0D_off(self***REMOVED***:
        input = 5.5
        targ = 0.
        res = mlab.detrend_linear(input***REMOVED***
        assert_almost_equal(res, targ***REMOVED***

    def test_detrend_str_linear_0D_off(self***REMOVED***:
        input = 5.5
        targ = 0.
        res = mlab.detrend(input, key='linear'***REMOVED***
        assert_almost_equal(res, targ***REMOVED***

    def test_detrend_detrend_linear_0D_off(self***REMOVED***:
        input = 5.5
        targ = 0.
        res = mlab.detrend(input, key=mlab.detrend_linear***REMOVED***
        assert_almost_equal(res, targ***REMOVED***

    def test_detrend_linear_1d_off(self***REMOVED***:
        input = self.sig_off
        targ = self.sig_zeros
        res = mlab.detrend_linear(input***REMOVED***
        assert_allclose(res, targ, atol=self.atol***REMOVED***

    def test_detrend_linear_1d_slope(self***REMOVED***:
        input = self.sig_slope
        targ = self.sig_zeros
        res = mlab.detrend_linear(input***REMOVED***
        assert_allclose(res, targ, atol=self.atol***REMOVED***

    def test_detrend_linear_1d_slope_off(self***REMOVED***:
        input = self.sig_slope + self.sig_off
        targ = self.sig_zeros
        res = mlab.detrend_linear(input***REMOVED***
        assert_allclose(res, targ, atol=self.atol***REMOVED***

    def test_detrend_str_linear_1d_slope_off(self***REMOVED***:
        input = self.sig_slope + self.sig_off
        targ = self.sig_zeros
        res = mlab.detrend(input, key='linear'***REMOVED***
        assert_allclose(res, targ, atol=self.atol***REMOVED***

    def test_detrend_detrend_linear_1d_slope_off(self***REMOVED***:
        input = self.sig_slope + self.sig_off
        targ = self.sig_zeros
        res = mlab.detrend(input, key=mlab.detrend_linear***REMOVED***
        assert_allclose(res, targ, atol=self.atol***REMOVED***

    def test_detrend_linear_1d_slope_off_list(self***REMOVED***:
        input = self.sig_slope + self.sig_off
        targ = self.sig_zeros
        res = mlab.detrend_linear(input.tolist(***REMOVED******REMOVED***
        assert_allclose(res, targ, atol=self.atol***REMOVED***

    def test_detrend_linear_2D_ValueError(self***REMOVED***:
        input = self.sig_slope[np.newaxis***REMOVED***
        assert_raises(ValueError, mlab.detrend_linear, input***REMOVED***

    def test_detrend_str_linear_2d_slope_off_axis0(self***REMOVED***:
        arri = [self.sig_off,
                self.sig_slope,
                self.sig_slope + self.sig_off***REMOVED***
        arrt = [self.sig_zeros,
                self.sig_zeros,
                self.sig_zeros***REMOVED***
        input = np.vstack(arri***REMOVED***.T
        targ = np.vstack(arrt***REMOVED***.T
        res = mlab.detrend(input, key='linear', axis=0***REMOVED***
        assert_allclose(res, targ, atol=self.atol***REMOVED***

    def test_detrend_detrend_linear_1d_slope_off_axis1(self***REMOVED***:
        arri = [self.sig_off,
                self.sig_slope,
                self.sig_slope + self.sig_off***REMOVED***
        arrt = [self.sig_zeros,
                self.sig_zeros,
                self.sig_zeros***REMOVED***
        input = np.vstack(arri***REMOVED***.T
        targ = np.vstack(arrt***REMOVED***.T
        res = mlab.detrend(input, key=mlab.detrend_linear, axis=0***REMOVED***
        assert_allclose(res, targ, atol=self.atol***REMOVED***

    def test_detrend_str_linear_2d_slope_off_axis0(self***REMOVED***:
        arri = [self.sig_off,
                self.sig_slope,
                self.sig_slope + self.sig_off***REMOVED***
        arrt = [self.sig_zeros,
                self.sig_zeros,
                self.sig_zeros***REMOVED***
        input = np.vstack(arri***REMOVED***
        targ = np.vstack(arrt***REMOVED***
        res = mlab.detrend(input, key='linear', axis=1***REMOVED***
        assert_allclose(res, targ, atol=self.atol***REMOVED***

    def test_detrend_detrend_linear_1d_slope_off_axis1(self***REMOVED***:
        arri = [self.sig_off,
                self.sig_slope,
                self.sig_slope + self.sig_off***REMOVED***
        arrt = [self.sig_zeros,
                self.sig_zeros,
                self.sig_zeros***REMOVED***
        input = np.vstack(arri***REMOVED***
        targ = np.vstack(arrt***REMOVED***
        res = mlab.detrend(input, key=mlab.detrend_linear, axis=1***REMOVED***
        assert_allclose(res, targ, atol=self.atol***REMOVED***


class spectral_testcase_nosig_real_onesided(CleanupTestCase***REMOVED***:
    def setUp(self***REMOVED***:
        self.createStim(fstims=[***REMOVED***,
                        iscomplex=False, sides='onesided', nsides=1***REMOVED***

    def createStim(self, fstims, iscomplex, sides, nsides, len_x=None,
                   NFFT_density=-1, nover_density=-1, pad_to_density=-1,
                   pad_to_spectrum=-1***REMOVED***:
        Fs = 100.

        x = np.arange(0, 10, 1/Fs***REMOVED***
        if len_x is not None:
            x = x[:len_x***REMOVED***

        # get the stimulus frequencies, defaulting to None
        fstims = [Fs/fstim for fstim in fstims***REMOVED***

        # get the constants, default to calculated values
        if NFFT_density is None:
            NFFT_density_real = 256
        elif NFFT_density < 0:
            NFFT_density_real = NFFT_density = 100
        else:
            NFFT_density_real = NFFT_density

        if nover_density is None:
            nover_density_real = 0
        elif nover_density < 0:
            nover_density_real = nover_density = NFFT_density_real//2
        else:
            nover_density_real = nover_density

        if pad_to_density is None:
            pad_to_density_real = NFFT_density_real
        elif pad_to_density < 0:
            pad_to_density = int(2**np.ceil(np.log2(NFFT_density_real***REMOVED******REMOVED******REMOVED***
            pad_to_density_real = pad_to_density
        else:
            pad_to_density_real = pad_to_density

        if pad_to_spectrum is None:
            pad_to_spectrum_real = len(x***REMOVED***
        elif pad_to_spectrum < 0:
            pad_to_spectrum_real = pad_to_spectrum = len(x***REMOVED***
        else:
            pad_to_spectrum_real = pad_to_spectrum

        if pad_to_spectrum is None:
            NFFT_spectrum_real = NFFT_spectrum = pad_to_spectrum_real
        else:
            NFFT_spectrum_real = NFFT_spectrum = len(x***REMOVED***
        nover_spectrum_real = nover_spectrum = 0

        NFFT_specgram = NFFT_density
        nover_specgram = nover_density
        pad_to_specgram = pad_to_density
        NFFT_specgram_real = NFFT_density_real
        nover_specgram_real = nover_density_real

        if nsides == 1:
            # frequencies for specgram, psd, and csd
            # need to handle even and odd differently
            if pad_to_density_real % 2:
                freqs_density = np.linspace(0, Fs/2,
                                            num=pad_to_density_real,
                                            endpoint=False***REMOVED***[::2***REMOVED***
            else:
                freqs_density = np.linspace(0, Fs/2,
                                            num=pad_to_density_real//2+1***REMOVED***

            # frequencies for complex, magnitude, angle, and phase spectrums
            # need to handle even and odd differently
            if pad_to_spectrum_real % 2:
                freqs_spectrum = np.linspace(0, Fs/2,
                                             num=pad_to_spectrum_real,
                                             endpoint=False***REMOVED***[::2***REMOVED***
            else:
                freqs_spectrum = np.linspace(0, Fs/2,
                                             num=pad_to_spectrum_real//2+1***REMOVED***
        else:
            # frequencies for specgram, psd, and csd
            # need to handle even and odd differentl
            if pad_to_density_real % 2:
                freqs_density = np.linspace(-Fs/2, Fs/2,
                                            num=2*pad_to_density_real,
                                            endpoint=False***REMOVED***[1::2***REMOVED***
            else:
                freqs_density = np.linspace(-Fs/2, Fs/2,
                                            num=pad_to_density_real,
                                            endpoint=False***REMOVED***

            # frequencies for complex, magnitude, angle, and phase spectrums
            # need to handle even and odd differently
            if pad_to_spectrum_real % 2:
                freqs_spectrum = np.linspace(-Fs/2, Fs/2,
                                             num=2*pad_to_spectrum_real,
                                             endpoint=False***REMOVED***[1::2***REMOVED***
            else:
                freqs_spectrum = np.linspace(-Fs/2, Fs/2,
                                             num=pad_to_spectrum_real,
                                             endpoint=False***REMOVED***

        freqs_specgram = freqs_density
        # time points for specgram
        t_start = NFFT_specgram_real//2
        t_stop = len(x***REMOVED*** - NFFT_specgram_real//2+1
        t_step = NFFT_specgram_real - nover_specgram_real
        t_specgram = x[t_start:t_stop:t_step***REMOVED***
        if NFFT_specgram_real % 2:
            t_specgram += 1/Fs/2
        if len(t_specgram***REMOVED*** == 0:
            t_specgram = np.array([NFFT_specgram_real/(2*Fs***REMOVED******REMOVED******REMOVED***
        t_spectrum = np.array([NFFT_spectrum_real/(2*Fs***REMOVED******REMOVED******REMOVED***
        t_density = t_specgram

        y = np.zeros_like(x***REMOVED***
        for i, fstim in enumerate(fstims***REMOVED***:
            y += np.sin(fstim * x * np.pi * 2***REMOVED*** * 10**i

        if iscomplex:
            y = y.astype('complex'***REMOVED***

        self.Fs = Fs
        self.sides = sides
        self.fstims = fstims

        self.NFFT_density = NFFT_density
        self.nover_density = nover_density
        self.pad_to_density = pad_to_density

        self.NFFT_spectrum = NFFT_spectrum
        self.nover_spectrum = nover_spectrum
        self.pad_to_spectrum = pad_to_spectrum

        self.NFFT_specgram = NFFT_specgram
        self.nover_specgram = nover_specgram
        self.pad_to_specgram = pad_to_specgram

        self.t_specgram = t_specgram
        self.t_density = t_density
        self.t_spectrum = t_spectrum
        self.y = y

        self.freqs_density = freqs_density
        self.freqs_spectrum = freqs_spectrum
        self.freqs_specgram = freqs_specgram

        self.NFFT_density_real = NFFT_density_real

    def check_freqs(self, vals, targfreqs, resfreqs, fstims***REMOVED***:
        assert_true(resfreqs.argmin(***REMOVED*** == 0***REMOVED***
        assert_true(resfreqs.argmax(***REMOVED*** == len(resfreqs***REMOVED***-1***REMOVED***
        assert_allclose(resfreqs, targfreqs, atol=1e-06***REMOVED***
        for fstim in fstims:
            i = np.abs(resfreqs - fstim***REMOVED***.argmin(***REMOVED***
            assert_true(vals[i***REMOVED*** > vals[i+2***REMOVED******REMOVED***
            assert_true(vals[i***REMOVED*** > vals[i-2***REMOVED******REMOVED***

    def check_maxfreq(self, spec, fsp, fstims***REMOVED***:
        # skip the test if there are no frequencies
        if len(fstims***REMOVED*** == 0:
            return

        # if twosided, do the test for each side
        if fsp.min(***REMOVED*** < 0:
            fspa = np.abs(fsp***REMOVED***
            zeroind = fspa.argmin(***REMOVED***
            self.check_maxfreq(spec[:zeroind***REMOVED***, fspa[:zeroind***REMOVED***, fstims***REMOVED***
            self.check_maxfreq(spec[zeroind:***REMOVED***, fspa[zeroind:***REMOVED***, fstims***REMOVED***
            return

        fstimst = fstims[:***REMOVED***
        spect = spec.copy(***REMOVED***

        # go through each peak and make sure it is correctly the maximum peak
        while fstimst:
            maxind = spect.argmax(***REMOVED***
            maxfreq = fsp[maxind***REMOVED***
            assert_almost_equal(maxfreq, fstimst[-1***REMOVED******REMOVED***
            del fstimst[-1***REMOVED***
            spect[maxind-5:maxind+5***REMOVED*** = 0

    def test_spectral_helper_raises_complex_same_data(self***REMOVED***:
        # test that mode 'complex' cannot be used if x is not y
        assert_raises(ValueError, mlab._spectral_helper,
                      x=self.y, y=self.y+1, mode='complex'***REMOVED***

    def test_spectral_helper_raises_magnitude_same_data(self***REMOVED***:
        # test that mode 'magnitude' cannot be used if x is not y
        assert_raises(ValueError, mlab._spectral_helper,
                      x=self.y, y=self.y+1, mode='magnitude'***REMOVED***

    def test_spectral_helper_raises_angle_same_data(self***REMOVED***:
        # test that mode 'angle' cannot be used if x is not y
        assert_raises(ValueError, mlab._spectral_helper,
                      x=self.y, y=self.y+1, mode='angle'***REMOVED***

    def test_spectral_helper_raises_phase_same_data(self***REMOVED***:
        # test that mode 'phase' cannot be used if x is not y
        assert_raises(ValueError, mlab._spectral_helper,
                      x=self.y, y=self.y+1, mode='phase'***REMOVED***

    def test_spectral_helper_raises_unknown_mode(self***REMOVED***:
        # test that unknown value for mode cannot be used
        assert_raises(ValueError, mlab._spectral_helper,
                      x=self.y, mode='spam'***REMOVED***

    def test_spectral_helper_raises_unknown_sides(self***REMOVED***:
        # test that unknown value for sides cannot be used
        assert_raises(ValueError, mlab._spectral_helper,
                      x=self.y, y=self.y, sides='eggs'***REMOVED***

    def test_spectral_helper_raises_noverlap_gt_NFFT(self***REMOVED***:
        # test that noverlap cannot be larger than NFFT
        assert_raises(ValueError, mlab._spectral_helper,
                      x=self.y, y=self.y, NFFT=10, noverlap=20***REMOVED***

    def test_spectral_helper_raises_noverlap_eq_NFFT(self***REMOVED***:
        # test that noverlap cannot be equal to NFFT
        assert_raises(ValueError, mlab._spectral_helper,
                      x=self.y, NFFT=10, noverlap=10***REMOVED***

    def test_spectral_helper_raises_winlen_ne_NFFT(self***REMOVED***:
        # test that the window length cannot be different from NFFT
        assert_raises(ValueError, mlab._spectral_helper,
                      x=self.y, y=self.y, NFFT=10, window=np.ones(9***REMOVED******REMOVED***

    def test_single_spectrum_helper_raises_mode_default(self***REMOVED***:
        # test that mode 'default' cannot be used with _single_spectrum_helper
        assert_raises(ValueError, mlab._single_spectrum_helper,
                      x=self.y, mode='default'***REMOVED***

    def test_single_spectrum_helper_raises_mode_psd(self***REMOVED***:
        # test that mode 'psd' cannot be used with _single_spectrum_helper
        assert_raises(ValueError, mlab._single_spectrum_helper,
                      x=self.y, mode='psd'***REMOVED***

    def test_spectral_helper_psd(self***REMOVED***:
        freqs = self.freqs_density
        spec, fsp, t = mlab._spectral_helper(x=self.y, y=self.y,
                                             NFFT=self.NFFT_density,
                                             Fs=self.Fs,
                                             noverlap=self.nover_density,
                                             pad_to=self.pad_to_density,
                                             sides=self.sides,
                                             mode='psd'***REMOVED***

        assert_allclose(fsp, freqs, atol=1e-06***REMOVED***
        assert_allclose(t, self.t_density, atol=1e-06***REMOVED***

        assert_equal(spec.shape[0***REMOVED***, freqs.shape[0***REMOVED******REMOVED***
        assert_equal(spec.shape[1***REMOVED***, self.t_specgram.shape[0***REMOVED******REMOVED***

    def test_spectral_helper_magnitude_specgram(self***REMOVED***:
        freqs = self.freqs_specgram
        spec, fsp, t = mlab._spectral_helper(x=self.y, y=self.y,
                                             NFFT=self.NFFT_specgram,
                                             Fs=self.Fs,
                                             noverlap=self.nover_specgram,
                                             pad_to=self.pad_to_specgram,
                                             sides=self.sides,
                                             mode='magnitude'***REMOVED***

        assert_allclose(fsp, freqs, atol=1e-06***REMOVED***
        assert_allclose(t, self.t_specgram, atol=1e-06***REMOVED***

        assert_equal(spec.shape[0***REMOVED***, freqs.shape[0***REMOVED******REMOVED***
        assert_equal(spec.shape[1***REMOVED***, self.t_specgram.shape[0***REMOVED******REMOVED***

    def test_spectral_helper_magnitude_magnitude_spectrum(self***REMOVED***:
        freqs = self.freqs_spectrum
        spec, fsp, t = mlab._spectral_helper(x=self.y, y=self.y,
                                             NFFT=self.NFFT_spectrum,
                                             Fs=self.Fs,
                                             noverlap=self.nover_spectrum,
                                             pad_to=self.pad_to_spectrum,
                                             sides=self.sides,
                                             mode='magnitude'***REMOVED***

        assert_allclose(fsp, freqs, atol=1e-06***REMOVED***
        assert_allclose(t, self.t_spectrum, atol=1e-06***REMOVED***

        assert_equal(spec.shape[0***REMOVED***, freqs.shape[0***REMOVED******REMOVED***
        assert_equal(spec.shape[1***REMOVED***, 1***REMOVED***

    def test_csd(self***REMOVED***:
        freqs = self.freqs_density
        spec, fsp = mlab.csd(x=self.y, y=self.y+1,
                             NFFT=self.NFFT_density,
                             Fs=self.Fs,
                             noverlap=self.nover_density,
                             pad_to=self.pad_to_density,
                             sides=self.sides***REMOVED***
        assert_allclose(fsp, freqs, atol=1e-06***REMOVED***
        assert_equal(spec.shape, freqs.shape***REMOVED***

    def test_psd(self***REMOVED***:
        freqs = self.freqs_density
        spec, fsp = mlab.psd(x=self.y,
                             NFFT=self.NFFT_density,
                             Fs=self.Fs,
                             noverlap=self.nover_density,
                             pad_to=self.pad_to_density,
                             sides=self.sides***REMOVED***
        assert_equal(spec.shape, freqs.shape***REMOVED***
        self.check_freqs(spec, freqs, fsp, self.fstims***REMOVED***

    def test_psd_detrend_mean_func_offset(self***REMOVED***:
        if self.NFFT_density is None:
            return
        freqs = self.freqs_density
        ydata = np.zeros(self.NFFT_density***REMOVED***
        ydata1 = ydata+5
        ydata2 = ydata+3.3
        ydata = np.vstack([ydata1, ydata2***REMOVED******REMOVED***
        ydata = np.tile(ydata, (20, 1***REMOVED******REMOVED***
        ydatab = ydata.T.flatten(***REMOVED***
        ydata = ydata.flatten(***REMOVED***
        ycontrol = np.zeros_like(ydata***REMOVED***
        spec_g, fsp_g = mlab.psd(x=ydata,
                                 NFFT=self.NFFT_density,
                                 Fs=self.Fs,
                                 noverlap=0,
                                 sides=self.sides,
                                 detrend=mlab.detrend_mean***REMOVED***
        spec_b, fsp_b = mlab.psd(x=ydatab,
                                 NFFT=self.NFFT_density,
                                 Fs=self.Fs,
                                 noverlap=0,
                                 sides=self.sides,
                                 detrend=mlab.detrend_mean***REMOVED***
        spec_c, fsp_c = mlab.psd(x=ycontrol,
                                 NFFT=self.NFFT_density,
                                 Fs=self.Fs,
                                 noverlap=0,
                                 sides=self.sides***REMOVED***
        assert_array_equal(fsp_g, fsp_c***REMOVED***
        assert_array_equal(fsp_b, fsp_c***REMOVED***
        assert_allclose(spec_g, spec_c, atol=1e-08***REMOVED***
        # these should not be almost equal
        assert_raises(AssertionError,
                      assert_allclose, spec_b, spec_c, atol=1e-08***REMOVED***

    def test_psd_detrend_mean_str_offset(self***REMOVED***:
        if self.NFFT_density is None:
            return
        freqs = self.freqs_density
        ydata = np.zeros(self.NFFT_density***REMOVED***
        ydata1 = ydata+5
        ydata2 = ydata+3.3
        ydata = np.vstack([ydata1, ydata2***REMOVED******REMOVED***
        ydata = np.tile(ydata, (20, 1***REMOVED******REMOVED***
        ydatab = ydata.T.flatten(***REMOVED***
        ydata = ydata.flatten(***REMOVED***
        ycontrol = np.zeros_like(ydata***REMOVED***
        spec_g, fsp_g = mlab.psd(x=ydata,
                                 NFFT=self.NFFT_density,
                                 Fs=self.Fs,
                                 noverlap=0,
                                 sides=self.sides,
                                 detrend='mean'***REMOVED***
        spec_b, fsp_b = mlab.psd(x=ydatab,
                                 NFFT=self.NFFT_density,
                                 Fs=self.Fs,
                                 noverlap=0,
                                 sides=self.sides,
                                 detrend='mean'***REMOVED***
        spec_c, fsp_c = mlab.psd(x=ycontrol,
                                 NFFT=self.NFFT_density,
                                 Fs=self.Fs,
                                 noverlap=0,
                                 sides=self.sides***REMOVED***
        assert_array_equal(fsp_g, fsp_c***REMOVED***
        assert_array_equal(fsp_b, fsp_c***REMOVED***
        assert_allclose(spec_g, spec_c, atol=1e-08***REMOVED***
        # these should not be almost equal
        assert_raises(AssertionError,
                      assert_allclose, spec_b, spec_c, atol=1e-08***REMOVED***

    def test_psd_detrend_linear_func_trend(self***REMOVED***:
        if self.NFFT_density is None:
            return
        freqs = self.freqs_density
        ydata = np.arange(self.NFFT_density***REMOVED***
        ydata1 = ydata+5
        ydata2 = ydata+3.3
        ydata = np.vstack([ydata1, ydata2***REMOVED******REMOVED***
        ydata = np.tile(ydata, (20, 1***REMOVED******REMOVED***
        ydatab = ydata.T.flatten(***REMOVED***
        ydata = ydata.flatten(***REMOVED***
        ycontrol = np.zeros_like(ydata***REMOVED***
        spec_g, fsp_g = mlab.psd(x=ydata,
                                 NFFT=self.NFFT_density,
                                 Fs=self.Fs,
                                 noverlap=0,
                                 sides=self.sides,
                                 detrend=mlab.detrend_linear***REMOVED***
        spec_b, fsp_b = mlab.psd(x=ydatab,
                                 NFFT=self.NFFT_density,
                                 Fs=self.Fs,
                                 noverlap=0,
                                 sides=self.sides,
                                 detrend=mlab.detrend_linear***REMOVED***
        spec_c, fsp_c = mlab.psd(x=ycontrol,
                                 NFFT=self.NFFT_density,
                                 Fs=self.Fs,
                                 noverlap=0,
                                 sides=self.sides***REMOVED***
        assert_array_equal(fsp_g, fsp_c***REMOVED***
        assert_array_equal(fsp_b, fsp_c***REMOVED***
        assert_allclose(spec_g, spec_c, atol=1e-08***REMOVED***
        # these should not be almost equal
        assert_raises(AssertionError,
                      assert_allclose, spec_b, spec_c, atol=1e-08***REMOVED***

    def test_psd_detrend_linear_str_trend(self***REMOVED***:
        if self.NFFT_density is None:
            return
        freqs = self.freqs_density
        ydata = np.arange(self.NFFT_density***REMOVED***
        ydata1 = ydata+5
        ydata2 = ydata+3.3
        ydata = np.vstack([ydata1, ydata2***REMOVED******REMOVED***
        ydata = np.tile(ydata, (20, 1***REMOVED******REMOVED***
        ydatab = ydata.T.flatten(***REMOVED***
        ydata = ydata.flatten(***REMOVED***
        ycontrol = np.zeros_like(ydata***REMOVED***
        spec_g, fsp_g = mlab.psd(x=ydata,
                                 NFFT=self.NFFT_density,
                                 Fs=self.Fs,
                                 noverlap=0,
                                 sides=self.sides,
                                 detrend='linear'***REMOVED***
        spec_b, fsp_b = mlab.psd(x=ydatab,
                                 NFFT=self.NFFT_density,
                                 Fs=self.Fs,
                                 noverlap=0,
                                 sides=self.sides,
                                 detrend='linear'***REMOVED***
        spec_c, fsp_c = mlab.psd(x=ycontrol,
                                 NFFT=self.NFFT_density,
                                 Fs=self.Fs,
                                 noverlap=0,
                                 sides=self.sides***REMOVED***
        assert_array_equal(fsp_g, fsp_c***REMOVED***
        assert_array_equal(fsp_b, fsp_c***REMOVED***
        assert_allclose(spec_g, spec_c, atol=1e-08***REMOVED***
        # these should not be almost equal
        assert_raises(AssertionError,
                      assert_allclose, spec_b, spec_c, atol=1e-08***REMOVED***

    def test_psd_window_hanning(self***REMOVED***:
        if self.NFFT_density is None:
            return
        freqs = self.freqs_density
        ydata = np.arange(self.NFFT_density***REMOVED***
        ydata1 = ydata+5
        ydata2 = ydata+3.3
        ycontrol1, windowVals = mlab.apply_window(ydata1,
                                                  mlab.window_hanning,
                                                  return_window=True***REMOVED***
        ycontrol2 = mlab.window_hanning(ydata2***REMOVED***
        ydata = np.vstack([ydata1, ydata2***REMOVED******REMOVED***
        ycontrol = np.vstack([ycontrol1, ycontrol2***REMOVED******REMOVED***
        ydata = np.tile(ydata, (20, 1***REMOVED******REMOVED***
        ycontrol = np.tile(ycontrol, (20, 1***REMOVED******REMOVED***
        ydatab = ydata.T.flatten(***REMOVED***
        ydataf = ydata.flatten(***REMOVED***
        ycontrol = ycontrol.flatten(***REMOVED***
        spec_g, fsp_g = mlab.psd(x=ydataf,
                                 NFFT=self.NFFT_density,
                                 Fs=self.Fs,
                                 noverlap=0,
                                 sides=self.sides,
                                 window=mlab.window_hanning***REMOVED***
        spec_b, fsp_b = mlab.psd(x=ydatab,
                                 NFFT=self.NFFT_density,
                                 Fs=self.Fs,
                                 noverlap=0,
                                 sides=self.sides,
                                 window=mlab.window_hanning***REMOVED***
        spec_c, fsp_c = mlab.psd(x=ycontrol,
                                 NFFT=self.NFFT_density,
                                 Fs=self.Fs,
                                 noverlap=0,
                                 sides=self.sides,
                                 window=mlab.window_none***REMOVED***
        spec_c *= len(ycontrol1***REMOVED***/(np.abs(windowVals***REMOVED*****2***REMOVED***.sum(***REMOVED***
        assert_array_equal(fsp_g, fsp_c***REMOVED***
        assert_array_equal(fsp_b, fsp_c***REMOVED***
        assert_allclose(spec_g, spec_c, atol=1e-08***REMOVED***
        # these should not be almost equal
        assert_raises(AssertionError,
                      assert_allclose, spec_b, spec_c, atol=1e-08***REMOVED***

    def test_psd_window_hanning_detrend_linear(self***REMOVED***:
        if self.NFFT_density is None:
            return
        freqs = self.freqs_density
        ydata = np.arange(self.NFFT_density***REMOVED***
        ycontrol = np.zeros(self.NFFT_density***REMOVED***
        ydata1 = ydata+5
        ydata2 = ydata+3.3
        ycontrol1 = ycontrol
        ycontrol2 = ycontrol
        ycontrol1, windowVals = mlab.apply_window(ycontrol1,
                                                  mlab.window_hanning,
                                                  return_window=True***REMOVED***
        ycontrol2 = mlab.window_hanning(ycontrol2***REMOVED***
        ydata = np.vstack([ydata1, ydata2***REMOVED******REMOVED***
        ycontrol = np.vstack([ycontrol1, ycontrol2***REMOVED******REMOVED***
        ydata = np.tile(ydata, (20, 1***REMOVED******REMOVED***
        ycontrol = np.tile(ycontrol, (20, 1***REMOVED******REMOVED***
        ydatab = ydata.T.flatten(***REMOVED***
        ydataf = ydata.flatten(***REMOVED***
        ycontrol = ycontrol.flatten(***REMOVED***
        spec_g, fsp_g = mlab.psd(x=ydataf,
                                 NFFT=self.NFFT_density,
                                 Fs=self.Fs,
                                 noverlap=0,
                                 sides=self.sides,
                                 detrend=mlab.detrend_linear,
                                 window=mlab.window_hanning***REMOVED***
        spec_b, fsp_b = mlab.psd(x=ydatab,
                                 NFFT=self.NFFT_density,
                                 Fs=self.Fs,
                                 noverlap=0,
                                 sides=self.sides,
                                 detrend=mlab.detrend_linear,
                                 window=mlab.window_hanning***REMOVED***
        spec_c, fsp_c = mlab.psd(x=ycontrol,
                                 NFFT=self.NFFT_density,
                                 Fs=self.Fs,
                                 noverlap=0,
                                 sides=self.sides,
                                 window=mlab.window_none***REMOVED***
        spec_c *= len(ycontrol1***REMOVED***/(np.abs(windowVals***REMOVED*****2***REMOVED***.sum(***REMOVED***
        assert_array_equal(fsp_g, fsp_c***REMOVED***
        assert_array_equal(fsp_b, fsp_c***REMOVED***
        assert_allclose(spec_g, spec_c, atol=1e-08***REMOVED***
        # these should not be almost equal
        assert_raises(AssertionError,
                      assert_allclose, spec_b, spec_c, atol=1e-08***REMOVED***

    def test_psd_windowarray(self***REMOVED***:
        freqs = self.freqs_density
        spec, fsp = mlab.psd(x=self.y,
                             NFFT=self.NFFT_density,
                             Fs=self.Fs,
                             noverlap=self.nover_density,
                             pad_to=self.pad_to_density,
                             sides=self.sides,
                             window=np.ones(self.NFFT_density_real***REMOVED******REMOVED***
        assert_allclose(fsp, freqs, atol=1e-06***REMOVED***
        assert_equal(spec.shape, freqs.shape***REMOVED***

    def test_psd_windowarray_scale_by_freq(self***REMOVED***:
        freqs = self.freqs_density
        win = mlab.window_hanning(np.ones(self.NFFT_density_real***REMOVED******REMOVED***

        spec, fsp = mlab.psd(x=self.y,
                             NFFT=self.NFFT_density,
                             Fs=self.Fs,
                             noverlap=self.nover_density,
                             pad_to=self.pad_to_density,
                             sides=self.sides,
                             window=mlab.window_hanning***REMOVED***
        spec_s, fsp_s = mlab.psd(x=self.y,
                                 NFFT=self.NFFT_density,
                                 Fs=self.Fs,
                                 noverlap=self.nover_density,
                                 pad_to=self.pad_to_density,
                                 sides=self.sides,
                                 window=mlab.window_hanning,
                                 scale_by_freq=True***REMOVED***
        spec_n, fsp_n = mlab.psd(x=self.y,
                                 NFFT=self.NFFT_density,
                                 Fs=self.Fs,
                                 noverlap=self.nover_density,
                                 pad_to=self.pad_to_density,
                                 sides=self.sides,
                                 window=mlab.window_hanning,
                                 scale_by_freq=False***REMOVED***
        assert_array_equal(fsp, fsp_s***REMOVED***
        assert_array_equal(fsp, fsp_n***REMOVED***
        assert_array_equal(spec, spec_s***REMOVED***
        assert_allclose(spec_s*(win**2***REMOVED***.sum(***REMOVED***,
                        spec_n/self.Fs*win.sum(***REMOVED*****2,
                        atol=1e-08***REMOVED***

    def test_complex_spectrum(self***REMOVED***:
        freqs = self.freqs_spectrum
        spec, fsp = mlab.complex_spectrum(x=self.y,
                                          Fs=self.Fs,
                                          sides=self.sides,
                                          pad_to=self.pad_to_spectrum***REMOVED***
        assert_allclose(fsp, freqs, atol=1e-06***REMOVED***
        assert_equal(spec.shape, freqs.shape***REMOVED***

    def test_magnitude_spectrum(self***REMOVED***:
        freqs = self.freqs_spectrum
        spec, fsp = mlab.magnitude_spectrum(x=self.y,
                                            Fs=self.Fs,
                                            sides=self.sides,
                                            pad_to=self.pad_to_spectrum***REMOVED***
        assert_equal(spec.shape, freqs.shape***REMOVED***
        self.check_maxfreq(spec, fsp, self.fstims***REMOVED***
        self.check_freqs(spec, freqs, fsp, self.fstims***REMOVED***

    def test_angle_spectrum(self***REMOVED***:
        freqs = self.freqs_spectrum
        spec, fsp = mlab.angle_spectrum(x=self.y,
                                        Fs=self.Fs,
                                        sides=self.sides,
                                        pad_to=self.pad_to_spectrum***REMOVED***
        assert_allclose(fsp, freqs, atol=1e-06***REMOVED***
        assert_equal(spec.shape, freqs.shape***REMOVED***

    def test_phase_spectrum(self***REMOVED***:
        freqs = self.freqs_spectrum
        spec, fsp = mlab.phase_spectrum(x=self.y,
                                        Fs=self.Fs,
                                        sides=self.sides,
                                        pad_to=self.pad_to_spectrum***REMOVED***
        assert_allclose(fsp, freqs, atol=1e-06***REMOVED***
        assert_equal(spec.shape, freqs.shape***REMOVED***

    def test_specgram_auto(self***REMOVED***:
        freqs = self.freqs_specgram
        spec, fsp, t = mlab.specgram(x=self.y,
                                     NFFT=self.NFFT_specgram,
                                     Fs=self.Fs,
                                     noverlap=self.nover_specgram,
                                     pad_to=self.pad_to_specgram,
                                     sides=self.sides***REMOVED***
        specm = np.mean(spec, axis=1***REMOVED***

        assert_allclose(fsp, freqs, atol=1e-06***REMOVED***
        assert_allclose(t, self.t_specgram, atol=1e-06***REMOVED***

        assert_equal(spec.shape[0***REMOVED***, freqs.shape[0***REMOVED******REMOVED***
        assert_equal(spec.shape[1***REMOVED***, self.t_specgram.shape[0***REMOVED******REMOVED***

        # since we are using a single freq, all time slices
        # should be about the same
        if np.abs(spec.max(***REMOVED******REMOVED*** != 0:
            assert_allclose(np.diff(spec, axis=1***REMOVED***.max(***REMOVED***/np.abs(spec.max(***REMOVED******REMOVED***, 0,
                            atol=1e-02***REMOVED***
        self.check_freqs(specm, freqs, fsp, self.fstims***REMOVED***

    def test_specgram_default(self***REMOVED***:
        freqs = self.freqs_specgram
        spec, fsp, t = mlab.specgram(x=self.y,
                                     NFFT=self.NFFT_specgram,
                                     Fs=self.Fs,
                                     noverlap=self.nover_specgram,
                                     pad_to=self.pad_to_specgram,
                                     sides=self.sides,
                                     mode='default'***REMOVED***
        specm = np.mean(spec, axis=1***REMOVED***

        assert_allclose(fsp, freqs, atol=1e-06***REMOVED***
        assert_allclose(t, self.t_specgram, atol=1e-06***REMOVED***

        assert_equal(spec.shape[0***REMOVED***, freqs.shape[0***REMOVED******REMOVED***
        assert_equal(spec.shape[1***REMOVED***, self.t_specgram.shape[0***REMOVED******REMOVED***

        # since we are using a single freq, all time slices
        # should be about the same
        if np.abs(spec.max(***REMOVED******REMOVED*** != 0:
            assert_allclose(np.diff(spec, axis=1***REMOVED***.max(***REMOVED***/np.abs(spec.max(***REMOVED******REMOVED***, 0,
                            atol=1e-02***REMOVED***
        self.check_freqs(specm, freqs, fsp, self.fstims***REMOVED***

    def test_specgram_psd(self***REMOVED***:
        freqs = self.freqs_specgram
        spec, fsp, t = mlab.specgram(x=self.y,
                                     NFFT=self.NFFT_specgram,
                                     Fs=self.Fs,
                                     noverlap=self.nover_specgram,
                                     pad_to=self.pad_to_specgram,
                                     sides=self.sides,
                                     mode='psd'***REMOVED***
        specm = np.mean(spec, axis=1***REMOVED***

        assert_allclose(fsp, freqs, atol=1e-06***REMOVED***
        assert_allclose(t, self.t_specgram, atol=1e-06***REMOVED***

        assert_equal(spec.shape[0***REMOVED***, freqs.shape[0***REMOVED******REMOVED***
        assert_equal(spec.shape[1***REMOVED***, self.t_specgram.shape[0***REMOVED******REMOVED***
        # since we are using a single freq, all time slices
        # should be about the same
        if np.abs(spec.max(***REMOVED******REMOVED*** != 0:
            assert_allclose(np.diff(spec, axis=1***REMOVED***.max(***REMOVED***/np.abs(spec.max(***REMOVED******REMOVED***, 0,
                            atol=1e-02***REMOVED***
        self.check_freqs(specm, freqs, fsp, self.fstims***REMOVED***

    def test_specgram_complex(self***REMOVED***:
        freqs = self.freqs_specgram
        spec, fsp, t = mlab.specgram(x=self.y,
                                     NFFT=self.NFFT_specgram,
                                     Fs=self.Fs,
                                     noverlap=self.nover_specgram,
                                     pad_to=self.pad_to_specgram,
                                     sides=self.sides,
                                     mode='complex'***REMOVED***
        specm = np.mean(np.abs(spec***REMOVED***, axis=1***REMOVED***
        assert_allclose(fsp, freqs, atol=1e-06***REMOVED***
        assert_allclose(t, self.t_specgram, atol=1e-06***REMOVED***

        assert_equal(spec.shape[0***REMOVED***, freqs.shape[0***REMOVED******REMOVED***
        assert_equal(spec.shape[1***REMOVED***, self.t_specgram.shape[0***REMOVED******REMOVED***

        self.check_freqs(specm, freqs, fsp, self.fstims***REMOVED***

    def test_specgram_magnitude(self***REMOVED***:
        freqs = self.freqs_specgram
        spec, fsp, t = mlab.specgram(x=self.y,
                                     NFFT=self.NFFT_specgram,
                                     Fs=self.Fs,
                                     noverlap=self.nover_specgram,
                                     pad_to=self.pad_to_specgram,
                                     sides=self.sides,
                                     mode='magnitude'***REMOVED***
        specm = np.mean(spec, axis=1***REMOVED***
        assert_allclose(fsp, freqs, atol=1e-06***REMOVED***
        assert_allclose(t, self.t_specgram, atol=1e-06***REMOVED***

        assert_equal(spec.shape[0***REMOVED***, freqs.shape[0***REMOVED******REMOVED***
        assert_equal(spec.shape[1***REMOVED***, self.t_specgram.shape[0***REMOVED******REMOVED***
        # since we are using a single freq, all time slices
        # should be about the same
        if np.abs(spec.max(***REMOVED******REMOVED*** != 0:
            assert_allclose(np.diff(spec, axis=1***REMOVED***.max(***REMOVED***/np.abs(spec.max(***REMOVED******REMOVED***, 0,
                            atol=1e-02***REMOVED***
        self.check_freqs(specm, freqs, fsp, self.fstims***REMOVED***

    def test_specgram_angle(self***REMOVED***:
        freqs = self.freqs_specgram
        spec, fsp, t = mlab.specgram(x=self.y,
                                     NFFT=self.NFFT_specgram,
                                     Fs=self.Fs,
                                     noverlap=self.nover_specgram,
                                     pad_to=self.pad_to_specgram,
                                     sides=self.sides,
                                     mode='angle'***REMOVED***
        specm = np.mean(spec, axis=1***REMOVED***
        assert_allclose(fsp, freqs, atol=1e-06***REMOVED***
        assert_allclose(t, self.t_specgram, atol=1e-06***REMOVED***

        assert_equal(spec.shape[0***REMOVED***, freqs.shape[0***REMOVED******REMOVED***
        assert_equal(spec.shape[1***REMOVED***, self.t_specgram.shape[0***REMOVED******REMOVED***

    def test_specgram_phase(self***REMOVED***:
        freqs = self.freqs_specgram
        spec, fsp, t = mlab.specgram(x=self.y,
                                     NFFT=self.NFFT_specgram,
                                     Fs=self.Fs,
                                     noverlap=self.nover_specgram,
                                     pad_to=self.pad_to_specgram,
                                     sides=self.sides,
                                     mode='phase'***REMOVED***
        specm = np.mean(spec, axis=1***REMOVED***

        assert_allclose(fsp, freqs, atol=1e-06***REMOVED***
        assert_allclose(t, self.t_specgram, atol=1e-06***REMOVED***

        assert_equal(spec.shape[0***REMOVED***, freqs.shape[0***REMOVED******REMOVED***
        assert_equal(spec.shape[1***REMOVED***, self.t_specgram.shape[0***REMOVED******REMOVED***

    def test_psd_csd_equal(self***REMOVED***:
        freqs = self.freqs_density
        Pxx, freqsxx = mlab.psd(x=self.y,
                                NFFT=self.NFFT_density,
                                Fs=self.Fs,
                                noverlap=self.nover_density,
                                pad_to=self.pad_to_density,
                                sides=self.sides***REMOVED***
        Pxy, freqsxy = mlab.csd(x=self.y, y=self.y,
                                NFFT=self.NFFT_density,
                                Fs=self.Fs,
                                noverlap=self.nover_density,
                                pad_to=self.pad_to_density,
                                sides=self.sides***REMOVED***
        assert_array_equal(Pxx, Pxy***REMOVED***
        assert_array_equal(freqsxx, freqsxy***REMOVED***

    def test_specgram_auto_default_equal(self***REMOVED***:
        '''test that mlab.specgram without mode and with mode 'default' and
        'psd' are all the same'''
        freqs = self.freqs_specgram
        speca, freqspeca, ta = mlab.specgram(x=self.y,
                                             NFFT=self.NFFT_specgram,
                                             Fs=self.Fs,
                                             noverlap=self.nover_specgram,
                                             pad_to=self.pad_to_specgram,
                                             sides=self.sides***REMOVED***
        specb, freqspecb, tb = mlab.specgram(x=self.y,
                                             NFFT=self.NFFT_specgram,
                                             Fs=self.Fs,
                                             noverlap=self.nover_specgram,
                                             pad_to=self.pad_to_specgram,
                                             sides=self.sides,
                                             mode='default'***REMOVED***
        assert_array_equal(speca, specb***REMOVED***
        assert_array_equal(freqspeca, freqspecb***REMOVED***
        assert_array_equal(ta, tb***REMOVED***

    def test_specgram_auto_psd_equal(self***REMOVED***:
        '''test that mlab.specgram without mode and with mode 'default' and
        'psd' are all the same'''
        freqs = self.freqs_specgram
        speca, freqspeca, ta = mlab.specgram(x=self.y,
                                             NFFT=self.NFFT_specgram,
                                             Fs=self.Fs,
                                             noverlap=self.nover_specgram,
                                             pad_to=self.pad_to_specgram,
                                             sides=self.sides***REMOVED***
        specc, freqspecc, tc = mlab.specgram(x=self.y,
                                             NFFT=self.NFFT_specgram,
                                             Fs=self.Fs,
                                             noverlap=self.nover_specgram,
                                             pad_to=self.pad_to_specgram,
                                             sides=self.sides,
                                             mode='psd'***REMOVED***
        assert_array_equal(speca, specc***REMOVED***
        assert_array_equal(freqspeca, freqspecc***REMOVED***
        assert_array_equal(ta, tc***REMOVED***

    def test_specgram_complex_mag_equivalent(self***REMOVED***:
        freqs = self.freqs_specgram
        specc, freqspecc, tc = mlab.specgram(x=self.y,
                                             NFFT=self.NFFT_specgram,
                                             Fs=self.Fs,
                                             noverlap=self.nover_specgram,
                                             pad_to=self.pad_to_specgram,
                                             sides=self.sides,
                                             mode='complex'***REMOVED***
        specm, freqspecm, tm = mlab.specgram(x=self.y,
                                             NFFT=self.NFFT_specgram,
                                             Fs=self.Fs,
                                             noverlap=self.nover_specgram,
                                             pad_to=self.pad_to_specgram,
                                             sides=self.sides,
                                             mode='magnitude'***REMOVED***

        assert_array_equal(freqspecc, freqspecm***REMOVED***
        assert_array_equal(tc, tm***REMOVED***
        assert_allclose(np.abs(specc***REMOVED***, specm, atol=1e-06***REMOVED***

    def test_specgram_complex_angle_equivalent(self***REMOVED***:
        freqs = self.freqs_specgram
        specc, freqspecc, tc = mlab.specgram(x=self.y,
                                             NFFT=self.NFFT_specgram,
                                             Fs=self.Fs,
                                             noverlap=self.nover_specgram,
                                             pad_to=self.pad_to_specgram,
                                             sides=self.sides,
                                             mode='complex'***REMOVED***
        speca, freqspeca, ta = mlab.specgram(x=self.y,
                                             NFFT=self.NFFT_specgram,
                                             Fs=self.Fs,
                                             noverlap=self.nover_specgram,
                                             pad_to=self.pad_to_specgram,
                                             sides=self.sides,
                                             mode='angle'***REMOVED***

        assert_array_equal(freqspecc, freqspeca***REMOVED***
        assert_array_equal(tc, ta***REMOVED***
        assert_allclose(np.angle(specc***REMOVED***, speca, atol=1e-06***REMOVED***

    def test_specgram_complex_phase_equivalent(self***REMOVED***:
        freqs = self.freqs_specgram
        specc, freqspecc, tc = mlab.specgram(x=self.y,
                                             NFFT=self.NFFT_specgram,
                                             Fs=self.Fs,
                                             noverlap=self.nover_specgram,
                                             pad_to=self.pad_to_specgram,
                                             sides=self.sides,
                                             mode='complex'***REMOVED***
        specp, freqspecp, tp = mlab.specgram(x=self.y,
                                             NFFT=self.NFFT_specgram,
                                             Fs=self.Fs,
                                             noverlap=self.nover_specgram,
                                             pad_to=self.pad_to_specgram,
                                             sides=self.sides,
                                             mode='phase'***REMOVED***

        assert_array_equal(freqspecc, freqspecp***REMOVED***
        assert_array_equal(tc, tp***REMOVED***
        assert_allclose(np.unwrap(np.angle(specc***REMOVED***, axis=0***REMOVED***, specp,
                        atol=1e-06***REMOVED***

    def test_specgram_angle_phase_equivalent(self***REMOVED***:
        freqs = self.freqs_specgram
        speca, freqspeca, ta = mlab.specgram(x=self.y,
                                             NFFT=self.NFFT_specgram,
                                             Fs=self.Fs,
                                             noverlap=self.nover_specgram,
                                             pad_to=self.pad_to_specgram,
                                             sides=self.sides,
                                             mode='angle'***REMOVED***
        specp, freqspecp, tp = mlab.specgram(x=self.y,
                                             NFFT=self.NFFT_specgram,
                                             Fs=self.Fs,
                                             noverlap=self.nover_specgram,
                                             pad_to=self.pad_to_specgram,
                                             sides=self.sides,
                                             mode='phase'***REMOVED***

        assert_array_equal(freqspeca, freqspecp***REMOVED***
        assert_array_equal(ta, tp***REMOVED***
        assert_allclose(np.unwrap(speca, axis=0***REMOVED***, specp,
                        atol=1e-06***REMOVED***

    def test_psd_windowarray_equal(self***REMOVED***:
        freqs = self.freqs_density
        win = mlab.window_hanning(np.ones(self.NFFT_density_real***REMOVED******REMOVED***
        speca, fspa = mlab.psd(x=self.y,
                               NFFT=self.NFFT_density,
                               Fs=self.Fs,
                               noverlap=self.nover_density,
                               pad_to=self.pad_to_density,
                               sides=self.sides,
                               window=win***REMOVED***
        specb, fspb = mlab.psd(x=self.y,
                               NFFT=self.NFFT_density,
                               Fs=self.Fs,
                               noverlap=self.nover_density,
                               pad_to=self.pad_to_density,
                               sides=self.sides***REMOVED***
        assert_array_equal(fspa, fspb***REMOVED***
        assert_allclose(speca, specb, atol=1e-08***REMOVED***


class spectral_testcase_nosig_real_twosided(
        spectral_testcase_nosig_real_onesided***REMOVED***:
        def setUp(self***REMOVED***:
                self.createStim(fstims=[***REMOVED***,
                                iscomplex=False, sides='twosided', nsides=2***REMOVED***


class spectral_testcase_nosig_real_defaultsided(
        spectral_testcase_nosig_real_onesided***REMOVED***:
        def setUp(self***REMOVED***:
                self.createStim(fstims=[***REMOVED***,
                                iscomplex=False, sides='default', nsides=1***REMOVED***


class spectral_testcase_nosig_complex_onesided(
        spectral_testcase_nosig_real_onesided***REMOVED***:
        def setUp(self***REMOVED***:
                self.createStim(fstims=[***REMOVED***,
                                iscomplex=True, sides='onesided', nsides=1***REMOVED***


class spectral_testcase_nosig_complex_twosided(
        spectral_testcase_nosig_real_onesided***REMOVED***:
        def setUp(self***REMOVED***:
                self.createStim(fstims=[***REMOVED***,
                                iscomplex=True, sides='twosided', nsides=2***REMOVED***


class spectral_testcase_nosig_complex_defaultsided(
        spectral_testcase_nosig_real_onesided***REMOVED***:
        def setUp(self***REMOVED***:
                self.createStim(fstims=[***REMOVED***,
                                iscomplex=True, sides='default', nsides=2***REMOVED***


class spectral_testcase_Fs4_real_onesided(
        spectral_testcase_nosig_real_onesided***REMOVED***:
        def setUp(self***REMOVED***:
                self.createStim(fstims=[4***REMOVED***,
                                iscomplex=False, sides='onesided', nsides=1***REMOVED***


class spectral_testcase_Fs4_real_twosided(
        spectral_testcase_nosig_real_onesided***REMOVED***:
        def setUp(self***REMOVED***:
                self.createStim(fstims=[4***REMOVED***,
                                iscomplex=False, sides='twosided', nsides=2***REMOVED***


class spectral_testcase_Fs4_real_defaultsided(
        spectral_testcase_nosig_real_onesided***REMOVED***:
        def setUp(self***REMOVED***:
                self.createStim(fstims=[4***REMOVED***,
                                iscomplex=False, sides='default', nsides=1***REMOVED***


class spectral_testcase_Fs4_complex_onesided(
        spectral_testcase_nosig_real_onesided***REMOVED***:
        def setUp(self***REMOVED***:
                self.createStim(fstims=[4***REMOVED***,
                                iscomplex=True, sides='onesided', nsides=1***REMOVED***


class spectral_testcase_Fs4_complex_twosided(
        spectral_testcase_nosig_real_onesided***REMOVED***:
        def setUp(self***REMOVED***:
                self.createStim(fstims=[4***REMOVED***,
                                iscomplex=True, sides='twosided', nsides=2***REMOVED***


class spectral_testcase_Fs4_complex_defaultsided(
        spectral_testcase_nosig_real_onesided***REMOVED***:
        def setUp(self***REMOVED***:
                self.createStim(fstims=[4***REMOVED***,
                                iscomplex=True, sides='default', nsides=2***REMOVED***


class spectral_testcase_FsAll_real_onesided(
        spectral_testcase_nosig_real_onesided***REMOVED***:
        def setUp(self***REMOVED***:
                self.createStim(fstims=[4, 5, 10***REMOVED***,
                                iscomplex=False, sides='onesided', nsides=1***REMOVED***


class spectral_testcase_FsAll_real_twosided(
        spectral_testcase_nosig_real_onesided***REMOVED***:
        def setUp(self***REMOVED***:
                self.createStim(fstims=[4, 5, 10***REMOVED***,
                                iscomplex=False, sides='twosided', nsides=2***REMOVED***


class spectral_testcase_FsAll_real_defaultsided(
        spectral_testcase_nosig_real_onesided***REMOVED***:
        def setUp(self***REMOVED***:
                self.createStim(fstims=[4, 5, 10***REMOVED***,
                                iscomplex=False, sides='default', nsides=1***REMOVED***


class spectral_testcase_FsAll_complex_onesided(
        spectral_testcase_nosig_real_onesided***REMOVED***:
        def setUp(self***REMOVED***:
                self.createStim(fstims=[4, 5, 10***REMOVED***,
                                iscomplex=True, sides='onesided', nsides=1***REMOVED***


class spectral_testcase_FsAll_complex_twosided(
        spectral_testcase_nosig_real_onesided***REMOVED***:
        def setUp(self***REMOVED***:
                self.createStim(fstims=[4, 5, 10***REMOVED***,
                                iscomplex=True, sides='twosided', nsides=2***REMOVED***


class spectral_testcase_FsAll_complex_defaultsided(
        spectral_testcase_nosig_real_onesided***REMOVED***:
        def setUp(self***REMOVED***:
                self.createStim(fstims=[4, 5, 10***REMOVED***,
                                iscomplex=True, sides='default', nsides=2***REMOVED***


class spectral_testcase_nosig_real_onesided_noNFFT(
        spectral_testcase_nosig_real_onesided***REMOVED***:
        def setUp(self***REMOVED***:
                self.createStim(fstims=[***REMOVED***,
                                NFFT_density=None, pad_to_spectrum=None,
                                iscomplex=False, sides='onesided', nsides=1***REMOVED***


class spectral_testcase_nosig_real_twosided_noNFFT(
        spectral_testcase_nosig_real_onesided***REMOVED***:
        def setUp(self***REMOVED***:
                self.createStim(fstims=[***REMOVED***,
                                NFFT_density=None, pad_to_spectrum=None,
                                iscomplex=False, sides='twosided', nsides=2***REMOVED***


class spectral_testcase_nosig_real_defaultsided_noNFFT(
        spectral_testcase_nosig_real_onesided***REMOVED***:
        def setUp(self***REMOVED***:
                self.createStim(fstims=[***REMOVED***,
                                NFFT_density=None, pad_to_spectrum=None,
                                iscomplex=False, sides='default', nsides=1***REMOVED***


class spectral_testcase_nosig_complex_onesided_noNFFT(
        spectral_testcase_nosig_real_onesided***REMOVED***:
        def setUp(self***REMOVED***:
                self.createStim(fstims=[***REMOVED***,
                                NFFT_density=None, pad_to_spectrum=None,
                                iscomplex=True, sides='onesided', nsides=1***REMOVED***


class spectral_testcase_nosig_complex_twosided_noNFFT(
        spectral_testcase_nosig_real_onesided***REMOVED***:
        def setUp(self***REMOVED***:
                self.createStim(fstims=[***REMOVED***,
                                NFFT_density=None, pad_to_spectrum=None,
                                iscomplex=True, sides='twosided', nsides=2***REMOVED***


class spectral_testcase_nosig_complex_defaultsided_noNFFT(
        spectral_testcase_nosig_real_onesided***REMOVED***:
        def setUp(self***REMOVED***:
                self.createStim(fstims=[***REMOVED***,
                                NFFT_density=None, pad_to_spectrum=None,
                                iscomplex=True, sides='default', nsides=2***REMOVED***


class spectral_testcase_nosig_real_onesided_nopad_to(
        spectral_testcase_nosig_real_onesided***REMOVED***:
        def setUp(self***REMOVED***:
                self.createStim(fstims=[***REMOVED***,
                                pad_to_density=None, pad_to_spectrum=None,
                                iscomplex=False, sides='onesided', nsides=1***REMOVED***


class spectral_testcase_nosig_real_twosided_nopad_to(
        spectral_testcase_nosig_real_onesided***REMOVED***:
        def setUp(self***REMOVED***:
                self.createStim(fstims=[***REMOVED***,
                                pad_to_density=None, pad_to_spectrum=None,
                                iscomplex=False, sides='twosided', nsides=2***REMOVED***


class spectral_testcase_nosig_real_defaultsided_nopad_to(
        spectral_testcase_nosig_real_onesided***REMOVED***:
        def setUp(self***REMOVED***:
                self.createStim(fstims=[***REMOVED***,
                                pad_to_density=None, pad_to_spectrum=None,
                                iscomplex=False, sides='default', nsides=1***REMOVED***


class spectral_testcase_nosig_complex_onesided_nopad_to(
        spectral_testcase_nosig_real_onesided***REMOVED***:
        def setUp(self***REMOVED***:
                self.createStim(fstims=[***REMOVED***,
                                pad_to_density=None, pad_to_spectrum=None,
                                iscomplex=True, sides='onesided', nsides=1***REMOVED***


class spectral_testcase_nosig_complex_twosided_nopad_to(
        spectral_testcase_nosig_real_onesided***REMOVED***:
        def setUp(self***REMOVED***:
                self.createStim(fstims=[***REMOVED***,
                                NFFT_density=None,
                                pad_to_density=None, pad_to_spectrum=None,
                                iscomplex=True, sides='twosided', nsides=2***REMOVED***


class spectral_testcase_nosig_complex_defaultsided_nopad_to(
        spectral_testcase_nosig_real_onesided***REMOVED***:
        def setUp(self***REMOVED***:
                self.createStim(fstims=[***REMOVED***,
                                NFFT_density=None,
                                pad_to_density=None, pad_to_spectrum=None,
                                iscomplex=True, sides='default', nsides=2***REMOVED***


class spectral_testcase_nosig_real_onesided_noNFFT_no_pad_to(
        spectral_testcase_nosig_real_onesided***REMOVED***:
        def setUp(self***REMOVED***:
                self.createStim(fstims=[***REMOVED***,
                                NFFT_density=None,
                                pad_to_density=None, pad_to_spectrum=None,
                                iscomplex=False, sides='onesided', nsides=1***REMOVED***


class spectral_testcase_nosig_real_twosided_noNFFT_no_pad_to(
        spectral_testcase_nosig_real_onesided***REMOVED***:
        def setUp(self***REMOVED***:
                self.createStim(fstims=[***REMOVED***,
                                NFFT_density=None,
                                pad_to_density=None, pad_to_spectrum=None,
                                iscomplex=False, sides='twosided', nsides=2***REMOVED***


class spectral_testcase_nosig_real_defaultsided_noNFFT_no_pad_to(
        spectral_testcase_nosig_real_onesided***REMOVED***:
        def setUp(self***REMOVED***:
                self.createStim(fstims=[***REMOVED***,
                                NFFT_density=None,
                                pad_to_density=None, pad_to_spectrum=None,
                                iscomplex=False, sides='default', nsides=1***REMOVED***


class spectral_testcase_nosig_complex_onesided_noNFFT_no_pad_to(
        spectral_testcase_nosig_real_onesided***REMOVED***:
        def setUp(self***REMOVED***:
                self.createStim(fstims=[***REMOVED***,
                                NFFT_density=None,
                                pad_to_density=None, pad_to_spectrum=None,
                                iscomplex=True, sides='onesided', nsides=1***REMOVED***


class spectral_testcase_nosig_complex_twosided_noNFFT_no_pad_to(
        spectral_testcase_nosig_real_onesided***REMOVED***:
        def setUp(self***REMOVED***:
                self.createStim(fstims=[***REMOVED***,
                                NFFT_density=None,
                                pad_to_density=None, pad_to_spectrum=None,
                                iscomplex=True, sides='twosided', nsides=2***REMOVED***


class spectral_testcase_nosig_complex_defaultsided_noNFFT_no_pad_to(
        spectral_testcase_nosig_real_onesided***REMOVED***:
        def setUp(self***REMOVED***:
                self.createStim(fstims=[***REMOVED***,
                                NFFT_density=None,
                                pad_to_density=None, pad_to_spectrum=None,
                                iscomplex=True, sides='default', nsides=2***REMOVED***


class spectral_testcase_nosig_real_onesided_trim(
        spectral_testcase_nosig_real_onesided***REMOVED***:
        def setUp(self***REMOVED***:
                self.createStim(fstims=[***REMOVED***,
                                len_x=256,
                                NFFT_density=512, pad_to_spectrum=128,
                                iscomplex=False, sides='onesided', nsides=1***REMOVED***


class spectral_testcase_nosig_real_twosided_trim(
        spectral_testcase_nosig_real_onesided***REMOVED***:
        def setUp(self***REMOVED***:
                self.createStim(fstims=[***REMOVED***,
                                len_x=256,
                                NFFT_density=512, pad_to_spectrum=128,
                                iscomplex=False, sides='twosided', nsides=2***REMOVED***


class spectral_testcase_nosig_real_defaultsided_trim(
        spectral_testcase_nosig_real_onesided***REMOVED***:
        def setUp(self***REMOVED***:
                self.createStim(fstims=[***REMOVED***,
                                len_x=256,
                                NFFT_density=512, pad_to_spectrum=128,
                                iscomplex=False, sides='default', nsides=1***REMOVED***


class spectral_testcase_nosig_complex_onesided_trim(
        spectral_testcase_nosig_real_onesided***REMOVED***:
        def setUp(self***REMOVED***:
                self.createStim(fstims=[***REMOVED***,
                                len_x=256,
                                NFFT_density=512, pad_to_spectrum=128,
                                iscomplex=True, sides='onesided', nsides=1***REMOVED***


class spectral_testcase_nosig_complex_twosided_trim(
        spectral_testcase_nosig_real_onesided***REMOVED***:
        def setUp(self***REMOVED***:
                self.createStim(fstims=[***REMOVED***,
                                len_x=256,
                                NFFT_density=512, pad_to_spectrum=128,
                                iscomplex=True, sides='twosided', nsides=2***REMOVED***


class spectral_testcase_nosig_complex_defaultsided_trim(
        spectral_testcase_nosig_real_onesided***REMOVED***:
        def setUp(self***REMOVED***:
                self.createStim(fstims=[***REMOVED***,
                                len_x=256,
                                NFFT_density=128, pad_to_spectrum=128,
                                iscomplex=True, sides='default', nsides=2***REMOVED***


class spectral_testcase_nosig_real_onesided_odd(
        spectral_testcase_nosig_real_onesided***REMOVED***:
        def setUp(self***REMOVED***:
                self.createStim(fstims=[***REMOVED***,
                                len_x=256,
                                pad_to_density=33, pad_to_spectrum=257,
                                iscomplex=False, sides='onesided', nsides=1***REMOVED***


class spectral_testcase_nosig_real_twosided_odd(
        spectral_testcase_nosig_real_onesided***REMOVED***:
        def setUp(self***REMOVED***:
                self.createStim(fstims=[***REMOVED***,
                                len_x=256,
                                pad_to_density=33, pad_to_spectrum=257,
                                iscomplex=False, sides='twosided', nsides=2***REMOVED***


class spectral_testcase_nosig_real_defaultsided_odd(
        spectral_testcase_nosig_real_onesided***REMOVED***:
        def setUp(self***REMOVED***:
                self.createStim(fstims=[***REMOVED***,
                                len_x=256,
                                pad_to_density=33, pad_to_spectrum=257,
                                iscomplex=False, sides='default', nsides=1***REMOVED***


class spectral_testcase_nosig_complex_onesided_odd(
        spectral_testcase_nosig_real_onesided***REMOVED***:
        def setUp(self***REMOVED***:
                self.createStim(fstims=[***REMOVED***,
                                len_x=256,
                                pad_to_density=33, pad_to_spectrum=257,
                                iscomplex=True, sides='onesided', nsides=1***REMOVED***


class spectral_testcase_nosig_complex_twosided_odd(
        spectral_testcase_nosig_real_onesided***REMOVED***:
        def setUp(self***REMOVED***:
                self.createStim(fstims=[***REMOVED***,
                                len_x=256,
                                pad_to_density=33, pad_to_spectrum=257,
                                iscomplex=True, sides='twosided', nsides=2***REMOVED***


class spectral_testcase_nosig_complex_defaultsided_odd(
        spectral_testcase_nosig_real_onesided***REMOVED***:
        def setUp(self***REMOVED***:
                self.createStim(fstims=[***REMOVED***,
                                len_x=256,
                                pad_to_density=33, pad_to_spectrum=257,
                                iscomplex=True, sides='default', nsides=2***REMOVED***


class spectral_testcase_nosig_real_onesided_oddlen(
        spectral_testcase_nosig_real_onesided***REMOVED***:
        def setUp(self***REMOVED***:
                self.createStim(fstims=[***REMOVED***,
                                len_x=255,
                                NFFT_density=33, pad_to_spectrum=None,
                                iscomplex=False, sides='onesided', nsides=1***REMOVED***


class spectral_testcase_nosig_real_twosided_oddlen(
        spectral_testcase_nosig_real_onesided***REMOVED***:
        def setUp(self***REMOVED***:
                self.createStim(fstims=[***REMOVED***,
                                len_x=255,
                                NFFT_density=33, pad_to_spectrum=None,
                                iscomplex=False, sides='twosided', nsides=2***REMOVED***


class spectral_testcase_nosig_real_defaultsided_oddlen(
        spectral_testcase_nosig_real_onesided***REMOVED***:
        def setUp(self***REMOVED***:
                self.createStim(fstims=[***REMOVED***,
                                len_x=255,
                                NFFT_density=33, pad_to_spectrum=None,
                                iscomplex=False, sides='default', nsides=1***REMOVED***


class spectral_testcase_nosig_complex_onesided_oddlen(
        spectral_testcase_nosig_real_onesided***REMOVED***:
        def setUp(self***REMOVED***:
                self.createStim(fstims=[***REMOVED***,
                                len_x=255,
                                NFFT_density=33, pad_to_spectrum=None,
                                iscomplex=True, sides='onesided', nsides=1***REMOVED***


class spectral_testcase_nosig_complex_twosided_oddlen(
        spectral_testcase_nosig_real_onesided***REMOVED***:
        def setUp(self***REMOVED***:
                self.createStim(fstims=[***REMOVED***,
                                len_x=255,
                                NFFT_density=33, pad_to_spectrum=None,
                                iscomplex=True, sides='twosided', nsides=2***REMOVED***


class spectral_testcase_nosig_complex_defaultsided_oddlen(
        spectral_testcase_nosig_real_onesided***REMOVED***:
        def setUp(self***REMOVED***:
                self.createStim(fstims=[***REMOVED***,
                                len_x=255,
                                NFFT_density=128, pad_to_spectrum=None,
                                iscomplex=True, sides='default', nsides=2***REMOVED***


class spectral_testcase_nosig_real_onesided_stretch(
        spectral_testcase_nosig_real_onesided***REMOVED***:
        def setUp(self***REMOVED***:
                self.createStim(fstims=[***REMOVED***,
                                len_x=128,
                                NFFT_density=128,
                                pad_to_density=256, pad_to_spectrum=256,
                                iscomplex=False, sides='onesided', nsides=1***REMOVED***


class spectral_testcase_nosig_real_twosided_stretch(
        spectral_testcase_nosig_real_onesided***REMOVED***:
        def setUp(self***REMOVED***:
                self.createStim(fstims=[***REMOVED***,
                                len_x=128,
                                NFFT_density=128,
                                pad_to_density=256, pad_to_spectrum=256,
                                iscomplex=False, sides='twosided', nsides=2***REMOVED***


class spectral_testcase_nosig_real_defaultsided_stretch(
        spectral_testcase_nosig_real_onesided***REMOVED***:
        def setUp(self***REMOVED***:
                self.createStim(fstims=[***REMOVED***,
                                len_x=128,
                                NFFT_density=128,
                                pad_to_density=256, pad_to_spectrum=256,
                                iscomplex=False, sides='default', nsides=1***REMOVED***


class spectral_testcase_nosig_complex_onesided_stretch(
        spectral_testcase_nosig_real_onesided***REMOVED***:
        def setUp(self***REMOVED***:
                self.createStim(fstims=[***REMOVED***,
                                len_x=128,
                                NFFT_density=128,
                                pad_to_density=256, pad_to_spectrum=256,
                                iscomplex=True, sides='onesided', nsides=1***REMOVED***


class spectral_testcase_nosig_complex_twosided_stretch(
        spectral_testcase_nosig_real_onesided***REMOVED***:
        def setUp(self***REMOVED***:
                self.createStim(fstims=[***REMOVED***,
                                len_x=128,
                                NFFT_density=128,
                                pad_to_density=256, pad_to_spectrum=256,
                                iscomplex=True, sides='twosided', nsides=2***REMOVED***


class spectral_testcase_nosig_complex_defaultsided_stretch(
        spectral_testcase_nosig_real_onesided***REMOVED***:
        def setUp(self***REMOVED***:
                self.createStim(fstims=[***REMOVED***,
                                len_x=128,
                                NFFT_density=128,
                                pad_to_density=256, pad_to_spectrum=256,
                                iscomplex=True, sides='default', nsides=2***REMOVED***


class spectral_testcase_nosig_real_onesided_overlap(
        spectral_testcase_nosig_real_onesided***REMOVED***:
        def setUp(self***REMOVED***:
                self.createStim(fstims=[***REMOVED***,
                                nover_density=32,
                                iscomplex=False, sides='onesided', nsides=1***REMOVED***


class spectral_testcase_nosig_real_twosided_overlap(
        spectral_testcase_nosig_real_onesided***REMOVED***:
        def setUp(self***REMOVED***:
                self.createStim(fstims=[***REMOVED***,
                                nover_density=32,
                                iscomplex=False, sides='twosided', nsides=2***REMOVED***


class spectral_testcase_nosig_real_defaultsided_overlap(
        spectral_testcase_nosig_real_onesided***REMOVED***:
        def setUp(self***REMOVED***:
                self.createStim(fstims=[***REMOVED***,
                                nover_density=32,
                                iscomplex=False, sides='default', nsides=1***REMOVED***


class spectral_testcase_nosig_complex_onesided_overlap(
        spectral_testcase_nosig_real_onesided***REMOVED***:
        def setUp(self***REMOVED***:
                self.createStim(fstims=[***REMOVED***,
                                nover_density=32,
                                iscomplex=True, sides='onesided', nsides=1***REMOVED***


class spectral_testcase_nosig_complex_twosided_overlap(
        spectral_testcase_nosig_real_onesided***REMOVED***:
        def setUp(self***REMOVED***:
                self.createStim(fstims=[***REMOVED***,
                                nover_density=32,
                                iscomplex=True, sides='twosided', nsides=2***REMOVED***


class spectral_testcase_nosig_complex_defaultsided_overlap(
        spectral_testcase_nosig_real_onesided***REMOVED***:
        def setUp(self***REMOVED***:
                self.createStim(fstims=[***REMOVED***,
                                nover_density=32,
                                iscomplex=True, sides='default', nsides=2***REMOVED***


def test_griddata_linear(***REMOVED***:
    # z is a linear function of x and y.
    def get_z(x, y***REMOVED***:
        return 3.0*x - y

    # Passing 1D xi and yi arrays to griddata.
    x = np.asarray([0.0, 1.0, 0.0, 1.0, 0.5***REMOVED******REMOVED***
    y = np.asarray([0.0, 0.0, 1.0, 1.0, 0.5***REMOVED******REMOVED***
    z = get_z(x, y***REMOVED***
    xi = [0.2, 0.4, 0.6, 0.8***REMOVED***
    yi = [0.1, 0.3, 0.7, 0.9***REMOVED***
    zi = mlab.griddata(x, y, z, xi, yi, interp='linear'***REMOVED***
    xi, yi = np.meshgrid(xi, yi***REMOVED***
    np.testing.assert_array_almost_equal(zi, get_z(xi, yi***REMOVED******REMOVED***

    # Passing 2D xi and yi arrays to griddata.
    zi = mlab.griddata(x, y, z, xi, yi, interp='linear'***REMOVED***
    np.testing.assert_array_almost_equal(zi, get_z(xi, yi***REMOVED******REMOVED***

    # Masking z array.
    z_masked = np.ma.array(z, mask=[False, False, False, True, False***REMOVED******REMOVED***
    correct_zi_masked = np.ma.masked_where(xi + yi > 1.0, get_z(xi, yi***REMOVED******REMOVED***
    zi = mlab.griddata(x, y, z_masked, xi, yi, interp='linear'***REMOVED***
    matest.assert_array_almost_equal(zi, correct_zi_masked***REMOVED***
    np.testing.assert_array_equal(np.ma.getmask(zi***REMOVED***,
                                  np.ma.getmask(correct_zi_masked***REMOVED******REMOVED***


@knownfailureif(not HAS_NATGRID***REMOVED***
def test_griddata_nn(***REMOVED***:
    # z is a linear function of x and y.
    def get_z(x, y***REMOVED***:
        return 3.0*x - y

    # Passing 1D xi and yi arrays to griddata.
    x = np.asarray([0.0, 1.0, 0.0, 1.0, 0.5***REMOVED******REMOVED***
    y = np.asarray([0.0, 0.0, 1.0, 1.0, 0.5***REMOVED******REMOVED***
    z = get_z(x, y***REMOVED***
    xi = [0.2, 0.4, 0.6, 0.8***REMOVED***
    yi = [0.1, 0.3, 0.7, 0.9***REMOVED***
    correct_zi = [[0.49999252, 1.0999978, 1.7000030, 2.3000080***REMOVED***,
                  [0.29999208, 0.8999978, 1.5000029, 2.1000059***REMOVED***,
                  [-0.1000099, 0.4999943, 1.0999964, 1.6999979***REMOVED***,
                  [-0.3000128, 0.2999894, 0.8999913, 1.4999933***REMOVED******REMOVED***
    zi = mlab.griddata(x, y, z, xi, yi, interp='nn'***REMOVED***
    np.testing.assert_array_almost_equal(zi, correct_zi, 5***REMOVED***

    # Decreasing xi or yi should raise ValueError.
    assert_raises(ValueError, mlab.griddata, x, y, z, xi[::-1***REMOVED***, yi,
                  interp='nn'***REMOVED***
    assert_raises(ValueError, mlab.griddata, x, y, z, xi, yi[::-1***REMOVED***,
                  interp='nn'***REMOVED***

    # Passing 2D xi and yi arrays to griddata.
    xi, yi = np.meshgrid(xi, yi***REMOVED***
    zi = mlab.griddata(x, y, z, xi, yi, interp='nn'***REMOVED***
    np.testing.assert_array_almost_equal(zi, correct_zi, 5***REMOVED***

    # Masking z array.
    z_masked = np.ma.array(z, mask=[False, False, False, True, False***REMOVED******REMOVED***
    correct_zi_masked = np.ma.masked_where(xi + yi > 1.0, correct_zi***REMOVED***
    zi = mlab.griddata(x, y, z_masked, xi, yi, interp='nn'***REMOVED***
    np.testing.assert_array_almost_equal(zi, correct_zi_masked, 5***REMOVED***
    np.testing.assert_array_equal(np.ma.getmask(zi***REMOVED***,
                                  np.ma.getmask(correct_zi_masked***REMOVED******REMOVED***


#*****************************************************************
# These Tests where taken from SCIPY with some minor modifications
# this can be retreived from:
# https://github.com/scipy/scipy/blob/master/scipy/stats/tests/test_kdeoth.py
#*****************************************************************

class gaussian_kde_tests(***REMOVED***:

    def test_kde_integer_input(self***REMOVED***:
        ***REMOVED***Regression test for #1181.***REMOVED***
        x1 = np.arange(5***REMOVED***
        kde = mlab.GaussianKDE(x1***REMOVED***
        y_expected = [0.13480721, 0.18222869, 0.19514935, 0.18222869,
                      0.13480721***REMOVED***
        np.testing.assert_array_almost_equal(kde(x1***REMOVED***, y_expected, decimal=6***REMOVED***

    def test_gaussian_kde_covariance_caching(self***REMOVED***:
        x1 = np.array([-7, -5, 1, 4, 5***REMOVED***, dtype=np.float***REMOVED***
        xs = np.linspace(-10, 10, num=5***REMOVED***
        # These expected values are from scipy 0.10, before some changes to
        # gaussian_kde. They were not compared with any external reference.
        y_expected = [0.02463386, 0.04689208, 0.05395444, 0.05337754,
                      0.01664475***REMOVED***

        # set it to the default bandwidth.
        kde2 = mlab.GaussianKDE(x1, 'scott'***REMOVED***
        y2 = kde2(xs***REMOVED***

        np.testing.assert_array_almost_equal(y_expected, y2, decimal=7***REMOVED***

    def test_kde_bandwidth_method(self***REMOVED***:

        np.random.seed(8765678***REMOVED***
        n_basesample = 50
        xn = np.random.randn(n_basesample***REMOVED***

        # Default
        gkde = mlab.GaussianKDE(xn***REMOVED***
        # Supply a callable
        gkde2 = mlab.GaussianKDE(xn, 'scott'***REMOVED***
        # Supply a scalar
        gkde3 = mlab.GaussianKDE(xn, bw_method=gkde.factor***REMOVED***

        xs = np.linspace(-7, 7, 51***REMOVED***
        kdepdf = gkde.evaluate(xs***REMOVED***
        kdepdf2 = gkde2.evaluate(xs***REMOVED***
        assert_almost_equal(kdepdf.all(***REMOVED***, kdepdf2.all(***REMOVED******REMOVED***
        kdepdf3 = gkde3.evaluate(xs***REMOVED***
        assert_almost_equal(kdepdf.all(***REMOVED***, kdepdf3.all(***REMOVED******REMOVED***


class gaussian_kde_custom_tests(object***REMOVED***:
    def test_no_data(self***REMOVED***:
        ***REMOVED***Pass no data into the GaussianKDE class.***REMOVED***
        assert_raises(ValueError, mlab.GaussianKDE, [***REMOVED******REMOVED***

    def test_single_dataset_element(self***REMOVED***:
        ***REMOVED***Pass a single dataset element into the GaussianKDE class.***REMOVED***
        assert_raises(ValueError, mlab.GaussianKDE, [42***REMOVED******REMOVED***

    def test_silverman_multidim_dataset(self***REMOVED***:
        ***REMOVED***Use a multi-dimensional array as the dataset and test silverman's
        output***REMOVED***
        x1 = np.array([[1, 2, 3***REMOVED***, [4, 5, 6***REMOVED***, [7, 8, 9***REMOVED******REMOVED******REMOVED***
        assert_raises(np.linalg.LinAlgError, mlab.GaussianKDE, x1, "silverman"***REMOVED***

    def test_silverman_singledim_dataset(self***REMOVED***:
        ***REMOVED***Use a single dimension list as the dataset and test silverman's
        output.***REMOVED***
        x1 = np.array([-7, -5, 1, 4, 5***REMOVED******REMOVED***
        mygauss = mlab.GaussianKDE(x1, "silverman"***REMOVED***
        y_expected = 0.76770389927475502
        assert_almost_equal(mygauss.covariance_factor(***REMOVED***, y_expected, 7***REMOVED***

    def test_scott_multidim_dataset(self***REMOVED***:
        ***REMOVED***Use a multi-dimensional array as the dataset and test scott's output
        ***REMOVED***
        x1 = np.array([[1, 2, 3***REMOVED***, [4, 5, 6***REMOVED***, [7, 8, 9***REMOVED******REMOVED******REMOVED***
        assert_raises(np.linalg.LinAlgError, mlab.GaussianKDE, x1, "scott"***REMOVED***

    def test_scott_singledim_dataset(self***REMOVED***:
        ***REMOVED***Use a single-dimensional array as the dataset and test scott's
        output***REMOVED***
        x1 = np.array([-7, -5, 1, 4, 5***REMOVED******REMOVED***
        mygauss = mlab.GaussianKDE(x1, "scott"***REMOVED***
        y_expected = 0.72477966367769553
        assert_almost_equal(mygauss.covariance_factor(***REMOVED***, y_expected, 7***REMOVED***

    def test_scalar_empty_dataset(self***REMOVED***:
        ***REMOVED***Use an empty array as the dataset and test the scalar's cov factor
        ***REMOVED***
        assert_raises(ValueError, mlab.GaussianKDE, [***REMOVED***, bw_method=5***REMOVED***

    def test_scalar_covariance_dataset(self***REMOVED***:
        ***REMOVED***Use a dataset and test a scalar's cov factor
        ***REMOVED***
        np.random.seed(8765678***REMOVED***
        n_basesample = 50
        multidim_data = [np.random.randn(n_basesample***REMOVED*** for i in range(5***REMOVED******REMOVED***

        kde = mlab.GaussianKDE(multidim_data, bw_method=0.5***REMOVED***
        assert_equal(kde.covariance_factor(***REMOVED***, 0.5***REMOVED***

    def test_callable_covariance_dataset(self***REMOVED***:
        ***REMOVED***Use a multi-dimensional array as the dataset and test the callable's
        cov factor***REMOVED***
        np.random.seed(8765678***REMOVED***
        n_basesample = 50
        multidim_data = [np.random.randn(n_basesample***REMOVED*** for i in range(5***REMOVED******REMOVED***

        def callable_fun(x***REMOVED***:
            return 0.55
        kde = mlab.GaussianKDE(multidim_data, bw_method=callable_fun***REMOVED***
        assert_equal(kde.covariance_factor(***REMOVED***, 0.55***REMOVED***

    def test_callable_singledim_dataset(self***REMOVED***:
        ***REMOVED***Use a single-dimensional array as the dataset and test the
        callable's cov factor***REMOVED***
        np.random.seed(8765678***REMOVED***
        n_basesample = 50
        multidim_data = np.random.randn(n_basesample***REMOVED***

        kde = mlab.GaussianKDE(multidim_data, bw_method='silverman'***REMOVED***
        y_expected = 0.48438841363348911
        assert_almost_equal(kde.covariance_factor(***REMOVED***, y_expected, 7***REMOVED***

    def test_wrong_bw_method(self***REMOVED***:
        ***REMOVED***Test the error message that should be called when bw is invalid.***REMOVED***
        np.random.seed(8765678***REMOVED***
        n_basesample = 50
        data = np.random.randn(n_basesample***REMOVED***
        assert_raises(ValueError, mlab.GaussianKDE, data, bw_method="invalid"***REMOVED***


class gaussian_kde_evaluate_tests(object***REMOVED***:

    def test_evaluate_diff_dim(self***REMOVED***:
        ***REMOVED***Test the evaluate method when the dim's of dataset and points are
        different dimensions***REMOVED***
        x1 = np.arange(3, 10, 2***REMOVED***
        kde = mlab.GaussianKDE(x1***REMOVED***
        x2 = np.arange(3, 12, 2***REMOVED***
        y_expected = [
            0.08797252, 0.11774109, 0.11774109, 0.08797252, 0.0370153
        ***REMOVED***
        y = kde.evaluate(x2***REMOVED***
        np.testing.assert_array_almost_equal(y, y_expected, 7***REMOVED***

    def test_evaluate_inv_dim(self***REMOVED***:
        ***REMOVED*** Invert the dimensions. i.e., Give the dataset a dimension of
        1 [3,2,4***REMOVED***, and the points will have a dimension of 3 [[3***REMOVED***,[2***REMOVED***,[4***REMOVED******REMOVED***.
        ValueError should be raised***REMOVED***
        np.random.seed(8765678***REMOVED***
        n_basesample = 50
        multidim_data = np.random.randn(n_basesample***REMOVED***
        kde = mlab.GaussianKDE(multidim_data***REMOVED***
        x2 = [[1***REMOVED***, [2***REMOVED***, [3***REMOVED******REMOVED***
        assert_raises(ValueError, kde.evaluate, x2***REMOVED***

    def test_evaluate_dim_and_num(self***REMOVED***:
        ***REMOVED*** Tests if evaluated against a one by one array***REMOVED***
        x1 = np.arange(3, 10, 2***REMOVED***
        x2 = np.array([3***REMOVED******REMOVED***
        kde = mlab.GaussianKDE(x1***REMOVED***
        y_expected = [0.08797252***REMOVED***
        y = kde.evaluate(x2***REMOVED***
        np.testing.assert_array_almost_equal(y, y_expected, 7***REMOVED***

    def test_evaluate_point_dim_not_one(self***REMOVED***:
        ***REMOVED***Test***REMOVED***
        x1 = np.arange(3, 10, 2***REMOVED***
        x2 = [np.arange(3, 10, 2***REMOVED***, np.arange(3, 10, 2***REMOVED******REMOVED***
        kde = mlab.GaussianKDE(x1***REMOVED***
        assert_raises(ValueError, kde.evaluate, x2***REMOVED***

    def test_evaluate_equal_dim_and_num_lt(self***REMOVED***:
        ***REMOVED***Test when line 3810 fails***REMOVED***
        x1 = np.arange(3, 10, 2***REMOVED***
        x2 = np.arange(3, 8, 2***REMOVED***
        kde = mlab.GaussianKDE(x1***REMOVED***
        y_expected = [0.08797252, 0.11774109, 0.11774109***REMOVED***
        y = kde.evaluate(x2***REMOVED***
        np.testing.assert_array_almost_equal(y, y_expected, 7***REMOVED***


def test_contiguous_regions(***REMOVED***:
    a, b, c = 3, 4, 5
    # Starts and ends with True
    mask = [True***REMOVED****a + [False***REMOVED****b + [True***REMOVED****c
    expected = [(0, a***REMOVED***, (a+b, a+b+c***REMOVED******REMOVED***
    assert_equal(mlab.contiguous_regions(mask***REMOVED***, expected***REMOVED***
    d, e = 6, 7
    # Starts with True ends with False
    mask = mask + [False***REMOVED****e
    assert_equal(mlab.contiguous_regions(mask***REMOVED***, expected***REMOVED***
    # Starts with False ends with True
    mask = [False***REMOVED****d + mask[:-e***REMOVED***
    expected = [(d, d+a***REMOVED***, (d+a+b, d+a+b+c***REMOVED******REMOVED***
    assert_equal(mlab.contiguous_regions(mask***REMOVED***, expected***REMOVED***
    # Starts and ends with False
    mask = mask + [False***REMOVED****e
    assert_equal(mlab.contiguous_regions(mask***REMOVED***, expected***REMOVED***
    # No True in mask
    assert_equal(mlab.contiguous_regions([False***REMOVED****5***REMOVED***, [***REMOVED******REMOVED***
    # Empty mask
    assert_equal(mlab.contiguous_regions([***REMOVED******REMOVED***, [***REMOVED******REMOVED***


def test_psd_onesided_norm(***REMOVED***:
    u = np.array([0, 1, 2, 3, 1, 2, 1***REMOVED******REMOVED***
    dt = 1.0
    Su = np.abs(np.fft.fft(u***REMOVED*** * dt***REMOVED*****2 / float(dt * u.size***REMOVED***
    P, f = mlab.psd(u, NFFT=u.size, Fs=1/dt, window=mlab.window_none,
                    detrend=mlab.detrend_none, noverlap=0, pad_to=None,
                    scale_by_freq=None,
                    sides='onesided'***REMOVED***
    Su_1side = np.append([Su[0***REMOVED******REMOVED***, Su[1:4***REMOVED*** + Su[4:***REMOVED***[::-1***REMOVED******REMOVED***
    assert_allclose(P, Su_1side, atol=1e-06***REMOVED***


if __name__ == '__main__':
    import nose
    import sys

    args = ['-s', '--with-doctest'***REMOVED***
    argv = sys.argv
    argv = argv[:1***REMOVED*** + args + argv[1:***REMOVED***
    nose.runmodule(argv=argv, exit=False***REMOVED***
