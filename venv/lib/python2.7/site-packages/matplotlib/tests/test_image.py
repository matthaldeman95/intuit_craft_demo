from __future__ import (absolute_import, division, print_function,
                        unicode_literals***REMOVED***

from matplotlib.externals import six
import sys
import io
***REMOVED***

from nose.plugins.attrib import attr

import numpy as np

from matplotlib.testing.decorators import (image_comparison,
                                           knownfailureif, cleanup***REMOVED***
from matplotlib.image import (BboxImage, imread, NonUniformImage,
                              AxesImage, FigureImage, PcolorImage***REMOVED***
from matplotlib.transforms import Bbox
from matplotlib import rcParams
import matplotlib.pyplot as plt

from numpy.testing import assert_array_equal


import nose

***REMOVED***
    from PIL import Image
    del Image
    HAS_PIL = True
except ImportError:
    HAS_PIL = False


@image_comparison(baseline_images=['image_interps'***REMOVED******REMOVED***
def test_image_interps(***REMOVED***:
    'make the basic nearest, bilinear and bicubic interps'
    X = np.arange(100***REMOVED***
    X = X.reshape(5, 20***REMOVED***

    fig = plt.figure(***REMOVED***
    ax1 = fig.add_subplot(311***REMOVED***
    ax1.imshow(X, interpolation='nearest'***REMOVED***
    ax1.set_title('three interpolations'***REMOVED***
    ax1.set_ylabel('nearest'***REMOVED***

    ax2 = fig.add_subplot(312***REMOVED***
    ax2.imshow(X, interpolation='bilinear'***REMOVED***
    ax2.set_ylabel('bilinear'***REMOVED***

    ax3 = fig.add_subplot(313***REMOVED***
    ax3.imshow(X, interpolation='bicubic'***REMOVED***
    ax3.set_ylabel('bicubic'***REMOVED***

@image_comparison(baseline_images=['interp_nearest_vs_none'***REMOVED***,
                  extensions=['pdf', 'svg'***REMOVED***, remove_text=True***REMOVED***
def test_interp_nearest_vs_none(***REMOVED***:
    'Test the effect of "nearest" and "none" interpolation'
    # Setting dpi to something really small makes the difference very
    # visible. This works fine with pdf, since the dpi setting doesn't
    # affect anything but images, but the agg output becomes unusably
    # small.
    rcParams['savefig.dpi'***REMOVED*** = 3
    X = np.array([[[218, 165, 32***REMOVED***, [122, 103, 238***REMOVED******REMOVED***,
                  [[127, 255, 0***REMOVED***, [255, 99, 71***REMOVED******REMOVED******REMOVED***, dtype=np.uint8***REMOVED***
    fig = plt.figure(***REMOVED***
    ax1 = fig.add_subplot(121***REMOVED***
    ax1.imshow(X, interpolation='none'***REMOVED***
    ax1.set_title('interpolation none'***REMOVED***
    ax2 = fig.add_subplot(122***REMOVED***
    ax2.imshow(X, interpolation='nearest'***REMOVED***
    ax2.set_title('interpolation nearest'***REMOVED***


@image_comparison(baseline_images=['figimage-0', 'figimage-1'***REMOVED***, extensions=['png'***REMOVED******REMOVED***
def test_figimage(***REMOVED***:
    'test the figimage method'

    for suppressComposite in False, True:
        fig = plt.figure(figsize=(2,2***REMOVED***, dpi=100***REMOVED***
        fig.suppressComposite = suppressComposite
        x,y = np.ix_(np.arange(100.0***REMOVED***/100.0, np.arange(100.0***REMOVED***/100.0***REMOVED***
        z = np.sin(x**2 + y**2 - x*y***REMOVED***
        c = np.sin(20*x**2 + 50*y**2***REMOVED***
        img = z + c/5

        fig.figimage(img, xo=0, yo=0, origin='lower'***REMOVED***
        fig.figimage(img[::-1,:***REMOVED***, xo=0, yo=100, origin='lower'***REMOVED***
        fig.figimage(img[:,::-1***REMOVED***, xo=100, yo=0, origin='lower'***REMOVED***
        fig.figimage(img[::-1,::-1***REMOVED***, xo=100, yo=100, origin='lower'***REMOVED***

@cleanup
def test_image_python_io(***REMOVED***:
    fig = plt.figure(***REMOVED***
    ax = fig.add_subplot(111***REMOVED***
    ax.plot([1,2,3***REMOVED******REMOVED***
    buffer = io.BytesIO(***REMOVED***
    fig.savefig(buffer***REMOVED***
    buffer.seek(0***REMOVED***
    plt.imread(buffer***REMOVED***

@knownfailureif(not HAS_PIL***REMOVED***
def test_imread_pil_uint16(***REMOVED***:
    img = plt.imread(os.path.join(os.path.dirname(__file__***REMOVED***,
                     'baseline_images', 'test_image', 'uint16.tif'***REMOVED******REMOVED***
    assert (img.dtype == np.uint16***REMOVED***
    assert np.sum(img***REMOVED*** == 134184960

# def test_image_unicode_io(***REMOVED***:
#     fig = plt.figure(***REMOVED***
#     ax = fig.add_subplot(111***REMOVED***
#     ax.plot([1,2,3***REMOVED******REMOVED***
#     fname = u"\u0a3a\u0a3a.png"
#     fig.savefig(fname***REMOVED***
#     plt.imread(fname***REMOVED***
#     os.remove(fname***REMOVED***

def test_imsave(***REMOVED***:
    # The goal here is that the user can specify an output logical DPI
    # for the image, but this will not actually add any extra pixels
    # to the image, it will merely be used for metadata purposes.

    # So we do the traditional case (dpi == 1***REMOVED***, and the new case (dpi
    # == 100***REMOVED*** and read the resulting PNG files back in and make sure
    # the data is 100% identical.
    from numpy import random
    random.seed(1***REMOVED***
    data = random.rand(256, 128***REMOVED***

    buff_dpi1 = io.BytesIO(***REMOVED***
    plt.imsave(buff_dpi1, data, dpi=1***REMOVED***

    buff_dpi100 = io.BytesIO(***REMOVED***
    plt.imsave(buff_dpi100, data, dpi=100***REMOVED***

    buff_dpi1.seek(0***REMOVED***
    arr_dpi1 = plt.imread(buff_dpi1***REMOVED***

    buff_dpi100.seek(0***REMOVED***
    arr_dpi100 = plt.imread(buff_dpi100***REMOVED***

    assert arr_dpi1.shape == (256, 128, 4***REMOVED***
    assert arr_dpi100.shape == (256, 128, 4***REMOVED***

    assert_array_equal(arr_dpi1, arr_dpi100***REMOVED***

def test_imsave_color_alpha(***REMOVED***:
    # Test that imsave accept arrays with ndim=3 where the third dimension is
    # color and alpha without raising any exceptions, and that the data is
    # acceptably preserved through a save/read roundtrip.
    from numpy import random
    random.seed(1***REMOVED***
    data = random.rand(256, 128, 4***REMOVED***

    buff = io.BytesIO(***REMOVED***
    plt.imsave(buff, data***REMOVED***

    buff.seek(0***REMOVED***
    arr_buf = plt.imread(buff***REMOVED***

    # Recreate the float -> uint8 -> float32 conversion of the data
    data = (255*data***REMOVED***.astype('uint8'***REMOVED***.astype('float32'***REMOVED***/255
    # Wherever alpha values were rounded down to 0, the rgb values all get set
    # to 0 during imsave (this is reasonable behaviour***REMOVED***.
    # Recreate that here:
    for j in range(3***REMOVED***:
        data[data[:, :, 3***REMOVED*** == 0, j***REMOVED*** = 1

    assert_array_equal(data, arr_buf***REMOVED***


@cleanup
def test_cursor_data(***REMOVED***:
    from matplotlib.backend_bases import MouseEvent

    fig, ax = plt.subplots(***REMOVED***
    im = ax.imshow(np.arange(100***REMOVED***.reshape(10, 10***REMOVED***, origin='upper'***REMOVED***

    x, y = 4, 4
    xdisp, ydisp = ax.transData.transform_point([x, y***REMOVED******REMOVED***

    event = MouseEvent('motion_notify_event', fig.canvas, xdisp, ydisp***REMOVED***
    z = im.get_cursor_data(event***REMOVED***
    assert z == 44, "Did not get 44, got %d" % z

    # Now try for a point outside the image
    # Tests issue #4957
    x, y = 10.1, 4
    xdisp, ydisp = ax.transData.transform_point([x, y***REMOVED******REMOVED***

    event = MouseEvent('motion_notify_event', fig.canvas, xdisp, ydisp***REMOVED***
    z = im.get_cursor_data(event***REMOVED***
    assert z is None, "Did not get None, got %d" % z

    # Hmm, something is wrong here... I get 0, not None...
    # But, this works further down in the tests with extents flipped
    #x, y = 0.1, -0.1
    #xdisp, ydisp = ax.transData.transform_point([x, y***REMOVED******REMOVED***
    #event = MouseEvent('motion_notify_event', fig.canvas, xdisp, ydisp***REMOVED***
    #z = im.get_cursor_data(event***REMOVED***
    #assert z is None, "Did not get None, got %d" % z

    ax.clear(***REMOVED***
    # Now try with the extents flipped.
    im = ax.imshow(np.arange(100***REMOVED***.reshape(10, 10***REMOVED***, origin='lower'***REMOVED***

    x, y = 4, 4
    xdisp, ydisp = ax.transData.transform_point([x, y***REMOVED******REMOVED***

    event = MouseEvent('motion_notify_event', fig.canvas, xdisp, ydisp***REMOVED***
    z = im.get_cursor_data(event***REMOVED***
    assert z == 44, "Did not get 44, got %d" % z

    fig, ax = plt.subplots(***REMOVED***
    im = ax.imshow(np.arange(100***REMOVED***.reshape(10, 10***REMOVED***, extent=[0, 0.5, 0, 0.5***REMOVED******REMOVED***

    x, y = 0.25, 0.25
    xdisp, ydisp = ax.transData.transform_point([x, y***REMOVED******REMOVED***

    event = MouseEvent('motion_notify_event', fig.canvas, xdisp, ydisp***REMOVED***
    z = im.get_cursor_data(event***REMOVED***
    assert z == 55, "Did not get 55, got %d" % z

    # Now try for a point outside the image
    # Tests issue #4957
    x, y = 0.75, 0.25
    xdisp, ydisp = ax.transData.transform_point([x, y***REMOVED******REMOVED***

    event = MouseEvent('motion_notify_event', fig.canvas, xdisp, ydisp***REMOVED***
    z = im.get_cursor_data(event***REMOVED***
    assert z is None, "Did not get None, got %d" % z

    x, y = 0.01, -0.01
    xdisp, ydisp = ax.transData.transform_point([x, y***REMOVED******REMOVED***

    event = MouseEvent('motion_notify_event', fig.canvas, xdisp, ydisp***REMOVED***
    z = im.get_cursor_data(event***REMOVED***
    assert z is None, "Did not get None, got %d" % z


@image_comparison(baseline_images=['image_clip'***REMOVED******REMOVED***
def test_image_clip(***REMOVED***:
    from math import pi

    fig = plt.figure(***REMOVED***
    ax = fig.add_subplot(111, projection='hammer'***REMOVED***

    d = [[1,2***REMOVED***,[3,4***REMOVED******REMOVED***

    im = ax.imshow(d, extent=(-pi,pi,-pi/2,pi/2***REMOVED******REMOVED***

@image_comparison(baseline_images=['image_cliprect'***REMOVED******REMOVED***
def test_image_cliprect(***REMOVED***:
    import matplotlib.patches as patches

    fig = plt.figure(***REMOVED***
    ax = fig.add_subplot(111***REMOVED***
    d = [[1,2***REMOVED***,[3,4***REMOVED******REMOVED***

    im = ax.imshow(d, extent=(0,5,0,5***REMOVED******REMOVED***

    rect = patches.Rectangle(xy=(1,1***REMOVED***, width=2, height=2, transform=im.axes.transData***REMOVED***
    im.set_clip_path(rect***REMOVED***

@image_comparison(baseline_images=['imshow'***REMOVED***, remove_text=True***REMOVED***
def test_imshow(***REMOVED***:
    import numpy as np
    import matplotlib.pyplot as plt

    fig = plt.figure(***REMOVED***
    arr = np.arange(100***REMOVED***.reshape((10, 10***REMOVED******REMOVED***
    ax = fig.add_subplot(111***REMOVED***
    ax.imshow(arr, interpolation="bilinear", extent=(1,2,1,2***REMOVED******REMOVED***
    ax.set_xlim(0,3***REMOVED***
    ax.set_ylim(0,3***REMOVED***

@image_comparison(baseline_images=['no_interpolation_origin'***REMOVED***, remove_text=True***REMOVED***
def test_no_interpolation_origin(***REMOVED***:
    fig = plt.figure(***REMOVED***
    ax = fig.add_subplot(211***REMOVED***
    ax.imshow(np.arange(100***REMOVED***.reshape((2, 50***REMOVED******REMOVED***, origin="lower", interpolation='none'***REMOVED***

    ax = fig.add_subplot(212***REMOVED***
    ax.imshow(np.arange(100***REMOVED***.reshape((2, 50***REMOVED******REMOVED***, interpolation='none'***REMOVED***

@image_comparison(baseline_images=['image_shift'***REMOVED***, remove_text=True,
                  extensions=['pdf', 'svg'***REMOVED******REMOVED***
def test_image_shift(***REMOVED***:
    from matplotlib.colors import LogNorm

    imgData = [[1.0/(x***REMOVED*** + 1.0/(y***REMOVED*** for x in range(1,100***REMOVED******REMOVED*** for y in range(1,100***REMOVED******REMOVED***
    tMin=734717.945208
    tMax=734717.946366

    fig = plt.figure(***REMOVED***
    ax = fig.add_subplot(111***REMOVED***
    ax.imshow(imgData, norm=LogNorm(***REMOVED***, interpolation='none',
              extent=(tMin, tMax, 1, 100***REMOVED******REMOVED***
    ax.set_aspect('auto'***REMOVED***

@cleanup
def test_image_edges(***REMOVED***:
    f = plt.figure(figsize=[1, 1***REMOVED******REMOVED***
    ax = f.add_axes([0, 0, 1, 1***REMOVED***, frameon=False***REMOVED***

    data = np.tile(np.arange(12***REMOVED***, 15***REMOVED***.reshape(20, 9***REMOVED***

    im = ax.imshow(data, origin='upper',
                   extent=[-10, 10, -10, 10***REMOVED***, interpolation='none',
                   cmap='gray'
                   ***REMOVED***

    x = y = 2
    ax.set_xlim([-x, x***REMOVED******REMOVED***
    ax.set_ylim([-y, y***REMOVED******REMOVED***

    ax.set_xticks([***REMOVED******REMOVED***
    ax.set_yticks([***REMOVED******REMOVED***

    buf = io.BytesIO(***REMOVED***
    f.savefig(buf, facecolor=(0, 1, 0***REMOVED******REMOVED***

    buf.seek(0***REMOVED***

    im = plt.imread(buf***REMOVED***
    r, g, b, a = sum(im[:, 0***REMOVED******REMOVED***
    r, g, b, a = sum(im[:, -1***REMOVED******REMOVED***

    assert g != 100, 'Expected a non-green edge - but sadly, it was.'

@image_comparison(baseline_images=['image_composite_background'***REMOVED***, remove_text=True***REMOVED***
def test_image_composite_background(***REMOVED***:
    fig = plt.figure(***REMOVED***
    ax = fig.add_subplot(111***REMOVED***
    arr = np.arange(12***REMOVED***.reshape(4, 3***REMOVED***
    ax.imshow(arr, extent=[0, 2, 15, 0***REMOVED******REMOVED***
    ax.imshow(arr, extent=[4, 6, 15, 0***REMOVED******REMOVED***
    ax.set_axis_bgcolor((1, 0, 0, 0.5***REMOVED******REMOVED***
    ax.set_xlim([0, 12***REMOVED******REMOVED***

@image_comparison(baseline_images=['image_composite_alpha'***REMOVED***, remove_text=True***REMOVED***
def test_image_composite_alpha(***REMOVED***:
    ***REMOVED***
    Tests that the alpha value is recognized and correctly applied in the
    process of compositing images together.
    ***REMOVED***
    fig = plt.figure(***REMOVED***
    ax = fig.add_subplot(111***REMOVED***
    arr = np.zeros((11, 21, 4***REMOVED******REMOVED***
    arr[:, :, 0***REMOVED*** = 1
    arr[:, :, 3***REMOVED*** = np.concatenate((np.arange(0, 1.1, 0.1***REMOVED***, np.arange(0, 1, 0.1***REMOVED***[::-1***REMOVED******REMOVED******REMOVED***
    arr2 = np.zeros((21, 11, 4***REMOVED******REMOVED***
    arr2[:, :, 0***REMOVED*** = 1
    arr2[:, :, 1***REMOVED*** = 1
    arr2[:, :, 3***REMOVED*** = np.concatenate((np.arange(0, 1.1, 0.1***REMOVED***, np.arange(0, 1, 0.1***REMOVED***[::-1***REMOVED******REMOVED******REMOVED***[:, np.newaxis***REMOVED***
    ax.imshow(arr, extent=[1, 2, 5, 0***REMOVED***, alpha=0.3***REMOVED***
    ax.imshow(arr, extent=[2, 3, 5, 0***REMOVED***, alpha=0.6***REMOVED***
    ax.imshow(arr, extent=[3, 4, 5, 0***REMOVED******REMOVED***
    ax.imshow(arr2, extent=[0, 5, 1, 2***REMOVED******REMOVED***
    ax.imshow(arr2, extent=[0, 5, 2, 3***REMOVED***, alpha=0.6***REMOVED***
    ax.imshow(arr2, extent=[0, 5, 3, 4***REMOVED***, alpha=0.3***REMOVED***
    ax.set_axis_bgcolor((0, 0.5, 0, 1***REMOVED******REMOVED***
    ax.set_xlim([0, 5***REMOVED******REMOVED***
    ax.set_ylim([5, 0***REMOVED******REMOVED***


@image_comparison(baseline_images=['rasterize_10dpi'***REMOVED***, extensions=['pdf','svg'***REMOVED***, tol=5e-2, remove_text=True***REMOVED***
def test_rasterize_dpi(***REMOVED***:
    # This test should check rasterized rendering with high output resolution.
    # It plots a rasterized line and a normal image with implot. So it will catch
    # when images end up in the wrong place in case of non-standard dpi setting.
    # Instead of high-res rasterization i use low-res.  Therefore the fact that the
    # resolution is non-standard is is easily checked by image_comparison.
    import numpy as np
    import matplotlib.pyplot as plt

    img = np.asarray([[1, 2***REMOVED***, [3, 4***REMOVED******REMOVED******REMOVED***

    fig, axes = plt.subplots(1, 3, figsize = (3, 1***REMOVED******REMOVED***

    axes[0***REMOVED***.imshow(img***REMOVED***

    axes[1***REMOVED***.plot([0,1***REMOVED***,[0,1***REMOVED***, linewidth=20., rasterized=True***REMOVED***
    axes[1***REMOVED***.set(xlim = (0,1***REMOVED***, ylim = (-1, 2***REMOVED******REMOVED***

    axes[2***REMOVED***.plot([0,1***REMOVED***,[0,1***REMOVED***, linewidth=20.***REMOVED***
    axes[2***REMOVED***.set(xlim = (0,1***REMOVED***, ylim = (-1, 2***REMOVED******REMOVED***

    # Low-dpi PDF rasterization errors prevent proper image comparison tests.
    # Hide detailed structures like the axes spines.
    for ax in axes:
        ax.set_xticks([***REMOVED******REMOVED***
        ax.set_yticks([***REMOVED******REMOVED***
        for spine in ax.spines.values(***REMOVED***:
            spine.set_visible(False***REMOVED***

    rcParams['savefig.dpi'***REMOVED*** = 10


@image_comparison(baseline_images=['bbox_image_inverted'***REMOVED***,
                  extensions=['png', 'pdf'***REMOVED******REMOVED***
def test_bbox_image_inverted(***REMOVED***:
    # This is just used to produce an image to feed to BboxImage
    fig = plt.figure(***REMOVED***
    axes = fig.add_subplot(111***REMOVED***
    axes.plot([1, 2, 3***REMOVED******REMOVED***

    im_buffer = io.BytesIO(***REMOVED***
    fig.savefig(im_buffer***REMOVED***
    im_buffer.seek(0***REMOVED***
    image = imread(im_buffer***REMOVED***

    bbox_im = BboxImage(Bbox([[100, 100***REMOVED***, [0, 0***REMOVED******REMOVED******REMOVED******REMOVED***
    bbox_im.set_data(image***REMOVED***
    axes.add_artist(bbox_im***REMOVED***


@cleanup
def test_get_window_extent_for_AxisImage(***REMOVED***:
    # Create a figure of known size (1000x1000 pixels***REMOVED***, place an image
    # object at a given location and check that get_window_extent(***REMOVED***
    # returns the correct bounding box values (in pixels***REMOVED***.

    im = np.array([[0.25, 0.75, 1.0, 0.75***REMOVED***, [0.1, 0.65, 0.5, 0.4***REMOVED***, \
        [0.6, 0.3, 0.0, 0.2***REMOVED***, [0.7, 0.9, 0.4, 0.6***REMOVED******REMOVED******REMOVED***
    fig = plt.figure(figsize=(10, 10***REMOVED***, dpi=100***REMOVED***
    ax = plt.subplot(***REMOVED***
    ax.set_position([0, 0, 1, 1***REMOVED******REMOVED***
    ax.set_xlim(0, 1***REMOVED***
    ax.set_ylim(0, 1***REMOVED***
    im_obj = ax.imshow(im, extent=[0.4, 0.7, 0.2, 0.9***REMOVED***, interpolation='nearest'***REMOVED***

    fig.canvas.draw(***REMOVED***
    renderer = fig.canvas.renderer
    im_bbox = im_obj.get_window_extent(renderer***REMOVED***

    assert_array_equal(im_bbox.get_points(***REMOVED***, [[400, 200***REMOVED***, [700, 900***REMOVED******REMOVED******REMOVED***


@image_comparison(baseline_images=['zoom_and_clip_upper_origin'***REMOVED***,
                  remove_text=True,
                  extensions=['png'***REMOVED******REMOVED***
def test_zoom_and_clip_upper_origin(***REMOVED***:
    image = np.arange(100***REMOVED***
    image = image.reshape((10, 10***REMOVED******REMOVED***

    fig = plt.figure(***REMOVED***
    ax = fig.add_subplot(111***REMOVED***
    ax.imshow(image***REMOVED***
    ax.set_ylim(2.0, -0.5***REMOVED***
    ax.set_xlim(-0.5, 2.0***REMOVED***


@cleanup
def test_nonuniformimage_setcmap(***REMOVED***:
    ax = plt.gca(***REMOVED***
    im = NonUniformImage(ax***REMOVED***
    im.set_cmap('Blues'***REMOVED***


@cleanup
def test_nonuniformimage_setnorm(***REMOVED***:
    ax = plt.gca(***REMOVED***
    im = NonUniformImage(ax***REMOVED***
    im.set_norm(plt.Normalize(***REMOVED******REMOVED***


@cleanup
def test_nonuniformimage_setdata(***REMOVED***:
    ax = plt.gca(***REMOVED***
    im = NonUniformImage(ax***REMOVED***
    x = np.arange(3, dtype=np.float64***REMOVED***
    y = np.arange(4, dtype=np.float64***REMOVED***
    z = np.arange(12, dtype=np.float64***REMOVED***.reshape((4, 3***REMOVED******REMOVED***
    im.set_data(x, y, z***REMOVED***
    x[0***REMOVED*** = y[0***REMOVED*** = z[0, 0***REMOVED*** = 9.9
    assert im._A[0, 0***REMOVED*** == im._Ax[0***REMOVED*** == im._Ay[0***REMOVED*** == 0, 'value changed'


@cleanup
def test_axesimage_setdata(***REMOVED***:
    ax = plt.gca(***REMOVED***
    im = AxesImage(ax***REMOVED***
    z = np.arange(12, dtype=np.float64***REMOVED***.reshape((4, 3***REMOVED******REMOVED***
    im.set_data(z***REMOVED***
    z[0, 0***REMOVED*** = 9.9
    assert im._A[0, 0***REMOVED*** == 0, 'value changed'


@cleanup
def test_figureimage_setdata(***REMOVED***:
    fig = plt.gcf(***REMOVED***
    im = FigureImage(fig***REMOVED***
    z = np.arange(12, dtype=np.float64***REMOVED***.reshape((4, 3***REMOVED******REMOVED***
    im.set_data(z***REMOVED***
    z[0, 0***REMOVED*** = 9.9
    assert im._A[0, 0***REMOVED*** == 0, 'value changed'


@cleanup
def test_pcolorimage_setdata(***REMOVED***:
    ax = plt.gca(***REMOVED***
    im = PcolorImage(ax***REMOVED***
    x = np.arange(3, dtype=np.float64***REMOVED***
    y = np.arange(4, dtype=np.float64***REMOVED***
    z = np.arange(6, dtype=np.float64***REMOVED***.reshape((3, 2***REMOVED******REMOVED***
    im.set_data(x, y, z***REMOVED***
    x[0***REMOVED*** = y[0***REMOVED*** = z[0, 0***REMOVED*** = 9.9
    assert im._A[0, 0***REMOVED*** == im._Ax[0***REMOVED*** == im._Ay[0***REMOVED*** == 0, 'value changed'


@cleanup
def test_minimized_rasterized(***REMOVED***:
    # This ensures that the rasterized content in the colorbars is
    # only as thick as the colorbar, and doesn't extend to other parts
    # of the image.  See #5814.  While the original bug exists only
    # in Postscript, the best way to detect it is to generate SVG
    # and then parse the output to make sure the two colorbar images
    # are the same size.
    if sys.version_info[:2***REMOVED*** < (2, 7***REMOVED***:
        raise nose.SkipTest("xml.etree.ElementTree.Element.iter "
                            "added in py 2.7"***REMOVED***

    from xml.etree import ElementTree

    np.random.seed(0***REMOVED***
    data = np.random.rand(10, 10***REMOVED***

    fig, ax = plt.subplots(1, 2***REMOVED***
    p1 = ax[0***REMOVED***.pcolormesh(data***REMOVED***
    p2 = ax[1***REMOVED***.pcolormesh(data***REMOVED***

    plt.colorbar(p1, ax=ax[0***REMOVED******REMOVED***
    plt.colorbar(p2, ax=ax[1***REMOVED******REMOVED***

    buff = io.BytesIO(***REMOVED***
    plt.savefig(buff, format='svg'***REMOVED***

    buff = io.BytesIO(buff.getvalue(***REMOVED******REMOVED***
    tree = ElementTree.parse(buff***REMOVED***
    width = None
    for image in tree.iter('image'***REMOVED***:
        if width is None:
            width = image['width'***REMOVED***
        else:
            if image['width'***REMOVED*** != width:
                assert False


@attr('network'***REMOVED***
def test_load_from_url(***REMOVED***:
    req = six.moves.urllib.request.urlopen(
        "http://matplotlib.org/_static/logo_sidebar_horiz.png"***REMOVED***
    Z = plt.imread(req***REMOVED***


if __name__=='__main__':
    import nose
    nose.runmodule(argv=['-s','--with-doctest'***REMOVED***, exit=False***REMOVED***
