from __future__ import (absolute_import, division, print_function,
                        unicode_literals***REMOVED***

from matplotlib.externals import six
import itertools
from distutils.version import LooseVersion as V

from nose.tools import assert_raises, assert_equal, assert_true

***REMOVED***
    # this is not available in nose + py2.6
    from nose.tools import assert_sequence_equal
except ImportError:
    assert_sequence_equal = None

import numpy as np
from numpy.testing.utils import assert_array_equal, assert_array_almost_equal
from nose.plugins.skip import SkipTest

import matplotlib.colors as mcolors
import matplotlib.cm as cm
import matplotlib.cbook as cbook
import matplotlib.pyplot as plt
from matplotlib.testing.decorators import (image_comparison,
                                           cleanup, knownfailureif***REMOVED***


def test_resample(***REMOVED***:
    ***REMOVED***
    Github issue #6025 pointed to incorrect ListedColormap._resample;
    here we test the method for LinearSegmentedColormap as well.
    ***REMOVED***
    n = 101
    colorlist = np.empty((n, 4***REMOVED***, float***REMOVED***
    colorlist[:, 0***REMOVED*** = np.linspace(0, 1, n***REMOVED***
    colorlist[:, 1***REMOVED*** = 0.2
    colorlist[:, 2***REMOVED*** = np.linspace(1, 0, n***REMOVED***
    colorlist[:, 3***REMOVED*** = 0.7
    lsc = mcolors.LinearSegmentedColormap.from_list('lsc', colorlist***REMOVED***
    lc = mcolors.ListedColormap(colorlist***REMOVED***
    lsc3 = lsc._resample(3***REMOVED***
    lc3 = lc._resample(3***REMOVED***
    expected = np.array([[0.0, 0.2, 1.0, 0.7***REMOVED***,
                         [0.5, 0.2, 0.5, 0.7***REMOVED***,
                         [1.0, 0.2, 0.0, 0.7***REMOVED******REMOVED***, float***REMOVED***
    assert_array_almost_equal(lsc3([0, 0.5, 1***REMOVED******REMOVED***, expected***REMOVED***
    assert_array_almost_equal(lc3([0, 0.5, 1***REMOVED******REMOVED***, expected***REMOVED***


def test_colormap_endian(***REMOVED***:
    ***REMOVED***
    Github issue #1005: a bug in putmask caused erroneous
    mapping of 1.0 when input from a non-native-byteorder
    array.
    ***REMOVED***
    cmap = cm.get_cmap("jet"***REMOVED***
    # Test under, over, and invalid along with values 0 and 1.
    a = [-0.5, 0, 0.5, 1, 1.5, np.nan***REMOVED***
    for dt in ["f2", "f4", "f8"***REMOVED***:
        anative = np.ma.masked_invalid(np.array(a, dtype=dt***REMOVED******REMOVED***
        aforeign = anative.byteswap(***REMOVED***.newbyteorder(***REMOVED***
        #print(anative.dtype.isnative, aforeign.dtype.isnative***REMOVED***
        assert_array_equal(cmap(anative***REMOVED***, cmap(aforeign***REMOVED******REMOVED***


def test_BoundaryNorm(***REMOVED***:
    ***REMOVED***
    Github issue #1258: interpolation was failing with numpy
    1.7 pre-release.
    ***REMOVED***

    boundaries = [0, 1.1, 2.2***REMOVED***
    vals = [-1, 0, 1, 2, 2.2, 4***REMOVED***

    # Without interpolation
    expected = [-1, 0, 0, 1, 2, 2***REMOVED***
    ncolors = len(boundaries***REMOVED*** - 1
    bn = mcolors.BoundaryNorm(boundaries, ncolors***REMOVED***
    assert_array_equal(bn(vals***REMOVED***, expected***REMOVED***

    # ncolors != len(boundaries***REMOVED*** - 1 triggers interpolation
    expected = [-1, 0, 0, 2, 3, 3***REMOVED***
    ncolors = len(boundaries***REMOVED***
    bn = mcolors.BoundaryNorm(boundaries, ncolors***REMOVED***
    assert_array_equal(bn(vals***REMOVED***, expected***REMOVED***

    # more boundaries for a third color
    boundaries = [0, 1, 2, 3***REMOVED***
    vals = [-1, 0.1, 1.1, 2.2, 4***REMOVED***
    ncolors = 5
    expected = [-1, 0, 2, 4, 5***REMOVED***
    bn = mcolors.BoundaryNorm(boundaries, ncolors***REMOVED***
    assert_array_equal(bn(vals***REMOVED***, expected***REMOVED***

    # a scalar as input should not trigger an error and should return a scalar
    boundaries = [0, 1, 2***REMOVED***
    vals = [-1, 0.1, 1.1, 2.2***REMOVED***
    bn = mcolors.BoundaryNorm(boundaries, 2***REMOVED***
    expected = [-1, 0, 1, 2***REMOVED***
    for v, ex in zip(vals, expected***REMOVED***:
        ret = bn(v***REMOVED***
        assert_true(isinstance(ret, six.integer_types***REMOVED******REMOVED***
        assert_array_equal(ret, ex***REMOVED***
        assert_array_equal(bn([v***REMOVED******REMOVED***, ex***REMOVED***

    # same with interp
    bn = mcolors.BoundaryNorm(boundaries, 3***REMOVED***
    expected = [-1, 0, 2, 3***REMOVED***
    for v, ex in zip(vals, expected***REMOVED***:
        ret = bn(v***REMOVED***
        assert_true(isinstance(ret, six.integer_types***REMOVED******REMOVED***
        assert_array_equal(ret, ex***REMOVED***
        assert_array_equal(bn([v***REMOVED******REMOVED***, ex***REMOVED***

    # Clipping
    bn = mcolors.BoundaryNorm(boundaries, 3, clip=True***REMOVED***
    expected = [0, 0, 2, 2***REMOVED***
    for v, ex in zip(vals, expected***REMOVED***:
        ret = bn(v***REMOVED***
        assert_true(isinstance(ret, six.integer_types***REMOVED******REMOVED***
        assert_array_equal(ret, ex***REMOVED***
        assert_array_equal(bn([v***REMOVED******REMOVED***, ex***REMOVED***

    # Masked arrays
    boundaries = [0, 1.1, 2.2***REMOVED***
    vals = np.ma.masked_invalid([-1., np.NaN, 0, 1.4, 9***REMOVED******REMOVED***

    # Without interpolation
    ncolors = len(boundaries***REMOVED*** - 1
    bn = mcolors.BoundaryNorm(boundaries, ncolors***REMOVED***
    expected = np.ma.masked_array([-1, -99, 0, 1, 2***REMOVED***, mask=[0, 1, 0, 0, 0***REMOVED******REMOVED***
    assert_array_equal(bn(vals***REMOVED***, expected***REMOVED***

    # With interpolation
    bn = mcolors.BoundaryNorm(boundaries, len(boundaries***REMOVED******REMOVED***
    expected = np.ma.masked_array([-1, -99, 0, 2, 3***REMOVED***, mask=[0, 1, 0, 0, 0***REMOVED******REMOVED***
    assert_array_equal(bn(vals***REMOVED***, expected***REMOVED***

    # Non-trivial masked arrays
    vals = np.ma.masked_invalid([np.Inf, np.NaN***REMOVED******REMOVED***
    assert_true(np.all(bn(vals***REMOVED***.mask***REMOVED******REMOVED***
    vals = np.ma.masked_invalid([np.Inf***REMOVED******REMOVED***
    assert_true(np.all(bn(vals***REMOVED***.mask***REMOVED******REMOVED***


def test_LogNorm(***REMOVED***:
    ***REMOVED***
    LogNorm ignored clip, now it has the same
    behavior as Normalize, e.g., values > vmax are bigger than 1
    without clip, with clip they are 1.
    ***REMOVED***
    ln = mcolors.LogNorm(clip=True, vmax=5***REMOVED***
    assert_array_equal(ln([1, 6***REMOVED******REMOVED***, [0, 1.0***REMOVED******REMOVED***


def test_PowerNorm(***REMOVED***:
    a = np.array([0, 0.5, 1, 1.5***REMOVED***, dtype=np.float***REMOVED***
    pnorm = mcolors.PowerNorm(1***REMOVED***
    norm = mcolors.Normalize(***REMOVED***
    assert_array_almost_equal(norm(a***REMOVED***, pnorm(a***REMOVED******REMOVED***

    a = np.array([-0.5, 0, 2, 4, 8***REMOVED***, dtype=np.float***REMOVED***
    expected = [0, 0, 1/16, 1/4, 1***REMOVED***
    pnorm = mcolors.PowerNorm(2, vmin=0, vmax=8***REMOVED***
    assert_array_almost_equal(pnorm(a***REMOVED***, expected***REMOVED***
    assert_equal(pnorm(a[0***REMOVED******REMOVED***, expected[0***REMOVED******REMOVED***
    assert_equal(pnorm(a[2***REMOVED******REMOVED***, expected[2***REMOVED******REMOVED***
    assert_array_almost_equal(a[1:***REMOVED***, pnorm.inverse(pnorm(a***REMOVED******REMOVED***[1:***REMOVED******REMOVED***

    # Clip = True
    a = np.array([-0.5, 0, 1, 8, 16***REMOVED***, dtype=np.float***REMOVED***
    expected = [0, 0, 0, 1, 1***REMOVED***
    pnorm = mcolors.PowerNorm(2, vmin=2, vmax=8, clip=True***REMOVED***
    assert_array_almost_equal(pnorm(a***REMOVED***, expected***REMOVED***
    assert_equal(pnorm(a[0***REMOVED******REMOVED***, expected[0***REMOVED******REMOVED***
    assert_equal(pnorm(a[-1***REMOVED******REMOVED***, expected[-1***REMOVED******REMOVED***

    # Clip = True at call time
    a = np.array([-0.5, 0, 1, 8, 16***REMOVED***, dtype=np.float***REMOVED***
    expected = [0, 0, 0, 1, 1***REMOVED***
    pnorm = mcolors.PowerNorm(2, vmin=2, vmax=8, clip=False***REMOVED***
    assert_array_almost_equal(pnorm(a, clip=True***REMOVED***, expected***REMOVED***
    assert_equal(pnorm(a[0***REMOVED***, clip=True***REMOVED***, expected[0***REMOVED******REMOVED***
    assert_equal(pnorm(a[-1***REMOVED***, clip=True***REMOVED***, expected[-1***REMOVED******REMOVED***


def test_Normalize(***REMOVED***:
    norm = mcolors.Normalize(***REMOVED***
    vals = np.arange(-10, 10, 1, dtype=np.float***REMOVED***
    _inverse_tester(norm, vals***REMOVED***
    _scalar_tester(norm, vals***REMOVED***
    _mask_tester(norm, vals***REMOVED***


def test_SymLogNorm(***REMOVED***:
    ***REMOVED***
    Test SymLogNorm behavior
    ***REMOVED***
    norm = mcolors.SymLogNorm(3, vmax=5, linscale=1.2***REMOVED***
    vals = np.array([-30, -1, 2, 6***REMOVED***, dtype=np.float***REMOVED***
    normed_vals = norm(vals***REMOVED***
    expected = [0., 0.53980074, 0.826991, 1.02758204***REMOVED***
    assert_array_almost_equal(normed_vals, expected***REMOVED***
    _inverse_tester(norm, vals***REMOVED***
    _scalar_tester(norm, vals***REMOVED***
    _mask_tester(norm, vals***REMOVED***

    # Ensure that specifying vmin returns the same result as above
    norm = mcolors.SymLogNorm(3, vmin=-30, vmax=5, linscale=1.2***REMOVED***
    normed_vals = norm(vals***REMOVED***
    assert_array_almost_equal(normed_vals, expected***REMOVED***


def _inverse_tester(norm_instance, vals***REMOVED***:
    ***REMOVED***
    Checks if the inverse of the given normalization is working.
    ***REMOVED***
    assert_array_almost_equal(norm_instance.inverse(norm_instance(vals***REMOVED******REMOVED***, vals***REMOVED***


def _scalar_tester(norm_instance, vals***REMOVED***:
    ***REMOVED***
    Checks if scalars and arrays are handled the same way.
    Tests only for float.
    ***REMOVED***
    scalar_result = [norm_instance(float(v***REMOVED******REMOVED*** for v in vals***REMOVED***
    assert_array_almost_equal(scalar_result, norm_instance(vals***REMOVED******REMOVED***


def _mask_tester(norm_instance, vals***REMOVED***:
    ***REMOVED***
    Checks mask handling
    ***REMOVED***
    masked_array = np.ma.array(vals***REMOVED***
    masked_array[0***REMOVED*** = np.ma.masked
    assert_array_equal(masked_array.mask, norm_instance(masked_array***REMOVED***.mask***REMOVED***


@image_comparison(baseline_images=['levels_and_colors'***REMOVED***,
                  extensions=['png'***REMOVED******REMOVED***
def test_cmap_and_norm_from_levels_and_colors(***REMOVED***:
    data = np.linspace(-2, 4, 49***REMOVED***.reshape(7, 7***REMOVED***
    levels = [-1, 2, 2.5, 3***REMOVED***
    colors = ['red', 'green', 'blue', 'yellow', 'black'***REMOVED***
    extend = 'both'
    cmap, norm = mcolors.from_levels_and_colors(levels, colors, extend=extend***REMOVED***

    ax = plt.axes(***REMOVED***
    m = plt.pcolormesh(data, cmap=cmap, norm=norm***REMOVED***
    plt.colorbar(m***REMOVED***

    # Hide the axes labels (but not the colorbar ones, as they are useful***REMOVED***
    for lab in ax.get_xticklabels(***REMOVED*** + ax.get_yticklabels(***REMOVED***:
        lab.set_visible(False***REMOVED***


def test_cmap_and_norm_from_levels_and_colors2(***REMOVED***:
    levels = [-1, 2, 2.5, 3***REMOVED***
    colors = ['red', (0, 1, 0***REMOVED***, 'blue', (0.5, 0.5, 0.5***REMOVED***, (0.0, 0.0, 0.0, 1.0***REMOVED******REMOVED***
    clr = mcolors.colorConverter.to_rgba_array(colors***REMOVED***
    bad = (0.1, 0.1, 0.1, 0.1***REMOVED***
    no_color = (0.0, 0.0, 0.0, 0.0***REMOVED***
    masked_value = 'masked_value'

    # Define the test values which are of interest.
    # Note: levels are lev[i***REMOVED*** <= v < lev[i+1***REMOVED***
    tests = [('both', None, {-2: clr[0***REMOVED***,
                             -1: clr[1***REMOVED***,
                             2: clr[2***REMOVED***,
                             2.25: clr[2***REMOVED***,
                             3: clr[4***REMOVED***,
                             3.5: clr[4***REMOVED***,
                             masked_value: bad***REMOVED******REMOVED***,

             ('min', -1, {-2: clr[0***REMOVED***,
                          -1: clr[1***REMOVED***,
                          2: clr[2***REMOVED***,
                          2.25: clr[2***REMOVED***,
                          3: no_color,
                          3.5: no_color,
                          masked_value: bad***REMOVED******REMOVED***,

             ('max', -1, {-2: no_color,
                          -1: clr[0***REMOVED***,
                          2: clr[1***REMOVED***,
                          2.25: clr[1***REMOVED***,
                          3: clr[3***REMOVED***,
                          3.5: clr[3***REMOVED***,
                          masked_value: bad***REMOVED******REMOVED***,

             ('neither', -2, {-2: no_color,
                              -1: clr[0***REMOVED***,
                              2: clr[1***REMOVED***,
                              2.25: clr[1***REMOVED***,
                              3: no_color,
                              3.5: no_color,
                              masked_value: bad***REMOVED******REMOVED***,
             ***REMOVED***

    for extend, i1, cases in tests:
        cmap, norm = mcolors.from_levels_and_colors(levels, colors[0:i1***REMOVED***,
                                                    extend=extend***REMOVED***
        cmap.set_bad(bad***REMOVED***
        for d_val, expected_color in cases.items(***REMOVED***:
            if d_val == masked_value:
                d_val = np.ma.array([1***REMOVED***, mask=True***REMOVED***
            else:
                d_val = [d_val***REMOVED***
            assert_array_equal(expected_color, cmap(norm(d_val***REMOVED******REMOVED***[0***REMOVED***,
                               'Wih extend={0!r***REMOVED*** and data '
                               'value={1!r***REMOVED***'.format(extend, d_val***REMOVED******REMOVED***

    assert_raises(ValueError, mcolors.from_levels_and_colors, levels, colors***REMOVED***


def test_rgb_hsv_round_trip(***REMOVED***:
    for a_shape in [(500, 500, 3***REMOVED***, (500, 3***REMOVED***, (1, 3***REMOVED***, (3,***REMOVED******REMOVED***:
        np.random.seed(0***REMOVED***
        tt = np.random.random(a_shape***REMOVED***
        assert_array_almost_equal(tt,
            mcolors.hsv_to_rgb(mcolors.rgb_to_hsv(tt***REMOVED******REMOVED******REMOVED***
        assert_array_almost_equal(tt,
            mcolors.rgb_to_hsv(mcolors.hsv_to_rgb(tt***REMOVED******REMOVED******REMOVED***


@cleanup
def test_autoscale_masked(***REMOVED***:
    # Test for #2336. Previously fully masked data would trigger a ValueError.
    data = np.ma.masked_all((12, 20***REMOVED******REMOVED***
    plt.pcolor(data***REMOVED***
    plt.draw(***REMOVED***


def test_colors_no_float(***REMOVED***:
    # Gray must be a string to distinguish 3-4 grays from RGB or RGBA.

    def gray_from_float_rgb(***REMOVED***:
        return mcolors.colorConverter.to_rgb(0.4***REMOVED***

    def gray_from_float_rgba(***REMOVED***:
        return mcolors.colorConverter.to_rgba(0.4***REMOVED***

    assert_raises(ValueError, gray_from_float_rgb***REMOVED***
    assert_raises(ValueError, gray_from_float_rgba***REMOVED***


@image_comparison(baseline_images=['light_source_shading_topo'***REMOVED***,
                  extensions=['png'***REMOVED******REMOVED***
def test_light_source_topo_surface(***REMOVED***:
    ***REMOVED***Shades a DEM using different v.e.'s and blend modes.***REMOVED***
    fname = cbook.get_sample_data('jacksboro_fault_dem.npz', asfileobj=False***REMOVED***
    dem = np.load(fname***REMOVED***
    elev = dem['elevation'***REMOVED***
    # Get the true cellsize in meters for accurate vertical exaggeration
    #   Convert from decimal degrees to meters
    dx, dy = dem['dx'***REMOVED***, dem['dy'***REMOVED***
    dx = 111320.0 * dx * np.cos(dem['ymin'***REMOVED******REMOVED***
    dy = 111320.0 * dy
    dem.close(***REMOVED***

    ls = mcolors.LightSource(315, 45***REMOVED***
    cmap = cm.gist_earth

    fig, axes = plt.subplots(nrows=3, ncols=3***REMOVED***
    for row, mode in zip(axes, ['hsv', 'overlay', 'soft'***REMOVED******REMOVED***:
        for ax, ve in zip(row, [0.1, 1, 10***REMOVED******REMOVED***:
            rgb = ls.shade(elev, cmap, vert_exag=ve, dx=dx, dy=dy,
                           blend_mode=mode***REMOVED***
            ax.imshow(rgb***REMOVED***
            ax.set(xticks=[***REMOVED***, yticks=[***REMOVED******REMOVED***


def test_light_source_shading_default(***REMOVED***:
    ***REMOVED***Array comparison test for the default "hsv" blend mode. Ensure the
    default result doesn't change without warning.***REMOVED***
    y, x = np.mgrid[-1.2:1.2:8j, -1.2:1.2:8j***REMOVED***
    z = 10 * np.cos(x**2 + y**2***REMOVED***

    cmap = plt.cm.copper
    ls = mcolors.LightSource(315, 45***REMOVED***
    rgb = ls.shade(z, cmap***REMOVED***

    # Result stored transposed and rounded for for more compact display...
    expect = np.array([[[0.87, 0.85, 0.90, 0.90, 0.82, 0.62, 0.34, 0.00***REMOVED***,
                        [0.85, 0.94, 0.99, 1.00, 1.00, 0.96, 0.62, 0.17***REMOVED***,
                        [0.90, 0.99, 1.00, 1.00, 1.00, 1.00, 0.71, 0.33***REMOVED***,
                        [0.90, 1.00, 1.00, 1.00, 1.00, 0.98, 0.51, 0.29***REMOVED***,
                        [0.82, 1.00, 1.00, 1.00, 1.00, 0.64, 0.25, 0.13***REMOVED***,
                        [0.62, 0.96, 1.00, 0.98, 0.64, 0.22, 0.06, 0.03***REMOVED***,
                        [0.34, 0.62, 0.71, 0.51, 0.25, 0.06, 0.00, 0.01***REMOVED***,
                        [0.00, 0.17, 0.33, 0.29, 0.13, 0.03, 0.01, 0.00***REMOVED******REMOVED***,

                       [[0.87, 0.79, 0.83, 0.80, 0.66, 0.44, 0.23, 0.00***REMOVED***,
                        [0.79, 0.88, 0.93, 0.92, 0.83, 0.66, 0.38, 0.10***REMOVED***,
                        [0.83, 0.93, 0.99, 1.00, 0.92, 0.75, 0.40, 0.18***REMOVED***,
                        [0.80, 0.92, 1.00, 0.99, 0.93, 0.75, 0.28, 0.14***REMOVED***,
                        [0.66, 0.83, 0.92, 0.93, 0.87, 0.44, 0.12, 0.06***REMOVED***,
                        [0.44, 0.66, 0.75, 0.75, 0.44, 0.12, 0.03, 0.01***REMOVED***,
                        [0.23, 0.38, 0.40, 0.28, 0.12, 0.03, 0.00, 0.00***REMOVED***,
                        [0.00, 0.10, 0.18, 0.14, 0.06, 0.01, 0.00, 0.00***REMOVED******REMOVED***,

                       [[0.87, 0.75, 0.78, 0.73, 0.55, 0.33, 0.16, 0.00***REMOVED***,
                        [0.75, 0.85, 0.90, 0.86, 0.71, 0.48, 0.23, 0.05***REMOVED***,
                        [0.78, 0.90, 0.98, 1.00, 0.82, 0.51, 0.21, 0.08***REMOVED***,
                        [0.73, 0.86, 1.00, 0.97, 0.84, 0.47, 0.11, 0.05***REMOVED***,
                        [0.55, 0.71, 0.82, 0.84, 0.71, 0.20, 0.03, 0.01***REMOVED***,
                        [0.33, 0.48, 0.51, 0.47, 0.20, 0.02, 0.00, 0.00***REMOVED***,
                        [0.16, 0.23, 0.21, 0.11, 0.03, 0.00, 0.00, 0.00***REMOVED***,
                        [0.00, 0.05, 0.08, 0.05, 0.01, 0.00, 0.00, 0.00***REMOVED******REMOVED***,

                       [[1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00***REMOVED***,
                        [1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00***REMOVED***,
                        [1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00***REMOVED***,
                        [1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00***REMOVED***,
                        [1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00***REMOVED***,
                        [1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00***REMOVED***,
                        [1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00***REMOVED***,
                        [1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00***REMOVED******REMOVED******REMOVED******REMOVED***.T
    if (V(np.__version__***REMOVED*** == V('1.9.0'***REMOVED******REMOVED***:
        # Numpy 1.9.0 uses a 2. order algorithm on the edges by default
        # This was changed back again in 1.9.1
        expect = expect[1:-1, 1:-1, :***REMOVED***
        rgb = rgb[1:-1, 1:-1, :***REMOVED***

    assert_array_almost_equal(rgb, expect, decimal=2***REMOVED***


@knownfailureif((V(np.__version__***REMOVED*** <= V('1.9.0'***REMOVED***
                and V(np.__version__***REMOVED*** >= V('1.7.0'***REMOVED******REMOVED******REMOVED***
# Numpy 1.9.1 fixed a bug in masked arrays which resulted in
# additional elements being masked when calculating the gradient thus
# the output is different with earlier numpy versions.
def test_light_source_masked_shading(***REMOVED***:
    ***REMOVED***Array comparison test for a surface with a masked portion. Ensures that
    we don't wind up with "fringes" of odd colors around masked regions.***REMOVED***
    y, x = np.mgrid[-1.2:1.2:8j, -1.2:1.2:8j***REMOVED***
    z = 10 * np.cos(x**2 + y**2***REMOVED***

    z = np.ma.masked_greater(z, 9.9***REMOVED***

    cmap = plt.cm.copper
    ls = mcolors.LightSource(315, 45***REMOVED***
    rgb = ls.shade(z, cmap***REMOVED***

    # Result stored transposed and rounded for for more compact display...
    expect = np.array([[[0.90, 0.88, 0.91, 0.91, 0.84, 0.64, 0.36, 0.00***REMOVED***,
                        [0.88, 0.96, 1.00, 1.00, 1.00, 0.97, 0.64, 0.18***REMOVED***,
                        [0.91, 1.00, 1.00, 1.00, 1.00, 1.00, 0.74, 0.34***REMOVED***,
                        [0.91, 1.00, 1.00, 0.00, 0.00, 1.00, 0.52, 0.30***REMOVED***,
                        [0.84, 1.00, 1.00, 0.00, 0.00, 1.00, 0.25, 0.13***REMOVED***,
                        [0.64, 0.97, 1.00, 1.00, 1.00, 0.23, 0.07, 0.03***REMOVED***,
                        [0.36, 0.64, 0.74, 0.52, 0.25, 0.07, 0.00, 0.01***REMOVED***,
                        [0.00, 0.18, 0.34, 0.30, 0.13, 0.03, 0.01, 0.00***REMOVED******REMOVED***,

                       [[0.90, 0.82, 0.85, 0.82, 0.68, 0.46, 0.24, 0.00***REMOVED***,
                        [0.82, 0.91, 0.95, 0.93, 0.85, 0.68, 0.39, 0.10***REMOVED***,
                        [0.85, 0.95, 1.00, 0.78, 0.78, 0.77, 0.42, 0.18***REMOVED***,
                        [0.82, 0.93, 0.78, 0.00, 0.00, 0.78, 0.30, 0.15***REMOVED***,
                        [0.68, 0.85, 0.78, 0.00, 0.00, 0.78, 0.13, 0.06***REMOVED***,
                        [0.46, 0.68, 0.77, 0.78, 0.78, 0.13, 0.03, 0.01***REMOVED***,
                        [0.24, 0.39, 0.42, 0.30, 0.13, 0.03, 0.00, 0.00***REMOVED***,
                        [0.00, 0.10, 0.18, 0.15, 0.06, 0.01, 0.00, 0.00***REMOVED******REMOVED***,

                       [[0.90, 0.79, 0.81, 0.76, 0.58, 0.35, 0.17, 0.00***REMOVED***,
                        [0.79, 0.88, 0.92, 0.88, 0.73, 0.50, 0.24, 0.05***REMOVED***,
                        [0.81, 0.92, 1.00, 0.50, 0.50, 0.53, 0.22, 0.09***REMOVED***,
                        [0.76, 0.88, 0.50, 0.00, 0.00, 0.50, 0.12, 0.05***REMOVED***,
                        [0.58, 0.73, 0.50, 0.00, 0.00, 0.50, 0.03, 0.01***REMOVED***,
                        [0.35, 0.50, 0.53, 0.50, 0.50, 0.02, 0.00, 0.00***REMOVED***,
                        [0.17, 0.24, 0.22, 0.12, 0.03, 0.00, 0.00, 0.00***REMOVED***,
                        [0.00, 0.05, 0.09, 0.05, 0.01, 0.00, 0.00, 0.00***REMOVED******REMOVED***,

                       [[1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00***REMOVED***,
                        [1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00***REMOVED***,
                        [1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00***REMOVED***,
                        [1.00, 1.00, 1.00, 0.00, 0.00, 1.00, 1.00, 1.00***REMOVED***,
                        [1.00, 1.00, 1.00, 0.00, 0.00, 1.00, 1.00, 1.00***REMOVED***,
                        [1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00***REMOVED***,
                        [1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00***REMOVED***,
                        [1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00***REMOVED******REMOVED******REMOVED******REMOVED***.T

    assert_array_almost_equal(rgb, expect, decimal=2***REMOVED***


def test_light_source_hillshading(***REMOVED***:
    ***REMOVED***Compare the current hillshading method against one that should be
    mathematically equivalent. Illuminates a cone from a range of angles.***REMOVED***

    def alternative_hillshade(azimuth, elev, z***REMOVED***:
        illum = _sph2cart(*_azimuth2math(azimuth, elev***REMOVED******REMOVED***
        illum = np.array(illum***REMOVED***

        dy, dx = np.gradient(-z***REMOVED***
        dy = -dy
        dz = np.ones_like(dy***REMOVED***
        normals = np.dstack([dx, dy, dz***REMOVED******REMOVED***
        dividers = np.zeros_like(z***REMOVED***[..., None***REMOVED***
        for i, mat in enumerate(normals***REMOVED***:
            for j, vec in enumerate(mat***REMOVED***:
                dividers[i, j, 0***REMOVED*** = np.linalg.norm(vec***REMOVED***
        normals /= dividers
        # once we drop support for numpy 1.7.x the above can be written as
        # normals /= np.linalg.norm(normals, axis=2***REMOVED***[..., None***REMOVED***
        # aviding the double loop.

        intensity = np.tensordot(normals, illum, axes=(2, 0***REMOVED******REMOVED***
        intensity -= intensity.min(***REMOVED***
        intensity /= intensity.ptp(***REMOVED***
        return intensity

    y, x = np.mgrid[5:0:-1, :5***REMOVED***
    z = -np.hypot(x - x.mean(***REMOVED***, y - y.mean(***REMOVED******REMOVED***

    for az, elev in itertools.product(range(0, 390, 30***REMOVED***, range(0, 105, 15***REMOVED******REMOVED***:
        ls = mcolors.LightSource(az, elev***REMOVED***
        h1 = ls.hillshade(z***REMOVED***
        h2 = alternative_hillshade(az, elev, z***REMOVED***
        assert_array_almost_equal(h1, h2***REMOVED***


def test_light_source_planar_hillshading(***REMOVED***:
    ***REMOVED***Ensure that the illumination intensity is correct for planar
    surfaces.***REMOVED***

    def plane(azimuth, elevation, x, y***REMOVED***:
        ***REMOVED***Create a plane whose normal vector is at the given azimuth and
        elevation.***REMOVED***
        theta, phi = _azimuth2math(azimuth, elevation***REMOVED***
        a, b, c = _sph2cart(theta, phi***REMOVED***
        z = -(a*x + b*y***REMOVED*** / c
        return z

    def angled_plane(azimuth, elevation, angle, x, y***REMOVED***:
        ***REMOVED***Create a plane whose normal vector is at an angle from the given
        azimuth and elevation.***REMOVED***
        elevation = elevation + angle
        if elevation > 90:
            azimuth = (azimuth + 180***REMOVED*** % 360
            elevation = (90 - elevation***REMOVED*** % 90
        return plane(azimuth, elevation, x, y***REMOVED***

    y, x = np.mgrid[5:0:-1, :5***REMOVED***
    for az, elev in itertools.product(range(0, 390, 30***REMOVED***, range(0, 105, 15***REMOVED******REMOVED***:
        ls = mcolors.LightSource(az, elev***REMOVED***

        # Make a plane at a range of angles to the illumination
        for angle in range(0, 105, 15***REMOVED***:
            z = angled_plane(az, elev, angle, x, y***REMOVED***
            h = ls.hillshade(z***REMOVED***
            assert_array_almost_equal(h, np.cos(np.radians(angle***REMOVED******REMOVED******REMOVED***


def _sph2cart(theta, phi***REMOVED***:
    x = np.cos(theta***REMOVED*** * np.sin(phi***REMOVED***
    y = np.sin(theta***REMOVED*** * np.sin(phi***REMOVED***
    z = np.cos(phi***REMOVED***
    return x, y, z


def _azimuth2math(azimuth, elevation***REMOVED***:
    ***REMOVED***Converts from clockwise-from-north and up-from-horizontal to
    mathematical conventions.***REMOVED***
    theta = np.radians((90 - azimuth***REMOVED*** % 360***REMOVED***
    phi = np.radians(90 - elevation***REMOVED***
    return theta, phi


def test_pandas_iterable(***REMOVED***:
    ***REMOVED***
        import pandas as pd
    except ImportError:
        raise SkipTest("Pandas not installed"***REMOVED***
    if assert_sequence_equal is None:
        raise SkipTest("nose lacks required function"***REMOVED***
    # Using a list or series yields equivalent
    # color maps, i.e the series isn't seen as
    # a single color
    lst = ['red', 'blue', 'green'***REMOVED***
    s = pd.Series(lst***REMOVED***
    cm1 = mcolors.ListedColormap(lst, N=5***REMOVED***
    cm2 = mcolors.ListedColormap(s, N=5***REMOVED***
    assert_sequence_equal(cm1.colors, cm2.colors***REMOVED***


if __name__ == '__main__':
    import nose
    nose.runmodule(argv=['-s', '--with-doctest'***REMOVED***, exit=False***REMOVED***
