from __future__ import (absolute_import, division, print_function,
                        unicode_literals***REMOVED***

from matplotlib.externals import six
from matplotlib.externals.six.moves import xrange, zip

import unittest

from nose.tools import assert_equal, assert_raises
import numpy.testing as np_test
from numpy.testing import assert_almost_equal, assert_array_equal
from numpy.testing import assert_array_almost_equal
from matplotlib.transforms import Affine2D, BlendedGenericTransform, Bbox
from matplotlib.path import Path
from matplotlib.scale import LogScale
from matplotlib.testing.decorators import cleanup, image_comparison
import numpy as np

import matplotlib.transforms as mtrans
import matplotlib.pyplot as plt
import matplotlib.path as mpath
import matplotlib.patches as mpatches


@cleanup
def test_non_affine_caching(***REMOVED***:
    class AssertingNonAffineTransform(mtrans.Transform***REMOVED***:
        ***REMOVED***
        This transform raises an assertion error when called when it
        shouldn't be and self.raise_on_transform is True.

        ***REMOVED***
        input_dims = output_dims = 2
        is_affine = False

        def __init__(self, *args, **kwargs***REMOVED***:
            mtrans.Transform.__init__(self, *args, **kwargs***REMOVED***
            self.raise_on_transform = False
            self.underlying_transform = mtrans.Affine2D(***REMOVED***.scale(10, 10***REMOVED***

        def transform_path_non_affine(self, path***REMOVED***:
            if self.raise_on_transform:
                assert False, ('Invalidated affine part of transform '
                               'unnecessarily.'***REMOVED***
            return self.underlying_transform.transform_path(path***REMOVED***
        transform_path = transform_path_non_affine

        def transform_non_affine(self, path***REMOVED***:
            if self.raise_on_transform:
                assert False, ('Invalidated affine part of transform '
                               'unnecessarily.'***REMOVED***
            return self.underlying_transform.transform(path***REMOVED***
        transform = transform_non_affine

    my_trans = AssertingNonAffineTransform(***REMOVED***
    ax = plt.axes(***REMOVED***
    plt.plot(list(xrange(10***REMOVED******REMOVED***, transform=my_trans + ax.transData***REMOVED***
    plt.draw(***REMOVED***
    # enable the transform to raise an exception if it's non-affine transform
    # method is triggered again.
    my_trans.raise_on_transform = True
    ax.transAxes.invalidate(***REMOVED***
    plt.draw(***REMOVED***


@cleanup
def test_external_transform_api(***REMOVED***:
    class ScaledBy(object***REMOVED***:
        def __init__(self, scale_factor***REMOVED***:
            self._scale_factor = scale_factor

        def _as_mpl_transform(self, axes***REMOVED***:
            return mtrans.Affine2D(***REMOVED***.scale(self._scale_factor***REMOVED*** + axes.transData

    ax = plt.axes(***REMOVED***
    line, = plt.plot(list(xrange(10***REMOVED******REMOVED***, transform=ScaledBy(10***REMOVED******REMOVED***
    ax.set_xlim(0, 100***REMOVED***
    ax.set_ylim(0, 100***REMOVED***
    # assert that the top transform of the line is the scale transform.
    np.testing.assert_allclose(line.get_transform(***REMOVED***._a.get_matrix(***REMOVED***,
                               mtrans.Affine2D(***REMOVED***.scale(10***REMOVED***.get_matrix(***REMOVED******REMOVED***


@image_comparison(baseline_images=['pre_transform_data'***REMOVED******REMOVED***
def test_pre_transform_plotting(***REMOVED***:
    # a catch-all for as many as possible plot layouts which handle
    # pre-transforming the data NOTE: The axis range is important in this
    # plot. It should be x10 what the data suggests it should be
    ax = plt.axes(***REMOVED***
    times10 = mtrans.Affine2D(***REMOVED***.scale(10***REMOVED***

    ax.contourf(np.arange(48***REMOVED***.reshape(6, 8***REMOVED***, transform=times10 + ax.transData***REMOVED***

    ax.pcolormesh(np.linspace(0, 4, 7***REMOVED***,
                  np.linspace(5.5, 8, 9***REMOVED***,
                  np.arange(48***REMOVED***.reshape(8, 6***REMOVED***,
                  transform=times10 + ax.transData***REMOVED***

    ax.scatter(np.linspace(0, 10***REMOVED***, np.linspace(10, 0***REMOVED***,
               transform=times10 + ax.transData***REMOVED***

    x = np.linspace(8, 10, 20***REMOVED***
    y = np.linspace(1, 5, 20***REMOVED***
    u = 2*np.sin(x***REMOVED*** + np.cos(y[:, np.newaxis***REMOVED******REMOVED***
    v = np.sin(x***REMOVED*** - np.cos(y[:, np.newaxis***REMOVED******REMOVED***

    df = 25. / 30.   # Compatibility factor for old test image
    ax.streamplot(x, y, u, v, transform=times10 + ax.transData,
                  density=(df, df***REMOVED***, linewidth=u**2 + v**2***REMOVED***

    # reduce the vector data down a bit for barb and quiver plotting
    x, y = x[::3***REMOVED***, y[::3***REMOVED***
    u, v = u[::3, ::3***REMOVED***, v[::3, ::3***REMOVED***

    ax.quiver(x, y + 5, u, v, transform=times10 + ax.transData***REMOVED***

    ax.barbs(x - 3, y + 5, u**2, v**2, transform=times10 + ax.transData***REMOVED***


@cleanup
def test_contour_pre_transform_limits(***REMOVED***:
    ax = plt.axes(***REMOVED***
    xs, ys = np.meshgrid(np.linspace(15, 20, 15***REMOVED***, np.linspace(12.4, 12.5, 20***REMOVED******REMOVED***
    ax.contourf(xs, ys, np.log(xs * ys***REMOVED***,
                transform=mtrans.Affine2D(***REMOVED***.scale(0.1***REMOVED*** + ax.transData***REMOVED***

    expected = np.array([[1.5, 1.24***REMOVED***,
                         [2., 1.25***REMOVED******REMOVED******REMOVED***
    assert_almost_equal(expected, ax.dataLim.get_points(***REMOVED******REMOVED***


@cleanup
def test_pcolor_pre_transform_limits(***REMOVED***:
    # Based on test_contour_pre_transform_limits(***REMOVED***
    ax = plt.axes(***REMOVED***
    xs, ys = np.meshgrid(np.linspace(15, 20, 15***REMOVED***, np.linspace(12.4, 12.5, 20***REMOVED******REMOVED***
    ax.pcolor(xs, ys, np.log(xs * ys***REMOVED***,
              transform=mtrans.Affine2D(***REMOVED***.scale(0.1***REMOVED*** + ax.transData***REMOVED***

    expected = np.array([[1.5, 1.24***REMOVED***,
                         [2., 1.25***REMOVED******REMOVED******REMOVED***
    assert_almost_equal(expected, ax.dataLim.get_points(***REMOVED******REMOVED***


@cleanup
def test_pcolormesh_pre_transform_limits(***REMOVED***:
    # Based on test_contour_pre_transform_limits(***REMOVED***
    ax = plt.axes(***REMOVED***
    xs, ys = np.meshgrid(np.linspace(15, 20, 15***REMOVED***, np.linspace(12.4, 12.5, 20***REMOVED******REMOVED***
    ax.pcolormesh(xs, ys, np.log(xs * ys***REMOVED***,
                  transform=mtrans.Affine2D(***REMOVED***.scale(0.1***REMOVED*** + ax.transData***REMOVED***

    expected = np.array([[1.5, 1.24***REMOVED***,
                         [2., 1.25***REMOVED******REMOVED******REMOVED***
    assert_almost_equal(expected, ax.dataLim.get_points(***REMOVED******REMOVED***


def test_Affine2D_from_values(***REMOVED***:
    points = np.array([[0, 0***REMOVED***,
                       [10, 20***REMOVED***,
                       [-1, 0***REMOVED***,
                       ***REMOVED******REMOVED***

    t = mtrans.Affine2D.from_values(1, 0, 0, 0, 0, 0***REMOVED***
    actual = t.transform(points***REMOVED***
    expected = np.array([[0, 0***REMOVED***, [10, 0***REMOVED***, [-1, 0***REMOVED******REMOVED******REMOVED***
    assert_almost_equal(actual, expected***REMOVED***

    t = mtrans.Affine2D.from_values(0, 2, 0, 0, 0, 0***REMOVED***
    actual = t.transform(points***REMOVED***
    expected = np.array([[0, 0***REMOVED***, [0, 20***REMOVED***, [0, -2***REMOVED******REMOVED******REMOVED***
    assert_almost_equal(actual, expected***REMOVED***

    t = mtrans.Affine2D.from_values(0, 0, 3, 0, 0, 0***REMOVED***
    actual = t.transform(points***REMOVED***
    expected = np.array([[0, 0***REMOVED***, [60, 0***REMOVED***, [0, 0***REMOVED******REMOVED******REMOVED***
    assert_almost_equal(actual, expected***REMOVED***

    t = mtrans.Affine2D.from_values(0, 0, 0, 4, 0, 0***REMOVED***
    actual = t.transform(points***REMOVED***
    expected = np.array([[0, 0***REMOVED***, [0, 80***REMOVED***, [0, 0***REMOVED******REMOVED******REMOVED***
    assert_almost_equal(actual, expected***REMOVED***

    t = mtrans.Affine2D.from_values(0, 0, 0, 0, 5, 0***REMOVED***
    actual = t.transform(points***REMOVED***
    expected = np.array([[5, 0***REMOVED***, [5, 0***REMOVED***, [5, 0***REMOVED******REMOVED******REMOVED***
    assert_almost_equal(actual, expected***REMOVED***

    t = mtrans.Affine2D.from_values(0, 0, 0, 0, 0, 6***REMOVED***
    actual = t.transform(points***REMOVED***
    expected = np.array([[0, 6***REMOVED***, [0, 6***REMOVED***, [0, 6***REMOVED******REMOVED******REMOVED***
    assert_almost_equal(actual, expected***REMOVED***


def test_clipping_of_log(***REMOVED***:
    # issue 804
    M, L, C = Path.MOVETO, Path.LINETO, Path.CLOSEPOLY
    points = [(0.2, -99***REMOVED***, (0.4, -99***REMOVED***, (0.4, 20***REMOVED***, (0.2, 20***REMOVED***, (0.2, -99***REMOVED******REMOVED***
    codes = [M, L, L, L, C***REMOVED***
    path = Path(points, codes***REMOVED***

    # something like this happens in plotting logarithmic histograms
    trans = BlendedGenericTransform(Affine2D(***REMOVED***,
                                    LogScale.Log10Transform('clip'***REMOVED******REMOVED***
    tpath = trans.transform_path_non_affine(path***REMOVED***
    result = tpath.iter_segments(trans.get_affine(***REMOVED***,
                                 clip=(0, 0, 100, 100***REMOVED***,
                                 simplify=False***REMOVED***

    tpoints, tcodes = list(zip(*result***REMOVED******REMOVED***
    assert np.allclose(tcodes, [M, L, L, L, C***REMOVED******REMOVED***


class NonAffineForTest(mtrans.Transform***REMOVED***:
    ***REMOVED***
    A class which looks like a non affine transform, but does whatever
    the given transform does (even if it is affine***REMOVED***. This is very useful
    for testing NonAffine behaviour with a simple Affine transform.

    ***REMOVED***
    is_affine = False
    output_dims = 2
    input_dims = 2

    def __init__(self, real_trans, *args, **kwargs***REMOVED***:
        self.real_trans = real_trans
        r = mtrans.Transform.__init__(self, *args, **kwargs***REMOVED***

    def transform_non_affine(self, values***REMOVED***:
        return self.real_trans.transform(values***REMOVED***

    def transform_path_non_affine(self, path***REMOVED***:
        return self.real_trans.transform_path(path***REMOVED***


class BasicTransformTests(unittest.TestCase***REMOVED***:
    def setUp(self***REMOVED***:

        self.ta1 = mtrans.Affine2D(shorthand_name='ta1'***REMOVED***.rotate(np.pi / 2***REMOVED***
        self.ta2 = mtrans.Affine2D(shorthand_name='ta2'***REMOVED***.translate(10, 0***REMOVED***
        self.ta3 = mtrans.Affine2D(shorthand_name='ta3'***REMOVED***.scale(1, 2***REMOVED***

        self.tn1 = NonAffineForTest(mtrans.Affine2D(***REMOVED***.translate(1, 2***REMOVED***,
                                    shorthand_name='tn1'***REMOVED***
        self.tn2 = NonAffineForTest(mtrans.Affine2D(***REMOVED***.translate(1, 2***REMOVED***,
                                    shorthand_name='tn2'***REMOVED***
        self.tn3 = NonAffineForTest(mtrans.Affine2D(***REMOVED***.translate(1, 2***REMOVED***,
                                    shorthand_name='tn3'***REMOVED***

        # creates a transform stack which looks like ((A, (N, A***REMOVED******REMOVED***, A***REMOVED***
        self.stack1 = (self.ta1 + (self.tn1 + self.ta2***REMOVED******REMOVED*** + self.ta3
        # creates a transform stack which looks like (((A, N***REMOVED***, A***REMOVED***, A***REMOVED***
        self.stack2 = self.ta1 + self.tn1 + self.ta2 + self.ta3
        # creates a transform stack which is a subset of stack2
        self.stack2_subset = self.tn1 + self.ta2 + self.ta3

        # when in debug, the transform stacks can produce dot images:
#        self.stack1.write_graphviz(file('stack1.dot', 'w'***REMOVED******REMOVED***
#        self.stack2.write_graphviz(file('stack2.dot', 'w'***REMOVED******REMOVED***
#        self.stack2_subset.write_graphviz(file('stack2_subset.dot', 'w'***REMOVED******REMOVED***

    def test_transform_depth(self***REMOVED***:
        assert_equal(self.stack1.depth, 4***REMOVED***
        assert_equal(self.stack2.depth, 4***REMOVED***
        assert_equal(self.stack2_subset.depth, 3***REMOVED***

    def test_left_to_right_iteration(self***REMOVED***:
        stack3 = (self.ta1 + (self.tn1 + (self.ta2 + self.tn2***REMOVED******REMOVED******REMOVED*** + self.ta3
#        stack3.write_graphviz(file('stack3.dot', 'w'***REMOVED******REMOVED***

        target_transforms = [stack3,
                             (self.tn1 + (self.ta2 + self.tn2***REMOVED******REMOVED*** + self.ta3,
                             (self.ta2 + self.tn2***REMOVED*** + self.ta3,
                             self.tn2 + self.ta3,
                             self.ta3,
                             ***REMOVED***
        r = [rh for _, rh in stack3._iter_break_from_left_to_right(***REMOVED******REMOVED***
        self.assertEqual(len(r***REMOVED***, len(target_transforms***REMOVED******REMOVED***

        for target_stack, stack in zip(target_transforms, r***REMOVED***:
            self.assertEqual(target_stack, stack***REMOVED***

    def test_transform_shortcuts(self***REMOVED***:
        self.assertEqual(self.stack1 - self.stack2_subset, self.ta1***REMOVED***
        self.assertEqual(self.stack2 - self.stack2_subset, self.ta1***REMOVED***

        assert_equal((self.stack2_subset - self.stack2***REMOVED***,
                     self.ta1.inverted(***REMOVED***,
                     ***REMOVED***
        assert_equal((self.stack2_subset - self.stack2***REMOVED***.depth, 1***REMOVED***

        assert_raises(ValueError, self.stack1.__sub__, self.stack2***REMOVED***

        aff1 = self.ta1 + (self.ta2 + self.ta3***REMOVED***
        aff2 = self.ta2 + self.ta3

        self.assertEqual(aff1 - aff2, self.ta1***REMOVED***
        self.assertEqual(aff1 - self.ta2, aff1 + self.ta2.inverted(***REMOVED******REMOVED***

        self.assertEqual(self.stack1 - self.ta3,
                         self.ta1 + (self.tn1 + self.ta2***REMOVED******REMOVED***
        self.assertEqual(self.stack2 - self.ta3,
                         self.ta1 + self.tn1 + self.ta2***REMOVED***

        self.assertEqual((self.ta2 + self.ta3***REMOVED*** - self.ta3 + self.ta3,
                         self.ta2 + self.ta3***REMOVED***

    def test_contains_branch(self***REMOVED***:
        r1 = (self.ta2 + self.ta1***REMOVED***
        r2 = (self.ta2 + self.ta1***REMOVED***
        self.assertEqual(r1, r2***REMOVED***
        self.assertNotEqual(r1, self.ta1***REMOVED***
        self.assertTrue(r1.contains_branch(r2***REMOVED******REMOVED***
        self.assertTrue(r1.contains_branch(self.ta1***REMOVED******REMOVED***
        self.assertFalse(r1.contains_branch(self.ta2***REMOVED******REMOVED***
        self.assertFalse(r1.contains_branch((self.ta2 + self.ta2***REMOVED******REMOVED******REMOVED***

        self.assertEqual(r1, r2***REMOVED***

        self.assertTrue(self.stack1.contains_branch(self.ta3***REMOVED******REMOVED***
        self.assertTrue(self.stack2.contains_branch(self.ta3***REMOVED******REMOVED***

        self.assertTrue(self.stack1.contains_branch(self.stack2_subset***REMOVED******REMOVED***
        self.assertTrue(self.stack2.contains_branch(self.stack2_subset***REMOVED******REMOVED***

        self.assertFalse(self.stack2_subset.contains_branch(self.stack1***REMOVED******REMOVED***
        self.assertFalse(self.stack2_subset.contains_branch(self.stack2***REMOVED******REMOVED***

        self.assertTrue(self.stack1.contains_branch((self.ta2 + self.ta3***REMOVED******REMOVED******REMOVED***
        self.assertTrue(self.stack2.contains_branch((self.ta2 + self.ta3***REMOVED******REMOVED******REMOVED***

        self.assertFalse(self.stack1.contains_branch((self.tn1 + self.ta2***REMOVED******REMOVED******REMOVED***

    def test_affine_simplification(self***REMOVED***:
        # tests that a transform stack only calls as much is absolutely
        # necessary "non-affine" allowing the best possible optimization with
        # complex transformation stacks.
        points = np.array([[0, 0***REMOVED***, [10, 20***REMOVED***, [np.nan, 1***REMOVED***, [-1, 0***REMOVED******REMOVED***,
                          dtype=np.float64***REMOVED***
        na_pts = self.stack1.transform_non_affine(points***REMOVED***
        all_pts = self.stack1.transform(points***REMOVED***

        na_expected = np.array([[1., 2.***REMOVED***, [-19., 12.***REMOVED***,
                                [np.nan, np.nan***REMOVED***, [1., 1.***REMOVED******REMOVED***, dtype=np.float64***REMOVED***
        all_expected = np.array([[11., 4.***REMOVED***, [-9., 24.***REMOVED***,
                                 [np.nan, np.nan***REMOVED***, [11., 2.***REMOVED******REMOVED***,
                                dtype=np.float64***REMOVED***

        # check we have the expected results from doing the affine part only
        np_test.assert_array_almost_equal(na_pts, na_expected***REMOVED***
        # check we have the expected results from a full transformation
        np_test.assert_array_almost_equal(all_pts, all_expected***REMOVED***
        # check we have the expected results from doing the transformation in
        # two steps
        np_test.assert_array_almost_equal(self.stack1.transform_affine(na_pts***REMOVED***,
                                          all_expected***REMOVED***
        # check that getting the affine transformation first, then fully
        # transforming using that yields the same result as before.
        np_test.assert_array_almost_equal(
            self.stack1.get_affine(***REMOVED***.transform(na_pts***REMOVED***, all_expected***REMOVED***

        # check that the affine part of stack1 & stack2 are equivalent
        # (i.e. the optimization is working***REMOVED***
        expected_result = (self.ta2 + self.ta3***REMOVED***.get_matrix(***REMOVED***
        result = self.stack1.get_affine(***REMOVED***.get_matrix(***REMOVED***
        np_test.assert_array_equal(expected_result, result***REMOVED***

        result = self.stack2.get_affine(***REMOVED***.get_matrix(***REMOVED***
        np_test.assert_array_equal(expected_result, result***REMOVED***


class TestTransformPlotInterface(unittest.TestCase***REMOVED***:
    def tearDown(self***REMOVED***:
        plt.close(***REMOVED***

    def test_line_extent_axes_coords(self***REMOVED***:
        # a simple line in axes coordinates
        ax = plt.axes(***REMOVED***
        ax.plot([0.1, 1.2, 0.8***REMOVED***, [0.9, 0.5, 0.8***REMOVED***, transform=ax.transAxes***REMOVED***
        np.testing.assert_array_equal(ax.dataLim.get_points(***REMOVED***,
                                      np.array([[np.inf, np.inf***REMOVED***,
                                                [-np.inf, -np.inf***REMOVED******REMOVED******REMOVED******REMOVED***

    def test_line_extent_data_coords(self***REMOVED***:
        # a simple line in data coordinates
        ax = plt.axes(***REMOVED***
        ax.plot([0.1, 1.2, 0.8***REMOVED***, [0.9, 0.5, 0.8***REMOVED***, transform=ax.transData***REMOVED***
        np.testing.assert_array_equal(ax.dataLim.get_points(***REMOVED***,
                                      np.array([[0.1,  0.5***REMOVED***, [1.2,  0.9***REMOVED******REMOVED******REMOVED******REMOVED***

    def test_line_extent_compound_coords1(self***REMOVED***:
        # a simple line in data coordinates in the y component, and in axes
        # coordinates in the x
        ax = plt.axes(***REMOVED***
        trans = mtrans.blended_transform_factory(ax.transAxes, ax.transData***REMOVED***
        ax.plot([0.1, 1.2, 0.8***REMOVED***, [35, -5, 18***REMOVED***, transform=trans***REMOVED***
        np.testing.assert_array_equal(ax.dataLim.get_points(***REMOVED***,
                                      np.array([[np.inf, -5.***REMOVED***,
                                                [-np.inf, 35.***REMOVED******REMOVED******REMOVED******REMOVED***
        plt.close(***REMOVED***

    def test_line_extent_predata_transform_coords(self***REMOVED***:
        # a simple line in (offset + data***REMOVED*** coordinates
        ax = plt.axes(***REMOVED***
        trans = mtrans.Affine2D(***REMOVED***.scale(10***REMOVED*** + ax.transData
        ax.plot([0.1, 1.2, 0.8***REMOVED***, [35, -5, 18***REMOVED***, transform=trans***REMOVED***
        np.testing.assert_array_equal(ax.dataLim.get_points(***REMOVED***,
                                      np.array([[1., -50.***REMOVED***, [12., 350.***REMOVED******REMOVED******REMOVED******REMOVED***
        plt.close(***REMOVED***

    def test_line_extent_compound_coords2(self***REMOVED***:
        # a simple line in (offset + data***REMOVED*** coordinates in the y component, and
        # in axes coordinates in the x
        ax = plt.axes(***REMOVED***
        trans = mtrans.blended_transform_factory(
            ax.transAxes, mtrans.Affine2D(***REMOVED***.scale(10***REMOVED*** + ax.transData***REMOVED***
        ax.plot([0.1, 1.2, 0.8***REMOVED***, [35, -5, 18***REMOVED***, transform=trans***REMOVED***
        np.testing.assert_array_equal(
            ax.dataLim.get_points(***REMOVED***,
            np.array([[np.inf, -50.***REMOVED***, [-np.inf, 350.***REMOVED******REMOVED******REMOVED******REMOVED***
        plt.close(***REMOVED***

    def test_line_extents_affine(self***REMOVED***:
        ax = plt.axes(***REMOVED***
        offset = mtrans.Affine2D(***REMOVED***.translate(10, 10***REMOVED***
        plt.plot(list(xrange(10***REMOVED******REMOVED***, transform=offset + ax.transData***REMOVED***
        expeted_data_lim = np.array([[0., 0.***REMOVED***, [9.,  9.***REMOVED******REMOVED******REMOVED*** + 10
        np.testing.assert_array_almost_equal(ax.dataLim.get_points(***REMOVED***,
                                             expeted_data_lim***REMOVED***

    def test_line_extents_non_affine(self***REMOVED***:
        ax = plt.axes(***REMOVED***
        offset = mtrans.Affine2D(***REMOVED***.translate(10, 10***REMOVED***
        na_offset = NonAffineForTest(mtrans.Affine2D(***REMOVED***.translate(10, 10***REMOVED******REMOVED***
        plt.plot(list(xrange(10***REMOVED******REMOVED***, transform=offset + na_offset + ax.transData***REMOVED***
        expeted_data_lim = np.array([[0., 0.***REMOVED***, [9.,  9.***REMOVED******REMOVED******REMOVED*** + 20
        np.testing.assert_array_almost_equal(ax.dataLim.get_points(***REMOVED***,
                                             expeted_data_lim***REMOVED***

    def test_pathc_extents_non_affine(self***REMOVED***:
        ax = plt.axes(***REMOVED***
        offset = mtrans.Affine2D(***REMOVED***.translate(10, 10***REMOVED***
        na_offset = NonAffineForTest(mtrans.Affine2D(***REMOVED***.translate(10, 10***REMOVED******REMOVED***
        pth = mpath.Path(np.array([[0, 0***REMOVED***, [0, 10***REMOVED***, [10, 10***REMOVED***, [10, 0***REMOVED******REMOVED******REMOVED******REMOVED***
        patch = mpatches.PathPatch(pth,
                                   transform=offset + na_offset + ax.transData***REMOVED***
        ax.add_patch(patch***REMOVED***
        expeted_data_lim = np.array([[0., 0.***REMOVED***, [10.,  10.***REMOVED******REMOVED******REMOVED*** + 20
        np.testing.assert_array_almost_equal(ax.dataLim.get_points(***REMOVED***,
                                             expeted_data_lim***REMOVED***

    def test_pathc_extents_affine(self***REMOVED***:
        ax = plt.axes(***REMOVED***
        offset = mtrans.Affine2D(***REMOVED***.translate(10, 10***REMOVED***
        pth = mpath.Path(np.array([[0, 0***REMOVED***, [0, 10***REMOVED***, [10, 10***REMOVED***, [10, 0***REMOVED******REMOVED******REMOVED******REMOVED***
        patch = mpatches.PathPatch(pth, transform=offset + ax.transData***REMOVED***
        ax.add_patch(patch***REMOVED***
        expeted_data_lim = np.array([[0., 0.***REMOVED***, [10.,  10.***REMOVED******REMOVED******REMOVED*** + 10
        np.testing.assert_array_almost_equal(ax.dataLim.get_points(***REMOVED***,
                                             expeted_data_lim***REMOVED***

    def test_line_extents_for_non_affine_transData(self***REMOVED***:
        ax = plt.axes(projection='polar'***REMOVED***
        # add 10 to the radius of the data
        offset = mtrans.Affine2D(***REMOVED***.translate(0, 10***REMOVED***

        plt.plot(list(xrange(10***REMOVED******REMOVED***, transform=offset + ax.transData***REMOVED***
        # the data lim of a polar plot is stored in coordinates
        # before a transData transformation, hence the data limits
        # are not what is being shown on the actual plot.
        expeted_data_lim = np.array([[0., 0.***REMOVED***, [9.,  9.***REMOVED******REMOVED******REMOVED*** + [0, 10***REMOVED***
        np.testing.assert_array_almost_equal(ax.dataLim.get_points(***REMOVED***,
                                             expeted_data_lim***REMOVED***


def assert_bbox_eq(bbox1, bbox2***REMOVED***:
    assert_array_equal(bbox1.bounds, bbox2.bounds***REMOVED***


def test_bbox_intersection(***REMOVED***:
    bbox_from_ext = mtrans.Bbox.from_extents
    inter = mtrans.Bbox.intersection

    r1 = bbox_from_ext(0, 0, 1, 1***REMOVED***
    r2 = bbox_from_ext(0.5, 0.5, 1.5, 1.5***REMOVED***
    r3 = bbox_from_ext(0.5, 0, 0.75, 0.75***REMOVED***
    r4 = bbox_from_ext(0.5, 1.5, 1, 2.5***REMOVED***
    r5 = bbox_from_ext(1, 1, 2, 2***REMOVED***

    # self intersection -> no change
    assert_bbox_eq(inter(r1, r1***REMOVED***, r1***REMOVED***
    # simple intersection
    assert_bbox_eq(inter(r1, r2***REMOVED***, bbox_from_ext(0.5, 0.5, 1, 1***REMOVED******REMOVED***
    # r3 contains r2
    assert_bbox_eq(inter(r1, r3***REMOVED***, r3***REMOVED***
    # no intersection
    assert_equal(inter(r1, r4***REMOVED***, None***REMOVED***
    # single point
    assert_bbox_eq(inter(r1, r5***REMOVED***, bbox_from_ext(1, 1, 1, 1***REMOVED******REMOVED***


def test_bbox_as_strings(***REMOVED***:
    b = mtrans.Bbox([[.5, 0***REMOVED***, [.75, .75***REMOVED******REMOVED******REMOVED***
    assert_bbox_eq(b, eval(repr(b***REMOVED***, {'Bbox': mtrans.Bbox***REMOVED******REMOVED******REMOVED***
    asdict = eval(str(b***REMOVED***, {'Bbox': dict***REMOVED******REMOVED***
    for k, v in asdict.items(***REMOVED***:
        assert_equal(getattr(b, k***REMOVED***, v***REMOVED***
    fmt = '.1f'
    asdict = eval(format(b, fmt***REMOVED***, {'Bbox': dict***REMOVED******REMOVED***
    for k, v in asdict.items(***REMOVED***:
        assert_equal(eval(format(getattr(b, k***REMOVED***, fmt***REMOVED******REMOVED***, v***REMOVED***


def test_transform_single_point(***REMOVED***:
    t = mtrans.Affine2D(***REMOVED***
    r = t.transform_affine((1, 1***REMOVED******REMOVED***
    assert r.shape == (2,***REMOVED***


@cleanup
def test_log_transform(***REMOVED***:
    # Tests that the last line runs without exception (previously the
    # transform would fail if one of the axes was logarithmic***REMOVED***.
    fig, ax = plt.subplots(***REMOVED***
    ax.set_yscale('log'***REMOVED***
    ax.transData.transform((1, 1***REMOVED******REMOVED***


@cleanup
def test_nan_overlap(***REMOVED***:
    a = Bbox([[0, 0***REMOVED***, [1, 1***REMOVED******REMOVED******REMOVED***
    b = Bbox([[0, 0***REMOVED***, [1, np.nan***REMOVED******REMOVED******REMOVED***
    assert not a.overlaps(b***REMOVED***


def test_transform_angles(***REMOVED***:
    t = mtrans.Affine2D(***REMOVED***  # Identity transform
    angles = np.array([20, 45, 60***REMOVED******REMOVED***
    points = np.array([[0, 0***REMOVED***, [1, 1***REMOVED***, [2, 2***REMOVED******REMOVED******REMOVED***

    # Identity transform does not change angles
    new_angles = t.transform_angles(angles, points***REMOVED***
    assert_array_almost_equal(angles, new_angles***REMOVED***

    # points missing a 2nd dimension
    assert_raises(ValueError, t.transform_angles, angles, points[0:2, 0:1***REMOVED******REMOVED***

    # Number of angles != Number of points
    assert_raises(ValueError, t.transform_angles, angles, points[0:2, :***REMOVED******REMOVED***


def test_nonsingular(***REMOVED***:
    # test for zero-expansion type cases; other cases may be added later
    zero_expansion = np.array([-0.001, 0.001***REMOVED******REMOVED***
    cases = [(0, np.nan***REMOVED***, (0, 0***REMOVED***, (0, 7.9e-317***REMOVED******REMOVED***
    for args in cases:
        out = np.array(mtrans.nonsingular(*args***REMOVED******REMOVED***
        assert_array_equal(out, zero_expansion***REMOVED***


def test_invalid_arguments(***REMOVED***:
    t = mtrans.Affine2D(***REMOVED***
    # There are two different exceptions, since the wrong number of
    # dimensions is caught when constructing an array_view, and that
    # raises a ValueError, and a wrong shape with a possible number
    # of dimensions is caught by our CALL_CPP macro, which always
    # raises the less precise RuntimeError.
    assert_raises(ValueError, t.transform, 1***REMOVED***
    assert_raises(ValueError, t.transform, [[[1***REMOVED******REMOVED******REMOVED******REMOVED***
    assert_raises(RuntimeError, t.transform, [***REMOVED******REMOVED***
    assert_raises(RuntimeError, t.transform, [1***REMOVED******REMOVED***
    assert_raises(RuntimeError, t.transform, [[1***REMOVED******REMOVED******REMOVED***
    assert_raises(RuntimeError, t.transform, [[1, 2, 3***REMOVED******REMOVED******REMOVED***


if __name__ == '__main__':
    import nose
    nose.runmodule(argv=['-s', '--with-doctest'***REMOVED***,  exit=False***REMOVED***
