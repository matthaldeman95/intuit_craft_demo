from __future__ import (absolute_import, division, print_function,
                        unicode_literals***REMOVED***

from matplotlib.externals import six
from matplotlib.externals.six.moves import cPickle as pickle
from matplotlib.externals.six.moves import xrange

from io import BytesIO

from nose.tools import assert_equal, assert_not_equal
import numpy as np

from matplotlib.testing.decorators import cleanup, image_comparison
import matplotlib.pyplot as plt
import matplotlib.transforms as mtransforms


def depth_getter(obj,
                 current_depth=0,
                 depth_stack=None,
                 nest_info='top level object'***REMOVED***:
    ***REMOVED***
    Returns a dictionary mapping:

        id(obj***REMOVED***: (shallowest_depth, obj, nest_info***REMOVED***

    for the given object (and its subordinates***REMOVED***.

    This, in conjunction with recursive_pickle, can be used to debug
    pickling issues, although finding others is sometimes a case of
    trial and error.

    ***REMOVED***
    if depth_stack is None:
        depth_stack = {***REMOVED***

    if id(obj***REMOVED*** in depth_stack:
        stack = depth_stack[id(obj***REMOVED******REMOVED***
        if stack[0***REMOVED*** > current_depth:
            del depth_stack[id(obj***REMOVED******REMOVED***
        else:
            return depth_stack

    depth_stack[id(obj***REMOVED******REMOVED*** = (current_depth, obj, nest_info***REMOVED***

    if isinstance(obj, (list, tuple***REMOVED******REMOVED***:
        for i, item in enumerate(obj***REMOVED***:
            depth_getter(item, current_depth=current_depth + 1,
                         depth_stack=depth_stack,
                         nest_info=('list/tuple item #%s in '
                                    '(%s***REMOVED***' % (i, nest_info***REMOVED******REMOVED******REMOVED***
    else:
        if isinstance(obj, dict***REMOVED***:
            state = obj
        elif hasattr(obj, '__getstate__'***REMOVED***:
            state = obj.__getstate__(***REMOVED***
            if not isinstance(state, dict***REMOVED***:
                state = {***REMOVED***
        elif hasattr(obj, '__dict__'***REMOVED***:
            state = obj.__dict__
        else:
            state = {***REMOVED***

        for key, value in six.iteritems(state***REMOVED***:
            depth_getter(value, current_depth=current_depth + 1,
                         depth_stack=depth_stack,
                         nest_info=('attribute "%s" in '
                                    '(%s***REMOVED***' % (key, nest_info***REMOVED******REMOVED******REMOVED***

    return depth_stack


def recursive_pickle(top_obj***REMOVED***:
    ***REMOVED***
    Recursively pickle all of the given objects subordinates, starting with
    the deepest first. **Very** handy for debugging pickling issues, but
    also very slow (as it literally pickles each object in turn***REMOVED***.

    Handles circular object references gracefully.

    ***REMOVED***
    objs = depth_getter(top_obj***REMOVED***
    # sort by depth then by nest_info
    objs = sorted(six.itervalues(objs***REMOVED***, key=lambda val: (-val[0***REMOVED***, val[2***REMOVED******REMOVED******REMOVED***

    for _, obj, location in objs:
        ***REMOVED***
            pickle.dump(obj, BytesIO(***REMOVED***, pickle.HIGHEST_PROTOCOL***REMOVED***
        except Exception as err:
            print(obj***REMOVED***
            print('Failed to pickle %s. \n Type: %s. Traceback '
                  'follows:' % (location, type(obj***REMOVED******REMOVED******REMOVED***
            raise


@cleanup
def test_simple(***REMOVED***:
    fig = plt.figure(***REMOVED***
    # un-comment to debug
#    recursive_pickle(fig***REMOVED***
    pickle.dump(fig, BytesIO(***REMOVED***, pickle.HIGHEST_PROTOCOL***REMOVED***

    ax = plt.subplot(121***REMOVED***
    pickle.dump(ax, BytesIO(***REMOVED***, pickle.HIGHEST_PROTOCOL***REMOVED***

    ax = plt.axes(projection='polar'***REMOVED***
    plt.plot(list(xrange(10***REMOVED******REMOVED***, label='foobar'***REMOVED***
    plt.legend(***REMOVED***

    # Uncomment to debug any unpicklable objects. This is slow so is not
    # uncommented by default.
#    recursive_pickle(fig***REMOVED***
    pickle.dump(ax, BytesIO(***REMOVED***, pickle.HIGHEST_PROTOCOL***REMOVED***

#    ax = plt.subplot(121, projection='hammer'***REMOVED***
#    recursive_pickle(ax, 'figure'***REMOVED***
#    pickle.dump(ax, BytesIO(***REMOVED***, pickle.HIGHEST_PROTOCOL***REMOVED***

    plt.figure(***REMOVED***
    plt.bar(left=list(xrange(10***REMOVED******REMOVED***, height=list(xrange(10***REMOVED******REMOVED******REMOVED***
    pickle.dump(plt.gca(***REMOVED***, BytesIO(***REMOVED***, pickle.HIGHEST_PROTOCOL***REMOVED***

    fig = plt.figure(***REMOVED***
    ax = plt.axes(***REMOVED***
    plt.plot(list(xrange(10***REMOVED******REMOVED******REMOVED***
    ax.set_yscale('log'***REMOVED***
    pickle.dump(fig, BytesIO(***REMOVED***, pickle.HIGHEST_PROTOCOL***REMOVED***


@cleanup
@image_comparison(baseline_images=['multi_pickle'***REMOVED***,
                  extensions=['png'***REMOVED***, remove_text=True***REMOVED***
def test_complete(***REMOVED***:
    fig = plt.figure('Figure with a label?', figsize=(10, 6***REMOVED******REMOVED***

    plt.suptitle('Can you fit any more in a figure?'***REMOVED***

    # make some arbitrary data
    x, y = np.arange(8***REMOVED***, np.arange(10***REMOVED***
    data = u = v = np.linspace(0, 10, 80***REMOVED***.reshape(10, 8***REMOVED***
    v = np.sin(v * -0.6***REMOVED***

    plt.subplot(3, 3, 1***REMOVED***
    plt.plot(list(xrange(10***REMOVED******REMOVED******REMOVED***

    plt.subplot(3, 3, 2***REMOVED***
    plt.contourf(data, hatches=['//', 'ooo'***REMOVED******REMOVED***
    plt.colorbar(***REMOVED***

    plt.subplot(3, 3, 3***REMOVED***
    plt.pcolormesh(data***REMOVED***

    plt.subplot(3, 3, 4***REMOVED***
    plt.imshow(data***REMOVED***

    plt.subplot(3, 3, 5***REMOVED***
    plt.pcolor(data***REMOVED***

    ax = plt.subplot(3, 3, 6***REMOVED***
    ax.set_xlim(0, 7***REMOVED***
    ax.set_ylim(0, 9***REMOVED***
    plt.streamplot(x, y, u, v***REMOVED***

    ax = plt.subplot(3, 3, 7***REMOVED***
    ax.set_xlim(0, 7***REMOVED***
    ax.set_ylim(0, 9***REMOVED***
    plt.quiver(x, y, u, v***REMOVED***

    plt.subplot(3, 3, 8***REMOVED***
    plt.scatter(x, x**2, label='$x^2$'***REMOVED***
    plt.legend(loc='upper left'***REMOVED***

    plt.subplot(3, 3, 9***REMOVED***
    plt.errorbar(x, x * -0.5, xerr=0.2, yerr=0.4***REMOVED***

    ###### plotting is done, now test its pickle-ability #########

    # Uncomment to debug any unpicklable objects. This is slow (~200 seconds***REMOVED***.
#    recursive_pickle(fig***REMOVED***

    result_fh = BytesIO(***REMOVED***
    pickle.dump(fig, result_fh, pickle.HIGHEST_PROTOCOL***REMOVED***

    plt.close('all'***REMOVED***

    # make doubly sure that there are no figures left
    assert_equal(plt._pylab_helpers.Gcf.figs, {***REMOVED******REMOVED***

    # wind back the fh and load in the figure
    result_fh.seek(0***REMOVED***
    fig = pickle.load(result_fh***REMOVED***

    # make sure there is now a figure manager
    assert_not_equal(plt._pylab_helpers.Gcf.figs, {***REMOVED******REMOVED***

    assert_equal(fig.get_label(***REMOVED***, 'Figure with a label?'***REMOVED***


@cleanup
def test_no_pyplot(***REMOVED***:
    # tests pickle-ability of a figure not created with pyplot
    from matplotlib.backends.backend_pdf import FigureCanvasPdf as fc
    from matplotlib.figure import Figure

    fig = Figure(***REMOVED***
    _ = fc(fig***REMOVED***
    ax = fig.add_subplot(1, 1, 1***REMOVED***
    ax.plot([1, 2, 3***REMOVED***, [1, 2, 3***REMOVED******REMOVED***
    pickle.dump(fig, BytesIO(***REMOVED***, pickle.HIGHEST_PROTOCOL***REMOVED***


@cleanup
def test_renderer(***REMOVED***:
    from matplotlib.backends.backend_agg import RendererAgg
    renderer = RendererAgg(10, 20, 30***REMOVED***
    pickle.dump(renderer, BytesIO(***REMOVED******REMOVED***


@cleanup
def test_image(***REMOVED***:
    # Prior to v1.4.0 the Image would cache data which was not picklable
    # once it had been drawn.
    from matplotlib.backends.backend_agg import new_figure_manager
    manager = new_figure_manager(1000***REMOVED***
    fig = manager.canvas.figure
    ax = fig.add_subplot(1, 1, 1***REMOVED***
    ax.imshow(np.arange(12***REMOVED***.reshape(3, 4***REMOVED******REMOVED***
    manager.canvas.draw(***REMOVED***
    pickle.dump(fig, BytesIO(***REMOVED******REMOVED***


@cleanup
def test_grid(***REMOVED***:
    from matplotlib.backends.backend_agg import new_figure_manager
    manager = new_figure_manager(1000***REMOVED***
    fig = manager.canvas.figure
    ax = fig.add_subplot(1, 1, 1***REMOVED***
    ax.grid(***REMOVED***
    # Drawing the grid triggers instance methods to be attached
    # to the Line2D object (_lineFunc***REMOVED***.
    manager.canvas.draw(***REMOVED***

    pickle.dump(ax, BytesIO(***REMOVED******REMOVED***


@cleanup
def test_polar(***REMOVED***:
    ax = plt.subplot(111, polar=True***REMOVED***
    fig = plt.gcf(***REMOVED***
    result = BytesIO(***REMOVED***
    pf = pickle.dumps(fig***REMOVED***
    pickle.loads(pf***REMOVED***
    plt.draw(***REMOVED***


class TransformBlob(object***REMOVED***:
    def __init__(self***REMOVED***:
        self.identity = mtransforms.IdentityTransform(***REMOVED***
        self.identity2 = mtransforms.IdentityTransform(***REMOVED***
        # Force use of the more complex composition.
        self.composite = mtransforms.CompositeGenericTransform(
            self.identity,
            self.identity2***REMOVED***
        # Check parent -> child links of TransformWrapper.
        self.wrapper = mtransforms.TransformWrapper(self.composite***REMOVED***
        # Check child -> parent links of TransformWrapper.
        self.composite2 = mtransforms.CompositeGenericTransform(
            self.wrapper,
            self.identity***REMOVED***


def test_transform(***REMOVED***:
    obj = TransformBlob(***REMOVED***
    pf = pickle.dumps(obj***REMOVED***
    del obj

    obj = pickle.loads(pf***REMOVED***
    # Check parent -> child links of TransformWrapper.
    assert_equal(obj.wrapper._child, obj.composite***REMOVED***
    # Check child -> parent links of TransformWrapper.
    assert_equal(list(obj.wrapper._parents.values(***REMOVED******REMOVED***, [obj.composite2***REMOVED******REMOVED***
    # Check input and output dimensions are set as expected.
    assert_equal(obj.wrapper.input_dims, obj.composite.input_dims***REMOVED***
    assert_equal(obj.wrapper.output_dims, obj.composite.output_dims***REMOVED***


if __name__ == '__main__':
    import nose
    nose.runmodule(argv=['-s'***REMOVED******REMOVED***
