***REMOVED***
Testing that skewed axes properly work
***REMOVED***
from __future__ import (absolute_import, division, print_function,
                        unicode_literals***REMOVED***

import itertools
from matplotlib.externals import six

from nose.tools import assert_true
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.testing.decorators import cleanup, image_comparison

from matplotlib.axes import Axes
import matplotlib.transforms as transforms
import matplotlib.axis as maxis
import matplotlib.spines as mspines
import matplotlib.path as mpath
import matplotlib.patches as mpatch
from matplotlib.projections import register_projection


# The sole purpose of this class is to look at the upper, lower, or total
# interval as appropriate and see what parts of the tick to draw, if any.
class SkewXTick(maxis.XTick***REMOVED***:
    def draw(self, renderer***REMOVED***:
        if not self.get_visible(***REMOVED***:
            return
        renderer.open_group(self.__name__***REMOVED***

        lower_interval = self.axes.xaxis.lower_interval
        upper_interval = self.axes.xaxis.upper_interval

        if self.gridOn and transforms.interval_contains(
                self.axes.xaxis.get_view_interval(***REMOVED***, self.get_loc(***REMOVED******REMOVED***:
            self.gridline.draw(renderer***REMOVED***

        if transforms.interval_contains(lower_interval, self.get_loc(***REMOVED******REMOVED***:
            if self.tick1On:
                self.tick1line.draw(renderer***REMOVED***
            if self.label1On:
                self.label1.draw(renderer***REMOVED***

        if transforms.interval_contains(upper_interval, self.get_loc(***REMOVED******REMOVED***:
            if self.tick2On:
                self.tick2line.draw(renderer***REMOVED***
            if self.label2On:
                self.label2.draw(renderer***REMOVED***

        renderer.close_group(self.__name__***REMOVED***


# This class exists to provide two separate sets of intervals to the tick,
# as well as create instances of the custom tick
class SkewXAxis(maxis.XAxis***REMOVED***:
    def __init__(self, *args, **kwargs***REMOVED***:
        maxis.XAxis.__init__(self, *args, **kwargs***REMOVED***
        self.upper_interval = 0.0, 1.0

    def _get_tick(self, major***REMOVED***:
        return SkewXTick(self.axes, 0, '', major=major***REMOVED***

    @property
    def lower_interval(self***REMOVED***:
        return self.axes.viewLim.intervalx

    def get_view_interval(self***REMOVED***:
        return self.upper_interval[0***REMOVED***, self.axes.viewLim.intervalx[1***REMOVED***


# This class exists to calculate the separate data range of the
# upper X-axis and draw the spine there. It also provides this range
# to the X-axis artist for ticking and gridlines
class SkewSpine(mspines.Spine***REMOVED***:
    def __init__(self, axes, spine_type***REMOVED***:
        if spine_type == 'bottom':
            loc = 0.0
        else:
            loc = 1.0
        mspines.Spine.__init__(self, axes, spine_type,
                               mpath.Path([(13, loc***REMOVED***, (13, loc***REMOVED******REMOVED******REMOVED******REMOVED***

    def _adjust_location(self***REMOVED***:
        trans = self.axes.transDataToAxes.inverted(***REMOVED***
        if self.spine_type == 'top':
            yloc = 1.0
        else:
            yloc = 0.0
        left = trans.transform_point((0.0, yloc***REMOVED******REMOVED***[0***REMOVED***
        right = trans.transform_point((1.0, yloc***REMOVED******REMOVED***[0***REMOVED***

        pts = self._path.vertices
        pts[0, 0***REMOVED*** = left
        pts[1, 0***REMOVED*** = right
        self.axis.upper_interval = (left, right***REMOVED***


# This class handles registration of the skew-xaxes as a projection as well
# as setting up the appropriate transformations. It also overrides standard
# spines and axes instances as appropriate.
class SkewXAxes(Axes***REMOVED***:
    # The projection must specify a name.  This will be used be the
    # user to select the projection, i.e. ``subplot(111,
    # projection='skewx'***REMOVED***``.
    name = 'skewx'

    def _init_axis(self***REMOVED***:
        #Taken from Axes and modified to use our modified X-axis
        self.xaxis = SkewXAxis(self***REMOVED***
        self.spines['top'***REMOVED***.register_axis(self.xaxis***REMOVED***
        self.spines['bottom'***REMOVED***.register_axis(self.xaxis***REMOVED***
        self.yaxis = maxis.YAxis(self***REMOVED***
        self.spines['left'***REMOVED***.register_axis(self.yaxis***REMOVED***
        self.spines['right'***REMOVED***.register_axis(self.yaxis***REMOVED***

    def _gen_axes_spines(self***REMOVED***:
        spines = {'top': SkewSpine(self, 'top'***REMOVED***,
                  'bottom': mspines.Spine.linear_spine(self, 'bottom'***REMOVED***,
                  'left': mspines.Spine.linear_spine(self, 'left'***REMOVED***,
                  'right': mspines.Spine.linear_spine(self, 'right'***REMOVED******REMOVED***
        return spines

    def _set_lim_and_transforms(self***REMOVED***:
        ***REMOVED***
        This is called once when the plot is created to set up all the
        transforms for the data, text and grids.
        ***REMOVED***
        rot = 30

        #Get the standard transform setup from the Axes base class
        Axes._set_lim_and_transforms(self***REMOVED***

        # Need to put the skew in the middle, after the scale and limits,
        # but before the transAxes. This way, the skew is done in Axes
        # coordinates thus performing the transform around the proper origin
        # We keep the pre-transAxes transform around for other users, like the
        # spines for finding bounds
        self.transDataToAxes = (self.transScale +
                                (self.transLimits +
                                 transforms.Affine2D(***REMOVED***.skew_deg(rot, 0***REMOVED******REMOVED******REMOVED***

        # Create the full transform from Data to Pixels
        self.transData = self.transDataToAxes + self.transAxes

        # Blended transforms like this need to have the skewing applied using
        # both axes, in axes coords like before.
        self._xaxis_transform = (transforms.blended_transform_factory(
            self.transScale + self.transLimits,
            transforms.IdentityTransform(***REMOVED******REMOVED*** +
            transforms.Affine2D(***REMOVED***.skew_deg(rot, 0***REMOVED******REMOVED*** + self.transAxes

# Now register the projection with matplotlib so the user can select
# it.
register_projection(SkewXAxes***REMOVED***


@image_comparison(baseline_images=['skew_axes'***REMOVED***, remove_text=True***REMOVED***
def test_set_line_coll_dash_image(***REMOVED***:
    fig = plt.figure(***REMOVED***
    ax = fig.add_subplot(1, 1, 1, projection='skewx'***REMOVED***
    ax.set_xlim(-50, 50***REMOVED***
    ax.set_ylim(50, -50***REMOVED***
    ax.grid(True***REMOVED***

    # An example of a slanted line at constant X
    l = ax.axvline(0, color='b'***REMOVED***


@image_comparison(baseline_images=['skew_rects'***REMOVED***, remove_text=True***REMOVED***
def test_skew_rectange(***REMOVED***:

    fix, axes = plt.subplots(5, 5, sharex=True, sharey=True, figsize=(16, 12***REMOVED******REMOVED***
    axes = axes.flat

    rotations = list(itertools.product([-3, -1, 0, 1, 3***REMOVED***, repeat=2***REMOVED******REMOVED***

    axes[0***REMOVED***.set_xlim([-4, 4***REMOVED******REMOVED***
    axes[0***REMOVED***.set_ylim([-4, 4***REMOVED******REMOVED***
    axes[0***REMOVED***.set_aspect('equal'***REMOVED***

    for ax, (xrots, yrots***REMOVED*** in zip(axes, rotations***REMOVED***:
        xdeg, ydeg = 45 * xrots, 45 * yrots
        t = transforms.Affine2D(***REMOVED***.skew_deg(xdeg, ydeg***REMOVED***

        ax.set_title('Skew of {0***REMOVED*** in X and {1***REMOVED*** in Y'.format(xdeg, ydeg***REMOVED******REMOVED***
        ax.add_patch(mpatch.Rectangle([-1, -1***REMOVED***, 2, 2,
                                      transform=t + ax.transData,
                                      alpha=0.5, facecolor='coral'***REMOVED******REMOVED***

    plt.subplots_adjust(wspace=0, left=0, right=1, bottom=0***REMOVED***

if __name__ == '__main__':
    import nose
    nose.runmodule(argv=['-s', '--with-doctest'***REMOVED***, exit=False***REMOVED***
