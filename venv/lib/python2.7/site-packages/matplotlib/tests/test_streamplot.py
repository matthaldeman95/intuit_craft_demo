from __future__ import (absolute_import, division, print_function,
                        unicode_literals***REMOVED***

from matplotlib.externals import six

import numpy as np
from numpy.testing import assert_array_almost_equal
import matplotlib.pyplot as plt
from matplotlib.testing.decorators import image_comparison, cleanup
import matplotlib.transforms as mtransforms


def velocity_field(***REMOVED***:
    Y, X = np.mgrid[-3:3:100j, -3:3:100j***REMOVED***
    U = -1 - X**2 + Y
    V = 1 + X - Y**2
    return X, Y, U, V


@image_comparison(baseline_images=['streamplot_colormap_test_image'***REMOVED******REMOVED***
def test_colormap(***REMOVED***:
    X, Y, U, V = velocity_field(***REMOVED***
    plt.streamplot(X, Y, U, V, color=U, density=0.6, linewidth=2,
                   cmap=plt.cm.autumn***REMOVED***
    plt.colorbar(***REMOVED***


@image_comparison(baseline_images=['streamplot_linewidth_test_image'***REMOVED******REMOVED***
def test_linewidth(***REMOVED***:
    X, Y, U, V = velocity_field(***REMOVED***
    speed = np.sqrt(U*U + V*V***REMOVED***
    lw = 5*speed/speed.max(***REMOVED***
    df = 25. / 30.   # Compatibility factor for old test image
    plt.streamplot(X, Y, U, V, density=[0.5 * df, 1. * df***REMOVED***, color='k',
                   linewidth=lw***REMOVED***


@image_comparison(baseline_images=['streamplot_masks_and_nans_test_image'***REMOVED******REMOVED***
def test_masks_and_nans(***REMOVED***:
    X, Y, U, V = velocity_field(***REMOVED***
    mask = np.zeros(U.shape, dtype=bool***REMOVED***
    mask[40:60, 40:60***REMOVED*** = 1
    U = np.ma.array(U, mask=mask***REMOVED***
    U[:20, :20***REMOVED*** = np.nan
    with np.errstate(invalid='ignore'***REMOVED***:
        plt.streamplot(X, Y, U, V, color=U, cmap=plt.cm.Blues***REMOVED***


@cleanup
def test_streamplot_limits(***REMOVED***:
    ax = plt.axes(***REMOVED***
    x = np.linspace(-5, 10, 20***REMOVED***
    y = np.linspace(-2, 4, 10***REMOVED***
    y, x = np.meshgrid(y, x***REMOVED***
    trans = mtransforms.Affine2D(***REMOVED***.translate(25, 32***REMOVED*** + ax.transData
    plt.barbs(x, y, np.sin(x***REMOVED***, np.cos(y***REMOVED***, transform=trans***REMOVED***
    # The calculated bounds are approximately the bounds of the original data,
    # this is because the entire path is taken into account when updating the
    # datalim.
    assert_array_almost_equal(ax.dataLim.bounds, (20, 30, 15, 6***REMOVED***,
                              decimal=1***REMOVED***


if __name__=='__main__':
    import nose
    nose.runmodule(***REMOVED***
