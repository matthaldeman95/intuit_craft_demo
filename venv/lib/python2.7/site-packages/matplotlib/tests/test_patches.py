***REMOVED***
Tests specific to the patches module.
***REMOVED***
from __future__ import (absolute_import, division, print_function,
                        unicode_literals***REMOVED***

from matplotlib.externals import six

import numpy as np
from numpy.testing import assert_array_equal
from numpy.testing import assert_equal
from numpy.testing import assert_almost_equal

from matplotlib.patches import Polygon
from matplotlib.patches import Rectangle
from matplotlib.testing.decorators import image_comparison, cleanup
import matplotlib.pyplot as plt
import matplotlib.patches as mpatches
import matplotlib.collections as mcollections
from matplotlib import path as mpath
from matplotlib import transforms as mtrans


def test_Polygon_close(***REMOVED***:
    #: Github issue #1018 identified a bug in the Polygon handling
    #: of the closed attribute; the path was not getting closed
    #: when set_xy was used to set the vertices.

    # open set of vertices:
    xy = [[0, 0***REMOVED***, [0, 1***REMOVED***, [1, 1***REMOVED******REMOVED***
    # closed set:
    xyclosed = xy + [[0, 0***REMOVED******REMOVED***

    # start with open path and close it:
    p = Polygon(xy, closed=True***REMOVED***
    assert_array_equal(p.get_xy(***REMOVED***, xyclosed***REMOVED***
    p.set_xy(xy***REMOVED***
    assert_array_equal(p.get_xy(***REMOVED***, xyclosed***REMOVED***

    # start with closed path and open it:
    p = Polygon(xyclosed, closed=False***REMOVED***
    assert_array_equal(p.get_xy(***REMOVED***, xy***REMOVED***
    p.set_xy(xyclosed***REMOVED***
    assert_array_equal(p.get_xy(***REMOVED***, xy***REMOVED***

    # start with open path and leave it open:
    p = Polygon(xy, closed=False***REMOVED***
    assert_array_equal(p.get_xy(***REMOVED***, xy***REMOVED***
    p.set_xy(xy***REMOVED***
    assert_array_equal(p.get_xy(***REMOVED***, xy***REMOVED***

    # start with closed path and leave it closed:
    p = Polygon(xyclosed, closed=True***REMOVED***
    assert_array_equal(p.get_xy(***REMOVED***, xyclosed***REMOVED***
    p.set_xy(xyclosed***REMOVED***
    assert_array_equal(p.get_xy(***REMOVED***, xyclosed***REMOVED***


def test_rotate_rect(***REMOVED***:
    loc = np.asarray([1.0, 2.0***REMOVED******REMOVED***
    width = 2
    height = 3
    angle = 30.0

    # A rotated rectangle
    rect1 = Rectangle(loc, width, height, angle=angle***REMOVED***

    # A non-rotated rectangle
    rect2 = Rectangle(loc, width, height***REMOVED***

    # Set up an explicit rotation matrix (in radians***REMOVED***
    angle_rad = np.pi * angle / 180.0
    rotation_matrix = np.array([[np.cos(angle_rad***REMOVED***, -np.sin(angle_rad***REMOVED******REMOVED***,
                                [np.sin(angle_rad***REMOVED***,  np.cos(angle_rad***REMOVED******REMOVED******REMOVED******REMOVED***

    # Translate to origin, rotate each vertex, and then translate back
    new_verts = np.inner(rotation_matrix, rect2.get_verts(***REMOVED*** - loc***REMOVED***.T + loc

    # They should be the same
    assert_almost_equal(rect1.get_verts(***REMOVED***, new_verts***REMOVED***


@image_comparison(baseline_images=['clip_to_bbox'***REMOVED******REMOVED***
def test_clip_to_bbox(***REMOVED***:
    fig = plt.figure(***REMOVED***

    ax = fig.add_subplot(111***REMOVED***
    ax.set_xlim([-18, 20***REMOVED******REMOVED***
    ax.set_ylim([-150, 100***REMOVED******REMOVED***

    path = mpath.Path.unit_regular_star(8***REMOVED***.deepcopy(***REMOVED***
    path.vertices *= [10, 100***REMOVED***
    path.vertices -= [5, 25***REMOVED***

    path2 = mpath.Path.unit_circle(***REMOVED***.deepcopy(***REMOVED***
    path2.vertices *= [10, 100***REMOVED***
    path2.vertices += [10, -25***REMOVED***

    combined = mpath.Path.make_compound_path(path, path2***REMOVED***

    patch = mpatches.PathPatch(
        combined, alpha=0.5, facecolor='coral', edgecolor='none'***REMOVED***
    ax.add_patch(patch***REMOVED***

    bbox = mtrans.Bbox([[-12, -77.5***REMOVED***, [50, -110***REMOVED******REMOVED******REMOVED***
    result_path = combined.clip_to_bbox(bbox***REMOVED***
    result_patch = mpatches.PathPatch(
        result_path, alpha=0.5, facecolor='green', lw=4, edgecolor='black'***REMOVED***

    ax.add_patch(result_patch***REMOVED***


@image_comparison(baseline_images=['patch_alpha_coloring'***REMOVED***, remove_text=True***REMOVED***
def test_patch_alpha_coloring(***REMOVED***:
    ***REMOVED***
    Test checks that the patch and collection are rendered with the specified
    alpha values in their facecolor and edgecolor.
    ***REMOVED***
    star = mpath.Path.unit_regular_star(6***REMOVED***
    circle = mpath.Path.unit_circle(***REMOVED***
    # concatenate the star with an internal cutout of the circle
    verts = np.concatenate([circle.vertices, star.vertices[::-1***REMOVED******REMOVED******REMOVED***
    codes = np.concatenate([circle.codes, star.codes***REMOVED******REMOVED***
    cut_star1 = mpath.Path(verts, codes***REMOVED***
    cut_star2 = mpath.Path(verts + 1, codes***REMOVED***

    ax = plt.axes(***REMOVED***
    patch = mpatches.PathPatch(cut_star1,
                               linewidth=5, linestyle='dashdot',
                               facecolor=(1, 0, 0, 0.5***REMOVED***,
                               edgecolor=(0, 0, 1, 0.75***REMOVED******REMOVED***
    ax.add_patch(patch***REMOVED***

    col = mcollections.PathCollection([cut_star2***REMOVED***,
                                      linewidth=5, linestyles='dashdot',
                                      facecolor=(1, 0, 0, 0.5***REMOVED***,
                                      edgecolor=(0, 0, 1, 0.75***REMOVED******REMOVED***
    ax.add_collection(col***REMOVED***

    ax.set_xlim([-1, 2***REMOVED******REMOVED***
    ax.set_ylim([-1, 2***REMOVED******REMOVED***


@image_comparison(baseline_images=['patch_alpha_override'***REMOVED***, remove_text=True***REMOVED***
def test_patch_alpha_override(***REMOVED***:
    #: Test checks that specifying an alpha attribute for a patch or
    #: collection will override any alpha component of the facecolor
    #: or edgecolor.
    star = mpath.Path.unit_regular_star(6***REMOVED***
    circle = mpath.Path.unit_circle(***REMOVED***
    # concatenate the star with an internal cutout of the circle
    verts = np.concatenate([circle.vertices, star.vertices[::-1***REMOVED******REMOVED******REMOVED***
    codes = np.concatenate([circle.codes, star.codes***REMOVED******REMOVED***
    cut_star1 = mpath.Path(verts, codes***REMOVED***
    cut_star2 = mpath.Path(verts + 1, codes***REMOVED***

    ax = plt.axes(***REMOVED***
    patch = mpatches.PathPatch(cut_star1,
                               linewidth=5, linestyle='dashdot',
                               alpha=0.25,
                               facecolor=(1, 0, 0, 0.5***REMOVED***,
                               edgecolor=(0, 0, 1, 0.75***REMOVED******REMOVED***
    ax.add_patch(patch***REMOVED***

    col = mcollections.PathCollection([cut_star2***REMOVED***,
                                      linewidth=5, linestyles='dashdot',
                                      alpha=0.25,
                                      facecolor=(1, 0, 0, 0.5***REMOVED***,
                                      edgecolor=(0, 0, 1, 0.75***REMOVED******REMOVED***
    ax.add_collection(col***REMOVED***

    ax.set_xlim([-1, 2***REMOVED******REMOVED***
    ax.set_ylim([-1, 2***REMOVED******REMOVED***


@image_comparison(baseline_images=['patch_custom_linestyle'***REMOVED***,
                  remove_text=True***REMOVED***
def test_patch_custom_linestyle(***REMOVED***:
    #: A test to check that patches and collections accept custom dash
    #: patterns as linestyle and that they display correctly.
    star = mpath.Path.unit_regular_star(6***REMOVED***
    circle = mpath.Path.unit_circle(***REMOVED***
    # concatenate the star with an internal cutout of the circle
    verts = np.concatenate([circle.vertices, star.vertices[::-1***REMOVED******REMOVED******REMOVED***
    codes = np.concatenate([circle.codes, star.codes***REMOVED******REMOVED***
    cut_star1 = mpath.Path(verts, codes***REMOVED***
    cut_star2 = mpath.Path(verts + 1, codes***REMOVED***

    ax = plt.axes(***REMOVED***
    patch = mpatches.PathPatch(cut_star1,
                   linewidth=5, linestyle=(0.0, (5.0, 7.0, 10.0, 7.0***REMOVED******REMOVED***,
                   facecolor=(1, 0, 0***REMOVED***,
                   edgecolor=(0, 0, 1***REMOVED******REMOVED***
    ax.add_patch(patch***REMOVED***

    col = mcollections.PathCollection([cut_star2***REMOVED***,
                  linewidth=5, linestyles=[(0.0, (5.0, 7.0, 10.0, 7.0***REMOVED******REMOVED******REMOVED***,
                  facecolor=(1, 0, 0***REMOVED***,
                  edgecolor=(0, 0, 1***REMOVED******REMOVED***
    ax.add_collection(col***REMOVED***

    ax.set_xlim([-1, 2***REMOVED******REMOVED***
    ax.set_ylim([-1, 2***REMOVED******REMOVED***


@cleanup
def test_patch_linestyle_accents(***REMOVED***:
    #: Test if linestyle can also be specified with short menoics
    #: like "--"
    #: c.f. Gihub issue #2136
    star = mpath.Path.unit_regular_star(6***REMOVED***
    circle = mpath.Path.unit_circle(***REMOVED***
    # concatenate the star with an internal cutout of the circle
    verts = np.concatenate([circle.vertices, star.vertices[::-1***REMOVED******REMOVED******REMOVED***
    codes = np.concatenate([circle.codes, star.codes***REMOVED******REMOVED***

    linestyles = ["-", "--", "-.", ":",
                  "solid", "dashed", "dashdot", "dotted"***REMOVED***

    fig = plt.figure(***REMOVED***
    ax = fig.add_subplot(1, 1, 1***REMOVED***
    for i, ls in enumerate(linestyles***REMOVED***:
        star = mpath.Path(verts + i, codes***REMOVED***
        patch = mpatches.PathPatch(star,
                                   linewidth=3, linestyle=ls,
                                   facecolor=(1, 0, 0***REMOVED***,
                                   edgecolor=(0, 0, 1***REMOVED******REMOVED***
        ax.add_patch(patch***REMOVED***

    ax.set_xlim([-1, i + 1***REMOVED******REMOVED***
    ax.set_ylim([-1, i + 1***REMOVED******REMOVED***
    fig.canvas.draw(***REMOVED***
    assert True


def test_wedge_movement(***REMOVED***:
    param_dict = {'center': ((0, 0***REMOVED***, (1, 1***REMOVED***, 'set_center'***REMOVED***,
                  'r': (5, 8, 'set_radius'***REMOVED***,
                  'width': (2, 3, 'set_width'***REMOVED***,
                  'theta1': (0, 30, 'set_theta1'***REMOVED***,
                  'theta2': (45, 50, 'set_theta2'***REMOVED******REMOVED***

    init_args = dict((k, v[0***REMOVED******REMOVED*** for (k, v***REMOVED*** in six.iteritems(param_dict***REMOVED******REMOVED***

    w = mpatches.Wedge(**init_args***REMOVED***
    for attr, (old_v, new_v, func***REMOVED*** in six.iteritems(param_dict***REMOVED***:
        assert_equal(getattr(w, attr***REMOVED***, old_v***REMOVED***
        getattr(w, func***REMOVED***(new_v***REMOVED***
        assert_equal(getattr(w, attr***REMOVED***, new_v***REMOVED***


@image_comparison(baseline_images=['wedge_range'***REMOVED***,
                  remove_text=True***REMOVED***
def test_wedge_range(***REMOVED***:
    ax = plt.axes(***REMOVED***

    t1 = 2.313869244286224

    args = [[52.31386924, 232.31386924***REMOVED***,
            [52.313869244286224, 232.31386924428622***REMOVED***,
            [t1, t1 + 180.0***REMOVED***,
            [0, 360***REMOVED***,
            [90, 90 + 360***REMOVED***,
            [-180, 180***REMOVED***,
            [0, 380***REMOVED***,
            [45, 46***REMOVED***,
            [46, 45***REMOVED******REMOVED***

    for i, (theta1, theta2***REMOVED*** in enumerate(args***REMOVED***:
        x = i % 3
        y = i // 3

        wedge = mpatches.Wedge((x * 3, y * 3***REMOVED***, 1, theta1, theta2,
                               facecolor='none', edgecolor='k', lw=3***REMOVED***

        ax.add_artist(wedge***REMOVED***

    ax.set_xlim([-2, 8***REMOVED******REMOVED***
    ax.set_ylim([-2, 9***REMOVED******REMOVED***


if __name__ == '__main__':
    import nose
    nose.runmodule(argv=['-s', '--with-doctest'***REMOVED***, exit=False***REMOVED***
