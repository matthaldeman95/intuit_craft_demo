***REMOVED***
Tests specific to the collections module.
***REMOVED***
from __future__ import (absolute_import, division, print_function,
                        unicode_literals***REMOVED***

from matplotlib.externals import six

import io

from nose.tools import assert_equal
import numpy as np
from numpy.testing import assert_array_equal, assert_array_almost_equal
from nose.plugins.skip import SkipTest

import matplotlib.pyplot as plt
import matplotlib.collections as mcollections
import matplotlib.transforms as mtransforms
from matplotlib.collections import Collection, EventCollection
from matplotlib.testing.decorators import cleanup, image_comparison


def generate_EventCollection_plot(***REMOVED***:
    '''
    generate the initial collection and plot it
    '''
    positions = np.array([0., 1., 2., 3., 5., 8., 13., 21.***REMOVED******REMOVED***
    extra_positions = np.array([34., 55., 89.***REMOVED******REMOVED***
    orientation = 'horizontal'
    lineoffset = 1
    linelength = .5
    linewidth = 2
    color = [1, 0, 0, 1***REMOVED***
    linestyle = 'solid'
    antialiased = True

    coll = EventCollection(positions,
                           orientation=orientation,
                           lineoffset=lineoffset,
                           linelength=linelength,
                           linewidth=linewidth,
                           color=color,
                           linestyle=linestyle,
                           antialiased=antialiased
                           ***REMOVED***

    fig = plt.figure(***REMOVED***
    splt = fig.add_subplot(1, 1, 1***REMOVED***
    splt.add_collection(coll***REMOVED***
    splt.set_title('EventCollection: default'***REMOVED***
    props = {'positions': positions,
             'extra_positions': extra_positions,
             'orientation': orientation,
             'lineoffset': lineoffset,
             'linelength': linelength,
             'linewidth': linewidth,
             'color': color,
             'linestyle': linestyle,
             'antialiased': antialiased
         ***REMOVED***
    splt.set_xlim(-1, 22***REMOVED***
    splt.set_ylim(0, 2***REMOVED***
    return splt, coll, props


@image_comparison(baseline_images=['EventCollection_plot__default'***REMOVED******REMOVED***
def test__EventCollection__get_segments(***REMOVED***:
    '''
    check to make sure the default segments have the correct coordinates
    '''
    _, coll, props = generate_EventCollection_plot(***REMOVED***
    check_segments(coll,
                   props['positions'***REMOVED***,
                   props['linelength'***REMOVED***,
                   props['lineoffset'***REMOVED***,
                   props['orientation'***REMOVED******REMOVED***


@cleanup
def test__EventCollection__get_positions(***REMOVED***:
    '''
    check to make sure the default positions match the input positions
    '''
    _, coll, props = generate_EventCollection_plot(***REMOVED***
    np.testing.assert_array_equal(props['positions'***REMOVED***, coll.get_positions(***REMOVED******REMOVED***


@cleanup
def test__EventCollection__get_orientation(***REMOVED***:
    '''
    check to make sure the default orientation matches the input
    orientation
    '''
    _, coll, props = generate_EventCollection_plot(***REMOVED***
    assert_equal(props['orientation'***REMOVED***, coll.get_orientation(***REMOVED******REMOVED***


@cleanup
def test__EventCollection__is_horizontal(***REMOVED***:
    '''
    check to make sure the default orientation matches the input
    orientation
    '''
    _, coll, _ = generate_EventCollection_plot(***REMOVED***
    assert_equal(True, coll.is_horizontal(***REMOVED******REMOVED***


@cleanup
def test__EventCollection__get_linelength(***REMOVED***:
    '''
    check to make sure the default linelength matches the input linelength
    '''
    _, coll, props = generate_EventCollection_plot(***REMOVED***
    assert_equal(props['linelength'***REMOVED***, coll.get_linelength(***REMOVED******REMOVED***


@cleanup
def test__EventCollection__get_lineoffset(***REMOVED***:
    '''
    check to make sure the default lineoffset matches the input lineoffset
    '''
    _, coll, props = generate_EventCollection_plot(***REMOVED***
    assert_equal(props['lineoffset'***REMOVED***, coll.get_lineoffset(***REMOVED******REMOVED***


@cleanup
def test__EventCollection__get_linestyle(***REMOVED***:
    '''
    check to make sure the default linestyle matches the input linestyle
    '''
    _, coll, _ = generate_EventCollection_plot(***REMOVED***
    assert_equal(coll.get_linestyle(***REMOVED***, [(None, None***REMOVED******REMOVED******REMOVED***


@cleanup
def test__EventCollection__get_color(***REMOVED***:
    '''
    check to make sure the default color matches the input color
    '''
    _, coll, props = generate_EventCollection_plot(***REMOVED***
    np.testing.assert_array_equal(props['color'***REMOVED***, coll.get_color(***REMOVED******REMOVED***
    check_allprop_array(coll.get_colors(***REMOVED***, props['color'***REMOVED******REMOVED***


@image_comparison(baseline_images=['EventCollection_plot__set_positions'***REMOVED******REMOVED***
def test__EventCollection__set_positions(***REMOVED***:
    '''
    check to make sure set_positions works properly
    '''
    splt, coll, props = generate_EventCollection_plot(***REMOVED***
    new_positions = np.hstack([props['positions'***REMOVED***, props['extra_positions'***REMOVED******REMOVED******REMOVED***
    coll.set_positions(new_positions***REMOVED***
    np.testing.assert_array_equal(new_positions, coll.get_positions(***REMOVED******REMOVED***
    check_segments(coll, new_positions,
                   props['linelength'***REMOVED***,
                   props['lineoffset'***REMOVED***,
                   props['orientation'***REMOVED******REMOVED***
    splt.set_title('EventCollection: set_positions'***REMOVED***
    splt.set_xlim(-1, 90***REMOVED***


@image_comparison(baseline_images=['EventCollection_plot__add_positions'***REMOVED******REMOVED***
def test__EventCollection__add_positions(***REMOVED***:
    '''
    check to make sure add_positions works properly
    '''
    splt, coll, props = generate_EventCollection_plot(***REMOVED***
    new_positions = np.hstack([props['positions'***REMOVED***,
                               props['extra_positions'***REMOVED***[0***REMOVED******REMOVED******REMOVED***
    coll.add_positions(props['extra_positions'***REMOVED***[0***REMOVED******REMOVED***
    np.testing.assert_array_equal(new_positions, coll.get_positions(***REMOVED******REMOVED***
    check_segments(coll,
                   new_positions,
                   props['linelength'***REMOVED***,
                   props['lineoffset'***REMOVED***,
                   props['orientation'***REMOVED******REMOVED***
    splt.set_title('EventCollection: add_positions'***REMOVED***
    splt.set_xlim(-1, 35***REMOVED***


@image_comparison(baseline_images=['EventCollection_plot__append_positions'***REMOVED******REMOVED***
def test__EventCollection__append_positions(***REMOVED***:
    '''
    check to make sure append_positions works properly
    '''
    splt, coll, props = generate_EventCollection_plot(***REMOVED***
    new_positions = np.hstack([props['positions'***REMOVED***,
                               props['extra_positions'***REMOVED***[2***REMOVED******REMOVED******REMOVED***
    coll.append_positions(props['extra_positions'***REMOVED***[2***REMOVED******REMOVED***
    np.testing.assert_array_equal(new_positions, coll.get_positions(***REMOVED******REMOVED***
    check_segments(coll,
                   new_positions,
                   props['linelength'***REMOVED***,
                   props['lineoffset'***REMOVED***,
                   props['orientation'***REMOVED******REMOVED***
    splt.set_title('EventCollection: append_positions'***REMOVED***
    splt.set_xlim(-1, 90***REMOVED***


@image_comparison(baseline_images=['EventCollection_plot__extend_positions'***REMOVED******REMOVED***
def test__EventCollection__extend_positions(***REMOVED***:
    '''
    check to make sure extend_positions works properly
    '''
    splt, coll, props = generate_EventCollection_plot(***REMOVED***
    new_positions = np.hstack([props['positions'***REMOVED***,
                               props['extra_positions'***REMOVED***[1:***REMOVED******REMOVED******REMOVED***
    coll.extend_positions(props['extra_positions'***REMOVED***[1:***REMOVED******REMOVED***
    np.testing.assert_array_equal(new_positions, coll.get_positions(***REMOVED******REMOVED***
    check_segments(coll,
                   new_positions,
                   props['linelength'***REMOVED***,
                   props['lineoffset'***REMOVED***,
                   props['orientation'***REMOVED******REMOVED***
    splt.set_title('EventCollection: extend_positions'***REMOVED***
    splt.set_xlim(-1, 90***REMOVED***


@image_comparison(baseline_images=['EventCollection_plot__switch_orientation'***REMOVED******REMOVED***
def test__EventCollection__switch_orientation(***REMOVED***:
    '''
    check to make sure switch_orientation works properly
    '''
    splt, coll, props = generate_EventCollection_plot(***REMOVED***
    new_orientation = 'vertical'
    coll.switch_orientation(***REMOVED***
    assert_equal(new_orientation, coll.get_orientation(***REMOVED******REMOVED***
    assert_equal(False, coll.is_horizontal(***REMOVED******REMOVED***
    new_positions = coll.get_positions(***REMOVED***
    check_segments(coll,
                   new_positions,
                   props['linelength'***REMOVED***,
                   props['lineoffset'***REMOVED***, new_orientation***REMOVED***
    splt.set_title('EventCollection: switch_orientation'***REMOVED***
    splt.set_ylim(-1, 22***REMOVED***
    splt.set_xlim(0, 2***REMOVED***


@image_comparison(
    baseline_images=['EventCollection_plot__switch_orientation__2x'***REMOVED******REMOVED***
def test__EventCollection__switch_orientation_2x(***REMOVED***:
    '''
    check to make sure calling switch_orientation twice sets the
    orientation back to the default
    '''
    splt, coll, props = generate_EventCollection_plot(***REMOVED***
    coll.switch_orientation(***REMOVED***
    coll.switch_orientation(***REMOVED***
    new_positions = coll.get_positions(***REMOVED***
    assert_equal(props['orientation'***REMOVED***, coll.get_orientation(***REMOVED******REMOVED***
    assert_equal(True, coll.is_horizontal(***REMOVED******REMOVED***
    np.testing.assert_array_equal(props['positions'***REMOVED***, new_positions***REMOVED***
    check_segments(coll,
                   new_positions,
                   props['linelength'***REMOVED***,
                   props['lineoffset'***REMOVED***,
                   props['orientation'***REMOVED******REMOVED***
    splt.set_title('EventCollection: switch_orientation 2x'***REMOVED***


@image_comparison(baseline_images=['EventCollection_plot__set_orientation'***REMOVED******REMOVED***
def test__EventCollection__set_orientation(***REMOVED***:
    '''
    check to make sure set_orientation works properly
    '''
    splt, coll, props = generate_EventCollection_plot(***REMOVED***
    new_orientation = 'vertical'
    coll.set_orientation(new_orientation***REMOVED***
    assert_equal(new_orientation, coll.get_orientation(***REMOVED******REMOVED***
    assert_equal(False, coll.is_horizontal(***REMOVED******REMOVED***
    check_segments(coll,
                   props['positions'***REMOVED***,
                   props['linelength'***REMOVED***,
                   props['lineoffset'***REMOVED***,
                   new_orientation***REMOVED***
    splt.set_title('EventCollection: set_orientation'***REMOVED***
    splt.set_ylim(-1, 22***REMOVED***
    splt.set_xlim(0, 2***REMOVED***


@image_comparison(baseline_images=['EventCollection_plot__set_linelength'***REMOVED******REMOVED***
def test__EventCollection__set_linelength(***REMOVED***:
    '''
    check to make sure set_linelength works properly
    '''
    splt, coll, props = generate_EventCollection_plot(***REMOVED***
    new_linelength = 15
    coll.set_linelength(new_linelength***REMOVED***
    assert_equal(new_linelength, coll.get_linelength(***REMOVED******REMOVED***
    check_segments(coll,
                   props['positions'***REMOVED***,
                   new_linelength,
                   props['lineoffset'***REMOVED***,
                   props['orientation'***REMOVED******REMOVED***
    splt.set_title('EventCollection: set_linelength'***REMOVED***
    splt.set_ylim(-20, 20***REMOVED***


@image_comparison(baseline_images=['EventCollection_plot__set_lineoffset'***REMOVED******REMOVED***
def test__EventCollection__set_lineoffset(***REMOVED***:
    '''
    check to make sure set_lineoffset works properly
    '''
    splt, coll, props = generate_EventCollection_plot(***REMOVED***
    new_lineoffset = -5.
    coll.set_lineoffset(new_lineoffset***REMOVED***
    assert_equal(new_lineoffset, coll.get_lineoffset(***REMOVED******REMOVED***
    check_segments(coll,
                   props['positions'***REMOVED***,
                   props['linelength'***REMOVED***,
                   new_lineoffset,
                   props['orientation'***REMOVED******REMOVED***
    splt.set_title('EventCollection: set_lineoffset'***REMOVED***
    splt.set_ylim(-6, -4***REMOVED***


@image_comparison(baseline_images=['EventCollection_plot__set_linestyle'***REMOVED******REMOVED***
def test__EventCollection__set_linestyle(***REMOVED***:
    '''
    check to make sure set_linestyle works properly
    '''
    splt, coll, _ = generate_EventCollection_plot(***REMOVED***
    new_linestyle = 'dashed'
    coll.set_linestyle(new_linestyle***REMOVED***
    assert_equal(coll.get_linestyle(***REMOVED***, [(0, (6.0, 6.0***REMOVED******REMOVED******REMOVED******REMOVED***
    splt.set_title('EventCollection: set_linestyle'***REMOVED***


@image_comparison(baseline_images=['EventCollection_plot__set_ls_dash'***REMOVED***,
                  remove_text=True***REMOVED***
def test__EventCollection__set_linestyle_single_dash(***REMOVED***:
    '''
    check to make sure set_linestyle accepts a single dash pattern
    '''
    splt, coll, _ = generate_EventCollection_plot(***REMOVED***
    new_linestyle = (0, (6., 6.***REMOVED******REMOVED***
    coll.set_linestyle(new_linestyle***REMOVED***
    assert_equal(coll.get_linestyle(***REMOVED***, [(0, (6.0, 6.0***REMOVED******REMOVED******REMOVED******REMOVED***
    splt.set_title('EventCollection: set_linestyle'***REMOVED***


@image_comparison(baseline_images=['EventCollection_plot__set_linewidth'***REMOVED******REMOVED***
def test__EventCollection__set_linewidth(***REMOVED***:
    '''
    check to make sure set_linestyle works properly
    '''
    splt, coll, _ = generate_EventCollection_plot(***REMOVED***
    new_linewidth = 5
    coll.set_linewidth(new_linewidth***REMOVED***
    assert_equal(coll.get_linewidth(***REMOVED***, new_linewidth***REMOVED***
    splt.set_title('EventCollection: set_linewidth'***REMOVED***


@image_comparison(baseline_images=['EventCollection_plot__set_color'***REMOVED******REMOVED***
def test__EventCollection__set_color(***REMOVED***:
    '''
    check to make sure set_color works properly
    '''
    splt, coll, _ = generate_EventCollection_plot(***REMOVED***
    new_color = np.array([0, 1, 1, 1***REMOVED******REMOVED***
    coll.set_color(new_color***REMOVED***
    np.testing.assert_array_equal(new_color, coll.get_color(***REMOVED******REMOVED***
    check_allprop_array(coll.get_colors(***REMOVED***, new_color***REMOVED***
    splt.set_title('EventCollection: set_color'***REMOVED***


def check_segments(coll, positions, linelength, lineoffset, orientation***REMOVED***:
    '''
    check to make sure all values in the segment are correct, given a
    particular set of inputs

    note: this is not a test, it is used by tests
    '''
    segments = coll.get_segments(***REMOVED***
    if (orientation.lower(***REMOVED*** == 'horizontal'
            or orientation.lower(***REMOVED*** == 'none' or orientation is None***REMOVED***:
        # if horizontal, the position in is in the y-axis
        pos1 = 1
        pos2 = 0
    elif orientation.lower(***REMOVED*** == 'vertical':
        # if vertical, the position in is in the x-axis
        pos1 = 0
        pos2 = 1
    else:
        raise ValueError("orientation must be 'horizontal' or 'vertical'"***REMOVED***

    # test to make sure each segment is correct
    for i, segment in enumerate(segments***REMOVED***:
        assert_equal(segment[0, pos1***REMOVED***, lineoffset + linelength / 2.***REMOVED***
        assert_equal(segment[1, pos1***REMOVED***, lineoffset - linelength / 2.***REMOVED***
        assert_equal(segment[0, pos2***REMOVED***, positions[i***REMOVED******REMOVED***
        assert_equal(segment[1, pos2***REMOVED***, positions[i***REMOVED******REMOVED***


def check_allprop(values, target***REMOVED***:
    '''
    check to make sure all values match the given target

    note: this is not a test, it is used by tests
    '''
    for value in values:
        assert_equal(value, target***REMOVED***


def check_allprop_array(values, target***REMOVED***:
    '''
    check to make sure all values match the given target if arrays

    note: this is not a test, it is used by tests
    '''
    for value in values:
        np.testing.assert_array_equal(value, target***REMOVED***


def test_null_collection_datalim(***REMOVED***:
    col = mcollections.PathCollection([***REMOVED******REMOVED***
    col_data_lim = col.get_datalim(mtransforms.IdentityTransform(***REMOVED******REMOVED***
    assert_array_equal(col_data_lim.get_points(***REMOVED***,
                       mtransforms.Bbox.null(***REMOVED***.get_points(***REMOVED******REMOVED***


@cleanup
def test_add_collection(***REMOVED***:
    # Test if data limits are unchanged by adding an empty collection.
    # Github issue #1490, pull #1497.
    plt.figure(***REMOVED***
    ax = plt.axes(***REMOVED***
    coll = ax.scatter([0, 1***REMOVED***, [0, 1***REMOVED******REMOVED***
    ax.add_collection(coll***REMOVED***
    bounds = ax.dataLim.bounds
    coll = ax.scatter([***REMOVED***, [***REMOVED******REMOVED***
    assert_equal(ax.dataLim.bounds, bounds***REMOVED***


@cleanup
def test_quiver_limits(***REMOVED***:
    ax = plt.axes(***REMOVED***
    x, y = np.arange(8***REMOVED***, np.arange(10***REMOVED***
    data = u = v = np.linspace(0, 10, 80***REMOVED***.reshape(10, 8***REMOVED***
    q = plt.quiver(x, y, u, v***REMOVED***
    assert_equal(q.get_datalim(ax.transData***REMOVED***.bounds, (0., 0., 7., 9.***REMOVED******REMOVED***

    plt.figure(***REMOVED***
    ax = plt.axes(***REMOVED***
    x = np.linspace(-5, 10, 20***REMOVED***
    y = np.linspace(-2, 4, 10***REMOVED***
    y, x = np.meshgrid(y, x***REMOVED***
    trans = mtransforms.Affine2D(***REMOVED***.translate(25, 32***REMOVED*** + ax.transData
    plt.quiver(x, y, np.sin(x***REMOVED***, np.cos(y***REMOVED***, transform=trans***REMOVED***
    assert_equal(ax.dataLim.bounds, (20.0, 30.0, 15.0, 6.0***REMOVED******REMOVED***


@cleanup
def test_barb_limits(***REMOVED***:
    ax = plt.axes(***REMOVED***
    x = np.linspace(-5, 10, 20***REMOVED***
    y = np.linspace(-2, 4, 10***REMOVED***
    y, x = np.meshgrid(y, x***REMOVED***
    trans = mtransforms.Affine2D(***REMOVED***.translate(25, 32***REMOVED*** + ax.transData
    plt.barbs(x, y, np.sin(x***REMOVED***, np.cos(y***REMOVED***, transform=trans***REMOVED***
    # The calculated bounds are approximately the bounds of the original data,
    # this is because the entire path is taken into account when updating the
    # datalim.
    assert_array_almost_equal(ax.dataLim.bounds, (20, 30, 15, 6***REMOVED***,
                              decimal=1***REMOVED***


@image_comparison(baseline_images=['EllipseCollection_test_image'***REMOVED***,
                  extensions=['png'***REMOVED***,
                  remove_text=True***REMOVED***
def test_EllipseCollection(***REMOVED***:
    # Test basic functionality
    fig, ax = plt.subplots(***REMOVED***
    x = np.arange(4***REMOVED***
    y = np.arange(3***REMOVED***
    X, Y = np.meshgrid(x, y***REMOVED***
    XY = np.vstack((X.ravel(***REMOVED***, Y.ravel(***REMOVED******REMOVED******REMOVED***.T

    ww = X/float(x[-1***REMOVED******REMOVED***
    hh = Y/float(y[-1***REMOVED******REMOVED***
    aa = np.ones_like(ww***REMOVED*** * 20  # first axis is 20 degrees CCW from x axis

    ec = mcollections.EllipseCollection(ww, hh, aa,
                                        units='x',
                                        offsets=XY,
                                        transOffset=ax.transData,
                                        facecolors='none'***REMOVED***
    ax.add_collection(ec***REMOVED***
    ax.autoscale_view(***REMOVED***


@image_comparison(baseline_images=['polycollection_close'***REMOVED***,
                  extensions=['png'***REMOVED***, remove_text=True***REMOVED***
def test_polycollection_close(***REMOVED***:
    from mpl_toolkits.mplot3d import Axes3D

    vertsQuad = [
        [[0., 0.***REMOVED***, [0., 1.***REMOVED***, [1., 1.***REMOVED***, [1., 0.***REMOVED******REMOVED***,
        [[0., 1.***REMOVED***, [2., 3.***REMOVED***, [2., 2.***REMOVED***, [1., 1.***REMOVED******REMOVED***,
        [[2., 2.***REMOVED***, [2., 3.***REMOVED***, [4., 1.***REMOVED***, [3., 1.***REMOVED******REMOVED***,
        [[3., 0.***REMOVED***, [3., 1.***REMOVED***, [4., 1.***REMOVED***, [4., 0.***REMOVED******REMOVED******REMOVED***

    fig = plt.figure(***REMOVED***
    ax = Axes3D(fig***REMOVED***

    colors = ['r', 'g', 'b', 'y', 'k'***REMOVED***
    zpos = list(range(5***REMOVED******REMOVED***

    poly = mcollections.PolyCollection(
        vertsQuad * len(zpos***REMOVED***, linewidth=0.25***REMOVED***
    poly.set_alpha(0.7***REMOVED***

    # need to have a z-value for *each* polygon = element!
    zs = [***REMOVED***
    cs = [***REMOVED***
    for z, c in zip(zpos, colors***REMOVED***:
        zs.extend([z***REMOVED*** * len(vertsQuad***REMOVED******REMOVED***
        cs.extend([c***REMOVED*** * len(vertsQuad***REMOVED******REMOVED***

    poly.set_color(cs***REMOVED***

    ax.add_collection3d(poly, zs=zs, zdir='y'***REMOVED***

    # axis limit settings:
    ax.set_xlim3d(0, 4***REMOVED***
    ax.set_zlim3d(0, 3***REMOVED***
    ax.set_ylim3d(0, 4***REMOVED***


@image_comparison(baseline_images=['regularpolycollection_rotate'***REMOVED***,
                  extensions=['png'***REMOVED***, remove_text=True***REMOVED***
def test_regularpolycollection_rotate(***REMOVED***:
    xx, yy = np.mgrid[:10, :10***REMOVED***
    xy_points = np.transpose([xx.flatten(***REMOVED***, yy.flatten(***REMOVED******REMOVED******REMOVED***
    rotations = np.linspace(0, 2*np.pi, len(xy_points***REMOVED******REMOVED***

    fig, ax = plt.subplots(***REMOVED***
    for xy, alpha in zip(xy_points, rotations***REMOVED***:
        col = mcollections.RegularPolyCollection(
            4, sizes=(100,***REMOVED***, rotation=alpha,
            offsets=xy, transOffset=ax.transData***REMOVED***
        ax.add_collection(col, autolim=True***REMOVED***
    ax.autoscale_view(***REMOVED***


@image_comparison(baseline_images=['regularpolycollection_scale'***REMOVED***,
                  extensions=['png'***REMOVED***, remove_text=True***REMOVED***
def test_regularpolycollection_scale(***REMOVED***:
    # See issue #3860

    class SquareCollection(mcollections.RegularPolyCollection***REMOVED***:
        def __init__(self, **kwargs***REMOVED***:
            super(SquareCollection, self***REMOVED***.__init__(
                4, rotation=np.pi/4., **kwargs***REMOVED***

        def get_transform(self***REMOVED***:
            ***REMOVED***Return transform scaling circle areas to data space.***REMOVED***
            ax = self.axes

            pts2pixels = 72.0 / ax.figure.dpi

            scale_x = pts2pixels * ax.bbox.width / ax.viewLim.width
            scale_y = pts2pixels * ax.bbox.height / ax.viewLim.height
            return mtransforms.Affine2D(***REMOVED***.scale(scale_x, scale_y***REMOVED***

    fig, ax = plt.subplots(***REMOVED***

    xy = [(0, 0***REMOVED******REMOVED***
    # Unit square has a half-diagonal of `1 / sqrt(2***REMOVED***`, so `pi * r**2`
    # equals...
    circle_areas = [np.pi / 2***REMOVED***
    squares = SquareCollection(sizes=circle_areas, offsets=xy,
                               transOffset=ax.transData***REMOVED***
    ax.add_collection(squares, autolim=True***REMOVED***
    ax.axis([-1, 1, -1, 1***REMOVED******REMOVED***


@cleanup
def test_picking(***REMOVED***:
    fig, ax = plt.subplots(***REMOVED***
    col = ax.scatter([0***REMOVED***, [0***REMOVED***, [1000***REMOVED******REMOVED***
    fig.savefig(io.BytesIO(***REMOVED***, dpi=fig.dpi***REMOVED***

    class MouseEvent(object***REMOVED***:
        pass
    event = MouseEvent(***REMOVED***
    event.x = 325
    event.y = 240

    found, indices = col.contains(event***REMOVED***
    assert found
    assert_array_equal(indices['ind'***REMOVED***, [0***REMOVED******REMOVED***


@cleanup
def test_linestyle_single_dashes(***REMOVED***:
    plt.scatter([0, 1, 2***REMOVED***, [0, 1, 2***REMOVED***, linestyle=(0., [2., 2.***REMOVED******REMOVED******REMOVED***
    plt.draw(***REMOVED***


@image_comparison(baseline_images=['size_in_xy'***REMOVED***, remove_text=True,
                  extensions=['png'***REMOVED******REMOVED***
def test_size_in_xy(***REMOVED***:
    fig, ax = plt.subplots(***REMOVED***

    widths, heights, angles = (10, 10***REMOVED***, 10, 0
    widths = 10, 10
    coords = [(10, 10***REMOVED***, (15, 15***REMOVED******REMOVED***
    e = mcollections.EllipseCollection(
        widths, heights, angles,
        units='xy',
        offsets=coords,
        transOffset=ax.transData***REMOVED***

    ax.add_collection(e***REMOVED***

    ax.set_xlim(0, 30***REMOVED***
    ax.set_ylim(0, 30***REMOVED***


def test_pandas_indexing(***REMOVED***:
    ***REMOVED***
        import pandas as pd
    except ImportError:
        raise SkipTest("Pandas not installed"***REMOVED***

    # Should not fail break when faced with a
    # non-zero indexed series
    index = [11, 12, 13***REMOVED***
    ec = fc = pd.Series(['red', 'blue', 'green'***REMOVED***, index=index***REMOVED***
    lw = pd.Series([1, 2, 3***REMOVED***, index=index***REMOVED***
    ls = pd.Series(['solid', 'dashed', 'dashdot'***REMOVED***, index=index***REMOVED***
    aa = pd.Series([True, False, True***REMOVED***, index=index***REMOVED***

    Collection(edgecolors=ec***REMOVED***
    Collection(facecolors=fc***REMOVED***
    Collection(linewidths=lw***REMOVED***
    Collection(linestyles=ls***REMOVED***
    Collection(antialiaseds=aa***REMOVED***


if __name__ == '__main__':
    import nose
    nose.runmodule(argv=['-s', '--with-doctest'***REMOVED***, exit=False***REMOVED***
