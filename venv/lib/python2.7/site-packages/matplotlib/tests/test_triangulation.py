from __future__ import (absolute_import, division, print_function,
                        unicode_literals***REMOVED***

from matplotlib.externals import six

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.tri as mtri
from nose.tools import assert_equal, assert_raises, assert_true, assert_false
from numpy.testing import assert_array_equal, assert_array_almost_equal,\
    assert_array_less
import numpy.ma.testutils as matest
from matplotlib.testing.decorators import cleanup, image_comparison
import matplotlib.cm as cm
from matplotlib.path import Path


def test_delaunay(***REMOVED***:
    # No duplicate points, regular grid.
    nx = 5
    ny = 4
    x, y = np.meshgrid(np.linspace(0.0, 1.0, nx***REMOVED***, np.linspace(0.0, 1.0, ny***REMOVED******REMOVED***
    x = x.ravel(***REMOVED***
    y = y.ravel(***REMOVED***
    npoints = nx*ny
    ntriangles = 2 * (nx-1***REMOVED*** * (ny-1***REMOVED***
    nedges = 3*nx*ny - 2*nx - 2*ny + 1

    # Create delaunay triangulation.
    triang = mtri.Triangulation(x, y***REMOVED***

    # The tests in the remainder of this function should be passed by any
    # triangulation that does not contain duplicate points.

    # Points - floating point.
    assert_array_almost_equal(triang.x, x***REMOVED***
    assert_array_almost_equal(triang.y, y***REMOVED***

    # Triangles - integers.
    assert_equal(len(triang.triangles***REMOVED***, ntriangles***REMOVED***
    assert_equal(np.min(triang.triangles***REMOVED***, 0***REMOVED***
    assert_equal(np.max(triang.triangles***REMOVED***, npoints-1***REMOVED***

    # Edges - integers.
    assert_equal(len(triang.edges***REMOVED***, nedges***REMOVED***
    assert_equal(np.min(triang.edges***REMOVED***, 0***REMOVED***
    assert_equal(np.max(triang.edges***REMOVED***, npoints-1***REMOVED***

    # Neighbors - integers.
    # Check that neighbors calculated by C++ triangulation class are the same
    # as those returned from delaunay routine.
    neighbors = triang.neighbors
    triang._neighbors = None
    assert_array_equal(triang.neighbors, neighbors***REMOVED***

    # Is each point used in at least one triangle?
    assert_array_equal(np.unique(triang.triangles***REMOVED***, np.arange(npoints***REMOVED******REMOVED***


def test_delaunay_duplicate_points(***REMOVED***:
    # x[duplicate***REMOVED*** == x[duplicate_of***REMOVED***
    # y[duplicate***REMOVED*** == y[duplicate_of***REMOVED***
    npoints = 10
    duplicate = 7
    duplicate_of = 3

    np.random.seed(23***REMOVED***
    x = np.random.random((npoints***REMOVED******REMOVED***
    y = np.random.random((npoints***REMOVED******REMOVED***
    x[duplicate***REMOVED*** = x[duplicate_of***REMOVED***
    y[duplicate***REMOVED*** = y[duplicate_of***REMOVED***

    # Create delaunay triangulation.
    triang = mtri.Triangulation(x, y***REMOVED***

    # Duplicate points should be ignored, so the index of the duplicate points
    # should not appear in any triangle.
    assert_array_equal(np.unique(triang.triangles***REMOVED***,
                       np.delete(np.arange(npoints***REMOVED***, duplicate***REMOVED******REMOVED***


def test_delaunay_points_in_line(***REMOVED***:
    # Cannot triangulate points that are all in a straight line, but check
    # that delaunay code fails gracefully.
    x = np.linspace(0.0, 10.0, 11***REMOVED***
    y = np.linspace(0.0, 10.0, 11***REMOVED***
    assert_raises(RuntimeError, mtri.Triangulation, x, y***REMOVED***

    # Add an extra point not on the line and the triangulation is OK.
    x = np.append(x, 2.0***REMOVED***
    y = np.append(y, 8.0***REMOVED***
    triang = mtri.Triangulation(x, y***REMOVED***


def test_delaunay_insufficient_points(***REMOVED***:
    # Triangulation should raise a ValueError if passed less than 3 points.
    assert_raises(ValueError, mtri.Triangulation, [***REMOVED***, [***REMOVED******REMOVED***
    assert_raises(ValueError, mtri.Triangulation, [1***REMOVED***, [5***REMOVED******REMOVED***
    assert_raises(ValueError, mtri.Triangulation, [1, 2***REMOVED***, [5, 6***REMOVED******REMOVED***

    # Triangulation should also raise a ValueError if passed duplicate points
    # such that there are less than 3 unique points.
    assert_raises(ValueError, mtri.Triangulation, [1, 2, 1***REMOVED***, [5, 6, 5***REMOVED******REMOVED***
    assert_raises(ValueError, mtri.Triangulation, [1, 2, 2***REMOVED***, [5, 6, 6***REMOVED******REMOVED***
    assert_raises(ValueError, mtri.Triangulation, [1, 1, 1, 2, 1, 2***REMOVED***,
                  [5, 5, 5, 6, 5, 6***REMOVED******REMOVED***


def test_delaunay_robust(***REMOVED***:
    # Fails when mtri.Triangulation uses matplotlib.delaunay, works when using
    # qhull.
    tri_points = np.array([
        [0.8660254037844384, -0.5000000000000004***REMOVED***,
        [0.7577722283113836, -0.5000000000000004***REMOVED***,
        [0.6495190528383288, -0.5000000000000003***REMOVED***,
        [0.5412658773652739, -0.5000000000000003***REMOVED***,
        [0.811898816047911, -0.40625000000000044***REMOVED***,
        [0.7036456405748561, -0.4062500000000004***REMOVED***,
        [0.5953924651018013, -0.40625000000000033***REMOVED******REMOVED******REMOVED***
    test_points = np.asarray([
        [0.58, -0.46***REMOVED***,
        [0.65, -0.46***REMOVED***,
        [0.65, -0.42***REMOVED***,
        [0.7, -0.48***REMOVED***,
        [0.7, -0.44***REMOVED***,
        [0.75, -0.44***REMOVED***,
        [0.8, -0.48***REMOVED******REMOVED******REMOVED***

    # Utility function that indicates if a triangle defined by 3 points
    # (xtri, ytri***REMOVED*** contains the test point xy.  Avoid calling with a point that
    # lies on or very near to an edge of the triangle.
    def tri_contains_point(xtri, ytri, xy***REMOVED***:
        tri_points = np.vstack((xtri, ytri***REMOVED******REMOVED***.T
        return Path(tri_points***REMOVED***.contains_point(xy***REMOVED***

    # Utility function that returns how many triangles of the specified
    # triangulation contain the test point xy.  Avoid calling with a point that
    # lies on or very near to an edge of any triangle in the triangulation.
    def tris_contain_point(triang, xy***REMOVED***:
        count = 0
        for tri in triang.triangles:
            if tri_contains_point(triang.x[tri***REMOVED***, triang.y[tri***REMOVED***, xy***REMOVED***:
                count += 1
        return count

    # Using matplotlib.delaunay, an invalid triangulation is created with
    # overlapping triangles; qhull is OK.
    triang = mtri.Triangulation(tri_points[:, 0***REMOVED***, tri_points[:, 1***REMOVED******REMOVED***
    for test_point in test_points:
        assert_equal(tris_contain_point(triang, test_point***REMOVED***, 1***REMOVED***

    # If ignore the first point of tri_points, matplotlib.delaunay throws a
    # KeyError when calculating the convex hull; qhull is OK.
    triang = mtri.Triangulation(tri_points[1:, 0***REMOVED***, tri_points[1:, 1***REMOVED******REMOVED***


@image_comparison(baseline_images=['tripcolor1'***REMOVED***, extensions=['png'***REMOVED******REMOVED***
def test_tripcolor(***REMOVED***:
    x = np.asarray([0, 0.5, 1, 0,   0.5, 1,   0, 0.5, 1, 0.75***REMOVED******REMOVED***
    y = np.asarray([0, 0,   0, 0.5, 0.5, 0.5, 1, 1,   1, 0.75***REMOVED******REMOVED***
    triangles = np.asarray([
        [0, 1, 3***REMOVED***, [1, 4, 3***REMOVED***,
        [1, 2, 4***REMOVED***, [2, 5, 4***REMOVED***,
        [3, 4, 6***REMOVED***, [4, 7, 6***REMOVED***,
        [4, 5, 9***REMOVED***, [7, 4, 9***REMOVED***, [8, 7, 9***REMOVED***, [5, 8, 9***REMOVED******REMOVED******REMOVED***

    # Triangulation with same number of points and triangles.
    triang = mtri.Triangulation(x, y, triangles***REMOVED***

    Cpoints = x + 0.5*y

    xmid = x[triang.triangles***REMOVED***.mean(axis=1***REMOVED***
    ymid = y[triang.triangles***REMOVED***.mean(axis=1***REMOVED***
    Cfaces = 0.5*xmid + ymid

    plt.subplot(121***REMOVED***
    plt.tripcolor(triang, Cpoints, edgecolors='k'***REMOVED***
    plt.title('point colors'***REMOVED***

    plt.subplot(122***REMOVED***
    plt.tripcolor(triang, facecolors=Cfaces, edgecolors='k'***REMOVED***
    plt.title('facecolors'***REMOVED***


def test_no_modify(***REMOVED***:
    # Test that Triangulation does not modify triangles array passed to it.
    triangles = np.array([[3, 2, 0***REMOVED***, [3, 1, 0***REMOVED******REMOVED***, dtype=np.int32***REMOVED***
    points = np.array([(0, 0***REMOVED***, (0, 1.1***REMOVED***, (1, 0***REMOVED***, (1, 1***REMOVED******REMOVED******REMOVED***

    old_triangles = triangles.copy(***REMOVED***
    tri = mtri.Triangulation(points[:, 0***REMOVED***, points[:, 1***REMOVED***, triangles***REMOVED***
    edges = tri.edges
    assert_array_equal(old_triangles, triangles***REMOVED***


def test_trifinder(***REMOVED***:
    # Test points within triangles of masked triangulation.
    x, y = np.meshgrid(np.arange(4***REMOVED***, np.arange(4***REMOVED******REMOVED***
    x = x.ravel(***REMOVED***
    y = y.ravel(***REMOVED***
    triangles = [[0, 1, 4***REMOVED***, [1, 5, 4***REMOVED***, [1, 2, 5***REMOVED***, [2, 6, 5***REMOVED***, [2, 3, 6***REMOVED***,
                 [3, 7, 6***REMOVED***, [4, 5, 8***REMOVED***, [5, 9, 8***REMOVED***, [5, 6, 9***REMOVED***, [6, 10, 9***REMOVED***,
                 [6, 7, 10***REMOVED***, [7, 11, 10***REMOVED***, [8, 9, 12***REMOVED***, [9, 13, 12***REMOVED***, [9, 10, 13***REMOVED***,
                 [10, 14, 13***REMOVED***, [10, 11, 14***REMOVED***, [11, 15, 14***REMOVED******REMOVED***
    mask = np.zeros(len(triangles***REMOVED******REMOVED***
    mask[8:10***REMOVED*** = 1
    triang = mtri.Triangulation(x, y, triangles, mask***REMOVED***
    trifinder = triang.get_trifinder(***REMOVED***

    xs = [0.25, 1.25, 2.25, 3.25***REMOVED***
    ys = [0.25, 1.25, 2.25, 3.25***REMOVED***
    xs, ys = np.meshgrid(xs, ys***REMOVED***
    xs = xs.ravel(***REMOVED***
    ys = ys.ravel(***REMOVED***
    tris = trifinder(xs, ys***REMOVED***
    assert_array_equal(tris, [0, 2, 4, -1, 6, -1, 10, -1,
                              12, 14, 16, -1, -1, -1, -1, -1***REMOVED******REMOVED***
    tris = trifinder(xs-0.5, ys-0.5***REMOVED***
    assert_array_equal(tris, [-1, -1, -1, -1, -1, 1, 3, 5,
                              -1, 7, -1, 11, -1, 13, 15, 17***REMOVED******REMOVED***

    # Test points exactly on boundary edges of masked triangulation.
    xs = [0.5, 1.5, 2.5, 0.5, 1.5, 2.5, 1.5, 1.5, 0.0, 1.0, 2.0, 3.0***REMOVED***
    ys = [0.0, 0.0, 0.0, 3.0, 3.0, 3.0, 1.0, 2.0, 1.5, 1.5, 1.5, 1.5***REMOVED***
    tris = trifinder(xs, ys***REMOVED***
    assert_array_equal(tris, [0, 2, 4, 13, 15, 17, 3, 14, 6, 7, 10, 11***REMOVED******REMOVED***

    # Test points exactly on boundary corners of masked triangulation.
    xs = [0.0, 3.0***REMOVED***
    ys = [0.0, 3.0***REMOVED***
    tris = trifinder(xs, ys***REMOVED***
    assert_array_equal(tris, [0, 17***REMOVED******REMOVED***

    # Test triangles with horizontal colinear points.  These are not valid
    # triangulations, but we try to deal with the simplest violations.
    delta = 0.0  # If +ve, triangulation is OK, if -ve triangulation invalid,
                 # if zero have colinear points but should pass tests anyway.
    x = [1.5, 0,  1,  2, 3, 1.5,   1.5***REMOVED***
    y = [-1,  0,  0,  0, 0, delta, 1***REMOVED***
    triangles = [[0, 2, 1***REMOVED***, [0, 3, 2***REMOVED***, [0, 4, 3***REMOVED***, [1, 2, 5***REMOVED***, [2, 3, 5***REMOVED***,
                 [3, 4, 5***REMOVED***, [1, 5, 6***REMOVED***, [4, 6, 5***REMOVED******REMOVED***
    triang = mtri.Triangulation(x, y, triangles***REMOVED***
    trifinder = triang.get_trifinder(***REMOVED***

    xs = [-0.1, 0.4, 0.9, 1.4, 1.9, 2.4, 2.9***REMOVED***
    ys = [-0.1, 0.1***REMOVED***
    xs, ys = np.meshgrid(xs, ys***REMOVED***
    tris = trifinder(xs, ys***REMOVED***
    assert_array_equal(tris, [[-1, 0, 0, 1, 1, 2, -1***REMOVED***,
                              [-1, 6, 6, 6, 7, 7, -1***REMOVED******REMOVED******REMOVED***

    # Test triangles with vertical colinear points.  These are not valid
    # triangulations, but we try to deal with the simplest violations.
    delta = 0.0  # If +ve, triangulation is OK, if -ve triangulation invalid,
                # if zero have colinear points but should pass tests anyway.
    x = [-1, -delta, 0,  0,  0, 0, 1***REMOVED***
    y = [1.5, 1.5,   0,  1,  2, 3, 1.5***REMOVED***
    triangles = [[0, 1, 2***REMOVED***, [0, 1, 5***REMOVED***, [1, 2, 3***REMOVED***, [1, 3, 4***REMOVED***, [1, 4, 5***REMOVED***,
                 [2, 6, 3***REMOVED***, [3, 6, 4***REMOVED***, [4, 6, 5***REMOVED******REMOVED***
    triang = mtri.Triangulation(x, y, triangles***REMOVED***
    trifinder = triang.get_trifinder(***REMOVED***

    xs = [-0.1, 0.1***REMOVED***
    ys = [-0.1, 0.4, 0.9, 1.4, 1.9, 2.4, 2.9***REMOVED***
    xs, ys = np.meshgrid(xs, ys***REMOVED***
    tris = trifinder(xs, ys***REMOVED***
    assert_array_equal(tris, [[-1, -1***REMOVED***, [0, 5***REMOVED***, [0, 5***REMOVED***, [0, 6***REMOVED***, [1, 6***REMOVED***, [1, 7***REMOVED***,
                              [-1, -1***REMOVED******REMOVED******REMOVED***

    # Test that changing triangulation by setting a mask causes the trifinder
    # to be reinitialised.
    x = [0, 1, 0, 1***REMOVED***
    y = [0, 0, 1, 1***REMOVED***
    triangles = [[0, 1, 2***REMOVED***, [1, 3, 2***REMOVED******REMOVED***
    triang = mtri.Triangulation(x, y, triangles***REMOVED***
    trifinder = triang.get_trifinder(***REMOVED***

    xs = [-0.2, 0.2, 0.8, 1.2***REMOVED***
    ys = [ 0.5, 0.5, 0.5, 0.5***REMOVED***
    tris = trifinder(xs, ys***REMOVED***
    assert_array_equal(tris, [-1, 0, 1, -1***REMOVED******REMOVED***

    triang.set_mask([1, 0***REMOVED******REMOVED***
    assert_equal(trifinder, triang.get_trifinder(***REMOVED******REMOVED***
    tris = trifinder(xs, ys***REMOVED***
    assert_array_equal(tris, [-1, -1, 1, -1***REMOVED******REMOVED***


def test_triinterp(***REMOVED***:
    # Test points within triangles of masked triangulation.
    x, y = np.meshgrid(np.arange(4***REMOVED***, np.arange(4***REMOVED******REMOVED***
    x = x.ravel(***REMOVED***
    y = y.ravel(***REMOVED***
    z = 1.23*x - 4.79*y
    triangles = [[0, 1, 4***REMOVED***, [1, 5, 4***REMOVED***, [1, 2, 5***REMOVED***, [2, 6, 5***REMOVED***, [2, 3, 6***REMOVED***,
                 [3, 7, 6***REMOVED***, [4, 5, 8***REMOVED***, [5, 9, 8***REMOVED***, [5, 6, 9***REMOVED***, [6, 10, 9***REMOVED***,
                 [6, 7, 10***REMOVED***, [7, 11, 10***REMOVED***, [8, 9, 12***REMOVED***, [9, 13, 12***REMOVED***, [9, 10, 13***REMOVED***,
                 [10, 14, 13***REMOVED***, [10, 11, 14***REMOVED***, [11, 15, 14***REMOVED******REMOVED***
    mask = np.zeros(len(triangles***REMOVED******REMOVED***
    mask[8:10***REMOVED*** = 1
    triang = mtri.Triangulation(x, y, triangles, mask***REMOVED***
    linear_interp = mtri.LinearTriInterpolator(triang, z***REMOVED***
    cubic_min_E = mtri.CubicTriInterpolator(triang, z***REMOVED***
    cubic_geom = mtri.CubicTriInterpolator(triang, z, kind='geom'***REMOVED***

    xs = np.linspace(0.25, 2.75, 6***REMOVED***
    ys = [0.25, 0.75, 2.25, 2.75***REMOVED***
    xs, ys = np.meshgrid(xs, ys***REMOVED***  # Testing arrays with array.ndim = 2
    for interp in (linear_interp, cubic_min_E, cubic_geom***REMOVED***:
        zs = interp(xs, ys***REMOVED***
        assert_array_almost_equal(zs, (1.23*xs - 4.79*ys***REMOVED******REMOVED***

    # Test points outside triangulation.
    xs = [-0.25, 1.25, 1.75, 3.25***REMOVED***
    ys = xs
    xs, ys = np.meshgrid(xs, ys***REMOVED***
    for interp in (linear_interp, cubic_min_E, cubic_geom***REMOVED***:
        zs = linear_interp(xs, ys***REMOVED***
        assert_array_equal(zs.mask, [[True***REMOVED****4***REMOVED****4***REMOVED***

    # Test mixed configuration (outside / inside***REMOVED***.
    xs = np.linspace(0.25, 1.75, 6***REMOVED***
    ys = [0.25, 0.75, 1.25, 1.75***REMOVED***
    xs, ys = np.meshgrid(xs, ys***REMOVED***
    for interp in (linear_interp, cubic_min_E, cubic_geom***REMOVED***:
        zs = interp(xs, ys***REMOVED***
        matest.assert_array_almost_equal(zs, (1.23*xs - 4.79*ys***REMOVED******REMOVED***
        mask = (xs >= 1***REMOVED*** * (xs <= 2***REMOVED*** * (ys >= 1***REMOVED*** * (ys <= 2***REMOVED***
        assert_array_equal(zs.mask, mask***REMOVED***

    # 2nd order patch test: on a grid with an 'arbitrary shaped' triangle,
    # patch test shall be exact for quadratic functions and cubic
    # interpolator if *kind* = user
    (a, b, c***REMOVED*** = (1.23, -4.79, 0.6***REMOVED***

    def quad(x, y***REMOVED***:
        return a*(x-0.5***REMOVED*****2 + b*(y-0.5***REMOVED*****2 + c*x*y

    def gradient_quad(x, y***REMOVED***:
        return (2*a*(x-0.5***REMOVED*** + c*y, 2*b*(y-0.5***REMOVED*** + c*x***REMOVED***

    x = np.array([0.2, 0.33367, 0.669, 0., 1., 1., 0.***REMOVED******REMOVED***
    y = np.array([0.3, 0.80755, 0.4335, 0., 0., 1., 1.***REMOVED******REMOVED***
    triangles = np.array([[0, 1, 2***REMOVED***, [3, 0, 4***REMOVED***, [4, 0, 2***REMOVED***, [4, 2, 5***REMOVED***,
                          [1, 5, 2***REMOVED***, [6, 5, 1***REMOVED***, [6, 1, 0***REMOVED***, [6, 0, 3***REMOVED******REMOVED******REMOVED***
    triang = mtri.Triangulation(x, y, triangles***REMOVED***
    z = quad(x, y***REMOVED***
    dz = gradient_quad(x, y***REMOVED***
    # test points for 2nd order patch test
    xs = np.linspace(0., 1., 5***REMOVED***
    ys = np.linspace(0., 1., 5***REMOVED***
    xs, ys = np.meshgrid(xs, ys***REMOVED***
    cubic_user = mtri.CubicTriInterpolator(triang, z, kind='user', dz=dz***REMOVED***
    interp_zs = cubic_user(xs, ys***REMOVED***
    assert_array_almost_equal(interp_zs, quad(xs, ys***REMOVED******REMOVED***
    (interp_dzsdx, interp_dzsdy***REMOVED*** = cubic_user.gradient(x, y***REMOVED***
    (dzsdx, dzsdy***REMOVED*** = gradient_quad(x, y***REMOVED***
    assert_array_almost_equal(interp_dzsdx, dzsdx***REMOVED***
    assert_array_almost_equal(interp_dzsdy, dzsdy***REMOVED***

    # Cubic improvement: cubic interpolation shall perform better than linear
    # on a sufficiently dense mesh for a quadratic function.
    n = 11
    x, y = np.meshgrid(np.linspace(0., 1., n+1***REMOVED***, np.linspace(0., 1., n+1***REMOVED******REMOVED***
    x = x.ravel(***REMOVED***
    y = y.ravel(***REMOVED***
    z = quad(x, y***REMOVED***
    triang = mtri.Triangulation(x, y, triangles=meshgrid_triangles(n+1***REMOVED******REMOVED***
    xs, ys = np.meshgrid(np.linspace(0.1, 0.9, 5***REMOVED***, np.linspace(0.1, 0.9, 5***REMOVED******REMOVED***
    xs = xs.ravel(***REMOVED***
    ys = ys.ravel(***REMOVED***
    linear_interp = mtri.LinearTriInterpolator(triang, z***REMOVED***
    cubic_min_E = mtri.CubicTriInterpolator(triang, z***REMOVED***
    cubic_geom = mtri.CubicTriInterpolator(triang, z, kind='geom'***REMOVED***
    zs = quad(xs, ys***REMOVED***
    diff_lin = np.abs(linear_interp(xs, ys***REMOVED*** - zs***REMOVED***
    for interp in (cubic_min_E, cubic_geom***REMOVED***:
        diff_cubic = np.abs(interp(xs, ys***REMOVED*** - zs***REMOVED***
        assert(np.max(diff_lin***REMOVED*** >= 10.*np.max(diff_cubic***REMOVED******REMOVED***
        assert(np.dot(diff_lin, diff_lin***REMOVED*** >=
               100.*np.dot(diff_cubic, diff_cubic***REMOVED******REMOVED***


def test_triinterpcubic_C1_continuity(***REMOVED***:
    # Below the 4 tests which demonstrate C1 continuity of the
    # TriCubicInterpolator (testing the cubic shape functions on arbitrary
    # triangle***REMOVED***:
    #
    # 1***REMOVED*** Testing continuity of function & derivatives at corner for all 9
    #    shape functions. Testing also function values at same location.
    # 2***REMOVED*** Testing C1 continuity along each edge (as gradient is polynomial of
    #    2nd order, it is sufficient to test at the middle***REMOVED***.
    # 3***REMOVED*** Testing C1 continuity at triangle barycenter (where the 3 subtriangles
    #    meet***REMOVED***
    # 4***REMOVED*** Testing C1 continuity at median 1/3 points (midside between 2
    #    subtriangles***REMOVED***

    # Utility test function check_continuity
    def check_continuity(interpolator, loc, values=None***REMOVED***:
        ***REMOVED***
        Checks the continuity of interpolator (and its derivatives***REMOVED*** near
        location loc. Can check the value at loc itself if *values* is
        provided.

        *interpolator* TriInterpolator
        *loc* location to test (x0, y0***REMOVED***
        *values* (optional***REMOVED*** array [z0, dzx0, dzy0***REMOVED*** to check the value at *loc*
        ***REMOVED***
        n_star = 24       # Number of continuity points in a boundary of loc
        epsilon = 1.e-10  # Distance for loc boundary
        k = 100.          # Continuity coefficient
        (loc_x, loc_y***REMOVED*** = loc
        star_x = loc_x + epsilon*np.cos(np.linspace(0., 2*np.pi, n_star***REMOVED******REMOVED***
        star_y = loc_y + epsilon*np.sin(np.linspace(0., 2*np.pi, n_star***REMOVED******REMOVED***
        z = interpolator([loc_x***REMOVED***, [loc_y***REMOVED******REMOVED***[0***REMOVED***
        (dzx, dzy***REMOVED*** = interpolator.gradient([loc_x***REMOVED***, [loc_y***REMOVED******REMOVED***
        if values is not None:
            assert_array_almost_equal(z, values[0***REMOVED******REMOVED***
            assert_array_almost_equal(dzx[0***REMOVED***, values[1***REMOVED******REMOVED***
            assert_array_almost_equal(dzy[0***REMOVED***, values[2***REMOVED******REMOVED***
        diff_z = interpolator(star_x, star_y***REMOVED*** - z
        (tab_dzx, tab_dzy***REMOVED*** = interpolator.gradient(star_x, star_y***REMOVED***
        diff_dzx = tab_dzx - dzx
        diff_dzy = tab_dzy - dzy
        assert_array_less(diff_z, epsilon*k***REMOVED***
        assert_array_less(diff_dzx, epsilon*k***REMOVED***
        assert_array_less(diff_dzy, epsilon*k***REMOVED***

    # Drawing arbitrary triangle (a, b, c***REMOVED*** inside a unit square.
    (ax, ay***REMOVED*** = (0.2, 0.3***REMOVED***
    (bx, by***REMOVED*** = (0.33367, 0.80755***REMOVED***
    (cx, cy***REMOVED*** = (0.669, 0.4335***REMOVED***
    x = np.array([ax, bx, cx, 0., 1., 1., 0.***REMOVED******REMOVED***
    y = np.array([ay, by, cy, 0., 0., 1., 1.***REMOVED******REMOVED***
    triangles = np.array([[0, 1, 2***REMOVED***, [3, 0, 4***REMOVED***, [4, 0, 2***REMOVED***, [4, 2, 5***REMOVED***,
                          [1, 5, 2***REMOVED***, [6, 5, 1***REMOVED***, [6, 1, 0***REMOVED***, [6, 0, 3***REMOVED******REMOVED******REMOVED***
    triang = mtri.Triangulation(x, y, triangles***REMOVED***

    for idof in range(9***REMOVED***:
        z = np.zeros(7, dtype=np.float64***REMOVED***
        dzx = np.zeros(7, dtype=np.float64***REMOVED***
        dzy = np.zeros(7, dtype=np.float64***REMOVED***
        values = np.zeros([3, 3***REMOVED***, dtype=np.float64***REMOVED***
        case = idof//3
        values[case, idof % 3***REMOVED*** = 1.0
        if case == 0:
            z[idof***REMOVED*** = 1.0
        elif case == 1:
            dzx[idof % 3***REMOVED*** = 1.0
        elif case == 2:
            dzy[idof % 3***REMOVED*** = 1.0
        interp = mtri.CubicTriInterpolator(triang, z, kind='user',
                                           dz=(dzx, dzy***REMOVED******REMOVED***
        # Test 1***REMOVED*** Checking values and continuity at nodes
        check_continuity(interp, (ax, ay***REMOVED***, values[:, 0***REMOVED******REMOVED***
        check_continuity(interp, (bx, by***REMOVED***, values[:, 1***REMOVED******REMOVED***
        check_continuity(interp, (cx, cy***REMOVED***, values[:, 2***REMOVED******REMOVED***
        # Test 2***REMOVED*** Checking continuity at midside nodes
        check_continuity(interp, ((ax+bx***REMOVED****0.5, (ay+by***REMOVED****0.5***REMOVED******REMOVED***
        check_continuity(interp, ((ax+cx***REMOVED****0.5, (ay+cy***REMOVED****0.5***REMOVED******REMOVED***
        check_continuity(interp, ((cx+bx***REMOVED****0.5, (cy+by***REMOVED****0.5***REMOVED******REMOVED***
        # Test 3***REMOVED*** Checking continuity at barycenter
        check_continuity(interp, ((ax+bx+cx***REMOVED***/3., (ay+by+cy***REMOVED***/3.***REMOVED******REMOVED***
        # Test 4***REMOVED*** Checking continuity at median 1/3-point
        check_continuity(interp, ((4.*ax+bx+cx***REMOVED***/6., (4.*ay+by+cy***REMOVED***/6.***REMOVED******REMOVED***
        check_continuity(interp, ((ax+4.*bx+cx***REMOVED***/6., (ay+4.*by+cy***REMOVED***/6.***REMOVED******REMOVED***
        check_continuity(interp, ((ax+bx+4.*cx***REMOVED***/6., (ay+by+4.*cy***REMOVED***/6.***REMOVED******REMOVED***


def test_triinterpcubic_cg_solver(***REMOVED***:
    # Now 3 basic tests of the Sparse CG solver, used for
    # TriCubicInterpolator with *kind* = 'min_E'
    # 1***REMOVED*** A commonly used test involves a 2d Poisson matrix.
    def poisson_sparse_matrix(n, m***REMOVED***:
        ***REMOVED***
        Sparse Poisson matrix.

        Returns the sparse matrix in coo format resulting from the
        discretisation of the 2-dimensional Poisson equation according to a
        finite difference numerical scheme on a uniform (n, m***REMOVED*** grid.
        Size of the matrix: (n*m, n*m***REMOVED***
        ***REMOVED***
        l = m*n
        rows = np.concatenate([
            np.arange(l, dtype=np.int32***REMOVED***,
            np.arange(l-1, dtype=np.int32***REMOVED***, np.arange(1, l, dtype=np.int32***REMOVED***,
            np.arange(l-n, dtype=np.int32***REMOVED***, np.arange(n, l, dtype=np.int32***REMOVED******REMOVED******REMOVED***
        cols = np.concatenate([
            np.arange(l, dtype=np.int32***REMOVED***,
            np.arange(1, l, dtype=np.int32***REMOVED***, np.arange(l-1, dtype=np.int32***REMOVED***,
            np.arange(n, l, dtype=np.int32***REMOVED***, np.arange(l-n, dtype=np.int32***REMOVED******REMOVED******REMOVED***
        vals = np.concatenate([
            4*np.ones(l, dtype=np.float64***REMOVED***,
            -np.ones(l-1, dtype=np.float64***REMOVED***, -np.ones(l-1, dtype=np.float64***REMOVED***,
            -np.ones(l-n, dtype=np.float64***REMOVED***, -np.ones(l-n, dtype=np.float64***REMOVED******REMOVED******REMOVED***
        # In fact +1 and -1 diags have some zeros
        vals[l:2*l-1***REMOVED***[m-1::m***REMOVED*** = 0.
        vals[2*l-1:3*l-2***REMOVED***[m-1::m***REMOVED*** = 0.
        return vals, rows, cols, (n*m, n*m***REMOVED***

    # Instantiating a sparse Poisson matrix of size 48 x 48:
    (n, m***REMOVED*** = (12, 4***REMOVED***
    mat = mtri.triinterpolate._Sparse_Matrix_coo(*poisson_sparse_matrix(n, m***REMOVED******REMOVED***
    mat.compress_csc(***REMOVED***
    mat_dense = mat.to_dense(***REMOVED***
    # Testing a sparse solve for all 48 basis vector
    for itest in range(n*m***REMOVED***:
        b = np.zeros(n*m, dtype=np.float64***REMOVED***
        b[itest***REMOVED*** = 1.
        x, _ = mtri.triinterpolate._cg(A=mat, b=b, x0=np.zeros(n*m***REMOVED***,
                                       tol=1.e-10***REMOVED***
        assert_array_almost_equal(np.dot(mat_dense, x***REMOVED***, b***REMOVED***

    # 2***REMOVED*** Same matrix with inserting 2 rows - cols with null diag terms
    # (but still linked with the rest of the matrix by extra-diag terms***REMOVED***
    (i_zero, j_zero***REMOVED*** = (12, 49***REMOVED***
    vals, rows, cols, _ = poisson_sparse_matrix(n, m***REMOVED***
    rows = rows + 1*(rows >= i_zero***REMOVED*** + 1*(rows >= j_zero***REMOVED***
    cols = cols + 1*(cols >= i_zero***REMOVED*** + 1*(cols >= j_zero***REMOVED***
    # adding extra-diag terms
    rows = np.concatenate([rows, [i_zero, i_zero-1, j_zero, j_zero-1***REMOVED******REMOVED******REMOVED***
    cols = np.concatenate([cols, [i_zero-1, i_zero, j_zero-1, j_zero***REMOVED******REMOVED******REMOVED***
    vals = np.concatenate([vals, [1., 1., 1., 1.***REMOVED******REMOVED******REMOVED***
    mat = mtri.triinterpolate._Sparse_Matrix_coo(vals, rows, cols,
                                                 (n*m + 2, n*m + 2***REMOVED******REMOVED***
    mat.compress_csc(***REMOVED***
    mat_dense = mat.to_dense(***REMOVED***
    # Testing a sparse solve for all 50 basis vec
    for itest in range(n*m + 2***REMOVED***:
        b = np.zeros(n*m + 2, dtype=np.float64***REMOVED***
        b[itest***REMOVED*** = 1.
        x, _ = mtri.triinterpolate._cg(A=mat, b=b, x0=np.ones(n*m + 2***REMOVED***,
                                       tol=1.e-10***REMOVED***
        assert_array_almost_equal(np.dot(mat_dense, x***REMOVED***, b***REMOVED***

    # 3***REMOVED*** Now a simple test that summation of duplicate (i.e. with same rows,
    # same cols***REMOVED*** entries occurs when compressed.
    vals = np.ones(17, dtype=np.float64***REMOVED***
    rows = np.array([0, 1, 2, 0, 0, 1, 1, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1***REMOVED***,
                    dtype=np.int32***REMOVED***
    cols = np.array([0, 1, 2, 1, 1, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2***REMOVED***,
                    dtype=np.int32***REMOVED***
    dim = (3, 3***REMOVED***
    mat = mtri.triinterpolate._Sparse_Matrix_coo(vals, rows, cols, dim***REMOVED***
    mat.compress_csc(***REMOVED***
    mat_dense = mat.to_dense(***REMOVED***
    assert_array_almost_equal(mat_dense, np.array([
        [1., 2., 0.***REMOVED***, [2., 1., 5.***REMOVED***, [0., 5., 1.***REMOVED******REMOVED***, dtype=np.float64***REMOVED******REMOVED***


def test_triinterpcubic_geom_weights(***REMOVED***:
    # Tests to check computation of weights for _DOF_estimator_geom:
    # The weight sum per triangle can be 1. (in case all angles < 90 degrees***REMOVED***
    # or (2*w_i***REMOVED*** where w_i = 1-alpha_i/np.pi is the weight of apex i ; alpha_i
    # is the apex angle > 90 degrees.
    (ax, ay***REMOVED*** = (0., 1.687***REMOVED***
    x = np.array([ax, 0.5*ax, 0., 1.***REMOVED******REMOVED***
    y = np.array([ay, -ay, 0., 0.***REMOVED******REMOVED***
    z = np.zeros(4, dtype=np.float64***REMOVED***
    triangles = [[0, 2, 3***REMOVED***, [1, 3, 2***REMOVED******REMOVED***
    sum_w = np.zeros([4, 2***REMOVED******REMOVED***  # 4 possibilities ; 2 triangles
    for theta in np.linspace(0., 2*np.pi, 14***REMOVED***:  # rotating the figure...
        x_rot = np.cos(theta***REMOVED****x + np.sin(theta***REMOVED****y
        y_rot = -np.sin(theta***REMOVED****x + np.cos(theta***REMOVED****y
        triang = mtri.Triangulation(x_rot, y_rot, triangles***REMOVED***
        cubic_geom = mtri.CubicTriInterpolator(triang, z, kind='geom'***REMOVED***
        dof_estimator = mtri.triinterpolate._DOF_estimator_geom(cubic_geom***REMOVED***
        weights = dof_estimator.compute_geom_weights(***REMOVED***
        # Testing for the 4 possibilities...
        sum_w[0, :***REMOVED*** = np.sum(weights, 1***REMOVED*** - 1
        for itri in range(3***REMOVED***:
            sum_w[itri+1, :***REMOVED*** = np.sum(weights, 1***REMOVED*** - 2*weights[:, itri***REMOVED***
        assert_array_almost_equal(np.min(np.abs(sum_w***REMOVED***, axis=0***REMOVED***,
                                  np.array([0., 0.***REMOVED***, dtype=np.float64***REMOVED******REMOVED***


def test_triinterp_colinear(***REMOVED***:
    # Tests interpolating inside a triangulation with horizontal colinear
    # points (refer also to the tests :func:`test_trifinder` ***REMOVED***.
    #
    # These are not valid triangulations, but we try to deal with the
    # simplest violations (i. e. those handled by default TriFinder***REMOVED***.
    #
    # Note that the LinearTriInterpolator and the CubicTriInterpolator with
    # kind='min_E' or 'geom' still pass a linear patch test.
    # We also test interpolation inside a  flat triangle, by forcing
    # *tri_index* in a call to :meth:`_interpolate_multikeys`.

    delta = 0.  # If +ve, triangulation is OK, if -ve triangulation invalid,
                # if zero have colinear points but should pass tests anyway.
    x0 = np.array([1.5, 0,  1,  2, 3, 1.5,   1.5***REMOVED******REMOVED***
    y0 = np.array([-1,  0,  0,  0, 0, delta, 1***REMOVED******REMOVED***

    # We test different affine transformations of the initial figure ; to
    # avoid issues related to round-off errors we only use integer
    # coefficients (otherwise the Triangulation might become invalid even with
    # delta == 0***REMOVED***.
    transformations = [[1, 0***REMOVED***, [0, 1***REMOVED***, [1, 1***REMOVED***, [1, 2***REMOVED***, [-2, -1***REMOVED***, [-2, 1***REMOVED******REMOVED***
    for transformation in transformations:
        x_rot = transformation[0***REMOVED****x0 + transformation[1***REMOVED****y0
        y_rot = -transformation[1***REMOVED****x0 + transformation[0***REMOVED****y0
        (x, y***REMOVED*** = (x_rot, y_rot***REMOVED***
        z = 1.23*x - 4.79*y
        triangles = [[0, 2, 1***REMOVED***, [0, 3, 2***REMOVED***, [0, 4, 3***REMOVED***, [1, 2, 5***REMOVED***, [2, 3, 5***REMOVED***,
                     [3, 4, 5***REMOVED***, [1, 5, 6***REMOVED***, [4, 6, 5***REMOVED******REMOVED***
        triang = mtri.Triangulation(x, y, triangles***REMOVED***
        xs = np.linspace(np.min(triang.x***REMOVED***, np.max(triang.x***REMOVED***, 20***REMOVED***
        ys = np.linspace(np.min(triang.y***REMOVED***, np.max(triang.y***REMOVED***, 20***REMOVED***
        xs, ys = np.meshgrid(xs, ys***REMOVED***
        xs = xs.ravel(***REMOVED***
        ys = ys.ravel(***REMOVED***
        mask_out = (triang.get_trifinder(***REMOVED***(xs, ys***REMOVED*** == -1***REMOVED***
        zs_target = np.ma.array(1.23*xs - 4.79*ys, mask=mask_out***REMOVED***

        linear_interp = mtri.LinearTriInterpolator(triang, z***REMOVED***
        cubic_min_E = mtri.CubicTriInterpolator(triang, z***REMOVED***
        cubic_geom = mtri.CubicTriInterpolator(triang, z, kind='geom'***REMOVED***

        for interp in (linear_interp, cubic_min_E, cubic_geom***REMOVED***:
            zs = interp(xs, ys***REMOVED***
            assert_array_almost_equal(zs_target, zs***REMOVED***

        # Testing interpolation inside the flat triangle number 4: [2, 3, 5***REMOVED***
        # by imposing *tri_index* in a call to :meth:`_interpolate_multikeys`
        itri = 4
        pt1 = triang.triangles[itri, 0***REMOVED***
        pt2 = triang.triangles[itri, 1***REMOVED***
        xs = np.linspace(triang.x[pt1***REMOVED***, triang.x[pt2***REMOVED***, 10***REMOVED***
        ys = np.linspace(triang.y[pt1***REMOVED***, triang.y[pt2***REMOVED***, 10***REMOVED***
        zs_target = 1.23*xs - 4.79*ys
        for interp in (linear_interp, cubic_min_E, cubic_geom***REMOVED***:
            zs, = interp._interpolate_multikeys(
                xs, ys, tri_index=itri*np.ones(10, dtype=np.int32***REMOVED******REMOVED***
            assert_array_almost_equal(zs_target, zs***REMOVED***


def test_triinterp_transformations(***REMOVED***:
    # 1***REMOVED*** Testing that the interpolation scheme is invariant by rotation of the
    # whole figure.
    # Note: This test is non-trivial for a CubicTriInterpolator with
    # kind='min_E'. It does fail for a non-isotropic stiffness matrix E of
    # :class:`_ReducedHCT_Element` (tested with E=np.diag([1., 1., 1.***REMOVED******REMOVED******REMOVED***, and
    # provides a good test for :meth:`get_Kff_and_Ff`of the same class.
    #
    # 2***REMOVED*** Also testing that the interpolation scheme is invariant by expansion
    # of the whole figure along one axis.
    n_angles = 20
    n_radii = 10
    min_radius = 0.15

    def z(x, y***REMOVED***:
        r1 = np.sqrt((0.5-x***REMOVED*****2 + (0.5-y***REMOVED*****2***REMOVED***
        theta1 = np.arctan2(0.5-x, 0.5-y***REMOVED***
        r2 = np.sqrt((-x-0.2***REMOVED*****2 + (-y-0.2***REMOVED*****2***REMOVED***
        theta2 = np.arctan2(-x-0.2, -y-0.2***REMOVED***
        z = -(2*(np.exp((r1/10***REMOVED*****2***REMOVED***-1***REMOVED****30. * np.cos(7.*theta1***REMOVED*** +
              (np.exp((r2/10***REMOVED*****2***REMOVED***-1***REMOVED****30. * np.cos(11.*theta2***REMOVED*** +
              0.7*(x**2 + y**2***REMOVED******REMOVED***
        return (np.max(z***REMOVED***-z***REMOVED***/(np.max(z***REMOVED***-np.min(z***REMOVED******REMOVED***

    # First create the x and y coordinates of the points.
    radii = np.linspace(min_radius, 0.95, n_radii***REMOVED***
    angles = np.linspace(0 + n_angles, 2*np.pi + n_angles,
                         n_angles, endpoint=False***REMOVED***
    angles = np.repeat(angles[..., np.newaxis***REMOVED***, n_radii, axis=1***REMOVED***
    angles[:, 1::2***REMOVED*** += np.pi/n_angles
    x0 = (radii*np.cos(angles***REMOVED******REMOVED***.flatten(***REMOVED***
    y0 = (radii*np.sin(angles***REMOVED******REMOVED***.flatten(***REMOVED***
    triang0 = mtri.Triangulation(x0, y0***REMOVED***  # Delaunay triangulation
    z0 = z(x0, y0***REMOVED***

    # Then create the test points
    xs0 = np.linspace(-1., 1., 23***REMOVED***
    ys0 = np.linspace(-1., 1., 23***REMOVED***
    xs0, ys0 = np.meshgrid(xs0, ys0***REMOVED***
    xs0 = xs0.ravel(***REMOVED***
    ys0 = ys0.ravel(***REMOVED***

    interp_z0 = {***REMOVED***
    for i_angle in range(2***REMOVED***:
        # Rotating everything
        theta = 2*np.pi / n_angles * i_angle
        x = np.cos(theta***REMOVED****x0 + np.sin(theta***REMOVED****y0
        y = -np.sin(theta***REMOVED****x0 + np.cos(theta***REMOVED****y0
        xs = np.cos(theta***REMOVED****xs0 + np.sin(theta***REMOVED****ys0
        ys = -np.sin(theta***REMOVED****xs0 + np.cos(theta***REMOVED****ys0
        triang = mtri.Triangulation(x, y, triang0.triangles***REMOVED***
        linear_interp = mtri.LinearTriInterpolator(triang, z0***REMOVED***
        cubic_min_E = mtri.CubicTriInterpolator(triang, z0***REMOVED***
        cubic_geom = mtri.CubicTriInterpolator(triang, z0, kind='geom'***REMOVED***
        dic_interp = {'lin': linear_interp,
                      'min_E': cubic_min_E,
                      'geom': cubic_geom***REMOVED***
        # Testing that the interpolation is invariant by rotation...
        for interp_key in ['lin', 'min_E', 'geom'***REMOVED***:
            interp = dic_interp[interp_key***REMOVED***
            if i_angle == 0:
                interp_z0[interp_key***REMOVED*** = interp(xs0, ys0***REMOVED***  # storage
            else:
                interpz = interp(xs, ys***REMOVED***
                matest.assert_array_almost_equal(interpz,
                                                 interp_z0[interp_key***REMOVED******REMOVED***

    scale_factor = 987654.3210
    for scaled_axis in ('x', 'y'***REMOVED***:
        # Scaling everything (expansion along scaled_axis***REMOVED***
        if scaled_axis == 'x':
            x = scale_factor * x0
            y = y0
            xs = scale_factor * xs0
            ys = ys0
        else:
            x = x0
            y = scale_factor * y0
            xs = xs0
            ys = scale_factor * ys0
        triang = mtri.Triangulation(x, y, triang0.triangles***REMOVED***
        linear_interp = mtri.LinearTriInterpolator(triang, z0***REMOVED***
        cubic_min_E = mtri.CubicTriInterpolator(triang, z0***REMOVED***
        cubic_geom = mtri.CubicTriInterpolator(triang, z0, kind='geom'***REMOVED***
        dic_interp = {'lin': linear_interp,
                      'min_E': cubic_min_E,
                      'geom': cubic_geom***REMOVED***
        # Testing that the interpolation is invariant by expansion along
        # 1 axis...
        for interp_key in ['lin', 'min_E', 'geom'***REMOVED***:
            interpz = dic_interp[interp_key***REMOVED***(xs, ys***REMOVED***
            matest.assert_array_almost_equal(interpz, interp_z0[interp_key***REMOVED******REMOVED***


@image_comparison(baseline_images=['tri_smooth_contouring'***REMOVED***,
                  extensions=['png'***REMOVED***, remove_text=True***REMOVED***
def test_tri_smooth_contouring(***REMOVED***:
    # Image comparison based on example tricontour_smooth_user.
    n_angles = 20
    n_radii = 10
    min_radius = 0.15

    def z(x, y***REMOVED***:
        r1 = np.sqrt((0.5-x***REMOVED*****2 + (0.5-y***REMOVED*****2***REMOVED***
        theta1 = np.arctan2(0.5-x, 0.5-y***REMOVED***
        r2 = np.sqrt((-x-0.2***REMOVED*****2 + (-y-0.2***REMOVED*****2***REMOVED***
        theta2 = np.arctan2(-x-0.2, -y-0.2***REMOVED***
        z = -(2*(np.exp((r1/10***REMOVED*****2***REMOVED***-1***REMOVED****30. * np.cos(7.*theta1***REMOVED*** +
              (np.exp((r2/10***REMOVED*****2***REMOVED***-1***REMOVED****30. * np.cos(11.*theta2***REMOVED*** +
              0.7*(x**2 + y**2***REMOVED******REMOVED***
        return (np.max(z***REMOVED***-z***REMOVED***/(np.max(z***REMOVED***-np.min(z***REMOVED******REMOVED***

    # First create the x and y coordinates of the points.
    radii = np.linspace(min_radius, 0.95, n_radii***REMOVED***
    angles = np.linspace(0 + n_angles, 2*np.pi + n_angles,
                         n_angles, endpoint=False***REMOVED***
    angles = np.repeat(angles[..., np.newaxis***REMOVED***, n_radii, axis=1***REMOVED***
    angles[:, 1::2***REMOVED*** += np.pi/n_angles
    x0 = (radii*np.cos(angles***REMOVED******REMOVED***.flatten(***REMOVED***
    y0 = (radii*np.sin(angles***REMOVED******REMOVED***.flatten(***REMOVED***
    triang0 = mtri.Triangulation(x0, y0***REMOVED***  # Delaunay triangulation
    z0 = z(x0, y0***REMOVED***
    xmid = x0[triang0.triangles***REMOVED***.mean(axis=1***REMOVED***
    ymid = y0[triang0.triangles***REMOVED***.mean(axis=1***REMOVED***
    mask = np.where(xmid*xmid + ymid*ymid < min_radius*min_radius, 1, 0***REMOVED***
    triang0.set_mask(mask***REMOVED***

    # Then the plot
    refiner = mtri.UniformTriRefiner(triang0***REMOVED***
    tri_refi, z_test_refi = refiner.refine_field(z0, subdiv=4***REMOVED***
    levels = np.arange(0., 1., 0.025***REMOVED***
    plt.triplot(triang0, lw=0.5, color='0.5'***REMOVED***
    plt.tricontour(tri_refi, z_test_refi, levels=levels, colors="black"***REMOVED***


@image_comparison(baseline_images=['tri_smooth_gradient'***REMOVED***,
                  extensions=['png'***REMOVED***, remove_text=True***REMOVED***
def test_tri_smooth_gradient(***REMOVED***:
    # Image comparison based on example trigradient_demo.

    def dipole_potential(x, y***REMOVED***:
        ***REMOVED*** An electric dipole potential V ***REMOVED***
        r_sq = x**2 + y**2
        theta = np.arctan2(y, x***REMOVED***
        z = np.cos(theta***REMOVED***/r_sq
        return (np.max(z***REMOVED***-z***REMOVED*** / (np.max(z***REMOVED***-np.min(z***REMOVED******REMOVED***

    # Creating a Triangulation
    n_angles = 30
    n_radii = 10
    min_radius = 0.2
    radii = np.linspace(min_radius, 0.95, n_radii***REMOVED***
    angles = np.linspace(0, 2*np.pi, n_angles, endpoint=False***REMOVED***
    angles = np.repeat(angles[..., np.newaxis***REMOVED***, n_radii, axis=1***REMOVED***
    angles[:, 1::2***REMOVED*** += np.pi/n_angles
    x = (radii*np.cos(angles***REMOVED******REMOVED***.flatten(***REMOVED***
    y = (radii*np.sin(angles***REMOVED******REMOVED***.flatten(***REMOVED***
    V = dipole_potential(x, y***REMOVED***
    triang = mtri.Triangulation(x, y***REMOVED***
    xmid = x[triang.triangles***REMOVED***.mean(axis=1***REMOVED***
    ymid = y[triang.triangles***REMOVED***.mean(axis=1***REMOVED***
    mask = np.where(xmid*xmid + ymid*ymid < min_radius*min_radius, 1, 0***REMOVED***
    triang.set_mask(mask***REMOVED***

    # Refine data - interpolates the electrical potential V
    refiner = mtri.UniformTriRefiner(triang***REMOVED***
    tri_refi, z_test_refi = refiner.refine_field(V, subdiv=3***REMOVED***

    # Computes the electrical field (Ex, Ey***REMOVED*** as gradient of -V
    tci = mtri.CubicTriInterpolator(triang, -V***REMOVED***
    (Ex, Ey***REMOVED*** = tci.gradient(triang.x, triang.y***REMOVED***
    E_norm = np.sqrt(Ex**2 + Ey**2***REMOVED***

    # Plot the triangulation, the potential iso-contours and the vector field
    plt.figure(***REMOVED***
    plt.gca(***REMOVED***.set_aspect('equal'***REMOVED***
    plt.triplot(triang, color='0.8'***REMOVED***

    levels = np.arange(0., 1., 0.01***REMOVED***
    cmap = cm.get_cmap(name='hot', lut=None***REMOVED***
    plt.tricontour(tri_refi, z_test_refi, levels=levels, cmap=cmap,
                   linewidths=[2.0, 1.0, 1.0, 1.0***REMOVED******REMOVED***
    # Plots direction of the electrical vector field
    plt.quiver(triang.x, triang.y, Ex/E_norm, Ey/E_norm,
               units='xy', scale=10., zorder=3, color='blue',
               width=0.007, headwidth=3., headlength=4.***REMOVED***


def test_tritools(***REMOVED***:
    # Tests TriAnalyzer.scale_factors on masked triangulation
    # Tests circle_ratios on equilateral and right-angled triangle.
    x = np.array([0., 1., 0.5, 0., 2.***REMOVED******REMOVED***
    y = np.array([0., 0., 0.5*np.sqrt(3.***REMOVED***, -1., 1.***REMOVED******REMOVED***
    triangles = np.array([[0, 1, 2***REMOVED***, [0, 1, 3***REMOVED***, [1, 2, 4***REMOVED******REMOVED***, dtype=np.int32***REMOVED***
    mask = np.array([False, False, True***REMOVED***, dtype=np.bool***REMOVED***
    triang = mtri.Triangulation(x, y, triangles, mask=mask***REMOVED***
    analyser = mtri.TriAnalyzer(triang***REMOVED***
    assert_array_almost_equal(analyser.scale_factors,
                              np.array([1., 1./(1.+0.5*np.sqrt(3.***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***
    assert_array_almost_equal(
        analyser.circle_ratios(rescale=False***REMOVED***,
        np.ma.masked_array([0.5, 1./(1.+np.sqrt(2.***REMOVED******REMOVED***, np.nan***REMOVED***, mask***REMOVED******REMOVED***

    # Tests circle ratio of a flat triangle
    x = np.array([0., 1., 2.***REMOVED******REMOVED***
    y = np.array([1., 1.+3., 1.+6.***REMOVED******REMOVED***
    triangles = np.array([[0, 1, 2***REMOVED******REMOVED***, dtype=np.int32***REMOVED***
    triang = mtri.Triangulation(x, y, triangles***REMOVED***
    analyser = mtri.TriAnalyzer(triang***REMOVED***
    assert_array_almost_equal(analyser.circle_ratios(***REMOVED***, np.array([0.***REMOVED******REMOVED******REMOVED***

    # Tests TriAnalyzer.get_flat_tri_mask
    # Creates a triangulation of [-1, 1***REMOVED*** x [-1, 1***REMOVED*** with contiguous groups of
    # 'flat' triangles at the 4 corners and at the center. Checks that only
    # those at the borders are eliminated by TriAnalyzer.get_flat_tri_mask
    n = 9

    def power(x, a***REMOVED***:
        return np.abs(x***REMOVED*****a*np.sign(x***REMOVED***

    x = np.linspace(-1., 1., n+1***REMOVED***
    x, y = np.meshgrid(power(x, 2.***REMOVED***, power(x, 0.25***REMOVED******REMOVED***
    x = x.ravel(***REMOVED***
    y = y.ravel(***REMOVED***

    triang = mtri.Triangulation(x, y, triangles=meshgrid_triangles(n+1***REMOVED******REMOVED***
    analyser = mtri.TriAnalyzer(triang***REMOVED***
    mask_flat = analyser.get_flat_tri_mask(0.2***REMOVED***
    verif_mask = np.zeros(162, dtype=np.bool***REMOVED***
    corners_index = [0, 1, 2, 3, 14, 15, 16, 17, 18, 19, 34, 35, 126, 127,
                     142, 143, 144, 145, 146, 147, 158, 159, 160, 161***REMOVED***
    verif_mask[corners_index***REMOVED*** = True
    assert_array_equal(mask_flat, verif_mask***REMOVED***

    # Now including a hole (masked triangle***REMOVED*** at the center. The center also
    # shall be eliminated by get_flat_tri_mask.
    mask = np.zeros(162, dtype=np.bool***REMOVED***
    mask[80***REMOVED*** = True
    triang.set_mask(mask***REMOVED***
    mask_flat = analyser.get_flat_tri_mask(0.2***REMOVED***
    center_index = [44, 45, 62, 63, 78, 79, 80, 81, 82, 83, 98, 99, 116, 117***REMOVED***
    verif_mask[center_index***REMOVED*** = True
    assert_array_equal(mask_flat, verif_mask***REMOVED***


def test_trirefine(***REMOVED***:
    # Testing subdiv=2 refinement
    n = 3
    subdiv = 2
    x = np.linspace(-1., 1., n+1***REMOVED***
    x, y = np.meshgrid(x, x***REMOVED***
    x = x.ravel(***REMOVED***
    y = y.ravel(***REMOVED***
    mask = np.zeros(2*n**2, dtype=np.bool***REMOVED***
    mask[n**2:***REMOVED*** = True
    triang = mtri.Triangulation(x, y, triangles=meshgrid_triangles(n+1***REMOVED***,
                                mask=mask***REMOVED***
    refiner = mtri.UniformTriRefiner(triang***REMOVED***
    refi_triang = refiner.refine_triangulation(subdiv=subdiv***REMOVED***
    x_refi = refi_triang.x
    y_refi = refi_triang.y

    n_refi = n * subdiv**2
    x_verif = np.linspace(-1., 1., n_refi+1***REMOVED***
    x_verif, y_verif = np.meshgrid(x_verif, x_verif***REMOVED***
    x_verif = x_verif.ravel(***REMOVED***
    y_verif = y_verif.ravel(***REMOVED***
    ind1d = np.in1d(np.around(x_verif*(2.5+y_verif***REMOVED***, 8***REMOVED***,
                    np.around(x_refi*(2.5+y_refi***REMOVED***, 8***REMOVED******REMOVED***
    assert_array_equal(ind1d, True***REMOVED***

    # Testing the mask of the refined triangulation
    refi_mask = refi_triang.mask
    refi_tri_barycenter_x = np.sum(refi_triang.x[refi_triang.triangles***REMOVED***,
                                   axis=1***REMOVED*** / 3.
    refi_tri_barycenter_y = np.sum(refi_triang.y[refi_triang.triangles***REMOVED***,
                                   axis=1***REMOVED*** / 3.
    tri_finder = triang.get_trifinder(***REMOVED***
    refi_tri_indices = tri_finder(refi_tri_barycenter_x,
                                  refi_tri_barycenter_y***REMOVED***
    refi_tri_mask = triang.mask[refi_tri_indices***REMOVED***
    assert_array_equal(refi_mask, refi_tri_mask***REMOVED***

    # Testing that the numbering of triangles does not change the
    # interpolation result.
    x = np.asarray([0.0, 1.0, 0.0, 1.0***REMOVED******REMOVED***
    y = np.asarray([0.0, 0.0, 1.0, 1.0***REMOVED******REMOVED***
    triang = [mtri.Triangulation(x, y, [[0, 1, 3***REMOVED***, [3, 2, 0***REMOVED******REMOVED******REMOVED***,
              mtri.Triangulation(x, y, [[0, 1, 3***REMOVED***, [2, 0, 3***REMOVED******REMOVED******REMOVED******REMOVED***
    z = np.sqrt((x-0.3***REMOVED****(x-0.3***REMOVED*** + (y-0.4***REMOVED****(y-0.4***REMOVED******REMOVED***
    # Refining the 2 triangulations and reordering the points
    xyz_data = [***REMOVED***
    for i in range(2***REMOVED***:
        refiner = mtri.UniformTriRefiner(triang[i***REMOVED******REMOVED***
        refined_triang, refined_z = refiner.refine_field(z, subdiv=1***REMOVED***
        xyz = np.dstack((refined_triang.x, refined_triang.y, refined_z***REMOVED******REMOVED***[0***REMOVED***
        xyz = xyz[np.lexsort((xyz[:, 1***REMOVED***, xyz[:, 0***REMOVED******REMOVED******REMOVED******REMOVED***
        xyz_data += [xyz***REMOVED***
    assert_array_almost_equal(xyz_data[0***REMOVED***, xyz_data[1***REMOVED******REMOVED***


def meshgrid_triangles(n***REMOVED***:
    ***REMOVED***
    Utility function.
    Returns triangles to mesh a np.meshgrid of n x n points
    ***REMOVED***
    tri = [***REMOVED***
    for i in range(n-1***REMOVED***:
        for j in range(n-1***REMOVED***:
            a = i + j*(n***REMOVED***
            b = (i+1***REMOVED*** + j*n
            c = i + (j+1***REMOVED****n
            d = (i+1***REMOVED*** + (j+1***REMOVED****n
            tri += [[a, b, d***REMOVED***, [a, d, c***REMOVED******REMOVED***
    return np.array(tri, dtype=np.int32***REMOVED***


def test_triplot_return(***REMOVED***:
    # Check that triplot returns the artists it adds
    from matplotlib.figure import Figure
    ax = Figure(***REMOVED***.add_axes([0.1, 0.1, 0.7, 0.7***REMOVED******REMOVED***
    triang = mtri.Triangulation(
        [0.0, 1.0, 0.0, 1.0***REMOVED***, [0.0, 0.0, 1.0, 1.0***REMOVED***,
        triangles=[[0, 1, 3***REMOVED***, [3, 2, 0***REMOVED******REMOVED******REMOVED***
    if ax.triplot(triang, "b-"***REMOVED*** is None:
        raise AssertionError("triplot should return the artist it adds"***REMOVED***


def test_trirefiner_fortran_contiguous_triangles(***REMOVED***:
    # github issue 4180.  Test requires two arrays of triangles that are
    # identical except that one is C-contiguous and one is fortran-contiguous.
    triangles1 = np.array([[2, 0, 3***REMOVED***, [2, 1, 0***REMOVED******REMOVED******REMOVED***
    assert_false(np.isfortran(triangles1***REMOVED******REMOVED***

    triangles2 = np.array(triangles1, copy=True, order='F'***REMOVED***
    assert_true(np.isfortran(triangles2***REMOVED******REMOVED***

    x = np.array([0.39, 0.59, 0.43, 0.32***REMOVED******REMOVED***
    y = np.array([33.99, 34.01, 34.19, 34.18***REMOVED******REMOVED***
    triang1 = mtri.Triangulation(x, y, triangles1***REMOVED***
    triang2 = mtri.Triangulation(x, y, triangles2***REMOVED***

    refiner1 = mtri.UniformTriRefiner(triang1***REMOVED***
    refiner2 = mtri.UniformTriRefiner(triang2***REMOVED***

    fine_triang1 = refiner1.refine_triangulation(subdiv=1***REMOVED***
    fine_triang2 = refiner2.refine_triangulation(subdiv=1***REMOVED***

    assert_array_equal(fine_triang1.triangles, fine_triang2.triangles***REMOVED***


def test_qhull_triangle_orientation(***REMOVED***:
    # github issue 4437.
    xi = np.linspace(-2, 2, 100***REMOVED***
    x, y = map(np.ravel, np.meshgrid(xi, xi***REMOVED******REMOVED***
    w = np.logical_and(x > y - 1, np.logical_and(x < -1.95, y > -1.2***REMOVED******REMOVED***
    x, y = x[w***REMOVED***, y[w***REMOVED***
    theta = np.radians(25***REMOVED***
    x1 = x*np.cos(theta***REMOVED*** - y*np.sin(theta***REMOVED***
    y1 = x*np.sin(theta***REMOVED*** + y*np.cos(theta***REMOVED***

    # Calculate Delaunay triangulation using Qhull.
    triang = mtri.Triangulation(x1, y1***REMOVED***

    # Neighbors returned by Qhull.
    qhull_neighbors = triang.neighbors

    # Obtain neighbors using own C++ calculation.
    triang._neighbors = None
    own_neighbors = triang.neighbors

    assert_array_equal(qhull_neighbors, own_neighbors***REMOVED***


def test_trianalyzer_mismatched_indices(***REMOVED***:
    # github issue 4999.
    x = np.array([0., 1., 0.5, 0., 2.***REMOVED******REMOVED***
    y = np.array([0., 0., 0.5*np.sqrt(3.***REMOVED***, -1., 1.***REMOVED******REMOVED***
    triangles = np.array([[0, 1, 2***REMOVED***, [0, 1, 3***REMOVED***, [1, 2, 4***REMOVED******REMOVED***, dtype=np.int32***REMOVED***
    mask = np.array([False, False, True***REMOVED***, dtype=np.bool***REMOVED***
    triang = mtri.Triangulation(x, y, triangles, mask=mask***REMOVED***
    analyser = mtri.TriAnalyzer(triang***REMOVED***
    # numpy >= 1.10 raises a VisibleDeprecationWarning in the following line
    # prior to the fix.
    triang2 = analyser._get_compressed_triangulation(***REMOVED***


@cleanup
def test_tricontourf_decreasing_levels(***REMOVED***:
    # github issue 5477.
    x = [0.0, 1.0, 1.0***REMOVED***
    y = [0.0, 0.0, 1.0***REMOVED***
    z = [0.2, 0.4, 0.6***REMOVED***
    plt.figure(***REMOVED***
    assert_raises(ValueError, plt.tricontourf, x, y, z, [1.0, 0.0***REMOVED******REMOVED***


if __name__ == '__main__':
    import nose
    nose.runmodule(argv=['-s', '--with-doctest'***REMOVED***, exit=False***REMOVED***
