***REMOVED***
Place a table below the x-axis at location loc.

The table consists of a grid of cells.

The grid need not be rectangular and can have holes.

Cells are added by specifying their row and column.

For the purposes of positioning the cell at (0, 0***REMOVED*** is
assumed to be at the top left and the cell at (max_row, max_col***REMOVED***
is assumed to be at bottom right.

You can add additional cells outside this range to have convenient
ways of positioning more interesting grids.

Author    : John Gill <jng@europe.renre.com>
Copyright : 2004 John Gill and John Hunter
License   : matplotlib license

***REMOVED***
from __future__ import (absolute_import, division, print_function,
                        unicode_literals***REMOVED***

from matplotlib.externals import six
from matplotlib.externals.six.moves import xrange

import warnings

from . import artist
from .artist import Artist, allow_rasterization
from .patches import Rectangle
from .cbook import is_string_like
from matplotlib import docstring
from .text import Text
from .transforms import Bbox
from matplotlib.path import Path


class Cell(Rectangle***REMOVED***:
    ***REMOVED***
    A cell is a Rectangle with some associated text.

    ***REMOVED***
    PAD = 0.1  # padding between text and rectangle

    def __init__(self, xy, width, height,
                 edgecolor='k', facecolor='w',
                 fill=True,
                 text='',
                 loc=None,
                 fontproperties=None
                 ***REMOVED***:

        # Call base
        Rectangle.__init__(self, xy, width=width, height=height,
                           edgecolor=edgecolor, facecolor=facecolor***REMOVED***
        self.set_clip_on(False***REMOVED***

        # Create text object
        if loc is None:
            loc = 'right'
        self._loc = loc
        self._text = Text(x=xy[0***REMOVED***, y=xy[1***REMOVED***, text=text,
                          fontproperties=fontproperties***REMOVED***
        self._text.set_clip_on(False***REMOVED***

    def set_transform(self, trans***REMOVED***:
        Rectangle.set_transform(self, trans***REMOVED***
        # the text does not get the transform!
        self.stale = True

    def set_figure(self, fig***REMOVED***:
        Rectangle.set_figure(self, fig***REMOVED***
        self._text.set_figure(fig***REMOVED***

    def get_text(self***REMOVED***:
        'Return the cell Text intance'
        return self._text

    def set_fontsize(self, size***REMOVED***:
        self._text.set_fontsize(size***REMOVED***
        self.stale = True

    def get_fontsize(self***REMOVED***:
        'Return the cell fontsize'
        return self._text.get_fontsize(***REMOVED***

    def auto_set_font_size(self, renderer***REMOVED***:
        ***REMOVED*** Shrink font size until text fits. ***REMOVED***
        fontsize = self.get_fontsize(***REMOVED***
        required = self.get_required_width(renderer***REMOVED***
        while fontsize > 1 and required > self.get_width(***REMOVED***:
            fontsize -= 1
            self.set_fontsize(fontsize***REMOVED***
            required = self.get_required_width(renderer***REMOVED***

        return fontsize

    @allow_rasterization
    def draw(self, renderer***REMOVED***:
        if not self.get_visible(***REMOVED***:
            return
        # draw the rectangle
        Rectangle.draw(self, renderer***REMOVED***

        # position the text
        self._set_text_position(renderer***REMOVED***
        self._text.draw(renderer***REMOVED***
        self.stale = False

    def _set_text_position(self, renderer***REMOVED***:
        ***REMOVED*** Set text up so it draws in the right place.

        Currently support 'left', 'center' and 'right'
        ***REMOVED***
        bbox = self.get_window_extent(renderer***REMOVED***
        l, b, w, h = bbox.bounds

        # draw in center vertically
        self._text.set_verticalalignment('center'***REMOVED***
        y = b + (h / 2.0***REMOVED***

        # now position horizontally
        if self._loc == 'center':
            self._text.set_horizontalalignment('center'***REMOVED***
            x = l + (w / 2.0***REMOVED***
        elif self._loc == 'left':
            self._text.set_horizontalalignment('left'***REMOVED***
            x = l + (w * self.PAD***REMOVED***
        else:
            self._text.set_horizontalalignment('right'***REMOVED***
            x = l + (w * (1.0 - self.PAD***REMOVED******REMOVED***

        self._text.set_position((x, y***REMOVED******REMOVED***

    def get_text_bounds(self, renderer***REMOVED***:
        ***REMOVED*** Get text bounds in axes co-ordinates. ***REMOVED***
        bbox = self._text.get_window_extent(renderer***REMOVED***
        bboxa = bbox.inverse_transformed(self.get_data_transform(***REMOVED******REMOVED***
        return bboxa.bounds

    def get_required_width(self, renderer***REMOVED***:
        ***REMOVED*** Get width required for this cell. ***REMOVED***
        l, b, w, h = self.get_text_bounds(renderer***REMOVED***
        return w * (1.0 + (2.0 * self.PAD***REMOVED******REMOVED***

    def set_text_props(self, **kwargs***REMOVED***:
        'update the text properties with kwargs'
        self._text.update(kwargs***REMOVED***
        self.stale = True


class CustomCell(Cell***REMOVED***:
    ***REMOVED***
    A subclass of Cell where the sides may be visibly toggled.

    ***REMOVED***

    _edges = 'BRTL'
    _edge_aliases = {'open':         '',
                     'closed':       _edges,  # default
                     'horizontal':   'BT',
                     'vertical':     'RL'
                 ***REMOVED***

    def __init__(self, *args, **kwargs***REMOVED***:
        visible_edges = kwargs.pop('visible_edges'***REMOVED***
        Cell.__init__(self, *args, **kwargs***REMOVED***
        self.visible_edges = visible_edges

    @property
    def visible_edges(self***REMOVED***:
        return self._visible_edges

    @visible_edges.setter
    def visible_edges(self, value***REMOVED***:
        if value is None:
            self._visible_edges = self._edges
        elif value in self._edge_aliases:
            self._visible_edges = self._edge_aliases[value***REMOVED***
        else:
            for edge in value:
                if edge not in self._edges:
                    msg = ('Invalid edge param {0***REMOVED***, must only be one of'
                           ' {1***REMOVED*** or string of {2***REMOVED***.'***REMOVED***.format(
                                   value,
                                   ", ".join(self._edge_aliases.keys(***REMOVED******REMOVED***,
                                   ", ".join(self._edges***REMOVED***,
                                   ***REMOVED***
                    raise ValueError(msg***REMOVED***
            self._visible_edges = value
        self.stale = True

    def get_path(self***REMOVED***:
        'Return a path where the edges specificed by _visible_edges are drawn'

        codes = [Path.MOVETO***REMOVED***

        for edge in self._edges:
            if edge in self._visible_edges:
                codes.append(Path.LINETO***REMOVED***
            else:
                codes.append(Path.MOVETO***REMOVED***

        if Path.MOVETO not in codes[1:***REMOVED***:  # All sides are visible
            codes[-1***REMOVED*** = Path.CLOSEPOLY

        return Path(
            [[0.0, 0.0***REMOVED***, [1.0, 0.0***REMOVED***, [1.0, 1.0***REMOVED***, [0.0, 1.0***REMOVED***, [0.0, 0.0***REMOVED******REMOVED***,
            codes,
            readonly=True
            ***REMOVED***


class Table(Artist***REMOVED***:
    ***REMOVED***
    Create a table of cells.

    Table can have (optional***REMOVED*** row and column headers.

    Each entry in the table can be either text or patches.

    Column widths and row heights for the table can be specified.

    Return value is a sequence of text, line and patch instances that make
    up the table
    ***REMOVED***
    codes = {'best': 0,
             'upper right':  1,  # default
             'upper left':   2,
             'lower left':   3,
             'lower right':  4,
             'center left':  5,
             'center right': 6,
             'lower center': 7,
             'upper center': 8,
             'center':       9,
             'top right':    10,
             'top left':     11,
             'bottom left':  12,
             'bottom right': 13,
             'right':        14,
             'left':         15,
             'top':          16,
             'bottom':       17,
         ***REMOVED***

    FONTSIZE = 10
    AXESPAD = 0.02    # the border between the axes and table edge

    def __init__(self, ax, loc=None, bbox=None, **kwargs***REMOVED***:

        Artist.__init__(self***REMOVED***

        if is_string_like(loc***REMOVED*** and loc not in self.codes:
            warnings.warn('Unrecognized location %s. Falling back on '
                          'bottom; valid locations are\n%s\t' %
                          (loc, '\n\t'.join(six.iterkeys(self.codes***REMOVED******REMOVED******REMOVED******REMOVED***
            loc = 'bottom'
        if is_string_like(loc***REMOVED***:
            loc = self.codes.get(loc, 1***REMOVED***
        self.set_figure(ax.figure***REMOVED***
        self._axes = ax
        self._loc = loc
        self._bbox = bbox

        # use axes coords
        self.set_transform(ax.transAxes***REMOVED***

        self._texts = [***REMOVED***
        self._cells = {***REMOVED***
        self._edges = None
        self._autoRows = [***REMOVED***
        self._autoColumns = [***REMOVED***
        self._autoFontsize = True
        self.update(kwargs***REMOVED***

        self.set_clip_on(False***REMOVED***

        self._cachedRenderer = None

    def add_cell(self, row, col, *args, **kwargs***REMOVED***:
        ***REMOVED*** Add a cell to the table. ***REMOVED***
        xy = (0, 0***REMOVED***

        cell = CustomCell(xy, visible_edges=self.edges, *args, **kwargs***REMOVED***
        cell.set_figure(self.figure***REMOVED***
        cell.set_transform(self.get_transform(***REMOVED******REMOVED***

        cell.set_clip_on(False***REMOVED***
        self._cells[(row, col***REMOVED******REMOVED*** = cell
        self.stale = True

    @property
    def edges(self***REMOVED***:
        return self._edges

    @edges.setter
    def edges(self, value***REMOVED***:
        self._edges = value
        self.stale = True

    def _approx_text_height(self***REMOVED***:
        return (self.FONTSIZE / 72.0 * self.figure.dpi /
                self._axes.bbox.height * 1.2***REMOVED***

    @allow_rasterization
    def draw(self, renderer***REMOVED***:
        # Need a renderer to do hit tests on mouseevent; assume the last one
        # will do
        if renderer is None:
            renderer = self._cachedRenderer
        if renderer is None:
            raise RuntimeError('No renderer defined'***REMOVED***
        self._cachedRenderer = renderer

        if not self.get_visible(***REMOVED***:
            return
        renderer.open_group('table'***REMOVED***
        self._update_positions(renderer***REMOVED***

        keys = list(six.iterkeys(self._cells***REMOVED******REMOVED***
        keys.sort(***REMOVED***
        for key in keys:
            self._cells[key***REMOVED***.draw(renderer***REMOVED***
        # for c in self._cells.itervalues(***REMOVED***:
        #     c.draw(renderer***REMOVED***
        renderer.close_group('table'***REMOVED***
        self.stale = False

    def _get_grid_bbox(self, renderer***REMOVED***:
        ***REMOVED***Get a bbox, in axes co-ordinates for the cells.

        Only include those in the range (0,0***REMOVED*** to (maxRow, maxCol***REMOVED******REMOVED***
        boxes = [self._cells[pos***REMOVED***.get_window_extent(renderer***REMOVED***
                 for pos in six.iterkeys(self._cells***REMOVED***
                 if pos[0***REMOVED*** >= 0 and pos[1***REMOVED*** >= 0***REMOVED***

        bbox = Bbox.union(boxes***REMOVED***
        return bbox.inverse_transformed(self.get_transform(***REMOVED******REMOVED***

    def contains(self, mouseevent***REMOVED***:
        ***REMOVED***Test whether the mouse event occurred in the table.

        Returns T/F, {***REMOVED***
        ***REMOVED***
        if six.callable(self._contains***REMOVED***:
            return self._contains(self, mouseevent***REMOVED***

        # TODO: Return index of the cell containing the cursor so that the user
        # doesn't have to bind to each one individually.
        if self._cachedRenderer is not None:
            boxes = [self._cells[pos***REMOVED***.get_window_extent(self._cachedRenderer***REMOVED***
                     for pos in six.iterkeys(self._cells***REMOVED***
                     if pos[0***REMOVED*** >= 0 and pos[1***REMOVED*** >= 0***REMOVED***
            bbox = Bbox.union(boxes***REMOVED***
            return bbox.contains(mouseevent.x, mouseevent.y***REMOVED***, {***REMOVED***
        else:
            return False, {***REMOVED***

    def get_children(self***REMOVED***:
        'Return the Artists contained by the table'
        return list(six.itervalues(self._cells***REMOVED******REMOVED***
    get_child_artists = get_children  # backward compatibility

    def get_window_extent(self, renderer***REMOVED***:
        'Return the bounding box of the table in window coords'
        boxes = [cell.get_window_extent(renderer***REMOVED***
                 for cell in six.itervalues(self._cells***REMOVED******REMOVED***

        return Bbox.union(boxes***REMOVED***

    def _do_cell_alignment(self***REMOVED***:
        ***REMOVED*** Calculate row heights and column widths.

        Position cells accordingly.
        ***REMOVED***
        # Calculate row/column widths
        widths = {***REMOVED***
        heights = {***REMOVED***
        for (row, col***REMOVED***, cell in six.iteritems(self._cells***REMOVED***:
            height = heights.setdefault(row, 0.0***REMOVED***
            heights[row***REMOVED*** = max(height, cell.get_height(***REMOVED******REMOVED***
            width = widths.setdefault(col, 0.0***REMOVED***
            widths[col***REMOVED*** = max(width, cell.get_width(***REMOVED******REMOVED***

        # work out left position for each column
        xpos = 0
        lefts = {***REMOVED***
        cols = list(six.iterkeys(widths***REMOVED******REMOVED***
        cols.sort(***REMOVED***
        for col in cols:
            lefts[col***REMOVED*** = xpos
            xpos += widths[col***REMOVED***

        ypos = 0
        bottoms = {***REMOVED***
        rows = list(six.iterkeys(heights***REMOVED******REMOVED***
        rows.sort(***REMOVED***
        rows.reverse(***REMOVED***
        for row in rows:
            bottoms[row***REMOVED*** = ypos
            ypos += heights[row***REMOVED***

        # set cell positions
        for (row, col***REMOVED***, cell in six.iteritems(self._cells***REMOVED***:
            cell.set_x(lefts[col***REMOVED******REMOVED***
            cell.set_y(bottoms[row***REMOVED******REMOVED***

    def auto_set_column_width(self, col***REMOVED***:

        self._autoColumns.append(col***REMOVED***
        self.stale = True

    def _auto_set_column_width(self, col, renderer***REMOVED***:
        ***REMOVED*** Automagically set width for column.
        ***REMOVED***
        cells = [key for key in self._cells if key[1***REMOVED*** == col***REMOVED***

        # find max width
        width = 0
        for cell in cells:
            c = self._cells[cell***REMOVED***
            width = max(c.get_required_width(renderer***REMOVED***, width***REMOVED***

        # Now set the widths
        for cell in cells:
            self._cells[cell***REMOVED***.set_width(width***REMOVED***

    def auto_set_font_size(self, value=True***REMOVED***:
        ***REMOVED*** Automatically set font size. ***REMOVED***
        self._autoFontsize = value
        self.stale = True

    def _auto_set_font_size(self, renderer***REMOVED***:

        if len(self._cells***REMOVED*** == 0:
            return
        fontsize = list(six.itervalues(self._cells***REMOVED******REMOVED***[0***REMOVED***.get_fontsize(***REMOVED***
        cells = [***REMOVED***
        for key, cell in six.iteritems(self._cells***REMOVED***:
            # ignore auto-sized columns
            if key[1***REMOVED*** in self._autoColumns:
                continue
            size = cell.auto_set_font_size(renderer***REMOVED***
            fontsize = min(fontsize, size***REMOVED***
            cells.append(cell***REMOVED***

        # now set all fontsizes equal
        for cell in six.itervalues(self._cells***REMOVED***:
            cell.set_fontsize(fontsize***REMOVED***

    def scale(self, xscale, yscale***REMOVED***:
        ***REMOVED*** Scale column widths by xscale and row heights by yscale. ***REMOVED***
        for c in six.itervalues(self._cells***REMOVED***:
            c.set_width(c.get_width(***REMOVED*** * xscale***REMOVED***
            c.set_height(c.get_height(***REMOVED*** * yscale***REMOVED***

    def set_fontsize(self, size***REMOVED***:
        ***REMOVED***
        Set the fontsize of the cell text

        ACCEPTS: a float in points
        ***REMOVED***

        for cell in six.itervalues(self._cells***REMOVED***:
            cell.set_fontsize(size***REMOVED***
        self.stale = True

    def _offset(self, ox, oy***REMOVED***:
        'Move all the artists by ox,oy (axes coords***REMOVED***'

        for c in six.itervalues(self._cells***REMOVED***:
            x, y = c.get_x(***REMOVED***, c.get_y(***REMOVED***
            c.set_x(x + ox***REMOVED***
            c.set_y(y + oy***REMOVED***

    def _update_positions(self, renderer***REMOVED***:
        # called from renderer to allow more precise estimates of
        # widths and heights with get_window_extent

        # Do any auto width setting
        for col in self._autoColumns:
            self._auto_set_column_width(col, renderer***REMOVED***

        if self._autoFontsize:
            self._auto_set_font_size(renderer***REMOVED***

        # Align all the cells
        self._do_cell_alignment(***REMOVED***

        bbox = self._get_grid_bbox(renderer***REMOVED***
        l, b, w, h = bbox.bounds

        if self._bbox is not None:
            # Position according to bbox
            rl, rb, rw, rh = self._bbox
            self.scale(rw / w, rh / h***REMOVED***
            ox = rl - l
            oy = rb - b
            self._do_cell_alignment(***REMOVED***
        else:
            # Position using loc
            (BEST, UR, UL, LL, LR, CL, CR, LC, UC, C,
             TR, TL, BL, BR, R, L, T, B***REMOVED*** = list(xrange(len(self.codes***REMOVED******REMOVED******REMOVED***
            # defaults for center
            ox = (0.5 - w / 2***REMOVED*** - l
            oy = (0.5 - h / 2***REMOVED*** - b
            if self._loc in (UL, LL, CL***REMOVED***:   # left
                ox = self.AXESPAD - l
            if self._loc in (BEST, UR, LR, R, CR***REMOVED***:  # right
                ox = 1 - (l + w + self.AXESPAD***REMOVED***
            if self._loc in (BEST, UR, UL, UC***REMOVED***:     # upper
                oy = 1 - (b + h + self.AXESPAD***REMOVED***
            if self._loc in (LL, LR, LC***REMOVED***:           # lower
                oy = self.AXESPAD - b
            if self._loc in (LC, UC, C***REMOVED***:            # center x
                ox = (0.5 - w / 2***REMOVED*** - l
            if self._loc in (CL, CR, C***REMOVED***:            # center y
                oy = (0.5 - h / 2***REMOVED*** - b

            if self._loc in (TL, BL, L***REMOVED***:            # out left
                ox = - (l + w***REMOVED***
            if self._loc in (TR, BR, R***REMOVED***:            # out right
                ox = 1.0 - l
            if self._loc in (TR, TL, T***REMOVED***:            # out top
                oy = 1.0 - b
            if self._loc in (BL, BR, B***REMOVED***:           # out bottom
                oy = - (b + h***REMOVED***

        self._offset(ox, oy***REMOVED***

    def get_celld(self***REMOVED***:
        'return a dict of cells in the table'
        return self._cells


def table(ax,
          cellText=None, cellColours=None,
          cellLoc='right', colWidths=None,
          rowLabels=None, rowColours=None, rowLoc='left',
          colLabels=None, colColours=None, colLoc='center',
          loc='bottom', bbox=None, edges='closed',
          **kwargs***REMOVED***:
    ***REMOVED***
    TABLE(cellText=None, cellColours=None,
          cellLoc='right', colWidths=None,
          rowLabels=None, rowColours=None, rowLoc='left',
          colLabels=None, colColours=None, colLoc='center',
          loc='bottom', bbox=None, edges='closed'***REMOVED***

    Factory function to generate a Table instance.

    Thanks to John Gill for providing the class and table.
    ***REMOVED***

    # Check we have some cellText
    if cellText is None:
        # assume just colours are needed
        rows = len(cellColours***REMOVED***
        cols = len(cellColours[0***REMOVED******REMOVED***
        cellText = [[''***REMOVED*** * rows***REMOVED*** * cols

    rows = len(cellText***REMOVED***
    cols = len(cellText[0***REMOVED******REMOVED***
    for row in cellText:
        if len(row***REMOVED*** != cols:
            msg = "Each row in 'cellText' must have {0***REMOVED*** columns"
            raise ValueError(msg.format(cols***REMOVED******REMOVED***

    if cellColours is not None:
        if len(cellColours***REMOVED*** != rows:
            raise ValueError("'cellColours' must have {0***REMOVED*** rows".format(rows***REMOVED******REMOVED***
        for row in cellColours:
            if len(row***REMOVED*** != cols:
                msg = "Each row in 'cellColours' must have {0***REMOVED*** columns"
                raise ValueError(msg.format(cols***REMOVED******REMOVED***
    else:
        cellColours = ['w' * cols***REMOVED*** * rows

    # Set colwidths if not given
    if colWidths is None:
        colWidths = [1.0 / cols***REMOVED*** * cols

    # Fill in missing information for column
    # and row labels
    rowLabelWidth = 0
    if rowLabels is None:
        if rowColours is not None:
            rowLabels = [''***REMOVED*** * rows
            rowLabelWidth = colWidths[0***REMOVED***
    elif rowColours is None:
        rowColours = 'w' * rows

    if rowLabels is not None:
        if len(rowLabels***REMOVED*** != rows:
            raise ValueError("'rowLabels' must be of length {0***REMOVED***".format(rows***REMOVED******REMOVED***

    # If we have column labels, need to shift
    # the text and colour arrays down 1 row
    offset = 1
    if colLabels is None:
        if colColours is not None:
            colLabels = [''***REMOVED*** * cols
        else:
            offset = 0
    elif colColours is None:
        colColours = 'w' * cols

    # Set up cell colours if not given
    if cellColours is None:
        cellColours = ['w' * cols***REMOVED*** * rows

    # Now create the table
    table = Table(ax, loc, bbox, **kwargs***REMOVED***
    table.edges = edges
    height = table._approx_text_height(***REMOVED***

    # Add the cells
    for row in xrange(rows***REMOVED***:
        for col in xrange(cols***REMOVED***:
            table.add_cell(row + offset, col,
                           width=colWidths[col***REMOVED***, height=height,
                           text=cellText[row***REMOVED***[col***REMOVED***,
                           facecolor=cellColours[row***REMOVED***[col***REMOVED***,
                           loc=cellLoc***REMOVED***
    # Do column labels
    if colLabels is not None:
        for col in xrange(cols***REMOVED***:
            table.add_cell(0, col,
                           width=colWidths[col***REMOVED***, height=height,
                           text=colLabels[col***REMOVED***, facecolor=colColours[col***REMOVED***,
                           loc=colLoc***REMOVED***

    # Do row labels
    if rowLabels is not None:
        for row in xrange(rows***REMOVED***:
            table.add_cell(row + offset, -1,
                           width=rowLabelWidth or 1e-15, height=height,
                           text=rowLabels[row***REMOVED***, facecolor=rowColours[row***REMOVED***,
                           loc=rowLoc***REMOVED***
        if rowLabelWidth == 0:
            table.auto_set_column_width(-1***REMOVED***

    ax.add_table(table***REMOVED***
    return table


docstring.interpd.update(Table=artist.kwdoc(Table***REMOVED******REMOVED***
