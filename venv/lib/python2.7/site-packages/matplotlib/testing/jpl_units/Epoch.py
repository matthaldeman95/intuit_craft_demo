#===========================================================================
#
# Epoch
#
#===========================================================================


***REMOVED***Epoch module.***REMOVED***

#===========================================================================
# Place all imports after here.
#
from __future__ import (absolute_import, division, print_function,
                        unicode_literals***REMOVED***

from matplotlib.externals import six

import math
import datetime as DT
from matplotlib.dates import date2num
#
# Place all imports before here.
#===========================================================================

#===========================================================================
class Epoch(object***REMOVED***:
   # Frame conversion offsets in seconds
   # t(TO***REMOVED*** = t(FROM***REMOVED*** + allowed[ FROM ***REMOVED***[ TO ***REMOVED***
   allowed = {
      "ET" : {
         "UTC" : +64.1839,
 ***REMOVED***
      "UTC" : {
         "ET" : -64.1839,
 ***REMOVED***
  ***REMOVED***

   #-----------------------------------------------------------------------
   def __init__( self, frame, sec=None, jd=None, daynum=None, dt=None ***REMOVED***:
      ***REMOVED***Create a new Epoch object.

      Build an epoch 1 of 2 ways:

      Using seconds past a Julian date:
      #   Epoch( 'ET', sec=1e8, jd=2451545 ***REMOVED***

      or using a matplotlib day number
      #   Epoch( 'ET', daynum=730119.5 ***REMOVED***


      = ERROR CONDITIONS
      - If the input units are not in the allowed list, an error is thrown.

      = INPUT VARIABLES
      - frame    The frame of the epoch.  Must be 'ET' or 'UTC'
      - sec      The number of seconds past the input JD.
      - jd       The Julian date of the epoch.
      - daynum   The matplotlib day number of the epoch.
      - dt       A python datetime instance.
      ***REMOVED***
      if ( ( sec is None and jd is not None ***REMOVED*** or
           ( sec is not None and jd is None ***REMOVED*** or
           ( daynum is not None and ( sec is not None or jd is not None ***REMOVED*** ***REMOVED*** or
           ( daynum is None and dt is None and ( sec is None or jd is None ***REMOVED*** ***REMOVED*** or
           ( daynum is not None and dt is not None ***REMOVED*** or
           ( dt is not None and ( sec is not None or jd is not None ***REMOVED*** ***REMOVED*** or
           ( (dt is not None***REMOVED*** and not isinstance(dt, DT.datetime***REMOVED*** ***REMOVED*** ***REMOVED***:
         msg = "Invalid inputs.  Must enter sec and jd together, " \
               "daynum by itself, or dt (must be a python datetime***REMOVED***.\n" \
               "Sec = %s\nJD  = %s\ndnum= %s\ndt  = %s" \
               % ( str( sec ***REMOVED***, str( jd ***REMOVED***, str( daynum ***REMOVED***, str( dt ***REMOVED*** ***REMOVED***
         raise ValueError( msg ***REMOVED***

      if frame not in self.allowed:
         msg = "Input frame '%s' is not one of the supported frames of %s" \
               % ( frame, str( list(six.iterkeys(self.allowed***REMOVED*** ***REMOVED*** ***REMOVED*** ***REMOVED***
         raise ValueError(msg***REMOVED***

      self._frame = frame

      if dt is not None:
         daynum = date2num( dt ***REMOVED***

      if daynum is not None:
         # 1-JAN-0001 in JD = 1721425.5
         jd = float( daynum ***REMOVED*** + 1721425.5
         self._jd = math.floor( jd ***REMOVED***
         self._seconds = ( jd - self._jd ***REMOVED*** * 86400.0

      else:
         self._seconds = float( sec ***REMOVED***
         self._jd = float( jd ***REMOVED***

         # Resolve seconds down to [ 0, 86400 ***REMOVED***
         deltaDays = int( math.floor( self._seconds / 86400.0 ***REMOVED*** ***REMOVED***
         self._jd += deltaDays
         self._seconds -= deltaDays * 86400.0

   #-----------------------------------------------------------------------
   def convert( self, frame ***REMOVED***:
      if self._frame == frame:
         return self

      offset = self.allowed[ self._frame ***REMOVED***[ frame ***REMOVED***

      return Epoch( frame, self._seconds + offset, self._jd ***REMOVED***

   #-----------------------------------------------------------------------
   def frame( self ***REMOVED***:
      return self._frame

   #-----------------------------------------------------------------------
   def julianDate( self, frame ***REMOVED***:
      t = self
      if frame != self._frame:
         t = self.convert( frame ***REMOVED***

      return t._jd + t._seconds / 86400.0

   #-----------------------------------------------------------------------
   def secondsPast( self, frame, jd ***REMOVED***:
      t = self
      if frame != self._frame:
         t = self.convert( frame ***REMOVED***

      delta = t._jd - jd
      return t._seconds + delta * 86400

   #-----------------------------------------------------------------------
   def __cmp__( self, rhs ***REMOVED***:
      ***REMOVED***Compare two Epoch's.

      = INPUT VARIABLES
      - rhs    The Epoch to compare against.

      = RETURN VALUE
      - Returns -1 if self < rhs, 0 if self == rhs, +1 if self > rhs.
      ***REMOVED***
      t = self
      if self._frame != rhs._frame:
         t = self.convert( rhs._frame ***REMOVED***

      if t._jd != rhs._jd:
         return cmp( t._jd, rhs._jd ***REMOVED***

      return cmp( t._seconds, rhs._seconds ***REMOVED***

   #-----------------------------------------------------------------------
   def __add__( self, rhs ***REMOVED***:
      ***REMOVED***Add a duration to an Epoch.

      = INPUT VARIABLES
      - rhs    The Epoch to subtract.

      = RETURN VALUE
      - Returns the difference of ourselves and the input Epoch.
      ***REMOVED***
      t = self
      if self._frame != rhs.frame(***REMOVED***:
         t = self.convert( rhs._frame ***REMOVED***

      sec = t._seconds + rhs.seconds(***REMOVED***

      return Epoch( t._frame, sec, t._jd ***REMOVED***

   #-----------------------------------------------------------------------
   def __sub__( self, rhs ***REMOVED***:
      ***REMOVED***Subtract two Epoch's or a Duration from an Epoch.

      Valid:
      Duration = Epoch - Epoch
      Epoch = Epoch - Duration

      = INPUT VARIABLES
      - rhs    The Epoch to subtract.

      = RETURN VALUE
      - Returns either the duration between to Epoch's or the a new
        Epoch that is the result of subtracting a duration from an epoch.
      ***REMOVED***
      # Delay-load due to circular dependencies.
      import matplotlib.testing.jpl_units as U

      # Handle Epoch - Duration
      if isinstance( rhs, U.Duration ***REMOVED***:
         return self + -rhs

      t = self
      if self._frame != rhs._frame:
         t = self.convert( rhs._frame ***REMOVED***

      days = t._jd - rhs._jd
      sec = t._seconds - rhs._seconds

      return U.Duration( rhs._frame, days*86400 + sec ***REMOVED***

   #-----------------------------------------------------------------------
   def __str__( self ***REMOVED***:
      ***REMOVED***Print the Epoch.***REMOVED***
      return "%22.15e %s" % ( self.julianDate( self._frame ***REMOVED***, self._frame ***REMOVED***

   #-----------------------------------------------------------------------
   def __repr__( self ***REMOVED***:
      ***REMOVED***Print the Epoch.***REMOVED***
      return str( self ***REMOVED***

   #-----------------------------------------------------------------------
   def range( start, stop, step ***REMOVED***:
      ***REMOVED***Generate a range of Epoch objects.

      Similar to the Python range(***REMOVED*** method.  Returns the range [
      start, stop ***REMOVED*** at the requested step.  Each element will be a
      Epoch object.

      = INPUT VARIABLES
      - start    The starting value of the range.
      - stop     The stop value of the range.
      - step     Step to use.

      = RETURN VALUE
      - Returns a list contianing the requested Epoch values.
      ***REMOVED***
      elems = [***REMOVED***

      i = 0
      while True:
         d = start + i * step
         if d >= stop:
            break

         elems.append( d ***REMOVED***
         i += 1

      return elems

   range = staticmethod( range ***REMOVED***

#===========================================================================
