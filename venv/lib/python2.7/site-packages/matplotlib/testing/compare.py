***REMOVED***
Provides a collection of utilities for comparing (image***REMOVED*** results.

***REMOVED***
from __future__ import (absolute_import, division, print_function,
                        unicode_literals***REMOVED***

from matplotlib.externals import six

import hashlib
***REMOVED***
import shutil

import numpy as np

import matplotlib
from matplotlib.compat import subprocess
from matplotlib.testing.exceptions import ImageComparisonFailure
from matplotlib import _png
from matplotlib import _get_cachedir
from matplotlib import cbook
from distutils import version

__all__ = ['compare_float', 'compare_images', 'comparable_formats'***REMOVED***


def make_test_filename(fname, purpose***REMOVED***:
    ***REMOVED***
    Make a new filename by inserting `purpose` before the file's
    extension.
    ***REMOVED***
    base, ext = os.path.splitext(fname***REMOVED***
    return '%s-%s%s' % (base, purpose, ext***REMOVED***


def compare_float(expected, actual, relTol=None, absTol=None***REMOVED***:
    ***REMOVED***
    Fail if the floating point values are not close enough, with
    the given message.

    You can specify a relative tolerance, absolute tolerance, or both.

    ***REMOVED***
    if relTol is None and absTol is None:
        raise ValueError("You haven't specified a 'relTol' relative "
                         "tolerance or a 'absTol' absolute tolerance "
                         "function argument. You must specify one."***REMOVED***
    msg = ""

    if absTol is not None:
        absDiff = abs(expected - actual***REMOVED***
        if absTol < absDiff:
            template = ['',
                        'Expected: {expected***REMOVED***',
                        'Actual:   {actual***REMOVED***',
                        'Abs diff: {absDiff***REMOVED***',
                        'Abs tol:  {absTol***REMOVED***'***REMOVED***
            msg += '\n  '.join([line.format(**locals(***REMOVED******REMOVED*** for line in template***REMOVED******REMOVED***

    if relTol is not None:
        # The relative difference of the two values.  If the expected value is
        # zero, then return the absolute value of the difference.
        relDiff = abs(expected - actual***REMOVED***
        if expected:
            relDiff = relDiff / abs(expected***REMOVED***

        if relTol < relDiff:
            # The relative difference is a ratio, so it's always unit-less.
            template = ['',
                        'Expected: {expected***REMOVED***',
                        'Actual:   {actual***REMOVED***',
                        'Rel diff: {relDiff***REMOVED***',
                        'Rel tol:  {relTol***REMOVED***'***REMOVED***
            msg += '\n  '.join([line.format(**locals(***REMOVED******REMOVED*** for line in template***REMOVED******REMOVED***

    return msg or None


def get_cache_dir(***REMOVED***:
    cachedir = _get_cachedir(***REMOVED***
    if cachedir is None:
        raise RuntimeError('Could not find a suitable configuration directory'***REMOVED***
    cache_dir = os.path.join(cachedir, 'test_cache'***REMOVED***
    if not os.path.exists(cache_dir***REMOVED***:
        ***REMOVED***
            cbook.mkdirs(cache_dir***REMOVED***
        except IOError:
            return None
    if not os.access(cache_dir, os.W_OK***REMOVED***:
        return None
    return cache_dir


def get_file_hash(path, block_size=2 ** 20***REMOVED***:
    md5 = hashlib.md5(***REMOVED***
    with open(path, 'rb'***REMOVED*** as fd:
        while True:
            data = fd.read(block_size***REMOVED***
            if not data:
                break
            md5.update(data***REMOVED***
    return md5.hexdigest(***REMOVED***


def make_external_conversion_command(cmd***REMOVED***:
    def convert(old, new***REMOVED***:
        cmdline = cmd(old, new***REMOVED***
        pipe = subprocess.Popen(
            cmdline, stdout=subprocess.PIPE, stderr=subprocess.PIPE***REMOVED***
        stdout, stderr = pipe.communicate(***REMOVED***
        errcode = pipe.wait(***REMOVED***
        if not os.path.exists(new***REMOVED*** or errcode:
            msg = "Conversion command failed:\n%s\n" % ' '.join(cmdline***REMOVED***
            if stdout:
                msg += "Standard output:\n%s\n" % stdout
            if stderr:
                msg += "Standard error:\n%s\n" % stderr
            raise IOError(msg***REMOVED***

    return convert


def _update_converter(***REMOVED***:
    gs, gs_v = matplotlib.checkdep_ghostscript(***REMOVED***
    if gs_v is not None:
        def cmd(old, new***REMOVED***:
            return [gs, '-q', '-sDEVICE=png16m', '-dNOPAUSE', '-dBATCH',
             '-sOutputFile=' + new, old***REMOVED***
        converter['pdf'***REMOVED*** = make_external_conversion_command(cmd***REMOVED***
        converter['eps'***REMOVED*** = make_external_conversion_command(cmd***REMOVED***

    if matplotlib.checkdep_inkscape(***REMOVED*** is not None:
        def cmd(old, new***REMOVED***:
            return ['inkscape', '-z', old, '--export-png', new***REMOVED***
        converter['svg'***REMOVED*** = make_external_conversion_command(cmd***REMOVED***


#: A dictionary that maps filename extensions to functions which
#: themselves map arguments `old` and `new` (filenames***REMOVED*** to a list of strings.
#: The list can then be passed to Popen to convert files with that
#: extension to png format.
converter = {***REMOVED***
_update_converter(***REMOVED***


def comparable_formats(***REMOVED***:
    ***REMOVED***
    Returns the list of file formats that compare_images can compare
    on this system.

    ***REMOVED***
    return ['png'***REMOVED*** + list(six.iterkeys(converter***REMOVED******REMOVED***


def convert(filename, cache***REMOVED***:
    ***REMOVED***
    Convert the named file into a png file.  Returns the name of the
    created file.

    If *cache* is True, the result of the conversion is cached in
    `matplotlib._get_cachedir(***REMOVED*** + '/test_cache/'`.  The caching is based
    on a hash of the exact contents of the input file.  The is no limit
    on the size of the cache, so it may need to be manually cleared
    periodically.

    ***REMOVED***
    base, extension = filename.rsplit('.', 1***REMOVED***
    if extension not in converter:
        raise ImageComparisonFailure(
            "Don't know how to convert %s files to png" % extension***REMOVED***
    newname = base + '_' + extension + '.png'
    if not os.path.exists(filename***REMOVED***:
        raise IOError("'%s' does not exist" % filename***REMOVED***

    # Only convert the file if the destination doesn't already exist or
    # is out of date.
    if (not os.path.exists(newname***REMOVED*** or
            os.stat(newname***REMOVED***.st_mtime < os.stat(filename***REMOVED***.st_mtime***REMOVED***:
        if cache:
            cache_dir = get_cache_dir(***REMOVED***
        else:
            cache_dir = None

        if cache_dir is not None:
            hash_value = get_file_hash(filename***REMOVED***
            new_ext = os.path.splitext(newname***REMOVED***[1***REMOVED***
            cached_file = os.path.join(cache_dir, hash_value + new_ext***REMOVED***
            if os.path.exists(cached_file***REMOVED***:
                shutil.copyfile(cached_file, newname***REMOVED***
                return newname

        converter[extension***REMOVED***(filename, newname***REMOVED***

        if cache_dir is not None:
            shutil.copyfile(newname, cached_file***REMOVED***

    return newname

#: Maps file extensions to a function which takes a filename as its
#: only argument to return a list suitable for execution with Popen.
#: The purpose of this is so that the result file (with the given
#: extension***REMOVED*** can be verified with tools such as xmllint for svg.
verifiers = {***REMOVED***

# Turning this off, because it seems to cause multiprocessing issues
if matplotlib.checkdep_xmllint(***REMOVED*** and False:
    verifiers['svg'***REMOVED*** = lambda filename: [
        'xmllint', '--valid', '--nowarning', '--noout', filename***REMOVED***


def verify(filename***REMOVED***:
    ***REMOVED***Verify the file through some sort of verification tool.***REMOVED***
    if not os.path.exists(filename***REMOVED***:
        raise IOError("'%s' does not exist" % filename***REMOVED***
    base, extension = filename.rsplit('.', 1***REMOVED***
    verifier = verifiers.get(extension, None***REMOVED***
    if verifier is not None:
        cmd = verifier(filename***REMOVED***
        pipe = subprocess.Popen(
            cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE***REMOVED***
        stdout, stderr = pipe.communicate(***REMOVED***
        errcode = pipe.wait(***REMOVED***
        if errcode != 0:
            msg = "File verification command failed:\n%s\n" % ' '.join(cmd***REMOVED***
            if stdout:
                msg += "Standard output:\n%s\n" % stdout
            if stderr:
                msg += "Standard error:\n%s\n" % stderr
            raise IOError(msg***REMOVED***


def crop_to_same(actual_path, actual_image, expected_path, expected_image***REMOVED***:
    # clip the images to the same size -- this is useful only when
    # comparing eps to pdf
    if actual_path[-7:-4***REMOVED*** == 'eps' and expected_path[-7:-4***REMOVED*** == 'pdf':
        aw, ah = actual_image.shape
        ew, eh = expected_image.shape
        actual_image = actual_image[int(aw / 2 - ew / 2***REMOVED***:int(
            aw / 2 + ew / 2***REMOVED***, int(ah / 2 - eh / 2***REMOVED***:int(ah / 2 + eh / 2***REMOVED******REMOVED***
    return actual_image, expected_image


def calculate_rms(expectedImage, actualImage***REMOVED***:
    "Calculate the per-pixel errors, then compute the root mean square error."
    if expectedImage.shape != actualImage.shape:
        raise ImageComparisonFailure(
            "image sizes do not match expected size: {0***REMOVED*** "
            "actual size {1***REMOVED***".format(expectedImage.shape, actualImage.shape***REMOVED******REMOVED***

    num_values = np.prod(expectedImage.shape***REMOVED***
    abs_diff_image = abs(expectedImage - actualImage***REMOVED***

    # On Numpy 1.6, we can use bincount with minlength, which is much
    # faster than using histogram
    expected_version = version.LooseVersion("1.6"***REMOVED***
    found_version = version.LooseVersion(np.__version__***REMOVED***
    if found_version >= expected_version:
        histogram = np.bincount(abs_diff_image.ravel(***REMOVED***, minlength=256***REMOVED***
    else:
        histogram = np.histogram(abs_diff_image, bins=np.arange(257***REMOVED******REMOVED***[0***REMOVED***

    sum_of_squares = np.sum(histogram * np.arange(len(histogram***REMOVED******REMOVED*** ** 2***REMOVED***
    rms = np.sqrt(float(sum_of_squares***REMOVED*** / num_values***REMOVED***

    return rms


def compare_images(expected, actual, tol, in_decorator=False***REMOVED***:
    ***REMOVED***
    Compare two "image" files checking differences within a tolerance.

    The two given filenames may point to files which are convertible to
    PNG via the `.converter` dictionary. The underlying RMS is calculated
    with the `.calculate_rms` function.

    Parameters
    ----------
    expected : str
        The filename of the expected image.
    actual :str
        The filename of the actual image.
    tol : float
        The tolerance (a color value difference, where 255 is the
        maximal difference***REMOVED***.  The test fails if the average pixel
        difference is greater than this value.
    in_decorator : bool
        If called from image_comparison decorator, this should be
        True. (default=False***REMOVED***

    Example
    -------
    img1 = "./baseline/plot.png"
    img2 = "./output/plot.png"
    compare_images( img1, img2, 0.001 ***REMOVED***:

    ***REMOVED***
    if not os.path.exists(actual***REMOVED***:
        msg = "Output image %s does not exist." % actual
        raise Exception(msg***REMOVED***

    if os.stat(actual***REMOVED***.st_size == 0:
        msg = "Output image file %s is empty." % actual
        raise Exception(msg***REMOVED***

    verify(actual***REMOVED***

    # Convert the image to png
    extension = expected.split('.'***REMOVED***[-1***REMOVED***

    if not os.path.exists(expected***REMOVED***:
        raise IOError('Baseline image %r does not exist.' % expected***REMOVED***

    if extension != 'png':
        actual = convert(actual, False***REMOVED***
        expected = convert(expected, True***REMOVED***

    # open the image files and remove the alpha channel (if it exists***REMOVED***
    expectedImage = _png.read_png_int(expected***REMOVED***
    actualImage = _png.read_png_int(actual***REMOVED***
    expectedImage = expectedImage[:, :, :3***REMOVED***
    actualImage = actualImage[:, :, :3***REMOVED***

    actualImage, expectedImage = crop_to_same(
        actual, actualImage, expected, expectedImage***REMOVED***

    # convert to signed integers, so that the images can be subtracted without
    # overflow
    expectedImage = expectedImage.astype(np.int16***REMOVED***
    actualImage = actualImage.astype(np.int16***REMOVED***

    rms = calculate_rms(expectedImage, actualImage***REMOVED***

    diff_image = make_test_filename(actual, 'failed-diff'***REMOVED***

    if rms <= tol:
        if os.path.exists(diff_image***REMOVED***:
            os.unlink(diff_image***REMOVED***
        return None

    save_diff_image(expected, actual, diff_image***REMOVED***

    results = dict(rms=rms, expected=str(expected***REMOVED***,
                   actual=str(actual***REMOVED***, diff=str(diff_image***REMOVED***, tol=tol***REMOVED***

    if not in_decorator:
        # Then the results should be a string suitable for stdout.
        template = ['Error: Image files did not match.',
                    'RMS Value: {rms***REMOVED***',
                    'Expected:  \n***REMOVED***expected***REMOVED***',
                    'Actual:    \n***REMOVED***actual***REMOVED***',
                    'Difference:\n***REMOVED***diff***REMOVED***',
                    'Tolerance: \n***REMOVED***tol***REMOVED***', ***REMOVED***
        results = '\n  '.join([line.format(**results***REMOVED*** for line in template***REMOVED******REMOVED***
    return results


def save_diff_image(expected, actual, output***REMOVED***:
    expectedImage = _png.read_png(expected***REMOVED***
    actualImage = _png.read_png(actual***REMOVED***
    actualImage, expectedImage = crop_to_same(
        actual, actualImage, expected, expectedImage***REMOVED***
    expectedImage = np.array(expectedImage***REMOVED***.astype(np.float***REMOVED***
    actualImage = np.array(actualImage***REMOVED***.astype(np.float***REMOVED***
    assert expectedImage.ndim == actualImage.ndim
    assert expectedImage.shape == actualImage.shape
    absDiffImage = abs(expectedImage - actualImage***REMOVED***

    # expand differences in luminance domain
    absDiffImage *= 255 * 10
    save_image_np = np.clip(absDiffImage, 0, 255***REMOVED***.astype(np.uint8***REMOVED***
    height, width, depth = save_image_np.shape

    # The PDF renderer doesn't produce an alpha channel, but the
    # matplotlib PNG writer requires one, so expand the array
    if depth == 3:
        with_alpha = np.empty((height, width, 4***REMOVED***, dtype=np.uint8***REMOVED***
        with_alpha[:, :, 0:3***REMOVED*** = save_image_np
        save_image_np = with_alpha

    # Hard-code the alpha channel to fully solid
    save_image_np[:, :, 3***REMOVED*** = 255

    _png.write_png(save_image_np, output***REMOVED***
