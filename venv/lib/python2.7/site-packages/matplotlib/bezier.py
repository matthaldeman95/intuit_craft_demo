***REMOVED***
A module providing some utility functions regarding bezier path manipulation.
***REMOVED***

from __future__ import (absolute_import, division, print_function,
                        unicode_literals***REMOVED***

from matplotlib.externals import six

import numpy as np
from matplotlib.path import Path

from operator import xor
import warnings


class NonIntersectingPathException(ValueError***REMOVED***:
    pass

# some functions


def get_intersection(cx1, cy1, cos_t1, sin_t1,
                     cx2, cy2, cos_t2, sin_t2***REMOVED***:
    ***REMOVED*** return a intersecting point between a line through (cx1, cy1***REMOVED***
    and having angle t1 and a line through (cx2, cy2***REMOVED*** and angle t2.
    ***REMOVED***

    # line1 => sin_t1 * (x - cx1***REMOVED*** - cos_t1 * (y - cy1***REMOVED*** = 0.
    # line1 => sin_t1 * x + cos_t1 * y = sin_t1*cx1 - cos_t1*cy1

    line1_rhs = sin_t1 * cx1 - cos_t1 * cy1
    line2_rhs = sin_t2 * cx2 - cos_t2 * cy2

    # rhs matrix
    a, b = sin_t1, -cos_t1
    c, d = sin_t2, -cos_t2

    ad_bc = a * d - b * c
    if ad_bc == 0.:
        raise ValueError("Given lines do not intersect"***REMOVED***

    # rhs_inverse
    a_, b_ = d, -b
    c_, d_ = -c, a
    a_, b_, c_, d_ = [k / ad_bc for k in [a_, b_, c_, d_***REMOVED******REMOVED***

    x = a_ * line1_rhs + b_ * line2_rhs
    y = c_ * line1_rhs + d_ * line2_rhs

    return x, y


def get_normal_points(cx, cy, cos_t, sin_t, length***REMOVED***:
    ***REMOVED***
    For a line passing through (*cx*, *cy****REMOVED*** and having a angle *t*, return
    locations of the two points located along its perpendicular line at the
    distance of *length*.
    ***REMOVED***

    if length == 0.:
        return cx, cy, cx, cy

    cos_t1, sin_t1 = sin_t, -cos_t
    cos_t2, sin_t2 = -sin_t, cos_t

    x1, y1 = length * cos_t1 + cx, length * sin_t1 + cy
    x2, y2 = length * cos_t2 + cx, length * sin_t2 + cy

    return x1, y1, x2, y2


# BEZIER routines

# subdividing bezier curve
# http://www.cs.mtu.edu/~shene/COURSES/cs3621/NOTES/spline/Bezier/bezier-sub.html


def _de_casteljau1(beta, t***REMOVED***:
    next_beta = beta[:-1***REMOVED*** * (1 - t***REMOVED*** + beta[1:***REMOVED*** * t
    return next_beta


def split_de_casteljau(beta, t***REMOVED***:
    ***REMOVED***split a bezier segment defined by its controlpoints *beta*
    into two separate segment divided at *t* and return their control points.

    ***REMOVED***
    beta = np.asarray(beta***REMOVED***
    beta_list = [beta***REMOVED***
    while True:
        beta = _de_casteljau1(beta, t***REMOVED***
        beta_list.append(beta***REMOVED***
        if len(beta***REMOVED*** == 1:
            break
    left_beta = [beta[0***REMOVED*** for beta in beta_list***REMOVED***
    right_beta = [beta[-1***REMOVED*** for beta in reversed(beta_list***REMOVED******REMOVED***

    return left_beta, right_beta


# FIXME spelling mistake in the name of the parameter ``tolerence``
def find_bezier_t_intersecting_with_closedpath(bezier_point_at_t,
                                               inside_closedpath,
                                               t0=0., t1=1., tolerence=0.01***REMOVED***:
    ***REMOVED*** Find a parameter t0 and t1 of the given bezier path which
    bounds the intersecting points with a provided closed
    path(*inside_closedpath****REMOVED***. Search starts from *t0* and *t1* and it
    uses a simple bisecting algorithm therefore one of the end point
    must be inside the path while the orther doesn't. The search stop
    when |t0-t1| gets smaller than the given tolerence.
    value for

    - bezier_point_at_t : a function which returns x, y coordinates at *t*

    - inside_closedpath : return True if the point is insed the path

    ***REMOVED***
    # inside_closedpath : function

    start = bezier_point_at_t(t0***REMOVED***
    end = bezier_point_at_t(t1***REMOVED***

    start_inside = inside_closedpath(start***REMOVED***
    end_inside = inside_closedpath(end***REMOVED***

    if start_inside == end_inside:
        if start != end:
            raise NonIntersectingPathException(
                "the segment does not seem to intersect with the path"
            ***REMOVED***

    while 1:

        # return if the distance is smaller than the tolerence
        if (start[0***REMOVED*** - end[0***REMOVED******REMOVED*** ** 2 + \
           (start[1***REMOVED*** - end[1***REMOVED******REMOVED*** ** 2 < tolerence ** 2:
            return t0, t1

        # calculate the middle point
        middle_t = 0.5 * (t0 + t1***REMOVED***
        middle = bezier_point_at_t(middle_t***REMOVED***
        middle_inside = inside_closedpath(middle***REMOVED***

        if xor(start_inside, middle_inside***REMOVED***:
            t1 = middle_t
            end = middle
            end_inside = middle_inside
        else:
            t0 = middle_t
            start = middle
            start_inside = middle_inside


class BezierSegment(object***REMOVED***:
    ***REMOVED***
    A simple class of a 2-dimensional bezier segment
    ***REMOVED***

    # Higher order bezier lines can be supported by simplying adding
    # corresponding values.
    _binom_coeff = {1: np.array([1., 1.***REMOVED******REMOVED***,
                    2: np.array([1., 2., 1.***REMOVED******REMOVED***,
                    3: np.array([1., 3., 3., 1.***REMOVED******REMOVED******REMOVED***

    def __init__(self, control_points***REMOVED***:
        ***REMOVED***
        *control_points* : location of contol points. It needs have a
         shpae of n * 2, where n is the order of the bezier line. 1<=
         n <= 3 is supported.
        ***REMOVED***
        _o = len(control_points***REMOVED***
        self._orders = np.arange(_o***REMOVED***
        _coeff = BezierSegment._binom_coeff[_o - 1***REMOVED***

        _control_points = np.asarray(control_points***REMOVED***
        xx = _control_points[:, 0***REMOVED***
        yy = _control_points[:, 1***REMOVED***

        self._px = xx * _coeff
        self._py = yy * _coeff

    def point_at_t(self, t***REMOVED***:
        "evaluate a point at t"
        one_minus_t_powers = np.power(1. - t, self._orders***REMOVED***[::-1***REMOVED***
        t_powers = np.power(t, self._orders***REMOVED***

        tt = one_minus_t_powers * t_powers
        _x = sum(tt * self._px***REMOVED***
        _y = sum(tt * self._py***REMOVED***

        return _x, _y


def split_bezier_intersecting_with_closedpath(bezier,
                                              inside_closedpath,
                                              tolerence=0.01***REMOVED***:

    ***REMOVED***
    bezier : control points of the bezier segment
    inside_closedpath : a function which returns true if the point is inside
                        the path
    ***REMOVED***

    bz = BezierSegment(bezier***REMOVED***
    bezier_point_at_t = bz.point_at_t

    t0, t1 = find_bezier_t_intersecting_with_closedpath(bezier_point_at_t,
                                                        inside_closedpath,
                                                        tolerence=tolerence***REMOVED***

    _left, _right = split_de_casteljau(bezier, (t0 + t1***REMOVED*** / 2.***REMOVED***
    return _left, _right


def find_r_to_boundary_of_closedpath(inside_closedpath, xy,
                                     cos_t, sin_t,
                                     rmin=0., rmax=1., tolerence=0.01***REMOVED***:
    ***REMOVED***
    Find a radius r (centered at *xy****REMOVED*** between *rmin* and *rmax* at
    which it intersect with the path.

    inside_closedpath : function
    cx, cy : center
    cos_t, sin_t : cosine and sine for the angle
    rmin, rmax :
    ***REMOVED***

    cx, cy = xy

    def _f(r***REMOVED***:
        return cos_t * r + cx, sin_t * r + cy

    find_bezier_t_intersecting_with_closedpath(_f, inside_closedpath,
                                               t0=rmin, t1=rmax,
                                               tolerence=tolerence***REMOVED***

# matplotlib specific


def split_path_inout(path, inside, tolerence=0.01, reorder_inout=False***REMOVED***:
    ***REMOVED*** divide a path into two segment at the point where inside(x, y***REMOVED***
    becomes False.
    ***REMOVED***

    path_iter = path.iter_segments(***REMOVED***

    ctl_points, command = next(path_iter***REMOVED***
    begin_inside = inside(ctl_points[-2:***REMOVED******REMOVED***  # true if begin point is inside

    bezier_path = None
    ctl_points_old = ctl_points

    concat = np.concatenate

    iold = 0
    i = 1

    for ctl_points, command in path_iter:
        iold = i
        i += len(ctl_points***REMOVED*** // 2
        if inside(ctl_points[-2:***REMOVED******REMOVED*** != begin_inside:
            bezier_path = concat([ctl_points_old[-2:***REMOVED***, ctl_points***REMOVED******REMOVED***
            break

        ctl_points_old = ctl_points

    if bezier_path is None:
        raise ValueError("The path does not seem to intersect with the patch"***REMOVED***

    bp = list(zip(bezier_path[::2***REMOVED***, bezier_path[1::2***REMOVED******REMOVED******REMOVED***
    left, right = split_bezier_intersecting_with_closedpath(bp,
                                                            inside,
                                                            tolerence***REMOVED***
    if len(left***REMOVED*** == 2:
        codes_left = [Path.LINETO***REMOVED***
        codes_right = [Path.MOVETO, Path.LINETO***REMOVED***
    elif len(left***REMOVED*** == 3:
        codes_left = [Path.CURVE3, Path.CURVE3***REMOVED***
        codes_right = [Path.MOVETO, Path.CURVE3, Path.CURVE3***REMOVED***
    elif len(left***REMOVED*** == 4:
        codes_left = [Path.CURVE4, Path.CURVE4, Path.CURVE4***REMOVED***
        codes_right = [Path.MOVETO, Path.CURVE4, Path.CURVE4, Path.CURVE4***REMOVED***
    else:
        raise ValueError(***REMOVED***

    verts_left = left[1:***REMOVED***
    verts_right = right[:***REMOVED***

    if path.codes is None:
        path_in = Path(concat([path.vertices[:i***REMOVED***, verts_left***REMOVED******REMOVED******REMOVED***
        path_out = Path(concat([verts_right, path.vertices[i:***REMOVED******REMOVED******REMOVED******REMOVED***

    else:
        path_in = Path(concat([path.vertices[:iold***REMOVED***, verts_left***REMOVED******REMOVED***,
                       concat([path.codes[:iold***REMOVED***, codes_left***REMOVED******REMOVED******REMOVED***

        path_out = Path(concat([verts_right, path.vertices[i:***REMOVED******REMOVED******REMOVED***,
                        concat([codes_right, path.codes[i:***REMOVED******REMOVED******REMOVED******REMOVED***

    if reorder_inout and begin_inside is False:
        path_in, path_out = path_out, path_in

    return path_in, path_out


def inside_circle(cx, cy, r***REMOVED***:
    r2 = r ** 2

    def _f(xy***REMOVED***:
        x, y = xy
        return (x - cx***REMOVED*** ** 2 + (y - cy***REMOVED*** ** 2 < r2
    return _f


# quadratic bezier lines

def get_cos_sin(x0, y0, x1, y1***REMOVED***:
    dx, dy = x1 - x0, y1 - y0
    d = (dx * dx + dy * dy***REMOVED*** ** .5
    # Account for divide by zero
    if d == 0:
        return 0.0, 0.0
    return dx / d, dy / d


def check_if_parallel(dx1, dy1, dx2, dy2, tolerence=1.e-5***REMOVED***:
    ***REMOVED*** returns
       * 1 if two lines are parralel in same direction
       * -1 if two lines are parralel in opposite direction
       * 0 otherwise
    ***REMOVED***
    theta1 = np.arctan2(dx1, dy1***REMOVED***
    theta2 = np.arctan2(dx2, dy2***REMOVED***
    dtheta = np.abs(theta1 - theta2***REMOVED***
    if dtheta < tolerence:
        return 1
    elif np.abs(dtheta - np.pi***REMOVED*** < tolerence:
        return -1
    else:
        return False


def get_parallels(bezier2, width***REMOVED***:
    ***REMOVED***
    Given the quadratic bezier control points *bezier2*, returns
    control points of quadratic bezier lines roughly parallel to given
    one separated by *width*.
    ***REMOVED***

    # The parallel bezier lines are constructed by following ways.
    #  c1 and  c2 are contol points representing the begin and end of the
    #  bezier line.
    #  cm is the middle point

    c1x, c1y = bezier2[0***REMOVED***
    cmx, cmy = bezier2[1***REMOVED***
    c2x, c2y = bezier2[2***REMOVED***

    parallel_test = check_if_parallel(c1x - cmx, c1y - cmy,
                                      cmx - c2x, cmy - c2y***REMOVED***

    if parallel_test == -1:
        warnings.warn(
            "Lines do not intersect. A straight line is used instead."***REMOVED***
        cos_t1, sin_t1 = get_cos_sin(c1x, c1y, c2x, c2y***REMOVED***
        cos_t2, sin_t2 = cos_t1, sin_t1
    else:
        # t1 and t2 is the angle between c1 and cm, cm, c2.  They are
        # also a angle of the tangential line of the path at c1 and c2
        cos_t1, sin_t1 = get_cos_sin(c1x, c1y, cmx, cmy***REMOVED***
        cos_t2, sin_t2 = get_cos_sin(cmx, cmy, c2x, c2y***REMOVED***

    # find c1_left, c1_right which are located along the lines
    # throught c1 and perpendicular to the tangential lines of the
    # bezier path at a distance of width. Same thing for c2_left and
    # c2_right with respect to c2.
    c1x_left, c1y_left, c1x_right, c1y_right = (
        get_normal_points(c1x, c1y, cos_t1, sin_t1, width***REMOVED***
    ***REMOVED***
    c2x_left, c2y_left, c2x_right, c2y_right = (
        get_normal_points(c2x, c2y, cos_t2, sin_t2, width***REMOVED***
    ***REMOVED***

    # find cm_left which is the intersectng point of a line through
    # c1_left with angle t1 and a line throught c2_left with angle
    # t2. Same with cm_right.
    if parallel_test != 0:
        # a special case for a straight line, i.e., angle between two
        # lines are smaller than some (arbitrtay***REMOVED*** value.
        cmx_left, cmy_left = (
            0.5 * (c1x_left + c2x_left***REMOVED***, 0.5 * (c1y_left + c2y_left***REMOVED***
        ***REMOVED***
        cmx_right, cmy_right = (
            0.5 * (c1x_right + c2x_right***REMOVED***, 0.5 * (c1y_right + c2y_right***REMOVED***
        ***REMOVED***
    else:
        cmx_left, cmy_left = get_intersection(c1x_left, c1y_left, cos_t1,
                                              sin_t1, c2x_left, c2y_left,
                                              cos_t2, sin_t2***REMOVED***

        cmx_right, cmy_right = get_intersection(c1x_right, c1y_right, cos_t1,
                                                sin_t1, c2x_right, c2y_right,
                                                cos_t2, sin_t2***REMOVED***

    # the parralel bezier lines are created with control points of
    # [c1_left, cm_left, c2_left***REMOVED*** and [c1_right, cm_right, c2_right***REMOVED***
    path_left = [(c1x_left, c1y_left***REMOVED***,
                 (cmx_left, cmy_left***REMOVED***,
                 (c2x_left, c2y_left***REMOVED******REMOVED***
    path_right = [(c1x_right, c1y_right***REMOVED***,
                  (cmx_right, cmy_right***REMOVED***,
                  (c2x_right, c2y_right***REMOVED******REMOVED***

    return path_left, path_right


def find_control_points(c1x, c1y, mmx, mmy, c2x, c2y***REMOVED***:
    ***REMOVED*** Find control points of the bezier line throught c1, mm, c2. We
    simply assume that c1, mm, c2 which have parametric value 0, 0.5, and 1.
    ***REMOVED***

    cmx = .5 * (4 * mmx - (c1x + c2x***REMOVED******REMOVED***
    cmy = .5 * (4 * mmy - (c1y + c2y***REMOVED******REMOVED***

    return [(c1x, c1y***REMOVED***, (cmx, cmy***REMOVED***, (c2x, c2y***REMOVED******REMOVED***


def make_wedged_bezier2(bezier2, width, w1=1., wm=0.5, w2=0.***REMOVED***:
    ***REMOVED***
    Being similar to get_parallels, returns control points of two quadrativ
    bezier lines having a width roughly parralel to given one separated by
    *width*.
    ***REMOVED***

    # c1, cm, c2
    c1x, c1y = bezier2[0***REMOVED***
    cmx, cmy = bezier2[1***REMOVED***
    c3x, c3y = bezier2[2***REMOVED***

    # t1 and t2 is the anlge between c1 and cm, cm, c3.
    # They are also a angle of the tangential line of the path at c1 and c3
    cos_t1, sin_t1 = get_cos_sin(c1x, c1y, cmx, cmy***REMOVED***
    cos_t2, sin_t2 = get_cos_sin(cmx, cmy, c3x, c3y***REMOVED***

    # find c1_left, c1_right which are located along the lines
    # throught c1 and perpendicular to the tangential lines of the
    # bezier path at a distance of width. Same thing for c3_left and
    # c3_right with respect to c3.
    c1x_left, c1y_left, c1x_right, c1y_right = (
        get_normal_points(c1x, c1y, cos_t1, sin_t1, width * w1***REMOVED***
    ***REMOVED***
    c3x_left, c3y_left, c3x_right, c3y_right = (
        get_normal_points(c3x, c3y, cos_t2, sin_t2, width * w2***REMOVED***
    ***REMOVED***

    # find c12, c23 and c123 which are middle points of c1-cm, cm-c3 and
    # c12-c23
    c12x, c12y = (c1x + cmx***REMOVED*** * .5, (c1y + cmy***REMOVED*** * .5
    c23x, c23y = (cmx + c3x***REMOVED*** * .5, (cmy + c3y***REMOVED*** * .5
    c123x, c123y = (c12x + c23x***REMOVED*** * .5, (c12y + c23y***REMOVED*** * .5

    # tangential angle of c123 (angle between c12 and c23***REMOVED***
    cos_t123, sin_t123 = get_cos_sin(c12x, c12y, c23x, c23y***REMOVED***

    c123x_left, c123y_left, c123x_right, c123y_right = (
        get_normal_points(c123x, c123y, cos_t123, sin_t123, width * wm***REMOVED***
    ***REMOVED***

    path_left = find_control_points(c1x_left, c1y_left,
                                    c123x_left, c123y_left,
                                    c3x_left, c3y_left***REMOVED***
    path_right = find_control_points(c1x_right, c1y_right,
                                     c123x_right, c123y_right,
                                     c3x_right, c3y_right***REMOVED***

    return path_left, path_right


def make_path_regular(p***REMOVED***:
    ***REMOVED***
    fill in the codes if None.
    ***REMOVED***
    c = p.codes
    if c is None:
        c = np.empty(p.vertices.shape[:1***REMOVED***, "i"***REMOVED***
        c.fill(Path.LINETO***REMOVED***
        c[0***REMOVED*** = Path.MOVETO

        return Path(p.vertices, c***REMOVED***
    else:
        return p


def concatenate_paths(paths***REMOVED***:
    ***REMOVED***
    concatenate list of paths into a single path.
    ***REMOVED***

    vertices = [***REMOVED***
    codes = [***REMOVED***
    for p in paths:
        p = make_path_regular(p***REMOVED***
        vertices.append(p.vertices***REMOVED***
        codes.append(p.codes***REMOVED***

    _path = Path(np.concatenate(vertices***REMOVED***,
                 np.concatenate(codes***REMOVED******REMOVED***
    return _path
