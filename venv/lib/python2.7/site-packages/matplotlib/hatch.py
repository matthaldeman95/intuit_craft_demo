***REMOVED***
Contains a classes for generating hatch patterns.
***REMOVED***

from __future__ import (absolute_import, division, print_function,
                        unicode_literals***REMOVED***

from matplotlib.externals import six
from matplotlib.externals.six.moves import xrange

import numpy as np
from matplotlib.path import Path


class HatchPatternBase(object***REMOVED***:
    ***REMOVED***
    The base class for a hatch pattern.
    ***REMOVED***
    pass


class HorizontalHatch(HatchPatternBase***REMOVED***:
    def __init__(self, hatch, density***REMOVED***:
        self.num_lines = int((hatch.count('-'***REMOVED*** + hatch.count('+'***REMOVED******REMOVED*** * density***REMOVED***
        self.num_vertices = self.num_lines * 2

    def set_vertices_and_codes(self, vertices, codes***REMOVED***:
        steps, stepsize = np.linspace(0.0, 1.0, self.num_lines, False,
                                      retstep=True***REMOVED***
        steps += stepsize / 2.
        vertices[0::2, 0***REMOVED*** = 0.0
        vertices[0::2, 1***REMOVED*** = steps
        vertices[1::2, 0***REMOVED*** = 1.0
        vertices[1::2, 1***REMOVED*** = steps
        codes[0::2***REMOVED*** = Path.MOVETO
        codes[1::2***REMOVED*** = Path.LINETO


class VerticalHatch(HatchPatternBase***REMOVED***:
    def __init__(self, hatch, density***REMOVED***:
        self.num_lines = int((hatch.count('|'***REMOVED*** + hatch.count('+'***REMOVED******REMOVED*** * density***REMOVED***
        self.num_vertices = self.num_lines * 2

    def set_vertices_and_codes(self, vertices, codes***REMOVED***:
        steps, stepsize = np.linspace(0.0, 1.0, self.num_lines, False,
                                      retstep=True***REMOVED***
        steps += stepsize / 2.
        vertices[0::2, 0***REMOVED*** = steps
        vertices[0::2, 1***REMOVED*** = 0.0
        vertices[1::2, 0***REMOVED*** = steps
        vertices[1::2, 1***REMOVED*** = 1.0
        codes[0::2***REMOVED*** = Path.MOVETO
        codes[1::2***REMOVED*** = Path.LINETO


class NorthEastHatch(HatchPatternBase***REMOVED***:
    def __init__(self, hatch, density***REMOVED***:
        self.num_lines = int((hatch.count('/'***REMOVED*** + hatch.count('x'***REMOVED*** +
                          hatch.count('X'***REMOVED******REMOVED*** * density***REMOVED***
        if self.num_lines:
            self.num_vertices = (self.num_lines + 1***REMOVED*** * 2
        else:
            self.num_vertices = 0

    def set_vertices_and_codes(self, vertices, codes***REMOVED***:
        steps = np.linspace(-0.5, 0.5, self.num_lines + 1, True***REMOVED***
        vertices[0::2, 0***REMOVED*** = 0.0 + steps
        vertices[0::2, 1***REMOVED*** = 0.0 - steps
        vertices[1::2, 0***REMOVED*** = 1.0 + steps
        vertices[1::2, 1***REMOVED*** = 1.0 - steps
        codes[0::2***REMOVED*** = Path.MOVETO
        codes[1::2***REMOVED*** = Path.LINETO


class SouthEastHatch(HatchPatternBase***REMOVED***:
    def __init__(self, hatch, density***REMOVED***:
        self.num_lines = int((hatch.count('\\'***REMOVED*** + hatch.count('x'***REMOVED*** +
                          hatch.count('X'***REMOVED******REMOVED*** * density***REMOVED***
        self.num_vertices = (self.num_lines + 1***REMOVED*** * 2
        if self.num_lines:
            self.num_vertices = (self.num_lines + 1***REMOVED*** * 2
        else:
            self.num_vertices = 0

    def set_vertices_and_codes(self, vertices, codes***REMOVED***:
        steps = np.linspace(-0.5, 0.5, self.num_lines + 1, True***REMOVED***
        vertices[0::2, 0***REMOVED*** = 0.0 + steps
        vertices[0::2, 1***REMOVED*** = 1.0 + steps
        vertices[1::2, 0***REMOVED*** = 1.0 + steps
        vertices[1::2, 1***REMOVED*** = 0.0 + steps
        codes[0::2***REMOVED*** = Path.MOVETO
        codes[1::2***REMOVED*** = Path.LINETO


class Shapes(HatchPatternBase***REMOVED***:
    filled = False

    def __init__(self, hatch, density***REMOVED***:
        if self.num_rows == 0:
            self.num_shapes = 0
            self.num_vertices = 0
        else:
            self.num_shapes = ((self.num_rows // 2 + 1***REMOVED*** * (self.num_rows + 1***REMOVED*** +
                               (self.num_rows // 2***REMOVED*** * (self.num_rows***REMOVED******REMOVED***
            self.num_vertices = (self.num_shapes *
                                 len(self.shape_vertices***REMOVED*** *
                                 (self.filled and 1 or 2***REMOVED******REMOVED***

    def set_vertices_and_codes(self, vertices, codes***REMOVED***:
        offset = 1.0 / self.num_rows
        shape_vertices = self.shape_vertices * offset * self.size
        if not self.filled:
            inner_vertices = shape_vertices[::-1***REMOVED*** * 0.9
        shape_codes = self.shape_codes
        shape_size = len(shape_vertices***REMOVED***

        cursor = 0
        for row in xrange(self.num_rows + 1***REMOVED***:
            if row % 2 == 0:
                cols = np.linspace(0.0, 1.0, self.num_rows + 1, True***REMOVED***
            else:
                cols = np.linspace(offset / 2.0, 1.0 - offset / 2.0,
                                   self.num_rows, True***REMOVED***
            row_pos = row * offset
            for col_pos in cols:
                vertices[cursor:cursor + shape_size***REMOVED*** = (shape_vertices +
                                                        (col_pos, row_pos***REMOVED******REMOVED***
                codes[cursor:cursor + shape_size***REMOVED*** = shape_codes
                cursor += shape_size
                if not self.filled:
                    vertices[cursor:cursor + shape_size***REMOVED*** = (inner_vertices +
                                                            (col_pos, row_pos***REMOVED******REMOVED***
                    codes[cursor:cursor + shape_size***REMOVED*** = shape_codes
                    cursor += shape_size


class Circles(Shapes***REMOVED***:
    def __init__(self, hatch, density***REMOVED***:
        path = Path.unit_circle(***REMOVED***
        self.shape_vertices = path.vertices
        self.shape_codes = path.codes
        Shapes.__init__(self, hatch, density***REMOVED***


class SmallCircles(Circles***REMOVED***:
    size = 0.2

    def __init__(self, hatch, density***REMOVED***:
        self.num_rows = (hatch.count('o'***REMOVED******REMOVED*** * density
        Circles.__init__(self, hatch, density***REMOVED***


class LargeCircles(Circles***REMOVED***:
    size = 0.35

    def __init__(self, hatch, density***REMOVED***:
        self.num_rows = (hatch.count('O'***REMOVED******REMOVED*** * density
        Circles.__init__(self, hatch, density***REMOVED***


class SmallFilledCircles(SmallCircles***REMOVED***:
    size = 0.1
    filled = True

    def __init__(self, hatch, density***REMOVED***:
        self.num_rows = (hatch.count('.'***REMOVED******REMOVED*** * density
        Circles.__init__(self, hatch, density***REMOVED***


class Stars(Shapes***REMOVED***:
    size = 1.0 / 3.0
    filled = True

    def __init__(self, hatch, density***REMOVED***:
        self.num_rows = (hatch.count('*'***REMOVED******REMOVED*** * density
        path = Path.unit_regular_star(5***REMOVED***
        self.shape_vertices = path.vertices
        self.shape_codes = np.ones(len(self.shape_vertices***REMOVED******REMOVED*** * Path.LINETO
        self.shape_codes[0***REMOVED*** = Path.MOVETO
        Shapes.__init__(self, hatch, density***REMOVED***

_hatch_types = [
    HorizontalHatch,
    VerticalHatch,
    NorthEastHatch,
    SouthEastHatch,
    SmallCircles,
    LargeCircles,
    SmallFilledCircles,
    Stars
    ***REMOVED***


def get_path(hatchpattern, density=6***REMOVED***:
    ***REMOVED***
    Given a hatch specifier, *hatchpattern*, generates Path to render
    the hatch in a unit square.  *density* is the number of lines per
    unit square.
    ***REMOVED***
    density = int(density***REMOVED***

    patterns = [hatch_type(hatchpattern, density***REMOVED***
                for hatch_type in _hatch_types***REMOVED***
    num_vertices = sum([pattern.num_vertices for pattern in patterns***REMOVED******REMOVED***

    if num_vertices == 0:
        return Path(np.empty((0, 2***REMOVED******REMOVED******REMOVED***

    vertices = np.empty((num_vertices, 2***REMOVED******REMOVED***
    codes = np.empty((num_vertices,***REMOVED***, np.uint8***REMOVED***

    cursor = 0
    for pattern in patterns:
        if pattern.num_vertices != 0:
            vertices_chunk = vertices[cursor:cursor + pattern.num_vertices***REMOVED***
            codes_chunk = codes[cursor:cursor + pattern.num_vertices***REMOVED***
            pattern.set_vertices_and_codes(vertices_chunk, codes_chunk***REMOVED***
            cursor += pattern.num_vertices

    return Path(vertices, codes***REMOVED***
