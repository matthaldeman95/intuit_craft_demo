***REMOVED***
Defines classes for path effects. The path effects are supported in
:class:`~matplotlib.text.Text`, :class:`~matplotlib.lines.Line2D`
and :class:`~matplotlib.patches.Patch`.
***REMOVED***

from __future__ import (absolute_import, division, print_function,
                        unicode_literals***REMOVED***

from matplotlib.externals import six

from matplotlib.backend_bases import RendererBase
import matplotlib.transforms as mtransforms
from matplotlib.colors import colorConverter
import matplotlib.patches as mpatches


class AbstractPathEffect(object***REMOVED***:
    ***REMOVED***
    A base class for path effects.

    Subclasses should override the ``draw_path`` method to add effect
    functionality.

    ***REMOVED***
    def __init__(self, offset=(0., 0.***REMOVED******REMOVED***:
        ***REMOVED***
        Parameters
        ----------
        offset : pair of floats
            The offset to apply to the path, measured in points.
        ***REMOVED***
        self._offset = offset
        self._offset_trans = mtransforms.Affine2D(***REMOVED***

    def _offset_transform(self, renderer, transform***REMOVED***:
        ***REMOVED***Apply the offset to the given transform.***REMOVED***
        offset_x = renderer.points_to_pixels(self._offset[0***REMOVED******REMOVED***
        offset_y = renderer.points_to_pixels(self._offset[1***REMOVED******REMOVED***
        return transform + self._offset_trans.clear(***REMOVED***.translate(offset_x,
                                                                offset_y***REMOVED***

    def _update_gc(self, gc, new_gc_dict***REMOVED***:
        ***REMOVED***
        Update the given GraphicsCollection with the given
        dictionary of properties. The keys in the dictionary are used to
        identify the appropriate set_ method on the gc.

        ***REMOVED***
        new_gc_dict = new_gc_dict.copy(***REMOVED***

        dashes = new_gc_dict.pop("dashes", None***REMOVED***
        if dashes:
            gc.set_dashes(**dashes***REMOVED***

        for k, v in six.iteritems(new_gc_dict***REMOVED***:
            set_method = getattr(gc, 'set_' + k, None***REMOVED***
            if set_method is None or not six.callable(set_method***REMOVED***:
                raise AttributeError('Unknown property {0***REMOVED***'.format(k***REMOVED******REMOVED***
            set_method(v***REMOVED***
        return gc

    def draw_path(self, renderer, gc, tpath, affine, rgbFace=None***REMOVED***:
        ***REMOVED***
        Derived should override this method. The arguments are the same
        as :meth:`matplotlib.backend_bases.RendererBase.draw_path`
        except the first argument is a renderer.

        ***REMOVED***
        # Get the real renderer, not a PathEffectRenderer.
        if isinstance(renderer, PathEffectRenderer***REMOVED***:
            renderer = renderer._renderer
        return renderer.draw_path(gc, tpath, affine, rgbFace***REMOVED***


class PathEffectRenderer(RendererBase***REMOVED***:
    ***REMOVED***
    Implements a Renderer which contains another renderer.

    This proxy then intercepts draw calls, calling the appropriate
    :class:`AbstractPathEffect` draw method.

    .. note::
        Not all methods have been overridden on this RendererBase subclass.
        It may be necessary to add further methods to extend the PathEffects
        capabilities further.

    ***REMOVED***
    def __init__(self, path_effects, renderer***REMOVED***:
        ***REMOVED***
        Parameters
        ----------
        path_effects : iterable of :class:`AbstractPathEffect`
            The path effects which this renderer represents.
        renderer : :class:`matplotlib.backend_bases.RendererBase` instance

        ***REMOVED***
        self._path_effects = path_effects
        self._renderer = renderer

    def new_gc(self***REMOVED***:
        return self._renderer.new_gc(***REMOVED***

    def copy_with_path_effect(self, path_effects***REMOVED***:
        return self.__class__(path_effects, self._renderer***REMOVED***

    def draw_path(self, gc, tpath, affine, rgbFace=None***REMOVED***:
        for path_effect in self._path_effects:
            path_effect.draw_path(self._renderer, gc, tpath, affine,
                                  rgbFace***REMOVED***

    def draw_markers(self, gc, marker_path, marker_trans, path, *args,
                             **kwargs***REMOVED***:
        # We do a little shimmy so that all markers are drawn for each path
        # effect in turn. Essentially, we induce recursion (depth 1***REMOVED*** which is
        # terminated once we have just a single path effect to work with.
        if len(self._path_effects***REMOVED*** == 1:
            # Call the base path effect function - this uses the unoptimised
            # approach of calling "draw_path" multiple times.
            return RendererBase.draw_markers(self, gc, marker_path,
                                             marker_trans, path, *args,
                                             **kwargs***REMOVED***

        for path_effect in self._path_effects:
            renderer = self.copy_with_path_effect([path_effect***REMOVED******REMOVED***
            # Recursively call this method, only next time we will only have
            # one path effect.
            renderer.draw_markers(gc, marker_path, marker_trans, path,
                                  *args, **kwargs***REMOVED***

    def draw_path_collection(self, gc, master_transform, paths, *args,
                             **kwargs***REMOVED***:
        # We do a little shimmy so that all paths are drawn for each path
        # effect in turn. Essentially, we induce recursion (depth 1***REMOVED*** which is
        # terminated once we have just a single path effect to work with.
        if len(self._path_effects***REMOVED*** == 1:
            # Call the base path effect function - this uses the unoptimised
            # approach of calling "draw_path" multiple times.
            return RendererBase.draw_path_collection(self, gc,
                                                     master_transform, paths,
                                                     *args, **kwargs***REMOVED***

        for path_effect in self._path_effects:
            renderer = self.copy_with_path_effect([path_effect***REMOVED******REMOVED***
            # Recursively call this method, only next time we will only have
            # one path effect.
            renderer.draw_path_collection(gc, master_transform, paths,
                                          *args, **kwargs***REMOVED***

    def points_to_pixels(self, points***REMOVED***:
        return self._renderer.points_to_pixels(points***REMOVED***

    def _draw_text_as_path(self, gc, x, y, s, prop, angle, ismath***REMOVED***:
        # Implements the naive text drawing as is found in RendererBase.
        path, transform = self._get_text_path_transform(x, y, s, prop,
                                                        angle, ismath***REMOVED***
        color = gc.get_rgb(***REMOVED***
        gc.set_linewidth(0.0***REMOVED***
        self.draw_path(gc, path, transform, rgbFace=color***REMOVED***

    def __getattribute__(self, name***REMOVED***:
        if name in ['_text2path', 'flipy', 'height', 'width'***REMOVED***:
            return getattr(self._renderer, name***REMOVED***
        else:
            return object.__getattribute__(self, name***REMOVED***


class Normal(AbstractPathEffect***REMOVED***:
    ***REMOVED***
    The "identity" PathEffect.

    The Normal PathEffect's sole purpose is to draw the original artist with
    no special path effect.
    ***REMOVED***
    pass


class Stroke(AbstractPathEffect***REMOVED***:
    ***REMOVED***A line based PathEffect which re-draws a stroke.***REMOVED***
    def __init__(self, offset=(0, 0***REMOVED***, **kwargs***REMOVED***:
        ***REMOVED***
        The path will be stroked with its gc updated with the given
        keyword arguments, i.e., the keyword arguments should be valid
        gc parameter values.
        ***REMOVED***
        super(Stroke, self***REMOVED***.__init__(offset***REMOVED***
        self._gc = kwargs

    def draw_path(self, renderer, gc, tpath, affine, rgbFace***REMOVED***:
        ***REMOVED***
        draw the path with updated gc.
        ***REMOVED***
        # Do not modify the input! Use copy instead.

        gc0 = renderer.new_gc(***REMOVED***
        gc0.copy_properties(gc***REMOVED***

        gc0 = self._update_gc(gc0, self._gc***REMOVED***
        trans = self._offset_transform(renderer, affine***REMOVED***
        renderer.draw_path(gc0, tpath, trans, rgbFace***REMOVED***
        gc0.restore(***REMOVED***


class withStroke(Stroke***REMOVED***:
    ***REMOVED***
    Adds a simple :class:`Stroke` and then draws the
    original Artist to avoid needing to call :class:`Normal`.

    ***REMOVED***
    def draw_path(self, renderer, gc, tpath, affine, rgbFace***REMOVED***:
        Stroke.draw_path(self, renderer, gc, tpath, affine, rgbFace***REMOVED***
        renderer.draw_path(gc, tpath, affine, rgbFace***REMOVED***


class SimplePatchShadow(AbstractPathEffect***REMOVED***:
    ***REMOVED***A simple shadow via a filled patch.***REMOVED***
    def __init__(self, offset=(2, -2***REMOVED***,
                 shadow_rgbFace=None, alpha=None,
                 rho=0.3, **kwargs***REMOVED***:
        ***REMOVED***
        Parameters
        ----------
        offset : pair of floats
            The offset of the shadow in points.
        shadow_rgbFace : color
            The shadow color.
        alpha : float
            The alpha transparency of the created shadow patch.
            Default is 0.3.
            http://matplotlib.1069221.n5.nabble.com/path-effects-question-td27630.html
        rho : float
            A scale factor to apply to the rgbFace color if `shadow_rgbFace`
            is not specified. Default is 0.3.
        **kwargs
            Extra keywords are stored and passed through to
            :meth:`AbstractPathEffect._update_gc`.

        ***REMOVED***
        super(SimplePatchShadow, self***REMOVED***.__init__(offset***REMOVED***

        if shadow_rgbFace is None:
            self._shadow_rgbFace = shadow_rgbFace
        else:
            self._shadow_rgbFace = colorConverter.to_rgba(shadow_rgbFace***REMOVED***

        if alpha is None:
            alpha = 0.3

        self._alpha = alpha
        self._rho = rho

        #: The dictionary of keywords to update the graphics collection with.
        self._gc = kwargs

        #: The offset transform object. The offset isn't calculated yet
        #: as we don't know how big the figure will be in pixels.
        self._offset_tran = mtransforms.Affine2D(***REMOVED***

    def draw_path(self, renderer, gc, tpath, affine, rgbFace***REMOVED***:
        ***REMOVED***
        Overrides the standard draw_path to add the shadow offset and
        necessary color changes for the shadow.

        ***REMOVED***
        # IMPORTANT: Do not modify the input - we copy everything instead.
        affine0 = self._offset_transform(renderer, affine***REMOVED***
        gc0 = renderer.new_gc(***REMOVED***
        gc0.copy_properties(gc***REMOVED***

        if self._shadow_rgbFace is None:
            r,g,b = (rgbFace or (1., 1., 1.***REMOVED******REMOVED***[:3***REMOVED***
            # Scale the colors by a factor to improve the shadow effect.
            shadow_rgbFace = (r * self._rho, g * self._rho, b * self._rho***REMOVED***
        else:
            shadow_rgbFace = self._shadow_rgbFace

        gc0.set_foreground("none"***REMOVED***
        gc0.set_alpha(self._alpha***REMOVED***
        gc0.set_linewidth(0***REMOVED***

        gc0 = self._update_gc(gc0, self._gc***REMOVED***
        renderer.draw_path(gc0, tpath, affine0, shadow_rgbFace***REMOVED***
        gc0.restore(***REMOVED***


class withSimplePatchShadow(SimplePatchShadow***REMOVED***:
    ***REMOVED***
    Adds a simple :class:`SimplePatchShadow` and then draws the
    original Artist to avoid needing to call :class:`Normal`.

    ***REMOVED***
    def draw_path(self, renderer, gc, tpath, affine, rgbFace***REMOVED***:
        SimplePatchShadow.draw_path(self, renderer, gc, tpath, affine, rgbFace***REMOVED***
        renderer.draw_path(gc, tpath, affine, rgbFace***REMOVED***


class SimpleLineShadow(AbstractPathEffect***REMOVED***:
    ***REMOVED***A simple shadow via a line.***REMOVED***
    def __init__(self, offset=(2,-2***REMOVED***,
                 shadow_color='k', alpha=0.3, rho=0.3, **kwargs***REMOVED***:
        ***REMOVED***
        Parameters
        ----------
        offset : pair of floats
            The offset to apply to the path, in points.
        shadow_color : color
            The shadow color. Default is black.
            A value of ``None`` takes the original artist's color
            with a scale factor of `rho`.
        alpha : float
            The alpha transparency of the created shadow patch.
            Default is 0.3.
        rho : float
            A scale factor to apply to the rgbFace color if `shadow_rgbFace`
            is ``None``. Default is 0.3.
        **kwargs
            Extra keywords are stored and passed through to
            :meth:`AbstractPathEffect._update_gc`.

        ***REMOVED***
        super(SimpleLineShadow, self***REMOVED***.__init__(offset***REMOVED***
        if shadow_color is None:
            self._shadow_color = shadow_color
        else:
            self._shadow_color = colorConverter.to_rgba(shadow_color***REMOVED***
        self._alpha = alpha
        self._rho = rho

        #: The dictionary of keywords to update the graphics collection with.
        self._gc = kwargs

        #: The offset transform object. The offset isn't calculated yet
        #: as we don't know how big the figure will be in pixels.
        self._offset_tran = mtransforms.Affine2D(***REMOVED***

    def draw_path(self, renderer, gc, tpath, affine, rgbFace***REMOVED***:
        ***REMOVED***
        Overrides the standard draw_path to add the shadow offset and
        necessary color changes for the shadow.

        ***REMOVED***
        # IMPORTANT: Do not modify the input - we copy everything instead.
        affine0 = self._offset_transform(renderer, affine***REMOVED***
        gc0 = renderer.new_gc(***REMOVED***
        gc0.copy_properties(gc***REMOVED***

        if self._shadow_color is None:
            r,g,b = (gc0.get_foreground(***REMOVED*** or (1., 1., 1.***REMOVED******REMOVED***[:3***REMOVED***
            # Scale the colors by a factor to improve the shadow effect.
            shadow_rgbFace = (r * self._rho, g * self._rho, b * self._rho***REMOVED***
        else:
            shadow_rgbFace = self._shadow_color

        fill_color = None

        gc0.set_foreground(shadow_rgbFace***REMOVED***
        gc0.set_alpha(self._alpha***REMOVED***
        gc0.set_linestyle("solid"***REMOVED***

        gc0 = self._update_gc(gc0, self._gc***REMOVED***
        renderer.draw_path(gc0, tpath, affine0, fill_color***REMOVED***
        gc0.restore(***REMOVED***


class PathPatchEffect(AbstractPathEffect***REMOVED***:
    ***REMOVED***
    Draws a :class:`~matplotlib.patches.PathPatch` instance whose Path
    comes from the original PathEffect artist.

    ***REMOVED***
    def __init__(self, offset=(0, 0***REMOVED***, **kwargs***REMOVED***:
        ***REMOVED***
        Parameters
        ----------
        offset : pair of floats
            The offset to apply to the path, in points.
        **kwargs :
            All keyword arguments are passed through to the
            :class:`~matplotlib.patches.PathPatch` constructor. The
            properties which cannot be overridden are "path", "clip_box"
            "transform" and "clip_path".
        ***REMOVED***
        super(PathPatchEffect, self***REMOVED***.__init__(offset=offset***REMOVED***
        self.patch = mpatches.PathPatch([***REMOVED***, **kwargs***REMOVED***

    def draw_path(self, renderer, gc, tpath, affine, rgbFace***REMOVED***:
        affine = self._offset_transform(renderer, affine***REMOVED***
        self.patch._path = tpath
        self.patch.set_transform(affine***REMOVED***
        self.patch.set_clip_box(gc._cliprect***REMOVED***
        self.patch.set_clip_path(gc._clippath***REMOVED***
        self.patch.draw(renderer***REMOVED***
