from __future__ import (absolute_import, division, print_function,
                        unicode_literals***REMOVED***

from matplotlib.externals import six

import numpy as np
from .axes_divider import make_axes_locatable, Size, locatable_axes_factory
import sys
from .mpl_axes import Axes


def make_rgb_axes(ax, pad=0.01, axes_class=None, add_all=True***REMOVED***:
    ***REMOVED***
    pad : fraction of the axes height.
    ***REMOVED***

    divider = make_axes_locatable(ax***REMOVED***

    pad_size = Size.Fraction(pad, Size.AxesY(ax***REMOVED******REMOVED***

    xsize = Size.Fraction((1.-2.*pad***REMOVED***/3., Size.AxesX(ax***REMOVED******REMOVED***
    ysize = Size.Fraction((1.-2.*pad***REMOVED***/3., Size.AxesY(ax***REMOVED******REMOVED***

    divider.set_horizontal([Size.AxesX(ax***REMOVED***, pad_size, xsize***REMOVED******REMOVED***
    divider.set_vertical([ysize, pad_size, ysize, pad_size, ysize***REMOVED******REMOVED***

    ax.set_axes_locator(divider.new_locator(0, 0, ny1=-1***REMOVED******REMOVED***

    ax_rgb = [***REMOVED***
    if axes_class is None:
        ***REMOVED***
            axes_class = locatable_axes_factory(ax._axes_class***REMOVED***
        except AttributeError:
            axes_class = locatable_axes_factory(type(ax***REMOVED******REMOVED***

    for ny in [4, 2, 0***REMOVED***:
        ax1 = axes_class(ax.get_figure(***REMOVED***,
                         ax.get_position(original=True***REMOVED***,
                         sharex=ax, sharey=ax***REMOVED***
        locator = divider.new_locator(nx=2, ny=ny***REMOVED***
        ax1.set_axes_locator(locator***REMOVED***
        for t in ax1.yaxis.get_ticklabels(***REMOVED*** + ax1.xaxis.get_ticklabels(***REMOVED***:
            t.set_visible(False***REMOVED***
        ***REMOVED***
            for axis in ax1.axis.values(***REMOVED***:
                axis.major_ticklabels.set_visible(False***REMOVED***
        except AttributeError:
            pass

        ax_rgb.append(ax1***REMOVED***

    if add_all:
        fig = ax.get_figure(***REMOVED***
        for ax1 in ax_rgb:
            fig.add_axes(ax1***REMOVED***

    return ax_rgb


def imshow_rgb(ax, r, g, b, **kwargs***REMOVED***:
    ny, nx = r.shape
    R = np.zeros([ny, nx, 3***REMOVED***, dtype="d"***REMOVED***
    R[:,:,0***REMOVED*** = r
    G = np.zeros_like(R***REMOVED***
    G[:,:,1***REMOVED*** = g
    B = np.zeros_like(R***REMOVED***
    B[:,:,2***REMOVED*** = b

    RGB = R + G + B

    im_rgb = ax.imshow(RGB, **kwargs***REMOVED***

    return im_rgb


class RGBAxesBase(object***REMOVED***:
    ***REMOVED***base class for a 4-panel imshow (RGB, R, G, B***REMOVED***

    Layout:
    +---------------+-----+
    |               |  R  |
    +               +-----+
    |      RGB      |  G  |
    +               +-----+
    |               |  B  |
    +---------------+-----+

    Attributes
    ----------
    _defaultAxesClass : matplotlib.axes.Axes
        defaults to 'Axes' in RGBAxes child class.
        No default in abstract base class
    RGB : _defaultAxesClass
        The axes object for the three-channel imshow
    R : _defaultAxesClass
        The axes object for the red channel imshow
    G : _defaultAxesClass
        The axes object for the green channel imshow
    B : _defaultAxesClass
        The axes object for the blue channel imshow
    ***REMOVED***
    def __init__(self, *kl, **kwargs***REMOVED***:
        ***REMOVED***
        Parameters
        ----------
        pad : float
            fraction of the axes height to put as padding.
            defaults to 0.0
        add_all : bool
            True: Add the {rgb, r, g, b***REMOVED*** axes to the figure
            defaults to True.
        axes_class : matplotlib.axes.Axes

        kl :
            Unpacked into axes_class(***REMOVED*** init for RGB
        kwargs :
            Unpacked into axes_class(***REMOVED*** init for RGB, R, G, B axes
        ***REMOVED***
        pad = kwargs.pop("pad", 0.0***REMOVED***
        add_all = kwargs.pop("add_all", True***REMOVED***
        ***REMOVED***
            axes_class = kwargs.pop("axes_class", self._defaultAxesClass***REMOVED***
        except AttributeError:
            new_msg = ("A subclass of RGBAxesBase must have a "
                       "_defaultAxesClass attribute. If you are not sure which "
                       "axes class to use, consider using "
                       "mpl_toolkits.axes_grid1.mpl_axes.Axes."***REMOVED***
            six.reraise(AttributeError, AttributeError(new_msg***REMOVED***,
                        sys.exc_info(***REMOVED***[2***REMOVED******REMOVED***

        ax = axes_class(*kl, **kwargs***REMOVED***

        divider = make_axes_locatable(ax***REMOVED***

        pad_size = Size.Fraction(pad, Size.AxesY(ax***REMOVED******REMOVED***

        xsize = Size.Fraction((1.-2.*pad***REMOVED***/3., Size.AxesX(ax***REMOVED******REMOVED***
        ysize = Size.Fraction((1.-2.*pad***REMOVED***/3., Size.AxesY(ax***REMOVED******REMOVED***

        divider.set_horizontal([Size.AxesX(ax***REMOVED***, pad_size, xsize***REMOVED******REMOVED***
        divider.set_vertical([ysize, pad_size, ysize, pad_size, ysize***REMOVED******REMOVED***

        ax.set_axes_locator(divider.new_locator(0, 0, ny1=-1***REMOVED******REMOVED***

        ax_rgb = [***REMOVED***
        for ny in [4, 2, 0***REMOVED***:
            ax1 = axes_class(ax.get_figure(***REMOVED***,
                             ax.get_position(original=True***REMOVED***,
                             sharex=ax, sharey=ax, **kwargs***REMOVED***
            locator = divider.new_locator(nx=2, ny=ny***REMOVED***
            ax1.set_axes_locator(locator***REMOVED***
            ax1.axis[:***REMOVED***.toggle(ticklabels=False***REMOVED***
            ax_rgb.append(ax1***REMOVED***

        self.RGB = ax
        self.R, self.G, self.B = ax_rgb

        if add_all:
            fig = ax.get_figure(***REMOVED***
            fig.add_axes(ax***REMOVED***
            self.add_RGB_to_figure(***REMOVED***

        self._config_axes(***REMOVED***

    def _config_axes(self, line_color='w', marker_edge_color='w'***REMOVED***:
        ***REMOVED***Set the line color and ticks for the axes

        Parameters
        ----------
        line_color : any matplotlib color
        marker_edge_color : any matplotlib color
        ***REMOVED***
        for ax1 in [self.RGB, self.R, self.G, self.B***REMOVED***:
            ax1.axis[:***REMOVED***.line.set_color(line_color***REMOVED***
            ax1.axis[:***REMOVED***.major_ticks.set_markeredgecolor(marker_edge_color***REMOVED***

    def add_RGB_to_figure(self***REMOVED***:
        ***REMOVED***Add the red, green and blue axes to the RGB composite's axes figure
        ***REMOVED***
        self.RGB.get_figure(***REMOVED***.add_axes(self.R***REMOVED***
        self.RGB.get_figure(***REMOVED***.add_axes(self.G***REMOVED***
        self.RGB.get_figure(***REMOVED***.add_axes(self.B***REMOVED***

    def imshow_rgb(self, r, g, b, **kwargs***REMOVED***:
        ***REMOVED***Create the four images {rgb, r, g, b***REMOVED***

        Parameters
        ----------
        r : array-like
            The red array
        g : array-like
            The green array
        b : array-like
            The blue array
        kwargs : imshow kwargs
            kwargs get unpacked into the imshow calls for the four images

        Returns
        -------
        rgb : matplotlib.image.AxesImage
        r : matplotlib.image.AxesImage
        g : matplotlib.image.AxesImage
        b : matplotlib.image.AxesImage
        ***REMOVED***
        ny, nx = r.shape
        if not ((nx, ny***REMOVED*** == g.shape == b.shape***REMOVED***:
            raise ValueError('Input shapes do not match.'
                             '\nr.shape = {0***REMOVED***'
                             '\ng.shape = {1***REMOVED***'
                             '\nb.shape = {2***REMOVED***'
                             ''.format(r.shape, g.shape, b.shape***REMOVED******REMOVED***

        R = np.zeros([ny, nx, 3***REMOVED***, dtype="d"***REMOVED***
        R[:,:,0***REMOVED*** = r
        G = np.zeros_like(R***REMOVED***
        G[:,:,1***REMOVED*** = g
        B = np.zeros_like(R***REMOVED***
        B[:,:,2***REMOVED*** = b

        RGB = R + G + B

        im_rgb = self.RGB.imshow(RGB, **kwargs***REMOVED***
        im_r = self.R.imshow(R, **kwargs***REMOVED***
        im_g = self.G.imshow(G, **kwargs***REMOVED***
        im_b = self.B.imshow(B, **kwargs***REMOVED***

        return im_rgb, im_r, im_g, im_b


class RGBAxes(RGBAxesBase***REMOVED***:
    _defaultAxesClass = Axes
