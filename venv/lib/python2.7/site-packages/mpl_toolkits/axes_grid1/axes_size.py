
***REMOVED***
provides a classes of simple units that will be used with AxesDivider
class (or others***REMOVED*** to determine the size of each axes. The unit
classes define `get_size` method that returns a tuple of two floats,
meaning relative and absolute sizes, respectively.

Note that this class is nothing more than a simple tuple of two
floats. Take a look at the Divider class to see how these two
values are used.

***REMOVED***
from __future__ import (absolute_import, division, print_function,
                        unicode_literals***REMOVED***

from matplotlib.externals import six

import matplotlib.cbook as cbook
from matplotlib.axes import Axes

class _Base(object***REMOVED***:
    "Base class"

    def __rmul__(self, other***REMOVED***:
        float(other***REMOVED*** # just to check if number if given
        return Fraction(other, self***REMOVED***

    def __add__(self, other***REMOVED***:
        if isinstance(other, _Base***REMOVED***:
            return Add(self, other***REMOVED***
        else:
            float(other***REMOVED***
            other = Fixed(other***REMOVED***
            return Add(self, other***REMOVED***


class Add(_Base***REMOVED***:
    def __init__(self, a, b***REMOVED***:
        self._a = a
        self._b = b

    def get_size(self, renderer***REMOVED***:
        a_rel_size, a_abs_size = self._a.get_size(renderer***REMOVED***
        b_rel_size, b_abs_size = self._b.get_size(renderer***REMOVED***
        return a_rel_size + b_rel_size, a_abs_size + b_abs_size

class AddList(_Base***REMOVED***:
    def __init__(self, add_list***REMOVED***:
        self._list = add_list

    def get_size(self, renderer***REMOVED***:
        sum_rel_size = sum([a.get_size(renderer***REMOVED***[0***REMOVED*** for a in self._list***REMOVED******REMOVED***
        sum_abs_size = sum([a.get_size(renderer***REMOVED***[1***REMOVED*** for a in self._list***REMOVED******REMOVED***
        return sum_rel_size, sum_abs_size


class Fixed(_Base***REMOVED***:
    "Simple fixed size  with absolute part = *fixed_size* and relative part = 0"
    def __init__(self, fixed_size***REMOVED***:
        self.fixed_size = fixed_size

    def get_size(self, renderer***REMOVED***:
        rel_size = 0.
        abs_size = self.fixed_size
        return rel_size, abs_size


class Scaled(_Base***REMOVED***:
    "Simple scaled(?***REMOVED*** size with absolute part = 0 and relative part = *scalable_size*"
    def __init__(self, scalable_size***REMOVED***:
        self._scalable_size = scalable_size

    def get_size(self, renderer***REMOVED***:
        rel_size = self._scalable_size
        abs_size = 0.
        return rel_size, abs_size

Scalable=Scaled

def _get_axes_aspect(ax***REMOVED***:
    aspect = ax.get_aspect(***REMOVED***
    # when aspec is "auto", consider it as 1.
    if aspect in ('normal', 'auto'***REMOVED***:
        aspect = 1.
    elif aspect == "equal":
        aspect = 1
    else:
        aspect = float(aspect***REMOVED***

    return aspect

class AxesX(_Base***REMOVED***:
    ***REMOVED***
    Scaled size whose relative part corresponds to the data width
    of the *axes* multiplied by the *aspect*.
    ***REMOVED***
    def __init__(self, axes, aspect=1., ref_ax=None***REMOVED***:
        self._axes = axes
        self._aspect = aspect
        if aspect == "axes" and ref_ax is None:
            raise ValueError("ref_ax must be set when aspect='axes'"***REMOVED***
        self._ref_ax = ref_ax

    def get_size(self, renderer***REMOVED***:
        l1, l2 = self._axes.get_xlim(***REMOVED***
        if self._aspect == "axes":
            ref_aspect = _get_axes_aspect(self._ref_ax***REMOVED***
            aspect = ref_aspect/_get_axes_aspect(self._axes***REMOVED***
        else:
            aspect = self._aspect

        rel_size = abs(l2-l1***REMOVED****aspect
        abs_size = 0.
        return rel_size, abs_size

class AxesY(_Base***REMOVED***:
    ***REMOVED***
    Scaled size whose relative part corresponds to the data height
    of the *axes* multiplied by the *aspect*.
    ***REMOVED***
    def __init__(self, axes, aspect=1., ref_ax=None***REMOVED***:
        self._axes = axes
        self._aspect = aspect
        if aspect == "axes" and ref_ax is None:
            raise ValueError("ref_ax must be set when aspect='axes'"***REMOVED***
        self._ref_ax = ref_ax

    def get_size(self, renderer***REMOVED***:
        l1, l2 = self._axes.get_ylim(***REMOVED***

        if self._aspect == "axes":
            ref_aspect = _get_axes_aspect(self._ref_ax***REMOVED***
            aspect = _get_axes_aspect(self._axes***REMOVED***
        else:
            aspect = self._aspect

        rel_size = abs(l2-l1***REMOVED****aspect
        abs_size = 0.
        return rel_size, abs_size


class MaxExtent(_Base***REMOVED***:
    ***REMOVED***
    Size whose absolute part is the largest width (or height***REMOVED*** of
    the given *artist_list*.
    ***REMOVED***
    def __init__(self, artist_list, w_or_h***REMOVED***:
        self._artist_list = artist_list

        if w_or_h not in ["width", "height"***REMOVED***:
            raise ValueError(***REMOVED***

        self._w_or_h = w_or_h

    def add_artist(self, a***REMOVED***:
        self._artist_list.append(a***REMOVED***

    def get_size(self, renderer***REMOVED***:
        rel_size = 0.
        w_list, h_list = [***REMOVED***, [***REMOVED***
        for a in self._artist_list:
            bb = a.get_window_extent(renderer***REMOVED***
            w_list.append(bb.width***REMOVED***
            h_list.append(bb.height***REMOVED***
        dpi = a.get_figure(***REMOVED***.get_dpi(***REMOVED***
        if self._w_or_h == "width":
            abs_size = max(w_list***REMOVED***/dpi
        elif self._w_or_h == "height":
            abs_size = max(h_list***REMOVED***/dpi

        return rel_size, abs_size


class MaxWidth(_Base***REMOVED***:
    ***REMOVED***
    Size whose absolute part is the largest width of
    the given *artist_list*.
    ***REMOVED***
    def __init__(self, artist_list***REMOVED***:
        self._artist_list = artist_list

    def add_artist(self, a***REMOVED***:
        self._artist_list.append(a***REMOVED***

    def get_size(self, renderer***REMOVED***:
        rel_size = 0.
        w_list = [***REMOVED***
        for a in self._artist_list:
            bb = a.get_window_extent(renderer***REMOVED***
            w_list.append(bb.width***REMOVED***
        dpi = a.get_figure(***REMOVED***.get_dpi(***REMOVED***
        abs_size = max(w_list***REMOVED***/dpi

        return rel_size, abs_size



class MaxHeight(_Base***REMOVED***:
    ***REMOVED***
    Size whose absolute part is the largest height of
    the given *artist_list*.
    ***REMOVED***
    def __init__(self, artist_list***REMOVED***:
        self._artist_list = artist_list

    def add_artist(self, a***REMOVED***:
        self._artist_list.append(a***REMOVED***

    def get_size(self, renderer***REMOVED***:
        rel_size = 0.
        h_list = [***REMOVED***
        for a in self._artist_list:
            bb = a.get_window_extent(renderer***REMOVED***
            h_list.append(bb.height***REMOVED***
        dpi = a.get_figure(***REMOVED***.get_dpi(***REMOVED***
        abs_size = max(h_list***REMOVED***/dpi

        return rel_size, abs_size


class Fraction(_Base***REMOVED***:
    ***REMOVED***
    An instance whose size is a *fraction* of the *ref_size*.
    ::

      >>> s = Fraction(0.3, AxesX(ax***REMOVED******REMOVED***

    ***REMOVED***
    def __init__(self, fraction, ref_size***REMOVED***:
        self._fraction_ref = ref_size
        self._fraction = fraction

    def get_size(self, renderer***REMOVED***:
        if self._fraction_ref is None:
            return self._fraction, 0.
        else:
            r, a = self._fraction_ref.get_size(renderer***REMOVED***
            rel_size = r*self._fraction
            abs_size = a*self._fraction
            return rel_size, abs_size

class Padded(_Base***REMOVED***:
    ***REMOVED***
    Return a instance where the absolute part of *size* is
    increase by the amount of *pad*.
    ***REMOVED***
    def __init__(self, size, pad***REMOVED***:
        self._size = size
        self._pad = pad

    def get_size(self, renderer***REMOVED***:
        r, a = self._size.get_size(renderer***REMOVED***
        rel_size = r
        abs_size = a + self._pad
        return rel_size, abs_size

def from_any(size, fraction_ref=None***REMOVED***:
    ***REMOVED***
    Creates Fixed unit when the first argument is a float, or a
    Fraction unit if that is a string that ends with %. The second
    argument is only meaningful when Fraction unit is created.::

      >>> a = Size.from_any(1.2***REMOVED*** # => Size.Fixed(1.2***REMOVED***
      >>> Size.from_any("50%", a***REMOVED*** # => Size.Fraction(0.5, a***REMOVED***

    ***REMOVED***
    if cbook.is_numlike(size***REMOVED***:
        return Fixed(size***REMOVED***
    elif cbook.is_string_like(size***REMOVED***:
        if size[-1***REMOVED*** == "%":
            return Fraction(float(size[:-1***REMOVED******REMOVED***/100., fraction_ref***REMOVED***

    raise ValueError("Unknown format"***REMOVED***


class SizeFromFunc(_Base***REMOVED***:
    def __init__(self, func***REMOVED***:
        self._func = func

    def get_size(self, renderer***REMOVED***:
        rel_size = 0.

        bb = self._func(renderer***REMOVED***
        dpi = renderer.points_to_pixels(72.***REMOVED***
        abs_size = bb/dpi

        return rel_size, abs_size

class GetExtentHelper(object***REMOVED***:
    def _get_left(tight_bbox, axes_bbox***REMOVED***:
        return axes_bbox.xmin - tight_bbox.xmin

    def _get_right(tight_bbox, axes_bbox***REMOVED***:
        return tight_bbox.xmax - axes_bbox.xmax

    def _get_bottom(tight_bbox, axes_bbox***REMOVED***:
        return axes_bbox.ymin - tight_bbox.ymin

    def _get_top(tight_bbox, axes_bbox***REMOVED***:
        return tight_bbox.ymax - axes_bbox.ymax

    _get_func_map = dict(left=_get_left,
                         right=_get_right,
                         bottom=_get_bottom,
                         top=_get_top***REMOVED***

    del _get_left, _get_right, _get_bottom, _get_top

    def __init__(self, ax, direction***REMOVED***:
        if isinstance(ax, Axes***REMOVED***:
            self._ax_list = [ax***REMOVED***
        else:
            self._ax_list = ax

        ***REMOVED***
            self._get_func = self._get_func_map[direction***REMOVED***
        except KeyError:
            raise KeyError("direction must be one of left, right, bottom, top"***REMOVED***

    def __call__(self, renderer***REMOVED***:
        vl = [self._get_func(ax.get_tightbbox(renderer, False***REMOVED***,
                             ax.bbox***REMOVED*** for ax in self._ax_list***REMOVED***
        return max(vl***REMOVED***
