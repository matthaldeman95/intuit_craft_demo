from __future__ import (absolute_import, division, print_function,
                        unicode_literals***REMOVED***

from matplotlib.externals import six

import warnings

import matplotlib
rcParams = matplotlib.rcParams
import matplotlib.artist as martist
import matplotlib.transforms as mtransforms
import matplotlib.collections as mcoll
import matplotlib.legend as mlegend

from matplotlib.axes import subplot_class_factory
from .mpl_axes import Axes

from matplotlib.transforms import Bbox

import numpy as np

import matplotlib.cbook as cbook
is_string_like = cbook.is_string_like


class ParasiteAxesBase(object***REMOVED***:

    def get_images_artists(self***REMOVED***:
        artists = set([a for a in self.get_children(***REMOVED*** if a.get_visible(***REMOVED******REMOVED******REMOVED***
        images = set([a for a in self.images if a.get_visible(***REMOVED******REMOVED******REMOVED***

        return list(images***REMOVED***, list(artists - images***REMOVED***

    def __init__(self, parent_axes, **kargs***REMOVED***:

        self._parent_axes = parent_axes
        kargs.update(dict(frameon=False***REMOVED******REMOVED***
        self._get_base_axes_attr("__init__"***REMOVED***(self, parent_axes.figure,
                                        parent_axes._position, **kargs***REMOVED***

    def cla(self***REMOVED***:
        self._get_base_axes_attr("cla"***REMOVED***(self***REMOVED***

        martist.setp(self.get_children(***REMOVED***, visible=False***REMOVED***
        self._get_lines = self._parent_axes._get_lines

        # In mpl's Axes, zorders of x- and y-axis are originally set
        # within Axes.draw(***REMOVED***.
        if self._axisbelow:
            self.xaxis.set_zorder(0.5***REMOVED***
            self.yaxis.set_zorder(0.5***REMOVED***
        else:
            self.xaxis.set_zorder(2.5***REMOVED***
            self.yaxis.set_zorder(2.5***REMOVED***


_parasite_axes_classes = {***REMOVED***
def parasite_axes_class_factory(axes_class=None***REMOVED***:
    if axes_class is None:
        axes_class = Axes

    new_class = _parasite_axes_classes.get(axes_class***REMOVED***
    if new_class is None:
        def _get_base_axes_attr(self, attrname***REMOVED***:
            return getattr(axes_class, attrname***REMOVED***

        new_class = type(str("%sParasite" % (axes_class.__name__***REMOVED******REMOVED***,
                         (ParasiteAxesBase, axes_class***REMOVED***,
                     ***REMOVED***'_get_base_axes_attr': _get_base_axes_attr***REMOVED******REMOVED***
        _parasite_axes_classes[axes_class***REMOVED*** = new_class

    return new_class

ParasiteAxes = parasite_axes_class_factory(***REMOVED***

# #class ParasiteAxes(ParasiteAxesBase, Axes***REMOVED***:

#     @classmethod
#     def _get_base_axes_attr(cls, attrname***REMOVED***:
#         return getattr(Axes, attrname***REMOVED***



class ParasiteAxesAuxTransBase(object***REMOVED***:
    def __init__(self, parent_axes, aux_transform, viewlim_mode=None,
                 **kwargs***REMOVED***:

        self.transAux = aux_transform
        self.set_viewlim_mode(viewlim_mode***REMOVED***

        self._parasite_axes_class.__init__(self, parent_axes, **kwargs***REMOVED***

    def _set_lim_and_transforms(self***REMOVED***:

        self.transAxes = self._parent_axes.transAxes

        self.transData = \
            self.transAux + \
            self._parent_axes.transData

        self._xaxis_transform = mtransforms.blended_transform_factory(
                self.transData, self.transAxes***REMOVED***
        self._yaxis_transform = mtransforms.blended_transform_factory(
                self.transAxes, self.transData***REMOVED***

    def set_viewlim_mode(self, mode***REMOVED***:
        if mode not in [None, "equal", "transform"***REMOVED***:
            raise ValueError("Unknown mode : %s" % (mode,***REMOVED******REMOVED***
        else:
            self._viewlim_mode = mode

    def get_viewlim_mode(self***REMOVED***:
        return self._viewlim_mode


    def update_viewlim(self***REMOVED***:
        viewlim = self._parent_axes.viewLim.frozen(***REMOVED***
        mode = self.get_viewlim_mode(***REMOVED***
        if mode is None:
            pass
        elif mode == "equal":
            self.axes.viewLim.set(viewlim***REMOVED***
        elif mode == "transform":
            self.axes.viewLim.set(viewlim.transformed(self.transAux.inverted(***REMOVED******REMOVED******REMOVED***
        else:
            raise ValueError("Unknown mode : %s" % (self._viewlim_mode,***REMOVED******REMOVED***


    def _pcolor(self, method_name, *XYC, **kwargs***REMOVED***:
        if len(XYC***REMOVED*** == 1:
            C = XYC[0***REMOVED***
            ny, nx = C.shape

            gx = np.arange(-0.5, nx, 1.***REMOVED***
            gy = np.arange(-0.5, ny, 1.***REMOVED***

            X, Y = np.meshgrid(gx, gy***REMOVED***
        else:
            X, Y, C = XYC

        pcolor_routine = self._get_base_axes_attr(method_name***REMOVED***

        if "transform" in kwargs:
            mesh = pcolor_routine(self, X, Y, C, **kwargs***REMOVED***
        else:
            orig_shape = X.shape
            xy = np.vstack([X.flat, Y.flat***REMOVED******REMOVED***
            xyt=xy.transpose(***REMOVED***
            wxy = self.transAux.transform(xyt***REMOVED***
            gx, gy = wxy[:,0***REMOVED***.reshape(orig_shape***REMOVED***, wxy[:,1***REMOVED***.reshape(orig_shape***REMOVED***
            mesh = pcolor_routine(self, gx, gy, C, **kwargs***REMOVED***
            mesh.set_transform(self._parent_axes.transData***REMOVED***

        return mesh

    def pcolormesh(self, *XYC, **kwargs***REMOVED***:
        return self._pcolor("pcolormesh", *XYC, **kwargs***REMOVED***

    def pcolor(self, *XYC, **kwargs***REMOVED***:
        return self._pcolor("pcolor", *XYC, **kwargs***REMOVED***


    def _contour(self, method_name, *XYCL, **kwargs***REMOVED***:

        if len(XYCL***REMOVED*** <= 2:
            C = XYCL[0***REMOVED***
            ny, nx = C.shape

            gx = np.arange(0., nx, 1.***REMOVED***
            gy = np.arange(0., ny, 1.***REMOVED***

            X,Y = np.meshgrid(gx, gy***REMOVED***
            CL = XYCL
        else:
            X, Y = XYCL[:2***REMOVED***
            CL = XYCL[2:***REMOVED***

        contour_routine = self._get_base_axes_attr(method_name***REMOVED***

        if "transform" in kwargs:
            cont = contour_routine(self, X, Y, *CL, **kwargs***REMOVED***
        else:
            orig_shape = X.shape
            xy = np.vstack([X.flat, Y.flat***REMOVED******REMOVED***
            xyt=xy.transpose(***REMOVED***
            wxy = self.transAux.transform(xyt***REMOVED***
            gx, gy = wxy[:,0***REMOVED***.reshape(orig_shape***REMOVED***, wxy[:,1***REMOVED***.reshape(orig_shape***REMOVED***
            cont = contour_routine(self, gx, gy, *CL, **kwargs***REMOVED***
            for c in cont.collections:
                c.set_transform(self._parent_axes.transData***REMOVED***

        return cont

    def contour(self, *XYCL, **kwargs***REMOVED***:
        return self._contour("contour", *XYCL, **kwargs***REMOVED***

    def contourf(self, *XYCL, **kwargs***REMOVED***:
        return self._contour("contourf", *XYCL, **kwargs***REMOVED***

    def apply_aspect(self, position=None***REMOVED***:
        self.update_viewlim(***REMOVED***
        self._get_base_axes_attr("apply_aspect"***REMOVED***(self***REMOVED***
        #ParasiteAxes.apply_aspect(***REMOVED***



_parasite_axes_auxtrans_classes = {***REMOVED***
def parasite_axes_auxtrans_class_factory(axes_class=None***REMOVED***:
    if axes_class is None:
        parasite_axes_class = ParasiteAxes
    elif not issubclass(axes_class, ParasiteAxesBase***REMOVED***:
        parasite_axes_class = parasite_axes_class_factory(axes_class***REMOVED***
    else:
        parasite_axes_class = axes_class

    new_class = _parasite_axes_auxtrans_classes.get(parasite_axes_class***REMOVED***
    if new_class is None:
        new_class = type(str("%sParasiteAuxTrans" % (parasite_axes_class.__name__***REMOVED******REMOVED***,
                         (ParasiteAxesAuxTransBase, parasite_axes_class***REMOVED***,
                     ***REMOVED***'_parasite_axes_class': parasite_axes_class,
                         'name': 'parasite_axes'***REMOVED******REMOVED***
        _parasite_axes_auxtrans_classes[parasite_axes_class***REMOVED*** = new_class

    return new_class


ParasiteAxesAuxTrans = parasite_axes_auxtrans_class_factory(axes_class=ParasiteAxes***REMOVED***




def _get_handles(ax***REMOVED***:
    handles = ax.lines[:***REMOVED***
    handles.extend(ax.patches***REMOVED***
    handles.extend([c for c in ax.collections
                    if isinstance(c, mcoll.LineCollection***REMOVED******REMOVED******REMOVED***
    handles.extend([c for c in ax.collections
                    if isinstance(c, mcoll.RegularPolyCollection***REMOVED******REMOVED******REMOVED***
    handles.extend([c for c in ax.collections
                    if isinstance(c, mcoll.CircleCollection***REMOVED******REMOVED******REMOVED***

    return handles


class HostAxesBase(object***REMOVED***:
    def __init__(self, *args, **kwargs***REMOVED***:

        self.parasites = [***REMOVED***
        self._get_base_axes_attr("__init__"***REMOVED***(self, *args, **kwargs***REMOVED***


    def get_aux_axes(self, tr, viewlim_mode="equal", axes_class=None***REMOVED***:
        parasite_axes_class = parasite_axes_auxtrans_class_factory(axes_class***REMOVED***
        ax2 = parasite_axes_class(self, tr, viewlim_mode***REMOVED***
        # note that ax2.transData == tr + ax1.transData
        # Anthing you draw in ax2 will match the ticks and grids of ax1.
        self.parasites.append(ax2***REMOVED***
        return ax2


    def _get_legend_handles(self, legend_handler_map=None***REMOVED***:
        Axes_get_legend_handles = self._get_base_axes_attr("_get_legend_handles"***REMOVED***
        all_handles = list(Axes_get_legend_handles(self, legend_handler_map***REMOVED******REMOVED***

        for ax in self.parasites:
            all_handles.extend(ax._get_legend_handles(legend_handler_map***REMOVED******REMOVED***

        return all_handles


    def draw(self, renderer***REMOVED***:

        orig_artists = list(self.artists***REMOVED***
        orig_images = list(self.images***REMOVED***

        if hasattr(self, "get_axes_locator"***REMOVED***:
            locator = self.get_axes_locator(***REMOVED***
            if locator:
                pos = locator(self, renderer***REMOVED***
                self.set_position(pos, which="active"***REMOVED***
                self.apply_aspect(pos***REMOVED***
            else:
                self.apply_aspect(***REMOVED***
        else:
            self.apply_aspect(***REMOVED***

        rect = self.get_position(***REMOVED***

        for ax in self.parasites:
            ax.apply_aspect(rect***REMOVED***
            images, artists = ax.get_images_artists(***REMOVED***
            self.images.extend(images***REMOVED***
            self.artists.extend(artists***REMOVED***

        self._get_base_axes_attr("draw"***REMOVED***(self, renderer***REMOVED***
        self.artists = orig_artists
        self.images = orig_images


    def cla(self***REMOVED***:

        for ax in self.parasites:
            ax.cla(***REMOVED***

        self._get_base_axes_attr("cla"***REMOVED***(self***REMOVED***
        #super(HostAxes, self***REMOVED***.cla(***REMOVED***


    def twinx(self, axes_class=None***REMOVED***:
        ***REMOVED***
        call signature::

          ax2 = ax.twinx(***REMOVED***

        create a twin of Axes for generating a plot with a sharex
        x-axis but independent y axis.  The y-axis of self will have
        ticks on left and the returned axes will have ticks on the
        right
        ***REMOVED***

        if axes_class is None:
            axes_class = self._get_base_axes(***REMOVED***

        parasite_axes_class = parasite_axes_class_factory(axes_class***REMOVED***

        ax2 = parasite_axes_class(self, sharex=self, frameon=False***REMOVED***
        self.parasites.append(ax2***REMOVED***

        # for normal axes

        self.axis["right"***REMOVED***.toggle(all=False***REMOVED***
        self.axis["right"***REMOVED***.line.set_visible(True***REMOVED***

        ax2.axis["right"***REMOVED***.set_visible(True***REMOVED***
        ax2.axis["left","top", "bottom"***REMOVED***.toggle(all=False***REMOVED***
        ax2.axis["left","top", "bottom"***REMOVED***.line.set_visible(False***REMOVED***

        ax2.axis["right"***REMOVED***.toggle(all=True***REMOVED***
        ax2.axis["right"***REMOVED***.line.set_visible(False***REMOVED***

        return ax2

    def twiny(self, axes_class=None***REMOVED***:
        ***REMOVED***
        call signature::

          ax2 = ax.twiny(***REMOVED***

        create a twin of Axes for generating a plot with a shared
        y-axis but independent x axis.  The x-axis of self will have
        ticks on bottom and the returned axes will have ticks on the
        top
        ***REMOVED***

        if axes_class is None:
            axes_class = self._get_base_axes(***REMOVED***

        parasite_axes_class = parasite_axes_class_factory(axes_class***REMOVED***

        ax2 = parasite_axes_class(self, sharey=self, frameon=False***REMOVED***
        self.parasites.append(ax2***REMOVED***

        self.axis["top"***REMOVED***.toggle(all=False***REMOVED***
        self.axis["top"***REMOVED***.line.set_visible(True***REMOVED***

        ax2.axis["top"***REMOVED***.set_visible(True***REMOVED***
        ax2.axis["left","right", "bottom"***REMOVED***.toggle(all=False***REMOVED***
        ax2.axis["left","right", "bottom"***REMOVED***.line.set_visible(False***REMOVED***

        ax2.axis["top"***REMOVED***.toggle(all=True***REMOVED***
        ax2.axis["top"***REMOVED***.line.set_visible(False***REMOVED***

        return ax2


    def twin(self, aux_trans=None, axes_class=None***REMOVED***:
        ***REMOVED***
        call signature::

          ax2 = ax.twin(***REMOVED***

        create a twin of Axes for generating a plot with a sharex
        x-axis but independent y axis.  The y-axis of self will have
        ticks on left and the returned axes will have ticks on the
        right
        ***REMOVED***

        if axes_class is None:
            axes_class = self._get_base_axes(***REMOVED***

        parasite_axes_auxtrans_class = parasite_axes_auxtrans_class_factory(axes_class***REMOVED***

        if aux_trans is None:
            ax2 = parasite_axes_auxtrans_class(self, mtransforms.IdentityTransform(***REMOVED***,
                                               viewlim_mode="equal",
                                               ***REMOVED***
        else:
            ax2 = parasite_axes_auxtrans_class(self, aux_trans,
                                               viewlim_mode="transform",
                                               ***REMOVED***
        self.parasites.append(ax2***REMOVED***


        # for normal axes
        #self.yaxis.tick_left(***REMOVED***
        #self.xaxis.tick_bottom(***REMOVED***
        #ax2.yaxis.tick_right(***REMOVED***
        #ax2.xaxis.set_visible(True***REMOVED***
        #ax2.yaxis.set_visible(True***REMOVED***

        #ax2.yaxis.set_label_position('right'***REMOVED***
        ##ax2.xaxis.tick_top(***REMOVED***
        #ax2.xaxis.set_label_position('top'***REMOVED***


        self.axis["top","right"***REMOVED***.toggle(all=False***REMOVED***
        self.axis["top","right"***REMOVED***.line.set_visible(False***REMOVED***
        #self.axis["left","bottom"***REMOVED***.toggle(label=True***REMOVED***

        ax2.axis["top","right"***REMOVED***.set_visible(True***REMOVED***

        ax2.axis["bottom","left"***REMOVED***.toggle(all=False***REMOVED***
        ax2.axis["bottom","left"***REMOVED***.line.set_visible(False***REMOVED***

        ax2.axis["top","right"***REMOVED***.toggle(all=True***REMOVED***
        ax2.axis["top","right"***REMOVED***.line.set_visible(True***REMOVED***


        # # for axisline axes
        # self._axislines["right"***REMOVED***.set_visible(False***REMOVED***
        # self._axislines["top"***REMOVED***.set_visible(False***REMOVED***
        # ax2._axislines["left"***REMOVED***.set_visible(False***REMOVED***
        # ax2._axislines["bottom"***REMOVED***.set_visible(False***REMOVED***

        # ax2._axislines["right"***REMOVED***.set_visible(True***REMOVED***
        # ax2._axislines["top"***REMOVED***.set_visible(True***REMOVED***
        # ax2._axislines["right"***REMOVED***.major_ticklabels.set_visible(True***REMOVED***
        # ax2._axislines["top"***REMOVED***.major_ticklabels.set_visible(True***REMOVED***

        return ax2

    def get_tightbbox(self, renderer, call_axes_locator=True***REMOVED***:

        bbs = [ax.get_tightbbox(renderer, call_axes_locator***REMOVED*** \
               for ax in self.parasites***REMOVED***
        get_tightbbox = self._get_base_axes_attr("get_tightbbox"***REMOVED***
        bbs.append(get_tightbbox(self, renderer, call_axes_locator***REMOVED******REMOVED***

        _bbox = Bbox.union([b for b in bbs if b.width!=0 or b.height!=0***REMOVED******REMOVED***

        return _bbox



_host_axes_classes = {***REMOVED***
def host_axes_class_factory(axes_class=None***REMOVED***:
    if axes_class is None:
        axes_class = Axes

    new_class = _host_axes_classes.get(axes_class***REMOVED***
    if new_class is None:
        def _get_base_axes(self***REMOVED***:
            return axes_class

        def _get_base_axes_attr(self, attrname***REMOVED***:
            return getattr(axes_class, attrname***REMOVED***

        new_class = type(str("%sHostAxes" % (axes_class.__name__***REMOVED******REMOVED***,
                         (HostAxesBase, axes_class***REMOVED***,
                     ***REMOVED***'_get_base_axes_attr': _get_base_axes_attr,
                          '_get_base_axes': _get_base_axes***REMOVED******REMOVED***

        _host_axes_classes[axes_class***REMOVED*** = new_class

    return new_class

def host_subplot_class_factory(axes_class***REMOVED***:
    host_axes_class = host_axes_class_factory(axes_class=axes_class***REMOVED***
    subplot_host_class = subplot_class_factory(host_axes_class***REMOVED***
    return subplot_host_class

HostAxes = host_axes_class_factory(axes_class=Axes***REMOVED***
SubplotHost = subplot_class_factory(HostAxes***REMOVED***


def host_axes(*args, **kwargs***REMOVED***:
    import matplotlib.pyplot as plt
    axes_class = kwargs.pop("axes_class", None***REMOVED***
    host_axes_class = host_axes_class_factory(axes_class***REMOVED***
    fig = plt.gcf(***REMOVED***
    ax = host_axes_class(fig, *args, **kwargs***REMOVED***
    fig.add_axes(ax***REMOVED***
    plt.draw_if_interactive(***REMOVED***
    return ax

def host_subplot(*args, **kwargs***REMOVED***:
    import matplotlib.pyplot as plt
    axes_class = kwargs.pop("axes_class", None***REMOVED***
    host_subplot_class = host_subplot_class_factory(axes_class***REMOVED***
    fig = plt.gcf(***REMOVED***
    ax = host_subplot_class(fig, *args, **kwargs***REMOVED***
    fig.add_subplot(ax***REMOVED***
    plt.draw_if_interactive(***REMOVED***
    return ax
