from __future__ import (absolute_import, division, print_function,
                        unicode_literals***REMOVED***

from matplotlib.externals import six

import matplotlib.cbook as cbook

import matplotlib.axes as maxes
#import matplotlib.colorbar as mcolorbar
from . import colorbar as mcolorbar
import matplotlib as mpl
import matplotlib.patches as mpatches
import matplotlib.lines as mlines
import matplotlib.ticker as ticker

from matplotlib.gridspec import SubplotSpec

from .axes_divider import Size, SubplotDivider, LocatableAxes, Divider


def _extend_axes_pad(value***REMOVED***:
    # Check whether a list/tuple/array or scalar has been passed
    ret = value
    if not hasattr(ret, "__getitem__"***REMOVED***:
        ret = (value, value***REMOVED***
    return ret


def _tick_only(ax, bottom_on, left_on***REMOVED***:
    bottom_off = not bottom_on
    left_off = not left_on
    # [l.set_visible(bottom_off***REMOVED*** for l in ax.get_xticklabels(***REMOVED******REMOVED***
    # [l.set_visible(left_off***REMOVED*** for l in ax.get_yticklabels(***REMOVED******REMOVED***
    # ax.xaxis.label.set_visible(bottom_off***REMOVED***
    # ax.yaxis.label.set_visible(left_off***REMOVED***
    ax.axis["bottom"***REMOVED***.toggle(ticklabels=bottom_off, label=bottom_off***REMOVED***
    ax.axis["left"***REMOVED***.toggle(ticklabels=left_off, label=left_off***REMOVED***


class Colorbar(mcolorbar.Colorbar***REMOVED***:
    def _config_axes_deprecated(self, X, Y***REMOVED***:
        '''
        Make an axes patch and outline.
        '''
        ax = self.ax
        ax.set_frame_on(False***REMOVED***
        ax.set_navigate(False***REMOVED***
        xy = self._outline(X, Y***REMOVED***
        ax.update_datalim(xy***REMOVED***
        ax.set_xlim(*ax.dataLim.intervalx***REMOVED***
        ax.set_ylim(*ax.dataLim.intervaly***REMOVED***
        self.outline = mlines.Line2D(xy[:, 0***REMOVED***, xy[:, 1***REMOVED***,
                                     color=mpl.rcParams['axes.edgecolor'***REMOVED***,
                                     linewidth=mpl.rcParams['axes.linewidth'***REMOVED******REMOVED***
        ax.add_artist(self.outline***REMOVED***
        self.outline.set_clip_box(None***REMOVED***
        self.outline.set_clip_path(None***REMOVED***
        c = mpl.rcParams['axes.facecolor'***REMOVED***
        self.patch = mpatches.Polygon(xy, edgecolor=c,
                                      facecolor=c,
                                      linewidth=0.01,
                                      zorder=-1***REMOVED***
        ax.add_artist(self.patch***REMOVED***
        ticks, ticklabels, offset_string = self._ticker(***REMOVED***

        if self.orientation == 'vertical':
            ax.set_yticks(ticks***REMOVED***
            ax.set_yticklabels(ticklabels***REMOVED***
            ax.yaxis.get_major_formatter(***REMOVED***.set_offset_string(offset_string***REMOVED***

        else:
            ax.set_xticks(ticks***REMOVED***
            ax.set_xticklabels(ticklabels***REMOVED***
            ax.xaxis.get_major_formatter(***REMOVED***.set_offset_string(offset_string***REMOVED***


class CbarAxesBase(object***REMOVED***:

    def colorbar(self, mappable, **kwargs***REMOVED***:
        locator = kwargs.pop("locator", None***REMOVED***

        if locator is None:
            if "ticks" not in kwargs:
                kwargs["ticks"***REMOVED*** = ticker.MaxNLocator(5***REMOVED***
        if locator is not None:
            if "ticks" in kwargs:
                raise ValueError("Either *locator* or *ticks* need" +
                                 " to be given, not both"***REMOVED***
            else:
                kwargs["ticks"***REMOVED*** = locator

        self.hold(True***REMOVED***
        if self.orientation in ["top", "bottom"***REMOVED***:
            orientation = "horizontal"
        else:
            orientation = "vertical"

        cb = Colorbar(self, mappable, orientation=orientation, **kwargs***REMOVED***
        self._config_axes(***REMOVED***

        def on_changed(m***REMOVED***:
            #print 'calling on changed', m.get_cmap(***REMOVED***.name
            cb.set_cmap(m.get_cmap(***REMOVED******REMOVED***
            cb.set_clim(m.get_clim(***REMOVED******REMOVED***
            cb.update_bruteforce(m***REMOVED***

        self.cbid = mappable.callbacksSM.connect('changed', on_changed***REMOVED***
        mappable.colorbar = cb

        self.locator = cb.cbar_axis.get_major_locator(***REMOVED***

        return cb

    def _config_axes(self***REMOVED***:
        '''
        Make an axes patch and outline.
        '''
        ax = self
        ax.set_navigate(False***REMOVED***

        ax.axis[:***REMOVED***.toggle(all=False***REMOVED***
        b = self._default_label_on
        ax.axis[self.orientation***REMOVED***.toggle(all=b***REMOVED***

        # for axis in ax.axis.values(***REMOVED***:
        #     axis.major_ticks.set_visible(False***REMOVED***
        #     axis.minor_ticks.set_visible(False***REMOVED***
        #     axis.major_ticklabels.set_visible(False***REMOVED***
        #     axis.minor_ticklabels.set_visible(False***REMOVED***
        #     axis.label.set_visible(False***REMOVED***

        # axis = ax.axis[self.orientation***REMOVED***
        # axis.major_ticks.set_visible(True***REMOVED***
        # axis.minor_ticks.set_visible(True***REMOVED***

        #axis.major_ticklabels.set_size(
        #    int(axis.major_ticklabels.get_size(***REMOVED****.9***REMOVED******REMOVED***
        #axis.major_tick_pad = 3

        # axis.major_ticklabels.set_visible(b***REMOVED***
        # axis.minor_ticklabels.set_visible(b***REMOVED***
        # axis.label.set_visible(b***REMOVED***

    def toggle_label(self, b***REMOVED***:
        self._default_label_on = b
        axis = self.axis[self.orientation***REMOVED***
        axis.toggle(ticklabels=b, label=b***REMOVED***
        #axis.major_ticklabels.set_visible(b***REMOVED***
        #axis.minor_ticklabels.set_visible(b***REMOVED***
        #axis.label.set_visible(b***REMOVED***


class CbarAxes(CbarAxesBase, LocatableAxes***REMOVED***:
    def __init__(self, *kl, **kwargs***REMOVED***:
        orientation = kwargs.pop("orientation", None***REMOVED***
        if orientation is None:
            raise ValueError("orientation must be specified"***REMOVED***
        self.orientation = orientation
        self._default_label_on = True
        self.locator = None

        super(LocatableAxes, self***REMOVED***.__init__(*kl, **kwargs***REMOVED***

    def cla(self***REMOVED***:
        super(LocatableAxes, self***REMOVED***.cla(***REMOVED***
        self._config_axes(***REMOVED***


class Grid(object***REMOVED***:
    ***REMOVED***
    A class that creates a grid of Axes. In matplotlib, the axes
    location (and size***REMOVED*** is specified in the normalized figure
    coordinates. This may not be ideal for images that needs to be
    displayed with a given aspect ratio.  For example, displaying
    images of a same size with some fixed padding between them cannot
    be easily done in matplotlib. AxesGrid is used in such case.
    ***REMOVED***

    _defaultLocatableAxesClass = LocatableAxes

    def __init__(self, fig,
                 rect,
                 nrows_ncols,
                 ngrids=None,
                 direction="row",
                 axes_pad=0.02,
                 add_all=True,
                 share_all=False,
                 share_x=True,
                 share_y=True,
                 #aspect=True,
                 label_mode="L",
                 axes_class=None,
                 ***REMOVED***:
        ***REMOVED***
        Build an :class:`Grid` instance with a grid nrows*ncols
        :class:`~matplotlib.axes.Axes` in
        :class:`~matplotlib.figure.Figure` *fig* with
        *rect=[left, bottom, width, height***REMOVED**** (in
        :class:`~matplotlib.figure.Figure` coordinates***REMOVED*** or
        the subplot position code (e.g., "121"***REMOVED***.

        Optional keyword arguments:

          ================  ========  =========================================
          Keyword           Default   Description
          ================  ========  =========================================
          direction         "row"     [ "row" | "column" ***REMOVED***
          axes_pad          0.02      float| pad between axes given in inches
                                      or tuple-like of floats,
                                      (horizontal padding, vertical padding***REMOVED***
          add_all           True      [ True | False ***REMOVED***
          share_all         False     [ True | False ***REMOVED***
          share_x           True      [ True | False ***REMOVED***
          share_y           True      [ True | False ***REMOVED***
          label_mode        "L"       [ "L" | "1" | "all" ***REMOVED***
          axes_class        None      a type object which must be a subclass
                                      of :class:`~matplotlib.axes.Axes`
          ================  ========  =========================================
        ***REMOVED***
        self._nrows, self._ncols = nrows_ncols

        if ngrids is None:
            ngrids = self._nrows * self._ncols
        else:
            if (ngrids > self._nrows * self._ncols***REMOVED*** or (ngrids <= 0***REMOVED***:
                raise Exception(""***REMOVED***

        self.ngrids = ngrids

        self._init_axes_pad(axes_pad***REMOVED***

        if direction not in ["column", "row"***REMOVED***:
            raise Exception(""***REMOVED***

        self._direction = direction

        if axes_class is None:
            axes_class = self._defaultLocatableAxesClass
            axes_class_args = {***REMOVED***
        else:
            if (type(axes_class***REMOVED******REMOVED*** == type and \
                   issubclass(axes_class,
                              self._defaultLocatableAxesClass.Axes***REMOVED***:
                axes_class_args = {***REMOVED***
            else:
                axes_class, axes_class_args = axes_class

        self.axes_all = [***REMOVED***
        self.axes_column = [[***REMOVED*** for _ in range(self._ncols***REMOVED******REMOVED***
        self.axes_row = [[***REMOVED*** for _ in range(self._nrows***REMOVED******REMOVED***

        h = [***REMOVED***
        v = [***REMOVED***
        if cbook.is_string_like(rect***REMOVED*** or cbook.is_numlike(rect***REMOVED***:
            self._divider = SubplotDivider(fig, rect, horizontal=h, vertical=v,
                                           aspect=False***REMOVED***
        elif isinstance(rect, SubplotSpec***REMOVED***:
            self._divider = SubplotDivider(fig, rect, horizontal=h, vertical=v,
                                           aspect=False***REMOVED***
        elif len(rect***REMOVED*** == 3:
            kw = dict(horizontal=h, vertical=v, aspect=False***REMOVED***
            self._divider = SubplotDivider(fig, *rect, **kw***REMOVED***
        elif len(rect***REMOVED*** == 4:
            self._divider = Divider(fig, rect, horizontal=h, vertical=v,
                                    aspect=False***REMOVED***
        else:
            raise Exception(""***REMOVED***

        rect = self._divider.get_position(***REMOVED***

        # reference axes
        self._column_refax = [None for _ in range(self._ncols***REMOVED******REMOVED***
        self._row_refax = [None for _ in range(self._nrows***REMOVED******REMOVED***
        self._refax = None

        for i in range(self.ngrids***REMOVED***:

            col, row = self._get_col_row(i***REMOVED***

            if share_all:
                sharex = self._refax
                sharey = self._refax
            else:
                if share_x:
                    sharex = self._column_refax[col***REMOVED***
                else:
                    sharex = None

                if share_y:
                    sharey = self._row_refax[row***REMOVED***
                else:
                    sharey = None

            ax = axes_class(fig, rect, sharex=sharex, sharey=sharey,
                            **axes_class_args***REMOVED***

            if share_all:
                if self._refax is None:
                    self._refax = ax
            else:
                if sharex is None:
                    self._column_refax[col***REMOVED*** = ax
                if sharey is None:
                    self._row_refax[row***REMOVED*** = ax

            self.axes_all.append(ax***REMOVED***
            self.axes_column[col***REMOVED***.append(ax***REMOVED***
            self.axes_row[row***REMOVED***.append(ax***REMOVED***

        self.axes_llc = self.axes_column[0***REMOVED***[-1***REMOVED***

        self._update_locators(***REMOVED***

        if add_all:
            for ax in self.axes_all:
                fig.add_axes(ax***REMOVED***

        self.set_label_mode(label_mode***REMOVED***

    def _init_axes_pad(self, axes_pad***REMOVED***:
        axes_pad = _extend_axes_pad(axes_pad***REMOVED***
        self._axes_pad = axes_pad

        self._horiz_pad_size = Size.Fixed(axes_pad[0***REMOVED******REMOVED***
        self._vert_pad_size = Size.Fixed(axes_pad[1***REMOVED******REMOVED***

    def _update_locators(self***REMOVED***:

        h = [***REMOVED***

        h_ax_pos = [***REMOVED***

        for _ in self._column_refax:
            #if h: h.append(Size.Fixed(self._axes_pad***REMOVED******REMOVED***
            if h:
                h.append(self._horiz_pad_size***REMOVED***

            h_ax_pos.append(len(h***REMOVED******REMOVED***

            sz = Size.Scaled(1***REMOVED***
            h.append(sz***REMOVED***

        v = [***REMOVED***

        v_ax_pos = [***REMOVED***
        for _ in self._row_refax[::-1***REMOVED***:
            #if v: v.append(Size.Fixed(self._axes_pad***REMOVED******REMOVED***
            if v:
                v.append(self._vert_pad_size***REMOVED***

            v_ax_pos.append(len(v***REMOVED******REMOVED***
            sz = Size.Scaled(1***REMOVED***
            v.append(sz***REMOVED***

        for i in range(self.ngrids***REMOVED***:
            col, row = self._get_col_row(i***REMOVED***
            locator = self._divider.new_locator(nx=h_ax_pos[col***REMOVED***,
                                ny=v_ax_pos[self._nrows - 1 - row***REMOVED******REMOVED***
            self.axes_all[i***REMOVED***.set_axes_locator(locator***REMOVED***

        self._divider.set_horizontal(h***REMOVED***
        self._divider.set_vertical(v***REMOVED***

    def _get_col_row(self, n***REMOVED***:
        if self._direction == "column":
            col, row = divmod(n, self._nrows***REMOVED***
        else:
            row, col = divmod(n, self._ncols***REMOVED***

        return col, row

    # Good to propagate __len__ if we have __getitem__
    def __len__(self***REMOVED***:
        return len(self.axes_all***REMOVED***

    def __getitem__(self, i***REMOVED***:
        return self.axes_all[i***REMOVED***

    def get_geometry(self***REMOVED***:
        ***REMOVED***
        get geometry of the grid. Returns a tuple of two integer,
        representing number of rows and number of columns.
        ***REMOVED***
        return self._nrows, self._ncols

    def set_axes_pad(self, axes_pad***REMOVED***:
        "set axes_pad"
        self._axes_pad = axes_pad

        # These two lines actually differ from ones in _init_axes_pad
        self._horiz_pad_size.fixed_size = axes_pad[0***REMOVED***
        self._vert_pad_size.fixed_size = axes_pad[1***REMOVED***

    def get_axes_pad(self***REMOVED***:
        ***REMOVED***
        get axes_pad

        Returns
        -------
        tuple
            Padding in inches, (horizontal pad, vertical pad***REMOVED***
        ***REMOVED***
        return self._axes_pad

    def set_aspect(self, aspect***REMOVED***:
        "set aspect"
        self._divider.set_aspect(aspect***REMOVED***

    def get_aspect(self***REMOVED***:
        "get aspect"
        return self._divider.get_aspect(***REMOVED***

    def set_label_mode(self, mode***REMOVED***:
        "set label_mode"
        if mode == "all":
            for ax in self.axes_all:
                _tick_only(ax, False, False***REMOVED***
        elif mode == "L":
            # left-most axes
            for ax in self.axes_column[0***REMOVED***[:-1***REMOVED***:
                _tick_only(ax, bottom_on=True, left_on=False***REMOVED***
            # lower-left axes
            ax = self.axes_column[0***REMOVED***[-1***REMOVED***
            _tick_only(ax, bottom_on=False, left_on=False***REMOVED***

            for col in self.axes_column[1:***REMOVED***:
                # axes with no labels
                for ax in col[:-1***REMOVED***:
                    _tick_only(ax, bottom_on=True, left_on=True***REMOVED***

                # bottom
                ax = col[-1***REMOVED***
                _tick_only(ax, bottom_on=False, left_on=True***REMOVED***

        elif mode == "1":
            for ax in self.axes_all:
                _tick_only(ax, bottom_on=True, left_on=True***REMOVED***

            ax = self.axes_llc
            _tick_only(ax, bottom_on=False, left_on=False***REMOVED***

    def get_divider(self***REMOVED***:
        return self._divider

    def set_axes_locator(self, locator***REMOVED***:
        self._divider.set_locator(locator***REMOVED***

    def get_axes_locator(self***REMOVED***:
        return self._divider.get_locator(***REMOVED***

    def get_vsize_hsize(self***REMOVED***:

        return self._divider.get_vsize_hsize(***REMOVED***
#         from axes_size import AddList

#         vsize = AddList(self._divider.get_vertical(***REMOVED******REMOVED***
#         hsize = AddList(self._divider.get_horizontal(***REMOVED******REMOVED***

#         return vsize, hsize


class ImageGrid(Grid***REMOVED***:
    ***REMOVED***
    A class that creates a grid of Axes. In matplotlib, the axes
    location (and size***REMOVED*** is specified in the normalized figure
    coordinates. This may not be ideal for images that needs to be
    displayed with a given aspect ratio.  For example, displaying
    images of a same size with some fixed padding between them cannot
    be easily done in matplotlib. ImageGrid is used in such case.
    ***REMOVED***

    _defaultCbarAxesClass = CbarAxes

    def __init__(self, fig,
                 rect,
                 nrows_ncols,
                 ngrids=None,
                 direction="row",
                 axes_pad=0.02,
                 add_all=True,
                 share_all=False,
                 aspect=True,
                 label_mode="L",
                 cbar_mode=None,
                 cbar_location="right",
                 cbar_pad=None,
                 cbar_size="5%",
                 cbar_set_cax=True,
                 axes_class=None,
                 ***REMOVED***:
        ***REMOVED***
        Build an :class:`ImageGrid` instance with a grid nrows*ncols
        :class:`~matplotlib.axes.Axes` in
        :class:`~matplotlib.figure.Figure` *fig* with
        *rect=[left, bottom, width, height***REMOVED**** (in
        :class:`~matplotlib.figure.Figure` coordinates***REMOVED*** or
        the subplot position code (e.g., "121"***REMOVED***.

        Optional keyword arguments:

          ================  ========  =========================================
          Keyword           Default   Description
          ================  ========  =========================================
          direction         "row"     [ "row" | "column" ***REMOVED***
          axes_pad          0.02      float| pad between axes given in inches
                                      or tuple-like of floats,
                                      (horizontal padding, vertical padding***REMOVED***
          add_all           True      [ True | False ***REMOVED***
          share_all         False     [ True | False ***REMOVED***
          aspect            True      [ True | False ***REMOVED***
          label_mode        "L"       [ "L" | "1" | "all" ***REMOVED***
          cbar_mode         None      [ "each" | "single" | "edge" ***REMOVED***
          cbar_location     "right"   [ "left" | "right" | "bottom" | "top" ***REMOVED***
          cbar_pad          None
          cbar_size         "5%"
          cbar_set_cax      True      [ True | False ***REMOVED***
          axes_class        None      a type object which must be a subclass
                                      of axes_grid's subclass of
                                      :class:`~matplotlib.axes.Axes`
          ================  ========  =========================================

        *cbar_set_cax* : if True, each axes in the grid has a cax
          attribute that is bind to associated cbar_axes.
        ***REMOVED***
        self._nrows, self._ncols = nrows_ncols

        if ngrids is None:
            ngrids = self._nrows * self._ncols
        else:
            if (ngrids > self._nrows * self._ncols***REMOVED*** or (ngrids <= 0***REMOVED***:
                raise Exception(""***REMOVED***

        self.ngrids = ngrids

        axes_pad = _extend_axes_pad(axes_pad***REMOVED***
        self._axes_pad = axes_pad

        self._colorbar_mode = cbar_mode
        self._colorbar_location = cbar_location
        if cbar_pad is None:
            # horizontal or vertical arrangement?
            if cbar_location in ("left", "right"***REMOVED***:
                self._colorbar_pad = axes_pad[0***REMOVED***
            else:
                self._colorbar_pad = axes_pad[1***REMOVED***
        else:
            self._colorbar_pad = cbar_pad

        self._colorbar_size = cbar_size

        self._init_axes_pad(axes_pad***REMOVED***

        if direction not in ["column", "row"***REMOVED***:
            raise Exception(""***REMOVED***

        self._direction = direction

        if axes_class is None:
            axes_class = self._defaultLocatableAxesClass
            axes_class_args = {***REMOVED***
        else:
            if isinstance(axes_class, maxes.Axes***REMOVED***:
                axes_class_args = {***REMOVED***
            else:
                axes_class, axes_class_args = axes_class

        self.axes_all = [***REMOVED***
        self.axes_column = [[***REMOVED*** for _ in range(self._ncols***REMOVED******REMOVED***
        self.axes_row = [[***REMOVED*** for _ in range(self._nrows***REMOVED******REMOVED***

        self.cbar_axes = [***REMOVED***

        h = [***REMOVED***
        v = [***REMOVED***
        if cbook.is_string_like(rect***REMOVED*** or cbook.is_numlike(rect***REMOVED***:
            self._divider = SubplotDivider(fig, rect, horizontal=h, vertical=v,
                                           aspect=aspect***REMOVED***
        elif isinstance(rect, SubplotSpec***REMOVED***:
            self._divider = SubplotDivider(fig, rect, horizontal=h, vertical=v,
                                           aspect=aspect***REMOVED***
        elif len(rect***REMOVED*** == 3:
            kw = dict(horizontal=h, vertical=v, aspect=aspect***REMOVED***
            self._divider = SubplotDivider(fig, *rect, **kw***REMOVED***
        elif len(rect***REMOVED*** == 4:
            self._divider = Divider(fig, rect, horizontal=h, vertical=v,
                                    aspect=aspect***REMOVED***
        else:
            raise Exception(""***REMOVED***

        rect = self._divider.get_position(***REMOVED***

        # reference axes
        self._column_refax = [None for _ in range(self._ncols***REMOVED******REMOVED***
        self._row_refax = [None for _ in range(self._nrows***REMOVED******REMOVED***
        self._refax = None

        for i in range(self.ngrids***REMOVED***:

            col, row = self._get_col_row(i***REMOVED***

            if share_all:
                if self.axes_all:
                    sharex = self.axes_all[0***REMOVED***
                    sharey = self.axes_all[0***REMOVED***
                else:
                    sharex = None
                    sharey = None
            else:
                sharex = self._column_refax[col***REMOVED***
                sharey = self._row_refax[row***REMOVED***

            ax = axes_class(fig, rect, sharex=sharex, sharey=sharey,
                            **axes_class_args***REMOVED***

            self.axes_all.append(ax***REMOVED***
            self.axes_column[col***REMOVED***.append(ax***REMOVED***
            self.axes_row[row***REMOVED***.append(ax***REMOVED***

            if share_all:
                if self._refax is None:
                    self._refax = ax
            if sharex is None:
                self._column_refax[col***REMOVED*** = ax
            if sharey is None:
                self._row_refax[row***REMOVED*** = ax

            cax = self._defaultCbarAxesClass(fig, rect,
                                        orientation=self._colorbar_location***REMOVED***
            self.cbar_axes.append(cax***REMOVED***

        self.axes_llc = self.axes_column[0***REMOVED***[-1***REMOVED***

        self._update_locators(***REMOVED***

        if add_all:
            for ax in self.axes_all+self.cbar_axes:
                fig.add_axes(ax***REMOVED***

        if cbar_set_cax:
            if self._colorbar_mode == "single":
                for ax in self.axes_all:
                    ax.cax = self.cbar_axes[0***REMOVED***
            elif self._colorbar_mode == "edge":
                for index, ax in enumerate(self.axes_all***REMOVED***:
                    col, row = self._get_col_row(index***REMOVED***
                    if self._colorbar_location in ("left", "right"***REMOVED***:
                        ax.cax = self.cbar_axes[row***REMOVED***
                    else:
                        ax.cax = self.cbar_axes[col***REMOVED***
            else:
                for ax, cax in zip(self.axes_all, self.cbar_axes***REMOVED***:
                    ax.cax = cax

        self.set_label_mode(label_mode***REMOVED***

    def _update_locators(self***REMOVED***:

        h = [***REMOVED***
        v = [***REMOVED***

        h_ax_pos = [***REMOVED***
        h_cb_pos = [***REMOVED***
        if (self._colorbar_mode == "single" and
             self._colorbar_location in ('left', 'bottom'***REMOVED******REMOVED***:
            if self._colorbar_location == "left":
                #sz = Size.Fraction(Size.AxesX(self.axes_llc***REMOVED***, self._nrows***REMOVED***
                sz = Size.Fraction(self._nrows, Size.AxesX(self.axes_llc***REMOVED******REMOVED***
                h.append(Size.from_any(self._colorbar_size, sz***REMOVED******REMOVED***
                h.append(Size.from_any(self._colorbar_pad, sz***REMOVED******REMOVED***
                locator = self._divider.new_locator(nx=0, ny=0, ny1=-1***REMOVED***
            elif self._colorbar_location == "bottom":
                #sz = Size.Fraction(Size.AxesY(self.axes_llc***REMOVED***, self._ncols***REMOVED***
                sz = Size.Fraction(self._ncols, Size.AxesY(self.axes_llc***REMOVED******REMOVED***
                v.append(Size.from_any(self._colorbar_size, sz***REMOVED******REMOVED***
                v.append(Size.from_any(self._colorbar_pad, sz***REMOVED******REMOVED***
                locator = self._divider.new_locator(nx=0, nx1=-1, ny=0***REMOVED***
            for i in range(self.ngrids***REMOVED***:
                self.cbar_axes[i***REMOVED***.set_visible(False***REMOVED***
            self.cbar_axes[0***REMOVED***.set_axes_locator(locator***REMOVED***
            self.cbar_axes[0***REMOVED***.set_visible(True***REMOVED***

        for col, ax in enumerate(self.axes_row[0***REMOVED******REMOVED***:
            if h:
                h.append(self._horiz_pad_size***REMOVED***  # Size.Fixed(self._axes_pad***REMOVED******REMOVED***

            if ax:
                sz = Size.AxesX(ax, aspect="axes", ref_ax=self.axes_all[0***REMOVED******REMOVED***
            else:
                sz = Size.AxesX(self.axes_all[0***REMOVED***,
                                aspect="axes", ref_ax=self.axes_all[0***REMOVED******REMOVED***

            if (self._colorbar_mode == "each" or
                    (self._colorbar_mode == 'edge' and
                        col == 0***REMOVED******REMOVED*** and self._colorbar_location == "left":
                h_cb_pos.append(len(h***REMOVED******REMOVED***
                h.append(Size.from_any(self._colorbar_size, sz***REMOVED******REMOVED***
                h.append(Size.from_any(self._colorbar_pad, sz***REMOVED******REMOVED***

            h_ax_pos.append(len(h***REMOVED******REMOVED***

            h.append(sz***REMOVED***

            if ((self._colorbar_mode == "each" or
                    (self._colorbar_mode == 'edge' and
                        col == self._ncols - 1***REMOVED******REMOVED*** and
                    self._colorbar_location == "right"***REMOVED***:
                h.append(Size.from_any(self._colorbar_pad, sz***REMOVED******REMOVED***
                h_cb_pos.append(len(h***REMOVED******REMOVED***
                h.append(Size.from_any(self._colorbar_size, sz***REMOVED******REMOVED***

        v_ax_pos = [***REMOVED***
        v_cb_pos = [***REMOVED***
        for row, ax in enumerate(self.axes_column[0***REMOVED***[::-1***REMOVED******REMOVED***:
            if v:
                v.append(self._vert_pad_size***REMOVED***  # Size.Fixed(self._axes_pad***REMOVED******REMOVED***

            if ax:
                sz = Size.AxesY(ax, aspect="axes", ref_ax=self.axes_all[0***REMOVED******REMOVED***
            else:
                sz = Size.AxesY(self.axes_all[0***REMOVED***,
                                aspect="axes", ref_ax=self.axes_all[0***REMOVED******REMOVED***

            if (self._colorbar_mode == "each" or
                    (self._colorbar_mode == 'edge' and
                        row == 0***REMOVED******REMOVED*** and self._colorbar_location == "bottom":
                v_cb_pos.append(len(v***REMOVED******REMOVED***
                v.append(Size.from_any(self._colorbar_size, sz***REMOVED******REMOVED***
                v.append(Size.from_any(self._colorbar_pad, sz***REMOVED******REMOVED***

            v_ax_pos.append(len(v***REMOVED******REMOVED***
            v.append(sz***REMOVED***

            if ((self._colorbar_mode == "each" or
                    (self._colorbar_mode == 'edge' and
                        row == self._nrows - 1***REMOVED******REMOVED*** and
                        self._colorbar_location == "top"***REMOVED***:
                v.append(Size.from_any(self._colorbar_pad, sz***REMOVED******REMOVED***
                v_cb_pos.append(len(v***REMOVED******REMOVED***
                v.append(Size.from_any(self._colorbar_size, sz***REMOVED******REMOVED***

        for i in range(self.ngrids***REMOVED***:
            col, row = self._get_col_row(i***REMOVED***
            #locator = self._divider.new_locator(nx=4*col,
            #                                    ny=2*(self._nrows - row - 1***REMOVED******REMOVED***
            locator = self._divider.new_locator(nx=h_ax_pos[col***REMOVED***,
                                                ny=v_ax_pos[self._nrows-1-row***REMOVED******REMOVED***
            self.axes_all[i***REMOVED***.set_axes_locator(locator***REMOVED***

            if self._colorbar_mode == "each":
                if self._colorbar_location in ("right", "left"***REMOVED***:
                    locator = self._divider.new_locator(
                        nx=h_cb_pos[col***REMOVED***, ny=v_ax_pos[self._nrows - 1 - row***REMOVED******REMOVED***

                elif self._colorbar_location in ("top", "bottom"***REMOVED***:
                    locator = self._divider.new_locator(
                        nx=h_ax_pos[col***REMOVED***, ny=v_cb_pos[self._nrows - 1 - row***REMOVED******REMOVED***

                self.cbar_axes[i***REMOVED***.set_axes_locator(locator***REMOVED***
            elif self._colorbar_mode == 'edge':
                if ((self._colorbar_location == 'left' and col == 0***REMOVED*** or
                        (self._colorbar_location == 'right'
                         and col == self._ncols-1***REMOVED******REMOVED***:
                    locator = self._divider.new_locator(
                        nx=h_cb_pos[0***REMOVED***, ny=v_ax_pos[self._nrows -1 - row***REMOVED******REMOVED***
                    self.cbar_axes[row***REMOVED***.set_axes_locator(locator***REMOVED***
                elif ((self._colorbar_location == 'bottom' and
                       row == self._nrows - 1***REMOVED*** or
                        (self._colorbar_location == 'top' and row == 0***REMOVED******REMOVED***:
                    locator = self._divider.new_locator(nx=h_ax_pos[col***REMOVED***,
                                                        ny=v_cb_pos[0***REMOVED******REMOVED***
                    self.cbar_axes[col***REMOVED***.set_axes_locator(locator***REMOVED***

        if self._colorbar_mode == "single":
            if self._colorbar_location == "right":
                #sz = Size.Fraction(Size.AxesX(self.axes_llc***REMOVED***, self._nrows***REMOVED***
                sz = Size.Fraction(self._nrows, Size.AxesX(self.axes_llc***REMOVED******REMOVED***
                h.append(Size.from_any(self._colorbar_pad, sz***REMOVED******REMOVED***
                h.append(Size.from_any(self._colorbar_size, sz***REMOVED******REMOVED***
                locator = self._divider.new_locator(nx=-2, ny=0, ny1=-1***REMOVED***
            elif self._colorbar_location == "top":
                #sz = Size.Fraction(Size.AxesY(self.axes_llc***REMOVED***, self._ncols***REMOVED***
                sz = Size.Fraction(self._ncols, Size.AxesY(self.axes_llc***REMOVED******REMOVED***
                v.append(Size.from_any(self._colorbar_pad, sz***REMOVED******REMOVED***
                v.append(Size.from_any(self._colorbar_size, sz***REMOVED******REMOVED***
                locator = self._divider.new_locator(nx=0, nx1=-1, ny=-2***REMOVED***
            if self._colorbar_location in ("right", "top"***REMOVED***:
                for i in range(self.ngrids***REMOVED***:
                    self.cbar_axes[i***REMOVED***.set_visible(False***REMOVED***
                self.cbar_axes[0***REMOVED***.set_axes_locator(locator***REMOVED***
                self.cbar_axes[0***REMOVED***.set_visible(True***REMOVED***
        elif self._colorbar_mode == "each":
            for i in range(self.ngrids***REMOVED***:
                self.cbar_axes[i***REMOVED***.set_visible(True***REMOVED***
        elif self._colorbar_mode == "edge":
            if self._colorbar_location in ('right', 'left'***REMOVED***:
                count = self._nrows
            else:
                count = self._ncols
            for i in range(count***REMOVED***:
                self.cbar_axes[i***REMOVED***.set_visible(True***REMOVED***
            for j in range(i + 1, self.ngrids***REMOVED***:
                self.cbar_axes[j***REMOVED***.set_visible(False***REMOVED***
        else:
            for i in range(self.ngrids***REMOVED***:
                self.cbar_axes[i***REMOVED***.set_visible(False***REMOVED***
                self.cbar_axes[i***REMOVED***.set_position([1., 1., 0.001, 0.001***REMOVED***,
                                               which="active"***REMOVED***

        self._divider.set_horizontal(h***REMOVED***
        self._divider.set_vertical(v***REMOVED***


AxesGrid = ImageGrid

