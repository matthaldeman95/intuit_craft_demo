***REMOVED***

Some gtk specific tools and widgets

   * rec2gtk          : put record array in GTK treeview - requires gtk

Example usage

    import matplotlib.mlab as mlab
    import mpl_toolkits.gtktools as gtktools

    r = mlab.csv2rec('somefile.csv', checkrows=0***REMOVED***

    formatd = dict(
        weight = mlab.FormatFloat(2***REMOVED***,
        change = mlab.FormatPercent(2***REMOVED***,
        cost   = mlab.FormatThousands(2***REMOVED***,
        ***REMOVED***


    exceltools.rec2excel(r, 'test.xls', formatd=formatd***REMOVED***
    mlab.rec2csv(r, 'test.csv', formatd=formatd***REMOVED***


    import gtk
    scroll = gtktools.rec2gtk(r, formatd=formatd***REMOVED***
    win = gtk.Window(***REMOVED***
    win.set_size_request(600,800***REMOVED***
    win.add(scroll***REMOVED***
    win.show_all(***REMOVED***
    gtk.main(***REMOVED***

***REMOVED***
from __future__ import (absolute_import, division, print_function,
                        unicode_literals***REMOVED***

from matplotlib.externals import six
from matplotlib.externals.six.moves import xrange, zip

import copy
import gtk, gobject
import numpy as npy
import matplotlib.cbook as cbook
import matplotlib.mlab as mlab


def error_message(msg, parent=None, title=None***REMOVED***:
    ***REMOVED***
    create an error message dialog with string msg.  Optionally set
    the parent widget and dialog title
    ***REMOVED***

    dialog = gtk.MessageDialog(
        parent         = None,
        type           = gtk.MESSAGE_ERROR,
        buttons        = gtk.BUTTONS_OK,
        message_format = msg***REMOVED***
    if parent is not None:
        dialog.set_transient_for(parent***REMOVED***
    if title is not None:
        dialog.set_title(title***REMOVED***
    else:
        dialog.set_title('Error!'***REMOVED***
    dialog.show(***REMOVED***
    dialog.run(***REMOVED***
    dialog.destroy(***REMOVED***
    return None

def simple_message(msg, parent=None, title=None***REMOVED***:
    ***REMOVED***
    create a simple message dialog with string msg.  Optionally set
    the parent widget and dialog title
    ***REMOVED***
    dialog = gtk.MessageDialog(
        parent         = None,
        type           = gtk.MESSAGE_INFO,
        buttons        = gtk.BUTTONS_OK,
        message_format = msg***REMOVED***
    if parent is not None:
        dialog.set_transient_for(parent***REMOVED***
    if title is not None:
        dialog.set_title(title***REMOVED***
    dialog.show(***REMOVED***
    dialog.run(***REMOVED***
    dialog.destroy(***REMOVED***
    return None


def gtkformat_factory(format, colnum***REMOVED***:
    ***REMOVED***
    copy the format, perform any overrides, and attach an gtk style attrs


    xalign = 0.
    cell = None

    ***REMOVED***
    if format is None: return None
    format = copy.copy(format***REMOVED***
    format.xalign = 0.
    format.cell = None

    def negative_red_cell(column, cell, model, thisiter***REMOVED***:
        val = model.get_value(thisiter, colnum***REMOVED***
        ***REMOVED*** val = float(val***REMOVED***
        ***REMOVED*** cell.set_property('foreground', 'black'***REMOVED***
        else:
            if val<0:
                cell.set_property('foreground', 'red'***REMOVED***
            else:
                cell.set_property('foreground', 'black'***REMOVED***


    if isinstance(format, mlab.FormatFloat***REMOVED*** or isinstance(format, mlab.FormatInt***REMOVED***:
        format.cell = negative_red_cell
        format.xalign = 1.
    elif isinstance(format, mlab.FormatDate***REMOVED***:
        format.xalign = 1.
    return format



class SortedStringsScrolledWindow(gtk.ScrolledWindow***REMOVED***:
    ***REMOVED***
    A simple treeview/liststore assuming all columns are strings.
    Supports ascending/descending sort by clicking on column header
    ***REMOVED***

    def __init__(self, colheaders, formatterd=None***REMOVED***:
        ***REMOVED***
        xalignd if not None, is a dict mapping col header to xalignent (default 1***REMOVED***

        formatterd if not None, is a dict mapping col header to a ColumnFormatter
        ***REMOVED***


        gtk.ScrolledWindow.__init__(self***REMOVED***
        self.colheaders = colheaders
        self.seq = None # not initialized with accts
        self.set_shadow_type(gtk.SHADOW_ETCHED_IN***REMOVED***
        self.set_policy(gtk.POLICY_AUTOMATIC,
                        gtk.POLICY_AUTOMATIC***REMOVED***

        types = [gobject.TYPE_STRING***REMOVED*** * len(colheaders***REMOVED***
        model = self.model = gtk.ListStore(*types***REMOVED***


        treeview = gtk.TreeView(self.model***REMOVED***
        treeview.show(***REMOVED***
        treeview.get_selection(***REMOVED***.set_mode(gtk.SELECTION_MULTIPLE***REMOVED***
        treeview.set_rules_hint(True***REMOVED***


        class Clicked:
            def __init__(self, parent, i***REMOVED***:
                self.parent = parent
                self.i = i
                self.num = 0

            def __call__(self, column***REMOVED***:
                ind = [***REMOVED***
                dsu = [***REMOVED***
                for rownum, thisiter in enumerate(self.parent.iters***REMOVED***:
                    val = model.get_value(thisiter, self.i***REMOVED***
                    ***REMOVED*** val = float(val.strip(***REMOVED***.rstrip('%'***REMOVED******REMOVED***
                    except ValueError: pass
                    if mlab.safe_isnan(val***REMOVED***: val = npy.inf # force nan to sort uniquely
                    dsu.append((val, rownum***REMOVED******REMOVED***
                dsu.sort(***REMOVED***
                if not self.num%2: dsu.reverse(***REMOVED***

                vals, otherind = list(zip(*dsu***REMOVED******REMOVED***
                ind.extend(otherind***REMOVED***

                self.parent.model.reorder(ind***REMOVED***
                newiters = [***REMOVED***
                for i in ind:
                    newiters.append(self.parent.iters[i***REMOVED******REMOVED***
                self.parent.iters = newiters[:***REMOVED***
                for i, thisiter in enumerate(self.parent.iters***REMOVED***:
                    key = tuple([self.parent.model.get_value(thisiter, j***REMOVED*** for j in range(len(colheaders***REMOVED******REMOVED******REMOVED******REMOVED***
                    self.parent.rownumd[i***REMOVED*** = key

                self.num+=1


        if formatterd is None:
            formatterd = dict(***REMOVED***

        formatterd = formatterd.copy(***REMOVED***

        for i, header in enumerate(colheaders***REMOVED***:
            renderer = gtk.CellRendererText(***REMOVED***
            if header not in formatterd:
                formatterd[header***REMOVED*** = ColumnFormatter(***REMOVED***
            formatter = formatterd[header***REMOVED***

            column = gtk.TreeViewColumn(header, renderer, text=i***REMOVED***
            renderer.set_property('xalign', formatter.xalign***REMOVED***
            renderer.set_property('editable', True***REMOVED***
            renderer.connect("edited", self.position_edited, i***REMOVED***
            column.connect('clicked', Clicked(self, i***REMOVED******REMOVED***
            column.set_property('clickable', True***REMOVED***

            if formatter.cell is not None:
                column.set_cell_data_func(renderer, formatter.cell***REMOVED***

            treeview.append_column(column***REMOVED***



        self.formatterd = formatterd
        self.lastcol = column
        self.add(treeview***REMOVED***
        self.treeview = treeview
        self.clear(***REMOVED***

    def position_edited(self, renderer, path, newtext, position***REMOVED***:
        #print path, position
        self.model[path***REMOVED***[position***REMOVED*** = newtext

    def clear(self***REMOVED***:
        self.iterd = dict(***REMOVED***
        self.iters = [***REMOVED***        # an ordered list of iters
        self.rownumd = dict(***REMOVED***  # a map from rownum -> symbol
        self.model.clear(***REMOVED***
        self.datad = dict(***REMOVED***


    def flat(self, row***REMOVED***:
        seq = [***REMOVED***
        for i,val in enumerate(row***REMOVED***:
            formatter = self.formatterd.get(self.colheaders[i***REMOVED******REMOVED***
            seq.extend([i,formatter.tostr(val***REMOVED******REMOVED******REMOVED***
        return seq

    def __delete_selected(self, *unused***REMOVED***: # untested


        keyd = dict([(thisiter, key***REMOVED*** for key, thisiter in self.iterd.values(***REMOVED******REMOVED******REMOVED***
        for row in self.get_selected(***REMOVED***:
            key = tuple(row***REMOVED***
            thisiter = self.iterd[key***REMOVED***
            self.model.remove(thisiter***REMOVED***
            del self.datad[key***REMOVED***
            del self.iterd[key***REMOVED***
            self.iters.remove(thisiter***REMOVED***

        for i, thisiter in enumerate(self.iters***REMOVED***:
            self.rownumd[i***REMOVED*** = keyd[thisiter***REMOVED***



    def delete_row(self, row***REMOVED***:
        key = tuple(row***REMOVED***
        thisiter = self.iterd[key***REMOVED***
        self.model.remove(thisiter***REMOVED***


        del self.datad[key***REMOVED***
        del self.iterd[key***REMOVED***
        self.rownumd[len(self.iters***REMOVED******REMOVED*** = key
        self.iters.remove(thisiter***REMOVED***

        for rownum, thiskey in list(six.iteritems(self.rownumd***REMOVED******REMOVED***:
            if thiskey==key: del self.rownumd[rownum***REMOVED***

    def add_row(self, row***REMOVED***:
        thisiter = self.model.append(***REMOVED***
        self.model.set(thisiter, *self.flat(row***REMOVED******REMOVED***
        key = tuple(row***REMOVED***
        self.datad[key***REMOVED*** = row
        self.iterd[key***REMOVED*** = thisiter
        self.rownumd[len(self.iters***REMOVED******REMOVED*** = key
        self.iters.append(thisiter***REMOVED***

    def update_row(self, rownum, newrow***REMOVED***:
        key = self.rownumd[rownum***REMOVED***
        thisiter = self.iterd[key***REMOVED***
        newkey = tuple(newrow***REMOVED***

        self.rownumd[rownum***REMOVED*** = newkey
        del self.datad[key***REMOVED***
        del self.iterd[key***REMOVED***
        self.datad[newkey***REMOVED*** = newrow
        self.iterd[newkey***REMOVED*** = thisiter


        self.model.set(thisiter, *self.flat(newrow***REMOVED******REMOVED***

    def get_row(self, rownum***REMOVED***:
        key = self.rownumd[rownum***REMOVED***
        return self.datad[key***REMOVED***

    def get_selected(self***REMOVED***:
        selected = [***REMOVED***
        def foreach(model, path, iter, selected***REMOVED***:
            selected.append(model.get_value(iter, 0***REMOVED******REMOVED***

        self.treeview.get_selection(***REMOVED***.selected_foreach(foreach, selected***REMOVED***
        return selected



def rec2gtk(r, formatd=None, rownum=0, autowin=True***REMOVED***:
    ***REMOVED***
    formatd is a dictionary mapping dtype name -> mlab.Format instances

    This function creates a SortedStringsScrolledWindow (derived
    from gtk.ScrolledWindow***REMOVED*** and returns it.  if autowin is True,
    a gtk.Window is created, attached to the
    SortedStringsScrolledWindow instance, shown and returned.  If
    autowin=False, the caller is responsible for adding the
    SortedStringsScrolledWindow instance to a gtk widget and
    showing it.
    ***REMOVED***



    if formatd is None:
        formatd = dict(***REMOVED***

    formats = [***REMOVED***
    for i, name in enumerate(r.dtype.names***REMOVED***:
        dt = r.dtype[name***REMOVED***
        format = formatd.get(name***REMOVED***
        if format is None:
            format = mlab.defaultformatd.get(dt.type, mlab.FormatObj(***REMOVED******REMOVED***
        #print 'gtk fmt factory', i, name, format, type(format***REMOVED***
        format = gtkformat_factory(format, i***REMOVED***
        formatd[name***REMOVED*** = format


    colheaders = r.dtype.names
    scroll = SortedStringsScrolledWindow(colheaders, formatd***REMOVED***

    ind = npy.arange(len(r.dtype.names***REMOVED******REMOVED***
    for row in r:
        scroll.add_row(row***REMOVED***


    if autowin:
        win = gtk.Window(***REMOVED***
        win.set_default_size(800,600***REMOVED***
        #win.set_geometry_hints(scroll***REMOVED***
        win.add(scroll***REMOVED***
        win.show_all(***REMOVED***
        scroll.win = win

    return scroll


class RecListStore(gtk.ListStore***REMOVED***:
    ***REMOVED***
    A liststore as a model of an editable record array.

    attributes:

     * r - the record array with the edited values

     * formatd - the list of mlab.FormatObj instances, with gtk attachments

     * stringd - a dict mapping dtype names to a list of valid strings for the combo drop downs

     * callbacks - a matplotlib.cbook.CallbackRegistry.  Connect to the cell_changed with

        def mycallback(liststore, rownum, colname, oldval, newval***REMOVED***:
           print('verify: old=%s, new=%s, rec=%s'%(oldval, newval, liststore.r[rownum***REMOVED***[colname***REMOVED******REMOVED******REMOVED***

        cid = liststore.callbacks.connect('cell_changed', mycallback***REMOVED***

        ***REMOVED***
    def __init__(self, r, formatd=None, stringd=None***REMOVED***:
        ***REMOVED***
        r is a numpy record array

        formatd is a dict mapping dtype name to mlab.FormatObj instances

        stringd, if not None, is a dict mapping dtype names to a list of
        valid strings for a combo drop down editor
        ***REMOVED***

        if stringd is None:
            stringd = dict(***REMOVED***

        if formatd is None:
            formatd = mlab.get_formatd(r***REMOVED***

        self.stringd = stringd
        self.callbacks = cbook.CallbackRegistry(['cell_changed'***REMOVED******REMOVED***

        self.r = r

        self.headers = r.dtype.names
        self.formats = [gtkformat_factory(formatd.get(name, mlab.FormatObj(***REMOVED******REMOVED***,i***REMOVED***
                        for i,name in enumerate(self.headers***REMOVED******REMOVED***

        # use the gtk attached versions
        self.formatd = formatd = dict(zip(self.headers, self.formats***REMOVED******REMOVED***
        types = [***REMOVED***
        for format in self.formats:
            if isinstance(format, mlab.FormatBool***REMOVED***:
                types.append(gobject.TYPE_BOOLEAN***REMOVED***
            else:
                types.append(gobject.TYPE_STRING***REMOVED***

        self.combod = dict(***REMOVED***
        if len(stringd***REMOVED***:
            types.extend([gobject.TYPE_INT***REMOVED****len(stringd***REMOVED******REMOVED***

            keys = list(six.iterkeys(stringd***REMOVED******REMOVED***
            keys.sort(***REMOVED***

            valid = set(r.dtype.names***REMOVED***
            for ikey, key in enumerate(keys***REMOVED***:
                assert(key in valid***REMOVED***
                combostore = gtk.ListStore(gobject.TYPE_STRING***REMOVED***
                for s in stringd[key***REMOVED***:
                    combostore.append([s***REMOVED******REMOVED***
                self.combod[key***REMOVED*** = combostore, len(self.headers***REMOVED***+ikey


        gtk.ListStore.__init__(self, *types***REMOVED***

        for row in r:
            vals = [***REMOVED***
            for formatter, val in zip(self.formats, row***REMOVED***:
                if isinstance(formatter, mlab.FormatBool***REMOVED***:
                    vals.append(val***REMOVED***
                else:
                    vals.append(formatter.tostr(val***REMOVED******REMOVED***
            if len(stringd***REMOVED***:
                # todo, get correct index here?
                vals.extend([0***REMOVED****len(stringd***REMOVED******REMOVED***
            self.append(vals***REMOVED***


    def position_edited(self, renderer, path, newtext, position***REMOVED***:

        position = int(position***REMOVED***
        format = self.formats[position***REMOVED***

        rownum = int(path***REMOVED***
        colname = self.headers[position***REMOVED***
        oldval = self.r[rownum***REMOVED***[colname***REMOVED***
        ***REMOVED*** newval = format.fromstr(newtext***REMOVED***
        except ValueError:
            msg = cbook.exception_to_str('Error converting "%s"'%newtext***REMOVED***
            error_message(msg, title='Error'***REMOVED***
            return
        self.r[rownum***REMOVED***[colname***REMOVED*** = newval

        self[path***REMOVED***[position***REMOVED*** = format.tostr(newval***REMOVED***


        self.callbacks.process('cell_changed', self, rownum, colname, oldval, newval***REMOVED***

    def position_toggled(self, cellrenderer, path, position***REMOVED***:
        position = int(position***REMOVED***
        format = self.formats[position***REMOVED***

        newval = not cellrenderer.get_active(***REMOVED***

        rownum = int(path***REMOVED***
        colname = self.headers[position***REMOVED***
        oldval = self.r[rownum***REMOVED***[colname***REMOVED***
        self.r[rownum***REMOVED***[colname***REMOVED*** = newval

        self[path***REMOVED***[position***REMOVED*** = newval

        self.callbacks.process('cell_changed', self, rownum, colname, oldval, newval***REMOVED***





class RecTreeView(gtk.TreeView***REMOVED***:
    ***REMOVED***
    An editable tree view widget for record arrays
    ***REMOVED***
    def __init__(self, recliststore, constant=None***REMOVED***:
        ***REMOVED***
        build a gtk.TreeView to edit a RecListStore

        constant, if not None, is a list of dtype names which are not editable
        ***REMOVED***
        self.recliststore = recliststore

        gtk.TreeView.__init__(self, recliststore***REMOVED***

        combostrings = set(recliststore.stringd.keys(***REMOVED******REMOVED***


        if constant is None:
            constant = [***REMOVED***

        constant = set(constant***REMOVED***

        for i, header in enumerate(recliststore.headers***REMOVED***:
            formatter = recliststore.formatd[header***REMOVED***
            coltype =  recliststore.get_column_type(i***REMOVED***

            if coltype==gobject.TYPE_BOOLEAN:
                renderer = gtk.CellRendererToggle(***REMOVED***
                if header not in constant:
                    renderer.connect("toggled", recliststore.position_toggled, i***REMOVED***
                    renderer.set_property('activatable', True***REMOVED***

            elif header in combostrings:
                 renderer = gtk.CellRendererCombo(***REMOVED***
                 renderer.connect("edited", recliststore.position_edited, i***REMOVED***
                 combostore, listind = recliststore.combod[header***REMOVED***
                 renderer.set_property("model", combostore***REMOVED***
                 renderer.set_property('editable', True***REMOVED***
            else:
                renderer = gtk.CellRendererText(***REMOVED***
                if header not in constant:
                    renderer.connect("edited", recliststore.position_edited, i***REMOVED***
                    renderer.set_property('editable', True***REMOVED***


                if formatter is not None:
                    renderer.set_property('xalign', formatter.xalign***REMOVED***



            tvcol = gtk.TreeViewColumn(header***REMOVED***
            self.append_column(tvcol***REMOVED***
            tvcol.pack_start(renderer, True***REMOVED***

            if coltype == gobject.TYPE_STRING:
                tvcol.add_attribute(renderer, 'text', i***REMOVED***
                if header in combostrings:
                    combostore, listind = recliststore.combod[header***REMOVED***
                    tvcol.add_attribute(renderer, 'text-column', listind***REMOVED***
            elif coltype == gobject.TYPE_BOOLEAN:
                tvcol.add_attribute(renderer, 'active', i***REMOVED***


            if formatter is not None and formatter.cell is not None:
                tvcol.set_cell_data_func(renderer, formatter.cell***REMOVED***




        self.connect("button-release-event", self.on_selection_changed***REMOVED***
        #self.set_grid_lines(gtk.TREE_VIEW_GRID_LINES_BOTH***REMOVED***

        self.get_selection(***REMOVED***.set_mode(gtk.SELECTION_BROWSE***REMOVED***
        self.get_selection(***REMOVED***.set_select_function(self.on_select***REMOVED***


    def on_select(self, *args***REMOVED***:
        return False

    def on_selection_changed(self, *args***REMOVED***:
        (path, col***REMOVED*** = self.get_cursor(***REMOVED***
        ren = col.get_cell_renderers(***REMOVED***[0***REMOVED***
        if isinstance(ren, gtk.CellRendererText***REMOVED***:
            self.set_cursor_on_cell(path, col, ren, start_editing=True***REMOVED***

def edit_recarray(r, formatd=None, stringd=None, constant=None, autowin=True***REMOVED***:
    ***REMOVED***
    create a RecListStore and RecTreeView and return them.

    If autowin is True, create a gtk.Window, insert the treeview into
    it, and return it (return value will be (liststore, treeview, win***REMOVED***

    See RecListStore and RecTreeView for a description of the keyword args
    ***REMOVED***

    liststore = RecListStore(r, formatd=formatd, stringd=stringd***REMOVED***
    treeview = RecTreeView(liststore, constant=constant***REMOVED***

    if autowin:
        win = gtk.Window(***REMOVED***
        win.add(treeview***REMOVED***
        win.show_all(***REMOVED***
        return liststore, treeview, win
    else:
        return liststore, treeview




if __name__=='__main__':

    import datetime
    import gtk
    import numpy as np
    import matplotlib.mlab as mlab
    N = 10
    today = datetime.date.today(***REMOVED***
    dates = [today+datetime.timedelta(days=i***REMOVED*** for i in range(N***REMOVED******REMOVED*** # datetimes
    weekdays = [d.strftime('%a'***REMOVED*** for d in dates***REMOVED***                 # strings
    gains = np.random.randn(N***REMOVED***                                   # floats
    prices = np.random.rand(N***REMOVED****1e7                               # big numbers
    up = gains>0                                                 # bools
    clientid = list(xrange(N***REMOVED******REMOVED***                                   # ints

    r = np.rec.fromarrays([clientid, dates, weekdays, gains, prices, up***REMOVED***,
                          names='clientid,date,weekdays,gains,prices,up'***REMOVED***

    # some custom formatters
    formatd = mlab.get_formatd(r***REMOVED***
    formatd['date'***REMOVED*** = mlab.FormatDate('%Y-%m-%d'***REMOVED***
    formatd['prices'***REMOVED*** = mlab.FormatMillions(precision=1***REMOVED***
    formatd['gain'***REMOVED*** = mlab.FormatPercent(precision=2***REMOVED***

    # use a drop down combo for weekdays
    stringd = dict(weekdays=['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'***REMOVED******REMOVED***
    constant = ['clientid'***REMOVED***   # block editing of this field


    liststore = RecListStore(r, formatd=formatd, stringd=stringd***REMOVED***
    treeview = RecTreeView(liststore, constant=constant***REMOVED***

    def mycallback(liststore, rownum, colname, oldval, newval***REMOVED***:
        print('verify: old=%s, new=%s, rec=%s'%(oldval, newval, liststore.r[rownum***REMOVED***[colname***REMOVED******REMOVED******REMOVED***

    liststore.callbacks.connect('cell_changed', mycallback***REMOVED***

    win = gtk.Window(***REMOVED***
    win.set_title('with full customization'***REMOVED***
    win.add(treeview***REMOVED***
    win.show_all(***REMOVED***

    # or you just use the defaults
    r2 = r.copy(***REMOVED***
    ls, tv, win2 = edit_recarray(r2***REMOVED***
    win2.set_title('with all defaults'***REMOVED***

    gtk.main(***REMOVED***
