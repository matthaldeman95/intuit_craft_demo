from __future__ import (absolute_import, division, print_function,
                        unicode_literals***REMOVED***

from matplotlib.externals import six

from math import floor

import numpy as np
import math

A = np.array

from mpl_toolkits.axisartist.grid_finder import ExtremeFinderSimple

def select_step_degree(dv***REMOVED***:

    degree_limits_ = [1.5, 3, 7, 13, 20, 40, 70, 120, 270, 520***REMOVED***
    degree_steps_  = [  1, 2, 5, 10, 15, 30, 45,  90, 180, 360***REMOVED***
    degree_factors = [1.***REMOVED*** * len(degree_steps_***REMOVED***

    minsec_limits_ = [1.5, 2.5, 3.5, 8, 11, 18, 25, 45***REMOVED***
    minsec_steps_  = [1,   2,   3,   5, 10, 15, 20, 30***REMOVED***

    minute_limits_ = A(minsec_limits_***REMOVED****(1./60.***REMOVED***
    minute_factors = [60.***REMOVED*** * len(minute_limits_***REMOVED***

    second_limits_ = A(minsec_limits_***REMOVED****(1./3600.***REMOVED***
    second_factors = [3600.***REMOVED*** * len(second_limits_***REMOVED***

    degree_limits = np.concatenate([second_limits_,
                                    minute_limits_,
                                    degree_limits_***REMOVED******REMOVED***

    degree_steps = np.concatenate([minsec_steps_,
                                   minsec_steps_,
                                   degree_steps_***REMOVED******REMOVED***

    degree_factors = np.concatenate([second_factors,
                                     minute_factors,
                                     degree_factors***REMOVED******REMOVED***

    n = degree_limits.searchsorted(dv***REMOVED***
    step = degree_steps[n***REMOVED***
    factor = degree_factors[n***REMOVED***

    return step, factor



def select_step_hour(dv***REMOVED***:

    hour_limits_ = [1.5, 2.5, 3.5, 5, 7, 10, 15, 21, 36***REMOVED***
    hour_steps_  = [1,   2  , 3,   4, 6,  8, 12, 18, 24***REMOVED***
    hour_factors = [1.***REMOVED*** * len(hour_steps_***REMOVED***

    minsec_limits_ = [1.5, 2.5, 3.5, 4.5, 5.5, 8, 11, 14, 18, 25, 45***REMOVED***
    minsec_steps_  = [1,   2,   3,   4,   5,   6, 10, 12, 15, 20, 30***REMOVED***

    minute_limits_ = A(minsec_limits_***REMOVED****(1./60.***REMOVED***
    minute_factors = [60.***REMOVED*** * len(minute_limits_***REMOVED***

    second_limits_ = A(minsec_limits_***REMOVED****(1./3600.***REMOVED***
    second_factors = [3600.***REMOVED*** * len(second_limits_***REMOVED***

    hour_limits = np.concatenate([second_limits_,
                                  minute_limits_,
                                  hour_limits_***REMOVED******REMOVED***

    hour_steps = np.concatenate([minsec_steps_,
                                 minsec_steps_,
                                 hour_steps_***REMOVED******REMOVED***

    hour_factors = np.concatenate([second_factors,
                                   minute_factors,
                                   hour_factors***REMOVED******REMOVED***

    n = hour_limits.searchsorted(dv***REMOVED***
    step = hour_steps[n***REMOVED***
    factor = hour_factors[n***REMOVED***

    return step, factor


def select_step_sub(dv***REMOVED***:

    # subarcsec or degree
    tmp = 10.**(int(math.log10(dv***REMOVED******REMOVED***-1.***REMOVED***

    factor = 1./tmp

    if 1.5*tmp >= dv:
        step = 1
    elif 3.*tmp >= dv:
        step = 2
    elif 7.*tmp >= dv:
        step = 5
    else:
        step = 1
        factor = 0.1*factor

    return step, factor


def select_step(v1, v2, nv, hour=False, include_last=True,
                threshold_factor=3600.***REMOVED***:

    if v1 > v2:
        v1, v2 = v2, v1

    dv = float(v2 - v1***REMOVED*** / nv

    if hour:
        _select_step = select_step_hour
        cycle = 24.
    else:
        _select_step = select_step_degree
        cycle = 360.

    # for degree
    if dv > 1./threshold_factor:
        #print "degree"
        step, factor = _select_step(dv***REMOVED***
    else:
        step, factor = select_step_sub(dv*threshold_factor***REMOVED***
        #print "feac", step, factor

        factor = factor * threshold_factor


    f1, f2, fstep = v1*factor, v2*factor, step/factor
    levs = np.arange(math.floor(f1/step***REMOVED***, math.ceil(f2/step***REMOVED***+0.5,
                     1, dtype="i"***REMOVED*** * step

    # n : number of valid levels. If there is a cycle, e.g., [0, 90, 180,
    # 270, 360***REMOVED***, the grid line needs to be extended from 0 to 360, so
    # we need to return the whole array. However, the last level (360***REMOVED***
    # needs to be ignored often. In this case, so we return n=4.

    n = len(levs***REMOVED***


    # we need to check the range of values
    # for example, -90 to 90, 0 to 360,

    if factor == 1. and (levs[-1***REMOVED*** >= levs[0***REMOVED***+cycle***REMOVED***: # check for cycle
        nv = int(cycle / step***REMOVED***
        if include_last:
            levs = levs[0***REMOVED*** + np.arange(0, nv+1, 1***REMOVED*** * step
        else:
            levs = levs[0***REMOVED*** + np.arange(0, nv, 1***REMOVED*** * step

        n = len(levs***REMOVED***

    return np.array(levs***REMOVED***, n, factor


def select_step24(v1, v2, nv, include_last=True, threshold_factor=3600***REMOVED***:
    v1, v2 = v1/15., v2/15.
    levs, n, factor =  select_step(v1, v2, nv, hour=True,
                                   include_last=include_last,
                                   threshold_factor=threshold_factor***REMOVED***
    return levs*15., n, factor

def select_step360(v1, v2, nv, include_last=True, threshold_factor=3600***REMOVED***:
    return select_step(v1, v2, nv, hour=False,
                       include_last=include_last,
                       threshold_factor=threshold_factor***REMOVED***



class LocatorBase(object***REMOVED***:
    def __init__(self, den, include_last=True***REMOVED***:
        self.den = den
        self._include_last = include_last

    def _get_nbins(self***REMOVED***:
        return self.den

    def _set_nbins(self, v***REMOVED***:
        self.den = v

    nbins = property(_get_nbins, _set_nbins***REMOVED***

    def set_params(self, **kwargs***REMOVED***:
        if "nbins" in kwargs:
            self.den = int(kwargs.pop("nbins"***REMOVED******REMOVED***

        if kwargs:
            raise ValueError("Following keys are not processed: %s" % \
                             ", ".join([str(k***REMOVED*** for k in kwargs.keys(***REMOVED******REMOVED******REMOVED******REMOVED***


class LocatorHMS(LocatorBase***REMOVED***:
    def __call__(self, v1, v2***REMOVED***:
        return select_step24(v1, v2, self.den, self._include_last***REMOVED***

class LocatorHM(LocatorBase***REMOVED***:
    def __call__(self, v1, v2***REMOVED***:
        return select_step24(v1, v2, self.den, self._include_last,
                             threshold_factor=60***REMOVED***

class LocatorH(LocatorBase***REMOVED***:
    def __call__(self, v1, v2***REMOVED***:
        return select_step24(v1, v2, self.den, self._include_last,
                             threshold_factor=1***REMOVED***


class LocatorDMS(LocatorBase***REMOVED***:
    def __call__(self, v1, v2***REMOVED***:
        return select_step360(v1, v2, self.den, self._include_last***REMOVED***

class LocatorDM(LocatorBase***REMOVED***:
    def __call__(self, v1, v2***REMOVED***:
        return select_step360(v1, v2, self.den, self._include_last,
                              threshold_factor=60***REMOVED***

class LocatorD(LocatorBase***REMOVED***:
    def __call__(self, v1, v2***REMOVED***:
        return select_step360(v1, v2, self.den, self._include_last,
                              threshold_factor=1***REMOVED***



class FormatterDMS(object***REMOVED***:

    deg_mark = "^{\circ***REMOVED***"
    min_mark = "^{\prime***REMOVED***"
    sec_mark = "^{\prime\prime***REMOVED***"

    fmt_d = "$%d"+deg_mark+"$"
    fmt_ds = r"$%d.\!\!"+deg_mark+"%s$"

    # %s for signe
    fmt_d_m = r"$%s%d"+deg_mark+"\,%02d"+min_mark+"$"
    fmt_d_ms = r"$%s%d"+deg_mark+"\,%02d.\mkern-4mu"+min_mark+"%s$"


    fmt_d_m_partial = "$%s%d"+deg_mark+"\,%02d"+min_mark+"\,"
    fmt_s_partial = "%02d"+sec_mark+"$"
    fmt_ss_partial = "%02d.\!\!"+sec_mark+"%s$"


    def _get_number_fraction(self, factor***REMOVED***:
        ## check for fractional numbers
        number_fraction = None
        # check for 60

        for threshold in [1, 60, 3600***REMOVED***:
            if factor <= threshold:
                break

            d = factor // threshold
            int_log_d = int(floor(math.log10(d***REMOVED******REMOVED******REMOVED***
            if 10**int_log_d == d and d!=1:
                number_fraction = int_log_d
                factor = factor // 10**int_log_d
                return factor, number_fraction

        return factor, number_fraction


    def __call__(self, direction, factor, values***REMOVED***:
        if len(values***REMOVED*** == 0:
            return [***REMOVED***
        #ss = [[-1, 1***REMOVED***[v>0***REMOVED*** for v in values***REMOVED*** #not py24 compliant
        values = np.asarray(values***REMOVED***
        ss = np.where(values>0, 1, -1***REMOVED***

        sign_map = {(-1, True***REMOVED***:"-"***REMOVED***
        signs = [sign_map.get((s, v!=0***REMOVED***, ""***REMOVED*** for s, v in zip(ss, values***REMOVED******REMOVED***

        factor, number_fraction = self._get_number_fraction(factor***REMOVED***

        values = np.abs(values***REMOVED***

        if number_fraction is not None:
            values, frac_part = divmod(values, 10**number_fraction***REMOVED***
            frac_fmt = "%%0%dd" % (number_fraction,***REMOVED***
            frac_str = [frac_fmt % (f1,***REMOVED*** for f1 in frac_part***REMOVED***

        if factor == 1:
            if number_fraction is None:
                return [self.fmt_d % (s*int(v***REMOVED***,***REMOVED*** for (s, v***REMOVED*** in zip(ss, values***REMOVED******REMOVED***
            else:
                return [self.fmt_ds % (s*int(v***REMOVED***, f1***REMOVED*** for (s, v, f1***REMOVED*** in \
                        zip(ss, values, frac_str***REMOVED******REMOVED***
        elif factor == 60:
            deg_part, min_part = divmod(values, 60***REMOVED***
            if number_fraction is None:
                return [self.fmt_d_m % (s1, d1, m1***REMOVED*** \
                        for s1, d1, m1 in zip(signs, deg_part, min_part***REMOVED******REMOVED***
            else:
                return [self.fmt_d_ms % (s, d1, m1, f1***REMOVED*** \
                        for s, d1, m1, f1 in zip(signs, deg_part, min_part, frac_str***REMOVED******REMOVED***

        elif factor == 3600:
            if ss[-1***REMOVED*** == -1:
                inverse_order = True
                values = values[::-1***REMOVED***
                sings = signs[::-1***REMOVED***
            else:
                inverse_order = False

            l_hm_old = ""
            r = [***REMOVED***

            deg_part, min_part_ = divmod(values, 3600***REMOVED***
            min_part, sec_part = divmod(min_part_, 60***REMOVED***

            if number_fraction is None:
                sec_str = [self.fmt_s_partial % (s1,***REMOVED*** for s1 in sec_part***REMOVED***
            else:
                sec_str = [self.fmt_ss_partial % (s1, f1***REMOVED*** for s1, f1 in zip(sec_part, frac_str***REMOVED******REMOVED***

            for s, d1, m1, s1 in zip(signs, deg_part, min_part, sec_str***REMOVED***:
                l_hm = self.fmt_d_m_partial % (s, d1, m1***REMOVED***
                if l_hm != l_hm_old:
                    l_hm_old = l_hm
                    l = l_hm + s1 #l_s
                else:
                    l = "$"+s1 #l_s
                r.append(l***REMOVED***

            if inverse_order:
                return r[::-1***REMOVED***
            else:
                return r

        else: # factor > 3600.
            return [r"$%s^{\circ***REMOVED***$" % (str(v***REMOVED***,***REMOVED*** for v in ss*values***REMOVED***

class FormatterHMS(FormatterDMS***REMOVED***:
    deg_mark = "^\mathrm{h***REMOVED***"
    min_mark = "^\mathrm{m***REMOVED***"
    sec_mark = "^\mathrm{s***REMOVED***"

    fmt_d = "$%d"+deg_mark+"$"
    fmt_ds = r"$%d.\!\!"+deg_mark+"%s$"

    # %s for signe
    fmt_d_m = r"$%s%d"+deg_mark+"\,%02d"+min_mark+"$"
    fmt_d_ms = r"$%s%d"+deg_mark+"\,%02d.\!\!"+min_mark+"%s$"


    fmt_d_m_partial = "$%s%d"+deg_mark+"\,%02d"+min_mark+"\,"
    fmt_s_partial = "%02d"+sec_mark+"$"
    fmt_ss_partial = "%02d.\!\!"+sec_mark+"%s$"


    def __call__(self, direction, factor, values***REMOVED***: # hour
        return FormatterDMS.__call__(self, direction, factor, np.asarray(values***REMOVED***/15.***REMOVED***





class ExtremeFinderCycle(ExtremeFinderSimple***REMOVED***:
    ***REMOVED***
    When there is a cycle, e.g., longitude goes from 0-360.
    ***REMOVED***
    def __init__(self,
                 nx, ny,
                 lon_cycle = 360.,
                 lat_cycle = None,
                 lon_minmax = None,
                 lat_minmax = (-90, 90***REMOVED***
                 ***REMOVED***:
        #self.transfrom_xy = transform_xy
        #self.inv_transfrom_xy = inv_transform_xy
        self.nx, self.ny = nx, ny
        self.lon_cycle, self.lat_cycle = lon_cycle, lat_cycle
        self.lon_minmax = lon_minmax
        self.lat_minmax = lat_minmax


    def __call__(self, transform_xy, x1, y1, x2, y2***REMOVED***:
        ***REMOVED***
        get extreme values.

        x1, y1, x2, y2 in image coordinates (0-based***REMOVED***
        nx, ny : number of divisions in each axis
        ***REMOVED***
        x_, y_ = np.linspace(x1, x2, self.nx***REMOVED***, np.linspace(y1, y2, self.ny***REMOVED***
        x, y = np.meshgrid(x_, y_***REMOVED***
        lon, lat = transform_xy(np.ravel(x***REMOVED***, np.ravel(y***REMOVED******REMOVED***

        # iron out jumps, but algorithm should be improved.
        # This is just naive way of doing and my fail for some cases.
        # Consider replacing this with numpy.unwrap
        # We are ignoring invalid warnings. They are triggered when
        # comparing arrays with NaNs using > We are already handling
        # that correctly using np.nanmin and np.nanmax
        with np.errstate(invalid='ignore'***REMOVED***:
            if self.lon_cycle is not None:
                lon0 = np.nanmin(lon***REMOVED***
                lon -= 360. * ((lon - lon0***REMOVED*** > 180.***REMOVED***
            if self.lat_cycle is not None:
                lat0 = np.nanmin(lat***REMOVED***
                lat -= 360. * ((lat - lat0***REMOVED*** > 180.***REMOVED***

        lon_min, lon_max = np.nanmin(lon***REMOVED***, np.nanmax(lon***REMOVED***
        lat_min, lat_max = np.nanmin(lat***REMOVED***, np.nanmax(lat***REMOVED***

        lon_min, lon_max, lat_min, lat_max = \
                 self._adjust_extremes(lon_min, lon_max, lat_min, lat_max***REMOVED***

        return lon_min, lon_max, lat_min, lat_max


    def _adjust_extremes(self, lon_min, lon_max, lat_min, lat_max***REMOVED***:

        lon_min, lon_max, lat_min, lat_max = \
                 self._add_pad(lon_min, lon_max, lat_min, lat_max***REMOVED***

        # check cycle
        if self.lon_cycle:
            lon_max = min(lon_max, lon_min + self.lon_cycle***REMOVED***
        if self.lat_cycle:
            lat_max = min(lat_max, lat_min + self.lat_cycle***REMOVED***

        if self.lon_minmax is not None:
            min0 = self.lon_minmax[0***REMOVED***
            lon_min = max(min0, lon_min***REMOVED***
            max0 = self.lon_minmax[1***REMOVED***
            lon_max = min(max0, lon_max***REMOVED***

        if self.lat_minmax is not None:
            min0 = self.lat_minmax[0***REMOVED***
            lat_min = max(min0, lat_min***REMOVED***
            max0 = self.lat_minmax[1***REMOVED***
            lat_max = min(max0, lat_max***REMOVED***

        return lon_min, lon_max, lat_min, lat_max





if __name__ == "__main__":
    #test2(***REMOVED***
    #print select_step360(21.2, 33.3, 5***REMOVED***
    #print select_step360(20+21.2/60., 21+33.3/60., 5***REMOVED***
    #print select_step360(20.5+21.2/3600., 20.5+33.3/3600., 5***REMOVED***

    # test threshold factor
    print(select_step360(20.5+11.2/3600., 20.5+53.3/3600., 5,
                         threshold_factor=60***REMOVED******REMOVED***

    print(select_step360(20.5+11.2/3600., 20.5+53.3/3600., 5,
                         threshold_factor=1***REMOVED******REMOVED***

    fmt = FormatterDMS(***REMOVED***
    #print fmt("left", 60, [0, -30, -60***REMOVED******REMOVED***
    print(fmt("left", 600, [12301, 12302, 12303***REMOVED******REMOVED******REMOVED***

    print(select_step360(20.5+21.2/3600., 20.5+21.4/3600., 5***REMOVED******REMOVED***
    print(fmt("left", 36000, [738210, 738215, 738220***REMOVED******REMOVED******REMOVED***
    print(fmt("left", 360000, [7382120, 7382125, 7382130***REMOVED******REMOVED******REMOVED***
    print(fmt("left", 1., [45, 46, 47***REMOVED******REMOVED******REMOVED***
    print(fmt("left", 10., [452, 453, 454***REMOVED******REMOVED******REMOVED***

if 0:
    print(select_step360(20+21.2/60., 21+33.3/60., 5***REMOVED******REMOVED***
    print(select_step360(20.5+21.2/3600., 20.5+33.3/3600., 5***REMOVED******REMOVED***
    print(select_step360(20+21.2/60., 20+53.3/60., 5***REMOVED******REMOVED***

    ###
    levs, n, factor = select_step360(20.5+21.2/3600., 20.5+27.25/3600., 5***REMOVED***
    levs = levs * 0.1
    fmt = FormatterDMS(***REMOVED***
    #print fmt("left", 60, [0, -30, -60***REMOVED******REMOVED***
    print(fmt("left", factor, levs***REMOVED******REMOVED***


    print(select_step(-180, 180, 10, hour=False***REMOVED******REMOVED***
    print(select_step(-12, 12, 10, hour=True***REMOVED******REMOVED***

    fmt = FormatterDMS(***REMOVED***
    #print fmt("left", 60, [0, -30, -60***REMOVED******REMOVED***
    print(fmt("left", 3600, [0, -30, -60***REMOVED******REMOVED******REMOVED***
