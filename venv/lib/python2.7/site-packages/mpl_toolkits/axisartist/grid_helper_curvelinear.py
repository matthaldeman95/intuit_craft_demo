***REMOVED***
An experimental support for curvilinear grid.
***REMOVED***
from __future__ import (absolute_import, division, print_function,
                        unicode_literals***REMOVED***

from matplotlib.externals import six
from matplotlib.externals.six.moves import zip

from itertools import chain
from .grid_finder import GridFinder

from  .axislines import AxisArtistHelper, GridHelperBase
from  .axis_artist import AxisArtist
from matplotlib.transforms import Affine2D, IdentityTransform
import numpy as np

from matplotlib.path import Path

class FixedAxisArtistHelper(AxisArtistHelper.Fixed***REMOVED***:
    ***REMOVED***
    Helper class for a fixed axis.
    ***REMOVED***

    def __init__(self, grid_helper, side, nth_coord_ticks=None***REMOVED***:
        ***REMOVED***
        nth_coord = along which coordinate value varies.
         nth_coord = 0 ->  x axis, nth_coord = 1 -> y axis
        ***REMOVED***

        super(FixedAxisArtistHelper, self***REMOVED***.__init__( \
            loc=side,
            ***REMOVED***

        self.grid_helper = grid_helper
        if nth_coord_ticks is None:
            nth_coord_ticks = self.nth_coord
        self.nth_coord_ticks = nth_coord_ticks

        self.side = side
        self._limits_inverted = False

    def update_lim(self, axes***REMOVED***:
        self.grid_helper.update_lim(axes***REMOVED***

        if self.nth_coord == 0:
            xy1, xy2 = axes.get_ylim(***REMOVED***
        else:
            xy1, xy2 = axes.get_xlim(***REMOVED***

        if xy1 > xy2:
            self._limits_inverted = True
        else:
            self._limits_inverted = False


    def change_tick_coord(self, coord_number=None***REMOVED***:
        if coord_number is None:
            self.nth_coord_ticks = 1 - self.nth_coord_ticks
        elif coord_number in [0, 1***REMOVED***:
            self.nth_coord_ticks = coord_number
        else:
            raise Exception("wrong coord number"***REMOVED***


    def get_tick_transform(self, axes***REMOVED***:
        return axes.transData

    def get_tick_iterators(self, axes***REMOVED***:
        ***REMOVED***tick_loc, tick_angle, tick_label***REMOVED***

        g = self.grid_helper

        if self._limits_inverted:
            side = {"left":"right","right":"left",
                    "top":"bottom", "bottom":"top"***REMOVED***[self.side***REMOVED***
        else:
            side = self.side

        ti1 = g.get_tick_iterator(self.nth_coord_ticks, side***REMOVED***
        ti2 = g.get_tick_iterator(1-self.nth_coord_ticks, side, minor=True***REMOVED***

        #ti2 = g.get_tick_iterator(1-self.nth_coord_ticks, self.side, minor=True***REMOVED***

        return chain(ti1, ti2***REMOVED***, iter([***REMOVED******REMOVED***



class FloatingAxisArtistHelper(AxisArtistHelper.Floating***REMOVED***:

    def __init__(self, grid_helper, nth_coord, value, axis_direction=None***REMOVED***:
        ***REMOVED***
        nth_coord = along which coordinate value varies.
         nth_coord = 0 ->  x axis, nth_coord = 1 -> y axis
        ***REMOVED***

        super(FloatingAxisArtistHelper, self***REMOVED***.__init__(nth_coord,
                                                       value,
                                                       ***REMOVED***
        self.value = value
        self.grid_helper = grid_helper
        self._extremes = None, None

        self._get_line_path = None # a method that returns a Path.
        self._line_num_points = 100 # number of points to create a line

    def set_extremes(self, e1, e2***REMOVED***:
        self._extremes = e1, e2

    def update_lim(self, axes***REMOVED***:
        self.grid_helper.update_lim(axes***REMOVED***

        x1, x2 = axes.get_xlim(***REMOVED***
        y1, y2 = axes.get_ylim(***REMOVED***
        grid_finder = self.grid_helper.grid_finder
        extremes = grid_finder.extreme_finder(grid_finder.inv_transform_xy,
                                              x1, y1, x2, y2***REMOVED***

        extremes = list(extremes***REMOVED***
        e1, e2 = self._extremes # ranges of other coordinates
        if self.nth_coord == 0:
            if e1 is not None:
                extremes[2***REMOVED*** = max(e1, extremes[2***REMOVED******REMOVED***
            if e2 is not None:
                extremes[3***REMOVED*** = min(e2, extremes[3***REMOVED******REMOVED***
        elif self.nth_coord == 1:
            if e1 is not None:
                extremes[0***REMOVED*** = max(e1, extremes[0***REMOVED******REMOVED***
            if e2 is not None:
                extremes[1***REMOVED*** = min(e2, extremes[1***REMOVED******REMOVED***

        grid_info = dict(***REMOVED***
        lon_min, lon_max, lat_min, lat_max = extremes
        lon_levs, lon_n, lon_factor = \
                  grid_finder.grid_locator1(lon_min, lon_max***REMOVED***
        lat_levs, lat_n, lat_factor = \
                  grid_finder.grid_locator2(lat_min, lat_max***REMOVED***
        grid_info["extremes"***REMOVED*** = extremes

        grid_info["lon_info"***REMOVED*** = lon_levs, lon_n, lon_factor
        grid_info["lat_info"***REMOVED*** = lat_levs, lat_n, lat_factor

        grid_info["lon_labels"***REMOVED*** = grid_finder.tick_formatter1("bottom",
                                                              lon_factor,
                                                              lon_levs***REMOVED***

        grid_info["lat_labels"***REMOVED*** = grid_finder.tick_formatter2("bottom",
                                                              lat_factor,
                                                              lat_levs***REMOVED***

        grid_finder = self.grid_helper.grid_finder

        #e1, e2 = self._extremes # ranges of other coordinates
        if self.nth_coord == 0:
            xx0 = np.linspace(self.value, self.value, self._line_num_points***REMOVED***
            yy0 = np.linspace(extremes[2***REMOVED***, extremes[3***REMOVED***, self._line_num_points***REMOVED***
            xx, yy = grid_finder.transform_xy(xx0, yy0***REMOVED***
        elif self.nth_coord == 1:
            xx0 = np.linspace(extremes[0***REMOVED***, extremes[1***REMOVED***, self._line_num_points***REMOVED***
            yy0 = np.linspace(self.value, self.value, self._line_num_points***REMOVED***
            xx, yy = grid_finder.transform_xy(xx0, yy0***REMOVED***

        grid_info["line_xy"***REMOVED*** = xx, yy
        self.grid_info = grid_info

    def get_axislabel_transform(self, axes***REMOVED***:
        return Affine2D(***REMOVED*** #axes.transData

    def get_axislabel_pos_angle(self, axes***REMOVED***:

        extremes = self.grid_info["extremes"***REMOVED***

        if self.nth_coord == 0:
            xx0 = self.value
            yy0 = (extremes[2***REMOVED***+extremes[3***REMOVED******REMOVED***/2.
            dxx, dyy = 0., abs(extremes[2***REMOVED***-extremes[3***REMOVED******REMOVED***/1000.
        elif self.nth_coord == 1:
            xx0 = (extremes[0***REMOVED***+extremes[1***REMOVED******REMOVED***/2.
            yy0 = self.value
            dxx, dyy = abs(extremes[0***REMOVED***-extremes[1***REMOVED******REMOVED***/1000., 0.

        grid_finder = self.grid_helper.grid_finder
        xx1, yy1 = grid_finder.transform_xy([xx0***REMOVED***, [yy0***REMOVED******REMOVED***

        trans_passingthrough_point = axes.transData + axes.transAxes.inverted(***REMOVED***
        p = trans_passingthrough_point.transform_point([xx1[0***REMOVED***, yy1[0***REMOVED******REMOVED******REMOVED***


        if (0. <= p[0***REMOVED*** <= 1.***REMOVED*** and (0. <= p[1***REMOVED*** <= 1.***REMOVED***:
            xx1c, yy1c = axes.transData.transform_point([xx1[0***REMOVED***, yy1[0***REMOVED******REMOVED******REMOVED***
            xx2, yy2 = grid_finder.transform_xy([xx0+dxx***REMOVED***, [yy0+dyy***REMOVED******REMOVED***
            xx2c, yy2c = axes.transData.transform_point([xx2[0***REMOVED***, yy2[0***REMOVED******REMOVED******REMOVED***

            return (xx1c, yy1c***REMOVED***, np.arctan2(yy2c-yy1c, xx2c-xx1c***REMOVED***/np.pi*180.
        else:
            return None, None




    def get_tick_transform(self, axes***REMOVED***:
        return IdentityTransform(***REMOVED*** #axes.transData

    def get_tick_iterators(self, axes***REMOVED***:
        ***REMOVED***tick_loc, tick_angle, tick_label, (optionally***REMOVED*** tick_label***REMOVED***

        grid_finder = self.grid_helper.grid_finder

        lat_levs, lat_n, lat_factor = self.grid_info["lat_info"***REMOVED***
        lat_levs = np.asarray(lat_levs***REMOVED***
        if lat_factor is not None:
            yy0 = lat_levs / lat_factor
            dy = 0.01 / lat_factor
        else:
            yy0 = lat_levs
            dy = 0.01

        lon_levs, lon_n, lon_factor = self.grid_info["lon_info"***REMOVED***
        lon_levs = np.asarray(lon_levs***REMOVED***
        if lon_factor is not None:
            xx0 = lon_levs / lon_factor
            dx = 0.01 / lon_factor
        else:
            xx0 = lon_levs
            dx = 0.01

        if None in self._extremes:
            e0, e1 = self._extremes
        else:
            e0, e1 = sorted(self._extremes***REMOVED***
        if e0 is None:
            e0 = -np.inf
        if e1 is None:
            e1 = np.inf

        if self.nth_coord == 0:
            mask = (e0 <= yy0***REMOVED*** & (yy0 <= e1***REMOVED***
            #xx0, yy0 = xx0[mask***REMOVED***, yy0[mask***REMOVED***
            yy0 = yy0[mask***REMOVED***
        elif self.nth_coord == 1:
            mask = (e0 <= xx0***REMOVED*** & (xx0 <= e1***REMOVED***
            #xx0, yy0 = xx0[mask***REMOVED***, yy0[mask***REMOVED***
            xx0 = xx0[mask***REMOVED***

        def transform_xy(x, y***REMOVED***:
            x1, y1 = grid_finder.transform_xy(x, y***REMOVED***
            x2y2 = axes.transData.transform(np.array([x1, y1***REMOVED******REMOVED***.transpose(***REMOVED******REMOVED***
            x2, y2 = x2y2.transpose(***REMOVED***
            return x2, y2

        # find angles
        if self.nth_coord == 0:
            xx0 = np.empty_like(yy0***REMOVED***
            xx0.fill(self.value***REMOVED***

            xx1, yy1 = transform_xy(xx0, yy0***REMOVED***

            xx00 = xx0.copy(***REMOVED***
            xx00[xx0+dx>e1***REMOVED*** -= dx
            xx1a, yy1a = transform_xy(xx00, yy0***REMOVED***
            xx1b, yy1b = transform_xy(xx00+dx, yy0***REMOVED***

            xx2a, yy2a = transform_xy(xx0, yy0***REMOVED***
            xx2b, yy2b = transform_xy(xx0, yy0+dy***REMOVED***

            labels = self.grid_info["lat_labels"***REMOVED***
            labels = [l for l, m in zip(labels, mask***REMOVED*** if m***REMOVED***

        elif self.nth_coord == 1:
            yy0 = np.empty_like(xx0***REMOVED***
            yy0.fill(self.value***REMOVED***

            xx1, yy1 = transform_xy(xx0, yy0***REMOVED***

            xx1a, yy1a = transform_xy(xx0, yy0***REMOVED***
            xx1b, yy1b = transform_xy(xx0, yy0+dy***REMOVED***

            xx00 = xx0.copy(***REMOVED***
            xx00[xx0+dx>e1***REMOVED*** -= dx
            xx2a, yy2a = transform_xy(xx00, yy0***REMOVED***
            xx2b, yy2b = transform_xy(xx00+dx, yy0***REMOVED***

            labels = self.grid_info["lon_labels"***REMOVED***
            labels = [l for l, m in zip(labels, mask***REMOVED*** if m***REMOVED***


        def f1(***REMOVED***:
            dd = np.arctan2(yy1b-yy1a, xx1b-xx1a***REMOVED*** # angle normal
            dd2 = np.arctan2(yy2b-yy2a, xx2b-xx2a***REMOVED*** # angle tangent
            mm = ((yy1b-yy1a***REMOVED***==0.***REMOVED*** & ((xx1b-xx1a***REMOVED***==0.***REMOVED*** # mask where dd1 is not defined
            dd[mm***REMOVED*** = dd2[mm***REMOVED***+3.14159/2.
            #dd = np.arctan2(yy2-yy1, xx2-xx1***REMOVED*** # angle normal
            #dd2 = np.arctan2(yy3-yy1, xx3-xx1***REMOVED*** # angle tangent
            #mm = ((yy2-yy1***REMOVED***==0.***REMOVED*** & ((xx2-xx1***REMOVED***==0.***REMOVED*** # mask where dd1 is not defined
            #dd[mm***REMOVED*** = dd2[mm***REMOVED***+3.14159/2.

            #dd += 3.14159

            #dd = np.arctan2(xx2-xx1, angle_tangent-yy1***REMOVED***
            trans_tick = self.get_tick_transform(axes***REMOVED***
            tr2ax = trans_tick + axes.transAxes.inverted(***REMOVED***
            for x, y, d, d2, lab in zip(xx1, yy1, dd, dd2, labels***REMOVED***:
                c2 = tr2ax.transform_point((x, y***REMOVED******REMOVED***
                delta=0.00001
                if (0. -delta<= c2[0***REMOVED*** <= 1.+delta***REMOVED*** and \
                       (0. -delta<= c2[1***REMOVED*** <= 1.+delta***REMOVED***:
                    d1 = d/3.14159*180.
                    d2 = d2/3.14159*180.
                    yield [x, y***REMOVED***, d1, d2, lab

        return f1(***REMOVED***, iter([***REMOVED******REMOVED***

    def get_line_transform(self, axes***REMOVED***:
        return axes.transData

    def get_line(self, axes***REMOVED***:
        self.update_lim(axes***REMOVED***
        x, y = self.grid_info["line_xy"***REMOVED***

        if self._get_line_path is None:
            return Path(list(zip(x, y***REMOVED******REMOVED******REMOVED***
        else:
            return self._get_line_path(axes, x, y***REMOVED***




class GridHelperCurveLinear(GridHelperBase***REMOVED***:

    def __init__(self, aux_trans,
                 extreme_finder=None,
                 grid_locator1=None,
                 grid_locator2=None,
                 tick_formatter1=None,
                 tick_formatter2=None***REMOVED***:
        ***REMOVED***
        aux_trans : a transform from the source (curved***REMOVED*** coordinate to
        target (rectilinear***REMOVED*** coordinate. An instance of MPL's Transform
        (inverse transform should be defined***REMOVED*** or a tuple of two callable
        objects which defines the transform and its inverse. The callables
        need take two arguments of array of source coordinates and
        should return two target coordinates:
          e.g., x2, y2 = trans(x1, y1***REMOVED***
        ***REMOVED***
        super(GridHelperCurveLinear, self***REMOVED***.__init__(***REMOVED***

        self.grid_info = None
        self._old_values = None
        #self._grid_params = dict(***REMOVED***
        self._aux_trans = aux_trans

        self.grid_finder = GridFinder(aux_trans,
                                      extreme_finder,
                                      grid_locator1,
                                      grid_locator2,
                                      tick_formatter1,
                                      tick_formatter2***REMOVED***


    def update_grid_finder(self, aux_trans=None, **kw***REMOVED***:

        if aux_trans is not None:
            self.grid_finder.update_transform(aux_trans***REMOVED***

        self.grid_finder.update(**kw***REMOVED***
        self.invalidate(***REMOVED***


    def _update(self, x1, x2, y1, y2***REMOVED***:
        "bbox in 0-based image coordinates"
        # update wcsgrid

        if self.valid(***REMOVED*** and self._old_values == (x1, x2, y1, y2***REMOVED***:
            return

        self._update_grid(x1, y1, x2, y2***REMOVED***

        self._old_values = (x1, x2, y1, y2***REMOVED***

        self._force_update = False


    def new_fixed_axis(self, loc,
                       nth_coord=None,
                       axis_direction=None,
                       offset=None,
                       axes=None***REMOVED***:


        if axes is None:
            axes = self.axes

        if axis_direction is None:
            axis_direction = loc
        _helper = FixedAxisArtistHelper(self, loc,
                                        #nth_coord,
                                        nth_coord_ticks=nth_coord,
                                        ***REMOVED***

        axisline = AxisArtist(axes, _helper, axis_direction=axis_direction***REMOVED***

        return axisline


    def new_floating_axis(self, nth_coord,
                          value,
                          axes=None,
                          axis_direction="bottom"
                          ***REMOVED***:

        if axes is None:
            axes = self.axes

        _helper = FloatingAxisArtistHelper( \
            self, nth_coord, value, axis_direction***REMOVED***

        axisline = AxisArtist(axes, _helper***REMOVED***

        #_helper = FloatingAxisArtistHelper(self, nth_coord,
        #                                   value,
        #                                   label_direction=label_direction,
        #                                   ***REMOVED***

        #axisline = AxisArtistFloating(axes, _helper,
        #                              axis_direction=axis_direction***REMOVED***
        axisline.line.set_clip_on(True***REMOVED***
        axisline.line.set_clip_box(axisline.axes.bbox***REMOVED***
        #axisline.major_ticklabels.set_visible(True***REMOVED***
        #axisline.minor_ticklabels.set_visible(False***REMOVED***

        #axisline.major_ticklabels.set_rotate_along_line(True***REMOVED***
        #axisline.set_rotate_label_along_line(True***REMOVED***

        return axisline


    def _update_grid(self, x1, y1, x2, y2***REMOVED***:

        self.grid_info = self.grid_finder.get_grid_info(x1, y1, x2, y2***REMOVED***


    def get_gridlines(self, which="major", axis="both"***REMOVED***:
        grid_lines = [***REMOVED***

        if axis in ["both", "x"***REMOVED***:
            for gl in self.grid_info["lon"***REMOVED***["lines"***REMOVED***:
                grid_lines.extend(gl***REMOVED***
        if axis in ["both", "y"***REMOVED***:
            for gl in self.grid_info["lat"***REMOVED***["lines"***REMOVED***:
                grid_lines.extend(gl***REMOVED***

        return grid_lines


    def get_tick_iterator(self, nth_coord, axis_side, minor=False***REMOVED***:

        #axisnr = dict(left=0, bottom=1, right=2, top=3***REMOVED***[axis_side***REMOVED***
        angle_tangent = dict(left=90, right=90, bottom=0, top=0***REMOVED***[axis_side***REMOVED***
        #angle = [0, 90, 180, 270***REMOVED***[axisnr***REMOVED***
        lon_or_lat = ["lon", "lat"***REMOVED***[nth_coord***REMOVED***
        if not minor: # major ticks
            def f(***REMOVED***:
                for (xy, a***REMOVED***, l in zip(self.grid_info[lon_or_lat***REMOVED***["tick_locs"***REMOVED***[axis_side***REMOVED***,
                                    self.grid_info[lon_or_lat***REMOVED***["tick_labels"***REMOVED***[axis_side***REMOVED******REMOVED***:
                    angle_normal = a
                    yield xy, angle_normal, angle_tangent, l
        else:
            def f(***REMOVED***:
                for (xy, a***REMOVED***, l in zip(self.grid_info[lon_or_lat***REMOVED***["tick_locs"***REMOVED***[axis_side***REMOVED***,
                                    self.grid_info[lon_or_lat***REMOVED***["tick_labels"***REMOVED***[axis_side***REMOVED******REMOVED***:
                    angle_normal = a
                    yield xy, angle_normal, angle_tangent, ""
                #for xy, a, l in self.grid_info[lon_or_lat***REMOVED***["ticks"***REMOVED***[axis_side***REMOVED***:
                #    yield xy, a, ""

        return f(***REMOVED***



def test3(***REMOVED***:

    import numpy as np
    from matplotlib.transforms import Transform
    from matplotlib.path import Path

    class MyTransform(Transform***REMOVED***:
        input_dims = 2
        output_dims = 2
        is_separable = False

        def __init__(self, resolution***REMOVED***:
            ***REMOVED***
            Create a new Aitoff transform.  Resolution is the number of steps
            to interpolate between each input line segment to approximate its
            path in curved Aitoff space.
            ***REMOVED***
            Transform.__init__(self***REMOVED***
            self._resolution = resolution

        def transform(self, ll***REMOVED***:
            x = ll[:, 0:1***REMOVED***
            y  = ll[:, 1:2***REMOVED***

            return np.concatenate((x, y-x***REMOVED***, 1***REMOVED***

        transform.__doc__ = Transform.transform.__doc__

        transform_non_affine = transform
        transform_non_affine.__doc__ = Transform.transform_non_affine.__doc__

        def transform_path(self, path***REMOVED***:
            vertices = path.vertices
            ipath = path.interpolated(self._resolution***REMOVED***
            return Path(self.transform(ipath.vertices***REMOVED***, ipath.codes***REMOVED***
        transform_path.__doc__ = Transform.transform_path.__doc__

        transform_path_non_affine = transform_path
        transform_path_non_affine.__doc__ = Transform.transform_path_non_affine.__doc__

        def inverted(self***REMOVED***:
            return MyTransformInv(self._resolution***REMOVED***
        inverted.__doc__ = Transform.inverted.__doc__

    class MyTransformInv(Transform***REMOVED***:
        input_dims = 2
        output_dims = 2
        is_separable = False

        def __init__(self, resolution***REMOVED***:
            Transform.__init__(self***REMOVED***
            self._resolution = resolution

        def transform(self, ll***REMOVED***:
            x = ll[:, 0:1***REMOVED***
            y  = ll[:, 1:2***REMOVED***

            return np.concatenate((x, y+x***REMOVED***, 1***REMOVED***
        transform.__doc__ = Transform.transform.__doc__

        def inverted(self***REMOVED***:
            return MyTransform(self._resolution***REMOVED***
        inverted.__doc__ = Transform.inverted.__doc__



    import matplotlib.pyplot as plt
    fig = plt.figure(1***REMOVED***
    fig.clf(***REMOVED***
    tr = MyTransform(1***REMOVED***
    grid_helper = GridHelperCurveLinear(tr***REMOVED***


    from mpl_toolkits.axes_grid1.parasite_axes import host_subplot_class_factory
    from .axislines import Axes

    SubplotHost = host_subplot_class_factory(Axes***REMOVED***

    ax1 = SubplotHost(fig, 1, 1, 1, grid_helper=grid_helper***REMOVED***

    fig.add_subplot(ax1***REMOVED***

    ax2 = ParasiteAxesAuxTrans(ax1, tr, "equal"***REMOVED***
    ax1.parasites.append(ax2***REMOVED***
    ax2.plot([3, 6***REMOVED***, [5.0, 10.***REMOVED******REMOVED***

    ax1.set_aspect(1.***REMOVED***
    ax1.set_xlim(0, 10***REMOVED***
    ax1.set_ylim(0, 10***REMOVED***

    ax1.grid(True***REMOVED***
    plt.draw(***REMOVED***



def curvelinear_test2(fig***REMOVED***:
    ***REMOVED***
    polar projection, but in a rectangular box.
    ***REMOVED***
    global ax1
    import numpy as np
    from . import angle_helper
    from matplotlib.projections import PolarAxes
    from matplotlib.transforms import Affine2D

    from mpl_toolkits.axes_grid.parasite_axes import SubplotHost, \
         ParasiteAxesAuxTrans
    import matplotlib.cbook as cbook

    # PolarAxes.PolarTransform takes radian. However, we want our coordinate
    # system in degree
    tr = Affine2D(***REMOVED***.scale(np.pi/180., 1.***REMOVED*** + PolarAxes.PolarTransform(***REMOVED***

    # polar projection, which involves cycle, and also has limits in
    # its coordinates, needs a special method to find the extremes
    # (min, max of the coordinate within the view***REMOVED***.

    # 20, 20 : number of sampling points along x, y direction
    extreme_finder = angle_helper.ExtremeFinderCycle(20, 20,
                                                     lon_cycle = 360,
                                                     lat_cycle = None,
                                                     lon_minmax = None,
                                                     lat_minmax = (0, np.inf***REMOVED***,
                                                     ***REMOVED***

    grid_locator1 = angle_helper.LocatorDMS(5***REMOVED***
    # Find a grid values appropriate for the coordinate (degree,
    # minute, second***REMOVED***.

    tick_formatter1 = angle_helper.FormatterDMS(***REMOVED***
    # And also uses an appropriate formatter.  Note that,the
    # acceptable Locator and Formatter class is a bit different than
    # that of mpl's, and you cannot directly use mpl's Locator and
    # Formatter here (but may be possible in the future***REMOVED***.

    grid_helper = GridHelperCurveLinear(tr,
                                        extreme_finder=extreme_finder,
                                        grid_locator1=grid_locator1,
                                        tick_formatter1=tick_formatter1
                                        ***REMOVED***


    ax1 = SubplotHost(fig, 1, 1, 1, grid_helper=grid_helper***REMOVED***

    # make ticklabels of right and top axis visible.
    ax1.axis["right"***REMOVED***.major_ticklabels.set_visible(True***REMOVED***
    ax1.axis["top"***REMOVED***.major_ticklabels.set_visible(True***REMOVED***

    # let right axis shows ticklabels for 1st coordinate (angle***REMOVED***
    ax1.axis["right"***REMOVED***.get_helper(***REMOVED***.nth_coord_ticks=0
    # let bottom axis shows ticklabels for 2nd coordinate (radius***REMOVED***
    ax1.axis["bottom"***REMOVED***.get_helper(***REMOVED***.nth_coord_ticks=1

    fig.add_subplot(ax1***REMOVED***

    grid_helper = ax1.get_grid_helper(***REMOVED***
    ax1.axis["lat"***REMOVED*** = axis = grid_helper.new_floating_axis(0, 60, axes=ax1***REMOVED***
    axis.label.set_text("Test"***REMOVED***
    axis.label.set_visible(True***REMOVED***
    #axis._extremes = 2, 10
    #axis.label.set_text("Test"***REMOVED***
    #axis.major_ticklabels.set_visible(False***REMOVED***
    #axis.major_ticks.set_visible(False***REMOVED***
    axis.get_helper(***REMOVED***._extremes=2, 10

    ax1.axis["lon"***REMOVED*** = axis = grid_helper.new_floating_axis(1, 6, axes=ax1***REMOVED***
    #axis.major_ticklabels.set_visible(False***REMOVED***
    #axis.major_ticks.set_visible(False***REMOVED***
    axis.label.set_text("Test 2"***REMOVED***
    axis.get_helper(***REMOVED***._extremes=-180, 90

    # A parasite axes with given transform
    ax2 = ParasiteAxesAuxTrans(ax1, tr, "equal"***REMOVED***
    # note that ax2.transData == tr + ax1.transData
    # Anthing you draw in ax2 will match the ticks and grids of ax1.
    ax1.parasites.append(ax2***REMOVED***
    intp = cbook.simple_linear_interpolation
    ax2.plot(intp(np.array([0, 30***REMOVED******REMOVED***, 50***REMOVED***,
             intp(np.array([10., 10.***REMOVED******REMOVED***, 50***REMOVED******REMOVED***

    ax1.set_aspect(1.***REMOVED***
    ax1.set_xlim(-5, 12***REMOVED***
    ax1.set_ylim(-5, 10***REMOVED***

    ax1.grid(True***REMOVED***


def curvelinear_test3(fig***REMOVED***:
    ***REMOVED***
    polar projection, but in a rectangular box.
    ***REMOVED***
    global ax1, axis
    import numpy as np
    from . import angle_helper
    from matplotlib.projections import PolarAxes
    from matplotlib.transforms import Affine2D

    from mpl_toolkits.axes_grid.parasite_axes import SubplotHost

    # PolarAxes.PolarTransform takes radian. However, we want our coordinate
    # system in degree
    tr = Affine2D(***REMOVED***.scale(np.pi/180., 1.***REMOVED*** + PolarAxes.PolarTransform(***REMOVED***

    # polar projection, which involves cycle, and also has limits in
    # its coordinates, needs a special method to find the extremes
    # (min, max of the coordinate within the view***REMOVED***.

    # 20, 20 : number of sampling points along x, y direction
    extreme_finder = angle_helper.ExtremeFinderCycle(20, 20,
                                                     lon_cycle = 360,
                                                     lat_cycle = None,
                                                     lon_minmax = None,
                                                     lat_minmax = (0, np.inf***REMOVED***,
                                                     ***REMOVED***

    grid_locator1 = angle_helper.LocatorDMS(12***REMOVED***
    # Find a grid values appropriate for the coordinate (degree,
    # minute, second***REMOVED***.

    tick_formatter1 = angle_helper.FormatterDMS(***REMOVED***
    # And also uses an appropriate formatter.  Note that,the
    # acceptable Locator and Formatter class is a bit different than
    # that of mpl's, and you cannot directly use mpl's Locator and
    # Formatter here (but may be possible in the future***REMOVED***.

    grid_helper = GridHelperCurveLinear(tr,
                                        extreme_finder=extreme_finder,
                                        grid_locator1=grid_locator1,
                                        tick_formatter1=tick_formatter1
                                        ***REMOVED***


    ax1 = SubplotHost(fig, 1, 1, 1, grid_helper=grid_helper***REMOVED***

    for axis in list(six.itervalues(ax1.axis***REMOVED******REMOVED***:
        axis.set_visible(False***REMOVED***

    fig.add_subplot(ax1***REMOVED***

    grid_helper = ax1.get_grid_helper(***REMOVED***
    ax1.axis["lat1"***REMOVED*** = axis = grid_helper.new_floating_axis(0, 130,
                                                            axes=ax1,
                                                            axis_direction="left"
                                                            ***REMOVED***
    axis.label.set_text("Test"***REMOVED***
    axis.label.set_visible(True***REMOVED***
    axis.get_helper(***REMOVED***._extremes=0.001, 10



    grid_helper = ax1.get_grid_helper(***REMOVED***
    ax1.axis["lat2"***REMOVED*** = axis = grid_helper.new_floating_axis(0, 50, axes=ax1,
                                                            axis_direction="right"***REMOVED***
    axis.label.set_text("Test"***REMOVED***
    axis.label.set_visible(True***REMOVED***
    axis.get_helper(***REMOVED***._extremes=0.001, 10

    ax1.axis["lon"***REMOVED*** = axis = grid_helper.new_floating_axis(1, 10,
                                                           axes=ax1,
                                                           axis_direction="bottom"***REMOVED***
    axis.label.set_text("Test 2"***REMOVED***
    axis.get_helper(***REMOVED***._extremes= 50, 130
    axis.major_ticklabels.set_axis_direction("top"***REMOVED***
    axis.label.set_axis_direction("top"***REMOVED***

    grid_helper.grid_finder.grid_locator1.den = 5
    grid_helper.grid_finder.grid_locator2._nbins = 5


#     # A parasite axes with given transform
#     ax2 = ParasiteAxesAuxTrans(ax1, tr, "equal"***REMOVED***
#     # note that ax2.transData == tr + ax1.transData
#     # Anthing you draw in ax2 will match the ticks and grids of ax1.
#     ax1.parasites.append(ax2***REMOVED***
#     intp = cbook.simple_linear_interpolation
#     ax2.plot(intp(np.array([0, 30***REMOVED******REMOVED***, 50***REMOVED***,
#              intp(np.array([10., 10.***REMOVED******REMOVED***, 50***REMOVED******REMOVED***

    ax1.set_aspect(1.***REMOVED***
    ax1.set_xlim(-5, 12***REMOVED***
    ax1.set_ylim(-5, 10***REMOVED***

    ax1.grid(True***REMOVED***

if __name__ == "__main__":
    import matplotlib.pyplot as plt
    fig = plt.figure(1, figsize=(5, 5***REMOVED******REMOVED***
    fig.clf(***REMOVED***

    #test3(***REMOVED***
    #curvelinear_test2(fig***REMOVED***
    curvelinear_test3(fig***REMOVED***

    #plt.draw(***REMOVED***
    plt.show(***REMOVED***
