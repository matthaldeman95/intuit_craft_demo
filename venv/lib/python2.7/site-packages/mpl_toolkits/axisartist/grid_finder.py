from __future__ import (absolute_import, division, print_function,
                        unicode_literals***REMOVED***

from matplotlib.externals import six

import numpy as np
import matplotlib.cbook as mcbook
from matplotlib.transforms import Bbox
from . import clip_path
clip_line_to_rect = clip_path.clip_line_to_rect

import matplotlib.ticker as mticker
from matplotlib.transforms import Transform

# extremes finder

class ExtremeFinderSimple(object***REMOVED***:
    def __init__(self, nx, ny***REMOVED***:
        self.nx, self.ny = nx, ny

    def __call__(self, transform_xy, x1, y1, x2, y2***REMOVED***:
        ***REMOVED***
        get extreme values.

        x1, y1, x2, y2 in image coordinates (0-based***REMOVED***
        nx, ny : number of division in each axis
        ***REMOVED***
        x_, y_ = np.linspace(x1, x2, self.nx***REMOVED***, np.linspace(y1, y2, self.ny***REMOVED***
        x, y = np.meshgrid(x_, y_***REMOVED***
        lon, lat = transform_xy(np.ravel(x***REMOVED***, np.ravel(y***REMOVED******REMOVED***

        lon_min, lon_max = lon.min(***REMOVED***, lon.max(***REMOVED***
        lat_min, lat_max = lat.min(***REMOVED***, lat.max(***REMOVED***

        return self._add_pad(lon_min, lon_max, lat_min, lat_max***REMOVED***

    def _add_pad(self, lon_min, lon_max, lat_min, lat_max***REMOVED***:
        ***REMOVED*** a small amount of padding is added because the current
        clipping algorithms seems to fail when the gridline ends at
        the bbox boundary.
        ***REMOVED***
        dlon = (lon_max - lon_min***REMOVED*** / self.nx
        dlat = (lat_max - lat_min***REMOVED*** / self.ny

        lon_min, lon_max = lon_min - dlon, lon_max + dlon
        lat_min, lat_max = lat_min - dlat, lat_max + dlat

        return lon_min, lon_max, lat_min, lat_max



class GridFinderBase(object***REMOVED***:
    def __init__(self,
                 extreme_finder,
                 grid_locator1,
                 grid_locator2,
                 tick_formatter1=None,
                 tick_formatter2=None***REMOVED***:
        ***REMOVED***
        the transData of the axes to the world coordinate.
        locator1, locator2 : grid locator for 1st and 2nd axis.

        Derived must define "transform_xy, inv_transform_xy"
        (may use update_transform***REMOVED***
        ***REMOVED***
        super(GridFinderBase, self***REMOVED***.__init__(***REMOVED***

        self.extreme_finder = extreme_finder
        self.grid_locator1 = grid_locator1
        self.grid_locator2 = grid_locator2
        self.tick_formatter1 = tick_formatter1
        self.tick_formatter2 = tick_formatter2

    def get_grid_info(self,
                      x1, y1, x2, y2***REMOVED***:
        ***REMOVED***
        lon_values, lat_values : list of grid values. if integer is given,
                           rough number of grids in each direction.
        ***REMOVED***

        extremes = self.extreme_finder(self.inv_transform_xy, x1, y1, x2, y2***REMOVED***

        # min & max rage of lat (or lon***REMOVED*** for each grid line will be drawn.
        # i.e., gridline of lon=0 will be drawn from lat_min to lat_max.

        lon_min, lon_max, lat_min, lat_max = extremes
        lon_levs, lon_n, lon_factor = \
                  self.grid_locator1(lon_min, lon_max***REMOVED***
        lat_levs, lat_n, lat_factor = \
                  self.grid_locator2(lat_min, lat_max***REMOVED***

        if lon_factor is None:
            lon_values = np.asarray(lon_levs[:lon_n***REMOVED******REMOVED***
        else:
            lon_values = np.asarray(lon_levs[:lon_n***REMOVED***/lon_factor***REMOVED***
        if lat_factor is None:
            lat_values = np.asarray(lat_levs[:lat_n***REMOVED******REMOVED***
        else:
            lat_values = np.asarray(lat_levs[:lat_n***REMOVED***/lat_factor***REMOVED***


        lon_lines, lat_lines = self._get_raw_grid_lines(lon_values,
                                                        lat_values,
                                                        lon_min, lon_max,
                                                        lat_min, lat_max***REMOVED***

        ddx = (x2-x1***REMOVED****1.e-10
        ddy = (y2-y1***REMOVED****1.e-10
        bb = Bbox.from_extents(x1-ddx, y1-ddy, x2+ddx, y2+ddy***REMOVED***

        grid_info = {***REMOVED***
        grid_info["extremes"***REMOVED*** = extremes
        grid_info["lon_lines"***REMOVED*** = lon_lines
        grid_info["lat_lines"***REMOVED*** = lat_lines

        grid_info["lon"***REMOVED*** = self._clip_grid_lines_and_find_ticks(lon_lines,
                                                                lon_values,
                                                                lon_levs,
                                                                bb***REMOVED***

        grid_info["lat"***REMOVED*** = self._clip_grid_lines_and_find_ticks(lat_lines,
                                                                lat_values,
                                                                lat_levs,
                                                                bb***REMOVED***

        tck_labels = grid_info["lon"***REMOVED***["tick_labels"***REMOVED*** = dict(***REMOVED***
        for direction in ["left", "bottom", "right", "top"***REMOVED***:
            levs = grid_info["lon"***REMOVED***["tick_levels"***REMOVED***[direction***REMOVED***
            tck_labels[direction***REMOVED*** = self.tick_formatter1(direction,
                                                         lon_factor, levs***REMOVED***

        tck_labels = grid_info["lat"***REMOVED***["tick_labels"***REMOVED*** = dict(***REMOVED***
        for direction in ["left", "bottom", "right", "top"***REMOVED***:
            levs = grid_info["lat"***REMOVED***["tick_levels"***REMOVED***[direction***REMOVED***
            tck_labels[direction***REMOVED*** = self.tick_formatter2(direction,
                                                         lat_factor, levs***REMOVED***

        return grid_info


    def _get_raw_grid_lines(self,
                            lon_values, lat_values,
                            lon_min, lon_max, lat_min, lat_max***REMOVED***:

        lons_i = np.linspace(lon_min, lon_max, 100***REMOVED*** # for interpolation
        lats_i = np.linspace(lat_min, lat_max, 100***REMOVED***

        lon_lines = [self.transform_xy(np.zeros_like(lats_i***REMOVED***+lon, lats_i***REMOVED*** \
                     for lon in lon_values***REMOVED***
        lat_lines = [self.transform_xy(lons_i, np.zeros_like(lons_i***REMOVED***+lat***REMOVED*** \
                     for lat in lat_values***REMOVED***

        return lon_lines, lat_lines


    def _clip_grid_lines_and_find_ticks(self, lines, values, levs, bb***REMOVED***:
        gi = dict(***REMOVED***
        gi["values"***REMOVED*** = [***REMOVED***
        gi["levels"***REMOVED*** = [***REMOVED***
        gi["tick_levels"***REMOVED*** = dict(left=[***REMOVED***, bottom=[***REMOVED***, right=[***REMOVED***, top=[***REMOVED******REMOVED***
        gi["tick_locs"***REMOVED*** = dict(left=[***REMOVED***, bottom=[***REMOVED***, right=[***REMOVED***, top=[***REMOVED******REMOVED***
        gi["lines"***REMOVED*** = [***REMOVED***

        tck_levels = gi["tick_levels"***REMOVED***
        tck_locs = gi["tick_locs"***REMOVED***
        for (lx, ly***REMOVED***, v, lev in zip(lines, values, levs***REMOVED***:
            xy, tcks = clip_line_to_rect(lx, ly, bb***REMOVED***
            if not xy:
                continue
            gi["levels"***REMOVED***.append(v***REMOVED***
            gi["lines"***REMOVED***.append(xy***REMOVED***

            for tck, direction in zip(tcks, ["left", "bottom", "right", "top"***REMOVED******REMOVED***:
                for t in tck:
                    tck_levels[direction***REMOVED***.append(lev***REMOVED***
                    tck_locs[direction***REMOVED***.append(t***REMOVED***

        return gi


    def update_transform(self, aux_trans***REMOVED***:
        if isinstance(aux_trans, Transform***REMOVED***:
            def transform_xy(x, y***REMOVED***:
                x, y = np.asarray(x***REMOVED***, np.asarray(y***REMOVED***
                ll1 = np.concatenate((x[:,np.newaxis***REMOVED***, y[:,np.newaxis***REMOVED******REMOVED***, 1***REMOVED***
                ll2 = aux_trans.transform(ll1***REMOVED***
                lon, lat = ll2[:,0***REMOVED***, ll2[:,1***REMOVED***
                return lon, lat

            def inv_transform_xy(x, y***REMOVED***:
                x, y = np.asarray(x***REMOVED***, np.asarray(y***REMOVED***
                ll1 = np.concatenate((x[:,np.newaxis***REMOVED***, y[:,np.newaxis***REMOVED******REMOVED***, 1***REMOVED***
                ll2 = aux_trans.inverted(***REMOVED***.transform(ll1***REMOVED***
                lon, lat = ll2[:,0***REMOVED***, ll2[:,1***REMOVED***
                return lon, lat

        else:
            transform_xy, inv_transform_xy = aux_trans

        self.transform_xy = transform_xy
        self.inv_transform_xy = inv_transform_xy


    def update(self, **kw***REMOVED***:
        for k in kw:
            if k in ["extreme_finder",
                     "grid_locator1",
                     "grid_locator2",
                     "tick_formatter1",
                     "tick_formatter2"***REMOVED***:
                setattr(self, k, kw[k***REMOVED******REMOVED***
            else:
                raise ValueError("unknown update property '%s'" % k***REMOVED***




class GridFinder(GridFinderBase***REMOVED***:

    def __init__(self,
                 transform,
                 extreme_finder=None,
                 grid_locator1=None,
                 grid_locator2=None,
                 tick_formatter1=None,
                 tick_formatter2=None***REMOVED***:
        ***REMOVED***
        transform : transform from the image coordinate (which will be
        the transData of the axes to the world coordinate.

        or transform = (transform_xy, inv_transform_xy***REMOVED***

        locator1, locator2 : grid locator for 1st and 2nd axis.
        ***REMOVED***

        if extreme_finder is None:
            extreme_finder = ExtremeFinderSimple(20, 20***REMOVED***
        if grid_locator1 is None:
            grid_locator1 = MaxNLocator(***REMOVED***
        if grid_locator2 is None:
            grid_locator2 = MaxNLocator(***REMOVED***
        if tick_formatter1 is None:
            tick_formatter1 = FormatterPrettyPrint(***REMOVED***
        if tick_formatter2 is None:
            tick_formatter2 = FormatterPrettyPrint(***REMOVED***

        super(GridFinder, self***REMOVED***.__init__( \
                 extreme_finder,
                 grid_locator1,
                 grid_locator2,
                 tick_formatter1,
                 tick_formatter2***REMOVED***

        self.update_transform(transform***REMOVED***


class MaxNLocator(mticker.MaxNLocator***REMOVED***:
    def __init__(self, nbins = 10, steps = None,
                 trim = True,
                 integer=False,
                 symmetric=False,
                 prune=None***REMOVED***:

        mticker.MaxNLocator.__init__(self, nbins, steps=steps,
                                     trim=trim, integer=integer,
                                     symmetric=symmetric, prune=prune***REMOVED***
        self.create_dummy_axis(***REMOVED***
        self._factor = None

    def __call__(self, v1, v2***REMOVED***:
        if self._factor is not None:
            self.set_bounds(v1*self._factor, v2*self._factor***REMOVED***
            locs = mticker.MaxNLocator.__call__(self***REMOVED***
            return np.array(locs***REMOVED***, len(locs***REMOVED***, self._factor
        else:
            self.set_bounds(v1, v2***REMOVED***
            locs = mticker.MaxNLocator.__call__(self***REMOVED***
            return np.array(locs***REMOVED***, len(locs***REMOVED***, None

    def set_factor(self, f***REMOVED***:
        self._factor = f


class FixedLocator(object***REMOVED***:
    def __init__(self, locs***REMOVED***:
        self._locs = locs
        self._factor = None


    def __call__(self, v1, v2***REMOVED***:
        if self._factor is None:
            v1, v2 = sorted([v1, v2***REMOVED******REMOVED***
        else:
            v1, v2 = sorted([v1*self._factor, v2*self._factor***REMOVED******REMOVED***
        locs = np.array([l for l in self._locs if ((v1 <= l***REMOVED*** and (l <= v2***REMOVED******REMOVED******REMOVED******REMOVED***
        return locs, len(locs***REMOVED***, self._factor

    def set_factor(self, f***REMOVED***:
        self._factor = f



# Tick Formatter

class FormatterPrettyPrint(object***REMOVED***:
    def __init__(self, useMathText=True***REMOVED***:
        self._fmt = mticker.ScalarFormatter(useMathText=useMathText, useOffset=False***REMOVED***
        self._fmt.create_dummy_axis(***REMOVED***
        self._ignore_factor = True

    def __call__(self, direction, factor, values***REMOVED***:
        if not self._ignore_factor:
            if factor is None:
                factor = 1.
            values = [v/factor for v in values***REMOVED***
        #values = [v for v in values***REMOVED***
        self._fmt.set_locs(values***REMOVED***
        return [self._fmt(v***REMOVED*** for v in values***REMOVED***


class DictFormatter(object***REMOVED***:
    def __init__(self, format_dict, formatter=None***REMOVED***:
        ***REMOVED***
        format_dict : dictionary for format strings to be used.
        formatter : fall-back formatter
        ***REMOVED***
        super(DictFormatter, self***REMOVED***.__init__(***REMOVED***
        self._format_dict = format_dict
        self._fallback_formatter = formatter

    def __call__(self, direction, factor, values***REMOVED***:
        ***REMOVED***
        factor is ignored if value is found in the dictionary
        ***REMOVED***

        if self._fallback_formatter:
            fallback_strings = self._fallback_formatter(direction, factor, values***REMOVED***
        else:
            fallback_strings = [""***REMOVED****len(values***REMOVED***

        r = [self._format_dict.get(k, v***REMOVED*** for k, v in zip(values,
                                                         fallback_strings***REMOVED******REMOVED***
        return r


if __name__ == "__main__":
    locator = MaxNLocator(***REMOVED***
    locs, nloc, factor = locator(0, 100***REMOVED***

    fmt = FormatterPrettyPrint(***REMOVED***

    print(fmt("left", None, locs***REMOVED******REMOVED***
