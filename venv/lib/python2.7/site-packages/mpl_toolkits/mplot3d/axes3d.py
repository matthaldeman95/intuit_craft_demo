#!/usr/bin/python
# axes3d.py, original mplot3d version by John Porter
# Created: 23 Sep 2005
# Parts fixed by Reinier Heeres <reinier@heeres.eu>
# Minor additions by Ben Axelrod <baxelrod@coroware.com>
# Significant updates and revisions by Ben Root <ben.v.root@gmail.com>

***REMOVED***
Module containing Axes3D, an object which can plot 3D objects on a
2D matplotlib figure.
***REMOVED***
from __future__ import (absolute_import, division, print_function,
                        unicode_literals***REMOVED***
import math

from matplotlib.externals import six
from matplotlib.externals.six.moves import map, xrange, zip, reduce

import warnings
from operator import itemgetter

import matplotlib.axes as maxes
from matplotlib.axes import Axes, rcParams
from matplotlib import cbook
import matplotlib.transforms as mtransforms
from matplotlib.transforms import Bbox
import matplotlib.collections as mcoll
from matplotlib import docstring
import matplotlib.scale as mscale
from matplotlib.tri.triangulation import Triangulation
import numpy as np
from matplotlib.colors import Normalize, colorConverter, LightSource

from . import art3d
from . import proj3d
from . import axis3d

def unit_bbox(***REMOVED***:
    box = Bbox(np.array([[0, 0***REMOVED***, [1, 1***REMOVED******REMOVED******REMOVED******REMOVED***
    return box

class Axes3D(Axes***REMOVED***:
    ***REMOVED***
    3D axes object.
    ***REMOVED***
    name = '3d'
    _shared_z_axes = cbook.Grouper(***REMOVED***

    def __init__(self, fig, rect=None, *args, **kwargs***REMOVED***:
        '''
        Build an :class:`Axes3D` instance in
        :class:`~matplotlib.figure.Figure` *fig* with
        *rect=[left, bottom, width, height***REMOVED**** in
        :class:`~matplotlib.figure.Figure` coordinates

        Optional keyword arguments:

          ================   =========================================
          Keyword            Description
          ================   =========================================
          *azim*             Azimuthal viewing angle (default -60***REMOVED***
          *elev*             Elevation viewing angle (default 30***REMOVED***
          *zscale*           [%(scale***REMOVED***s***REMOVED***
          *sharez*           Other axes to share z-limits with
          ================   =========================================

        .. versionadded :: 1.2.1
            *sharez*

        ''' % {'scale': ' | '.join([repr(x***REMOVED*** for x in mscale.get_scale_names(***REMOVED******REMOVED******REMOVED******REMOVED***

        if rect is None:
            rect = [0.0, 0.0, 1.0, 1.0***REMOVED***
        self._cids = [***REMOVED***

        self.initial_azim = kwargs.pop('azim', -60***REMOVED***
        self.initial_elev = kwargs.pop('elev', 30***REMOVED***
        zscale = kwargs.pop('zscale', None***REMOVED***
        sharez = kwargs.pop('sharez', None***REMOVED***

        self.xy_viewLim = unit_bbox(***REMOVED***
        self.zz_viewLim = unit_bbox(***REMOVED***
        self.xy_dataLim = unit_bbox(***REMOVED***
        self.zz_dataLim = unit_bbox(***REMOVED***
        # inihibit autoscale_view until the axes are defined
        # they can't be defined until Axes.__init__ has been called
        self.view_init(self.initial_elev, self.initial_azim***REMOVED***
        self._ready = 0

        self._sharez = sharez
        if sharez is not None:
            self._shared_z_axes.join(self, sharez***REMOVED***
            self._adjustable = 'datalim'

        Axes.__init__(self, fig, rect,
                      frameon=True,
                      *args, **kwargs***REMOVED***
        # Disable drawing of axes by base class
        Axes.set_axis_off(self***REMOVED***
        # Enable drawing of axes by Axes3D class
        self.set_axis_on(***REMOVED***
        self.M = None

        # func used to format z -- fall back on major formatters
        self.fmt_zdata = None

        if zscale is not None :
            self.set_zscale(zscale***REMOVED***

        if self.zaxis is not None :
            self._zcid = self.zaxis.callbacks.connect('units finalize',
                                                      self.relim***REMOVED***
        else :
            self._zcid = None

        self._ready = 1
        self.mouse_init(***REMOVED***
        self.set_top_view(***REMOVED***

        self.axesPatch.set_linewidth(0***REMOVED***
        # Calculate the pseudo-data width and height
        pseudo_bbox = self.transLimits.inverted(***REMOVED***.transform([(0, 0***REMOVED***, (1, 1***REMOVED******REMOVED******REMOVED***
        self._pseudo_w, self._pseudo_h = pseudo_bbox[1***REMOVED*** - pseudo_bbox[0***REMOVED***

        self.figure.add_axes(self***REMOVED***

    def set_axis_off(self***REMOVED***:
        self._axis3don = False
        self.stale = True

    def set_axis_on(self***REMOVED***:
        self._axis3don = True
        self.stale = True

    def have_units(self***REMOVED***:
        ***REMOVED***
        Return *True* if units are set on the *x*, *y*, or *z* axes

        ***REMOVED***
        return (self.xaxis.have_units(***REMOVED*** or self.yaxis.have_units(***REMOVED*** or
                self.zaxis.have_units(***REMOVED******REMOVED***

    def convert_zunits(self, z***REMOVED***:
        ***REMOVED***
        For artists in an axes, if the zaxis has units support,
        convert *z* using zaxis unit type

        .. versionadded :: 1.2.1

        ***REMOVED***
        return self.zaxis.convert_units(z***REMOVED***

    def _process_unit_info(self, xdata=None, ydata=None, zdata=None,
                           kwargs=None***REMOVED***:
        ***REMOVED***
        Look for unit *kwargs* and update the axis instances as necessary

        ***REMOVED***
        Axes._process_unit_info(self, xdata=xdata, ydata=ydata, kwargs=kwargs***REMOVED***

        if self.xaxis is None or self.yaxis is None or self.zaxis is None:
            return

        if zdata is not None:
            # we only need to update if there is nothing set yet.
            if not self.zaxis.have_units(***REMOVED***:
                self.zaxis.update_units(xdata***REMOVED***

        # process kwargs 2nd since these will override default units
        if kwargs is not None:
            zunits = kwargs.pop('zunits', self.zaxis.units***REMOVED***
            if zunits != self.zaxis.units:
                self.zaxis.set_units(zunits***REMOVED***
                # If the units being set imply a different converter,
                # we need to update.
                if zdata is not None:
                    self.zaxis.update_units(zdata***REMOVED***

    def set_top_view(self***REMOVED***:
        # this happens to be the right view for the viewing coordinates
        # moved up and to the left slightly to fit labels and axes
        xdwl = (0.95/self.dist***REMOVED***
        xdw = (0.9/self.dist***REMOVED***
        ydwl = (0.95/self.dist***REMOVED***
        ydw = (0.9/self.dist***REMOVED***

        # This is purposely using the 2D Axes's set_xlim and set_ylim,
        # because we are trying to place our viewing pane.
        Axes.set_xlim(self, -xdwl, xdw, auto=None***REMOVED***
        Axes.set_ylim(self, -ydwl, ydw, auto=None***REMOVED***

    def _init_axis(self***REMOVED***:
        '''Init 3D axes; overrides creation of regular X/Y axes'''
        self.w_xaxis = axis3d.XAxis('x', self.xy_viewLim.intervalx,
                                    self.xy_dataLim.intervalx, self***REMOVED***
        self.xaxis = self.w_xaxis
        self.w_yaxis = axis3d.YAxis('y', self.xy_viewLim.intervaly,
                                    self.xy_dataLim.intervaly, self***REMOVED***
        self.yaxis = self.w_yaxis
        self.w_zaxis = axis3d.ZAxis('z', self.zz_viewLim.intervalx,
                                    self.zz_dataLim.intervalx, self***REMOVED***
        self.zaxis = self.w_zaxis

        for ax in self.xaxis, self.yaxis, self.zaxis:
            ax.init3d(***REMOVED***

    def get_children(self***REMOVED***:
        return [self.zaxis, ***REMOVED*** + Axes.get_children(self***REMOVED***

    def _get_axis_list(self***REMOVED***:
        return super(Axes3D, self***REMOVED***._get_axis_list(***REMOVED*** + (self.zaxis, ***REMOVED***

    def unit_cube(self, vals=None***REMOVED***:
        minx, maxx, miny, maxy, minz, maxz = vals or self.get_w_lims(***REMOVED***
        xs, ys, zs = ([minx, maxx, maxx, minx, minx, maxx, maxx, minx***REMOVED***,
                      [miny, miny, maxy, maxy, miny, miny, maxy, maxy***REMOVED***,
                      [minz, minz, minz, minz, maxz, maxz, maxz, maxz***REMOVED******REMOVED***
        return list(zip(xs, ys, zs***REMOVED******REMOVED***

    def tunit_cube(self, vals=None, M=None***REMOVED***:
        if M is None:
            M = self.M
        xyzs = self.unit_cube(vals***REMOVED***
        tcube = proj3d.proj_points(xyzs, M***REMOVED***
        return tcube

    def tunit_edges(self, vals=None, M=None***REMOVED***:
        tc = self.tunit_cube(vals, M***REMOVED***
        edges = [(tc[0***REMOVED***, tc[1***REMOVED******REMOVED***,
                 (tc[1***REMOVED***, tc[2***REMOVED******REMOVED***,
                 (tc[2***REMOVED***, tc[3***REMOVED******REMOVED***,
                 (tc[3***REMOVED***, tc[0***REMOVED******REMOVED***,

                 (tc[0***REMOVED***, tc[4***REMOVED******REMOVED***,
                 (tc[1***REMOVED***, tc[5***REMOVED******REMOVED***,
                 (tc[2***REMOVED***, tc[6***REMOVED******REMOVED***,
                 (tc[3***REMOVED***, tc[7***REMOVED******REMOVED***,

                 (tc[4***REMOVED***, tc[5***REMOVED******REMOVED***,
                 (tc[5***REMOVED***, tc[6***REMOVED******REMOVED***,
                 (tc[6***REMOVED***, tc[7***REMOVED******REMOVED***,
                 (tc[7***REMOVED***, tc[4***REMOVED******REMOVED******REMOVED***
        return edges

    def draw(self, renderer***REMOVED***:
        # draw the background patch
        self.axesPatch.draw(renderer***REMOVED***
        self._frameon = False

        # first, set the aspect
        # this is duplicated from `axes._base._AxesBase.draw`
        # but must be called before any of the artist are drawn as
        # it adjusts the view limits and the size of the bounding box
        # of the axes
        locator = self.get_axes_locator(***REMOVED***
        if locator:
            pos = locator(self, renderer***REMOVED***
            self.apply_aspect(pos***REMOVED***
        else:
            self.apply_aspect(***REMOVED***

        # add the projection matrix to the renderer
        self.M = self.get_proj(***REMOVED***
        renderer.M = self.M
        renderer.vvec = self.vvec
        renderer.eye = self.eye
        renderer.get_axis_position = self.get_axis_position

        # Calculate projection of collections and zorder them
        zlist = [(col.do_3d_projection(renderer***REMOVED***, col***REMOVED*** \
                 for col in self.collections***REMOVED***
        zlist.sort(key=itemgetter(0***REMOVED***, reverse=True***REMOVED***
        for i, (z, col***REMOVED*** in enumerate(zlist***REMOVED***:
            col.zorder = i

        # Calculate projection of patches and zorder them
        zlist = [(patch.do_3d_projection(renderer***REMOVED***, patch***REMOVED*** \
                for patch in self.patches***REMOVED***
        zlist.sort(key=itemgetter(0***REMOVED***, reverse=True***REMOVED***
        for i, (z, patch***REMOVED*** in enumerate(zlist***REMOVED***:
            patch.zorder = i

        if self._axis3don:
            axes = (self.xaxis, self.yaxis, self.zaxis***REMOVED***
            # Draw panes first
            for ax in axes:
                ax.draw_pane(renderer***REMOVED***
            # Then axes
            for ax in axes:
                ax.draw(renderer***REMOVED***

        # Then rest
        Axes.draw(self, renderer***REMOVED***

    def get_axis_position(self***REMOVED***:
        vals = self.get_w_lims(***REMOVED***
        tc = self.tunit_cube(vals, self.M***REMOVED***
        xhigh = tc[1***REMOVED***[2***REMOVED*** > tc[2***REMOVED***[2***REMOVED***
        yhigh = tc[3***REMOVED***[2***REMOVED*** > tc[2***REMOVED***[2***REMOVED***
        zhigh = tc[0***REMOVED***[2***REMOVED*** > tc[2***REMOVED***[2***REMOVED***
        return xhigh, yhigh, zhigh

    def update_datalim(self, xys, **kwargs***REMOVED***:
        pass

    def get_autoscale_on(self***REMOVED*** :
        ***REMOVED***
        Get whether autoscaling is applied for all axes on plot commands

        .. versionadded :: 1.1.0
            This function was added, but not tested. Please report any bugs.
        ***REMOVED***
        return Axes.get_autoscale_on(self***REMOVED*** and self.get_autoscalez_on(***REMOVED***

    def get_autoscalez_on(self***REMOVED*** :
        ***REMOVED***
        Get whether autoscaling for the z-axis is applied on plot commands

        .. versionadded :: 1.1.0
            This function was added, but not tested. Please report any bugs.
        ***REMOVED***
        return self._autoscaleZon

    def set_autoscale_on(self, b***REMOVED*** :
        ***REMOVED***
        Set whether autoscaling is applied on plot commands

        accepts: [ *True* | *False* ***REMOVED***

        .. versionadded :: 1.1.0
            This function was added, but not tested. Please report any bugs.
        ***REMOVED***
        Axes.set_autoscale_on(self, b***REMOVED***
        self.set_autoscalez_on(b***REMOVED***

    def set_autoscalez_on(self, b***REMOVED*** :
        ***REMOVED***
        Set whether autoscaling for the z-axis is applied on plot commands

        accepts: [ *True* | *False* ***REMOVED***

        .. versionadded :: 1.1.0
            This function was added, but not tested. Please report any bugs.
        ***REMOVED***
        self._autoscalez_on = b

    def set_zmargin(self, m***REMOVED*** :
        ***REMOVED***
        Set padding of Z data limits prior to autoscaling.

        *m* times the data interval will be added to each
        end of that interval before it is used in autoscaling.

        accepts: float in range 0 to 1

        .. versionadded :: 1.1.0
            This function was added, but not tested. Please report any bugs.
        ***REMOVED***
        if m < 0 or m > 1 :
            raise ValueError("margin must be in range 0 to 1"***REMOVED***
        self._zmargin = m
        self.stale = True

    def margins(self, *args, **kw***REMOVED*** :
        ***REMOVED***
        Convenience method to set or retrieve autoscaling margins.

        signatures::
            margins(***REMOVED***

        returns xmargin, ymargin, zmargin

        ::

            margins(margin***REMOVED***

            margins(xmargin, ymargin, zmargin***REMOVED***

            margins(x=xmargin, y=ymargin, z=zmargin***REMOVED***

            margins(..., tight=False***REMOVED***

        All forms above set the xmargin, ymargin and zmargin
        parameters. All keyword parameters are optional.  A single argument
        specifies xmargin, ymargin and zmargin.  The *tight* parameter
        is passed to :meth:`autoscale_view`, which is executed after
        a margin is changed; the default here is *True*, on the
        assumption that when margins are specified, no additional
        padding to match tick marks is usually desired.  Setting
        *tight* to *None* will preserve the previous setting.

        Specifying any margin changes only the autoscaling; for example,
        if *xmargin* is not None, then *xmargin* times the X data
        interval will be added to each end of that interval before
        it is used in autoscaling.

        .. versionadded :: 1.1.0
            This function was added, but not tested. Please report any bugs.
        ***REMOVED***
        if not args and not kw:
            return self._xmargin, self._ymargin, self._zmargin

        tight = kw.pop('tight', True***REMOVED***
        mx = kw.pop('x', None***REMOVED***
        my = kw.pop('y', None***REMOVED***
        mz = kw.pop('z', None***REMOVED***
        if len(args***REMOVED*** == 1:
            mx = my = mz = args[0***REMOVED***
        elif len(args***REMOVED*** == 2:
            # Maybe put out a warning because mz is not set?
            mx, my = args
        elif len(args***REMOVED*** == 3:
            mx, my, mz = args
        else:
            raise ValueError("more than three arguments were supplied"***REMOVED***
        if mx is not None:
            self.set_xmargin(mx***REMOVED***
        if my is not None:
            self.set_ymargin(my***REMOVED***
        if mz is not None:
            self.set_zmargin(mz***REMOVED***

        scalex = (mx is not None***REMOVED***
        scaley = (my is not None***REMOVED***
        scalez = (mz is not None***REMOVED***

        self.autoscale_view(tight=tight, scalex=scalex, scaley=scaley,
                                         scalez=scalez***REMOVED***

    def autoscale(self, enable=True, axis='both', tight=None***REMOVED*** :
        ***REMOVED***
        Convenience method for simple axis view autoscaling.
        See :meth:`matplotlib.axes.Axes.autoscale` for full explanation.
        Note that this function behaves the same, but for all
        three axes.  Therfore, 'z' can be passed for *axis*,
        and 'both' applies to all three axes.

        .. versionadded :: 1.1.0
            This function was added, but not tested. Please report any bugs.
        ***REMOVED***
        if enable is None:
            scalex = True
            scaley = True
            scalez = True
        else:
            scalex = False
            scaley = False
            scalez = False
            if axis in ['x', 'both'***REMOVED***:
                self._autoscaleXon = bool(enable***REMOVED***
                scalex = self._autoscaleXon
            if axis in ['y', 'both'***REMOVED***:
                self._autoscaleYon = bool(enable***REMOVED***
                scaley = self._autoscaleYon
            if axis in ['z', 'both'***REMOVED***:
                self._autoscaleZon = bool(enable***REMOVED***
                scalez = self._autoscaleZon
        self.autoscale_view(tight=tight, scalex=scalex, scaley=scaley,
                                         scalez=scalez***REMOVED***

    def auto_scale_xyz(self, X, Y, Z=None, had_data=None***REMOVED***:
        x, y, z = list(map(np.asarray, (X, Y, Z***REMOVED******REMOVED******REMOVED***
        ***REMOVED***
            x, y = x.flatten(***REMOVED***, y.flatten(***REMOVED***
            if Z is not None:
                z = z.flatten(***REMOVED***
        except AttributeError:
            raise

        # This updates the bounding boxes as to keep a record as
        # to what the minimum sized rectangular volume holds the
        # data.
        self.xy_dataLim.update_from_data_xy(np.array([x, y***REMOVED******REMOVED***.T, not had_data***REMOVED***
        if z is not None:
            self.zz_dataLim.update_from_data_xy(np.array([z, z***REMOVED******REMOVED***.T, not had_data***REMOVED***

        # Let autoscale_view figure out how to use this data.
        self.autoscale_view(***REMOVED***

    def autoscale_view(self, tight=None, scalex=True, scaley=True,
                             scalez=True***REMOVED*** :
        ***REMOVED***
        Autoscale the view limits using the data limits.
        See :meth:`matplotlib.axes.Axes.autoscale_view` for documentation.
        Note that this function applies to the 3D axes, and as such
        adds the *scalez* to the function arguments.

        .. versionchanged :: 1.1.0
            Function signature was changed to better match the 2D version.
            *tight* is now explicitly a kwarg and placed first.

        .. versionchanged :: 1.2.1
            This is now fully functional.

        ***REMOVED***
        if not self._ready:
            return

        # This method looks at the rectangular volume (see above***REMOVED***
        # of data and decides how to scale the view portal to fit it.
        if tight is None:
            # if image data only just use the datalim
            _tight = self._tight or (len(self.images***REMOVED***>0 and
                                     len(self.lines***REMOVED***==0 and
                                     len(self.patches***REMOVED***==0***REMOVED***
        else:
            _tight = self._tight = bool(tight***REMOVED***

        if scalex and self._autoscaleXon:
            xshared = self._shared_x_axes.get_siblings(self***REMOVED***
            dl = [ax.dataLim for ax in xshared***REMOVED***
            bb = mtransforms.BboxBase.union(dl***REMOVED***
            x0, x1 = self.xy_dataLim.intervalx
            xlocator = self.xaxis.get_major_locator(***REMOVED***
            ***REMOVED***
                x0, x1 = xlocator.nonsingular(x0, x1***REMOVED***
            except AttributeError:
                x0, x1 = mtransforms.nonsingular(x0, x1, increasing=False,
                                                         expander=0.05***REMOVED***
            if self._xmargin > 0:
                delta = (x1 - x0***REMOVED*** * self._xmargin
                x0 -= delta
                x1 += delta
            if not _tight:
                x0, x1 = xlocator.view_limits(x0, x1***REMOVED***
            self.set_xbound(x0, x1***REMOVED***

        if scaley and self._autoscaleYon:
            yshared = self._shared_y_axes.get_siblings(self***REMOVED***
            dl = [ax.dataLim for ax in yshared***REMOVED***
            bb = mtransforms.BboxBase.union(dl***REMOVED***
            y0, y1 = self.xy_dataLim.intervaly
            ylocator = self.yaxis.get_major_locator(***REMOVED***
            ***REMOVED***
                y0, y1 = ylocator.nonsingular(y0, y1***REMOVED***
            except AttributeError:
                y0, y1 = mtransforms.nonsingular(y0, y1, increasing=False,
                                                         expander=0.05***REMOVED***
            if self._ymargin > 0:
                delta = (y1 - y0***REMOVED*** * self._ymargin
                y0 -= delta
                y1 += delta
            if not _tight:
                y0, y1 = ylocator.view_limits(y0, y1***REMOVED***
            self.set_ybound(y0, y1***REMOVED***

        if scalez and self._autoscaleZon:
            zshared = self._shared_z_axes.get_siblings(self***REMOVED***
            dl = [ax.dataLim for ax in zshared***REMOVED***
            bb = mtransforms.BboxBase.union(dl***REMOVED***
            z0, z1 = self.zz_dataLim.intervalx
            zlocator = self.zaxis.get_major_locator(***REMOVED***
            ***REMOVED***
                z0, z1 = zlocator.nonsingular(z0, z1***REMOVED***
            except AttributeError:
                z0, z1 = mtransforms.nonsingular(z0, z1, increasing=False,
                                                         expander=0.05***REMOVED***
            if self._zmargin > 0:
                delta = (z1 - z0***REMOVED*** * self._zmargin
                z0 -= delta
                z1 += delta
            if not _tight:
                z0, z1 = zlocator.view_limits(z0, z1***REMOVED***
            self.set_zbound(z0, z1***REMOVED***

    def get_w_lims(self***REMOVED***:
        '''Get 3D world limits.'''
        minx, maxx = self.get_xlim3d(***REMOVED***
        miny, maxy = self.get_ylim3d(***REMOVED***
        minz, maxz = self.get_zlim3d(***REMOVED***
        return minx, maxx, miny, maxy, minz, maxz

    def _determine_lims(self, xmin=None, xmax=None, *args, **kwargs***REMOVED***:
        if xmax is None and cbook.iterable(xmin***REMOVED***:
            xmin, xmax = xmin
        if xmin == xmax:
            xmin -= 0.05
            xmax += 0.05
        return (xmin, xmax***REMOVED***

    def set_xlim3d(self, left=None, right=None, emit=True, auto=False, **kw***REMOVED***:
        ***REMOVED***
        Set 3D x limits.

        See :meth:`matplotlib.axes.Axes.set_xlim` for full documentation.

        ***REMOVED***
        if 'xmin' in kw:
            left = kw.pop('xmin'***REMOVED***
        if 'xmax' in kw:
            right = kw.pop('xmax'***REMOVED***
        if kw:
            raise ValueError("unrecognized kwargs: %s" % kw.keys(***REMOVED******REMOVED***

        if right is None and cbook.iterable(left***REMOVED***:
            left, right = left

        self._process_unit_info(xdata=(left, right***REMOVED******REMOVED***
        if left is not None:
            left = self.convert_xunits(left***REMOVED***
        if right is not None:
            right = self.convert_xunits(right***REMOVED***

        old_left, old_right = self.get_xlim(***REMOVED***
        if left is None:
            left = old_left
        if right is None:
            right = old_right

        if left == right:
            warnings.warn(('Attempting to set identical left==right results\n'
                     'in singular transformations; automatically expanding.\n'
                     'left=%s, right=%s'***REMOVED*** % (left, right***REMOVED******REMOVED***
        left, right = mtransforms.nonsingular(left, right, increasing=False***REMOVED***
        left, right = self.xaxis.limit_range_for_scale(left, right***REMOVED***
        self.xy_viewLim.intervalx = (left, right***REMOVED***

        if auto is not None:
            self._autoscaleXon = bool(auto***REMOVED***

        if emit:
            self.callbacks.process('xlim_changed', self***REMOVED***
            # Call all of the other x-axes that are shared with this one
            for other in self._shared_x_axes.get_siblings(self***REMOVED***:
                if other is not self:
                    other.set_xlim(self.xy_viewLim.intervalx,
                                            emit=False, auto=auto***REMOVED***
                    if (other.figure != self.figure and
                        other.figure.canvas is not None***REMOVED***:
                        other.figure.canvas.draw_idle(***REMOVED***
        self.stale = True
        return left, right
    set_xlim = set_xlim3d


    def set_ylim3d(self, bottom=None, top=None, emit=True, auto=False, **kw***REMOVED***:
        ***REMOVED***
        Set 3D y limits.

        See :meth:`matplotlib.axes.Axes.set_ylim` for full documentation.

        ***REMOVED***
        if 'ymin' in kw:
            bottom = kw.pop('ymin'***REMOVED***
        if 'ymax' in kw:
            top = kw.pop('ymax'***REMOVED***
        if kw:
            raise ValueError("unrecognized kwargs: %s" % kw.keys(***REMOVED******REMOVED***

        if top is None and cbook.iterable(bottom***REMOVED***:
            bottom, top = bottom

        self._process_unit_info(ydata=(bottom, top***REMOVED******REMOVED***
        if bottom is not None:
            bottom = self.convert_yunits(bottom***REMOVED***
        if top is not None:
            top = self.convert_yunits(top***REMOVED***

        old_bottom, old_top = self.get_ylim(***REMOVED***
        if bottom is None:
            bottom = old_bottom
        if top is None:
            top = old_top

        if top == bottom:
            warnings.warn(('Attempting to set identical bottom==top results\n'
                     'in singular transformations; automatically expanding.\n'
                     'bottom=%s, top=%s'***REMOVED*** % (bottom, top***REMOVED******REMOVED***
        bottom, top = mtransforms.nonsingular(bottom, top, increasing=False***REMOVED***
        bottom, top = self.yaxis.limit_range_for_scale(bottom, top***REMOVED***
        self.xy_viewLim.intervaly = (bottom, top***REMOVED***

        if auto is not None:
            self._autoscaleYon = bool(auto***REMOVED***

        if emit:
            self.callbacks.process('ylim_changed', self***REMOVED***
            # Call all of the other y-axes that are shared with this one
            for other in self._shared_y_axes.get_siblings(self***REMOVED***:
                if other is not self:
                    other.set_ylim(self.xy_viewLim.intervaly,
                                            emit=False, auto=auto***REMOVED***
                    if (other.figure != self.figure and
                        other.figure.canvas is not None***REMOVED***:
                        other.figure.canvas.draw_idle(***REMOVED***
        self.stale = True
        return bottom, top
    set_ylim = set_ylim3d

    def set_zlim3d(self, bottom=None, top=None, emit=True, auto=False, **kw***REMOVED***:
        ***REMOVED***
        Set 3D z limits.

        See :meth:`matplotlib.axes.Axes.set_ylim` for full documentation

        ***REMOVED***
        if 'zmin' in kw:
            bottom = kw.pop('zmin'***REMOVED***
        if 'zmax' in kw:
            top = kw.pop('zmax'***REMOVED***
        if kw:
            raise ValueError("unrecognized kwargs: %s" % kw.keys(***REMOVED******REMOVED***

        if top is None and cbook.iterable(bottom***REMOVED***:
            bottom, top = bottom

        self._process_unit_info(zdata=(bottom, top***REMOVED******REMOVED***
        if bottom is not None:
            bottom = self.convert_zunits(bottom***REMOVED***
        if top is not None:
            top = self.convert_zunits(top***REMOVED***

        old_bottom, old_top = self.get_zlim(***REMOVED***
        if bottom is None:
            bottom = old_bottom
        if top is None:
            top = old_top

        if top == bottom:
            warnings.warn(('Attempting to set identical bottom==top results\n'
                     'in singular transformations; automatically expanding.\n'
                     'bottom=%s, top=%s'***REMOVED*** % (bottom, top***REMOVED******REMOVED***
        bottom, top = mtransforms.nonsingular(bottom, top, increasing=False***REMOVED***
        bottom, top = self.zaxis.limit_range_for_scale(bottom, top***REMOVED***
        self.zz_viewLim.intervalx = (bottom, top***REMOVED***

        if auto is not None:
            self._autoscaleZon = bool(auto***REMOVED***

        if emit:
            self.callbacks.process('zlim_changed', self***REMOVED***
            # Call all of the other y-axes that are shared with this one
            for other in self._shared_z_axes.get_siblings(self***REMOVED***:
                if other is not self:
                    other.set_zlim(self.zz_viewLim.intervalx,
                                            emit=False, auto=auto***REMOVED***
                    if (other.figure != self.figure and
                        other.figure.canvas is not None***REMOVED***:
                        other.figure.canvas.draw_idle(***REMOVED***
        self.stale = True
        return bottom, top
    set_zlim = set_zlim3d

    def get_xlim3d(self***REMOVED***:
        return self.xy_viewLim.intervalx
    get_xlim3d.__doc__ = maxes.Axes.get_xlim.__doc__
    get_xlim = get_xlim3d
    get_xlim.__doc__ += ***REMOVED***
        .. versionchanged :: 1.1.0
            This function now correctly refers to the 3D x-limits
        ***REMOVED***

    def get_ylim3d(self***REMOVED***:
        return self.xy_viewLim.intervaly
    get_ylim3d.__doc__ = maxes.Axes.get_ylim.__doc__
    get_ylim = get_ylim3d
    get_ylim.__doc__ += ***REMOVED***
        .. versionchanged :: 1.1.0
            This function now correctly refers to the 3D y-limits.
        ***REMOVED***

    def get_zlim3d(self***REMOVED***:
        '''Get 3D z limits.'''
        return self.zz_viewLim.intervalx
    get_zlim = get_zlim3d

    def get_zscale(self***REMOVED*** :
        ***REMOVED***
        Return the zaxis scale string %s

        .. versionadded :: 1.1.0
            This function was added, but not tested. Please report any bugs.
        ***REMOVED*** % (", ".join(mscale.get_scale_names(***REMOVED******REMOVED******REMOVED***
        return self.zaxis.get_scale(***REMOVED***

    # We need to slightly redefine these to pass scalez=False
    # to their calls of autoscale_view.
    def set_xscale(self, value, **kwargs***REMOVED*** :
        self.xaxis._set_scale(value, **kwargs***REMOVED***
        self.autoscale_view(scaley=False, scalez=False***REMOVED***
        self._update_transScale(***REMOVED***
    set_xscale.__doc__ = maxes.Axes.set_xscale.__doc__ + ***REMOVED***

        .. versionadded :: 1.1.0
            This function was added, but not tested. Please report any bugs.
        ***REMOVED***

    def set_yscale(self, value, **kwargs***REMOVED*** :
        self.yaxis._set_scale(value, **kwargs***REMOVED***
        self.autoscale_view(scalex=False, scalez=False***REMOVED***
        self._update_transScale(***REMOVED***
        self.stale = True
    set_yscale.__doc__ = maxes.Axes.set_yscale.__doc__ + ***REMOVED***

        .. versionadded :: 1.1.0
            This function was added, but not tested. Please report any bugs.
        ***REMOVED***

    @docstring.dedent_interpd
    def set_zscale(self, value, **kwargs***REMOVED*** :
        ***REMOVED***
        call signature::

          set_zscale(value***REMOVED***

        Set the scaling of the z-axis: %(scale***REMOVED***s

        ACCEPTS: [%(scale***REMOVED***s***REMOVED***

        Different kwargs are accepted, depending on the scale:
        %(scale_docs***REMOVED***s

        .. note ::
            Currently, Axes3D objects only supports linear scales.
            Other scales may or may not work, and support for these
            is improving with each release.

        .. versionadded :: 1.1.0
            This function was added, but not tested. Please report any bugs.
        ***REMOVED***
        self.zaxis._set_scale(value, **kwargs***REMOVED***
        self.autoscale_view(scalex=False, scaley=False***REMOVED***
        self._update_transScale(***REMOVED***
        self.stale = True

    def set_zticks(self, *args, **kwargs***REMOVED***:
        ***REMOVED***
        Set z-axis tick locations.
        See :meth:`matplotlib.axes.Axes.set_yticks` for more details.

        .. note::
            Minor ticks are not supported.

        .. versionadded:: 1.1.0
        ***REMOVED***
        return self.zaxis.set_ticks(*args, **kwargs***REMOVED***

    def get_zticks(self, minor=False***REMOVED***:
        ***REMOVED***
        Return the z ticks as a list of locations
        See :meth:`matplotlib.axes.Axes.get_yticks` for more details.

        .. note::
            Minor ticks are not supported.

        .. versionadded:: 1.1.0
        ***REMOVED***
        return self.zaxis.get_ticklocs(minor=minor***REMOVED***

    def get_zmajorticklabels(self***REMOVED*** :
        ***REMOVED***
        Get the ztick labels as a list of Text instances

        .. versionadded :: 1.1.0
        ***REMOVED***
        return cbook.silent_list('Text zticklabel',
                                 self.zaxis.get_majorticklabels(***REMOVED******REMOVED***

    def get_zminorticklabels(self***REMOVED*** :
        ***REMOVED***
        Get the ztick labels as a list of Text instances

        .. note::
            Minor ticks are not supported. This function was added
            only for completeness.

        .. versionadded :: 1.1.0
        ***REMOVED***
        return cbook.silent_list('Text zticklabel',
                                 self.zaxis.get_minorticklabels(***REMOVED******REMOVED***

    def set_zticklabels(self, *args, **kwargs***REMOVED*** :
        ***REMOVED***
        Set z-axis tick labels.
        See :meth:`matplotlib.axes.Axes.set_yticklabels` for more details.

        .. note::
            Minor ticks are not supported by Axes3D objects.

        .. versionadded:: 1.1.0
        ***REMOVED***
        return self.zaxis.set_ticklabels(*args, **kwargs***REMOVED***

    def get_zticklabels(self, minor=False***REMOVED*** :
        ***REMOVED***
        Get ztick labels as a list of Text instances.
        See :meth:`matplotlib.axes.Axes.get_yticklabels` for more details.

        .. note::
            Minor ticks are not supported.

        .. versionadded:: 1.1.0
        ***REMOVED***
        return cbook.silent_list('Text zticklabel',
                                 self.zaxis.get_ticklabels(minor=minor***REMOVED******REMOVED***

    def zaxis_date(self, tz=None***REMOVED*** :
        ***REMOVED***
        Sets up z-axis ticks and labels that treat the z data as dates.

        *tz* is a timezone string or :class:`tzinfo` instance.
        Defaults to rc value.

        .. note::
            This function is merely provided for completeness.
            Axes3D objects do not officially support dates for ticks,
            and so this may or may not work as expected.

        .. versionadded :: 1.1.0
            This function was added, but not tested. Please report any bugs.
        ***REMOVED***
        self.zaxis.axis_date(tz***REMOVED***

    def get_zticklines(self***REMOVED*** :
        ***REMOVED***
        Get ztick lines as a list of Line2D instances.
        Note that this function is provided merely for completeness.
        These lines are re-calculated as the display changes.

        .. versionadded:: 1.1.0
        ***REMOVED***
        return self.zaxis.get_ticklines(***REMOVED***

    def clabel(self, *args, **kwargs***REMOVED***:
        ***REMOVED***
        This function is currently not implemented for 3D axes.
        Returns *None*.
        ***REMOVED***
        return None

    def view_init(self, elev=None, azim=None***REMOVED***:
        ***REMOVED***
        Set the elevation and azimuth of the axes.

        This can be used to rotate the axes programatically.

        'elev' stores the elevation angle in the z plane.
        'azim' stores the azimuth angle in the x,y plane.

        if elev or azim are None (default***REMOVED***, then the initial value
        is used which was specified in the :class:`Axes3D` constructor.
        ***REMOVED***

        self.dist = 10

        if elev is None:
            self.elev = self.initial_elev
        else:
            self.elev = elev

        if azim is None:
            self.azim = self.initial_azim
        else:
            self.azim = azim

    def get_proj(self***REMOVED***:
        ***REMOVED***
        Create the projection matrix from the current viewing position.

        elev stores the elevation angle in the z plane
        azim stores the azimuth angle in the x,y plane

        dist is the distance of the eye viewing point from the object
        point.

        ***REMOVED***
        relev, razim = np.pi * self.elev/180, np.pi * self.azim/180

        xmin, xmax = self.get_xlim3d(***REMOVED***
        ymin, ymax = self.get_ylim3d(***REMOVED***
        zmin, zmax = self.get_zlim3d(***REMOVED***

        # transform to uniform world coordinates 0-1.0,0-1.0,0-1.0
        worldM = proj3d.world_transformation(xmin, xmax,
                                             ymin, ymax,
                                             zmin, zmax***REMOVED***

        # look into the middle of the new coordinates
        R = np.array([0.5, 0.5, 0.5***REMOVED******REMOVED***

        xp = R[0***REMOVED*** + np.cos(razim***REMOVED*** * np.cos(relev***REMOVED*** * self.dist
        yp = R[1***REMOVED*** + np.sin(razim***REMOVED*** * np.cos(relev***REMOVED*** * self.dist
        zp = R[2***REMOVED*** + np.sin(relev***REMOVED*** * self.dist
        E = np.array((xp, yp, zp***REMOVED******REMOVED***

        self.eye = E
        self.vvec = R - E
        self.vvec = self.vvec / proj3d.mod(self.vvec***REMOVED***

        if abs(relev***REMOVED*** > np.pi/2:
            # upside down
            V = np.array((0, 0, -1***REMOVED******REMOVED***
        else:
            V = np.array((0, 0, 1***REMOVED******REMOVED***
        zfront, zback = -self.dist, self.dist

        viewM = proj3d.view_transformation(E, R, V***REMOVED***
        perspM = proj3d.persp_transformation(zfront, zback***REMOVED***
        M0 = np.dot(viewM, worldM***REMOVED***
        M = np.dot(perspM, M0***REMOVED***
        return M

    def mouse_init(self, rotate_btn=1, zoom_btn=3***REMOVED***:
        ***REMOVED***Initializes mouse button callbacks to enable 3D rotation of
        the axes.  Also optionally sets the mouse buttons for 3D rotation
        and zooming.

        ============  =======================================================
        Argument      Description
        ============  =======================================================
        *rotate_btn*  The integer or list of integers specifying which mouse
                      button or buttons to use for 3D rotation of the axes.
                      Default = 1.

        *zoom_btn*    The integer or list of integers specifying which mouse
                      button or buttons to use to zoom the 3D axes.
                      Default = 3.
        ============  =======================================================

        ***REMOVED***
        self.button_pressed = None
        canv = self.figure.canvas
        if canv is not None:
            c1 = canv.mpl_connect('motion_notify_event', self._on_move***REMOVED***
            c2 = canv.mpl_connect('button_press_event', self._button_press***REMOVED***
            c3 = canv.mpl_connect('button_release_event', self._button_release***REMOVED***
            self._cids = [c1, c2, c3***REMOVED***
        else:
            warnings.warn('Axes3D.figure.canvas is \'None\', mouse rotation disabled.  Set canvas then call Axes3D.mouse_init(***REMOVED***.'***REMOVED***

        # coerce scalars into array-like, then convert into
        # a regular list to avoid comparisons against None
        # which breaks in recent versions of numpy.
        self._rotate_btn = np.atleast_1d(rotate_btn***REMOVED***.tolist(***REMOVED***
        self._zoom_btn = np.atleast_1d(zoom_btn***REMOVED***.tolist(***REMOVED***

    def can_zoom(self***REMOVED*** :
        ***REMOVED***
        Return *True* if this axes supports the zoom box button functionality.

        3D axes objects do not use the zoom box button.
        ***REMOVED***
        return False

    def can_pan(self***REMOVED*** :
        ***REMOVED***
        Return *True* if this axes supports the pan/zoom button functionality.

        3D axes objects do not use the pan/zoom button.
        ***REMOVED***
        return False

    def cla(self***REMOVED***:
        ***REMOVED***
        Clear axes
        ***REMOVED***
        # Disabling mouse interaction might have been needed a long
        # time ago, but I can't find a reason for it now - BVR (2012-03***REMOVED***
        #self.disable_mouse_rotation(***REMOVED***
        self.zaxis.cla(***REMOVED***

        if self._sharez is not None:
            self.zaxis.major = self._sharez.zaxis.major
            self.zaxis.minor = self._sharez.zaxis.minor
            z0, z1 = self._sharez.get_zlim(***REMOVED***
            self.set_zlim(z0, z1, emit=False, auto=None***REMOVED***
            self.zaxis._set_scale(self._sharez.zaxis.get_scale(***REMOVED******REMOVED***
        else:
            self.zaxis._set_scale('linear'***REMOVED***

        self._autoscaleZon = True
        self._zmargin = 0

        Axes.cla(self***REMOVED***

        self.grid(rcParams['axes3d.grid'***REMOVED******REMOVED***

    def disable_mouse_rotation(self***REMOVED***:
        ***REMOVED***Disable mouse button callbacks.
        ***REMOVED***
        # Disconnect the various events we set.
        for cid in self._cids:
            self.figure.canvas.mpl_disconnect(cid***REMOVED***

        self._cids = [***REMOVED***

    def _button_press(self, event***REMOVED***:
        if event.inaxes == self:
            self.button_pressed = event.button
            self.sx, self.sy = event.xdata, event.ydata

    def _button_release(self, event***REMOVED***:
        self.button_pressed = None

    def format_zdata(self, z***REMOVED***:
        ***REMOVED***
        Return *z* string formatted.  This function will use the
        :attr:`fmt_zdata` attribute if it is callable, else will fall
        back on the zaxis major formatter
        ***REMOVED***
        ***REMOVED*** return self.fmt_zdata(z***REMOVED***
        except (AttributeError, TypeError***REMOVED***:
            func = self.zaxis.get_major_formatter(***REMOVED***.format_data_short
            val = func(z***REMOVED***
            return val

    def format_coord(self, xd, yd***REMOVED***:
        ***REMOVED***
        Given the 2D view coordinates attempt to guess a 3D coordinate.
        Looks for the nearest edge to the point and then assumes that
        the point is at the same z location as the nearest point on the edge.
        ***REMOVED***

        if self.M is None:
            return ''

        if self.button_pressed in self._rotate_btn:
            return 'azimuth=%d deg, elevation=%d deg ' % (self.azim, self.elev***REMOVED***
            # ignore xd and yd and display angles instead

        p = (xd, yd***REMOVED***
        edges = self.tunit_edges(***REMOVED***
        #lines = [proj3d.line2d(p0,p1***REMOVED*** for (p0,p1***REMOVED*** in edges***REMOVED***
        ldists = [(proj3d.line2d_seg_dist(p0, p1, p***REMOVED***, i***REMOVED*** for \
                i, (p0, p1***REMOVED*** in enumerate(edges***REMOVED******REMOVED***
        ldists.sort(***REMOVED***
        # nearest edge
        edgei = ldists[0***REMOVED***[1***REMOVED***

        p0, p1 = edges[edgei***REMOVED***

        # scale the z value to match
        x0, y0, z0 = p0
        x1, y1, z1 = p1
        d0 = np.hypot(x0-xd, y0-yd***REMOVED***
        d1 = np.hypot(x1-xd, y1-yd***REMOVED***
        dt = d0+d1
        z = d1/dt * z0 + d0/dt * z1

        x, y, z = proj3d.inv_transform(xd, yd, z, self.M***REMOVED***

        xs = self.format_xdata(x***REMOVED***
        ys = self.format_ydata(y***REMOVED***
        zs = self.format_zdata(z***REMOVED***
        return 'x=%s, y=%s, z=%s' % (xs, ys, zs***REMOVED***

    def _on_move(self, event***REMOVED***:
        ***REMOVED***Mouse moving

        button-1 rotates by default.  Can be set explicitly in mouse_init(***REMOVED***.
        button-3 zooms by default.  Can be set explicitly in mouse_init(***REMOVED***.
        ***REMOVED***

        if not self.button_pressed:
            return

        if self.M is None:
            return

        x, y = event.xdata, event.ydata
        # In case the mouse is out of bounds.
        if x is None:
            return

        dx, dy = x - self.sx, y - self.sy
        w = self._pseudo_w
        h = self._pseudo_h
        self.sx, self.sy = x, y

        # Rotation
        if self.button_pressed in self._rotate_btn:
            # rotate viewing point
            # get the x and y pixel coords
            if dx == 0 and dy == 0:
                return
            self.elev = art3d.norm_angle(self.elev - (dy/h***REMOVED****180***REMOVED***
            self.azim = art3d.norm_angle(self.azim - (dx/w***REMOVED****180***REMOVED***
            self.get_proj(***REMOVED***
            self.figure.canvas.draw_idle(***REMOVED***

#        elif self.button_pressed == 2:
            # pan view
            # project xv,yv,zv -> xw,yw,zw
            # pan
#            pass

        # Zoom
        elif self.button_pressed in self._zoom_btn:
            # zoom view
            # hmmm..this needs some help from clipping....
            minx, maxx, miny, maxy, minz, maxz = self.get_w_lims(***REMOVED***
            df = 1-((h - dy***REMOVED***/h***REMOVED***
            dx = (maxx-minx***REMOVED****df
            dy = (maxy-miny***REMOVED****df
            dz = (maxz-minz***REMOVED****df
            self.set_xlim3d(minx - dx, maxx + dx***REMOVED***
            self.set_ylim3d(miny - dy, maxy + dy***REMOVED***
            self.set_zlim3d(minz - dz, maxz + dz***REMOVED***
            self.get_proj(***REMOVED***
            self.figure.canvas.draw_idle(***REMOVED***

    def set_zlabel(self, zlabel, fontdict=None, labelpad=None, **kwargs***REMOVED***:
        '''
        Set zlabel.  See doc for :meth:`set_ylabel` for description.

        '''
        if labelpad is not None : self.zaxis.labelpad = labelpad
        return self.zaxis.set_label_text(zlabel, fontdict, **kwargs***REMOVED***

    def get_zlabel(self***REMOVED*** :
        ***REMOVED***
        Get the z-label text string.

        .. versionadded :: 1.1.0
            This function was added, but not tested. Please report any bugs.
        ***REMOVED***
        label = self.zaxis.get_label(***REMOVED***
        return label.get_text(***REMOVED***

    #### Axes rectangle characteristics

    def get_frame_on(self***REMOVED***:
        ***REMOVED***
        Get whether the 3D axes panels are drawn

        .. versionadded :: 1.1.0
        ***REMOVED***
        return self._frameon

    def set_frame_on(self, b***REMOVED***:
        ***REMOVED***
        Set whether the 3D axes panels are drawn

        ACCEPTS: [ *True* | *False* ***REMOVED***

        .. versionadded :: 1.1.0
        ***REMOVED***
        self._frameon = bool(b***REMOVED***
        self.stale = True

    def get_axisbelow(self***REMOVED***:
        ***REMOVED***
        Get whether axis below is true or not.

        For axes3d objects, this will always be *True*

        .. versionadded :: 1.1.0
            This function was added for completeness.
        ***REMOVED***
        return True

    def set_axisbelow(self, b***REMOVED***:
        ***REMOVED***
        Set whether the axis ticks and gridlines are above or below
        most artists

        For axes3d objects, this will ignore any settings and just use *True*

        ACCEPTS: [ *True* | *False* ***REMOVED***

        .. versionadded :: 1.1.0
            This function was added for completeness.
        ***REMOVED***
        self._axisbelow = True
        self.stale = True

    def grid(self, b=True, **kwargs***REMOVED***:
        '''
        Set / unset 3D grid.

        .. note::

            Currently, this function does not behave the same as
            :meth:`matplotlib.axes.Axes.grid`, but it is intended to
            eventually support that behavior.

        .. versionchanged :: 1.1.0
            This function was changed, but not tested. Please report any bugs.
        '''
        # TODO: Operate on each axes separately
        if len(kwargs***REMOVED*** :
            b = True
        self._draw_grid = cbook._string_to_bool(b***REMOVED***
        self.stale = True

    def ticklabel_format(self, **kwargs***REMOVED*** :
        ***REMOVED***
        Convenience method for manipulating the ScalarFormatter
        used by default for linear axes in Axed3D objects.

        See :meth:`matplotlib.axes.Axes.ticklabel_format` for full
        documentation.  Note that this version applies to all three
        axes of the Axes3D object.  Therefore, the *axis* argument
        will also accept a value of 'z' and the value of 'both' will
        apply to all three axes.

        .. versionadded :: 1.1.0
            This function was added, but not tested. Please report any bugs.
        ***REMOVED***
        style = kwargs.pop('style', ''***REMOVED***.lower(***REMOVED***
        scilimits = kwargs.pop('scilimits', None***REMOVED***
        useOffset = kwargs.pop('useOffset', None***REMOVED***
        axis = kwargs.pop('axis', 'both'***REMOVED***.lower(***REMOVED***
        if scilimits is not None:
            ***REMOVED***
                m, n = scilimits
                m+n+1  # check that both are numbers
            except (ValueError, TypeError***REMOVED***:
                raise ValueError("scilimits must be a sequence of 2 integers"***REMOVED***
        if style[:3***REMOVED*** == 'sci':
            sb = True
        elif style in ['plain', 'comma'***REMOVED***:
            sb = False
            if style == 'plain':
                cb = False
            else:
                cb = True
                raise NotImplementedError("comma style remains to be added"***REMOVED***
        elif style == '':
            sb = None
        else:
            raise ValueError("%s is not a valid style value"***REMOVED***
        ***REMOVED***
            if sb is not None:
                if axis in ['both', 'z'***REMOVED***:
                    self.xaxis.major.formatter.set_scientific(sb***REMOVED***
                if axis in ['both', 'y'***REMOVED***:
                    self.yaxis.major.formatter.set_scientific(sb***REMOVED***
                if axis in ['both', 'z'***REMOVED*** :
                    self.zaxis.major.formatter.set_scientific(sb***REMOVED***
            if scilimits is not None:
                if axis in ['both', 'x'***REMOVED***:
                    self.xaxis.major.formatter.set_powerlimits(scilimits***REMOVED***
                if axis in ['both', 'y'***REMOVED***:
                    self.yaxis.major.formatter.set_powerlimits(scilimits***REMOVED***
                if axis in ['both', 'z'***REMOVED***:
                    self.zaxis.major.formatter.set_powerlimits(scilimits***REMOVED***
            if useOffset is not None:
                if axis in ['both', 'x'***REMOVED***:
                    self.xaxis.major.formatter.set_useOffset(useOffset***REMOVED***
                if axis in ['both', 'y'***REMOVED***:
                    self.yaxis.major.formatter.set_useOffset(useOffset***REMOVED***
                if axis in ['both', 'z'***REMOVED***:
                    self.zaxis.major.formatter.set_useOffset(useOffset***REMOVED***
        except AttributeError:
            raise AttributeError(
                "This method only works with the ScalarFormatter."***REMOVED***

    def locator_params(self, axis='both', tight=None, **kwargs***REMOVED*** :
        ***REMOVED***
        Convenience method for controlling tick locators.

        See :meth:`matplotlib.axes.Axes.locator_params` for full
        documentation  Note that this is for Axes3D objects,
        therefore, setting *axis* to 'both' will result in the
        parameters being set for all three axes.  Also, *axis*
        can also take a value of 'z' to apply parameters to the
        z axis.

        .. versionadded :: 1.1.0
            This function was added, but not tested. Please report any bugs.
        ***REMOVED***
        _x = axis in ['x', 'both'***REMOVED***
        _y = axis in ['y', 'both'***REMOVED***
        _z = axis in ['z', 'both'***REMOVED***
        if _x:
            self.xaxis.get_major_locator(***REMOVED***.set_params(**kwargs***REMOVED***
        if _y:
            self.yaxis.get_major_locator(***REMOVED***.set_params(**kwargs***REMOVED***
        if _z:
            self.zaxis.get_major_locator(***REMOVED***.set_params(**kwargs***REMOVED***
        self.autoscale_view(tight=tight, scalex=_x, scaley=_y, scalez=_z***REMOVED***

    def tick_params(self, axis='both', **kwargs***REMOVED*** :
        ***REMOVED***
        Convenience method for changing the appearance of ticks and
        tick labels.

        See :meth:`matplotlib.axes.Axes.tick_params` for more complete
        documentation.

        The only difference is that setting *axis* to 'both' will
        mean that the settings are applied to all three axes. Also,
        the *axis* parameter also accepts a value of 'z', which
        would mean to apply to only the z-axis.

        Also, because of how Axes3D objects are drawn very differently
        from regular 2D axes, some of these settings may have
        ambiguous meaning.  For simplicity, the 'z' axis will
        accept settings as if it was like the 'y' axis.

        .. note::
            While this function is currently implemented, the core part
            of the Axes3D object may ignore some of these settings.
            Future releases will fix this. Priority will be given to
            those who file bugs.

        .. versionadded :: 1.1.0
            This function was added, but not tested. Please report any bugs.
        ***REMOVED***
        Axes.tick_params(self, axis, **kwargs***REMOVED***
        if axis in ['z', 'both'***REMOVED*** :
            zkw = dict(kwargs***REMOVED***
            zkw.pop('top', None***REMOVED***
            zkw.pop('bottom', None***REMOVED***
            zkw.pop('labeltop', None***REMOVED***
            zkw.pop('labelbottom', None***REMOVED***
            self.zaxis.set_tick_params(**zkw***REMOVED***

    ### data limits, ticks, tick labels, and formatting

    def invert_zaxis(self***REMOVED***:
        ***REMOVED***
        Invert the z-axis.

        .. versionadded :: 1.1.0
            This function was added, but not tested. Please report any bugs.
        ***REMOVED***
        bottom, top = self.get_zlim(***REMOVED***
        self.set_zlim(top, bottom, auto=None***REMOVED***

    def zaxis_inverted(self***REMOVED***:
        '''
        Returns True if the z-axis is inverted.

        .. versionadded :: 1.1.0
            This function was added, but not tested. Please report any bugs.
        '''
        bottom, top = self.get_zlim(***REMOVED***
        return top < bottom

    def get_zbound(self***REMOVED***:
        ***REMOVED***
        Returns the z-axis numerical bounds where::

          lowerBound < upperBound

        .. versionadded :: 1.1.0
            This function was added, but not tested. Please report any bugs.
        ***REMOVED***
        bottom, top = self.get_zlim(***REMOVED***
        if bottom < top:
            return bottom, top
        else:
            return top, bottom

    def set_zbound(self, lower=None, upper=None***REMOVED***:
        ***REMOVED***
        Set the lower and upper numerical bounds of the z-axis.
        This method will honor axes inversion regardless of parameter order.
        It will not change the :attr:`_autoscaleZon` attribute.

        .. versionadded :: 1.1.0
            This function was added, but not tested. Please report any bugs.
        ***REMOVED***
        if upper is None and cbook.iterable(lower***REMOVED***:
            lower,upper = lower

        old_lower,old_upper = self.get_zbound(***REMOVED***

        if lower is None: lower = old_lower
        if upper is None: upper = old_upper

        if self.zaxis_inverted(***REMOVED***:
            if lower < upper:
                self.set_zlim(upper, lower, auto=None***REMOVED***
            else:
                self.set_zlim(lower, upper, auto=None***REMOVED***
        else :
            if lower < upper:
                self.set_zlim(lower, upper, auto=None***REMOVED***
            else :
                self.set_zlim(upper, lower, auto=None***REMOVED***



    def text(self, x, y, z, s, zdir=None, **kwargs***REMOVED***:
        '''
        Add text to the plot. kwargs will be passed on to Axes.text,
        except for the `zdir` keyword, which sets the direction to be
        used as the z direction.
        '''
        text = Axes.text(self, x, y, s, **kwargs***REMOVED***
        art3d.text_2d_to_3d(text, z, zdir***REMOVED***
        return text

    text3D = text
    text2D = Axes.text

    def plot(self, xs, ys, *args, **kwargs***REMOVED***:
        '''
        Plot 2D or 3D data.

        ==========  ================================================
        Argument    Description
        ==========  ================================================
        *xs*, *ys*  x, y coordinates of vertices

        *zs*        z value(s***REMOVED***, either one for all points or one for
                    each point.
        *zdir*      Which direction to use as z ('x', 'y' or 'z'***REMOVED***
                    when plotting a 2D set.
        ==========  ================================================

        Other arguments are passed on to
        :func:`~matplotlib.axes.Axes.plot`
        '''
        # FIXME: This argument parsing might be better handled
        #        when we set later versions of python for
        #        minimum requirements.  Currently at 2.4.
        #        Note that some of the reason for the current difficulty
        #        is caused by the fact that we want to insert a new
        #        (semi-optional***REMOVED*** positional argument 'Z' right before
        #        many other traditional positional arguments occur
        #        such as the color, linestyle and/or marker.
        had_data = self.has_data(***REMOVED***
        zs = kwargs.pop('zs', 0***REMOVED***
        zdir = kwargs.pop('zdir', 'z'***REMOVED***

        argsi = 0
        # First argument is array of zs
        if len(args***REMOVED*** > 0 and cbook.iterable(args[0***REMOVED******REMOVED*** and \
                len(xs***REMOVED*** == len(args[0***REMOVED******REMOVED*** :
            # So, we know that it is an array with
            # first dimension the same as xs.
            # Next, check to see if the data contained
            # therein (if any***REMOVED*** is scalar (and not another array***REMOVED***.
            if len(args[0***REMOVED******REMOVED*** == 0 or cbook.is_scalar(args[0***REMOVED***[0***REMOVED******REMOVED*** :
                zs = args[argsi***REMOVED***
                argsi += 1

        # First argument is z value
        elif len(args***REMOVED*** > 0 and cbook.is_scalar(args[0***REMOVED******REMOVED***:
            zs = args[argsi***REMOVED***
            argsi += 1

        # Match length
        if not cbook.iterable(zs***REMOVED***:
            zs = np.ones(len(xs***REMOVED******REMOVED*** * zs

        lines = Axes.plot(self, xs, ys, *args[argsi:***REMOVED***, **kwargs***REMOVED***
        for line in lines:
            art3d.line_2d_to_3d(line, zs=zs, zdir=zdir***REMOVED***

        self.auto_scale_xyz(xs, ys, zs, had_data***REMOVED***
        return lines

    plot3D = plot

    def plot_surface(self, X, Y, Z, *args, **kwargs***REMOVED***:
        '''
        Create a surface plot.

        By default it will be colored in shades of a solid color,
        but it also supports color mapping by supplying the *cmap*
        argument.

        The `rstride` and `cstride` kwargs set the stride used to
        sample the input data to generate the graph.  If 1k by 1k
        arrays are passed in the default values for the strides will
        result in a 100x100 grid being plotted.

        ============= ================================================
        Argument      Description
        ============= ================================================
        *X*, *Y*, *Z* Data values as 2D arrays
        *rstride*     Array row stride (step size***REMOVED***, defaults to 10
        *cstride*     Array column stride (step size***REMOVED***, defaults to 10
        *color*       Color of the surface patches
        *cmap*        A colormap for the surface patches.
        *facecolors*  Face colors for the individual patches
        *norm*        An instance of Normalize to map values to colors
        *vmin*        Minimum value to map
        *vmax*        Maximum value to map
        *shade*       Whether to shade the facecolors
        ============= ================================================

        Other arguments are passed on to
        :class:`~mpl_toolkits.mplot3d.art3d.Poly3DCollection`
        '''

        had_data = self.has_data(***REMOVED***

        Z = np.atleast_2d(Z***REMOVED***
        # TODO: Support masked arrays
        X, Y, Z = np.broadcast_arrays(X, Y, Z***REMOVED***
        rows, cols = Z.shape

        rstride = kwargs.pop('rstride', 10***REMOVED***
        cstride = kwargs.pop('cstride', 10***REMOVED***

        if 'facecolors' in kwargs:
            fcolors = kwargs.pop('facecolors'***REMOVED***
        else:
            color = np.array(colorConverter.to_rgba(kwargs.pop('color', 'b'***REMOVED******REMOVED******REMOVED***
            fcolors = None

        cmap = kwargs.get('cmap', None***REMOVED***
        norm = kwargs.pop('norm', None***REMOVED***
        vmin = kwargs.pop('vmin', None***REMOVED***
        vmax = kwargs.pop('vmax', None***REMOVED***
        linewidth = kwargs.get('linewidth', None***REMOVED***
        shade = kwargs.pop('shade', cmap is None***REMOVED***
        lightsource = kwargs.pop('lightsource', None***REMOVED***

        # Shade the data
        if shade and cmap is not None and fcolors is not None:
            fcolors = self._shade_colors_lightsource(Z, cmap, lightsource***REMOVED***

        polys = [***REMOVED***
        # Only need these vectors to shade if there is no cmap
        if cmap is None and shade :
            totpts = int(np.ceil(float(rows - 1***REMOVED*** / rstride***REMOVED*** *
                         np.ceil(float(cols - 1***REMOVED*** / cstride***REMOVED******REMOVED***
            v1 = np.empty((totpts, 3***REMOVED******REMOVED***
            v2 = np.empty((totpts, 3***REMOVED******REMOVED***
            # This indexes the vertex points
            which_pt = 0


        #colset contains the data for coloring: either average z or the facecolor
        colset = [***REMOVED***
        for rs in xrange(0, rows-1, rstride***REMOVED***:
            for cs in xrange(0, cols-1, cstride***REMOVED***:
                ps = [***REMOVED***
                for a in (X, Y, Z***REMOVED*** :
                    ztop = a[rs,cs:min(cols, cs+cstride+1***REMOVED******REMOVED***
                    zleft = a[rs+1:min(rows, rs+rstride+1***REMOVED***,
                              min(cols-1, cs+cstride***REMOVED******REMOVED***
                    zbase = a[min(rows-1, rs+rstride***REMOVED***, cs:min(cols, cs+cstride+1***REMOVED***:***REMOVED***[::-1***REMOVED***
                    zright = a[rs:min(rows-1, rs+rstride***REMOVED***:, cs***REMOVED***[::-1***REMOVED***
                    z = np.concatenate((ztop, zleft, zbase, zright***REMOVED******REMOVED***
                    ps.append(z***REMOVED***

                # The construction leaves the array with duplicate points, which
                # are removed here.
                ps = list(zip(*ps***REMOVED******REMOVED***
                lastp = np.array([***REMOVED******REMOVED***
                ps2 = [ps[0***REMOVED******REMOVED*** + [ps[i***REMOVED*** for i in xrange(1, len(ps***REMOVED******REMOVED*** if ps[i***REMOVED*** != ps[i-1***REMOVED******REMOVED***
                avgzsum = sum(p[2***REMOVED*** for p in ps2***REMOVED***
                polys.append(ps2***REMOVED***

                if fcolors is not None:
                    colset.append(fcolors[rs***REMOVED***[cs***REMOVED******REMOVED***
                else:
                    colset.append(avgzsum / len(ps2***REMOVED******REMOVED***

                # Only need vectors to shade if no cmap
                if cmap is None and shade:
                    i1, i2, i3 = 0, int(len(ps2***REMOVED***/3***REMOVED***, int(2*len(ps2***REMOVED***/3***REMOVED***
                    v1[which_pt***REMOVED*** = np.array(ps2[i1***REMOVED******REMOVED*** - np.array(ps2[i2***REMOVED******REMOVED***
                    v2[which_pt***REMOVED*** = np.array(ps2[i2***REMOVED******REMOVED*** - np.array(ps2[i3***REMOVED******REMOVED***
                    which_pt += 1
        if cmap is None and shade:
            normals = np.cross(v1, v2***REMOVED***
        else :
            normals = [***REMOVED***

        polyc = art3d.Poly3DCollection(polys, *args, **kwargs***REMOVED***

        if fcolors is not None:
            if shade:
                colset = self._shade_colors(colset, normals***REMOVED***
            polyc.set_facecolors(colset***REMOVED***
            polyc.set_edgecolors(colset***REMOVED***
        elif cmap:
            colset = np.array(colset***REMOVED***
            polyc.set_array(colset***REMOVED***
            if vmin is not None or vmax is not None:
                polyc.set_clim(vmin, vmax***REMOVED***
            if norm is not None:
                polyc.set_norm(norm***REMOVED***
        else:
            if shade:
                colset = self._shade_colors(color, normals***REMOVED***
            else:
                colset = color
            polyc.set_facecolors(colset***REMOVED***

        self.add_collection(polyc***REMOVED***
        self.auto_scale_xyz(X, Y, Z, had_data***REMOVED***

        return polyc

    def _generate_normals(self, polygons***REMOVED***:
        '''
        Generate normals for polygons by using the first three points.
        This normal of course might not make sense for polygons with
        more than three points not lying in a plane.
        '''

        normals = [***REMOVED***
        for verts in polygons:
            v1 = np.array(verts[0***REMOVED******REMOVED*** - np.array(verts[1***REMOVED******REMOVED***
            v2 = np.array(verts[2***REMOVED******REMOVED*** - np.array(verts[0***REMOVED******REMOVED***
            normals.append(np.cross(v1, v2***REMOVED******REMOVED***
        return normals

    def _shade_colors(self, color, normals***REMOVED***:
        '''
        Shade *color* using normal vectors given by *normals*.
        *color* can also be an array of the same length as *normals*.
        '''

        shade = np.array([np.dot(n / proj3d.mod(n***REMOVED***, [-1, -1, 0.5***REMOVED******REMOVED***
                          if proj3d.mod(n***REMOVED*** else np.nan
                          for n in normals***REMOVED******REMOVED***
        mask = ~np.isnan(shade***REMOVED***

        if len(shade[mask***REMOVED******REMOVED*** > 0:
            norm = Normalize(min(shade[mask***REMOVED******REMOVED***, max(shade[mask***REMOVED******REMOVED******REMOVED***
            shade[~mask***REMOVED*** = min(shade[mask***REMOVED******REMOVED***
            color = colorConverter.to_rgba_array(color***REMOVED***
            # shape of color should be (M, 4***REMOVED*** (where M is number of faces***REMOVED***
            # shape of shade should be (M,***REMOVED***
            # colors should have final shape of (M, 4***REMOVED***
            alpha = color[:, 3***REMOVED***
            colors = (0.5 + norm(shade***REMOVED***[:, np.newaxis***REMOVED*** * 0.5***REMOVED*** * color
            colors[:, 3***REMOVED*** = alpha
        else:
            colors = np.asanyarray(color***REMOVED***.copy(***REMOVED***

        return colors

    def _shade_colors_lightsource(self, data, cmap, lightsource***REMOVED***:
        if lightsource is None:
            lightsource = LightSource(azdeg=135, altdeg=55***REMOVED***
        return lightsource.shade(data, cmap***REMOVED***

    def plot_wireframe(self, X, Y, Z, *args, **kwargs***REMOVED***:
        '''
        Plot a 3D wireframe.

        The `rstride` and `cstride` kwargs set the stride used to
        sample the input data to generate the graph. If either is 0
        the input data in not sampled along this direction producing a
        3D line plot rather than a wireframe plot.

        ==========  ================================================
        Argument    Description
        ==========  ================================================
        *X*, *Y*,   Data values as 2D arrays
        *Z*
        *rstride*   Array row stride (step size***REMOVED***, defaults to 1
        *cstride*   Array column stride (step size***REMOVED***, defaults to 1
        ==========  ================================================

        Keyword arguments are passed on to
        :class:`~matplotlib.collections.LineCollection`.

        Returns a :class:`~mpl_toolkits.mplot3d.art3d.Line3DCollection`
        '''

        rstride = kwargs.pop("rstride", 1***REMOVED***
        cstride = kwargs.pop("cstride", 1***REMOVED***

        had_data = self.has_data(***REMOVED***
        Z = np.atleast_2d(Z***REMOVED***
        # FIXME: Support masked arrays
        X, Y, Z = np.broadcast_arrays(X, Y, Z***REMOVED***
        rows, cols = Z.shape

        # We want two sets of lines, one running along the "rows" of
        # Z and another set of lines running along the "columns" of Z.
        # This transpose will make it easy to obtain the columns.
        tX, tY, tZ = np.transpose(X***REMOVED***, np.transpose(Y***REMOVED***, np.transpose(Z***REMOVED***

        if rstride:
            rii = list(xrange(0, rows, rstride***REMOVED******REMOVED***
            # Add the last index only if needed
            if rows > 0 and rii[-1***REMOVED*** != (rows - 1***REMOVED*** :
                rii += [rows-1***REMOVED***
        else:
            rii = [***REMOVED***
        if cstride:
            cii = list(xrange(0, cols, cstride***REMOVED******REMOVED***
            # Add the last index only if needed
            if cols > 0 and cii[-1***REMOVED*** != (cols - 1***REMOVED*** :
                cii += [cols-1***REMOVED***
        else:
            cii = [***REMOVED***

        if rstride == 0 and cstride == 0:
            raise ValueError("Either rstride or cstride must be non zero"***REMOVED***

        # If the inputs were empty, then just
        # reset everything.
        if Z.size == 0 :
            rii = [***REMOVED***
            cii = [***REMOVED***

        xlines = [X[i***REMOVED*** for i in rii***REMOVED***
        ylines = [Y[i***REMOVED*** for i in rii***REMOVED***
        zlines = [Z[i***REMOVED*** for i in rii***REMOVED***

        txlines = [tX[i***REMOVED*** for i in cii***REMOVED***
        tylines = [tY[i***REMOVED*** for i in cii***REMOVED***
        tzlines = [tZ[i***REMOVED*** for i in cii***REMOVED***

        lines = [list(zip(xl, yl, zl***REMOVED******REMOVED*** for xl, yl, zl in \
                 zip(xlines, ylines, zlines***REMOVED******REMOVED***
        lines += [list(zip(xl, yl, zl***REMOVED******REMOVED*** for xl, yl, zl in \
                  zip(txlines, tylines, tzlines***REMOVED******REMOVED***

        linec = art3d.Line3DCollection(lines, *args, **kwargs***REMOVED***
        self.add_collection(linec***REMOVED***
        self.auto_scale_xyz(X, Y, Z, had_data***REMOVED***

        return linec

    def plot_trisurf(self, *args, **kwargs***REMOVED***:
        ***REMOVED***
        ============= ================================================
        Argument      Description
        ============= ================================================
        *X*, *Y*, *Z* Data values as 1D arrays
        *color*       Color of the surface patches
        *cmap*        A colormap for the surface patches.
        *norm*        An instance of Normalize to map values to colors
        *vmin*        Minimum value to map
        *vmax*        Maximum value to map
        *shade*       Whether to shade the facecolors
        ============= ================================================

        The (optional***REMOVED*** triangulation can be specified in one of two ways;
        either::

          plot_trisurf(triangulation, ...***REMOVED***

        where triangulation is a :class:`~matplotlib.tri.Triangulation`
        object, or::

          plot_trisurf(X, Y, ...***REMOVED***
          plot_trisurf(X, Y, triangles, ...***REMOVED***
          plot_trisurf(X, Y, triangles=triangles, ...***REMOVED***

        in which case a Triangulation object will be created.  See
        :class:`~matplotlib.tri.Triangulation` for a explanation of
        these possibilities.

        The remaining arguments are::

          plot_trisurf(..., Z***REMOVED***

        where *Z* is the array of values to contour, one per point
        in the triangulation.

        Other arguments are passed on to
        :class:`~mpl_toolkits.mplot3d.art3d.Poly3DCollection`

        **Examples:**

        .. plot:: mpl_examples/mplot3d/trisurf3d_demo.py
        .. plot:: mpl_examples/mplot3d/trisurf3d_demo2.py

        .. versionadded:: 1.2.0
            This plotting function was added for the v1.2.0 release.
        ***REMOVED***

        had_data = self.has_data(***REMOVED***

        # TODO: Support custom face colours
        color = np.array(colorConverter.to_rgba(kwargs.pop('color', 'b'***REMOVED******REMOVED******REMOVED***

        cmap = kwargs.get('cmap', None***REMOVED***
        norm = kwargs.pop('norm', None***REMOVED***
        vmin = kwargs.pop('vmin', None***REMOVED***
        vmax = kwargs.pop('vmax', None***REMOVED***
        linewidth = kwargs.get('linewidth', None***REMOVED***
        shade = kwargs.pop('shade', cmap is None***REMOVED***
        lightsource = kwargs.pop('lightsource', None***REMOVED***

        tri, args, kwargs = Triangulation.get_from_args_and_kwargs(*args, **kwargs***REMOVED***
        if 'Z' in kwargs:
            z = np.asarray(kwargs.pop('Z'***REMOVED******REMOVED***
        else:
            z = np.asarray(args[0***REMOVED******REMOVED***
            # We do this so Z doesn't get passed as an arg to PolyCollection
            args = args[1:***REMOVED***

        triangles = tri.get_masked_triangles(***REMOVED***
        xt = tri.x[triangles***REMOVED***[..., np.newaxis***REMOVED***
        yt = tri.y[triangles***REMOVED***[..., np.newaxis***REMOVED***
        zt = z[triangles***REMOVED***[..., np.newaxis***REMOVED***

        verts = np.concatenate((xt, yt, zt***REMOVED***, axis=2***REMOVED***

        # Only need these vectors to shade if there is no cmap
        if cmap is None and shade:
            totpts = len(verts***REMOVED***
            v1 = np.empty((totpts, 3***REMOVED******REMOVED***
            v2 = np.empty((totpts, 3***REMOVED******REMOVED***
            # This indexes the vertex points
            which_pt = 0

        colset = [***REMOVED***
        for i in xrange(len(verts***REMOVED******REMOVED***:
            avgzsum = verts[i,0,2***REMOVED*** + verts[i,1,2***REMOVED*** + verts[i,2,2***REMOVED***
            colset.append(avgzsum / 3.0***REMOVED***

            # Only need vectors to shade if no cmap
            if cmap is None and shade:
                v1[which_pt***REMOVED*** = np.array(verts[i,0***REMOVED******REMOVED*** - np.array(verts[i,1***REMOVED******REMOVED***
                v2[which_pt***REMOVED*** = np.array(verts[i,1***REMOVED******REMOVED*** - np.array(verts[i,2***REMOVED******REMOVED***
                which_pt += 1

        if cmap is None and shade:
            normals = np.cross(v1, v2***REMOVED***
        else:
            normals = [***REMOVED***

        polyc = art3d.Poly3DCollection(verts, *args, **kwargs***REMOVED***

        if cmap:
            colset = np.array(colset***REMOVED***
            polyc.set_array(colset***REMOVED***
            if vmin is not None or vmax is not None:
                polyc.set_clim(vmin, vmax***REMOVED***
            if norm is not None:
                polyc.set_norm(norm***REMOVED***
        else:
            if shade:
                colset = self._shade_colors(color, normals***REMOVED***
            else:
                colset = color
            polyc.set_facecolors(colset***REMOVED***

        self.add_collection(polyc***REMOVED***
        self.auto_scale_xyz(tri.x, tri.y, z, had_data***REMOVED***

        return polyc

    def _3d_extend_contour(self, cset, stride=5***REMOVED***:
        '''
        Extend a contour in 3D by creating
        '''

        levels = cset.levels
        colls = cset.collections
        dz = (levels[1***REMOVED*** - levels[0***REMOVED******REMOVED*** / 2

        for z, linec in zip(levels, colls***REMOVED***:
            topverts = art3d.paths_to_3d_segments(linec.get_paths(***REMOVED***, z - dz***REMOVED***
            botverts = art3d.paths_to_3d_segments(linec.get_paths(***REMOVED***, z + dz***REMOVED***

            color = linec.get_color(***REMOVED***[0***REMOVED***

            polyverts = [***REMOVED***
            normals = [***REMOVED***
            nsteps = round(len(topverts[0***REMOVED******REMOVED*** / stride***REMOVED***
            if nsteps <= 1:
                if len(topverts[0***REMOVED******REMOVED*** > 1:
                    nsteps = 2
                else:
                    continue

            stepsize = (len(topverts[0***REMOVED******REMOVED*** - 1***REMOVED*** / (nsteps - 1***REMOVED***
            for i in range(int(round(nsteps***REMOVED******REMOVED*** - 1***REMOVED***:
                i1 = int(round(i * stepsize***REMOVED******REMOVED***
                i2 = int(round((i + 1***REMOVED*** * stepsize***REMOVED******REMOVED***
                polyverts.append([topverts[0***REMOVED***[i1***REMOVED***,
                    topverts[0***REMOVED***[i2***REMOVED***,
                    botverts[0***REMOVED***[i2***REMOVED***,
                    botverts[0***REMOVED***[i1***REMOVED******REMOVED******REMOVED***

                v1 = np.array(topverts[0***REMOVED***[i1***REMOVED******REMOVED*** - np.array(topverts[0***REMOVED***[i2***REMOVED******REMOVED***
                v2 = np.array(topverts[0***REMOVED***[i1***REMOVED******REMOVED*** - np.array(botverts[0***REMOVED***[i1***REMOVED******REMOVED***
                normals.append(np.cross(v1, v2***REMOVED******REMOVED***

            colors = self._shade_colors(color, normals***REMOVED***
            colors2 = self._shade_colors(color, normals***REMOVED***
            polycol = art3d.Poly3DCollection(polyverts,
                                             facecolors=colors,
                                             edgecolors=colors2***REMOVED***
            polycol.set_sort_zpos(z***REMOVED***
            self.add_collection3d(polycol***REMOVED***

        for col in colls:
            self.collections.remove(col***REMOVED***

    def add_contour_set(self, cset, extend3d=False, stride=5, zdir='z', offset=None***REMOVED***:
        zdir = '-' + zdir
        if extend3d:
            self._3d_extend_contour(cset, stride***REMOVED***
        else:
            for z, linec in zip(cset.levels, cset.collections***REMOVED***:
                if offset is not None:
                    z = offset
                art3d.line_collection_2d_to_3d(linec, z, zdir=zdir***REMOVED***

    def add_contourf_set(self, cset, zdir='z', offset=None***REMOVED*** :
        zdir = '-' + zdir
        for z, linec in zip(cset.levels, cset.collections***REMOVED*** :
            if offset is not None :
                z = offset
            art3d.poly_collection_2d_to_3d(linec, z, zdir=zdir***REMOVED***
            linec.set_sort_zpos(z***REMOVED***

    def contour(self, X, Y, Z, *args, **kwargs***REMOVED***:
        '''
        Create a 3D contour plot.

        ==========  ================================================
        Argument    Description
        ==========  ================================================
        *X*, *Y*,   Data values as numpy.arrays
        *Z*
        *extend3d*  Whether to extend contour in 3D (default: False***REMOVED***
        *stride*    Stride (step size***REMOVED*** for extending contour
        *zdir*      The direction to use: x, y or z (default***REMOVED***
        *offset*    If specified plot a projection of the contour
                    lines on this position in plane normal to zdir
        ==========  ================================================

        The positional and other keyword arguments are passed on to
        :func:`~matplotlib.axes.Axes.contour`

        Returns a :class:`~matplotlib.axes.Axes.contour`
        '''

        extend3d = kwargs.pop('extend3d', False***REMOVED***
        stride = kwargs.pop('stride', 5***REMOVED***
        zdir = kwargs.pop('zdir', 'z'***REMOVED***
        offset = kwargs.pop('offset', None***REMOVED***

        had_data = self.has_data(***REMOVED***

        jX, jY, jZ = art3d.rotate_axes(X, Y, Z, zdir***REMOVED***
        cset = Axes.contour(self, jX, jY, jZ, *args, **kwargs***REMOVED***
        self.add_contour_set(cset, extend3d, stride, zdir, offset***REMOVED***

        self.auto_scale_xyz(X, Y, Z, had_data***REMOVED***
        return cset

    contour3D = contour

    def tricontour(self, *args, **kwargs***REMOVED***:
        ***REMOVED***
        Create a 3D contour plot.

        ==========  ================================================
        Argument    Description
        ==========  ================================================
        *X*, *Y*,   Data values as numpy.arrays
        *Z*
        *extend3d*  Whether to extend contour in 3D (default: False***REMOVED***
        *stride*    Stride (step size***REMOVED*** for extending contour
        *zdir*      The direction to use: x, y or z (default***REMOVED***
        *offset*    If specified plot a projection of the contour
                    lines on this position in plane normal to zdir
        ==========  ================================================

        Other keyword arguments are passed on to
        :func:`~matplotlib.axes.Axes.tricontour`

        Returns a :class:`~matplotlib.axes.Axes.contour`

        .. versionchanged:: 1.3.0
            Added support for custom triangulations

        EXPERIMENTAL:  This method currently produces incorrect output due to a
        longstanding bug in 3D PolyCollection rendering.
        ***REMOVED***

        extend3d = kwargs.pop('extend3d', False***REMOVED***
        stride = kwargs.pop('stride', 5***REMOVED***
        zdir = kwargs.pop('zdir', 'z'***REMOVED***
        offset = kwargs.pop('offset', None***REMOVED***

        had_data = self.has_data(***REMOVED***

        tri, args, kwargs = Triangulation.get_from_args_and_kwargs(
                *args, **kwargs***REMOVED***
        X = tri.x
        Y = tri.y
        if 'Z' in kwargs:
            Z = kwargs.pop('Z'***REMOVED***
        else:
            Z = args[0***REMOVED***
            # We do this so Z doesn't get passed as an arg to Axes.tricontour
            args = args[1:***REMOVED***

        jX, jY, jZ = art3d.rotate_axes(X, Y, Z, zdir***REMOVED***
        tri = Triangulation(jX, jY, tri.triangles, tri.mask***REMOVED***

        cset = Axes.tricontour(self, tri, jZ, *args, **kwargs***REMOVED***
        self.add_contour_set(cset, extend3d, stride, zdir, offset***REMOVED***

        self.auto_scale_xyz(X, Y, Z, had_data***REMOVED***
        return cset

    def contourf(self, X, Y, Z, *args, **kwargs***REMOVED***:
        '''
        Create a 3D contourf plot.

        ==========  ================================================
        Argument    Description
        ==========  ================================================
        *X*, *Y*,   Data values as numpy.arrays
        *Z*
        *zdir*      The direction to use: x, y or z (default***REMOVED***
        *offset*    If specified plot a projection of the filled contour
                    on this position in plane normal to zdir
        ==========  ================================================

        The positional and keyword arguments are passed on to
        :func:`~matplotlib.axes.Axes.contourf`

        Returns a :class:`~matplotlib.axes.Axes.contourf`

        .. versionchanged :: 1.1.0
            The *zdir* and *offset* kwargs were added.
        '''

        zdir = kwargs.pop('zdir', 'z'***REMOVED***
        offset = kwargs.pop('offset', None***REMOVED***

        had_data = self.has_data(***REMOVED***

        jX, jY, jZ = art3d.rotate_axes(X, Y, Z, zdir***REMOVED***
        cset = Axes.contourf(self, jX, jY, jZ, *args, **kwargs***REMOVED***
        self.add_contourf_set(cset, zdir, offset***REMOVED***

        self.auto_scale_xyz(X, Y, Z, had_data***REMOVED***
        return cset

    contourf3D = contourf

    def tricontourf(self, *args, **kwargs***REMOVED***:
        ***REMOVED***
        Create a 3D contourf plot.

        ==========  ================================================
        Argument    Description
        ==========  ================================================
        *X*, *Y*,   Data values as numpy.arrays
        *Z*
        *zdir*      The direction to use: x, y or z (default***REMOVED***
        *offset*    If specified plot a projection of the contour
                    lines on this position in plane normal to zdir
        ==========  ================================================

        Other keyword arguments are passed on to
        :func:`~matplotlib.axes.Axes.tricontour`

        Returns a :class:`~matplotlib.axes.Axes.contour`

        .. versionchanged :: 1.3.0
            Added support for custom triangulations

        EXPERIMENTAL:  This method currently produces incorrect output due to a
        longstanding bug in 3D PolyCollection rendering.
        ***REMOVED***
        zdir = kwargs.pop('zdir', 'z'***REMOVED***
        offset = kwargs.pop('offset', None***REMOVED***

        had_data = self.has_data(***REMOVED***

        tri, args, kwargs = Triangulation.get_from_args_and_kwargs(
                *args, **kwargs***REMOVED***
        X = tri.x
        Y = tri.y
        if 'Z' in kwargs:
            Z = kwargs.pop('Z'***REMOVED***
        else:
            Z = args[0***REMOVED***
            # We do this so Z doesn't get passed as an arg to Axes.tricontourf
            args = args[1:***REMOVED***

        jX, jY, jZ = art3d.rotate_axes(X, Y, Z, zdir***REMOVED***
        tri = Triangulation(jX, jY, tri.triangles, tri.mask***REMOVED***

        cset = Axes.tricontourf(self, tri, jZ, *args, **kwargs***REMOVED***
        self.add_contourf_set(cset, zdir, offset***REMOVED***

        self.auto_scale_xyz(X, Y, Z, had_data***REMOVED***
        return cset

    def add_collection3d(self, col, zs=0, zdir='z'***REMOVED***:
        '''
        Add a 3D collection object to the plot.

        2D collection types are converted to a 3D version by
        modifying the object and adding z coordinate information.

        Supported are:
            - PolyCollection
            - LineColleciton
            - PatchCollection
        '''
        zvals = np.atleast_1d(zs***REMOVED***
        if len(zvals***REMOVED*** > 0 :
            zsortval = min(zvals***REMOVED***
        else :
            zsortval = 0   # FIXME: Fairly arbitrary. Is there a better value?

        # FIXME: use issubclass(***REMOVED*** (although, then a 3D collection
        #       object would also pass.***REMOVED***  Maybe have a collection3d
        #       abstract class to test for and exclude?
        if type(col***REMOVED*** is mcoll.PolyCollection:
            art3d.poly_collection_2d_to_3d(col, zs=zs, zdir=zdir***REMOVED***
            col.set_sort_zpos(zsortval***REMOVED***
        elif type(col***REMOVED*** is mcoll.LineCollection:
            art3d.line_collection_2d_to_3d(col, zs=zs, zdir=zdir***REMOVED***
            col.set_sort_zpos(zsortval***REMOVED***
        elif type(col***REMOVED*** is mcoll.PatchCollection:
            art3d.patch_collection_2d_to_3d(col, zs=zs, zdir=zdir***REMOVED***
            col.set_sort_zpos(zsortval***REMOVED***

        Axes.add_collection(self, col***REMOVED***

    def scatter(self, xs, ys, zs=0, zdir='z', s=20, c=None, depthshade=True,
                *args, **kwargs***REMOVED***:
        '''
        Create a scatter plot.

        ============  ========================================================
        Argument      Description
        ============  ========================================================
        *xs*, *ys*    Positions of data points.
        *zs*          Either an array of the same length as *xs* and
                      *ys* or a single value to place all points in
                      the same plane. Default is 0.
        *zdir*        Which direction to use as z ('x', 'y' or 'z'***REMOVED***
                      when plotting a 2D set.
        *s*           Size in points^2.  It is a scalar or an array of the
                      same length as *x* and *y*.

        *c*           A color. *c* can be a single color format string, or a
                      sequence of color specifications of length *N*, or a
                      sequence of *N* numbers to be mapped to colors using the
                      *cmap* and *norm* specified via kwargs (see below***REMOVED***. Note
                      that *c* should not be a single numeric RGB or RGBA
                      sequence because that is indistinguishable from an array
                      of values to be colormapped.  *c* can be a 2-D array in
                      which the rows are RGB or RGBA, however, including the
                      case of a single row to specify the same color for
                      all points.

        *depthshade*
                      Whether or not to shade the scatter markers to give
                      the appearance of depth. Default is *True*.
        ============  ========================================================

        Keyword arguments are passed on to
        :func:`~matplotlib.axes.Axes.scatter`.

        Returns a :class:`~mpl_toolkits.mplot3d.art3d.Patch3DCollection`
        '''

        had_data = self.has_data(***REMOVED***

        xs = np.ma.ravel(xs***REMOVED***
        ys = np.ma.ravel(ys***REMOVED***
        zs = np.ma.ravel(zs***REMOVED***
        if xs.size != ys.size:
            raise ValueError("Arguments 'xs' and 'ys' must be of same size."***REMOVED***
        if xs.size != zs.size:
            if zs.size == 1:
                zs = np.tile(zs[0***REMOVED***, xs.size***REMOVED***
            else:
                raise ValueError(("Argument 'zs' must be of same size as 'xs' "
                    "and 'ys' or of size 1."***REMOVED******REMOVED***

        s = np.ma.ravel(s***REMOVED***  # This doesn't have to match x, y in size.

        if c is not None:
            cstr = cbook.is_string_like(c***REMOVED*** or cbook.is_sequence_of_strings(c***REMOVED***
            if not cstr:
                c = np.asanyarray(c***REMOVED***
                if c.size == xs.size:
                    c = np.ma.ravel(c***REMOVED***
            xs, ys, zs, s, c = cbook.delete_masked_points(xs, ys, zs, s, c***REMOVED***
        else:
            xs, ys, zs, s = cbook.delete_masked_points(xs, ys, zs, s***REMOVED***

        patches = Axes.scatter(self, xs, ys, s=s, c=c, *args, **kwargs***REMOVED***
        if not cbook.iterable(zs***REMOVED***:
            is_2d = True
            zs = np.ones(len(xs***REMOVED******REMOVED*** * zs
        else:
            is_2d = False
        art3d.patch_collection_2d_to_3d(patches, zs=zs, zdir=zdir,
                                        depthshade=depthshade***REMOVED***

        if self._zmargin < 0.05 and xs.size > 0:
            self.set_zmargin(0.05***REMOVED***

        #FIXME: why is this necessary?
        if not is_2d:
            self.auto_scale_xyz(xs, ys, zs, had_data***REMOVED***

        return patches

    scatter3D = scatter

    def bar(self, left, height, zs=0, zdir='z', *args, **kwargs***REMOVED***:
        '''
        Add 2D bar(s***REMOVED***.

        ==========  ================================================
        Argument    Description
        ==========  ================================================
        *left*      The x coordinates of the left sides of the bars.
        *height*    The height of the bars.
        *zs*        Z coordinate of bars, if one value is specified
                    they will all be placed at the same z.
        *zdir*      Which direction to use as z ('x', 'y' or 'z'***REMOVED***
                    when plotting a 2D set.
        ==========  ================================================

        Keyword arguments are passed onto :func:`~matplotlib.axes.Axes.bar`.

        Returns a :class:`~mpl_toolkits.mplot3d.art3d.Patch3DCollection`
        '''

        had_data = self.has_data(***REMOVED***

        patches = Axes.bar(self, left, height, *args, **kwargs***REMOVED***

        if not cbook.iterable(zs***REMOVED***:
            zs = np.ones(len(left***REMOVED******REMOVED*** * zs

        verts = [***REMOVED***
        verts_zs = [***REMOVED***
        for p, z in zip(patches, zs***REMOVED***:
            vs = art3d.get_patch_verts(p***REMOVED***
            verts += vs.tolist(***REMOVED***
            verts_zs += [z***REMOVED*** * len(vs***REMOVED***
            art3d.patch_2d_to_3d(p, z, zdir***REMOVED***
            if 'alpha' in kwargs:
                p.set_alpha(kwargs['alpha'***REMOVED******REMOVED***

        if len(verts***REMOVED*** > 0 :
            # the following has to be skipped if verts is empty
            # NOTE: Bugs could still occur if len(verts***REMOVED*** > 0,
            #       but the "2nd dimension" is empty.
            xs, ys = list(zip(*verts***REMOVED******REMOVED***
        else :
            xs, ys = [***REMOVED***, [***REMOVED***

        xs, ys, verts_zs = art3d.juggle_axes(xs, ys, verts_zs, zdir***REMOVED***
        self.auto_scale_xyz(xs, ys, verts_zs, had_data***REMOVED***

        return patches

    def bar3d(self, x, y, z, dx, dy, dz, color='b',
              zsort='average', *args, **kwargs***REMOVED***:
        '''
        Generate a 3D bar, or multiple bars.

        When generating multiple bars, x, y, z have to be arrays.
        dx, dy, dz can be arrays or scalars.

        *color* can be:

         - A single color value, to color all bars the same color.

         - An array of colors of length N bars, to color each bar
           independently.

         - An array of colors of length 6, to color the faces of the
           bars similarly.

         - An array of colors of length 6 * N bars, to color each face
           independently.

         When coloring the faces of the boxes specifically, this is
         the order of the coloring:

          1. -Z (bottom of box***REMOVED***
          2. +Z (top of box***REMOVED***
          3. -Y
          4. +Y
          5. -X
          6. +X

        Keyword arguments are passed onto
        :func:`~mpl_toolkits.mplot3d.art3d.Poly3DCollection`
        '''
        had_data = self.has_data(***REMOVED***

        if not cbook.iterable(x***REMOVED***:
            x = [x***REMOVED***
        if not cbook.iterable(y***REMOVED***:
            y = [y***REMOVED***
        if not cbook.iterable(z***REMOVED***:
            z = [z***REMOVED***

        if not cbook.iterable(dx***REMOVED***:
            dx = [dx***REMOVED***
        if not cbook.iterable(dy***REMOVED***:
            dy = [dy***REMOVED***
        if not cbook.iterable(dz***REMOVED***:
            dz = [dz***REMOVED***

        if len(dx***REMOVED*** == 1:
            dx = dx * len(x***REMOVED***
        if len(dy***REMOVED*** == 1:
            dy = dy * len(y***REMOVED***
        if len(dz***REMOVED*** == 1:
            dz = dz * len(z***REMOVED***

        if len(x***REMOVED*** != len(y***REMOVED*** or len(x***REMOVED*** != len(z***REMOVED***:
            warnings.warn('x, y, and z must be the same length.'***REMOVED***

        # FIXME: This is archaic and could be done much better.
        minx, miny, minz = 1e20, 1e20, 1e20
        maxx, maxy, maxz = -1e20, -1e20, -1e20

        polys = [***REMOVED***
        for xi, yi, zi, dxi, dyi, dzi in zip(x, y, z, dx, dy, dz***REMOVED***:
            minx = min(xi, minx***REMOVED***
            maxx = max(xi + dxi, maxx***REMOVED***
            miny = min(yi, miny***REMOVED***
            maxy = max(yi + dyi, maxy***REMOVED***
            minz = min(zi, minz***REMOVED***
            maxz = max(zi + dzi, maxz***REMOVED***

            polys.extend([
                ((xi, yi, zi***REMOVED***, (xi + dxi, yi, zi***REMOVED***,
                    (xi + dxi, yi + dyi, zi***REMOVED***, (xi, yi + dyi, zi***REMOVED******REMOVED***,
                ((xi, yi, zi + dzi***REMOVED***, (xi + dxi, yi, zi + dzi***REMOVED***,
                    (xi + dxi, yi + dyi, zi + dzi***REMOVED***, (xi, yi + dyi, zi + dzi***REMOVED******REMOVED***,

                ((xi, yi, zi***REMOVED***, (xi + dxi, yi, zi***REMOVED***,
                    (xi + dxi, yi, zi + dzi***REMOVED***, (xi, yi, zi + dzi***REMOVED******REMOVED***,
                ((xi, yi + dyi, zi***REMOVED***, (xi + dxi, yi + dyi, zi***REMOVED***,
                    (xi + dxi, yi + dyi, zi + dzi***REMOVED***, (xi, yi + dyi, zi + dzi***REMOVED******REMOVED***,

                ((xi, yi, zi***REMOVED***, (xi, yi + dyi, zi***REMOVED***,
                    (xi, yi + dyi, zi + dzi***REMOVED***, (xi, yi, zi + dzi***REMOVED******REMOVED***,
                ((xi + dxi, yi, zi***REMOVED***, (xi + dxi, yi + dyi, zi***REMOVED***,
                    (xi + dxi, yi + dyi, zi + dzi***REMOVED***, (xi + dxi, yi, zi + dzi***REMOVED******REMOVED***,
            ***REMOVED******REMOVED***

        facecolors = [***REMOVED***
        if color is None:
            # no color specified
            facecolors = [None***REMOVED*** * len(x***REMOVED***
        elif len(color***REMOVED*** == len(x***REMOVED***:
            # bar colors specified, need to expand to number of faces
            for c in color:
                facecolors.extend([c***REMOVED*** * 6***REMOVED***
        else:
            # a single color specified, or face colors specified explicitly
            facecolors = list(colorConverter.to_rgba_array(color***REMOVED******REMOVED***
            if len(facecolors***REMOVED*** < len(x***REMOVED***:
                facecolors *= (6 * len(x***REMOVED******REMOVED***

        normals = self._generate_normals(polys***REMOVED***
        sfacecolors = self._shade_colors(facecolors, normals***REMOVED***
        col = art3d.Poly3DCollection(polys,
                                     zsort=zsort,
                                     facecolor=sfacecolors,
                                     *args, **kwargs***REMOVED***
        self.add_collection(col***REMOVED***

        self.auto_scale_xyz((minx, maxx***REMOVED***, (miny, maxy***REMOVED***, (minz, maxz***REMOVED***, had_data***REMOVED***

        return col

    def set_title(self, label, fontdict=None, loc='center', **kwargs***REMOVED***:
        ret = Axes.set_title(self, label, fontdict=fontdict, loc=loc, **kwargs***REMOVED***
        (x, y***REMOVED*** = self.title.get_position(***REMOVED***
        self.title.set_y(0.92 * y***REMOVED***
        return ret
    set_title.__doc__ = maxes.Axes.set_title.__doc__

    def quiver(self, *args, **kwargs***REMOVED***:
        ***REMOVED***
        Plot a 3D field of arrows.

        call signatures::

            quiver(X, Y, Z, U, V, W, **kwargs***REMOVED***

        Arguments:

            *X*, *Y*, *Z*:
                The x, y and z coordinates of the arrow locations (default is
                tip of arrow; see *pivot* kwarg***REMOVED***

            *U*, *V*, *W*:
                The x, y and z components of the arrow vectors

        The arguments could be array-like or scalars, so long as they
        they can be broadcast together. The arguments can also be
        masked arrays. If an element in any of argument is masked, then
        that corresponding quiver element will not be plotted.

        Keyword arguments:

            *length*: [1.0 | float***REMOVED***
                The length of each quiver, default to 1.0, the unit is
                the same with the axes

            *arrow_length_ratio*: [0.3 | float***REMOVED***
                The ratio of the arrow head with respect to the quiver,
                default to 0.3

            *pivot*: [ 'tail' | 'middle' | 'tip' ***REMOVED***
                The part of the arrow that is at the grid point; the arrow
                rotates about this point, hence the name *pivot*.

        Any additional keyword arguments are delegated to
        :class:`~matplotlib.collections.LineCollection`

        ***REMOVED***
        def calc_arrow(uvw, angle=15***REMOVED***:
            ***REMOVED***
            To calculate the arrow head. uvw should be a unit vector.
            ***REMOVED***
            # get unit direction vector perpendicular to (u,v,w***REMOVED***
            norm = np.linalg.norm(uvw[:2***REMOVED******REMOVED***
            if norm > 0:
                x = uvw[1***REMOVED*** / norm
                y = -uvw[0***REMOVED*** / norm
            else:
                x, y = 0, 1

            # compute the two arrowhead direction unit vectors
            ra = math.radians(angle***REMOVED***
            c = math.cos(ra***REMOVED***
            s = math.sin(ra***REMOVED***

            # construct the rotation matrices
            Rpos = np.array([[c+(x**2***REMOVED****(1-c***REMOVED***, x*y*(1-c***REMOVED***, y*s***REMOVED***,
                             [y*x*(1-c***REMOVED***, c+(y**2***REMOVED****(1-c***REMOVED***, -x*s***REMOVED***,
                             [-y*s, x*s, c***REMOVED******REMOVED******REMOVED***
            # opposite rotation negates everything but the diagonal
            Rneg = Rpos * (np.eye(3***REMOVED****2 - 1***REMOVED***

            # multiply them to get the rotated vector
            return Rpos.dot(uvw***REMOVED***, Rneg.dot(uvw***REMOVED***

        had_data = self.has_data(***REMOVED***

        # handle kwargs
        # shaft length
        length = kwargs.pop('length', 1***REMOVED***
        # arrow length ratio to the shaft length
        arrow_length_ratio = kwargs.pop('arrow_length_ratio', 0.3***REMOVED***
        # pivot point
        pivot = kwargs.pop('pivot', 'tip'***REMOVED***

        # handle args
        argi = 6
        if len(args***REMOVED*** < argi:
            ValueError('Wrong number of arguments. Expected %d got %d' %
                       (argi, len(args***REMOVED******REMOVED******REMOVED***

        # first 6 arguments are X, Y, Z, U, V, W
        input_args = args[:argi***REMOVED***
        # if any of the args are scalar, convert into list
        input_args = [[k***REMOVED*** if isinstance(k, (int, float***REMOVED******REMOVED*** else k
                      for k in input_args***REMOVED***

        # extract the masks, if any
        masks = [k.mask for k in input_args if isinstance(k, np.ma.MaskedArray***REMOVED******REMOVED***
        # broadcast to match the shape
        bcast = np.broadcast_arrays(*(input_args + masks***REMOVED******REMOVED***
        input_args = bcast[:argi***REMOVED***
        masks = bcast[argi:***REMOVED***
        if masks:
            # combine the masks into one
            mask = reduce(np.logical_or, masks***REMOVED***
            # put mask on and compress
            input_args = [np.ma.array(k, mask=mask***REMOVED***.compressed(***REMOVED***
                          for k in input_args***REMOVED***
        else:
            input_args = [k.flatten(***REMOVED*** for k in input_args***REMOVED***

        if any(len(v***REMOVED*** == 0 for v in input_args***REMOVED***:
            # No quivers, so just make an empty collection and return early
            linec = art3d.Line3DCollection([***REMOVED***, *args[argi:***REMOVED***, **kwargs***REMOVED***
            self.add_collection(linec***REMOVED***
            return linec

        # Following assertions must be true before proceeding
        # must all be ndarray
        assert all(isinstance(k, np.ndarray***REMOVED*** for k in input_args***REMOVED***
        # must all in same shape
        assert len(set([k.shape for k in input_args***REMOVED******REMOVED******REMOVED*** == 1

        shaft_dt = np.linspace(0, length, num=2***REMOVED***
        arrow_dt = shaft_dt * arrow_length_ratio

        if pivot == 'tail':
            shaft_dt -= length
        elif pivot == 'middle':
            shaft_dt -= length/2.
        elif pivot != 'tip':
            raise ValueError('Invalid pivot argument: ' + str(pivot***REMOVED******REMOVED***

        XYZ = np.column_stack(input_args[:3***REMOVED******REMOVED***
        UVW = np.column_stack(input_args[3:argi***REMOVED******REMOVED***.astype(float***REMOVED***

        # Normalize rows of UVW
        # Note: with numpy 1.9+, could use np.linalg.norm(UVW, axis=1***REMOVED***
        norm = np.sqrt(np.sum(UVW**2, axis=1***REMOVED******REMOVED***

        # If any row of UVW is all zeros, don't make a quiver for it
        mask = norm > 1e-10
        XYZ = XYZ[mask***REMOVED***
        UVW = UVW[mask***REMOVED*** / norm[mask***REMOVED***.reshape((-1, 1***REMOVED******REMOVED***

        if len(XYZ***REMOVED*** > 0:
            # compute the shaft lines all at once with an outer product
            shafts = (XYZ - np.multiply.outer(shaft_dt, UVW***REMOVED******REMOVED***.swapaxes(0, 1***REMOVED***
            # compute head direction vectors, n heads by 2 sides by 3 dimensions
            head_dirs = np.array([calc_arrow(d***REMOVED*** for d in UVW***REMOVED******REMOVED***
            # compute all head lines at once, starting from where the shaft ends
            heads = shafts[:, :1***REMOVED*** - np.multiply.outer(arrow_dt, head_dirs***REMOVED***
            # stack left and right head lines together
            heads.shape = (len(arrow_dt***REMOVED***, -1, 3***REMOVED***
            # transpose to get a list of lines
            heads = heads.swapaxes(0, 1***REMOVED***

            lines = list(shafts***REMOVED*** + list(heads***REMOVED***
        else:
            lines = [***REMOVED***

        linec = art3d.Line3DCollection(lines, *args[argi:***REMOVED***, **kwargs***REMOVED***
        self.add_collection(linec***REMOVED***

        self.auto_scale_xyz(XYZ[:, 0***REMOVED***, XYZ[:, 1***REMOVED***, XYZ[:, 2***REMOVED***, had_data***REMOVED***

        return linec

    quiver3D = quiver


def get_test_data(delta=0.05***REMOVED***:
    '''
    Return a tuple X, Y, Z with a test data set.
    '''

    from matplotlib.mlab import  bivariate_normal
    x = y = np.arange(-3.0, 3.0, delta***REMOVED***
    X, Y = np.meshgrid(x, y***REMOVED***

    Z1 = bivariate_normal(X, Y, 1.0, 1.0, 0.0, 0.0***REMOVED***
    Z2 = bivariate_normal(X, Y, 1.5, 0.5, 1, 1***REMOVED***
    Z = Z2 - Z1

    X = X * 10
    Y = Y * 10
    Z = Z * 500
    return X, Y, Z



########################################################
# Register Axes3D as a 'projection' object available
# for use just like any other axes
########################################################
import matplotlib.projections as proj
proj.projection_registry.register(Axes3D***REMOVED***
