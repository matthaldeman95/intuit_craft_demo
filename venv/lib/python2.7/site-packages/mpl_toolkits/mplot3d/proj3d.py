#!/usr/bin/python
# 3dproj.py
#
***REMOVED***
Various transforms used for by the 3D code
***REMOVED***
from __future__ import (absolute_import, division, print_function,
                        unicode_literals***REMOVED***

from matplotlib.externals import six
from matplotlib.externals.six.moves import zip

from matplotlib.collections import LineCollection
from matplotlib.patches import Circle
import numpy as np
import numpy.linalg as linalg



def line2d(p0, p1***REMOVED***:
    ***REMOVED***
    Return 2D equation of line in the form ax+by+c = 0
    ***REMOVED***
    # x + x1  = 0
    x0, y0 = p0[:2***REMOVED***
    x1, y1 = p1[:2***REMOVED***
    #
    if x0 == x1:
        a = -1
        b = 0
        c = x1
    elif y0 == y1:
        a = 0
        b = 1
        c = -y1
    else:
        a = (y0-y1***REMOVED***
        b = (x0-x1***REMOVED***
        c = (x0*y1 - x1*y0***REMOVED***
    return a, b, c

def line2d_dist(l, p***REMOVED***:
    ***REMOVED***
    Distance from line to point
    line is a tuple of coefficients a,b,c
    ***REMOVED***
    a, b, c = l
    x0, y0 = p
    return abs((a*x0 + b*y0 + c***REMOVED***/np.sqrt(a**2+b**2***REMOVED******REMOVED***


def line2d_seg_dist(p1, p2, p0***REMOVED***:
    ***REMOVED***distance(s***REMOVED*** from line defined by p1 - p2 to point(s***REMOVED*** p0

    p0[0***REMOVED*** = x(s***REMOVED***
    p0[1***REMOVED*** = y(s***REMOVED***

    intersection point p = p1 + u*(p2-p1***REMOVED***
    and intersection point lies within segment if u is between 0 and 1
    ***REMOVED***

    x21 = p2[0***REMOVED*** - p1[0***REMOVED***
    y21 = p2[1***REMOVED*** - p1[1***REMOVED***
    x01 = np.asarray(p0[0***REMOVED******REMOVED*** - p1[0***REMOVED***
    y01 = np.asarray(p0[1***REMOVED******REMOVED*** - p1[1***REMOVED***

    u = (x01*x21 + y01*y21***REMOVED***/float(abs(x21**2 + y21**2***REMOVED******REMOVED***
    u = np.clip(u, 0, 1***REMOVED***
    d = np.sqrt((x01 - u*x21***REMOVED*****2 + (y01 - u*y21***REMOVED*****2***REMOVED***

    return d

def test_lines_dists(***REMOVED***:
    import pylab
    ax = pylab.gca(***REMOVED***

    xs, ys = (0,30***REMOVED***, (20,150***REMOVED***
    pylab.plot(xs, ys***REMOVED***
    points = list(zip(xs, ys***REMOVED******REMOVED***
    p0, p1 = points

    xs, ys = (0,0,20,30***REMOVED***, (100,150,30,200***REMOVED***
    pylab.scatter(xs, ys***REMOVED***

    dist = line2d_seg_dist(p0, p1, (xs[0***REMOVED***, ys[0***REMOVED******REMOVED******REMOVED***
    dist = line2d_seg_dist(p0, p1, np.array((xs, ys***REMOVED******REMOVED******REMOVED***
    for x, y, d in zip(xs, ys, dist***REMOVED***:
        c = Circle((x, y***REMOVED***, d, fill=0***REMOVED***
        ax.add_patch(c***REMOVED***

    pylab.xlim(-200, 200***REMOVED***
    pylab.ylim(-200, 200***REMOVED***
    pylab.show(***REMOVED***

def mod(v***REMOVED***:
    ***REMOVED***3d vector length***REMOVED***
    return np.sqrt(v[0***REMOVED*****2+v[1***REMOVED*****2+v[2***REMOVED*****2***REMOVED***

def world_transformation(xmin, xmax,
                         ymin, ymax,
                         zmin, zmax***REMOVED***:
    dx, dy, dz = (xmax-xmin***REMOVED***, (ymax-ymin***REMOVED***, (zmax-zmin***REMOVED***
    return np.array([
        [1.0/dx,0,0,-xmin/dx***REMOVED***,
        [0,1.0/dy,0,-ymin/dy***REMOVED***,
        [0,0,1.0/dz,-zmin/dz***REMOVED***,
        [0,0,0,1.0***REMOVED******REMOVED******REMOVED***

def test_world(***REMOVED***:
    xmin, xmax = 100, 120
    ymin, ymax = -100, 100
    zmin, zmax = 0.1, 0.2
    M = world_transformation(xmin, xmax, ymin, ymax, zmin, zmax***REMOVED***
    print(M***REMOVED***

def view_transformation(E, R, V***REMOVED***:
    n = (E - R***REMOVED***
    ## new
#    n /= mod(n***REMOVED***
#    u = np.cross(V,n***REMOVED***
#    u /= mod(u***REMOVED***
#    v = np.cross(n,u***REMOVED***
#    Mr = np.diag([1.***REMOVED****4***REMOVED***
#    Mt = np.diag([1.***REMOVED****4***REMOVED***
#    Mr[:3,:3***REMOVED*** = u,v,n
#    Mt[:3,-1***REMOVED*** = -E
    ## end new

    ## old
    n = n / mod(n***REMOVED***
    u = np.cross(V, n***REMOVED***
    u = u / mod(u***REMOVED***
    v = np.cross(n, u***REMOVED***
    Mr = [[u[0***REMOVED***,u[1***REMOVED***,u[2***REMOVED***,0***REMOVED***,
          [v[0***REMOVED***,v[1***REMOVED***,v[2***REMOVED***,0***REMOVED***,
          [n[0***REMOVED***,n[1***REMOVED***,n[2***REMOVED***,0***REMOVED***,
          [0,   0,   0,   1***REMOVED***,
          ***REMOVED***
    #
    Mt = [[1, 0, 0, -E[0***REMOVED******REMOVED***,
          [0, 1, 0, -E[1***REMOVED******REMOVED***,
          [0, 0, 1, -E[2***REMOVED******REMOVED***,
          [0, 0, 0, 1***REMOVED******REMOVED***
    ## end old

    return np.dot(Mr, Mt***REMOVED***

def persp_transformation(zfront, zback***REMOVED***:
    a = (zfront+zback***REMOVED***/(zfront-zback***REMOVED***
    b = -2*(zfront*zback***REMOVED***/(zfront-zback***REMOVED***
    return np.array([[1,0,0,0***REMOVED***,
                     [0,1,0,0***REMOVED***,
                     [0,0,a,b***REMOVED***,
                     [0,0,-1,0***REMOVED***
                     ***REMOVED******REMOVED***

def proj_transform_vec(vec, M***REMOVED***:
    vecw = np.dot(M, vec***REMOVED***
    w = vecw[3***REMOVED***
    # clip here..
    txs, tys, tzs = vecw[0***REMOVED***/w, vecw[1***REMOVED***/w, vecw[2***REMOVED***/w
    return txs, tys, tzs

def proj_transform_vec_clip(vec, M***REMOVED***:
    vecw = np.dot(M, vec***REMOVED***
    w = vecw[3***REMOVED***
    # clip here..
    txs, tys, tzs = vecw[0***REMOVED***/w, vecw[1***REMOVED***/w, vecw[2***REMOVED***/w
    tis = (vecw[0***REMOVED*** >= 0***REMOVED*** * (vecw[0***REMOVED*** <= 1***REMOVED*** * (vecw[1***REMOVED*** >= 0***REMOVED*** * (vecw[1***REMOVED*** <= 1***REMOVED***
    if np.sometrue(tis***REMOVED***:
        tis =  vecw[1***REMOVED*** < 1
    return txs, tys, tzs, tis

def inv_transform(xs, ys, zs, M***REMOVED***:
    iM = linalg.inv(M***REMOVED***
    vec = vec_pad_ones(xs, ys, zs***REMOVED***
    vecr = np.dot(iM, vec***REMOVED***
    ***REMOVED***
        vecr = vecr/vecr[3***REMOVED***
    except OverflowError:
        pass
    return vecr[0***REMOVED***, vecr[1***REMOVED***, vecr[2***REMOVED***

def vec_pad_ones(xs, ys, zs***REMOVED***:
    ***REMOVED***
        ***REMOVED***
            vec = np.array([xs,ys,zs,np.ones(xs.shape***REMOVED******REMOVED******REMOVED***
        except (AttributeError,TypeError***REMOVED***:
            vec = np.array([xs,ys,zs,np.ones((len(xs***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***
    except TypeError:
        vec = np.array([xs,ys,zs,1***REMOVED******REMOVED***
    return vec

def proj_transform(xs, ys, zs, M***REMOVED***:
    ***REMOVED***
    Transform the points by the projection matrix
    ***REMOVED***
    vec = vec_pad_ones(xs, ys, zs***REMOVED***
    return proj_transform_vec(vec, M***REMOVED***

def proj_transform_clip(xs, ys, zs, M***REMOVED***:
    ***REMOVED***
    Transform the points by the projection matrix
    and return the clipping result
    returns txs,tys,tzs,tis
    ***REMOVED***
    vec = vec_pad_ones(xs, ys, zs***REMOVED***
    return proj_transform_vec_clip(vec, M***REMOVED***
transform = proj_transform

def proj_points(points, M***REMOVED***:
    return list(zip(*proj_trans_points(points, M***REMOVED******REMOVED******REMOVED***

def proj_trans_points(points, M***REMOVED***:
    xs, ys, zs = list(zip(*points***REMOVED******REMOVED***
    return proj_transform(xs, ys, zs, M***REMOVED***

def proj_trans_clip_points(points, M***REMOVED***:
    xs, ys, zs = list(zip(*points***REMOVED******REMOVED***
    return proj_transform_clip(xs, ys, zs, M***REMOVED***

def test_proj_draw_axes(M, s=1***REMOVED***:
    import pylab
    xs, ys, zs = [0, s, 0, 0***REMOVED***, [0, 0, s, 0***REMOVED***, [0, 0, 0, s***REMOVED***
    txs, tys, tzs = proj_transform(xs, ys, zs, M***REMOVED***
    o, ax, ay, az = (txs[0***REMOVED***, tys[0***REMOVED******REMOVED***, (txs[1***REMOVED***, tys[1***REMOVED******REMOVED***, \
            (txs[2***REMOVED***, tys[2***REMOVED******REMOVED***, (txs[3***REMOVED***, tys[3***REMOVED******REMOVED***
    lines = [(o, ax***REMOVED***, (o, ay***REMOVED***, (o, az***REMOVED******REMOVED***

    ax = pylab.gca(***REMOVED***
    linec = LineCollection(lines***REMOVED***
    ax.add_collection(linec***REMOVED***
    for x, y, t in zip(txs, tys, ['o', 'x', 'y', 'z'***REMOVED******REMOVED***:
        pylab.text(x, y, t***REMOVED***

def test_proj_make_M(E=None***REMOVED***:
    # eye point
    E = E or np.array([1, -1, 2***REMOVED******REMOVED*** * 1000
    #E = np.array([20,10,20***REMOVED******REMOVED***
    R = np.array([1, 1, 1***REMOVED******REMOVED*** * 100
    V = np.array([0, 0, 1***REMOVED******REMOVED***
    viewM = view_transformation(E, R, V***REMOVED***
    perspM = persp_transformation(100, -100***REMOVED***
    M = np.dot(perspM, viewM***REMOVED***
    return M

def test_proj(***REMOVED***:
    import pylab
    M = test_proj_make_M(***REMOVED***

    ts = ['%d' % i for i in [0,1,2,3,0,4,5,6,7,4***REMOVED******REMOVED***
    xs, ys, zs = [0,1,1,0,0, 0,1,1,0,0***REMOVED***, [0,0,1,1,0, 0,0,1,1,0***REMOVED***, \
            [0,0,0,0,0, 1,1,1,1,1***REMOVED***
    xs, ys, zs = [np.array(v***REMOVED****300 for v in (xs, ys, zs***REMOVED******REMOVED***
    #
    test_proj_draw_axes(M, s=400***REMOVED***
    txs, tys, tzs = proj_transform(xs, ys, zs, M***REMOVED***
    ixs, iys, izs = inv_transform(txs, tys, tzs, M***REMOVED***

    pylab.scatter(txs, tys, c=tzs***REMOVED***
    pylab.plot(txs, tys, c='r'***REMOVED***
    for x, y, t in zip(txs, tys, ts***REMOVED***:
        pylab.text(x, y, t***REMOVED***

    pylab.xlim(-0.2, 0.2***REMOVED***
    pylab.ylim(-0.2, 0.2***REMOVED***

    pylab.show(***REMOVED***

def rot_x(V, alpha***REMOVED***:
    cosa, sina = np.cos(alpha***REMOVED***, np.sin(alpha***REMOVED***
    M1 = np.array([[1,0,0,0***REMOVED***,
                   [0,cosa,-sina,0***REMOVED***,
                   [0,sina,cosa,0***REMOVED***,
                   [0,0,0,0***REMOVED******REMOVED******REMOVED***

    return np.dot(M1, V***REMOVED***

def test_rot(***REMOVED***:
    V = [1,0,0,1***REMOVED***
    print(rot_x(V, np.pi/6***REMOVED******REMOVED***
    V = [0,1,0,1***REMOVED***
    print(rot_x(V, np.pi/6***REMOVED******REMOVED***


if __name__ == "__main__":
    test_proj(***REMOVED***
