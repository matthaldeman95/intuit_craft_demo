#!/usr/bin/python
# art3d.py, original mplot3d version by John Porter
# Parts rewritten by Reinier Heeres <reinier@heeres.eu>
# Minor additions by Ben Axelrod <baxelrod@coroware.com>

'''
Module containing 3D artist code and functions to convert 2D
artists into 3D versions which can be added to an Axes3D.
'''
from __future__ import (absolute_import, division, print_function,
                        unicode_literals***REMOVED***

from matplotlib.externals import six
from matplotlib.externals.six.moves import zip

from matplotlib import lines, text as mtext, path as mpath, colors as mcolors
from matplotlib import artist
from matplotlib.collections import Collection, LineCollection, \
        PolyCollection, PatchCollection, PathCollection
from matplotlib.cm import ScalarMappable
from matplotlib.patches import Patch
from matplotlib.colors import Normalize
from matplotlib.cbook import iterable

import warnings
import numpy as np
import math
from . import proj3d

def norm_angle(a***REMOVED***:
    ***REMOVED***Return angle between -180 and +180***REMOVED***
    a = (a + 360***REMOVED*** % 360
    if a > 180:
        a = a - 360
    return a

def norm_text_angle(a***REMOVED***:
    ***REMOVED***Return angle between -90 and +90***REMOVED***
    a = (a + 180***REMOVED*** % 180
    if a > 90:
        a = a - 180
    return a

def get_dir_vector(zdir***REMOVED***:
    if zdir == 'x':
        return np.array((1, 0, 0***REMOVED******REMOVED***
    elif zdir == 'y':
        return np.array((0, 1, 0***REMOVED******REMOVED***
    elif zdir == 'z':
        return np.array((0, 0, 1***REMOVED******REMOVED***
    elif zdir is None:
        return np.array((0, 0, 0***REMOVED******REMOVED***
    elif iterable(zdir***REMOVED*** and len(zdir***REMOVED*** == 3:
        return zdir
    else:
        raise ValueError("'x', 'y', 'z', None or vector of length 3 expected"***REMOVED***

class Text3D(mtext.Text***REMOVED***:
    '''
    Text object with 3D position and (in the future***REMOVED*** direction.
    '''

    def __init__(self, x=0, y=0, z=0, text='', zdir='z', **kwargs***REMOVED***:
        '''
        *x*, *y*, *z*  Position of text
        *text*         Text string to display
        *zdir*         Direction of text

        Keyword arguments are passed onto :func:`~matplotlib.text.Text`.
        '''
        mtext.Text.__init__(self, x, y, text, **kwargs***REMOVED***
        self.set_3d_properties(z, zdir***REMOVED***

    def set_3d_properties(self, z=0, zdir='z'***REMOVED***:
        x, y = self.get_position(***REMOVED***
        self._position3d = np.array((x, y, z***REMOVED******REMOVED***
        self._dir_vec = get_dir_vector(zdir***REMOVED***
        self.stale = True

    def draw(self, renderer***REMOVED***:
        proj = proj3d.proj_trans_points([self._position3d, \
                self._position3d + self._dir_vec***REMOVED***, renderer.M***REMOVED***
        dx = proj[0***REMOVED***[1***REMOVED*** - proj[0***REMOVED***[0***REMOVED***
        dy = proj[1***REMOVED***[1***REMOVED*** - proj[1***REMOVED***[0***REMOVED***
        if dx==0. and dy==0.:
            # atan2 raises ValueError: math domain error on 0,0
            angle = 0.
        else:
            angle = math.degrees(math.atan2(dy, dx***REMOVED******REMOVED***
        self.set_position((proj[0***REMOVED***[0***REMOVED***, proj[1***REMOVED***[0***REMOVED******REMOVED******REMOVED***
        self.set_rotation(norm_text_angle(angle***REMOVED******REMOVED***
        mtext.Text.draw(self, renderer***REMOVED***
        self.stale = False


def text_2d_to_3d(obj, z=0, zdir='z'***REMOVED***:
    ***REMOVED***Convert a Text to a Text3D object.***REMOVED***
    obj.__class__ = Text3D
    obj.set_3d_properties(z, zdir***REMOVED***


class Line3D(lines.Line2D***REMOVED***:
    '''
    3D line object.
    '''

    def __init__(self, xs, ys, zs, *args, **kwargs***REMOVED***:
        '''
        Keyword arguments are passed onto :func:`~matplotlib.lines.Line2D`.
        '''
        lines.Line2D.__init__(self, [***REMOVED***, [***REMOVED***, *args, **kwargs***REMOVED***
        self._verts3d = xs, ys, zs

    def set_3d_properties(self, zs=0, zdir='z'***REMOVED***:
        xs = self.get_xdata(***REMOVED***
        ys = self.get_ydata(***REMOVED***

        ***REMOVED***
            # If *zs* is a list or array, then this will fail and
            # just proceed to juggle_axes(***REMOVED***.
            zs = float(zs***REMOVED***
            zs = [zs for x in xs***REMOVED***
        except TypeError:
            pass
        self._verts3d = juggle_axes(xs, ys, zs, zdir***REMOVED***
        self.stale = True

    def draw(self, renderer***REMOVED***:
        xs3d, ys3d, zs3d = self._verts3d
        xs, ys, zs = proj3d.proj_transform(xs3d, ys3d, zs3d, renderer.M***REMOVED***
        self.set_data(xs, ys***REMOVED***
        lines.Line2D.draw(self, renderer***REMOVED***
        self.stale = False


def line_2d_to_3d(line, zs=0, zdir='z'***REMOVED***:
    '''
    Convert a 2D line to 3D.
    '''
    line.__class__ = Line3D
    line.set_3d_properties(zs, zdir***REMOVED***

def path_to_3d_segment(path, zs=0, zdir='z'***REMOVED***:
    '''Convert a path to a 3D segment.'''

    if not iterable(zs***REMOVED***:
        zs = np.ones(len(path***REMOVED******REMOVED*** * zs

    seg = [***REMOVED***
    pathsegs = path.iter_segments(simplify=False, curves=False***REMOVED***
    for (((x, y***REMOVED***, code***REMOVED***, z***REMOVED*** in zip(pathsegs, zs***REMOVED***:
        seg.append((x, y, z***REMOVED******REMOVED***
    seg3d = [juggle_axes(x, y, z, zdir***REMOVED*** for (x, y, z***REMOVED*** in seg***REMOVED***
    return seg3d

def paths_to_3d_segments(paths, zs=0, zdir='z'***REMOVED***:
    '''
    Convert paths from a collection object to 3D segments.
    '''

    if not iterable(zs***REMOVED***:
        zs = np.ones(len(paths***REMOVED******REMOVED*** * zs

    segments = [***REMOVED***
    for path, pathz in zip(paths, zs***REMOVED***:
        segments.append(path_to_3d_segment(path, pathz, zdir***REMOVED******REMOVED***
    return segments

def path_to_3d_segment_with_codes(path, zs=0, zdir='z'***REMOVED***:
    '''Convert a path to a 3D segment with path codes.'''

    if not iterable(zs***REMOVED***:
        zs = np.ones(len(path***REMOVED******REMOVED*** * zs

    seg = [***REMOVED***
    codes = [***REMOVED***
    pathsegs = path.iter_segments(simplify=False, curves=False***REMOVED***
    for (((x, y***REMOVED***, code***REMOVED***, z***REMOVED*** in zip(pathsegs, zs***REMOVED***:
        seg.append((x, y, z***REMOVED******REMOVED***
        codes.append(code***REMOVED***
    seg3d = [juggle_axes(x, y, z, zdir***REMOVED*** for (x, y, z***REMOVED*** in seg***REMOVED***
    return seg3d, codes

def paths_to_3d_segments_with_codes(paths, zs=0, zdir='z'***REMOVED***:
    '''
    Convert paths from a collection object to 3D segments with path codes.
    '''

    if not iterable(zs***REMOVED***:
        zs = np.ones(len(paths***REMOVED******REMOVED*** * zs

    segments = [***REMOVED***
    codes_list = [***REMOVED***
    for path, pathz in zip(paths, zs***REMOVED***:
        segs, codes = path_to_3d_segment_with_codes(path, pathz, zdir***REMOVED***
        segments.append(segs***REMOVED***
        codes_list.append(codes***REMOVED***
    return segments, codes_list

class Line3DCollection(LineCollection***REMOVED***:
    '''
    A collection of 3D lines.
    '''

    def __init__(self, segments, *args, **kwargs***REMOVED***:
        '''
        Keyword arguments are passed onto :func:`~matplotlib.collections.LineCollection`.
        '''
        LineCollection.__init__(self, segments, *args, **kwargs***REMOVED***

    def set_sort_zpos(self, val***REMOVED***:
        '''Set the position to use for z-sorting.'''
        self._sort_zpos = val
        self.stale = True

    def set_segments(self, segments***REMOVED***:
        '''
        Set 3D segments
        '''
        self._segments3d = np.asanyarray(segments***REMOVED***
        LineCollection.set_segments(self, [***REMOVED******REMOVED***

    def do_3d_projection(self, renderer***REMOVED***:
        '''
        Project the points according to renderer matrix.
        '''
        xyslist = [
            proj3d.proj_trans_points(points, renderer.M***REMOVED*** for points in
            self._segments3d***REMOVED***
        segments_2d = [list(zip(xs, ys***REMOVED******REMOVED*** for (xs, ys, zs***REMOVED*** in xyslist***REMOVED***
        LineCollection.set_segments(self, segments_2d***REMOVED***

        # FIXME
        minz = 1e9
        for (xs, ys, zs***REMOVED*** in xyslist:
            minz = min(minz, min(zs***REMOVED******REMOVED***
        return minz

    def draw(self, renderer, project=False***REMOVED***:
        if project:
            self.do_3d_projection(renderer***REMOVED***
        LineCollection.draw(self, renderer***REMOVED***


def line_collection_2d_to_3d(col, zs=0, zdir='z'***REMOVED***:
    ***REMOVED***Convert a LineCollection to a Line3DCollection object.***REMOVED***
    segments3d = paths_to_3d_segments(col.get_paths(***REMOVED***, zs, zdir***REMOVED***
    col.__class__ = Line3DCollection
    col.set_segments(segments3d***REMOVED***


class Patch3D(Patch***REMOVED***:
    '''
    3D patch object.
    '''

    def __init__(self, *args, **kwargs***REMOVED***:
        zs = kwargs.pop('zs', [***REMOVED******REMOVED***
        zdir = kwargs.pop('zdir', 'z'***REMOVED***
        Patch.__init__(self, *args, **kwargs***REMOVED***
        self.set_3d_properties(zs, zdir***REMOVED***

    def set_3d_properties(self, verts, zs=0, zdir='z'***REMOVED***:
        if not iterable(zs***REMOVED***:
            zs = np.ones(len(verts***REMOVED******REMOVED*** * zs

        self._segment3d = [juggle_axes(x, y, z, zdir***REMOVED*** \
                for ((x, y***REMOVED***, z***REMOVED*** in zip(verts, zs***REMOVED******REMOVED***
        self._facecolor3d = Patch.get_facecolor(self***REMOVED***

    def get_path(self***REMOVED***:
        return self._path2d

    def get_facecolor(self***REMOVED***:
        return self._facecolor2d

    def do_3d_projection(self, renderer***REMOVED***:
        s = self._segment3d
        xs, ys, zs = list(zip(*s***REMOVED******REMOVED***
        vxs, vys,vzs, vis = proj3d.proj_transform_clip(xs, ys, zs, renderer.M***REMOVED***
        self._path2d = mpath.Path(list(zip(vxs, vys***REMOVED******REMOVED******REMOVED***
        # FIXME: coloring
        self._facecolor2d = self._facecolor3d
        return min(vzs***REMOVED***

    def draw(self, renderer***REMOVED***:
        Patch.draw(self, renderer***REMOVED***


class PathPatch3D(Patch3D***REMOVED***:
    '''
    3D PathPatch object.
    '''

    def __init__(self, path, **kwargs***REMOVED***:
        zs = kwargs.pop('zs', [***REMOVED******REMOVED***
        zdir = kwargs.pop('zdir', 'z'***REMOVED***
        Patch.__init__(self, **kwargs***REMOVED***
        self.set_3d_properties(path, zs, zdir***REMOVED***

    def set_3d_properties(self, path, zs=0, zdir='z'***REMOVED***:
        Patch3D.set_3d_properties(self, path.vertices, zs=zs, zdir=zdir***REMOVED***
        self._code3d = path.codes

    def do_3d_projection(self, renderer***REMOVED***:
        s = self._segment3d
        xs, ys, zs = list(zip(*s***REMOVED******REMOVED***
        vxs, vys,vzs, vis = proj3d.proj_transform_clip(xs, ys, zs, renderer.M***REMOVED***
        self._path2d = mpath.Path(list(zip(vxs, vys***REMOVED******REMOVED***, self._code3d***REMOVED***
        # FIXME: coloring
        self._facecolor2d = self._facecolor3d
        return min(vzs***REMOVED***

def get_patch_verts(patch***REMOVED***:
    ***REMOVED***Return a list of vertices for the path of a patch.***REMOVED***
    trans = patch.get_patch_transform(***REMOVED***
    path =  patch.get_path(***REMOVED***
    polygons = path.to_polygons(trans***REMOVED***
    if len(polygons***REMOVED***:
        return polygons[0***REMOVED***
    else:
        return [***REMOVED***

def patch_2d_to_3d(patch, z=0, zdir='z'***REMOVED***:
    ***REMOVED***Convert a Patch to a Patch3D object.***REMOVED***
    verts = get_patch_verts(patch***REMOVED***
    patch.__class__ = Patch3D
    patch.set_3d_properties(verts, z, zdir***REMOVED***

def pathpatch_2d_to_3d(pathpatch, z=0, zdir='z'***REMOVED***:
    ***REMOVED***Convert a PathPatch to a PathPatch3D object.***REMOVED***
    path = pathpatch.get_path(***REMOVED***
    trans = pathpatch.get_patch_transform(***REMOVED***

    mpath = trans.transform_path(path***REMOVED***
    pathpatch.__class__ = PathPatch3D
    pathpatch.set_3d_properties(mpath, z, zdir***REMOVED***

class Patch3DCollection(PatchCollection***REMOVED***:
    '''
    A collection of 3D patches.
    '''

    def __init__(self, *args, **kwargs***REMOVED***:
        ***REMOVED***
        Create a collection of flat 3D patches with its normal vector
        pointed in *zdir* direction, and located at *zs* on the *zdir*
        axis. 'zs' can be a scalar or an array-like of the same length as
        the number of patches in the collection.

        Constructor arguments are the same as for
        :class:`~matplotlib.collections.PatchCollection`. In addition,
        keywords *zs=0* and *zdir='z'* are available.

        Also, the keyword argument "depthshade" is available to
        indicate whether or not to shade the patches in order to
        give the appearance of depth (default is *True****REMOVED***.
        This is typically desired in scatter plots.
        ***REMOVED***
        zs = kwargs.pop('zs', 0***REMOVED***
        zdir = kwargs.pop('zdir', 'z'***REMOVED***
        self._depthshade = kwargs.pop('depthshade', True***REMOVED***
        PatchCollection.__init__(self, *args, **kwargs***REMOVED***
        self.set_3d_properties(zs, zdir***REMOVED***

    def set_sort_zpos(self, val***REMOVED***:
        '''Set the position to use for z-sorting.'''
        self._sort_zpos = val
        self.stale = True

    def set_3d_properties(self, zs, zdir***REMOVED***:
        # Force the collection to initialize the face and edgecolors
        # just in case it is a scalarmappable with a colormap.
        self.update_scalarmappable(***REMOVED***
        offsets = self.get_offsets(***REMOVED***
        if len(offsets***REMOVED*** > 0:
            xs, ys = list(zip(*offsets***REMOVED******REMOVED***
        else:
            xs = [***REMOVED***
            ys = [***REMOVED***
        self._offsets3d = juggle_axes(xs, ys, np.atleast_1d(zs***REMOVED***, zdir***REMOVED***
        self._facecolor3d = self.get_facecolor(***REMOVED***
        self._edgecolor3d = self.get_edgecolor(***REMOVED***
        self.stale = True

    def do_3d_projection(self, renderer***REMOVED***:
        xs, ys, zs = self._offsets3d
        vxs, vys, vzs, vis = proj3d.proj_transform_clip(xs, ys, zs, renderer.M***REMOVED***

        fcs = (zalpha(self._facecolor3d, vzs***REMOVED*** if self._depthshade else
               self._facecolor3d***REMOVED***
        fcs = mcolors.colorConverter.to_rgba_array(fcs, self._alpha***REMOVED***
        self.set_facecolors(fcs***REMOVED***

        ecs = (zalpha(self._edgecolor3d, vzs***REMOVED*** if self._depthshade else
               self._edgecolor3d***REMOVED***
        ecs = mcolors.colorConverter.to_rgba_array(ecs, self._alpha***REMOVED***
        self.set_edgecolors(ecs***REMOVED***
        PatchCollection.set_offsets(self, list(zip(vxs, vys***REMOVED******REMOVED******REMOVED***

        if vzs.size > 0:
            return min(vzs***REMOVED***
        else:
            return np.nan


class Path3DCollection(PathCollection***REMOVED***:
    '''
    A collection of 3D paths.
    '''

    def __init__(self, *args, **kwargs***REMOVED***:
        ***REMOVED***
        Create a collection of flat 3D paths with its normal vector
        pointed in *zdir* direction, and located at *zs* on the *zdir*
        axis. 'zs' can be a scalar or an array-like of the same length as
        the number of paths in the collection.

        Constructor arguments are the same as for
        :class:`~matplotlib.collections.PathCollection`. In addition,
        keywords *zs=0* and *zdir='z'* are available.

        Also, the keyword argument "depthshade" is available to
        indicate whether or not to shade the patches in order to
        give the appearance of depth (default is *True****REMOVED***.
        This is typically desired in scatter plots.
        ***REMOVED***
        zs = kwargs.pop('zs', 0***REMOVED***
        zdir = kwargs.pop('zdir', 'z'***REMOVED***
        self._depthshade = kwargs.pop('depthshade', True***REMOVED***
        PathCollection.__init__(self, *args, **kwargs***REMOVED***
        self.set_3d_properties(zs, zdir***REMOVED***

    def set_sort_zpos(self, val***REMOVED***:
        '''Set the position to use for z-sorting.'''
        self._sort_zpos = val
        self.stale = True

    def set_3d_properties(self, zs, zdir***REMOVED***:
        # Force the collection to initialize the face and edgecolors
        # just in case it is a scalarmappable with a colormap.
        self.update_scalarmappable(***REMOVED***
        offsets = self.get_offsets(***REMOVED***
        if len(offsets***REMOVED*** > 0:
            xs, ys = list(zip(*offsets***REMOVED******REMOVED***
        else:
            xs = [***REMOVED***
            ys = [***REMOVED***
        self._offsets3d = juggle_axes(xs, ys, np.atleast_1d(zs***REMOVED***, zdir***REMOVED***
        self._facecolor3d = self.get_facecolor(***REMOVED***
        self._edgecolor3d = self.get_edgecolor(***REMOVED***
        self.stale = True

    def do_3d_projection(self, renderer***REMOVED***:
        xs, ys, zs = self._offsets3d
        vxs, vys, vzs, vis = proj3d.proj_transform_clip(xs, ys, zs, renderer.M***REMOVED***

        fcs = (zalpha(self._facecolor3d, vzs***REMOVED*** if self._depthshade else
               self._facecolor3d***REMOVED***
        fcs = mcolors.colorConverter.to_rgba_array(fcs, self._alpha***REMOVED***
        self.set_facecolors(fcs***REMOVED***

        ecs = (zalpha(self._edgecolor3d, vzs***REMOVED*** if self._depthshade else
               self._edgecolor3d***REMOVED***
        ecs = mcolors.colorConverter.to_rgba_array(ecs, self._alpha***REMOVED***
        self.set_edgecolors(ecs***REMOVED***
        PathCollection.set_offsets(self, list(zip(vxs, vys***REMOVED******REMOVED******REMOVED***

        if vzs.size > 0 :
            return min(vzs***REMOVED***
        else :
            return np.nan


def patch_collection_2d_to_3d(col, zs=0, zdir='z', depthshade=True***REMOVED***:
    ***REMOVED***
    Convert a :class:`~matplotlib.collections.PatchCollection` into a
    :class:`Patch3DCollection` object
    (or a :class:`~matplotlib.collections.PathCollection` into a
    :class:`Path3DCollection` object***REMOVED***.

    Keywords:

    *za*            The location or locations to place the patches in the
                    collection along the *zdir* axis. Defaults to 0.

    *zdir*          The axis in which to place the patches. Default is "z".

    *depthshade*    Whether to shade the patches to give a sense of depth.
                    Defaults to *True*.

    ***REMOVED***
    if isinstance(col, PathCollection***REMOVED***:
        col.__class__ = Path3DCollection
    elif isinstance(col, PatchCollection***REMOVED***:
        col.__class__ = Patch3DCollection
    col._depthshade = depthshade
    col.set_3d_properties(zs, zdir***REMOVED***


class Poly3DCollection(PolyCollection***REMOVED***:
    '''
    A collection of 3D polygons.
    '''

    def __init__(self, verts, *args, **kwargs***REMOVED***:
        '''
        Create a Poly3DCollection.

        *verts* should contain 3D coordinates.

        Keyword arguments:
        zsort, see set_zsort for options.

        Note that this class does a bit of magic with the _facecolors
        and _edgecolors properties.
        '''
        zsort = kwargs.pop('zsort', True***REMOVED***
        PolyCollection.__init__(self, verts, *args, **kwargs***REMOVED***
        self.set_zsort(zsort***REMOVED***
        self._codes3d = None

    _zsort_functions = {
        'average': np.average,
        'min': np.min,
        'max': np.max,
***REMOVED***

    def set_zsort(self, zsort***REMOVED***:
        '''
        Set z-sorting behaviour:
            boolean: if True use default 'average'
            string: 'average', 'min' or 'max'
        '''

        if zsort is True:
            zsort = 'average'

        if zsort is not False:
            if zsort in self._zsort_functions:
                zsortfunc = self._zsort_functions[zsort***REMOVED***
            else:
                return False
        else:
            zsortfunc = None

        self._zsort = zsort
        self._sort_zpos = None
        self._zsortfunc = zsortfunc
        self.stale = True

    def get_vector(self, segments3d***REMOVED***:
        ***REMOVED***Optimize points for projection***REMOVED***
        si = 0
        ei = 0
        segis = [***REMOVED***
        points = [***REMOVED***
        for p in segments3d:
            points.extend(p***REMOVED***
            ei = si+len(p***REMOVED***
            segis.append((si, ei***REMOVED******REMOVED***
            si = ei

        if len(segments3d***REMOVED*** > 0 :
            xs, ys, zs = list(zip(*points***REMOVED******REMOVED***
        else :
            # We need this so that we can skip the bad unpacking from zip(***REMOVED***
            xs, ys, zs = [***REMOVED***, [***REMOVED***, [***REMOVED***

        ones = np.ones(len(xs***REMOVED******REMOVED***
        self._vec = np.array([xs, ys, zs, ones***REMOVED******REMOVED***
        self._segis = segis

    def set_verts(self, verts, closed=True***REMOVED***:
        '''Set 3D vertices.'''
        self.get_vector(verts***REMOVED***
        # 2D verts will be updated at draw time
        PolyCollection.set_verts(self, [***REMOVED***, closed***REMOVED***

    def set_verts_and_codes(self, verts, codes***REMOVED***:
        '''Sets 3D vertices with path codes'''
        # set vertices with closed=False to prevent PolyCollection from
        # setting path codes
        self.set_verts(verts, closed=False***REMOVED***
        # and set our own codes instead.
        self._codes3d = codes

    def set_3d_properties(self***REMOVED***:
        # Force the collection to initialize the face and edgecolors
        # just in case it is a scalarmappable with a colormap.
        self.update_scalarmappable(***REMOVED***
        self._sort_zpos = None
        self.set_zsort(True***REMOVED***
        self._facecolors3d = PolyCollection.get_facecolors(self***REMOVED***
        self._edgecolors3d = PolyCollection.get_edgecolors(self***REMOVED***
        self._alpha3d = PolyCollection.get_alpha(self***REMOVED***
        self.stale = True

    def set_sort_zpos(self,val***REMOVED***:
        '''Set the position to use for z-sorting.'''
        self._sort_zpos = val
        self.stale = True

    def do_3d_projection(self, renderer***REMOVED***:
        '''
        Perform the 3D projection for this object.
        '''
        # FIXME: This may no longer be needed?
        if self._A is not None:
            self.update_scalarmappable(***REMOVED***
            self._facecolors3d = self._facecolors

        txs, tys, tzs = proj3d.proj_transform_vec(self._vec, renderer.M***REMOVED***
        xyzlist = [(txs[si:ei***REMOVED***, tys[si:ei***REMOVED***, tzs[si:ei***REMOVED******REMOVED***
                   for si, ei in self._segis***REMOVED***

        # This extra fuss is to re-order face / edge colors
        cface = self._facecolors3d
        cedge = self._edgecolors3d
        if len(cface***REMOVED*** != len(xyzlist***REMOVED***:
            cface = cface.repeat(len(xyzlist***REMOVED***, axis=0***REMOVED***
        if len(cedge***REMOVED*** != len(xyzlist***REMOVED***:
            if len(cedge***REMOVED*** == 0:
                cedge = cface
            cedge = cedge.repeat(len(xyzlist***REMOVED***, axis=0***REMOVED***

        # if required sort by depth (furthest drawn first***REMOVED***
        if self._zsort:
            indices = range(len(xyzlist***REMOVED******REMOVED***
            z_segments_2d = [(self._zsortfunc(zs***REMOVED***, list(zip(xs, ys***REMOVED******REMOVED***, fc, ec,
                              idx***REMOVED*** for (xs, ys, zs***REMOVED***, fc, ec, idx in
                             zip(xyzlist, cface, cedge, indices***REMOVED******REMOVED***
            z_segments_2d.sort(key=lambda x: x[0***REMOVED***, reverse=True***REMOVED***
        else:
            raise ValueError("whoops"***REMOVED***

        segments_2d = [s for z, s, fc, ec, idx in z_segments_2d***REMOVED***
        if self._codes3d is not None:
            codes = [self._codes3d[idx***REMOVED*** for z, s, fc, ec, idx in z_segments_2d***REMOVED***
            PolyCollection.set_verts_and_codes(self, segments_2d, codes***REMOVED***
        else:
            PolyCollection.set_verts(self, segments_2d***REMOVED***

        self._facecolors2d = [fc for z, s, fc, ec, idx in z_segments_2d***REMOVED***
        if len(self._edgecolors3d***REMOVED*** == len(cface***REMOVED***:
            self._edgecolors2d = [ec for z, s, fc, ec, idx in z_segments_2d***REMOVED***
        else:
            self._edgecolors2d = self._edgecolors3d

        # Return zorder value
        if self._sort_zpos is not None:
            zvec = np.array([[0***REMOVED***, [0***REMOVED***, [self._sort_zpos***REMOVED***, [1***REMOVED******REMOVED******REMOVED***
            ztrans = proj3d.proj_transform_vec(zvec, renderer.M***REMOVED***
            return ztrans[2***REMOVED***[0***REMOVED***
        elif tzs.size > 0 :
            # FIXME: Some results still don't look quite right.
            #        In particular, examine contourf3d_demo2.py
            #        with az = -54 and elev = -45.
            return np.min(tzs***REMOVED***
        else :
            return np.nan

    def set_facecolor(self, colors***REMOVED***:
        PolyCollection.set_facecolor(self, colors***REMOVED***
        self._facecolors3d = PolyCollection.get_facecolor(self***REMOVED***
    set_facecolors = set_facecolor

    def set_edgecolor(self, colors***REMOVED***:
        PolyCollection.set_edgecolor(self, colors***REMOVED***
        self._edgecolors3d = PolyCollection.get_edgecolor(self***REMOVED***
    set_edgecolors = set_edgecolor

    def set_alpha(self, alpha***REMOVED***:
        ***REMOVED***
        Set the alpha tranparencies of the collection.  *alpha* must be
        a float or *None*.

        ACCEPTS: float or None
        ***REMOVED***
        if alpha is not None:
            ***REMOVED***
                float(alpha***REMOVED***
            except TypeError:
                raise TypeError('alpha must be a float or None'***REMOVED***
        artist.Artist.set_alpha(self, alpha***REMOVED***
        ***REMOVED***
            self._facecolors = mcolors.colorConverter.to_rgba_array(
                self._facecolors3d, self._alpha***REMOVED***
        except (AttributeError, TypeError, IndexError***REMOVED***:
            pass
        ***REMOVED***
            self._edgecolors = mcolors.colorConverter.to_rgba_array(
                    self._edgecolors3d, self._alpha***REMOVED***
        except (AttributeError, TypeError, IndexError***REMOVED***:
            pass
        self.stale = True

    def get_facecolors(self***REMOVED***:
        return self._facecolors2d
    get_facecolor = get_facecolors

    def get_edgecolors(self***REMOVED***:
        return self._edgecolors2d
    get_edgecolor = get_edgecolors

    def draw(self, renderer***REMOVED***:
        return Collection.draw(self, renderer***REMOVED***


def poly_collection_2d_to_3d(col, zs=0, zdir='z'***REMOVED***:
    ***REMOVED***Convert a PolyCollection to a Poly3DCollection object.***REMOVED***
    segments_3d, codes = paths_to_3d_segments_with_codes(col.get_paths(***REMOVED***,
                                                         zs, zdir***REMOVED***
    col.__class__ = Poly3DCollection
    col.set_verts_and_codes(segments_3d, codes***REMOVED***
    col.set_3d_properties(***REMOVED***

def juggle_axes(xs, ys, zs, zdir***REMOVED***:
    ***REMOVED***
    Reorder coordinates so that 2D xs, ys can be plotted in the plane
    orthogonal to zdir. zdir is normally x, y or z. However, if zdir
    starts with a '-' it is interpreted as a compensation for rotate_axes.
    ***REMOVED***
    if zdir == 'x':
        return zs, xs, ys
    elif zdir == 'y':
        return xs, zs, ys
    elif zdir[0***REMOVED*** == '-':
        return rotate_axes(xs, ys, zs, zdir***REMOVED***
    else:
        return xs, ys, zs

def rotate_axes(xs, ys, zs, zdir***REMOVED***:
    ***REMOVED***
    Reorder coordinates so that the axes are rotated with zdir along
    the original z axis. Prepending the axis with a '-' does the
    inverse transform, so zdir can be x, -x, y, -y, z or -z
    ***REMOVED***
    if zdir == 'x':
        return ys, zs, xs
    elif zdir == '-x':
        return zs, xs, ys

    elif zdir == 'y':
        return zs, xs, ys
    elif zdir == '-y':
        return ys, zs, xs

    else:
        return xs, ys, zs

def iscolor(c***REMOVED***:
    ***REMOVED***
        if len(c***REMOVED*** == 4 or len(c***REMOVED*** == 3:
            if iterable(c[0***REMOVED******REMOVED***:
                return False
            if hasattr(c[0***REMOVED***, '__float__'***REMOVED***:
                return True
    ***REMOVED***
        return False
    return False

def get_colors(c, num***REMOVED***:
    ***REMOVED***Stretch the color argument to provide the required number num***REMOVED***

    if type(c***REMOVED*** == type("string"***REMOVED***:
        c = mcolors.colorConverter.to_rgba(c***REMOVED***

    if iscolor(c***REMOVED***:
        return [c***REMOVED*** * num
    if len(c***REMOVED*** == num:
        return c
    elif iscolor(c***REMOVED***:
        return [c***REMOVED*** * num
    elif len(c***REMOVED*** == 0: #if edgecolor or facecolor is specified as 'none'
        return [[0,0,0,0***REMOVED******REMOVED*** * num
    elif iscolor(c[0***REMOVED******REMOVED***:
        return [c[0***REMOVED******REMOVED*** * num
    else:
        raise ValueError('unknown color format %s' % c***REMOVED***

def zalpha(colors, zs***REMOVED***:
    ***REMOVED***Modify the alphas of the color list according to depth***REMOVED***
    # FIXME: This only works well if the points for *zs* are well-spaced
    #        in all three dimensions. Otherwise, at certain orientations,
    #        the min and max zs are very close together.
    #        Should really normalize against the viewing depth.
    colors = get_colors(colors, len(zs***REMOVED******REMOVED***
    if zs.size > 0 :
        norm = Normalize(min(zs***REMOVED***, max(zs***REMOVED******REMOVED***
        sats = 1 - norm(zs***REMOVED*** * 0.7
        colors = [(c[0***REMOVED***, c[1***REMOVED***, c[2***REMOVED***, c[3***REMOVED*** * s***REMOVED*** for c, s in zip(colors, sats***REMOVED******REMOVED***
    return colors
