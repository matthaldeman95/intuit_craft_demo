#!/usr/bin/python
# axis3d.py, original mplot3d version by John Porter
# Created: 23 Sep 2005
# Parts rewritten by Reinier Heeres <reinier@heeres.eu>

from __future__ import (absolute_import, division, print_function,
                        unicode_literals***REMOVED***

from matplotlib.externals import six

import math
import copy

from matplotlib import lines as mlines, axis as maxis, \
        patches as mpatches
from . import art3d
from . import proj3d

import numpy as np

def get_flip_min_max(coord, index, mins, maxs***REMOVED***:
    if coord[index***REMOVED*** == mins[index***REMOVED***:
        return maxs[index***REMOVED***
    else:
        return mins[index***REMOVED***

def move_from_center(coord, centers, deltas, axmask=(True, True, True***REMOVED******REMOVED***:
    '''Return a coordinate that is moved by "deltas" away from the center.'''
    coord = copy.copy(coord***REMOVED***
    #print coord, centers, deltas, axmask
    for i in range(3***REMOVED***:
        if not axmask[i***REMOVED***:
            continue
        if coord[i***REMOVED*** < centers[i***REMOVED***:
            coord[i***REMOVED*** -= deltas[i***REMOVED***
        else:
            coord[i***REMOVED*** += deltas[i***REMOVED***
    return coord

def tick_update_position(tick, tickxs, tickys, labelpos***REMOVED***:
    '''Update tick line and label position and style.'''

    for (label, on***REMOVED*** in ((tick.label1, tick.label1On***REMOVED***, \
            (tick.label2, tick.label2On***REMOVED******REMOVED***:
        if on:
            label.set_position(labelpos***REMOVED***

    tick.tick1On, tick.tick2On = True, False
    tick.tick1line.set_linestyle('-'***REMOVED***
    tick.tick1line.set_marker(''***REMOVED***
    tick.tick1line.set_data(tickxs, tickys***REMOVED***
    tick.gridline.set_data(0, 0***REMOVED***

class Axis(maxis.XAxis***REMOVED***:

    # These points from the unit cube make up the x, y and z-planes
    _PLANES = (
        (0, 3, 7, 4***REMOVED***, (1, 2, 6, 5***REMOVED***,     # yz planes
        (0, 1, 5, 4***REMOVED***, (3, 2, 6, 7***REMOVED***,     # xz planes
        (0, 1, 2, 3***REMOVED***, (4, 5, 6, 7***REMOVED***,     # xy planes
    ***REMOVED***

    # Some properties for the axes
    _AXINFO = {
        'x': {'i': 0, 'tickdir': 1, 'juggled': (1, 0, 2***REMOVED***,
            'color': (0.95, 0.95, 0.95, 0.5***REMOVED******REMOVED***,
        'y': {'i': 1, 'tickdir': 0, 'juggled': (0, 1, 2***REMOVED***,
            'color': (0.90, 0.90, 0.90, 0.5***REMOVED******REMOVED***,
        'z': {'i': 2, 'tickdir': 0, 'juggled': (0, 2, 1***REMOVED***,
            'color': (0.925, 0.925, 0.925, 0.5***REMOVED******REMOVED***,
***REMOVED***

    def __init__(self, adir, v_intervalx, d_intervalx, axes, *args, **kwargs***REMOVED***:
        # adir identifies which axes this is
        self.adir = adir
        # data and viewing intervals for this direction
        self.d_interval = d_intervalx
        self.v_interval = v_intervalx

        # This is a temporary member variable.
        # Do not depend on this existing in future releases!
        self._axinfo = self._AXINFO[adir***REMOVED***.copy(***REMOVED***
        self._axinfo.update({'label' : {'va': 'center',
                                        'ha': 'center'***REMOVED***,
                             'tick' : {'inward_factor': 0.2,
                                       'outward_factor': 0.1***REMOVED***,
                             'axisline': {'linewidth': 0.75,
                                          'color': (0, 0, 0, 1***REMOVED******REMOVED***,
                             'grid' : {'color': (0.9, 0.9, 0.9, 1***REMOVED***,
                                       'linewidth': 1.0***REMOVED***,
                        ***REMOVED******REMOVED***


        maxis.XAxis.__init__(self, axes, *args, **kwargs***REMOVED***

        self.set_rotate_label(kwargs.get('rotate_label', None***REMOVED******REMOVED***


    def init3d(self***REMOVED***:
        self.line = mlines.Line2D(xdata=(0, 0***REMOVED***, ydata=(0, 0***REMOVED***,
                            linewidth=self._axinfo['axisline'***REMOVED***['linewidth'***REMOVED***,
                            color=self._axinfo['axisline'***REMOVED***['color'***REMOVED***,
                            antialiased=True,
                           ***REMOVED***

        # Store dummy data in Polygon object
        self.pane = mpatches.Polygon(np.array([[0,0***REMOVED***, [0,1***REMOVED***, [1,0***REMOVED***, [0,0***REMOVED******REMOVED******REMOVED***,
                                    closed=False,
                                    alpha=0.8,
                                    facecolor=(1,1,1,0***REMOVED***,
                                    edgecolor=(1,1,1,0***REMOVED******REMOVED***
        self.set_pane_color(self._axinfo['color'***REMOVED******REMOVED***

        self.axes._set_artist_props(self.line***REMOVED***
        self.axes._set_artist_props(self.pane***REMOVED***
        self.gridlines = art3d.Line3DCollection([***REMOVED***, ***REMOVED***
        self.axes._set_artist_props(self.gridlines***REMOVED***
        self.axes._set_artist_props(self.label***REMOVED***
        self.axes._set_artist_props(self.offsetText***REMOVED***
        # Need to be able to place the label at the correct location
        self.label._transform = self.axes.transData
        self.offsetText._transform = self.axes.transData

    def get_tick_positions(self***REMOVED***:
        majorLocs = self.major.locator(***REMOVED***
        self.major.formatter.set_locs(majorLocs***REMOVED***
        majorLabels = [self.major.formatter(val, i***REMOVED*** for i, val in enumerate(majorLocs***REMOVED******REMOVED***
        return majorLabels, majorLocs

    def get_major_ticks(self, numticks=None***REMOVED***:
        ticks = maxis.XAxis.get_major_ticks(self, numticks***REMOVED***
        for t in ticks:
            t.tick1line.set_transform(self.axes.transData***REMOVED***
            t.tick2line.set_transform(self.axes.transData***REMOVED***
            t.gridline.set_transform(self.axes.transData***REMOVED***
            t.label1.set_transform(self.axes.transData***REMOVED***
            t.label2.set_transform(self.axes.transData***REMOVED***
        return ticks

    def set_pane_pos(self, xys***REMOVED***:
        xys = np.asarray(xys***REMOVED***
        xys = xys[:,:2***REMOVED***
        self.pane.xy = xys
        self.stale = True

    def set_pane_color(self, color***REMOVED***:
        '''Set pane color to a RGBA tuple'''
        self._axinfo['color'***REMOVED*** = color
        self.pane.set_edgecolor(color***REMOVED***
        self.pane.set_facecolor(color***REMOVED***
        self.pane.set_alpha(color[-1***REMOVED******REMOVED***
        self.stale = True

    def set_rotate_label(self, val***REMOVED***:
        '''
        Whether to rotate the axis label: True, False or None.
        If set to None the label will be rotated if longer than 4 chars.
        '''
        self._rotate_label = val
        self.stale = True

    def get_rotate_label(self, text***REMOVED***:
        if self._rotate_label is not None:
            return self._rotate_label
        else:
            return len(text***REMOVED*** > 4

    def _get_coord_info(self, renderer***REMOVED***:
        minx, maxx, miny, maxy, minz, maxz = self.axes.get_w_lims(***REMOVED***
        if minx > maxx:
            minx, maxx = maxx, minx
        if miny > maxy:
            miny, maxy = maxy, miny
        if minz > maxz:
            minz, maxz = maxz, minz
        mins = np.array((minx, miny, minz***REMOVED******REMOVED***
        maxs = np.array((maxx, maxy, maxz***REMOVED******REMOVED***
        centers = (maxs + mins***REMOVED*** / 2.
        deltas = (maxs - mins***REMOVED*** / 12.
        mins = mins - deltas / 4.
        maxs = maxs + deltas / 4.

        vals = mins[0***REMOVED***, maxs[0***REMOVED***, mins[1***REMOVED***, maxs[1***REMOVED***, mins[2***REMOVED***, maxs[2***REMOVED***
        tc = self.axes.tunit_cube(vals, renderer.M***REMOVED***
        avgz = [tc[p1***REMOVED***[2***REMOVED*** + tc[p2***REMOVED***[2***REMOVED*** + tc[p3***REMOVED***[2***REMOVED*** + tc[p4***REMOVED***[2***REMOVED*** for \
                p1, p2, p3, p4 in self._PLANES***REMOVED***
        highs = np.array([avgz[2*i***REMOVED*** < avgz[2*i+1***REMOVED*** for i in range(3***REMOVED******REMOVED******REMOVED***

        return mins, maxs, centers, deltas, tc, highs

    def draw_pane(self, renderer***REMOVED***:
        renderer.open_group('pane3d'***REMOVED***

        mins, maxs, centers, deltas, tc, highs = self._get_coord_info(renderer***REMOVED***

        info = self._axinfo
        index = info['i'***REMOVED***
        if not highs[index***REMOVED***:
            plane = self._PLANES[2 * index***REMOVED***
        else:
            plane = self._PLANES[2 * index + 1***REMOVED***
        xys = [tc[p***REMOVED*** for p in plane***REMOVED***
        self.set_pane_pos(xys***REMOVED***
        self.pane.draw(renderer***REMOVED***

        renderer.close_group('pane3d'***REMOVED***

    def draw(self, renderer***REMOVED***:
        self.label._transform = self.axes.transData
        renderer.open_group('axis3d'***REMOVED***

        # code from XAxis
        majorTicks = self.get_major_ticks(***REMOVED***
        majorLocs = self.major.locator(***REMOVED***

        info = self._axinfo
        index = info['i'***REMOVED***

        # filter locations here so that no extra grid lines are drawn
        locmin, locmax = self.get_view_interval(***REMOVED***
        if locmin > locmax:
            locmin, locmax = locmax, locmin

        # Rudimentary clipping
        majorLocs = [loc for loc in majorLocs if
                     locmin <= loc <= locmax***REMOVED***
        self.major.formatter.set_locs(majorLocs***REMOVED***
        majorLabels = [self.major.formatter(val, i***REMOVED***
                       for i, val in enumerate(majorLocs***REMOVED******REMOVED***

        mins, maxs, centers, deltas, tc, highs = self._get_coord_info(renderer***REMOVED***

        # Determine grid lines
        minmax = np.where(highs, maxs, mins***REMOVED***

        # Draw main axis line
        juggled = info['juggled'***REMOVED***
        edgep1 = minmax.copy(***REMOVED***
        edgep1[juggled[0***REMOVED******REMOVED*** = get_flip_min_max(edgep1, juggled[0***REMOVED***, mins, maxs***REMOVED***

        edgep2 = edgep1.copy(***REMOVED***
        edgep2[juggled[1***REMOVED******REMOVED*** = get_flip_min_max(edgep2, juggled[1***REMOVED***, mins, maxs***REMOVED***
        pep = proj3d.proj_trans_points([edgep1, edgep2***REMOVED***, renderer.M***REMOVED***
        centpt = proj3d.proj_transform(centers[0***REMOVED***, centers[1***REMOVED***, centers[2***REMOVED***, renderer.M***REMOVED***
        self.line.set_data((pep[0***REMOVED***[0***REMOVED***, pep[0***REMOVED***[1***REMOVED******REMOVED***, (pep[1***REMOVED***[0***REMOVED***, pep[1***REMOVED***[1***REMOVED******REMOVED******REMOVED***
        self.line.draw(renderer***REMOVED***

        # Grid points where the planes meet
        xyz0 = [***REMOVED***
        for val in majorLocs:
            coord = minmax.copy(***REMOVED***
            coord[index***REMOVED*** = val
            xyz0.append(coord***REMOVED***

        # Draw labels
        peparray = np.asanyarray(pep***REMOVED***
        # The transAxes transform is used because the Text object
        # rotates the text relative to the display coordinate system.
        # Therefore, if we want the labels to remain parallel to the
        # axis regardless of the aspect ratio, we need to convert the
        # edge points of the plane to display coordinates and calculate
        # an angle from that.
        # TODO: Maybe Text objects should handle this themselves?
        dx, dy = (self.axes.transAxes.transform([peparray[0:2, 1***REMOVED******REMOVED******REMOVED*** -
                  self.axes.transAxes.transform([peparray[0:2, 0***REMOVED******REMOVED******REMOVED******REMOVED***[0***REMOVED***

        lxyz = 0.5*(edgep1 + edgep2***REMOVED***

        # A rough estimate; points are ambiguous since 3D plots rotate
        ax_scale = self.axes.bbox.size / self.figure.bbox.size
        ax_inches = np.multiply(ax_scale, self.figure.get_size_inches(***REMOVED******REMOVED***
        ax_points_estimate = sum(72. * ax_inches***REMOVED***
        deltas_per_point = 48. / ax_points_estimate
        default_offset = 21.
        labeldeltas = (self.labelpad + default_offset***REMOVED*** * deltas_per_point\
            * deltas
        axmask = [True, True, True***REMOVED***
        axmask[index***REMOVED*** = False
        lxyz = move_from_center(lxyz, centers, labeldeltas, axmask***REMOVED***
        tlx, tly, tlz = proj3d.proj_transform(lxyz[0***REMOVED***, lxyz[1***REMOVED***, lxyz[2***REMOVED***, \
                renderer.M***REMOVED***
        self.label.set_position((tlx, tly***REMOVED******REMOVED***
        if self.get_rotate_label(self.label.get_text(***REMOVED******REMOVED***:
            angle = art3d.norm_text_angle(math.degrees(math.atan2(dy, dx***REMOVED******REMOVED******REMOVED***
            self.label.set_rotation(angle***REMOVED***
        self.label.set_va(info['label'***REMOVED***['va'***REMOVED******REMOVED***
        self.label.set_ha(info['label'***REMOVED***['ha'***REMOVED******REMOVED***
        self.label.draw(renderer***REMOVED***


        # Draw Offset text

        # Which of the two edge points do we want to
        # use for locating the offset text?
        if juggled[2***REMOVED*** == 2 :
            outeredgep = edgep1
            outerindex = 0
        else :
            outeredgep = edgep2
            outerindex = 1

        pos = copy.copy(outeredgep***REMOVED***
        pos = move_from_center(pos, centers, labeldeltas, axmask***REMOVED***
        olx, oly, olz = proj3d.proj_transform(pos[0***REMOVED***, pos[1***REMOVED***, pos[2***REMOVED***, renderer.M***REMOVED***
        self.offsetText.set_text( self.major.formatter.get_offset(***REMOVED*** ***REMOVED***
        self.offsetText.set_position( (olx, oly***REMOVED*** ***REMOVED***
        angle = art3d.norm_text_angle(math.degrees(math.atan2(dy, dx***REMOVED******REMOVED******REMOVED***
        self.offsetText.set_rotation(angle***REMOVED***
        # Must set rotation mode to "anchor" so that
        # the alignment point is used as the "fulcrum" for rotation.
        self.offsetText.set_rotation_mode('anchor'***REMOVED***

        #-----------------------------------------------------------------------
        # Note: the following statement for determining the proper alignment of
        #       the offset text. This was determined entirely by trial-and-error
        #       and should not be in any way considered as "the way".  There are
        #       still some edge cases where alignment is not quite right, but
        #       this seems to be more of a geometry issue (in other words, I
        #       might be using the wrong reference points***REMOVED***.
        #
        #   (TT, FF, TF, FT***REMOVED*** are the shorthand for the tuple of
        #     (centpt[info['tickdir'***REMOVED******REMOVED*** <= peparray[info['tickdir'***REMOVED***, outerindex***REMOVED***,
        #      centpt[index***REMOVED*** <= peparray[index, outerindex***REMOVED******REMOVED***
        #
        #   Three-letters (e.g., TFT, FTT***REMOVED*** are short-hand for the array
        #    of bools from the variable 'highs'.
        # ---------------------------------------------------------------------
        if centpt[info['tickdir'***REMOVED******REMOVED*** > peparray[info['tickdir'***REMOVED***, outerindex***REMOVED*** :
            # if FT and if highs has an even number of Trues
            if (centpt[index***REMOVED*** <= peparray[index, outerindex***REMOVED***
                and ((len(highs.nonzero(***REMOVED***[0***REMOVED******REMOVED*** % 2***REMOVED*** == 0***REMOVED******REMOVED*** :
                # Usually, this means align right, except for the FTT case,
                # in which offset for axis 1 and 2 are aligned left.
                if highs.tolist(***REMOVED*** == [False, True, True***REMOVED*** and index in (1, 2***REMOVED*** :
                    align = 'left'
                else :
                    align = 'right'
            else :
                # The FF case
                align = 'left'
        else :
            # if TF and if highs has an even number of Trues
            if (centpt[index***REMOVED*** > peparray[index, outerindex***REMOVED***
                and ((len(highs.nonzero(***REMOVED***[0***REMOVED******REMOVED*** % 2***REMOVED*** == 0***REMOVED******REMOVED*** :
                # Usually mean align left, except if it is axis 2
                if index == 2 :
                    align = 'right'
                else :
                    align = 'left'
            else :
                # The TT case
                align = 'right'

        self.offsetText.set_va('center'***REMOVED***
        self.offsetText.set_ha(align***REMOVED***
        self.offsetText.draw(renderer***REMOVED***

        # Draw grid lines
        if len(xyz0***REMOVED*** > 0:
            # Grid points at end of one plane
            xyz1 = copy.deepcopy(xyz0***REMOVED***
            newindex = (index + 1***REMOVED*** % 3
            newval = get_flip_min_max(xyz1[0***REMOVED***, newindex, mins, maxs***REMOVED***
            for i in range(len(majorLocs***REMOVED******REMOVED***:
                xyz1[i***REMOVED***[newindex***REMOVED*** = newval

            # Grid points at end of the other plane
            xyz2 = copy.deepcopy(xyz0***REMOVED***
            newindex = (index + 2***REMOVED*** %  3
            newval = get_flip_min_max(xyz2[0***REMOVED***, newindex, mins, maxs***REMOVED***
            for i in range(len(majorLocs***REMOVED******REMOVED***:
                xyz2[i***REMOVED***[newindex***REMOVED*** = newval

            lines = list(zip(xyz1, xyz0, xyz2***REMOVED******REMOVED***
            if self.axes._draw_grid:
                self.gridlines.set_segments(lines***REMOVED***
                self.gridlines.set_color([info['grid'***REMOVED***['color'***REMOVED******REMOVED*** * len(lines***REMOVED******REMOVED***
                self.gridlines.draw(renderer, project=True***REMOVED***

        # Draw ticks
        tickdir = info['tickdir'***REMOVED***
        tickdelta = deltas[tickdir***REMOVED***
        if highs[tickdir***REMOVED***:
            ticksign = 1
        else:
            ticksign = -1

        for tick, loc, label in zip(majorTicks, majorLocs, majorLabels***REMOVED***:
            if tick is None:
                continue

            # Get tick line positions
            pos = copy.copy(edgep1***REMOVED***
            pos[index***REMOVED*** = loc
            pos[tickdir***REMOVED*** = edgep1[tickdir***REMOVED*** + info['tick'***REMOVED***['outward_factor'***REMOVED*** * \
                                             ticksign * tickdelta
            x1, y1, z1 = proj3d.proj_transform(pos[0***REMOVED***, pos[1***REMOVED***, pos[2***REMOVED***, \
                    renderer.M***REMOVED***
            pos[tickdir***REMOVED*** = edgep1[tickdir***REMOVED*** - info['tick'***REMOVED***['inward_factor'***REMOVED*** * \
                                             ticksign * tickdelta
            x2, y2, z2 = proj3d.proj_transform(pos[0***REMOVED***, pos[1***REMOVED***, pos[2***REMOVED***, \
                    renderer.M***REMOVED***

            # Get position of label
            default_offset = 8.  # A rough estimate
            labeldeltas = (tick.get_pad(***REMOVED*** + default_offset***REMOVED*** * deltas_per_point\
                * deltas

            axmask = [True, True, True***REMOVED***
            axmask[index***REMOVED*** = False
            pos[tickdir***REMOVED*** = edgep1[tickdir***REMOVED***
            pos = move_from_center(pos, centers, labeldeltas, axmask***REMOVED***
            lx, ly, lz = proj3d.proj_transform(pos[0***REMOVED***, pos[1***REMOVED***, pos[2***REMOVED***, \
                    renderer.M***REMOVED***

            tick_update_position(tick, (x1, x2***REMOVED***, (y1, y2***REMOVED***, (lx, ly***REMOVED******REMOVED***
            tick.set_label1(label***REMOVED***
            tick.set_label2(label***REMOVED***
            tick.draw(renderer***REMOVED***

        renderer.close_group('axis3d'***REMOVED***
        self.stale = False

    def get_view_interval(self***REMOVED***:
        ***REMOVED***return the Interval instance for this 3d axis view limits***REMOVED***
        return self.v_interval

    def set_view_interval(self, vmin, vmax, ignore=False***REMOVED***:
        if ignore:
            self.v_interval = vmin, vmax
        else:
            Vmin, Vmax = self.get_view_interval(***REMOVED***
            self.v_interval = min(vmin, Vmin***REMOVED***, max(vmax, Vmax***REMOVED***

    # TODO: Get this to work properly when mplot3d supports
    #       the transforms framework.
    def get_tightbbox(self, renderer***REMOVED*** :
        # Currently returns None so that Axis.get_tightbbox
        # doesn't return junk info.
        return None

# Use classes to look at different data limits

class XAxis(Axis***REMOVED***:
    def get_data_interval(self***REMOVED***:
        'return the Interval instance for this axis data limits'
        return self.axes.xy_dataLim.intervalx

class YAxis(Axis***REMOVED***:
    def get_data_interval(self***REMOVED***:
        'return the Interval instance for this axis data limits'
        return self.axes.xy_dataLim.intervaly

class ZAxis(Axis***REMOVED***:
    def get_data_interval(self***REMOVED***:
        'return the Interval instance for this axis data limits'
        return self.axes.zz_dataLim.intervalx
