***REMOVED***
Cycler
======

Cycling through combinations of values, producing dictionaries.

You can add cyclers::

    from cycler import cycler
    cc = (cycler(color=list('rgb'***REMOVED******REMOVED*** +
          cycler(linestyle=['-', '--', '-.'***REMOVED******REMOVED******REMOVED***
    for d in cc:
        print(d***REMOVED***

Results in::

***REMOVED***'color': 'r', 'linestyle': '-'***REMOVED***
***REMOVED***'color': 'g', 'linestyle': '--'***REMOVED***
***REMOVED***'color': 'b', 'linestyle': '-.'***REMOVED***


You can multiply cyclers::

    from cycler import cycler
    cc = (cycler(color=list('rgb'***REMOVED******REMOVED*** *
          cycler(linestyle=['-', '--', '-.'***REMOVED******REMOVED******REMOVED***
    for d in cc:
        print(d***REMOVED***

Results in::

***REMOVED***'color': 'r', 'linestyle': '-'***REMOVED***
***REMOVED***'color': 'r', 'linestyle': '--'***REMOVED***
***REMOVED***'color': 'r', 'linestyle': '-.'***REMOVED***
***REMOVED***'color': 'g', 'linestyle': '-'***REMOVED***
***REMOVED***'color': 'g', 'linestyle': '--'***REMOVED***
***REMOVED***'color': 'g', 'linestyle': '-.'***REMOVED***
***REMOVED***'color': 'b', 'linestyle': '-'***REMOVED***
***REMOVED***'color': 'b', 'linestyle': '--'***REMOVED***
***REMOVED***'color': 'b', 'linestyle': '-.'***REMOVED***
***REMOVED***

from __future__ import (absolute_import, division, print_function,
                        unicode_literals***REMOVED***

import six
from itertools import product, cycle
from six.moves import zip, reduce
from operator import mul, add
import copy

__version__ = '0.10.0'


def _process_keys(left, right***REMOVED***:
    ***REMOVED***
    Helper function to compose cycler keys

    Parameters
    ----------
    left, right : iterable of dictionaries or None
        The cyclers to be composed
    Returns
    -------
    keys : set
        The keys in the composition of the two cyclers
    ***REMOVED***
    l_peek = next(iter(left***REMOVED******REMOVED*** if left is not None else {***REMOVED***
    r_peek = next(iter(right***REMOVED******REMOVED*** if right is not None else {***REMOVED***
    l_key = set(l_peek.keys(***REMOVED******REMOVED***
    r_key = set(r_peek.keys(***REMOVED******REMOVED***
    if l_key & r_key:
        raise ValueError("Can not compose overlapping cycles"***REMOVED***
    return l_key | r_key


class Cycler(object***REMOVED***:
    ***REMOVED***
    Composable cycles

    This class has compositions methods:

    ``+``
      for 'inner' products (zip***REMOVED***

    ``+=``
      in-place ``+``

    ``*``
      for outer products (itertools.product***REMOVED*** and integer multiplication

    ``*=``
      in-place ``*``

    and supports basic slicing via ``[***REMOVED***``

    Parameters
    ----------
    left : Cycler or None
        The 'left' cycler

    right : Cycler or None
        The 'right' cycler

    op : func or None
        Function which composes the 'left' and 'right' cyclers.

    ***REMOVED***
    def __call__(self***REMOVED***:
        return cycle(self***REMOVED***

    def __init__(self, left, right=None, op=None***REMOVED***:
        ***REMOVED***Semi-private init

        Do not use this directly, use `cycler` function instead.
        ***REMOVED***
        if isinstance(left, Cycler***REMOVED***:
            self._left = Cycler(left._left, left._right, left._op***REMOVED***
        elif left is not None:
            # Need to copy the dictionary or else that will be a residual
            # mutable that could lead to strange errors
            self._left = [copy.copy(v***REMOVED*** for v in left***REMOVED***
        else:
            self._left = None

        if isinstance(right, Cycler***REMOVED***:
            self._right = Cycler(right._left, right._right, right._op***REMOVED***
        elif right is not None:
            # Need to copy the dictionary or else that will be a residual
            # mutable that could lead to strange errors
            self._right = [copy.copy(v***REMOVED*** for v in right***REMOVED***
        else:
            self._right = None

        self._keys = _process_keys(self._left, self._right***REMOVED***
        self._op = op

    @property
    def keys(self***REMOVED***:
        ***REMOVED***
        The keys this Cycler knows about
        ***REMOVED***
        return set(self._keys***REMOVED***

    def change_key(self, old, new***REMOVED***:
        ***REMOVED***
        Change a key in this cycler to a new name.
        Modification is performed in-place.

        Does nothing if the old key is the same as the new key.
        Raises a ValueError if the new key is already a key.
        Raises a KeyError if the old key isn't a key.

        ***REMOVED***
        if old == new:
            return
        if new in self._keys:
            raise ValueError("Can't replace %s with %s, %s is already a key" %
                             (old, new, new***REMOVED******REMOVED***
        if old not in self._keys:
            raise KeyError("Can't replace %s with %s, %s is not a key" %
                           (old, new, old***REMOVED******REMOVED***

        self._keys.remove(old***REMOVED***
        self._keys.add(new***REMOVED***

        if self._right is not None and old in self._right.keys:
            self._right.change_key(old, new***REMOVED***

        # self._left should always be non-None
        # if self._keys is non-empty.
        elif isinstance(self._left, Cycler***REMOVED***:
            self._left.change_key(old, new***REMOVED***
        else:
            # It should be completely safe at this point to
            # assume that the old key can be found in each
            # iteration.
            self._left = [{new: entry[old***REMOVED******REMOVED*** for entry in self._left***REMOVED***

    def _compose(self***REMOVED***:
        ***REMOVED***
        Compose the 'left' and 'right' components of this cycle
        with the proper operation (zip or product as of now***REMOVED***
        ***REMOVED***
        for a, b in self._op(self._left, self._right***REMOVED***:
            out = dict(***REMOVED***
            out.update(a***REMOVED***
            out.update(b***REMOVED***
            yield out

    @classmethod
    def _from_iter(cls, label, itr***REMOVED***:
        ***REMOVED***
        Class method to create 'base' Cycler objects
        that do not have a 'right' or 'op' and for which
        the 'left' object is not another Cycler.

        Parameters
        ----------
        label : str
            The property key.

        itr : iterable
            Finite length iterable of the property values.

        Returns
        -------
        cycler : Cycler
            New 'base' `Cycler`
        ***REMOVED***
        ret = cls(None***REMOVED***
        ret._left = list({label: v***REMOVED*** for v in itr***REMOVED***
        ret._keys = set([label***REMOVED******REMOVED***
        return ret

    def __getitem__(self, key***REMOVED***:
        # TODO : maybe add numpy style fancy slicing
        if isinstance(key, slice***REMOVED***:
            trans = self.by_key(***REMOVED***
            return reduce(add, (_cycler(k, v[key***REMOVED******REMOVED***
                                for k, v in six.iteritems(trans***REMOVED******REMOVED******REMOVED***
        else:
            raise ValueError("Can only use slices with Cycler.__getitem__"***REMOVED***

    def __iter__(self***REMOVED***:
        if self._right is None:
            return iter(dict(l***REMOVED*** for l in self._left***REMOVED***

        return self._compose(***REMOVED***

    def __add__(self, other***REMOVED***:
        ***REMOVED***
        Pair-wise combine two equal length cycles (zip***REMOVED***

        Parameters
        ----------
        other : Cycler
           The second Cycler
        ***REMOVED***
        if len(self***REMOVED*** != len(other***REMOVED***:
            raise ValueError("Can only add equal length cycles, "
                             "not {0***REMOVED*** and {1***REMOVED***".format(len(self***REMOVED***, len(other***REMOVED******REMOVED******REMOVED***
        return Cycler(self, other, zip***REMOVED***

    def __mul__(self, other***REMOVED***:
        ***REMOVED***
        Outer product of two cycles (`itertools.product`***REMOVED*** or integer
        multiplication.

        Parameters
        ----------
        other : Cycler or int
           The second Cycler or integer
        ***REMOVED***
        if isinstance(other, Cycler***REMOVED***:
            return Cycler(self, other, product***REMOVED***
        elif isinstance(other, int***REMOVED***:
            trans = self.by_key(***REMOVED***
            return reduce(add, (_cycler(k, v*other***REMOVED***
                                for k, v in six.iteritems(trans***REMOVED******REMOVED******REMOVED***
        else:
            return NotImplemented

    def __rmul__(self, other***REMOVED***:
        return self * other

    def __len__(self***REMOVED***:
        op_dict = {zip: min, product: mul***REMOVED***
        if self._right is None:
            return len(self._left***REMOVED***
        l_len = len(self._left***REMOVED***
        r_len = len(self._right***REMOVED***
        return op_dict[self._op***REMOVED***(l_len, r_len***REMOVED***

    def __iadd__(self, other***REMOVED***:
        ***REMOVED***
        In-place pair-wise combine two equal length cycles (zip***REMOVED***

        Parameters
        ----------
        other : Cycler
           The second Cycler
        ***REMOVED***
        if not isinstance(other, Cycler***REMOVED***:
            raise TypeError("Cannot += with a non-Cycler object"***REMOVED***
        # True shallow copy of self is fine since this is in-place
        old_self = copy.copy(self***REMOVED***
        self._keys = _process_keys(old_self, other***REMOVED***
        self._left = old_self
        self._op = zip
        self._right = Cycler(other._left, other._right, other._op***REMOVED***
        return self

    def __imul__(self, other***REMOVED***:
        ***REMOVED***
        In-place outer product of two cycles (`itertools.product`***REMOVED***

        Parameters
        ----------
        other : Cycler
           The second Cycler
        ***REMOVED***
        if not isinstance(other, Cycler***REMOVED***:
            raise TypeError("Cannot *= with a non-Cycler object"***REMOVED***
        # True shallow copy of self is fine since this is in-place
        old_self = copy.copy(self***REMOVED***
        self._keys = _process_keys(old_self, other***REMOVED***
        self._left = old_self
        self._op = product
        self._right = Cycler(other._left, other._right, other._op***REMOVED***
        return self

    def __eq__(self, other***REMOVED***:
        ***REMOVED***
        Check equality
        ***REMOVED***
        if len(self***REMOVED*** != len(other***REMOVED***:
            return False
        if self.keys ^ other.keys:
            return False

        return all(a == b for a, b in zip(self, other***REMOVED******REMOVED***

    def __repr__(self***REMOVED***:
        op_map = {zip: '+', product: '*'***REMOVED***
        if self._right is None:
            lab = self.keys.pop(***REMOVED***
            itr = list(v[lab***REMOVED*** for v in self***REMOVED***
            return "cycler({lab!r***REMOVED***, {itr!r***REMOVED******REMOVED***".format(lab=lab, itr=itr***REMOVED***
        else:
            op = op_map.get(self._op, '?'***REMOVED***
            msg = "({left!r***REMOVED*** {op***REMOVED*** {right!r***REMOVED******REMOVED***"
            return msg.format(left=self._left, op=op, right=self._right***REMOVED***

    def _repr_html_(self***REMOVED***:
        # an table showing the value of each key through a full cycle
        output = "<table>"
        sorted_keys = sorted(self.keys, key=repr***REMOVED***
        for key in sorted_keys:
            output += "<th>{key!r***REMOVED***</th>".format(key=key***REMOVED***
        for d in iter(self***REMOVED***:
            output += "<tr>"
            for k in sorted_keys:
                output += "<td>{val!r***REMOVED***</td>".format(val=d[k***REMOVED******REMOVED***
            output += "</tr>"
        output += "</table>"
        return output

    def by_key(self***REMOVED***:
        ***REMOVED***Values by key

        This returns the transposed values of the cycler.  Iterating
        over a `Cycler` yields dicts with a single value for each key,
        this method returns a `dict` of `list` which are the values
        for the given key.

        The returned value can be used to create an equivalent `Cycler`
        using only `+`.

        Returns
        -------
        transpose : dict
            dict of lists of the values for each key.
        ***REMOVED***

        # TODO : sort out if this is a bottle neck, if there is a better way
        # and if we care.

        keys = self.keys
        # change this to dict comprehension when drop 2.6
        out = dict((k,  list(***REMOVED******REMOVED*** for k in keys***REMOVED***

        for d in self:
            for k in keys:
                out[k***REMOVED***.append(d[k***REMOVED******REMOVED***
        return out

    # for back compatibility
    _transpose = by_key

    def simplify(self***REMOVED***:
        ***REMOVED***Simplify the Cycler

        Returned as a composition using only sums (no multiplications***REMOVED***

        Returns
        -------
        simple : Cycler
            An equivalent cycler using only summation***REMOVED***
        # TODO: sort out if it is worth the effort to make sure this is
        # balanced.  Currently it is is
        # (((a + b***REMOVED*** + c***REMOVED*** + d***REMOVED*** vs
        # ((a + b***REMOVED*** + (c + d***REMOVED******REMOVED***
        # I would believe that there is some performance implications

        trans = self.by_key(***REMOVED***
        return reduce(add, (_cycler(k, v***REMOVED*** for k, v in six.iteritems(trans***REMOVED******REMOVED******REMOVED***

    def concat(self, other***REMOVED***:
        ***REMOVED***Concatenate this cycler and an other.

        The keys must match exactly.

        This returns a single Cycler which is equivalent to
        `itertools.chain(self, other***REMOVED***`

        Examples
        --------

        >>> num = cycler('a', range(3***REMOVED******REMOVED***
        >>> let = cycler('a', 'abc'***REMOVED***
        >>> num.concat(let***REMOVED***
        cycler('a', [0, 1, 2, 'a', 'b', 'c'***REMOVED******REMOVED***

        Parameters
        ----------
        other : `Cycler`
            The `Cycler` to concatenate to this one.

        Returns
        -------
        ret : `Cycler`
            The concatenated `Cycler`
        ***REMOVED***
        return concat(self, other***REMOVED***


def concat(left, right***REMOVED***:
    ***REMOVED***Concatenate two cyclers.

    The keys must match exactly.

    This returns a single Cycler which is equivalent to
    `itertools.chain(left, right***REMOVED***`

    Examples
    --------

    >>> num = cycler('a', range(3***REMOVED******REMOVED***
    >>> let = cycler('a', 'abc'***REMOVED***
    >>> num.concat(let***REMOVED***
    cycler('a', [0, 1, 2, 'a', 'b', 'c'***REMOVED******REMOVED***

    Parameters
    ----------
    left, right : `Cycler`
        The two `Cycler` instances to concatenate

    Returns
    -------
    ret : `Cycler`
        The concatenated `Cycler`
    ***REMOVED***
    if left.keys != right.keys:
        msg = '\n\t'.join(["Keys do not match:",
                           "Intersection: {both!r***REMOVED***",
                           "Disjoint: {just_one!r***REMOVED***"***REMOVED******REMOVED***.format(
                               both=left.keys & right.keys,
                               just_one=left.keys ^ right.keys***REMOVED***

        raise ValueError(msg***REMOVED***

    _l = left.by_key(***REMOVED***
    _r = right.by_key(***REMOVED***
    return reduce(add, (_cycler(k, _l[k***REMOVED*** + _r[k***REMOVED******REMOVED*** for k in left.keys***REMOVED******REMOVED***


def cycler(*args, **kwargs***REMOVED***:
    ***REMOVED***
    Create a new `Cycler` object from a single positional argument,
    a pair of positional arguments, or the combination of keyword arguments.

    cycler(arg***REMOVED***
    cycler(label1=itr1[, label2=iter2[, ...***REMOVED******REMOVED******REMOVED***
    cycler(label, itr***REMOVED***

    Form 1 simply copies a given `Cycler` object.

    Form 2 composes a `Cycler` as an inner product of the
    pairs of keyword arguments. In other words, all of the
    iterables are cycled simultaneously, as if through zip(***REMOVED***.

    Form 3 creates a `Cycler` from a label and an iterable.
    This is useful for when the label cannot be a keyword argument
    (e.g., an integer or a name that has a space in it***REMOVED***.

    Parameters
    ----------
    arg : Cycler
        Copy constructor for Cycler (does a shallow copy of iterables***REMOVED***.

    label : name
        The property key. In the 2-arg form of the function,
        the label can be any hashable object. In the keyword argument
        form of the function, it must be a valid python identifier.

    itr : iterable
        Finite length iterable of the property values.
        Can be a single-property `Cycler` that would
        be like a key change, but as a shallow copy.

    Returns
    -------
    cycler : Cycler
        New `Cycler` for the given property

    ***REMOVED***
    if args and kwargs:
        raise TypeError("cyl(***REMOVED*** can only accept positional OR keyword "
                        "arguments -- not both."***REMOVED***

    if len(args***REMOVED*** == 1:
        if not isinstance(args[0***REMOVED***, Cycler***REMOVED***:
            raise TypeError("If only one positional argument given, it must "
                            " be a Cycler instance."***REMOVED***
        return Cycler(args[0***REMOVED******REMOVED***
    elif len(args***REMOVED*** == 2:
        return _cycler(*args***REMOVED***
    elif len(args***REMOVED*** > 2:
        raise TypeError("Only a single Cycler can be accepted as the lone "
                        "positional argument. Use keyword arguments instead."***REMOVED***

    if kwargs:
        return reduce(add, (_cycler(k, v***REMOVED*** for k, v in six.iteritems(kwargs***REMOVED******REMOVED******REMOVED***

    raise TypeError("Must have at least a positional OR keyword arguments"***REMOVED***


def _cycler(label, itr***REMOVED***:
    ***REMOVED***
    Create a new `Cycler` object from a property name and
    iterable of values.

    Parameters
    ----------
    label : hashable
        The property key.

    itr : iterable
        Finite length iterable of the property values.

    Returns
    -------
    cycler : Cycler
        New `Cycler` for the given property
    ***REMOVED***
    if isinstance(itr, Cycler***REMOVED***:
        keys = itr.keys
        if len(keys***REMOVED*** != 1:
            msg = "Can not create Cycler from a multi-property Cycler"
            raise ValueError(msg***REMOVED***

        lab = keys.pop(***REMOVED***
        # Doesn't need to be a new list because
        # _from_iter(***REMOVED*** will be creating that new list anyway.
        itr = (v[lab***REMOVED*** for v in itr***REMOVED***

    return Cycler._from_iter(label, itr***REMOVED***
