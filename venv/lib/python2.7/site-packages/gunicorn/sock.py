# -*- coding: utf-8 -
#
# This file is part of gunicorn released under the MIT license.
# See the NOTICE for more information.

import errno
import fcntl
***REMOVED***
import socket
import stat
import sys
import time

from gunicorn import util
from gunicorn.six import string_types

SD_LISTEN_FDS_START = 3


class BaseSocket(object***REMOVED***:

    def __init__(self, address, conf, log, fd=None***REMOVED***:
        self.log = log
        self.conf = conf

        self.cfg_addr = address
        if fd is None:
            sock = socket.socket(self.FAMILY, socket.SOCK_STREAM***REMOVED***
        else:
            sock = socket.fromfd(fd, self.FAMILY, socket.SOCK_STREAM***REMOVED***

        self.sock = self.set_options(sock, bound=(fd is not None***REMOVED******REMOVED***

    def __str__(self, name***REMOVED***:
        return "<socket %d>" % self.sock.fileno(***REMOVED***

    def __getattr__(self, name***REMOVED***:
        return getattr(self.sock, name***REMOVED***

    def set_options(self, sock, bound=False***REMOVED***:
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1***REMOVED***
        if not bound:
            self.bind(sock***REMOVED***
        sock.setblocking(0***REMOVED***

        # make sure that the socket can be inherited
        if hasattr(sock, "set_inheritable"***REMOVED***:
            sock.set_inheritable(True***REMOVED***

        sock.listen(self.conf.backlog***REMOVED***
        return sock

    def bind(self, sock***REMOVED***:
        sock.bind(self.cfg_addr***REMOVED***

    def close(self***REMOVED***:
        if self.sock is None:
            return

        ***REMOVED***
            self.sock.close(***REMOVED***
        except socket.error as e:
            self.log.info("Error while closing socket %s", str(e***REMOVED******REMOVED***

        self.sock = None


class TCPSocket(BaseSocket***REMOVED***:

    FAMILY = socket.AF_INET

    def __str__(self***REMOVED***:
        if self.conf.is_ssl:
            scheme = "https"
        else:
            scheme = "http"

        addr = self.sock.getsockname(***REMOVED***
        return "%s://%s:%d" % (scheme, addr[0***REMOVED***, addr[1***REMOVED******REMOVED***

    def set_options(self, sock, bound=False***REMOVED***:
        sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1***REMOVED***
        return super(TCPSocket, self***REMOVED***.set_options(sock, bound=bound***REMOVED***


class TCP6Socket(TCPSocket***REMOVED***:

    FAMILY = socket.AF_INET6

    def __str__(self***REMOVED***:
        (host, port, fl, sc***REMOVED*** = self.sock.getsockname(***REMOVED***
        return "http://[%s***REMOVED***:%d" % (host, port***REMOVED***


class UnixSocket(BaseSocket***REMOVED***:

    FAMILY = socket.AF_UNIX

    def __init__(self, addr, conf, log, fd=None***REMOVED***:
        if fd is None:
            ***REMOVED***
                st = os.stat(addr***REMOVED***
            except OSError as e:
                if e.args[0***REMOVED*** != errno.ENOENT:
                    raise
            else:
                if stat.S_ISSOCK(st.st_mode***REMOVED***:
                    os.remove(addr***REMOVED***
                else:
                    raise ValueError("%r is not a socket" % addr***REMOVED***
        super(UnixSocket, self***REMOVED***.__init__(addr, conf, log, fd=fd***REMOVED***

    def __str__(self***REMOVED***:
        return "unix:%s" % self.cfg_addr

    def bind(self, sock***REMOVED***:
        old_umask = os.umask(self.conf.umask***REMOVED***
        sock.bind(self.cfg_addr***REMOVED***
        util.chown(self.cfg_addr, self.conf.uid, self.conf.gid***REMOVED***
        os.umask(old_umask***REMOVED***

    def close(self***REMOVED***:
        os.unlink(self.cfg_addr***REMOVED***
        super(UnixSocket, self***REMOVED***.close(***REMOVED***


def _sock_type(addr***REMOVED***:
    if isinstance(addr, tuple***REMOVED***:
        if util.is_ipv6(addr[0***REMOVED******REMOVED***:
            sock_type = TCP6Socket
        else:
            sock_type = TCPSocket
    elif isinstance(addr, string_types***REMOVED***:
        sock_type = UnixSocket
    else:
        raise TypeError("Unable to create socket from: %r" % addr***REMOVED***
    return sock_type


def create_sockets(conf, log***REMOVED***:
    ***REMOVED***
    Create a new socket for the given address. If the
    address is a tuple, a TCP socket is created. If it
    is a string, a Unix socket is created. Otherwise
    a TypeError is raised.
    ***REMOVED***

    # Systemd support, use the sockets managed by systemd and passed to
    # gunicorn.
    # http://www.freedesktop.org/software/systemd/man/systemd.socket.html
    listeners = [***REMOVED***
    if ('LISTEN_PID' in os.environ
            and int(os.environ.get('LISTEN_PID'***REMOVED******REMOVED*** == os.getpid(***REMOVED******REMOVED***:
        for i in range(int(os.environ.get('LISTEN_FDS', 0***REMOVED******REMOVED******REMOVED***:
            fd = i + SD_LISTEN_FDS_START
            ***REMOVED***
                sock = socket.fromfd(fd, socket.AF_UNIX, socket.SOCK_STREAM***REMOVED***
                sockname = sock.getsockname(***REMOVED***
                if isinstance(sockname, str***REMOVED*** and sockname.startswith('/'***REMOVED***:
                    listeners.append(UnixSocket(sockname, conf, log, fd=fd***REMOVED******REMOVED***
                elif len(sockname***REMOVED*** == 2 and '.' in sockname[0***REMOVED***:
                    listeners.append(TCPSocket("%s:%s" % sockname, conf, log,
                        fd=fd***REMOVED******REMOVED***
                elif len(sockname***REMOVED*** == 4 and ':' in sockname[0***REMOVED***:
                    listeners.append(TCP6Socket("[%s***REMOVED***:%s" % sockname[:2***REMOVED***, conf,
                        log, fd=fd***REMOVED******REMOVED***
            except socket.error:
                pass
        del os.environ['LISTEN_PID'***REMOVED***, os.environ['LISTEN_FDS'***REMOVED***

        if listeners:
            log.debug('Socket activation sockets: %s',
                    ",".join([str(l***REMOVED*** for l in listeners***REMOVED******REMOVED******REMOVED***
            return listeners

    # get it only once
    laddr = conf.address

    # check ssl config early to raise the error on startup
    # only the certfile is needed since it can contains the keyfile
    if conf.certfile and not os.path.exists(conf.certfile***REMOVED***:
        raise ValueError('certfile "%s" does not exist' % conf.certfile***REMOVED***

    if conf.keyfile and not os.path.exists(conf.keyfile***REMOVED***:
        raise ValueError('keyfile "%s" does not exist' % conf.keyfile***REMOVED***

    # sockets are already bound
    if 'GUNICORN_FD' in os.environ:
        fds = os.environ.pop('GUNICORN_FD'***REMOVED***.split(','***REMOVED***
        for i, fd in enumerate(fds***REMOVED***:
            fd = int(fd***REMOVED***
            addr = laddr[i***REMOVED***
            sock_type = _sock_type(addr***REMOVED***

            ***REMOVED***
                listeners.append(sock_type(addr, conf, log, fd=fd***REMOVED******REMOVED***
            except socket.error as e:
                if e.args[0***REMOVED*** == errno.ENOTCONN:
                    log.error("GUNICORN_FD should refer to an open socket."***REMOVED***
                else:
                    raise
        return listeners

    # no sockets is bound, first initialization of gunicorn in this env.
    for addr in laddr:
        sock_type = _sock_type(addr***REMOVED***
        # If we fail to create a socket from GUNICORN_FD
        # we fall through and try and open the socket
        # normally.
        sock = None
        for i in range(5***REMOVED***:
            ***REMOVED***
                sock = sock_type(addr, conf, log***REMOVED***
            except socket.error as e:
                if e.args[0***REMOVED*** == errno.EADDRINUSE:
                    log.error("Connection in use: %s", str(addr***REMOVED******REMOVED***
                if e.args[0***REMOVED*** == errno.EADDRNOTAVAIL:
                    log.error("Invalid address: %s", str(addr***REMOVED******REMOVED***
                if i < 5:
                    msg = "connection to {addr***REMOVED*** failed: {error***REMOVED***"
                    log.debug(msg.format(addr=str(addr***REMOVED***, error=str(e***REMOVED******REMOVED******REMOVED***
                    log.error("Retrying in 1 second."***REMOVED***
                    time.sleep(1***REMOVED***
            else:
                break

        if sock is None:
            log.error("Can't connect to %s", str(addr***REMOVED******REMOVED***
            sys.exit(1***REMOVED***

        listeners.append(sock***REMOVED***

    return listeners
