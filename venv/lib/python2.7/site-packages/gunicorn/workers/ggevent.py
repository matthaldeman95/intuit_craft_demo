# -*- coding: utf-8 -
#
# This file is part of gunicorn released under the MIT license.
# See the NOTICE for more information.

import errno
***REMOVED***
import sys
from datetime import datetime
from functools import partial
import time

_socket = __import__("socket"***REMOVED***

# workaround on osx, disable kqueue
if sys.platform == "darwin":
    os.environ['EVENT_NOKQUEUE'***REMOVED*** = "1"

***REMOVED***
    import gevent
except ImportError:
    raise RuntimeError("You need gevent installed to use this worker."***REMOVED***
from gevent.pool import Pool
from gevent.server import StreamServer
from gevent.socket import wait_write, socket
from gevent import pywsgi

import gunicorn
from gunicorn.http.wsgi import base_environ
from gunicorn.workers.async import AsyncWorker
from gunicorn.http.wsgi import sendfile as o_sendfile

VERSION = "gevent/%s gunicorn/%s" % (gevent.__version__, gunicorn.__version__***REMOVED***

def _gevent_sendfile(fdout, fdin, offset, nbytes***REMOVED***:
    while True:
        ***REMOVED***
            return o_sendfile(fdout, fdin, offset, nbytes***REMOVED***
        except OSError as e:
            if e.args[0***REMOVED*** == errno.EAGAIN:
                wait_write(fdout***REMOVED***
            else:
                raise

def patch_sendfile(***REMOVED***:
    from gunicorn.http import wsgi

    if o_sendfile is not None:
        setattr(wsgi, "sendfile", _gevent_sendfile***REMOVED***


class GeventWorker(AsyncWorker***REMOVED***:

    server_class = None
    wsgi_handler = None

    def patch(self***REMOVED***:
        from gevent import monkey
        monkey.noisy = False

        # if the new version is used make sure to patch subprocess
        if gevent.version_info[0***REMOVED*** == 0:
            monkey.patch_all(***REMOVED***
        else:
            monkey.patch_all(subprocess=True***REMOVED***

        # monkey patch sendfile to make it none blocking
        patch_sendfile(***REMOVED***

        # patch sockets
        sockets = [***REMOVED***
        for s in self.sockets:
            if sys.version_info[0***REMOVED*** == 3:
                sockets.append(socket(s.FAMILY, _socket.SOCK_STREAM,
                    fileno=s.sock.fileno(***REMOVED******REMOVED******REMOVED***
            else:
                sockets.append(socket(s.FAMILY, _socket.SOCK_STREAM,
                    _sock=s***REMOVED******REMOVED***
        self.sockets = sockets

    def notify(self***REMOVED***:
        super(GeventWorker, self***REMOVED***.notify(***REMOVED***
        if self.ppid != os.getppid(***REMOVED***:
            self.log.info("Parent changed, shutting down: %s", self***REMOVED***
            sys.exit(0***REMOVED***

    def timeout_ctx(self***REMOVED***:
        return gevent.Timeout(self.cfg.keepalive, False***REMOVED***

    def run(self***REMOVED***:
        servers = [***REMOVED***
        ssl_args = {***REMOVED***

        if self.cfg.is_ssl:
            ssl_args = dict(server_side=True, **self.cfg.ssl_options***REMOVED***

        for s in self.sockets:
            s.setblocking(1***REMOVED***
            pool = Pool(self.worker_connections***REMOVED***
            if self.server_class is not None:
                environ = base_environ(self.cfg***REMOVED***
                environ.update({
                    "wsgi.multithread": True,
                    "SERVER_SOFTWARE": VERSION,
            ***REMOVED******REMOVED***
                server = self.server_class(
                    s, application=self.wsgi, spawn=pool, log=self.log,
                    handler_class=self.wsgi_handler, environ=environ,
                    **ssl_args***REMOVED***
            else:
                hfun = partial(self.handle, s***REMOVED***
                server = StreamServer(s, handle=hfun, spawn=pool, **ssl_args***REMOVED***

            server.start(***REMOVED***
            servers.append(server***REMOVED***

        while self.alive:
            self.notify(***REMOVED***
            gevent.sleep(1.0***REMOVED***

        ***REMOVED***
            # Stop accepting requests
            for server in servers:
                if hasattr(server, 'close'***REMOVED***:  # gevent 1.0
                    server.close(***REMOVED***
                if hasattr(server, 'kill'***REMOVED***:  # gevent < 1.0
                    server.kill(***REMOVED***

            # Handle current requests until graceful_timeout
            ts = time.time(***REMOVED***
            while time.time(***REMOVED*** - ts <= self.cfg.graceful_timeout:
                accepting = 0
                for server in servers:
                    if server.pool.free_count(***REMOVED*** != server.pool.size:
                        accepting += 1

                # if no server is accepting a connection, we can exit
                if not accepting:
                    return

                self.notify(***REMOVED***
                gevent.sleep(1.0***REMOVED***

            # Force kill all active the handlers
            self.log.warning("Worker graceful timeout (pid:%s***REMOVED***" % self.pid***REMOVED***
            [server.stop(timeout=1***REMOVED*** for server in servers***REMOVED***
        ***REMOVED***
            pass

    def handle_request(self, *args***REMOVED***:
        ***REMOVED***
            super(GeventWorker, self***REMOVED***.handle_request(*args***REMOVED***
        except gevent.GreenletExit:
            pass
        except SystemExit:
            pass

    def handle_quit(self, sig, frame***REMOVED***:
        # Move this out of the signal handler so we can use
        # blocking calls. See #1126
        gevent.spawn(super(GeventWorker, self***REMOVED***.handle_quit, sig, frame***REMOVED***

    if gevent.version_info[0***REMOVED*** == 0:

        def init_process(self***REMOVED***:
            # monkey patch here
            self.patch(***REMOVED***

            # reinit the hub
            import gevent.core
            gevent.core.reinit(***REMOVED***

            #gevent 0.13 and older doesn't reinitialize dns for us after forking
            #here's the workaround
            gevent.core.dns_shutdown(fail_requests=1***REMOVED***
            gevent.core.dns_init(***REMOVED***
            super(GeventWorker, self***REMOVED***.init_process(***REMOVED***

    else:

        def init_process(self***REMOVED***:
            # monkey patch here
            self.patch(***REMOVED***

            # reinit the hub
            from gevent import hub
            hub.reinit(***REMOVED***

            # then initialize the process
            super(GeventWorker, self***REMOVED***.init_process(***REMOVED***


class GeventResponse(object***REMOVED***:

    status = None
    headers = None
    sent = None

    def __init__(self, status, headers, clength***REMOVED***:
        self.status = status
        self.headers = headers
        self.sent = clength


class PyWSGIHandler(pywsgi.WSGIHandler***REMOVED***:

    def log_request(self***REMOVED***:
        start = datetime.fromtimestamp(self.time_start***REMOVED***
        finish = datetime.fromtimestamp(self.time_finish***REMOVED***
        response_time = finish - start
        resp_headers = getattr(self, 'response_headers', {***REMOVED******REMOVED***
        resp = GeventResponse(self.status, resp_headers, self.response_length***REMOVED***
        if hasattr(self, 'headers'***REMOVED***:
            req_headers = [h.split(":", 1***REMOVED*** for h in self.headers.headers***REMOVED***
        else:
            req_headers = [***REMOVED***
        self.server.log.access(resp, req_headers, self.environ, response_time***REMOVED***

    def get_environ(self***REMOVED***:
        env = super(PyWSGIHandler, self***REMOVED***.get_environ(***REMOVED***
        env['gunicorn.sock'***REMOVED*** = self.socket
        env['RAW_URI'***REMOVED*** = self.path
        return env


class PyWSGIServer(pywsgi.WSGIServer***REMOVED***:
    pass


class GeventPyWSGIWorker(GeventWorker***REMOVED***:
    "The Gevent StreamServer based workers."
    server_class = PyWSGIServer
    wsgi_handler = PyWSGIHandler
