# -*- coding: utf-8 -
#
# This file is part of gunicorn released under the MIT license.
# See the NOTICE for more information.
#

from datetime import datetime
import errno
***REMOVED***
import select
import socket
import ssl
import sys

import gunicorn.http as http
import gunicorn.http.wsgi as wsgi
import gunicorn.util as util
import gunicorn.workers.base as base
from gunicorn import six

class StopWaiting(Exception***REMOVED***:
    ***REMOVED*** exception raised to stop waiting for a connnection ***REMOVED***

class SyncWorker(base.Worker***REMOVED***:

    def accept(self, listener***REMOVED***:
        client, addr = listener.accept(***REMOVED***
        client.setblocking(1***REMOVED***
        util.close_on_exec(client***REMOVED***
        self.handle(listener, client, addr***REMOVED***

    def wait(self, timeout***REMOVED***:
        ***REMOVED***
            self.notify(***REMOVED***
            ret = select.select(self.wait_fds, [***REMOVED***, [***REMOVED***, timeout***REMOVED***
            if ret[0***REMOVED***:
                if self.PIPE[0***REMOVED*** in ret[0***REMOVED***:
                    os.read(self.PIPE[0***REMOVED***, 1***REMOVED***
                return ret[0***REMOVED***

        except select.error as e:
            if e.args[0***REMOVED*** == errno.EINTR:
                return self.sockets
            if e.args[0***REMOVED*** == errno.EBADF:
                if self.nr < 0:
                    return self.sockets
                else:
                    raise StopWaiting
            raise

    def is_parent_alive(self***REMOVED***:
        # If our parent changed then we shut down.
        if self.ppid != os.getppid(***REMOVED***:
            self.log.info("Parent changed, shutting down: %s", self***REMOVED***
            return False
        return True

    def run_for_one(self, timeout***REMOVED***:
        listener = self.sockets[0***REMOVED***
        while self.alive:
            self.notify(***REMOVED***

            # Accept a connection. If we get an error telling us
            # that no connection is waiting we fall down to the
            # select which is where we'll wait for a bit for new
            # workers to come give us some love.
            ***REMOVED***
                self.accept(listener***REMOVED***
                # Keep processing clients until no one is waiting. This
                # prevents the need to select(***REMOVED*** for every client that we
                # process.
                continue

            except EnvironmentError as e:
                if e.errno not in (errno.EAGAIN, errno.ECONNABORTED,
                        errno.EWOULDBLOCK***REMOVED***:
                    raise

            if not self.is_parent_alive(***REMOVED***:
                return

            ***REMOVED***
                self.wait(timeout***REMOVED***
            except StopWaiting:
                return

    def run_for_multiple(self, timeout***REMOVED***:
        while self.alive:
            self.notify(***REMOVED***

            ***REMOVED***
                ready = self.wait(timeout***REMOVED***
            except StopWaiting:
                return

            if ready is not None:
                for listener in ready:
                    if listener == self.PIPE[0***REMOVED***:
                        continue

                    ***REMOVED***
                        self.accept(listener***REMOVED***
                    except EnvironmentError as e:
                        if e.errno not in (errno.EAGAIN, errno.ECONNABORTED,
                                errno.EWOULDBLOCK***REMOVED***:
                            raise

            if not self.is_parent_alive(***REMOVED***:
                return

    def run(self***REMOVED***:
        # if no timeout is given the worker will never wait and will
        # use the CPU for nothing. This minimal timeout prevent it.
        timeout = self.timeout or 0.5

        # self.socket appears to lose its blocking status after
        # we fork in the arbiter. Reset it here.
        for s in self.sockets:
            s.setblocking(0***REMOVED***

        if len(self.sockets***REMOVED*** > 1:
            self.run_for_multiple(timeout***REMOVED***
        else:
            self.run_for_one(timeout***REMOVED***

    def handle(self, listener, client, addr***REMOVED***:
        req = None
        ***REMOVED***
            if self.cfg.is_ssl:
                client = ssl.wrap_socket(client, server_side=True,
                    **self.cfg.ssl_options***REMOVED***

            parser = http.RequestParser(self.cfg, client***REMOVED***
            req = six.next(parser***REMOVED***
            self.handle_request(listener, req, client, addr***REMOVED***
        except http.errors.NoMoreData as e:
            self.log.debug("Ignored premature client disconnection. %s", e***REMOVED***
        except StopIteration as e:
            self.log.debug("Closing connection. %s", e***REMOVED***
        except ssl.SSLError as e:
            if e.args[0***REMOVED*** == ssl.SSL_ERROR_EOF:
                self.log.debug("ssl connection closed"***REMOVED***
                client.close(***REMOVED***
            else:
                self.log.debug("Error processing SSL request."***REMOVED***
                self.handle_error(req, client, addr, e***REMOVED***
        except EnvironmentError as e:
            if e.errno not in (errno.EPIPE, errno.ECONNRESET***REMOVED***:
                self.log.exception("Socket error processing request."***REMOVED***
            else:
                if e.errno == errno.ECONNRESET:
                    self.log.debug("Ignoring connection reset"***REMOVED***
                else:
                    self.log.debug("Ignoring EPIPE"***REMOVED***
        except Exception as e:
            self.handle_error(req, client, addr, e***REMOVED***
        finally:
            util.close(client***REMOVED***

    def handle_request(self, listener, req, client, addr***REMOVED***:
        environ = {***REMOVED***
        resp = None
        ***REMOVED***
            self.cfg.pre_request(self, req***REMOVED***
            request_start = datetime.now(***REMOVED***
            resp, environ = wsgi.create(req, client, addr,
                    listener.getsockname(***REMOVED***, self.cfg***REMOVED***
            # Force the connection closed until someone shows
            # a buffering proxy that supports Keep-Alive to
            # the backend.
            resp.force_close(***REMOVED***
            self.nr += 1
            if self.nr >= self.max_requests:
                self.log.info("Autorestarting worker after current request."***REMOVED***
                self.alive = False
            respiter = self.wsgi(environ, resp.start_response***REMOVED***
            ***REMOVED***
                if isinstance(respiter, environ['wsgi.file_wrapper'***REMOVED******REMOVED***:
                    resp.write_file(respiter***REMOVED***
                else:
                    for item in respiter:
                        resp.write(item***REMOVED***
                resp.close(***REMOVED***
                request_time = datetime.now(***REMOVED*** - request_start
                self.log.access(resp, req, environ, request_time***REMOVED***
            finally:
                if hasattr(respiter, "close"***REMOVED***:
                    respiter.close(***REMOVED***
        except EnvironmentError:
            # pass to next try-except level
            six.reraise(*sys.exc_info(***REMOVED******REMOVED***
        except Exception:
            if resp and resp.headers_sent:
                # If the requests have already been sent, we should close the
                # connection to indicate the error.
                self.log.exception("Error handling request"***REMOVED***
                ***REMOVED***
                    client.shutdown(socket.SHUT_RDWR***REMOVED***
                    client.close(***REMOVED***
                except EnvironmentError:
                    pass
                raise StopIteration(***REMOVED***
            raise
        finally:
            ***REMOVED***
                self.cfg.post_request(self, req, environ, resp***REMOVED***
            except Exception:
                self.log.exception("Exception in post_request hook"***REMOVED***
