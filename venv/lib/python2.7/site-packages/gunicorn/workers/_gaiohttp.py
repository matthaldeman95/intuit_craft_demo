# -*- coding: utf-8 -
#
# This file is part of gunicorn released under the MIT license.
# See the NOTICE for more information.

import asyncio
import datetime
import functools
import logging
***REMOVED***

***REMOVED***
    import ssl
except ImportError:
    ssl = None

import gunicorn.workers.base as base

from aiohttp.wsgi import WSGIServerHttpProtocol as OldWSGIServerHttpProtocol


class WSGIServerHttpProtocol(OldWSGIServerHttpProtocol***REMOVED***:
    def log_access(self, request, environ, response, time***REMOVED***:
        self.logger.access(response, request, environ, datetime.timedelta(0, 0, time***REMOVED******REMOVED***


class AiohttpWorker(base.Worker***REMOVED***:

    def __init__(self, *args, **kw***REMOVED***:  # pragma: no cover
        super(***REMOVED***.__init__(*args, **kw***REMOVED***
        cfg = self.cfg
        if cfg.is_ssl:
            self.ssl_context = self._create_ssl_context(cfg***REMOVED***
        else:
            self.ssl_context = None
        self.servers = [***REMOVED***
        self.connections = {***REMOVED***

    def init_process(self***REMOVED***:
        # create new event_loop after fork
        asyncio.get_event_loop(***REMOVED***.close(***REMOVED***

        self.loop = asyncio.new_event_loop(***REMOVED***
        asyncio.set_event_loop(self.loop***REMOVED***

        super(***REMOVED***.init_process(***REMOVED***

    def run(self***REMOVED***:
        self._runner = asyncio.async(self._run(***REMOVED***, loop=self.loop***REMOVED***

        ***REMOVED***
            self.loop.run_until_complete(self._runner***REMOVED***
        finally:
            self.loop.close(***REMOVED***

    def wrap_protocol(self, proto***REMOVED***:
        proto.connection_made = _wrp(
            proto, proto.connection_made, self.connections***REMOVED***
        proto.connection_lost = _wrp(
            proto, proto.connection_lost, self.connections, False***REMOVED***
        return proto

    def factory(self, wsgi, addr***REMOVED***:
        # are we in debug level
        is_debug = self.log.loglevel == logging.DEBUG

        proto = WSGIServerHttpProtocol(
            wsgi, readpayload=True,
            loop=self.loop,
            log=self.log,
            debug=is_debug,
            keep_alive=self.cfg.keepalive,
            access_log=self.log.access_log,
            access_log_format=self.cfg.access_log_format***REMOVED***
        return self.wrap_protocol(proto***REMOVED***

    def get_factory(self, sock, addr***REMOVED***:
        return functools.partial(self.factory, self.wsgi, addr***REMOVED***

    @asyncio.coroutine
    def close(self***REMOVED***:
        ***REMOVED***
            if hasattr(self.wsgi, 'close'***REMOVED***:
                yield from self.wsgi.close(***REMOVED***
        ***REMOVED***
            self.log.exception('Process shutdown exception'***REMOVED***

    @asyncio.coroutine
    def _run(self***REMOVED***:
        for sock in self.sockets:
            factory = self.get_factory(sock.sock, sock.cfg_addr***REMOVED***
            self.servers.append(
                (yield from self._create_server(factory, sock***REMOVED******REMOVED******REMOVED***

        # If our parent changed then we shut down.
        pid = os.getpid(***REMOVED***
        ***REMOVED***
            while self.alive or self.connections:
                self.notify(***REMOVED***

                if (self.alive and
                        pid == os.getpid(***REMOVED*** and self.ppid != os.getppid(***REMOVED******REMOVED***:
                    self.log.info("Parent changed, shutting down: %s", self***REMOVED***
                    self.alive = False

                # stop accepting requests
                if not self.alive:
                    if self.servers:
                        self.log.info(
                            "Stopping server: %s, connections: %s",
                            pid, len(self.connections***REMOVED******REMOVED***
                        for server in self.servers:
                            server.close(***REMOVED***
                        self.servers.clear(***REMOVED***

                    # prepare connections for closing
                    for conn in self.connections.values(***REMOVED***:
                        if hasattr(conn, 'closing'***REMOVED***:
                            conn.closing(***REMOVED***

                yield from asyncio.sleep(1.0, loop=self.loop***REMOVED***
        except KeyboardInterrupt:
            pass

        if self.servers:
            for server in self.servers:
                server.close(***REMOVED***

        yield from self.close(***REMOVED***

    @asyncio.coroutine
    def _create_server(self, factory, sock***REMOVED***:
        return self.loop.create_server(factory, sock=sock.sock,
                                       ssl=self.ssl_context***REMOVED***

    @staticmethod
    def _create_ssl_context(cfg***REMOVED***:
        ***REMOVED*** Creates SSLContext instance for usage in asyncio.create_server.

        See ssl.SSLSocket.__init__ for more details.
        ***REMOVED***
        ctx = ssl.SSLContext(cfg.ssl_version***REMOVED***
        ctx.load_cert_chain(cfg.certfile, cfg.keyfile***REMOVED***
        ctx.verify_mode = cfg.cert_reqs
        if cfg.ca_certs:
            ctx.load_verify_locations(cfg.ca_certs***REMOVED***
        if cfg.ciphers:
            ctx.set_ciphers(cfg.ciphers***REMOVED***
        return ctx


class _wrp:

    def __init__(self, proto, meth, tracking, add=True***REMOVED***:
        self._proto = proto
        self._id = id(proto***REMOVED***
        self._meth = meth
        self._tracking = tracking
        self._add = add

    def __call__(self, *args***REMOVED***:
        if self._add:
            self._tracking[self._id***REMOVED*** = self._proto
        elif self._id in self._tracking:
            del self._tracking[self._id***REMOVED***

        conn = self._meth(*args***REMOVED***
        return conn
