# -*- coding: utf-8 -
#
# This file is part of gunicorn released under the MIT license.
# See the NOTICE for more information.

import copy
***REMOVED***
import sys

***REMOVED***
    import tornado.web
except ImportError:
    raise RuntimeError("You need tornado installed to use this worker."***REMOVED***
import tornado.httpserver
from tornado.ioloop import IOLoop, PeriodicCallback
from tornado.wsgi import WSGIContainer
from gunicorn.workers.base import Worker
from gunicorn import __version__ as gversion


class TornadoWorker(Worker***REMOVED***:

    @classmethod
    def setup(cls***REMOVED***:
        web = sys.modules.pop("tornado.web"***REMOVED***
        old_clear = web.RequestHandler.clear

        def clear(self***REMOVED***:
            old_clear(self***REMOVED***
            if not "Gunicorn" in self._headers["Server"***REMOVED***:
                self._headers["Server"***REMOVED*** += " (Gunicorn/%s***REMOVED***" % gversion
        web.RequestHandler.clear = clear
        sys.modules["tornado.web"***REMOVED*** = web

    def handle_exit(self, sig, frame***REMOVED***:
        if self.alive:
            super(TornadoWorker, self***REMOVED***.handle_exit(sig, frame***REMOVED***

    def handle_request(self***REMOVED***:
        self.nr += 1
        if self.alive and self.nr >= self.max_requests:
            self.log.info("Autorestarting worker after current request."***REMOVED***
            self.alive = False

    def watchdog(self***REMOVED***:
        if self.alive:
            self.notify(***REMOVED***

        if self.ppid != os.getppid(***REMOVED***:
            self.log.info("Parent changed, shutting down: %s", self***REMOVED***
            self.alive = False

    def heartbeat(self***REMOVED***:
        if not self.alive:
            if self.server_alive:
                if hasattr(self, 'server'***REMOVED***:
                    ***REMOVED***
                        self.server.stop(***REMOVED***
                    except Exception:
                        pass
                self.server_alive = False
            else:
                if not self.ioloop._callbacks:
                    self.ioloop.stop(***REMOVED***

    def run(self***REMOVED***:
        self.ioloop = IOLoop.instance(***REMOVED***
        self.alive = True
        self.server_alive = False
        PeriodicCallback(self.watchdog, 1000, io_loop=self.ioloop***REMOVED***.start(***REMOVED***
        PeriodicCallback(self.heartbeat, 1000, io_loop=self.ioloop***REMOVED***.start(***REMOVED***

        # Assume the app is a WSGI callable if its not an
        # instance of tornado.web.Application or is an
        # instance of tornado.wsgi.WSGIApplication
        app = self.wsgi
        if not isinstance(app, tornado.web.Application***REMOVED*** or \
           isinstance(app, tornado.wsgi.WSGIApplication***REMOVED***:
            app = WSGIContainer(app***REMOVED***

        # Monkey-patching HTTPConnection.finish to count the
        # number of requests being handled by Tornado. This
        # will help gunicorn shutdown the worker if max_requests
        # is exceeded.
        httpserver = sys.modules["tornado.httpserver"***REMOVED***
        if hasattr(httpserver, 'HTTPConnection'***REMOVED***:
            old_connection_finish = httpserver.HTTPConnection.finish

            def finish(other***REMOVED***:
                self.handle_request(***REMOVED***
                old_connection_finish(other***REMOVED***
            httpserver.HTTPConnection.finish = finish
            sys.modules["tornado.httpserver"***REMOVED*** = httpserver

            server_class = tornado.httpserver.HTTPServer
        else:

            class _HTTPServer(tornado.httpserver.HTTPServer***REMOVED***:

                def on_close(instance, server_conn***REMOVED***:
                    self.handle_request(***REMOVED***
                    super(_HTTPServer, instance***REMOVED***.on_close(server_conn***REMOVED***

            server_class = _HTTPServer

        if self.cfg.is_ssl:
             _ssl_opt = copy.deepcopy(self.cfg.ssl_options***REMOVED***
             # tornado refuses initialization if ssl_options contains following
             # options
             del _ssl_opt["do_handshake_on_connect"***REMOVED***
             del _ssl_opt["suppress_ragged_eofs"***REMOVED***
             server = server_class(app, io_loop=self.ioloop,
                    ssl_options=_ssl_opt***REMOVED***
        else:
            server = server_class(app, io_loop=self.ioloop***REMOVED***

        self.server = server
        self.server_alive = True

        for s in self.sockets:
            s.setblocking(0***REMOVED***
            if hasattr(server, "add_socket"***REMOVED***:  # tornado > 2.0
                server.add_socket(s***REMOVED***
            elif hasattr(server, "_sockets"***REMOVED***:  # tornado 2.0
                server._sockets[s.fileno(***REMOVED******REMOVED*** = s

        server.no_keep_alive = self.cfg.keepalive <= 0
        server.start(num_processes=1***REMOVED***

        self.ioloop.start(***REMOVED***
