# -*- coding: utf-8 -
#
# This file is part of gunicorn released under the MIT license.
# See the NOTICE for more information.

from functools import partial
import errno
import sys

***REMOVED***
    import eventlet
except ImportError:
    raise RuntimeError("You need eventlet installed to use this worker."***REMOVED***

# validate the eventlet version
if eventlet.version_info < (0, 9, 7***REMOVED***:
    raise RuntimeError("You need eventlet >= 0.9.7"***REMOVED***


from eventlet import hubs, greenthread
from eventlet.greenio import GreenSocket
from eventlet.hubs import trampoline
import greenlet

from gunicorn.http.wsgi import sendfile as o_sendfile
from gunicorn.workers.async import AsyncWorker

def _eventlet_sendfile(fdout, fdin, offset, nbytes***REMOVED***:
    while True:
        ***REMOVED***
            return o_sendfile(fdout, fdin, offset, nbytes***REMOVED***
        except OSError as e:
            if e.args[0***REMOVED*** == errno.EAGAIN:
                trampoline(fdout, write=True***REMOVED***
            else:
                raise


def _eventlet_serve(sock, handle, concurrency***REMOVED***:
    ***REMOVED***
    Serve requests forever.

    This code is nearly identical to ``eventlet.convenience.serve`` except
    that it attempts to join the pool at the end, which allows for gunicorn
    graceful shutdowns.
    ***REMOVED***
    pool = eventlet.greenpool.GreenPool(concurrency***REMOVED***
    server_gt = eventlet.greenthread.getcurrent(***REMOVED***

    while True:
        ***REMOVED***
            conn, addr = sock.accept(***REMOVED***
            gt = pool.spawn(handle, conn, addr***REMOVED***
            gt.link(_eventlet_stop, server_gt, conn***REMOVED***
            conn, addr, gt = None, None, None
        except eventlet.StopServe:
            sock.close(***REMOVED***
            pool.waitall(***REMOVED***
            return


def _eventlet_stop(client, server, conn***REMOVED***:
    ***REMOVED***
    Stop a greenlet handling a request and close its connection.

    This code is lifted from eventlet so as not to depend on undocumented
    functions in the library.
    ***REMOVED***
    ***REMOVED***
        ***REMOVED***
            client.wait(***REMOVED***
        finally:
            conn.close(***REMOVED***
    except greenlet.GreenletExit:
        pass
    except Exception:
        greenthread.kill(server, *sys.exc_info(***REMOVED******REMOVED***


def patch_sendfile(***REMOVED***:
    from gunicorn.http import wsgi

    if o_sendfile is not None:
        setattr(wsgi, "sendfile", _eventlet_sendfile***REMOVED***


class EventletWorker(AsyncWorker***REMOVED***:

    def patch(self***REMOVED***:
        hubs.use_hub(***REMOVED***
        eventlet.monkey_patch(os=False***REMOVED***
        patch_sendfile(***REMOVED***

    def init_process(self***REMOVED***:
        self.patch(***REMOVED***
        super(EventletWorker, self***REMOVED***.init_process(***REMOVED***

    def handle_quit(self, sig, frame***REMOVED***:
        eventlet.spawn(super(EventletWorker, self***REMOVED***.handle_quit, sig, frame***REMOVED***

    def timeout_ctx(self***REMOVED***:
        return eventlet.Timeout(self.cfg.keepalive or None, False***REMOVED***

    def handle(self, listener, client, addr***REMOVED***:
        if self.cfg.is_ssl:
            client = eventlet.wrap_ssl(client, server_side=True,
                                       **self.cfg.ssl_options***REMOVED***

        super(EventletWorker, self***REMOVED***.handle(listener, client, addr***REMOVED***

    def run(self***REMOVED***:
        acceptors = [***REMOVED***
        for sock in self.sockets:
            gsock = GreenSocket(sock***REMOVED***
            gsock.setblocking(1***REMOVED***
            hfun = partial(self.handle, gsock***REMOVED***
            acceptor = eventlet.spawn(_eventlet_serve, gsock, hfun,
                                      self.worker_connections***REMOVED***

            acceptors.append(acceptor***REMOVED***
            eventlet.sleep(0.0***REMOVED***

        while self.alive:
            self.notify(***REMOVED***
            eventlet.sleep(1.0***REMOVED***

        self.notify(***REMOVED***
        ***REMOVED***
            with eventlet.Timeout(self.cfg.graceful_timeout***REMOVED*** as t:
                [a.kill(eventlet.StopServe(***REMOVED******REMOVED*** for a in acceptors***REMOVED***
                [a.wait(***REMOVED*** for a in acceptors***REMOVED***
        except eventlet.Timeout as te:
            if te != t:
                raise
            [a.kill(***REMOVED*** for a in acceptors***REMOVED***
