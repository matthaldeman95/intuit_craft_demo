# -*- coding: utf-8 -
#
# This file is part of gunicorn released under the MIT license.
# See the NOTICE for more information.

import io
import logging
***REMOVED***
import re
import sys

from gunicorn._compat import unquote_to_wsgi_str
from gunicorn.http.message import HEADER_RE
from gunicorn.http.errors import InvalidHeader, InvalidHeaderName
from gunicorn.six import string_types, binary_type, reraise
from gunicorn import SERVER_SOFTWARE
import gunicorn.util as util

***REMOVED***
    # Python 3.3 has os.sendfile(***REMOVED***.
    from os import sendfile
except ImportError:
    ***REMOVED***
        from ._sendfile import sendfile
    except ImportError:
        sendfile = None

# Send files in at most 1GB blocks as some operating systems can have problems
# with sending files in blocks over 2GB.
BLKSIZE = 0x3FFFFFFF

NORMALIZE_SPACE = re.compile(r'(?:\r\n***REMOVED***?[ \t***REMOVED***+'***REMOVED***
HEADER_VALUE_RE = re.compile(r'[\x00-\x1F\x7F***REMOVED***'***REMOVED***

log = logging.getLogger(__name__***REMOVED***


class FileWrapper(object***REMOVED***:

    def __init__(self, filelike, blksize=8192***REMOVED***:
        self.filelike = filelike
        self.blksize = blksize
        if hasattr(filelike, 'close'***REMOVED***:
            self.close = filelike.close

    def __getitem__(self, key***REMOVED***:
        data = self.filelike.read(self.blksize***REMOVED***
        if data:
            return data
        raise IndexError


class WSGIErrorsWrapper(io.RawIOBase***REMOVED***:

    def __init__(self, cfg***REMOVED***:
        errorlog = logging.getLogger("gunicorn.error"***REMOVED***
        handlers = errorlog.handlers
        self.streams = [***REMOVED***

        if cfg.errorlog == "-":
            self.streams.append(sys.stderr***REMOVED***
            handlers = handlers[1:***REMOVED***

        for h in handlers:
            if hasattr(h, "stream"***REMOVED***:
                self.streams.append(h.stream***REMOVED***

    def write(self, data***REMOVED***:
        for stream in self.streams:
            ***REMOVED***
                stream.write(data***REMOVED***
            except UnicodeError:
                stream.write(data.encode("UTF-8"***REMOVED******REMOVED***
            stream.flush(***REMOVED***


def base_environ(cfg***REMOVED***:
    return {
        "wsgi.errors": WSGIErrorsWrapper(cfg***REMOVED***,
        "wsgi.version": (1, 0***REMOVED***,
        "wsgi.multithread": False,
        "wsgi.multiprocess": (cfg.workers > 1***REMOVED***,
        "wsgi.run_once": False,
        "wsgi.file_wrapper": FileWrapper,
        "SERVER_SOFTWARE": SERVER_SOFTWARE,
***REMOVED***


def default_environ(req, sock, cfg***REMOVED***:
    env = base_environ(cfg***REMOVED***
    env.update({
        "wsgi.input": req.body,
        "gunicorn.socket": sock,
        "REQUEST_METHOD": req.method,
        "QUERY_STRING": req.query,
        "RAW_URI": req.uri,
        "SERVER_PROTOCOL": "HTTP/%s" % ".".join([str(v***REMOVED*** for v in req.version***REMOVED******REMOVED***
***REMOVED******REMOVED***
    return env


def proxy_environ(req***REMOVED***:
    info = req.proxy_protocol_info

    if not info:
        return {***REMOVED***

    return {
        "PROXY_PROTOCOL": info["proxy_protocol"***REMOVED***,
        "REMOTE_ADDR": info["client_addr"***REMOVED***,
        "REMOTE_PORT": str(info["client_port"***REMOVED******REMOVED***,
        "PROXY_ADDR": info["proxy_addr"***REMOVED***,
        "PROXY_PORT": str(info["proxy_port"***REMOVED******REMOVED***,
***REMOVED***


def create(req, sock, client, server, cfg***REMOVED***:
    resp = Response(req, sock, cfg***REMOVED***

    # set initial environ
    environ = default_environ(req, sock, cfg***REMOVED***

    # default variables
    host = None
    url_scheme = "https" if cfg.is_ssl else "http"
    script_name = os.environ.get("SCRIPT_NAME", ""***REMOVED***

    # set secure_headers
    secure_headers = cfg.secure_scheme_headers
    if client and not isinstance(client, string_types***REMOVED***:
        if ('*' not in cfg.forwarded_allow_ips
                and client[0***REMOVED*** not in cfg.forwarded_allow_ips***REMOVED***:
            secure_headers = {***REMOVED***

    # add the headers to the environ
    for hdr_name, hdr_value in req.headers:
        if hdr_name == "EXPECT":
            # handle expect
            if hdr_value.lower(***REMOVED*** == "100-continue":
                sock.send(b"HTTP/1.1 100 Continue\r\n\r\n"***REMOVED***
        elif secure_headers and (hdr_name in secure_headers and
              hdr_value == secure_headers[hdr_name***REMOVED******REMOVED***:
            url_scheme = "https"
        elif hdr_name == 'HOST':
            host = hdr_value
        elif hdr_name == "SCRIPT_NAME":
            script_name = hdr_value
        elif hdr_name == "CONTENT-TYPE":
            environ['CONTENT_TYPE'***REMOVED*** = hdr_value
            continue
        elif hdr_name == "CONTENT-LENGTH":
            environ['CONTENT_LENGTH'***REMOVED*** = hdr_value
            continue

        key = 'HTTP_' + hdr_name.replace('-', '_'***REMOVED***
        if key in environ:
            hdr_value = "%s,%s" % (environ[key***REMOVED***, hdr_value***REMOVED***
        environ[key***REMOVED*** = hdr_value

    # set the url scheme
    environ['wsgi.url_scheme'***REMOVED*** = url_scheme

    # set the REMOTE_* keys in environ
    # authors should be aware that REMOTE_HOST and REMOTE_ADDR
    # may not qualify the remote addr:
    # http://www.ietf.org/rfc/rfc3875
    if isinstance(client, string_types***REMOVED***:
        environ['REMOTE_ADDR'***REMOVED*** = client
    elif isinstance(client, binary_type***REMOVED***:
        environ['REMOTE_ADDR'***REMOVED*** = str(client***REMOVED***
    else:
        environ['REMOTE_ADDR'***REMOVED*** = client[0***REMOVED***
        environ['REMOTE_PORT'***REMOVED*** = str(client[1***REMOVED******REMOVED***

    # handle the SERVER_*
    # Normally only the application should use the Host header but since the
    # WSGI spec doesn't support unix sockets, we are using it to create
    # viable SERVER_* if possible.
    if isinstance(server, string_types***REMOVED***:
        server = server.split(":"***REMOVED***
        if len(server***REMOVED*** == 1:
            # unix socket
            if host and host is not None:
                server = host.split(':'***REMOVED***
                if len(server***REMOVED*** == 1:
                    if url_scheme == "http":
                        server.append(80***REMOVED***,
                    elif url_scheme == "https":
                        server.append(443***REMOVED***
                    else:
                        server.append(''***REMOVED***
            else:
                # no host header given which means that we are not behind a
                # proxy, so append an empty port.
                server.append(''***REMOVED***
    environ['SERVER_NAME'***REMOVED*** = server[0***REMOVED***
    environ['SERVER_PORT'***REMOVED*** = str(server[1***REMOVED******REMOVED***

    # set the path and script name
    path_info = req.path
    if script_name:
        path_info = path_info.split(script_name, 1***REMOVED***[1***REMOVED***
    environ['PATH_INFO'***REMOVED*** = unquote_to_wsgi_str(path_info***REMOVED***
    environ['SCRIPT_NAME'***REMOVED*** = script_name

    # override the environ with the correct remote and server address if
    # we are behind a proxy using the proxy protocol.
    environ.update(proxy_environ(req***REMOVED******REMOVED***
    return resp, environ


class Response(object***REMOVED***:

    def __init__(self, req, sock, cfg***REMOVED***:
        self.req = req
        self.sock = sock
        self.version = SERVER_SOFTWARE
        self.status = None
        self.chunked = False
        self.must_close = False
        self.headers = [***REMOVED***
        self.headers_sent = False
        self.response_length = None
        self.sent = 0
        self.upgrade = False
        self.cfg = cfg

    def force_close(self***REMOVED***:
        self.must_close = True

    def should_close(self***REMOVED***:
        if self.must_close or self.req.should_close(***REMOVED***:
            return True
        if self.response_length is not None or self.chunked:
            return False
        if self.req.method == 'HEAD':
            return False
        if self.status_code < 200 or self.status_code in (204, 304***REMOVED***:
            return False
        return True

    def start_response(self, status, headers, exc_info=None***REMOVED***:
        if exc_info:
            ***REMOVED***
                if self.status and self.headers_sent:
                    reraise(exc_info[0***REMOVED***, exc_info[1***REMOVED***, exc_info[2***REMOVED******REMOVED***
            finally:
                exc_info = None
        elif self.status is not None:
            raise AssertionError("Response headers already set!"***REMOVED***

        self.status = status

        # get the status code from the response here so we can use it to check
        # the need for the connection header later without parsing the string
        # each time.
        ***REMOVED***
            self.status_code = int(self.status.split(***REMOVED***[0***REMOVED******REMOVED***
        except ValueError:
            self.status_code = None

        self.process_headers(headers***REMOVED***
        self.chunked = self.is_chunked(***REMOVED***
        return self.write

    def process_headers(self, headers***REMOVED***:
        for name, value in headers:
            if not isinstance(name, string_types***REMOVED***:
                raise TypeError('%r is not a string' % name***REMOVED***

            if HEADER_RE.search(name***REMOVED***:
                raise InvalidHeaderName('%r' % name***REMOVED***

            if HEADER_VALUE_RE.search(value***REMOVED***:
                raise InvalidHeader('%r' % value***REMOVED***

            value = str(value***REMOVED***.strip(***REMOVED***
            lname = name.lower(***REMOVED***.strip(***REMOVED***
            if lname == "content-length":
                self.response_length = int(value***REMOVED***
            elif util.is_hoppish(name***REMOVED***:
                if lname == "connection":
                    # handle websocket
                    if value.lower(***REMOVED***.strip(***REMOVED*** == "upgrade":
                        self.upgrade = True
                elif lname == "upgrade":
                    if value.lower(***REMOVED***.strip(***REMOVED*** == "websocket":
                        self.headers.append((name.strip(***REMOVED***, value***REMOVED******REMOVED***

                # ignore hopbyhop headers
                continue
            self.headers.append((name.strip(***REMOVED***, value***REMOVED******REMOVED***

    def is_chunked(self***REMOVED***:
        # Only use chunked responses when the client is
        # speaking HTTP/1.1 or newer and there was
        # no Content-Length header set.
        if self.response_length is not None:
            return False
        elif self.req.version <= (1, 0***REMOVED***:
            return False
        elif self.req.method == 'HEAD':
            # Responses to a HEAD request MUST NOT contain a response body.
            return False
        elif self.status_code in (204, 304***REMOVED***:
            # Do not use chunked responses when the response is guaranteed to
            # not have a response body.
            return False
        return True

    def default_headers(self***REMOVED***:
        # set the connection header
        if self.upgrade:
            connection = "upgrade"
        elif self.should_close(***REMOVED***:
            connection = "close"
        else:
            connection = "keep-alive"

        headers = [
            "HTTP/%s.%s %s\r\n" % (self.req.version[0***REMOVED***,
                self.req.version[1***REMOVED***, self.status***REMOVED***,
            "Server: %s\r\n" % self.version,
            "Date: %s\r\n" % util.http_date(***REMOVED***,
            "Connection: %s\r\n" % connection
        ***REMOVED***
        if self.chunked:
            headers.append("Transfer-Encoding: chunked\r\n"***REMOVED***
        return headers

    def send_headers(self***REMOVED***:
        if self.headers_sent:
            return
        tosend = self.default_headers(***REMOVED***
        tosend.extend(["%s: %s\r\n" % (k, v***REMOVED*** for k, v in self.headers***REMOVED******REMOVED***

        header_str = "%s\r\n" % "".join(tosend***REMOVED***
        util.write(self.sock, util.to_bytestring(header_str, "ascii"***REMOVED******REMOVED***
        self.headers_sent = True

    def write(self, arg***REMOVED***:
        self.send_headers(***REMOVED***
        if not isinstance(arg, binary_type***REMOVED***:
            raise TypeError('%r is not a byte' % arg***REMOVED***
        arglen = len(arg***REMOVED***
        tosend = arglen
        if self.response_length is not None:
            if self.sent >= self.response_length:
                # Never write more than self.response_length bytes
                return

            tosend = min(self.response_length - self.sent, tosend***REMOVED***
            if tosend < arglen:
                arg = arg[:tosend***REMOVED***

        # Sending an empty chunk signals the end of the
        # response and prematurely closes the response
        if self.chunked and tosend == 0:
            return

        self.sent += tosend
        util.write(self.sock, arg, self.chunked***REMOVED***

    def can_sendfile(self***REMOVED***:
        return self.cfg.sendfile is not False and sendfile is not None

    def sendfile(self, respiter***REMOVED***:
        if self.cfg.is_ssl or not self.can_sendfile(***REMOVED***:
            return False

        if not util.has_fileno(respiter.filelike***REMOVED***:
            return False

        fileno = respiter.filelike.fileno(***REMOVED***
        ***REMOVED***
            offset = os.lseek(fileno, 0, os.SEEK_CUR***REMOVED***
            if self.response_length is None:
                filesize = os.fstat(fileno***REMOVED***.st_size

                # The file may be special and sendfile will fail.
                # It may also be zero-length, but that is okay.
                if filesize == 0:
                    return False

                nbytes = filesize - offset
            else:
                nbytes = self.response_length
        except (OSError, io.UnsupportedOperation***REMOVED***:
            return False

        self.send_headers(***REMOVED***

        if self.is_chunked(***REMOVED***:
            chunk_size = "%X\r\n" % nbytes
            self.sock.sendall(chunk_size.encode('utf-8'***REMOVED******REMOVED***

        sockno = self.sock.fileno(***REMOVED***
        sent = 0

        while sent != nbytes:
            count = min(nbytes - sent, BLKSIZE***REMOVED***
            sent += sendfile(sockno, fileno, offset + sent, count***REMOVED***

        if self.is_chunked(***REMOVED***:
            self.sock.sendall(b"\r\n"***REMOVED***

        os.lseek(fileno, offset, os.SEEK_SET***REMOVED***

        return True

    def write_file(self, respiter***REMOVED***:
        if not self.sendfile(respiter***REMOVED***:
            for item in respiter:
                self.write(item***REMOVED***

    def close(self***REMOVED***:
        if not self.headers_sent:
            self.send_headers(***REMOVED***
        if self.chunked:
            util.write_chunk(self.sock, b""***REMOVED***
