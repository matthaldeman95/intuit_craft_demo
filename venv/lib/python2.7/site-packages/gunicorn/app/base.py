# -*- coding: utf-8 -
#
# This file is part of gunicorn released under the MIT license.
# See the NOTICE for more information.
from __future__ import print_function

***REMOVED***
import sys
import traceback

from gunicorn._compat import execfile_
from gunicorn import util
from gunicorn.arbiter import Arbiter
from gunicorn.config import Config, get_default_config_file
from gunicorn import debug

class BaseApplication(object***REMOVED***:
    ***REMOVED***
    An application interface for configuring and loading
    the various necessities for any given web framework.
    ***REMOVED***
    def __init__(self, usage=None, prog=None***REMOVED***:
        self.usage = usage
        self.cfg = None
        self.callable = None
        self.prog = prog
        self.logger = None
        self.do_load_config(***REMOVED***

    def do_load_config(self***REMOVED***:
        ***REMOVED***
        Loads the configuration
        ***REMOVED***
        ***REMOVED***
            self.load_default_config(***REMOVED***
            self.load_config(***REMOVED***
        except Exception as e:
            print("\nError: %s" % str(e***REMOVED***, file=sys.stderr***REMOVED***
            sys.stderr.flush(***REMOVED***
            sys.exit(1***REMOVED***

    def load_default_config(self***REMOVED***:
        # init configuration
        self.cfg = Config(self.usage, prog=self.prog***REMOVED***

    def init(self, parser, opts, args***REMOVED***:
        raise NotImplementedError

    def load(self***REMOVED***:
        raise NotImplementedError

    def load_config(self***REMOVED***:
        ***REMOVED***
        This method is used to load the configuration from one or several input(s***REMOVED***.
        Custom Command line, configuration file.
        You have to override this method in your class.
        ***REMOVED***
        raise NotImplementedError

    def reload(self***REMOVED***:
        self.do_load_config(***REMOVED***
        if self.cfg.spew:
            debug.spew(***REMOVED***

    def wsgi(self***REMOVED***:
        if self.callable is None:
            self.callable = self.load(***REMOVED***
        return self.callable

    def run(self***REMOVED***:
        ***REMOVED***
            Arbiter(self***REMOVED***.run(***REMOVED***
        except RuntimeError as e:
            print("\nError: %s\n" % e, file=sys.stderr***REMOVED***
            sys.stderr.flush(***REMOVED***
            sys.exit(1***REMOVED***

class Application(BaseApplication***REMOVED***:

    def get_config_from_filename(self, filename***REMOVED***:

        if not os.path.exists(filename***REMOVED***:
            raise RuntimeError("%r doesn't exist" % filename***REMOVED***

        cfg = {
            "__builtins__": __builtins__,
            "__name__": "__config__",
            "__file__": filename,
            "__doc__": None,
            "__package__": None
    ***REMOVED***
        ***REMOVED***
            execfile_(filename, cfg, cfg***REMOVED***
        except Exception:
            print("Failed to read config file: %s" % filename, file=sys.stderr***REMOVED***
            traceback.print_exc(***REMOVED***
            sys.stderr.flush(***REMOVED***
            sys.exit(1***REMOVED***

        return cfg

    def get_config_from_module_name(self, module_name***REMOVED***:
        return util.import_module(module_name***REMOVED***.__dict__

    def load_config_from_module_name_or_filename(self, location***REMOVED***:
        ***REMOVED***
        Loads the configuration file: the file is a python file, otherwise raise an RuntimeError
        Exception or stop the process if the configuration file contains a syntax error.
        ***REMOVED***

        if location.startswith("python:"***REMOVED***:
            module_name = location[len("python:"***REMOVED***:***REMOVED***
            cfg = self.get_config_from_module_name(module_name***REMOVED***
        else:
            if location.startswith("file:"***REMOVED***:
                filename = location[len("file:"***REMOVED***:***REMOVED***
            else:
                filename = location
            cfg = self.get_config_from_filename(filename***REMOVED***

        for k, v in cfg.items(***REMOVED***:
            # Ignore unknown names
            if k not in self.cfg.settings:
                continue
            ***REMOVED***
                self.cfg.set(k.lower(***REMOVED***, v***REMOVED***
            ***REMOVED***
                print("Invalid value for %s: %s\n" % (k, v***REMOVED***, file=sys.stderr***REMOVED***
                sys.stderr.flush(***REMOVED***
                raise

        return cfg

    def load_config_from_file(self, filename***REMOVED***:
        return self.load_config_from_module_name_or_filename(location=filename***REMOVED***

    def load_config(self***REMOVED***:
        # parse console args
        parser = self.cfg.parser(***REMOVED***
        args = parser.parse_args(***REMOVED***

        # optional settings from apps
        cfg = self.init(parser, args, args.args***REMOVED***

        # Load up the any app specific configuration
        if cfg and cfg is not None:
            for k, v in cfg.items(***REMOVED***:
                self.cfg.set(k.lower(***REMOVED***, v***REMOVED***

        if args.config:
            self.load_config_from_file(args.config***REMOVED***
        else:
            default_config = get_default_config_file(***REMOVED***
            if default_config is not None:
                self.load_config_from_file(default_config***REMOVED***

        # Lastly, update the configuration with any command line
        # settings.
        for k, v in args.__dict__.items(***REMOVED***:
            if v is None:
                continue
            if k == "args":
                continue
            self.cfg.set(k.lower(***REMOVED***, v***REMOVED***

    def run(self***REMOVED***:
        if self.cfg.check_config:
            ***REMOVED***
                self.load(***REMOVED***
            ***REMOVED***
                msg = "\nError while loading the application:\n"
                print(msg, file=sys.stderr***REMOVED***
                traceback.print_exc(***REMOVED***
                sys.stderr.flush(***REMOVED***
                sys.exit(1***REMOVED***
            sys.exit(0***REMOVED***

        if self.cfg.spew:
            debug.spew(***REMOVED***

        if self.cfg.daemon:
            util.daemonize(self.cfg.enable_stdio_inheritance***REMOVED***

        # set python paths
        if self.cfg.pythonpath and self.cfg.pythonpath is not None:
            paths = self.cfg.pythonpath.split(","***REMOVED***
            for path in paths:
                pythonpath = os.path.abspath(path***REMOVED***
                if pythonpath not in sys.path:
                    sys.path.insert(0, pythonpath***REMOVED***

        super(Application, self***REMOVED***.run(***REMOVED***
