# -*- coding: utf-8 -
#
# This file is part of gunicorn released under the MIT license.
# See the NOTICE for more information.

"Bare-bones implementation of statsD's protocol, client-side"

import socket
import logging
from re import sub

from gunicorn.glogging import Logger
from gunicorn import six

# Instrumentation constants
STATSD_DEFAULT_PORT = 8125
METRIC_VAR = "metric"
VALUE_VAR = "value"
MTYPE_VAR = "mtype"
GAUGE_TYPE = "gauge"
COUNTER_TYPE = "counter"
HISTOGRAM_TYPE = "histogram"

class Statsd(Logger***REMOVED***:
    ***REMOVED***statsD-based instrumentation, that passes as a logger
    ***REMOVED***
    def __init__(self, cfg***REMOVED***:
        ***REMOVED***host, port: statsD server
        ***REMOVED***
        Logger.__init__(self, cfg***REMOVED***
        self.prefix = sub(r"^(.+[^.***REMOVED***+***REMOVED***\.*$", "\g<1>.", cfg.statsd_prefix***REMOVED***
        ***REMOVED***
            host, port = cfg.statsd_host
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM***REMOVED***
            self.sock.connect((host, int(port***REMOVED******REMOVED******REMOVED***
        except Exception:
            self.sock = None

    # Log errors and warnings
    def critical(self, msg, *args, **kwargs***REMOVED***:
        Logger.critical(self, msg, *args, **kwargs***REMOVED***
        self.increment("gunicorn.log.critical", 1***REMOVED***

    def error(self, msg, *args, **kwargs***REMOVED***:
        Logger.error(self, msg, *args, **kwargs***REMOVED***
        self.increment("gunicorn.log.error", 1***REMOVED***

    def warning(self, msg, *args, **kwargs***REMOVED***:
        Logger.warning(self, msg, *args, **kwargs***REMOVED***
        self.increment("gunicorn.log.warning", 1***REMOVED***

    def exception(self, msg, *args, **kwargs***REMOVED***:
        Logger.exception(self, msg, *args, **kwargs***REMOVED***
        self.increment("gunicorn.log.exception", 1***REMOVED***

    # Special treatement for info, the most common log level
    def info(self, msg, *args, **kwargs***REMOVED***:
        self.log(logging.INFO, msg, *args, **kwargs***REMOVED***

    # skip the run-of-the-mill logs
    def debug(self, msg, *args, **kwargs***REMOVED***:
        self.log(logging.DEBUG, msg, *args, **kwargs***REMOVED***

    def log(self, lvl, msg, *args, **kwargs***REMOVED***:
        ***REMOVED***Log a given statistic if metric, value and type are present
        ***REMOVED***
        ***REMOVED***
            extra = kwargs.get("extra", None***REMOVED***
            if extra is not None:
                metric = extra.get(METRIC_VAR, None***REMOVED***
                value = extra.get(VALUE_VAR, None***REMOVED***
                typ = extra.get(MTYPE_VAR, None***REMOVED***
                if metric and value and typ:
                    if typ == GAUGE_TYPE:
                        self.gauge(metric, value***REMOVED***
                    elif typ == COUNTER_TYPE:
                        self.increment(metric, value***REMOVED***
                    elif typ == HISTOGRAM_TYPE:
                        self.histogram(metric, value***REMOVED***
                    else:
                        pass

            # Log to parent logger only if there is something to say
            if msg is not None and len(msg***REMOVED*** > 0:
                Logger.log(self, lvl, msg, *args, **kwargs***REMOVED***
        except Exception:
            Logger.warning(self, "Failed to log to statsd", exc_info=True***REMOVED***

    # access logging
    def access(self, resp, req, environ, request_time***REMOVED***:
        ***REMOVED***Measure request duration
        request_time is a datetime.timedelta
        ***REMOVED***
        Logger.access(self, resp, req, environ, request_time***REMOVED***
        duration_in_ms = request_time.seconds * 1000 + float(request_time.microseconds***REMOVED*** / 10 ** 3
        status = resp.status
        if isinstance(status, str***REMOVED***:
            status = int(status.split(None, 1***REMOVED***[0***REMOVED******REMOVED***
        self.histogram("gunicorn.request.duration", duration_in_ms***REMOVED***
        self.increment("gunicorn.requests", 1***REMOVED***
        self.increment("gunicorn.request.status.%d" % status, 1***REMOVED***

    # statsD methods
    # you can use those directly if you want
    def gauge(self, name, value***REMOVED***:
        self._sock_send("{0***REMOVED***{1***REMOVED***:{2***REMOVED***|g".format(self.prefix, name, value***REMOVED******REMOVED***

    def increment(self, name, value, sampling_rate=1.0***REMOVED***:
        self._sock_send("{0***REMOVED***{1***REMOVED***:{2***REMOVED***|c|@{3***REMOVED***".format(self.prefix, name, value, sampling_rate***REMOVED******REMOVED***

    def decrement(self, name, value, sampling_rate=1.0***REMOVED***:
        self._sock_send("{0***REMOVED***{1***REMOVED***:-{2***REMOVED***|c|@{3***REMOVED***".format(self.prefix, name, value, sampling_rate***REMOVED******REMOVED***

    def histogram(self, name, value***REMOVED***:
        self._sock_send("{0***REMOVED***{1***REMOVED***:{2***REMOVED***|ms".format(self.prefix, name, value***REMOVED******REMOVED***

    def _sock_send(self, msg***REMOVED***:
        ***REMOVED***
            if isinstance(msg, six.text_type***REMOVED***:
                msg = msg.encode("ascii"***REMOVED***
            if self.sock:
                self.sock.send(msg***REMOVED***
        except Exception:
            Logger.warning(self, "Error sending message to statsd", exc_info=True***REMOVED***
