# -*- coding: utf-8 -
#
# This file is part of gunicorn released under the MIT license.
# See the NOTICE for more information.

import base64
import binascii
import time
import logging
logging.Logger.manager.emittedNoHandlerWarning = 1
from logging.config import fileConfig
***REMOVED***
import socket
import sys
import threading
import traceback

from gunicorn import util
from gunicorn.six import PY3, string_types


# syslog facility codes
SYSLOG_FACILITIES = {
        "auth":     4,
        "authpriv": 10,
        "cron":     9,
        "daemon":   3,
        "ftp":      11,
        "kern":     0,
        "lpr":      6,
        "mail":     2,
        "news":     7,
        "security": 4,  #  DEPRECATED
        "syslog":   5,
        "user":     1,
        "uucp":     8,
        "local0":   16,
        "local1":   17,
        "local2":   18,
        "local3":   19,
        "local4":   20,
        "local5":   21,
        "local6":   22,
        "local7":   23
    ***REMOVED***


CONFIG_DEFAULTS = dict(
        version=1,
        disable_existing_loggers=False,

        loggers={
            "root": {"level": "INFO", "handlers": ["console"***REMOVED******REMOVED***,
            "gunicorn.error": {
                "level": "INFO",
                "handlers": ["error_console"***REMOVED***,
                "propagate": True,
                "qualname": "gunicorn.error"
    ***REMOVED***

            "gunicorn.access": {
                "level": "INFO",
                "handlers": ["console"***REMOVED***,
                "propagate": True,
                "qualname": "gunicorn.access"
        ***REMOVED***
***REMOVED***
        handlers={
            "console": {
                "class": "logging.StreamHandler",
                "formatter": "generic",
                "stream": "sys.stdout"
    ***REMOVED***
            "error_console": {
                "class": "logging.StreamHandler",
                "formatter": "generic",
                "stream": "sys.stderr"
    ***REMOVED***
***REMOVED***
        formatters={
            "generic": {
                "format": "%(asctime***REMOVED***s [%(process***REMOVED***d***REMOVED*** [%(levelname***REMOVED***s***REMOVED*** %(message***REMOVED***s",
                "datefmt": "[%Y-%m-%d %H:%M:%S %z***REMOVED***",
                "class": "logging.Formatter"
        ***REMOVED***
    ***REMOVED***
***REMOVED***


def loggers(***REMOVED***:
    ***REMOVED*** get list of all loggers ***REMOVED***
    root = logging.root
    existing = root.manager.loggerDict.keys(***REMOVED***
    return [logging.getLogger(name***REMOVED*** for name in existing***REMOVED***


class SafeAtoms(dict***REMOVED***:

    def __init__(self, atoms***REMOVED***:
        dict.__init__(self***REMOVED***
        for key, value in atoms.items(***REMOVED***:
            if isinstance(value, string_types***REMOVED***:
                self[key***REMOVED*** = value.replace('"', '\\"'***REMOVED***
            else:
                self[key***REMOVED*** = value

    def __getitem__(self, k***REMOVED***:
        if k.startswith("{"***REMOVED***:
            kl = k.lower(***REMOVED***
            if kl in self:
                return super(SafeAtoms, self***REMOVED***.__getitem__(kl***REMOVED***
            else:
                return "-"
        if k in self:
            return super(SafeAtoms, self***REMOVED***.__getitem__(k***REMOVED***
        else:
            return '-'


def parse_syslog_address(addr***REMOVED***:

    if addr.startswith("unix://"***REMOVED***:
        sock_type = socket.SOCK_STREAM

        # are we using a different socket type?
        parts = addr.split("#", 1***REMOVED***
        if len(parts***REMOVED*** == 2:
            addr = parts[0***REMOVED***
            if parts[1***REMOVED*** == "dgram":
                sock_type = socket.SOCK_DGRAM

        return (sock_type, addr.split("unix://"***REMOVED***[1***REMOVED******REMOVED***

    if addr.startswith("udp://"***REMOVED***:
        addr = addr.split("udp://"***REMOVED***[1***REMOVED***
        socktype = socket.SOCK_DGRAM
    elif addr.startswith("tcp://"***REMOVED***:
        addr = addr.split("tcp://"***REMOVED***[1***REMOVED***
        socktype = socket.SOCK_STREAM
    else:
        raise RuntimeError("invalid syslog address"***REMOVED***

    if '[' in addr and '***REMOVED***' in addr:
        host = addr.split('***REMOVED***'***REMOVED***[0***REMOVED***[1:***REMOVED***.lower(***REMOVED***
    elif ':' in addr:
        host = addr.split(':'***REMOVED***[0***REMOVED***.lower(***REMOVED***
    elif addr == "":
        host = "localhost"
    else:
        host = addr.lower(***REMOVED***

    addr = addr.split('***REMOVED***'***REMOVED***[-1***REMOVED***
    if ":" in addr:
        port = addr.split(':', 1***REMOVED***[1***REMOVED***
        if not port.isdigit(***REMOVED***:
            raise RuntimeError("%r is not a valid port number." % port***REMOVED***
        port = int(port***REMOVED***
    else:
        port = 514

    return (socktype, (host, port***REMOVED******REMOVED***


class Logger(object***REMOVED***:

    LOG_LEVELS = {
        "critical": logging.CRITICAL,
        "error": logging.ERROR,
        "warning": logging.WARNING,
        "info": logging.INFO,
        "debug": logging.DEBUG
***REMOVED***
    loglevel = logging.INFO

    error_fmt = r"%(asctime***REMOVED***s [%(process***REMOVED***d***REMOVED*** [%(levelname***REMOVED***s***REMOVED*** %(message***REMOVED***s"
    datefmt = r"[%Y-%m-%d %H:%M:%S %z***REMOVED***"

    access_fmt = "%(message***REMOVED***s"
    syslog_fmt = "[%(process***REMOVED***d***REMOVED*** %(message***REMOVED***s"

    atoms_wrapper_class = SafeAtoms

    def __init__(self, cfg***REMOVED***:
        self.error_log = logging.getLogger("gunicorn.error"***REMOVED***
        self.error_log.propagate = False
        self.access_log = logging.getLogger("gunicorn.access"***REMOVED***
        self.access_log.propagate = False
        self.error_handlers = [***REMOVED***
        self.access_handlers = [***REMOVED***
        self.logfile = None
        self.lock = threading.Lock(***REMOVED***
        self.cfg = cfg
        self.setup(cfg***REMOVED***

    def setup(self, cfg***REMOVED***:
        self.loglevel = self.LOG_LEVELS.get(cfg.loglevel.lower(***REMOVED***, logging.INFO***REMOVED***
        self.error_log.setLevel(self.loglevel***REMOVED***
        self.access_log.setLevel(logging.INFO***REMOVED***

        # set gunicorn.error handler
        if self.cfg.capture_output and cfg.errorlog != "-":
            for stream in sys.stdout, sys.stderr:
                stream.flush(***REMOVED***

            self.logfile = open(cfg.errorlog, 'a+'***REMOVED***
            os.dup2(self.logfile.fileno(***REMOVED***, sys.stdout.fileno(***REMOVED******REMOVED***
            os.dup2(self.logfile.fileno(***REMOVED***, sys.stderr.fileno(***REMOVED******REMOVED***

        self._set_handler(self.error_log, cfg.errorlog,
                          logging.Formatter(self.error_fmt, self.datefmt***REMOVED******REMOVED***

        # set gunicorn.access handler
        if cfg.accesslog is not None:
            self._set_handler(self.access_log, cfg.accesslog,
                fmt=logging.Formatter(self.access_fmt***REMOVED******REMOVED***

        # set syslog handler
        if cfg.syslog:
            self._set_syslog_handler(
                self.error_log, cfg, self.syslog_fmt, "error"
            ***REMOVED***
            self._set_syslog_handler(
                self.access_log, cfg, self.syslog_fmt, "access"
            ***REMOVED***

        if cfg.logconfig:
            if os.path.exists(cfg.logconfig***REMOVED***:
                defaults = CONFIG_DEFAULTS.copy(***REMOVED***
                defaults['__file__'***REMOVED*** = cfg.logconfig
                defaults['here'***REMOVED*** = os.path.dirname(cfg.logconfig***REMOVED***
                fileConfig(cfg.logconfig, defaults=defaults,
                           disable_existing_loggers=False***REMOVED***
            else:
                msg = "Error: log config '%s' not found"
                raise RuntimeError(msg % cfg.logconfig***REMOVED***

    def critical(self, msg, *args, **kwargs***REMOVED***:
        self.error_log.critical(msg, *args, **kwargs***REMOVED***

    def error(self, msg, *args, **kwargs***REMOVED***:
        self.error_log.error(msg, *args, **kwargs***REMOVED***

    def warning(self, msg, *args, **kwargs***REMOVED***:
        self.error_log.warning(msg, *args, **kwargs***REMOVED***

    def info(self, msg, *args, **kwargs***REMOVED***:
        self.error_log.info(msg, *args, **kwargs***REMOVED***

    def debug(self, msg, *args, **kwargs***REMOVED***:
        self.error_log.debug(msg, *args, **kwargs***REMOVED***

    def exception(self, msg, *args, **kwargs***REMOVED***:
        self.error_log.exception(msg, *args, **kwargs***REMOVED***

    def log(self, lvl, msg, *args, **kwargs***REMOVED***:
        if isinstance(lvl, string_types***REMOVED***:
            lvl = self.LOG_LEVELS.get(lvl.lower(***REMOVED***, logging.INFO***REMOVED***
        self.error_log.log(lvl, msg, *args, **kwargs***REMOVED***

    def atoms(self, resp, req, environ, request_time***REMOVED***:
        ***REMOVED*** Gets atoms for log formating.
        ***REMOVED***
        status = resp.status
        if isinstance(status, str***REMOVED***:
            status = status.split(None, 1***REMOVED***[0***REMOVED***
        atoms = {
            'h': environ.get('REMOTE_ADDR', '-'***REMOVED***,
            'l': '-',
            'u': self._get_user(environ***REMOVED*** or '-',
            't': self.now(***REMOVED***,
            'r': "%s %s %s" % (environ['REQUEST_METHOD'***REMOVED***,
                environ['RAW_URI'***REMOVED***, environ["SERVER_PROTOCOL"***REMOVED******REMOVED***,
            's': status,
            'm': environ.get('REQUEST_METHOD'***REMOVED***,
            'U': environ.get('PATH_INFO'***REMOVED***,
            'q': environ.get('QUERY_STRING'***REMOVED***,
            'H': environ.get('SERVER_PROTOCOL'***REMOVED***,
            'b': getattr(resp, 'sent', None***REMOVED*** and str(resp.sent***REMOVED*** or '-',
            'B': getattr(resp, 'sent', None***REMOVED***,
            'f': environ.get('HTTP_REFERER', '-'***REMOVED***,
            'a': environ.get('HTTP_USER_AGENT', '-'***REMOVED***,
            'T': request_time.seconds,
            'D': (request_time.seconds*1000000***REMOVED*** + request_time.microseconds,
            'L': "%d.%06d" % (request_time.seconds, request_time.microseconds***REMOVED***,
            'p': "<%s>" % os.getpid(***REMOVED***
    ***REMOVED***

        # add request headers
        if hasattr(req, 'headers'***REMOVED***:
            req_headers = req.headers
        else:
            req_headers = req

        if hasattr(req_headers, "items"***REMOVED***:
            req_headers = req_headers.items(***REMOVED***

        atoms.update(dict([("{%s***REMOVED***i" % k.lower(***REMOVED***, v***REMOVED*** for k, v in req_headers***REMOVED******REMOVED******REMOVED***

        resp_headers = resp.headers
        if hasattr(resp_headers, "items"***REMOVED***:
            resp_headers = resp_headers.items(***REMOVED***

        # add response headers
        atoms.update(dict([("{%s***REMOVED***o" % k.lower(***REMOVED***, v***REMOVED*** for k, v in resp_headers***REMOVED******REMOVED******REMOVED***

        return atoms

    def access(self, resp, req, environ, request_time***REMOVED***:
        ***REMOVED*** See http://httpd.apache.org/docs/2.0/logs.html#combined
        for format details
        ***REMOVED***

        if not (self.cfg.accesslog or self.cfg.logconfig or self.cfg.syslog***REMOVED***:
            return

        # wrap atoms:
        # - make sure atoms will be test case insensitively
        # - if atom doesn't exist replace it by '-'
        safe_atoms = self.atoms_wrapper_class(self.atoms(resp, req, environ,
            request_time***REMOVED******REMOVED***

        ***REMOVED***
            self.access_log.info(self.cfg.access_log_format % safe_atoms***REMOVED***
        ***REMOVED***
            self.error(traceback.format_exc(***REMOVED******REMOVED***

    def now(self***REMOVED***:
        ***REMOVED*** return date in Apache Common Log Format ***REMOVED***
        return time.strftime('[%d/%b/%Y:%H:%M:%S %z***REMOVED***'***REMOVED***

    def reopen_files(self***REMOVED***:
        if self.cfg.capture_output and self.cfg.errorlog != "-":
            for stream in sys.stdout, sys.stderr:
                stream.flush(***REMOVED***

            with self.lock:
                if self.logfile is not None:
                    self.logfile.close(***REMOVED***
                self.logfile = open(self.cfg.errorlog, 'a+'***REMOVED***
                os.dup2(self.logfile.fileno(***REMOVED***, sys.stdout.fileno(***REMOVED******REMOVED***
                os.dup2(self.logfile.fileno(***REMOVED***, sys.stderr.fileno(***REMOVED******REMOVED***


        for log in loggers(***REMOVED***:
            for handler in log.handlers:
                if isinstance(handler, logging.FileHandler***REMOVED***:
                    handler.acquire(***REMOVED***
                    ***REMOVED***
                        if handler.stream:
                            handler.stream.close(***REMOVED***
                            handler.stream = open(handler.baseFilename,
                                    handler.mode***REMOVED***
                    finally:
                        handler.release(***REMOVED***

    def close_on_exec(self***REMOVED***:
        for log in loggers(***REMOVED***:
            for handler in log.handlers:
                if isinstance(handler, logging.FileHandler***REMOVED***:
                    handler.acquire(***REMOVED***
                    ***REMOVED***
                        if handler.stream:
                            util.close_on_exec(handler.stream.fileno(***REMOVED******REMOVED***
                    finally:
                        handler.release(***REMOVED***

    def _get_gunicorn_handler(self, log***REMOVED***:
        for h in log.handlers:
            if getattr(h, "_gunicorn", False***REMOVED***:
                return h

    def _set_handler(self, log, output, fmt***REMOVED***:
        # remove previous gunicorn log handler
        h = self._get_gunicorn_handler(log***REMOVED***
        if h:
            log.handlers.remove(h***REMOVED***

        if output is not None:
            if output == "-":
                h = logging.StreamHandler(***REMOVED***
            else:
                util.check_is_writeable(output***REMOVED***
                h = logging.FileHandler(output***REMOVED***
                # make sure the user can reopen the file
                ***REMOVED***
                    os.chown(h.baseFilename, self.cfg.user, self.cfg.group***REMOVED***
                except OSError:
                    # it's probably OK there, we assume the user has given
                    # /dev/null as a parameter.
                    pass

            h.setFormatter(fmt***REMOVED***
            h._gunicorn = True
            log.addHandler(h***REMOVED***

    def _set_syslog_handler(self, log, cfg, fmt, name***REMOVED***:
        # setup format
        if not cfg.syslog_prefix:
            prefix = cfg.proc_name.replace(":", "."***REMOVED***
        else:
            prefix = cfg.syslog_prefix

        prefix = "gunicorn.%s.%s" % (prefix, name***REMOVED***

        # set format
        fmt = logging.Formatter(r"%s: %s" % (prefix, fmt***REMOVED******REMOVED***

        # syslog facility
        ***REMOVED***
            facility = SYSLOG_FACILITIES[cfg.syslog_facility.lower(***REMOVED******REMOVED***
        except KeyError:
            raise RuntimeError("unknown facility name"***REMOVED***

        # parse syslog address
        socktype, addr = parse_syslog_address(cfg.syslog_addr***REMOVED***

        # finally setup the syslog handler
        if sys.version_info >= (2, 7***REMOVED***:
            h = logging.handlers.SysLogHandler(address=addr,
                    facility=facility, socktype=socktype***REMOVED***
        else:
            # socktype is only supported in 2.7 and sup
            # fix issue #541
            h = logging.handlers.SysLogHandler(address=addr,
                    facility=facility***REMOVED***

        h.setFormatter(fmt***REMOVED***
        h._gunicorn = True
        log.addHandler(h***REMOVED***

    def _get_user(self, environ***REMOVED***:
        user = None
        http_auth = environ.get("HTTP_AUTHORIZATION"***REMOVED***
        if http_auth and http_auth.startswith('Basic'***REMOVED***:
            auth = http_auth.split(" ", 1***REMOVED***
            if len(auth***REMOVED*** == 2:
                ***REMOVED***
                    # b64decode doesn't accept unicode in Python < 3.3
                    # so we need to convert it to a byte string
                    auth = base64.b64decode(auth[1***REMOVED***.strip(***REMOVED***.encode('utf-8'***REMOVED******REMOVED***
                    if PY3:  # b64decode returns a byte string in Python 3
                        auth = auth.decode('utf-8'***REMOVED***
                    auth = auth.split(":", 1***REMOVED***
                except TypeError as exc:
                    self.debug("Couldn't get username: %s", exc***REMOVED***
                    return user
                except binascii.Error as exc:
                    self.debug("Couldn't get username: %s", exc***REMOVED***
                    return user
                if len(auth***REMOVED*** == 2:
                    user = auth[0***REMOVED***
        return user
