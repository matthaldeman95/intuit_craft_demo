import sys

from gunicorn import six

PY26 = (sys.version_info[:2***REMOVED*** == (2, 6***REMOVED******REMOVED***
PY33 = (sys.version_info >= (3, 3***REMOVED******REMOVED***


def _check_if_pyc(fname***REMOVED***:
    ***REMOVED***Return True if the extension is .pyc, False if .py
    and None if otherwise***REMOVED***
    from imp import find_module
    from os.path import realpath, dirname, basename, splitext

    # Normalize the file-path for the find_module(***REMOVED***
    filepath = realpath(fname***REMOVED***
    dirpath = dirname(filepath***REMOVED***
    module_name = splitext(basename(filepath***REMOVED******REMOVED***[0***REMOVED***

    # Validate and fetch
    ***REMOVED***
        fileobj, fullpath, (_, _, pytype***REMOVED*** = find_module(module_name, [dirpath***REMOVED******REMOVED***
    except ImportError:
        raise IOError("Cannot find config file. "
                      "Path maybe incorrect! : {0***REMOVED***".format(filepath***REMOVED******REMOVED***
    return pytype, fileobj, fullpath


def _get_codeobj(pyfile***REMOVED***:
    ***REMOVED*** Returns the code object, given a python file ***REMOVED***
    from imp import PY_COMPILED, PY_SOURCE

    result, fileobj, fullpath = _check_if_pyc(pyfile***REMOVED***

    # WARNING:
    # fp.read(***REMOVED*** can blowup if the module is extremely large file.
    # Lookout for overflow errors.
    ***REMOVED***
        data = fileobj.read(***REMOVED***
    finally:
        fileobj.close(***REMOVED***

    # This is a .pyc file. Treat accordingly.
    if result is PY_COMPILED:
        # .pyc format is as follows:
        # 0 - 4 bytes: Magic number, which changes with each create of .pyc file.
        #              First 2 bytes change with each marshal of .pyc file. Last 2 bytes is "\r\n".
        # 4 - 8 bytes: Datetime value, when the .py was last changed.
        # 8 - EOF: Marshalled code object data.
        # So to get code object, just read the 8th byte onwards till EOF, and
        # UN-marshal it.
        import marshal
        code_obj = marshal.loads(data[8:***REMOVED******REMOVED***

    elif result is PY_SOURCE:
        # This is a .py file.
        code_obj = compile(data, fullpath, 'exec'***REMOVED***

    else:
        # Unsupported extension
        raise Exception("Input file is unknown format: {0***REMOVED***".format(fullpath***REMOVED******REMOVED***

    # Return code object
    return code_obj

if six.PY3:
    def execfile_(fname, *args***REMOVED***:
        if fname.endswith(".pyc"***REMOVED***:
            code = _get_codeobj(fname***REMOVED***
        else:
            code = compile(open(fname, 'rb'***REMOVED***.read(***REMOVED***, fname, 'exec'***REMOVED***
        return six.exec_(code, *args***REMOVED***

    def bytes_to_str(b***REMOVED***:
        if isinstance(b, six.text_type***REMOVED***:
            return b
        return str(b, 'latin1'***REMOVED***

    import urllib.parse

    def unquote_to_wsgi_str(string***REMOVED***:
        return _unquote_to_bytes(string***REMOVED***.decode('latin-1'***REMOVED***

    _unquote_to_bytes = urllib.parse.unquote_to_bytes

else:
    def execfile_(fname, *args***REMOVED***:
        ***REMOVED*** Overriding PY2 execfile(***REMOVED*** implementation to support .pyc files ***REMOVED***
        if fname.endswith(".pyc"***REMOVED***:
            return six.exec_(_get_codeobj(fname***REMOVED***, *args***REMOVED***
        return execfile(fname, *args***REMOVED***

    def bytes_to_str(s***REMOVED***:
        if isinstance(s, unicode***REMOVED***:
            return s.encode('utf-8'***REMOVED***
        return s

    import urllib
    unquote_to_wsgi_str = urllib.unquote


# The following code adapted from trollius.py33_exceptions
def _wrap_error(exc, mapping, key***REMOVED***:
    if key not in mapping:
        return
    new_err_cls = mapping[key***REMOVED***
    new_err = new_err_cls(*exc.args***REMOVED***

    # raise a new exception with the original traceback
    six.reraise(new_err_cls, new_err,
                exc.__traceback__ if hasattr(exc, '__traceback__'***REMOVED*** else sys.exc_info(***REMOVED***[2***REMOVED******REMOVED***

if PY33:
    import builtins

    BlockingIOError = builtins.BlockingIOError
    BrokenPipeError = builtins.BrokenPipeError
    ChildProcessError = builtins.ChildProcessError
    ConnectionRefusedError = builtins.ConnectionRefusedError
    ConnectionResetError = builtins.ConnectionResetError
    InterruptedError = builtins.InterruptedError
    ConnectionAbortedError = builtins.ConnectionAbortedError
    PermissionError = builtins.PermissionError
    FileNotFoundError = builtins.FileNotFoundError
    ProcessLookupError = builtins.ProcessLookupError

    def wrap_error(func, *args, **kw***REMOVED***:
        return func(*args, **kw***REMOVED***
else:
    import errno
    import select
    import socket

    class BlockingIOError(OSError***REMOVED***:
        pass

    class BrokenPipeError(OSError***REMOVED***:
        pass

    class ChildProcessError(OSError***REMOVED***:
        pass

    class ConnectionRefusedError(OSError***REMOVED***:
        pass

    class InterruptedError(OSError***REMOVED***:
        pass

    class ConnectionResetError(OSError***REMOVED***:
        pass

    class ConnectionAbortedError(OSError***REMOVED***:
        pass

    class PermissionError(OSError***REMOVED***:
        pass

    class FileNotFoundError(OSError***REMOVED***:
        pass

    class ProcessLookupError(OSError***REMOVED***:
        pass

    _MAP_ERRNO = {
        errno.EACCES: PermissionError,
        errno.EAGAIN: BlockingIOError,
        errno.EALREADY: BlockingIOError,
        errno.ECHILD: ChildProcessError,
        errno.ECONNABORTED: ConnectionAbortedError,
        errno.ECONNREFUSED: ConnectionRefusedError,
        errno.ECONNRESET: ConnectionResetError,
        errno.EINPROGRESS: BlockingIOError,
        errno.EINTR: InterruptedError,
        errno.ENOENT: FileNotFoundError,
        errno.EPERM: PermissionError,
        errno.EPIPE: BrokenPipeError,
        errno.ESHUTDOWN: BrokenPipeError,
        errno.EWOULDBLOCK: BlockingIOError,
        errno.ESRCH: ProcessLookupError,
***REMOVED***

    def wrap_error(func, *args, **kw***REMOVED***:
        ***REMOVED***
        Wrap socket.error, IOError, OSError, select.error to raise new specialized
        exceptions of Python 3.3 like InterruptedError (PEP 3151***REMOVED***.
        ***REMOVED***
        ***REMOVED***
            return func(*args, **kw***REMOVED***
        except (socket.error, IOError, OSError***REMOVED*** as exc:
            if hasattr(exc, 'winerror'***REMOVED***:
                _wrap_error(exc, _MAP_ERRNO, exc.winerror***REMOVED***
                # _MAP_ERRNO does not contain all Windows errors.
                # For some errors like "file not found", exc.errno should
                # be used (ex: ENOENT***REMOVED***.
            _wrap_error(exc, _MAP_ERRNO, exc.errno***REMOVED***
            raise
        except select.error as exc:
            if exc.args:
                _wrap_error(exc, _MAP_ERRNO, exc.args[0***REMOVED******REMOVED***
            raise

if PY26:
    from urlparse import (
        _parse_cache, MAX_CACHE_SIZE, clear_cache, _splitnetloc, SplitResult,
        scheme_chars,
    ***REMOVED***

    def urlsplit(url, scheme='', allow_fragments=True***REMOVED***:
        ***REMOVED***Parse a URL into 5 components:
        <scheme>://<netloc>/<path>?<query>#<fragment>
        Return a 5-tuple: (scheme, netloc, path, query, fragment***REMOVED***.
        Note that we don't break the components up in smaller bits
        (e.g. netloc is a single string***REMOVED*** and we don't expand % escapes.***REMOVED***
        allow_fragments = bool(allow_fragments***REMOVED***
        key = url, scheme, allow_fragments, type(url***REMOVED***, type(scheme***REMOVED***
        cached = _parse_cache.get(key, None***REMOVED***
        if cached:
            return cached
        if len(_parse_cache***REMOVED*** >= MAX_CACHE_SIZE: # avoid runaway growth
            clear_cache(***REMOVED***
        netloc = query = fragment = ''
        i = url.find(':'***REMOVED***
        if i > 0:
            if url[:i***REMOVED*** == 'http': # optimize the common case
                scheme = url[:i***REMOVED***.lower(***REMOVED***
                url = url[i+1:***REMOVED***
                if url[:2***REMOVED*** == '//':
                    netloc, url = _splitnetloc(url, 2***REMOVED***
                    if (('[' in netloc and '***REMOVED***' not in netloc***REMOVED*** or
                            ('***REMOVED***' in netloc and '[' not in netloc***REMOVED******REMOVED***:
                        raise ValueError("Invalid IPv6 URL"***REMOVED***
                if allow_fragments and '#' in url:
                    url, fragment = url.split('#', 1***REMOVED***
                if '?' in url:
                    url, query = url.split('?', 1***REMOVED***
                v = SplitResult(scheme, netloc, url, query, fragment***REMOVED***
                _parse_cache[key***REMOVED*** = v
                return v
            for c in url[:i***REMOVED***:
                if c not in scheme_chars:
                    break
            else:
                # make sure "url" is not actually a port number (in which case
                # "scheme" is really part of the path***REMOVED***
                rest = url[i+1:***REMOVED***
                if not rest or any(c not in '0123456789' for c in rest***REMOVED***:
                    # not a port number
                    scheme, url = url[:i***REMOVED***.lower(***REMOVED***, rest

        if url[:2***REMOVED*** == '//':
            netloc, url = _splitnetloc(url, 2***REMOVED***
            if (('[' in netloc and '***REMOVED***' not in netloc***REMOVED*** or
                    ('***REMOVED***' in netloc and '[' not in netloc***REMOVED******REMOVED***:
                raise ValueError("Invalid IPv6 URL"***REMOVED***
        if allow_fragments and '#' in url:
            url, fragment = url.split('#', 1***REMOVED***
        if '?' in url:
            url, query = url.split('?', 1***REMOVED***
        v = SplitResult(scheme, netloc, url, query, fragment***REMOVED***
        _parse_cache[key***REMOVED*** = v
        return v

else:
    from gunicorn.six.moves.urllib.parse import urlsplit
