***REMOVED***Selectors module.

This module allows high-level and efficient I/O multiplexing, built upon the
`select` module primitives.

The following code adapted from trollius.selectors.
***REMOVED***


from abc import ABCMeta, abstractmethod
from collections import namedtuple, Mapping
import math
import select
import sys

from gunicorn._compat import wrap_error, InterruptedError
from gunicorn import six


# generic events, that must be mapped to implementation-specific ones
EVENT_READ = (1 << 0***REMOVED***
EVENT_WRITE = (1 << 1***REMOVED***


def _fileobj_to_fd(fileobj***REMOVED***:
    ***REMOVED***Return a file descriptor from a file object.

    Parameters:
    fileobj -- file object or file descriptor

    Returns:
    corresponding file descriptor

    Raises:
    ValueError if the object is invalid
    ***REMOVED***
    if isinstance(fileobj, six.integer_types***REMOVED***:
        fd = fileobj
    else:
        ***REMOVED***
            fd = int(fileobj.fileno(***REMOVED******REMOVED***
        except (AttributeError, TypeError, ValueError***REMOVED***:
            raise ValueError("Invalid file object: "
                             "{0!r***REMOVED***".format(fileobj***REMOVED******REMOVED***
    if fd < 0:
        raise ValueError("Invalid file descriptor: {0***REMOVED***".format(fd***REMOVED******REMOVED***
    return fd


SelectorKey = namedtuple('SelectorKey', ['fileobj', 'fd', 'events', 'data'***REMOVED******REMOVED***
***REMOVED***Object used to associate a file object to its backing file descriptor,
selected event mask and attached data.***REMOVED***


class _SelectorMapping(Mapping***REMOVED***:
    ***REMOVED***Mapping of file objects to selector keys.***REMOVED***

    def __init__(self, selector***REMOVED***:
        self._selector = selector

    def __len__(self***REMOVED***:
        return len(self._selector._fd_to_key***REMOVED***

    def __getitem__(self, fileobj***REMOVED***:
        ***REMOVED***
            fd = self._selector._fileobj_lookup(fileobj***REMOVED***
            return self._selector._fd_to_key[fd***REMOVED***
        except KeyError:
            raise KeyError("{0!r***REMOVED*** is not registered".format(fileobj***REMOVED******REMOVED***

    def __iter__(self***REMOVED***:
        return iter(self._selector._fd_to_key***REMOVED***


class BaseSelector(six.with_metaclass(ABCMeta***REMOVED******REMOVED***:
    ***REMOVED***Selector abstract base class.

    A selector supports registering file objects to be monitored for specific
    I/O events.

    A file object is a file descriptor or any object with a `fileno(***REMOVED***` method.
    An arbitrary object can be attached to the file object, which can be used
    for example to store context information, a callback, etc.

    A selector can use various implementations (select(***REMOVED***, poll(***REMOVED***, epoll(***REMOVED***...***REMOVED***
    depending on the platform. The default `Selector` class uses the most
    efficient implementation on the current platform.
    ***REMOVED***

    @abstractmethod
    def register(self, fileobj, events, data=None***REMOVED***:
        ***REMOVED***Register a file object.

        Parameters:
        fileobj -- file object or file descriptor
        events  -- events to monitor (bitwise mask of EVENT_READ|EVENT_WRITE***REMOVED***
        data    -- attached data

        Returns:
        SelectorKey instance

        Raises:
        ValueError if events is invalid
        KeyError if fileobj is already registered
        OSError if fileobj is closed or otherwise is unacceptable to
                the underlying system call (if a system call is made***REMOVED***

        Note:
        OSError may or may not be raised
        ***REMOVED***
        raise NotImplementedError

    @abstractmethod
    def unregister(self, fileobj***REMOVED***:
        ***REMOVED***Unregister a file object.

        Parameters:
        fileobj -- file object or file descriptor

        Returns:
        SelectorKey instance

        Raises:
        KeyError if fileobj is not registered

        Note:
        If fileobj is registered but has since been closed this does
        *not* raise OSError (even if the wrapped syscall does***REMOVED***
        ***REMOVED***
        raise NotImplementedError

    def modify(self, fileobj, events, data=None***REMOVED***:
        ***REMOVED***Change a registered file object monitored events or attached data.

        Parameters:
        fileobj -- file object or file descriptor
        events  -- events to monitor (bitwise mask of EVENT_READ|EVENT_WRITE***REMOVED***
        data    -- attached data

        Returns:
        SelectorKey instance

        Raises:
        Anything that unregister(***REMOVED*** or register(***REMOVED*** raises
        ***REMOVED***
        self.unregister(fileobj***REMOVED***
        return self.register(fileobj, events, data***REMOVED***

    @abstractmethod
    def select(self, timeout=None***REMOVED***:
        ***REMOVED***Perform the actual selection, until some monitored file objects are
        ready or a timeout expires.

        Parameters:
        timeout -- if timeout > 0, this specifies the maximum wait time, in
                   seconds
                   if timeout <= 0, the select(***REMOVED*** call won't block, and will
                   report the currently ready file objects
                   if timeout is None, select(***REMOVED*** will block until a monitored
                   file object becomes ready

        Returns:
        list of (key, events***REMOVED*** for ready file objects
        `events` is a bitwise mask of EVENT_READ|EVENT_WRITE
        ***REMOVED***
        raise NotImplementedError

    def close(self***REMOVED***:
        ***REMOVED***Close the selector.

        This must be called to make sure that any underlying resource is freed.
        ***REMOVED***
        pass

    def get_key(self, fileobj***REMOVED***:
        ***REMOVED***Return the key associated to a registered file object.

        Returns:
        SelectorKey for this file object
        ***REMOVED***
        mapping = self.get_map(***REMOVED***
        ***REMOVED***
            return mapping[fileobj***REMOVED***
        except KeyError:
            raise KeyError("{0!r***REMOVED*** is not registered".format(fileobj***REMOVED******REMOVED***

    @abstractmethod
    def get_map(self***REMOVED***:
        ***REMOVED***Return a mapping of file objects to selector keys.***REMOVED***
        raise NotImplementedError

    def __enter__(self***REMOVED***:
        return self

    def __exit__(self, *args***REMOVED***:
        self.close(***REMOVED***


class _BaseSelectorImpl(BaseSelector***REMOVED***:
    ***REMOVED***Base selector implementation.***REMOVED***

    def __init__(self***REMOVED***:
        # this maps file descriptors to keys
        self._fd_to_key = {***REMOVED***
        # read-only mapping returned by get_map(***REMOVED***
        self._map = _SelectorMapping(self***REMOVED***

    def _fileobj_lookup(self, fileobj***REMOVED***:
        ***REMOVED***Return a file descriptor from a file object.

        This wraps _fileobj_to_fd(***REMOVED*** to do an exhaustive search in case
        the object is invalid but we still have it in our map.  This
        is used by unregister(***REMOVED*** so we can unregister an object that
        was previously registered even if it is closed.  It is also
        used by _SelectorMapping.
        ***REMOVED***
        ***REMOVED***
            return _fileobj_to_fd(fileobj***REMOVED***
        except ValueError:
            # Do an exhaustive search.
            for key in self._fd_to_key.values(***REMOVED***:
                if key.fileobj is fileobj:
                    return key.fd
            # Raise ValueError after all.
            raise

    def register(self, fileobj, events, data=None***REMOVED***:
        if (not events***REMOVED*** or (events & ~(EVENT_READ | EVENT_WRITE***REMOVED******REMOVED***:
            raise ValueError("Invalid events: {0!r***REMOVED***".format(events***REMOVED******REMOVED***

        key = SelectorKey(fileobj, self._fileobj_lookup(fileobj***REMOVED***, events, data***REMOVED***

        if key.fd in self._fd_to_key:
            raise KeyError("{0!r***REMOVED*** (FD {1***REMOVED******REMOVED*** is already registered"
                           .format(fileobj, key.fd***REMOVED******REMOVED***

        self._fd_to_key[key.fd***REMOVED*** = key
        return key

    def unregister(self, fileobj***REMOVED***:
        ***REMOVED***
            key = self._fd_to_key.pop(self._fileobj_lookup(fileobj***REMOVED******REMOVED***
        except KeyError:
            raise KeyError("{0!r***REMOVED*** is not registered".format(fileobj***REMOVED******REMOVED***
        return key

    def modify(self, fileobj, events, data=None***REMOVED***:
        # TODO: Subclasses can probably optimize this even further.
        ***REMOVED***
            key = self._fd_to_key[self._fileobj_lookup(fileobj***REMOVED******REMOVED***
        except KeyError:
            raise KeyError("{0!r***REMOVED*** is not registered".format(fileobj***REMOVED******REMOVED***
        if events != key.events:
            self.unregister(fileobj***REMOVED***
            key = self.register(fileobj, events, data***REMOVED***
        elif data != key.data:
            # Use a shortcut to update the data.
            key = key._replace(data=data***REMOVED***
            self._fd_to_key[key.fd***REMOVED*** = key
        return key

    def close(self***REMOVED***:
        self._fd_to_key.clear(***REMOVED***

    def get_map(self***REMOVED***:
        return self._map

    def _key_from_fd(self, fd***REMOVED***:
        ***REMOVED***Return the key associated to a given file descriptor.

        Parameters:
        fd -- file descriptor

        Returns:
        corresponding key, or None if not found
        ***REMOVED***
        ***REMOVED***
            return self._fd_to_key[fd***REMOVED***
        except KeyError:
            return None


class SelectSelector(_BaseSelectorImpl***REMOVED***:
    ***REMOVED***Select-based selector.***REMOVED***

    def __init__(self***REMOVED***:
        super(SelectSelector, self***REMOVED***.__init__(***REMOVED***
        self._readers = set(***REMOVED***
        self._writers = set(***REMOVED***

    def register(self, fileobj, events, data=None***REMOVED***:
        key = super(SelectSelector, self***REMOVED***.register(fileobj, events, data***REMOVED***
        if events & EVENT_READ:
            self._readers.add(key.fd***REMOVED***
        if events & EVENT_WRITE:
            self._writers.add(key.fd***REMOVED***
        return key

    def unregister(self, fileobj***REMOVED***:
        key = super(SelectSelector, self***REMOVED***.unregister(fileobj***REMOVED***
        self._readers.discard(key.fd***REMOVED***
        self._writers.discard(key.fd***REMOVED***
        return key

    if sys.platform == 'win32':
        def _select(self, r, w, _, timeout=None***REMOVED***:
            r, w, x = select.select(r, w, w, timeout***REMOVED***
            return r, w + x, [***REMOVED***
    else:
        _select = select.select

    def select(self, timeout=None***REMOVED***:
        timeout = None if timeout is None else max(timeout, 0***REMOVED***
        ready = [***REMOVED***
        ***REMOVED***
            r, w, _ = wrap_error(self._select,
                                 self._readers, self._writers, [***REMOVED***, timeout***REMOVED***
        except InterruptedError:
            return ready
        r = set(r***REMOVED***
        w = set(w***REMOVED***
        for fd in r | w:
            events = 0
            if fd in r:
                events |= EVENT_READ
            if fd in w:
                events |= EVENT_WRITE

            key = self._key_from_fd(fd***REMOVED***
            if key:
                ready.append((key, events & key.events***REMOVED******REMOVED***
        return ready


if hasattr(select, 'poll'***REMOVED***:

    class PollSelector(_BaseSelectorImpl***REMOVED***:
        ***REMOVED***Poll-based selector.***REMOVED***

        def __init__(self***REMOVED***:
            super(PollSelector, self***REMOVED***.__init__(***REMOVED***
            self._poll = select.poll(***REMOVED***

        def register(self, fileobj, events, data=None***REMOVED***:
            key = super(PollSelector, self***REMOVED***.register(fileobj, events, data***REMOVED***
            poll_events = 0
            if events & EVENT_READ:
                poll_events |= select.POLLIN
            if events & EVENT_WRITE:
                poll_events |= select.POLLOUT
            self._poll.register(key.fd, poll_events***REMOVED***
            return key

        def unregister(self, fileobj***REMOVED***:
            key = super(PollSelector, self***REMOVED***.unregister(fileobj***REMOVED***
            self._poll.unregister(key.fd***REMOVED***
            return key

        def select(self, timeout=None***REMOVED***:
            if timeout is None:
                timeout = None
            elif timeout <= 0:
                timeout = 0
            else:
                # poll(***REMOVED*** has a resolution of 1 millisecond, round away from
                # zero to wait *at least* timeout seconds.
                timeout = int(math.ceil(timeout * 1e3***REMOVED******REMOVED***
            ready = [***REMOVED***
            ***REMOVED***
                fd_event_list = wrap_error(self._poll.poll, timeout***REMOVED***
            except InterruptedError:
                return ready
            for fd, event in fd_event_list:
                events = 0
                if event & ~select.POLLIN:
                    events |= EVENT_WRITE
                if event & ~select.POLLOUT:
                    events |= EVENT_READ

                key = self._key_from_fd(fd***REMOVED***
                if key:
                    ready.append((key, events & key.events***REMOVED******REMOVED***
            return ready


if hasattr(select, 'epoll'***REMOVED***:

    class EpollSelector(_BaseSelectorImpl***REMOVED***:
        ***REMOVED***Epoll-based selector.***REMOVED***

        def __init__(self***REMOVED***:
            super(EpollSelector, self***REMOVED***.__init__(***REMOVED***
            self._epoll = select.epoll(***REMOVED***

        def fileno(self***REMOVED***:
            return self._epoll.fileno(***REMOVED***

        def register(self, fileobj, events, data=None***REMOVED***:
            key = super(EpollSelector, self***REMOVED***.register(fileobj, events, data***REMOVED***
            epoll_events = 0
            if events & EVENT_READ:
                epoll_events |= select.EPOLLIN
            if events & EVENT_WRITE:
                epoll_events |= select.EPOLLOUT
            self._epoll.register(key.fd, epoll_events***REMOVED***
            return key

        def unregister(self, fileobj***REMOVED***:
            key = super(EpollSelector, self***REMOVED***.unregister(fileobj***REMOVED***
            ***REMOVED***
                self._epoll.unregister(key.fd***REMOVED***
            except OSError:
                # This can happen if the FD was closed since it
                # was registered.
                pass
            return key

        def select(self, timeout=None***REMOVED***:
            if timeout is None:
                timeout = -1
            elif timeout <= 0:
                timeout = 0
            else:
                # epoll_wait(***REMOVED*** has a resolution of 1 millisecond, round away
                # from zero to wait *at least* timeout seconds.
                timeout = math.ceil(timeout * 1e3***REMOVED*** * 1e-3
            max_ev = len(self._fd_to_key***REMOVED***
            ready = [***REMOVED***
            ***REMOVED***
                fd_event_list = wrap_error(self._epoll.poll, timeout, max_ev***REMOVED***
            except InterruptedError:
                return ready
            for fd, event in fd_event_list:
                events = 0
                if event & ~select.EPOLLIN:
                    events |= EVENT_WRITE
                if event & ~select.EPOLLOUT:
                    events |= EVENT_READ

                key = self._key_from_fd(fd***REMOVED***
                if key:
                    ready.append((key, events & key.events***REMOVED******REMOVED***
            return ready

        def close(self***REMOVED***:
            self._epoll.close(***REMOVED***
            super(EpollSelector, self***REMOVED***.close(***REMOVED***


if hasattr(select, 'devpoll'***REMOVED***:

    class DevpollSelector(_BaseSelectorImpl***REMOVED***:
        ***REMOVED***Solaris /dev/poll selector.***REMOVED***

        def __init__(self***REMOVED***:
            super(DevpollSelector, self***REMOVED***.__init__(***REMOVED***
            self._devpoll = select.devpoll(***REMOVED***

        def fileno(self***REMOVED***:
            return self._devpoll.fileno(***REMOVED***

        def register(self, fileobj, events, data=None***REMOVED***:
            key = super(DevpollSelector, self***REMOVED***.register(fileobj, events, data***REMOVED***
            poll_events = 0
            if events & EVENT_READ:
                poll_events |= select.POLLIN
            if events & EVENT_WRITE:
                poll_events |= select.POLLOUT
            self._devpoll.register(key.fd, poll_events***REMOVED***
            return key

        def unregister(self, fileobj***REMOVED***:
            key = super(DevpollSelector, self***REMOVED***.unregister(fileobj***REMOVED***
            self._devpoll.unregister(key.fd***REMOVED***
            return key

        def select(self, timeout=None***REMOVED***:
            if timeout is None:
                timeout = None
            elif timeout <= 0:
                timeout = 0
            else:
                # devpoll(***REMOVED*** has a resolution of 1 millisecond, round away from
                # zero to wait *at least* timeout seconds.
                timeout = math.ceil(timeout * 1e3***REMOVED***
            ready = [***REMOVED***
            ***REMOVED***
                fd_event_list = self._devpoll.poll(timeout***REMOVED***
            except InterruptedError:
                return ready
            for fd, event in fd_event_list:
                events = 0
                if event & ~select.POLLIN:
                    events |= EVENT_WRITE
                if event & ~select.POLLOUT:
                    events |= EVENT_READ

                key = self._key_from_fd(fd***REMOVED***
                if key:
                    ready.append((key, events & key.events***REMOVED******REMOVED***
            return ready

        def close(self***REMOVED***:
            self._devpoll.close(***REMOVED***
            super(DevpollSelector, self***REMOVED***.close(***REMOVED***


if hasattr(select, 'kqueue'***REMOVED***:

    class KqueueSelector(_BaseSelectorImpl***REMOVED***:
        ***REMOVED***Kqueue-based selector.***REMOVED***

        def __init__(self***REMOVED***:
            super(KqueueSelector, self***REMOVED***.__init__(***REMOVED***
            self._kqueue = select.kqueue(***REMOVED***

        def fileno(self***REMOVED***:
            return self._kqueue.fileno(***REMOVED***

        def register(self, fileobj, events, data=None***REMOVED***:
            key = super(KqueueSelector, self***REMOVED***.register(fileobj, events, data***REMOVED***
            if events & EVENT_READ:
                kev = select.kevent(key.fd, select.KQ_FILTER_READ,
                                    select.KQ_EV_ADD***REMOVED***
                self._kqueue.control([kev***REMOVED***, 0, 0***REMOVED***
            if events & EVENT_WRITE:
                kev = select.kevent(key.fd, select.KQ_FILTER_WRITE,
                                    select.KQ_EV_ADD***REMOVED***
                self._kqueue.control([kev***REMOVED***, 0, 0***REMOVED***
            return key

        def unregister(self, fileobj***REMOVED***:
            key = super(KqueueSelector, self***REMOVED***.unregister(fileobj***REMOVED***
            if key.events & EVENT_READ:
                kev = select.kevent(key.fd, select.KQ_FILTER_READ,
                                    select.KQ_EV_DELETE***REMOVED***
                ***REMOVED***
                    self._kqueue.control([kev***REMOVED***, 0, 0***REMOVED***
                except OSError:
                    # This can happen if the FD was closed since it
                    # was registered.
                    pass
            if key.events & EVENT_WRITE:
                kev = select.kevent(key.fd, select.KQ_FILTER_WRITE,
                                    select.KQ_EV_DELETE***REMOVED***
                ***REMOVED***
                    self._kqueue.control([kev***REMOVED***, 0, 0***REMOVED***
                except OSError:
                    # See comment above.
                    pass
            return key

        def select(self, timeout=None***REMOVED***:
            timeout = None if timeout is None else max(timeout, 0***REMOVED***
            max_ev = len(self._fd_to_key***REMOVED***
            ready = [***REMOVED***
            ***REMOVED***
                kev_list = wrap_error(self._kqueue.control,
                                      None, max_ev, timeout***REMOVED***
            except InterruptedError:
                return ready
            for kev in kev_list:
                fd = kev.ident
                flag = kev.filter
                events = 0
                if flag == select.KQ_FILTER_READ:
                    events |= EVENT_READ
                if flag == select.KQ_FILTER_WRITE:
                    events |= EVENT_WRITE

                key = self._key_from_fd(fd***REMOVED***
                if key:
                    ready.append((key, events & key.events***REMOVED******REMOVED***
            return ready

        def close(self***REMOVED***:
            self._kqueue.close(***REMOVED***
            super(KqueueSelector, self***REMOVED***.close(***REMOVED***


# Choose the best implementation: roughly, epoll|kqueue|devpoll > poll > select.
# select(***REMOVED*** also can't accept a FD > FD_SETSIZE (usually around 1024***REMOVED***
if 'KqueueSelector' in globals(***REMOVED***:
    DefaultSelector = KqueueSelector
elif 'EpollSelector' in globals(***REMOVED***:
    DefaultSelector = EpollSelector
elif 'DevpollSelector' in globals(***REMOVED***:
    DefaultSelector = DevpollSelector
elif 'PollSelector' in globals(***REMOVED***:
    DefaultSelector = PollSelector
else:
    DefaultSelector = SelectSelector
