# -*- coding: utf-8 -
#
# This file is part of gunicorn released under the MIT license.
# See the NOTICE for more information.
from __future__ import print_function

import errno
***REMOVED***
import random
import select
import signal
import sys
import time
import traceback

from gunicorn.errors import HaltServer, AppImportError
from gunicorn.pidfile import Pidfile
from gunicorn.sock import create_sockets
from gunicorn import util

from gunicorn import __version__, SERVER_SOFTWARE


class Arbiter(object***REMOVED***:
    ***REMOVED***
    Arbiter maintain the workers processes alive. It launches or
    kills them if needed. It also manages application reloading
    via SIGHUP/USR2.
    ***REMOVED***

    # A flag indicating if a worker failed to
    # to boot. If a worker process exist with
    # this error code, the arbiter will terminate.
    WORKER_BOOT_ERROR = 3

    # A flag indicating if an application failed to be loaded
    APP_LOAD_ERROR = 4

    START_CTX = {***REMOVED***

    LISTENERS = [***REMOVED***
    WORKERS = {***REMOVED***
    PIPE = [***REMOVED***

    # I love dynamic languages
    SIG_QUEUE = [***REMOVED***
    SIGNALS = [getattr(signal, "SIG%s" % x***REMOVED***
               for x in "HUP QUIT INT TERM TTIN TTOU USR1 USR2 WINCH".split(***REMOVED******REMOVED***
    SIG_NAMES = dict(
        (getattr(signal, name***REMOVED***, name[3:***REMOVED***.lower(***REMOVED******REMOVED*** for name in dir(signal***REMOVED***
        if name[:3***REMOVED*** == "SIG" and name[3***REMOVED*** != "_"
    ***REMOVED***

    def __init__(self, app***REMOVED***:
        os.environ["SERVER_SOFTWARE"***REMOVED*** = SERVER_SOFTWARE

        self._num_workers = None
        self._last_logged_active_worker_count = None
        self.log = None

        self.setup(app***REMOVED***

        self.pidfile = None
        self.worker_age = 0
        self.reexec_pid = 0
        self.master_pid = 0
        self.master_name = "Master"

        cwd = util.getcwd(***REMOVED***

        args = sys.argv[:***REMOVED***
        args.insert(0, sys.executable***REMOVED***

        # init start context
        self.START_CTX = {
            "args": args,
            "cwd": cwd,
            0: sys.executable
    ***REMOVED***

    def _get_num_workers(self***REMOVED***:
        return self._num_workers

    def _set_num_workers(self, value***REMOVED***:
        old_value = self._num_workers
        self._num_workers = value
        self.cfg.nworkers_changed(self, value, old_value***REMOVED***
    num_workers = property(_get_num_workers, _set_num_workers***REMOVED***

    def setup(self, app***REMOVED***:
        self.app = app
        self.cfg = app.cfg

        if self.log is None:
            self.log = self.cfg.logger_class(app.cfg***REMOVED***

        # reopen files
        if 'GUNICORN_FD' in os.environ:
            self.log.reopen_files(***REMOVED***

        self.worker_class = self.cfg.worker_class
        self.address = self.cfg.address
        self.num_workers = self.cfg.workers
        self.timeout = self.cfg.timeout
        self.proc_name = self.cfg.proc_name

        self.log.debug('Current configuration:\n{0***REMOVED***'.format(
            '\n'.join(
                '  {0***REMOVED***: {1***REMOVED***'.format(config, value.value***REMOVED***
                for config, value
                in sorted(self.cfg.settings.items(***REMOVED***,
                          key=lambda setting: setting[1***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***

        # set enviroment' variables
        if self.cfg.env:
            for k, v in self.cfg.env.items(***REMOVED***:
                os.environ[k***REMOVED*** = v

        if self.cfg.preload_app:
            self.app.wsgi(***REMOVED***

    def start(self***REMOVED***:
        ***REMOVED***\
        Initialize the arbiter. Start listening and set pidfile if needed.
        ***REMOVED***
        self.log.info("Starting gunicorn %s", __version__***REMOVED***

        if 'GUNICORN_PID' in os.environ:
            self.master_pid = int(os.environ.get('GUNICORN_PID'***REMOVED******REMOVED***
            self.proc_name = self.proc_name + ".2"
            self.master_name = "Master.2"

        self.pid = os.getpid(***REMOVED***
        if self.cfg.pidfile is not None:
            pidname = self.cfg.pidfile
            if self.master_pid != 0:
                pidname += ".2"
            self.pidfile = Pidfile(pidname***REMOVED***
            self.pidfile.create(self.pid***REMOVED***
        self.cfg.on_starting(self***REMOVED***

        self.init_signals(***REMOVED***
        if not self.LISTENERS:
            self.LISTENERS = create_sockets(self.cfg, self.log***REMOVED***

        listeners_str = ",".join([str(l***REMOVED*** for l in self.LISTENERS***REMOVED******REMOVED***
        self.log.debug("Arbiter booted"***REMOVED***
        self.log.info("Listening at: %s (%s***REMOVED***", listeners_str, self.pid***REMOVED***
        self.log.info("Using worker: %s", self.cfg.worker_class_str***REMOVED***

        # check worker class requirements
        if hasattr(self.worker_class, "check_config"***REMOVED***:
            self.worker_class.check_config(self.cfg, self.log***REMOVED***

        self.cfg.when_ready(self***REMOVED***

    def init_signals(self***REMOVED***:
        ***REMOVED***\
        Initialize master signal handling. Most of the signals
        are queued. Child signals only wake up the master.
        ***REMOVED***
        # close old PIPE
        if self.PIPE:
            [os.close(p***REMOVED*** for p in self.PIPE***REMOVED***

        # initialize the pipe
        self.PIPE = pair = os.pipe(***REMOVED***
        for p in pair:
            util.set_non_blocking(p***REMOVED***
            util.close_on_exec(p***REMOVED***

        self.log.close_on_exec(***REMOVED***

        # initialize all signals
        [signal.signal(s, self.signal***REMOVED*** for s in self.SIGNALS***REMOVED***
        signal.signal(signal.SIGCHLD, self.handle_chld***REMOVED***

    def signal(self, sig, frame***REMOVED***:
        if len(self.SIG_QUEUE***REMOVED*** < 5:
            self.SIG_QUEUE.append(sig***REMOVED***
            self.wakeup(***REMOVED***

    def run(self***REMOVED***:
        "Main master loop."
        self.start(***REMOVED***
        util._setproctitle("master [%s***REMOVED***" % self.proc_name***REMOVED***

        ***REMOVED***
            self.manage_workers(***REMOVED***

            while True:
                self.maybe_promote_master(***REMOVED***

                sig = self.SIG_QUEUE.pop(0***REMOVED*** if len(self.SIG_QUEUE***REMOVED*** else None
                if sig is None:
                    self.sleep(***REMOVED***
                    self.murder_workers(***REMOVED***
                    self.manage_workers(***REMOVED***
                    continue

                if sig not in self.SIG_NAMES:
                    self.log.info("Ignoring unknown signal: %s", sig***REMOVED***
                    continue

                signame = self.SIG_NAMES.get(sig***REMOVED***
                handler = getattr(self, "handle_%s" % signame, None***REMOVED***
                if not handler:
                    self.log.error("Unhandled signal: %s", signame***REMOVED***
                    continue
                self.log.info("Handling signal: %s", signame***REMOVED***
                handler(***REMOVED***
                self.wakeup(***REMOVED***
        except StopIteration:
            self.halt(***REMOVED***
        except KeyboardInterrupt:
            self.halt(***REMOVED***
        except HaltServer as inst:
            self.halt(reason=inst.reason, exit_status=inst.exit_status***REMOVED***
        except SystemExit:
            raise
        except Exception:
            self.log.info("Unhandled exception in main loop",
                          exc_info=True***REMOVED***
            self.stop(False***REMOVED***
            if self.pidfile is not None:
                self.pidfile.unlink(***REMOVED***
            sys.exit(-1***REMOVED***

    def handle_chld(self, sig, frame***REMOVED***:
        "SIGCHLD handling"
        self.reap_workers(***REMOVED***
        self.wakeup(***REMOVED***

    def handle_hup(self***REMOVED***:
        ***REMOVED***\
        HUP handling.
        - Reload configuration
        - Start the new worker processes with a new configuration
        - Gracefully shutdown the old worker processes
        ***REMOVED***
        self.log.info("Hang up: %s", self.master_name***REMOVED***
        self.reload(***REMOVED***

    def handle_term(self***REMOVED***:
        "SIGTERM handling"
        raise StopIteration

    def handle_int(self***REMOVED***:
        "SIGINT handling"
        self.stop(False***REMOVED***
        raise StopIteration

    def handle_quit(self***REMOVED***:
        "SIGQUIT handling"
        self.stop(False***REMOVED***
        raise StopIteration

    def handle_ttin(self***REMOVED***:
        ***REMOVED***\
        SIGTTIN handling.
        Increases the number of workers by one.
        ***REMOVED***
        self.num_workers += 1
        self.manage_workers(***REMOVED***

    def handle_ttou(self***REMOVED***:
        ***REMOVED***\
        SIGTTOU handling.
        Decreases the number of workers by one.
        ***REMOVED***
        if self.num_workers <= 1:
            return
        self.num_workers -= 1
        self.manage_workers(***REMOVED***

    def handle_usr1(self***REMOVED***:
        ***REMOVED***\
        SIGUSR1 handling.
        Kill all workers by sending them a SIGUSR1
        ***REMOVED***
        self.log.reopen_files(***REMOVED***
        self.kill_workers(signal.SIGUSR1***REMOVED***

    def handle_usr2(self***REMOVED***:
        ***REMOVED***\
        SIGUSR2 handling.
        Creates a new master/worker set as a slave of the current
        master without affecting old workers. Use this to do live
        deployment with the ability to backout a change.
        ***REMOVED***
        self.reexec(***REMOVED***

    def handle_winch(self***REMOVED***:
        "SIGWINCH handling"
        if self.cfg.daemon:
            self.log.info("graceful stop of workers"***REMOVED***
            self.num_workers = 0
            self.kill_workers(signal.SIGTERM***REMOVED***
        else:
            self.log.debug("SIGWINCH ignored. Not daemonized"***REMOVED***

    def maybe_promote_master(self***REMOVED***:
        if self.master_pid == 0:
            return

        if self.master_pid != os.getppid(***REMOVED***:
            self.log.info("Master has been promoted."***REMOVED***
            # reset master infos
            self.master_name = "Master"
            self.master_pid = 0
            self.proc_name = self.cfg.proc_name
            del os.environ['GUNICORN_PID'***REMOVED***
            # rename the pidfile
            if self.pidfile is not None:
                self.pidfile.rename(self.cfg.pidfile***REMOVED***
            # reset proctitle
            util._setproctitle("master [%s***REMOVED***" % self.proc_name***REMOVED***

    def wakeup(self***REMOVED***:
        ***REMOVED***\
        Wake up the arbiter by writing to the PIPE
        ***REMOVED***
        ***REMOVED***
            os.write(self.PIPE[1***REMOVED***, b'.'***REMOVED***
        except IOError as e:
            if e.errno not in [errno.EAGAIN, errno.EINTR***REMOVED***:
                raise

    def halt(self, reason=None, exit_status=0***REMOVED***:
        ***REMOVED*** halt arbiter ***REMOVED***
        self.stop(***REMOVED***
        self.log.info("Shutting down: %s", self.master_name***REMOVED***
        if reason is not None:
            self.log.info("Reason: %s", reason***REMOVED***
        if self.pidfile is not None:
            self.pidfile.unlink(***REMOVED***
        self.cfg.on_exit(self***REMOVED***
        sys.exit(exit_status***REMOVED***

    def sleep(self***REMOVED***:
        ***REMOVED***\
        Sleep until PIPE is readable or we timeout.
        A readable PIPE means a signal occurred.
        ***REMOVED***
        ***REMOVED***
            ready = select.select([self.PIPE[0***REMOVED******REMOVED***, [***REMOVED***, [***REMOVED***, 1.0***REMOVED***
            if not ready[0***REMOVED***:
                return
            while os.read(self.PIPE[0***REMOVED***, 1***REMOVED***:
                pass
        except select.error as e:
            if e.args[0***REMOVED*** not in [errno.EAGAIN, errno.EINTR***REMOVED***:
                raise
        except OSError as e:
            if e.errno not in [errno.EAGAIN, errno.EINTR***REMOVED***:
                raise
        except KeyboardInterrupt:
            sys.exit(***REMOVED***

    def stop(self, graceful=True***REMOVED***:
        ***REMOVED***\
        Stop workers

        :attr graceful: boolean, If True (the default***REMOVED*** workers will be
        killed gracefully  (ie. trying to wait for the current connection***REMOVED***
        ***REMOVED***

        if self.reexec_pid == 0 and self.master_pid == 0:
            for l in self.LISTENERS:
                l.close(***REMOVED***

        self.LISTENERS = [***REMOVED***
        sig = signal.SIGTERM
        if not graceful:
            sig = signal.SIGQUIT
        limit = time.time(***REMOVED*** + self.cfg.graceful_timeout
        # instruct the workers to exit
        self.kill_workers(sig***REMOVED***
        # wait until the graceful timeout
        while self.WORKERS and time.time(***REMOVED*** < limit:
            time.sleep(0.1***REMOVED***

        self.kill_workers(signal.SIGKILL***REMOVED***

    def reexec(self***REMOVED***:
        ***REMOVED***\
        Relaunch the master and workers.
        ***REMOVED***
        if self.reexec_pid != 0:
            self.log.warning("USR2 signal ignored. Child exists."***REMOVED***
            return

        if self.master_pid != 0:
            self.log.warning("USR2 signal ignored. Parent exists"***REMOVED***
            return

        master_pid = os.getpid(***REMOVED***
        self.reexec_pid = os.fork(***REMOVED***
        if self.reexec_pid != 0:
            return

        self.cfg.pre_exec(self***REMOVED***

        environ = self.cfg.env_orig.copy(***REMOVED***
        fds = [l.fileno(***REMOVED*** for l in self.LISTENERS***REMOVED***
        environ['GUNICORN_FD'***REMOVED*** = ",".join([str(fd***REMOVED*** for fd in fds***REMOVED******REMOVED***
        environ['GUNICORN_PID'***REMOVED*** = str(master_pid***REMOVED***

        os.chdir(self.START_CTX['cwd'***REMOVED******REMOVED***

        # exec the process using the original environnement
        os.execvpe(self.START_CTX[0***REMOVED***, self.START_CTX['args'***REMOVED***, environ***REMOVED***

    def reload(self***REMOVED***:
        old_address = self.cfg.address

        # reset old environement
        for k in self.cfg.env:
            if k in self.cfg.env_orig:
                # reset the key to the value it had before
                # we launched gunicorn
                os.environ[k***REMOVED*** = self.cfg.env_orig[k***REMOVED***
            else:
                # delete the value set by gunicorn
                ***REMOVED***
                    del os.environ[k***REMOVED***
                except KeyError:
                    pass

        # reload conf
        self.app.reload(***REMOVED***
        self.setup(self.app***REMOVED***

        # reopen log files
        self.log.reopen_files(***REMOVED***

        # do we need to change listener ?
        if old_address != self.cfg.address:
            # close all listeners
            [l.close(***REMOVED*** for l in self.LISTENERS***REMOVED***
            # init new listeners
            self.LISTENERS = create_sockets(self.cfg, self.log***REMOVED***
            listeners_str = ",".join([str(l***REMOVED*** for l in self.LISTENERS***REMOVED******REMOVED***
            self.log.info("Listening at: %s", listeners_str***REMOVED***

        # do some actions on reload
        self.cfg.on_reload(self***REMOVED***

        # unlink pidfile
        if self.pidfile is not None:
            self.pidfile.unlink(***REMOVED***

        # create new pidfile
        if self.cfg.pidfile is not None:
            self.pidfile = Pidfile(self.cfg.pidfile***REMOVED***
            self.pidfile.create(self.pid***REMOVED***

        # set new proc_name
        util._setproctitle("master [%s***REMOVED***" % self.proc_name***REMOVED***

        # spawn new workers
        for i in range(self.cfg.workers***REMOVED***:
            self.spawn_worker(***REMOVED***

        # manage workers
        self.manage_workers(***REMOVED***

    def murder_workers(self***REMOVED***:
        ***REMOVED***\
        Kill unused/idle workers
        ***REMOVED***
        if not self.timeout:
            return
        workers = list(self.WORKERS.items(***REMOVED******REMOVED***
        for (pid, worker***REMOVED*** in workers:
            ***REMOVED***
                if time.time(***REMOVED*** - worker.tmp.last_update(***REMOVED*** <= self.timeout:
                    continue
            except (OSError, ValueError***REMOVED***:
                continue

            if not worker.aborted:
                self.log.critical("WORKER TIMEOUT (pid:%s***REMOVED***", pid***REMOVED***
                worker.aborted = True
                self.kill_worker(pid, signal.SIGABRT***REMOVED***
            else:
                self.kill_worker(pid, signal.SIGKILL***REMOVED***

    def reap_workers(self***REMOVED***:
        ***REMOVED***\
        Reap workers to avoid zombie processes
        ***REMOVED***
        ***REMOVED***
            while True:
                wpid, status = os.waitpid(-1, os.WNOHANG***REMOVED***
                if not wpid:
                    break
                if self.reexec_pid == wpid:
                    self.reexec_pid = 0
                else:
                    # A worker said it cannot boot. We'll shutdown
                    # to avoid infinite start/stop cycles.
                    exitcode = status >> 8
                    if exitcode == self.WORKER_BOOT_ERROR:
                        reason = "Worker failed to boot."
                        raise HaltServer(reason, self.WORKER_BOOT_ERROR***REMOVED***
                    if exitcode == self.APP_LOAD_ERROR:
                        reason = "App failed to load."
                        raise HaltServer(reason, self.APP_LOAD_ERROR***REMOVED***
                    worker = self.WORKERS.pop(wpid, None***REMOVED***
                    if not worker:
                        continue
                    worker.tmp.close(***REMOVED***
        except OSError as e:
            if e.errno != errno.ECHILD:
                raise

    def manage_workers(self***REMOVED***:
        ***REMOVED***\
        Maintain the number of workers by spawning or killing
        as required.
        ***REMOVED***
        if len(self.WORKERS.keys(***REMOVED******REMOVED*** < self.num_workers:
            self.spawn_workers(***REMOVED***

        workers = self.WORKERS.items(***REMOVED***
        workers = sorted(workers, key=lambda w: w[1***REMOVED***.age***REMOVED***
        while len(workers***REMOVED*** > self.num_workers:
            (pid, _***REMOVED*** = workers.pop(0***REMOVED***
            self.kill_worker(pid, signal.SIGTERM***REMOVED***

        active_worker_count = len(workers***REMOVED***
        if self._last_logged_active_worker_count != active_worker_count:
            self._last_logged_active_worker_count = active_worker_count
            self.log.debug("{0***REMOVED*** workers".format(active_worker_count***REMOVED***,
                           extra={"metric": "gunicorn.workers",
                                  "value": active_worker_count,
                                  "mtype": "gauge"***REMOVED******REMOVED***

    def spawn_worker(self***REMOVED***:
        self.worker_age += 1
        worker = self.worker_class(self.worker_age, self.pid, self.LISTENERS,
                                   self.app, self.timeout / 2.0,
                                   self.cfg, self.log***REMOVED***
        self.cfg.pre_fork(self, worker***REMOVED***
        pid = os.fork(***REMOVED***
        if pid != 0:
            self.WORKERS[pid***REMOVED*** = worker
            return pid

        # Process Child
        worker_pid = os.getpid(***REMOVED***
        ***REMOVED***
            util._setproctitle("worker [%s***REMOVED***" % self.proc_name***REMOVED***
            self.log.info("Booting worker with pid: %s", worker_pid***REMOVED***
            self.cfg.post_fork(self, worker***REMOVED***
            worker.init_process(***REMOVED***
            sys.exit(0***REMOVED***
        except SystemExit:
            raise
        except AppImportError as e:
            self.log.debug("Exception while loading the application",
                           exc_info=True***REMOVED***
            print("%s" % e, file=sys.stderr***REMOVED***
            sys.stderr.flush(***REMOVED***
            sys.exit(self.APP_LOAD_ERROR***REMOVED***
        ***REMOVED***
            self.log.exception("Exception in worker process"***REMOVED***,
            if not worker.booted:
                sys.exit(self.WORKER_BOOT_ERROR***REMOVED***
            sys.exit(-1***REMOVED***
        finally:
            self.log.info("Worker exiting (pid: %s***REMOVED***", worker_pid***REMOVED***
            ***REMOVED***
                worker.tmp.close(***REMOVED***
                self.cfg.worker_exit(self, worker***REMOVED***
            ***REMOVED***
                self.log.warning("Exception during worker exit:\n%s",
                                  traceback.format_exc(***REMOVED******REMOVED***

    def spawn_workers(self***REMOVED***:
        ***REMOVED***\
        Spawn new workers as needed.

        This is where a worker process leaves the main loop
        of the master process.
        ***REMOVED***

        for i in range(self.num_workers - len(self.WORKERS.keys(***REMOVED******REMOVED******REMOVED***:
            self.spawn_worker(***REMOVED***
            time.sleep(0.1 * random.random(***REMOVED******REMOVED***

    def kill_workers(self, sig***REMOVED***:
        ***REMOVED***\
        Kill all workers with the signal `sig`
        :attr sig: `signal.SIG*` value
        ***REMOVED***
        worker_pids = list(self.WORKERS.keys(***REMOVED******REMOVED***
        for pid in worker_pids:
            self.kill_worker(pid, sig***REMOVED***

    def kill_worker(self, pid, sig***REMOVED***:
        ***REMOVED***\
        Kill a worker

        :attr pid: int, worker pid
        :attr sig: `signal.SIG*` value
         ***REMOVED***
        ***REMOVED***
            os.kill(pid, sig***REMOVED***
        except OSError as e:
            if e.errno == errno.ESRCH:
                ***REMOVED***
                    worker = self.WORKERS.pop(pid***REMOVED***
                    worker.tmp.close(***REMOVED***
                    self.cfg.worker_exit(self, worker***REMOVED***
                    return
                except (KeyError, OSError***REMOVED***:
                    return
            raise
