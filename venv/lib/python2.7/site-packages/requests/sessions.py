# -*- coding: utf-8 -*-

***REMOVED***
requests.session
~~~~~~~~~~~~~~~~

This module provides a Session object to manage and persist settings across
requests (cookies, auth, proxies***REMOVED***.
***REMOVED***
***REMOVED***
from collections import Mapping
from datetime import datetime

from .auth import _basic_auth_str
from .compat import cookielib, OrderedDict, urljoin, urlparse
from .cookies import (
    cookiejar_from_dict, extract_cookies_to_jar, RequestsCookieJar, merge_cookies***REMOVED***
from .models import Request, PreparedRequest, DEFAULT_REDIRECT_LIMIT
from .hooks import default_hooks, dispatch_hook
from .utils import to_key_val_list, default_headers, to_native_string
from .exceptions import (
    TooManyRedirects, InvalidSchema, ChunkedEncodingError, ContentDecodingError***REMOVED***
from .packages.urllib3._collections import RecentlyUsedContainer
from .structures import CaseInsensitiveDict

from .adapters import HTTPAdapter

from .utils import (
    requote_uri, get_environ_proxies, get_netrc_auth, should_bypass_proxies,
    get_auth_from_url
***REMOVED***

from .status_codes import codes

# formerly defined here, reexposed here for backward compatibility
from .models import REDIRECT_STATI

REDIRECT_CACHE_SIZE = 1000


def merge_setting(request_setting, session_setting, dict_class=OrderedDict***REMOVED***:
    ***REMOVED***Determines appropriate setting for a given request, taking into account
    the explicit setting on that request, and the setting in the session. If a
    setting is a dictionary, they will be merged together using `dict_class`
    ***REMOVED***

    if session_setting is None:
        return request_setting

    if request_setting is None:
        return session_setting

    # Bypass if not a dictionary (e.g. verify***REMOVED***
    if not (
            isinstance(session_setting, Mapping***REMOVED*** and
            isinstance(request_setting, Mapping***REMOVED***
    ***REMOVED***:
        return request_setting

    merged_setting = dict_class(to_key_val_list(session_setting***REMOVED******REMOVED***
    merged_setting.update(to_key_val_list(request_setting***REMOVED******REMOVED***

    # Remove keys that are set to None. Extract keys first to avoid altering
    # the dictionary during iteration.
    none_keys = [k for (k, v***REMOVED*** in merged_setting.items(***REMOVED*** if v is None***REMOVED***
    for key in none_keys:
        del merged_setting[key***REMOVED***

    return merged_setting


def merge_hooks(request_hooks, session_hooks, dict_class=OrderedDict***REMOVED***:
    ***REMOVED***Properly merges both requests and session hooks.

    This is necessary because when request_hooks == {'response': [***REMOVED******REMOVED***, the
    merge breaks Session hooks entirely.
    ***REMOVED***
    if session_hooks is None or session_hooks.get('response'***REMOVED*** == [***REMOVED***:
        return request_hooks

    if request_hooks is None or request_hooks.get('response'***REMOVED*** == [***REMOVED***:
        return session_hooks

    return merge_setting(request_hooks, session_hooks, dict_class***REMOVED***


class SessionRedirectMixin(object***REMOVED***:
    def resolve_redirects(self, resp, req, stream=False, timeout=None,
                          verify=True, cert=None, proxies=None, **adapter_kwargs***REMOVED***:
        ***REMOVED***Receives a Response. Returns a generator of Responses.***REMOVED***

        i = 0
        hist = [***REMOVED*** # keep track of history

        while resp.is_redirect:
            prepared_request = req.copy(***REMOVED***

            if i > 0:
                # Update history and keep track of redirects.
                hist.append(resp***REMOVED***
                new_hist = list(hist***REMOVED***
                resp.history = new_hist

            ***REMOVED***
                resp.content  # Consume socket so it can be released
            except (ChunkedEncodingError, ContentDecodingError, RuntimeError***REMOVED***:
                resp.raw.read(decode_content=False***REMOVED***

            if i >= self.max_redirects:
                raise TooManyRedirects('Exceeded %s redirects.' % self.max_redirects, response=resp***REMOVED***

            # Release the connection back into the pool.
            resp.close(***REMOVED***

            url = resp.headers['location'***REMOVED***

            # Handle redirection without scheme (see: RFC 1808 Section 4***REMOVED***
            if url.startswith('//'***REMOVED***:
                parsed_rurl = urlparse(resp.url***REMOVED***
                url = '%s:%s' % (parsed_rurl.scheme, url***REMOVED***

            # The scheme should be lower case...
            parsed = urlparse(url***REMOVED***
            url = parsed.geturl(***REMOVED***

            # Facilitate relative 'location' headers, as allowed by RFC 7231.
            # (e.g. '/path/to/resource' instead of 'http://domain.tld/path/to/resource'***REMOVED***
            # Compliant with RFC3986, we percent encode the url.
            if not parsed.netloc:
                url = urljoin(resp.url, requote_uri(url***REMOVED******REMOVED***
            else:
                url = requote_uri(url***REMOVED***

            prepared_request.url = to_native_string(url***REMOVED***
            # Cache the url, unless it redirects to itself.
            if resp.is_permanent_redirect and req.url != prepared_request.url:
                self.redirect_cache[req.url***REMOVED*** = prepared_request.url

            self.rebuild_method(prepared_request, resp***REMOVED***

            # https://github.com/kennethreitz/requests/issues/1084
            if resp.status_code not in (codes.temporary_redirect, codes.permanent_redirect***REMOVED***:
                # https://github.com/kennethreitz/requests/issues/3490
                purged_headers = ('Content-Length', 'Content-Type', 'Transfer-Encoding'***REMOVED***
                for header in purged_headers:
                    prepared_request.headers.pop(header, None***REMOVED***
                prepared_request.body = None

            headers = prepared_request.headers
            ***REMOVED***
                del headers['Cookie'***REMOVED***
            except KeyError:
                pass

            # Extract any cookies sent on the response to the cookiejar
            # in the new request. Because we've mutated our copied prepared
            # request, use the old one that we haven't yet touched.
            extract_cookies_to_jar(prepared_request._cookies, req, resp.raw***REMOVED***
            prepared_request._cookies.update(self.cookies***REMOVED***
            prepared_request.prepare_cookies(prepared_request._cookies***REMOVED***

            # Rebuild auth and proxy information.
            proxies = self.rebuild_proxies(prepared_request, proxies***REMOVED***
            self.rebuild_auth(prepared_request, resp***REMOVED***

            # Override the original request.
            req = prepared_request

            resp = self.send(
                req,
                stream=stream,
                timeout=timeout,
                verify=verify,
                cert=cert,
                proxies=proxies,
                allow_redirects=False,
                **adapter_kwargs
            ***REMOVED***

            extract_cookies_to_jar(self.cookies, prepared_request, resp.raw***REMOVED***

            i += 1
            yield resp

    def rebuild_auth(self, prepared_request, response***REMOVED***:
        ***REMOVED***When being redirected we may want to strip authentication from the
        request to avoid leaking credentials. This method intelligently removes
        and reapplies authentication where possible to avoid credential loss.
        ***REMOVED***
        headers = prepared_request.headers
        url = prepared_request.url

        if 'Authorization' in headers:
            # If we get redirected to a new host, we should strip out any
            # authentication headers.
            original_parsed = urlparse(response.request.url***REMOVED***
            redirect_parsed = urlparse(url***REMOVED***

            if (original_parsed.hostname != redirect_parsed.hostname***REMOVED***:
                del headers['Authorization'***REMOVED***

        # .netrc might have more auth for us on our new host.
        new_auth = get_netrc_auth(url***REMOVED*** if self.trust_env else None
        if new_auth is not None:
            prepared_request.prepare_auth(new_auth***REMOVED***

        return

    def rebuild_proxies(self, prepared_request, proxies***REMOVED***:
        ***REMOVED***This method re-evaluates the proxy configuration by considering the
        environment variables. If we are redirected to a URL covered by
        NO_PROXY, we strip the proxy configuration. Otherwise, we set missing
        proxy keys for this URL (in case they were stripped by a previous
        redirect***REMOVED***.

        This method also replaces the Proxy-Authorization header where
        necessary.

        :rtype: dict
        ***REMOVED***
        headers = prepared_request.headers
        url = prepared_request.url
        scheme = urlparse(url***REMOVED***.scheme
        new_proxies = proxies.copy(***REMOVED*** if proxies is not None else {***REMOVED***

        if self.trust_env and not should_bypass_proxies(url***REMOVED***:
            environ_proxies = get_environ_proxies(url***REMOVED***

            proxy = environ_proxies.get('all', environ_proxies.get(scheme***REMOVED******REMOVED***

            if proxy:
                new_proxies.setdefault(scheme, proxy***REMOVED***

        if 'Proxy-Authorization' in headers:
            del headers['Proxy-Authorization'***REMOVED***

        ***REMOVED***
            username, password = get_auth_from_url(new_proxies[scheme***REMOVED******REMOVED***
        except KeyError:
            username, password = None, None

        if username and password:
            headers['Proxy-Authorization'***REMOVED*** = _basic_auth_str(username, password***REMOVED***

        return new_proxies

    def rebuild_method(self, prepared_request, response***REMOVED***:
        ***REMOVED***When being redirected we may want to change the method of the request
        based on certain specs or browser behavior.
        ***REMOVED***
        method = prepared_request.method

        # http://tools.ietf.org/html/rfc7231#section-6.4.4
        if response.status_code == codes.see_other and method != 'HEAD':
            method = 'GET'

        # Do what the browsers do, despite standards...
        # First, turn 302s into GETs.
        if response.status_code == codes.found and method != 'HEAD':
            method = 'GET'

        # Second, if a POST is responded to with a 301, turn it into a GET.
        # This bizarre behaviour is explained in Issue 1704.
        if response.status_code == codes.moved and method == 'POST':
            method = 'GET'

        prepared_request.method = method


class Session(SessionRedirectMixin***REMOVED***:
    ***REMOVED***A Requests session.

    Provides cookie persistence, connection-pooling, and configuration.

    Basic Usage::

      >>> import requests
      >>> s = requests.Session(***REMOVED***
      >>> s.get('http://httpbin.org/get'***REMOVED***
      <Response [200***REMOVED***>

    Or as a context manager::

      >>> with requests.Session(***REMOVED*** as s:
      >>>     s.get('http://httpbin.org/get'***REMOVED***
      <Response [200***REMOVED***>
    ***REMOVED***

    __attrs__ = [
        'headers', 'cookies', 'auth', 'proxies', 'hooks', 'params', 'verify',
        'cert', 'prefetch', 'adapters', 'stream', 'trust_env',
        'max_redirects',
    ***REMOVED***

    def __init__(self***REMOVED***:

        #: A case-insensitive dictionary of headers to be sent on each
        #: :class:`Request <Request>` sent from this
        #: :class:`Session <Session>`.
        self.headers = default_headers(***REMOVED***

        #: Default Authentication tuple or object to attach to
        #: :class:`Request <Request>`.
        self.auth = None

        #: Dictionary mapping protocol or protocol and host to the URL of the proxy
        #: (e.g. {'http': 'foo.bar:3128', 'http://host.name': 'foo.bar:4012'***REMOVED******REMOVED*** to
        #: be used on each :class:`Request <Request>`.
        self.proxies = {***REMOVED***

        #: Event-handling hooks.
        self.hooks = default_hooks(***REMOVED***

        #: Dictionary of querystring data to attach to each
        #: :class:`Request <Request>`. The dictionary values may be lists for
        #: representing multivalued query parameters.
        self.params = {***REMOVED***

        #: Stream response content default.
        self.stream = False

        #: SSL Verification default.
        self.verify = True

        #: SSL certificate default.
        self.cert = None

        #: Maximum number of redirects allowed. If the request exceeds this
        #: limit, a :class:`TooManyRedirects` exception is raised.
        #: This defaults to requests.models.DEFAULT_REDIRECT_LIMIT, which is
        #: 30.
        self.max_redirects = DEFAULT_REDIRECT_LIMIT

        #: Trust environment settings for proxy configuration, default
        #: authentication and similar.
        self.trust_env = True

        #: A CookieJar containing all currently outstanding cookies set on this
        #: session. By default it is a
        #: :class:`RequestsCookieJar <requests.cookies.RequestsCookieJar>`, but
        #: may be any other ``cookielib.CookieJar`` compatible object.
        self.cookies = cookiejar_from_dict({***REMOVED******REMOVED***

        # Default connection adapters.
        self.adapters = OrderedDict(***REMOVED***
        self.mount('https://', HTTPAdapter(***REMOVED******REMOVED***
        self.mount('http://', HTTPAdapter(***REMOVED******REMOVED***

        # Only store 1000 redirects to prevent using infinite memory
        self.redirect_cache = RecentlyUsedContainer(REDIRECT_CACHE_SIZE***REMOVED***

    def __enter__(self***REMOVED***:
        return self

    def __exit__(self, *args***REMOVED***:
        self.close(***REMOVED***

    def prepare_request(self, request***REMOVED***:
        ***REMOVED***Constructs a :class:`PreparedRequest <PreparedRequest>` for
        transmission and returns it. The :class:`PreparedRequest` has settings
        merged from the :class:`Request <Request>` instance and those of the
        :class:`Session`.

        :param request: :class:`Request` instance to prepare with this
            session's settings.
        :rtype: requests.PreparedRequest
        ***REMOVED***
        cookies = request.cookies or {***REMOVED***

        # Bootstrap CookieJar.
        if not isinstance(cookies, cookielib.CookieJar***REMOVED***:
            cookies = cookiejar_from_dict(cookies***REMOVED***

        # Merge with session cookies
        merged_cookies = merge_cookies(
            merge_cookies(RequestsCookieJar(***REMOVED***, self.cookies***REMOVED***, cookies***REMOVED***

        # Set environment's basic authentication if not explicitly set.
        auth = request.auth
        if self.trust_env and not auth and not self.auth:
            auth = get_netrc_auth(request.url***REMOVED***

        p = PreparedRequest(***REMOVED***
        p.prepare(
            method=request.method.upper(***REMOVED***,
            url=request.url,
            files=request.files,
            data=request.data,
            json=request.json,
            headers=merge_setting(request.headers, self.headers, dict_class=CaseInsensitiveDict***REMOVED***,
            params=merge_setting(request.params, self.params***REMOVED***,
            auth=merge_setting(auth, self.auth***REMOVED***,
            cookies=merged_cookies,
            hooks=merge_hooks(request.hooks, self.hooks***REMOVED***,
        ***REMOVED***
        return p

    def request(self, method, url,
        params=None,
        data=None,
        headers=None,
        cookies=None,
        files=None,
        auth=None,
        timeout=None,
        allow_redirects=True,
        proxies=None,
        hooks=None,
        stream=None,
        verify=None,
        cert=None,
        json=None***REMOVED***:
        ***REMOVED***Constructs a :class:`Request <Request>`, prepares it and sends it.
        Returns :class:`Response <Response>` object.

        :param method: method for the new :class:`Request` object.
        :param url: URL for the new :class:`Request` object.
        :param params: (optional***REMOVED*** Dictionary or bytes to be sent in the query
            string for the :class:`Request`.
        :param data: (optional***REMOVED*** Dictionary, bytes, or file-like object to send
            in the body of the :class:`Request`.
        :param json: (optional***REMOVED*** json to send in the body of the
            :class:`Request`.
        :param headers: (optional***REMOVED*** Dictionary of HTTP Headers to send with the
            :class:`Request`.
        :param cookies: (optional***REMOVED*** Dict or CookieJar object to send with the
            :class:`Request`.
        :param files: (optional***REMOVED*** Dictionary of ``'filename': file-like-objects``
            for multipart encoding upload.
        :param auth: (optional***REMOVED*** Auth tuple or callable to enable
            Basic/Digest/Custom HTTP Auth.
        :param timeout: (optional***REMOVED*** How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout***REMOVED*** <timeouts>` tuple.
        :type timeout: float or tuple
        :param allow_redirects: (optional***REMOVED*** Set to True by default.
        :type allow_redirects: bool
        :param proxies: (optional***REMOVED*** Dictionary mapping protocol or protocol and
            hostname to the URL of the proxy.
        :param stream: (optional***REMOVED*** whether to immediately download the response
            content. Defaults to ``False``.
        :param verify: (optional***REMOVED*** whether the SSL cert will be verified.
            A CA_BUNDLE path can also be provided. Defaults to ``True``.
        :param cert: (optional***REMOVED*** if String, path to ssl client cert file (.pem***REMOVED***.
            If Tuple, ('cert', 'key'***REMOVED*** pair.
        :rtype: requests.Response
        ***REMOVED***
        # Create the Request.
        req = Request(
            method = method.upper(***REMOVED***,
            url = url,
            headers = headers,
            files = files,
            data = data or {***REMOVED***,
            json = json,
            params = params or {***REMOVED***,
            auth = auth,
            cookies = cookies,
            hooks = hooks,
        ***REMOVED***
        prep = self.prepare_request(req***REMOVED***

        proxies = proxies or {***REMOVED***

        settings = self.merge_environment_settings(
            prep.url, proxies, stream, verify, cert
        ***REMOVED***

        # Send the request.
        send_kwargs = {
            'timeout': timeout,
            'allow_redirects': allow_redirects,
    ***REMOVED***
        send_kwargs.update(settings***REMOVED***
        resp = self.send(prep, **send_kwargs***REMOVED***

        return resp

    def get(self, url, **kwargs***REMOVED***:
        ***REMOVED***Sends a GET request. Returns :class:`Response` object.

        :param url: URL for the new :class:`Request` object.
        :param \*\*kwargs: Optional arguments that ``request`` takes.
        :rtype: requests.Response
        ***REMOVED***

        kwargs.setdefault('allow_redirects', True***REMOVED***
        return self.request('GET', url, **kwargs***REMOVED***

    def options(self, url, **kwargs***REMOVED***:
        ***REMOVED***Sends a OPTIONS request. Returns :class:`Response` object.

        :param url: URL for the new :class:`Request` object.
        :param \*\*kwargs: Optional arguments that ``request`` takes.
        :rtype: requests.Response
        ***REMOVED***

        kwargs.setdefault('allow_redirects', True***REMOVED***
        return self.request('OPTIONS', url, **kwargs***REMOVED***

    def head(self, url, **kwargs***REMOVED***:
        ***REMOVED***Sends a HEAD request. Returns :class:`Response` object.

        :param url: URL for the new :class:`Request` object.
        :param \*\*kwargs: Optional arguments that ``request`` takes.
        :rtype: requests.Response
        ***REMOVED***

        kwargs.setdefault('allow_redirects', False***REMOVED***
        return self.request('HEAD', url, **kwargs***REMOVED***

    def post(self, url, data=None, json=None, **kwargs***REMOVED***:
        ***REMOVED***Sends a POST request. Returns :class:`Response` object.

        :param url: URL for the new :class:`Request` object.
        :param data: (optional***REMOVED*** Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.
        :param json: (optional***REMOVED*** json to send in the body of the :class:`Request`.
        :param \*\*kwargs: Optional arguments that ``request`` takes.
        :rtype: requests.Response
        ***REMOVED***

        return self.request('POST', url, data=data, json=json, **kwargs***REMOVED***

    def put(self, url, data=None, **kwargs***REMOVED***:
        ***REMOVED***Sends a PUT request. Returns :class:`Response` object.

        :param url: URL for the new :class:`Request` object.
        :param data: (optional***REMOVED*** Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.
        :param \*\*kwargs: Optional arguments that ``request`` takes.
        :rtype: requests.Response
        ***REMOVED***

        return self.request('PUT', url, data=data, **kwargs***REMOVED***

    def patch(self, url, data=None, **kwargs***REMOVED***:
        ***REMOVED***Sends a PATCH request. Returns :class:`Response` object.

        :param url: URL for the new :class:`Request` object.
        :param data: (optional***REMOVED*** Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.
        :param \*\*kwargs: Optional arguments that ``request`` takes.
        :rtype: requests.Response
        ***REMOVED***

        return self.request('PATCH', url,  data=data, **kwargs***REMOVED***

    def delete(self, url, **kwargs***REMOVED***:
        ***REMOVED***Sends a DELETE request. Returns :class:`Response` object.

        :param url: URL for the new :class:`Request` object.
        :param \*\*kwargs: Optional arguments that ``request`` takes.
        :rtype: requests.Response
        ***REMOVED***

        return self.request('DELETE', url, **kwargs***REMOVED***

    def send(self, request, **kwargs***REMOVED***:
        ***REMOVED***
        Send a given PreparedRequest.

        :rtype: requests.Response
        ***REMOVED***
        # Set defaults that the hooks can utilize to ensure they always have
        # the correct parameters to reproduce the previous request.
        kwargs.setdefault('stream', self.stream***REMOVED***
        kwargs.setdefault('verify', self.verify***REMOVED***
        kwargs.setdefault('cert', self.cert***REMOVED***
        kwargs.setdefault('proxies', self.proxies***REMOVED***

        # It's possible that users might accidentally send a Request object.
        # Guard against that specific failure case.
        if isinstance(request, Request***REMOVED***:
            raise ValueError('You can only send PreparedRequests.'***REMOVED***

        # Set up variables needed for resolve_redirects and dispatching of hooks
        allow_redirects = kwargs.pop('allow_redirects', True***REMOVED***
        stream = kwargs.get('stream'***REMOVED***
        hooks = request.hooks

        # Resolve URL in redirect cache, if available.
        if allow_redirects:
            checked_urls = set(***REMOVED***
            while request.url in self.redirect_cache:
                checked_urls.add(request.url***REMOVED***
                new_url = self.redirect_cache.get(request.url***REMOVED***
                if new_url in checked_urls:
                    break
                request.url = new_url

        # Get the appropriate adapter to use
        adapter = self.get_adapter(url=request.url***REMOVED***

        # Start time (approximately***REMOVED*** of the request
        start = datetime.utcnow(***REMOVED***

        # Send the request
        r = adapter.send(request, **kwargs***REMOVED***

        # Total elapsed time of the request (approximately***REMOVED***
        r.elapsed = datetime.utcnow(***REMOVED*** - start

        # Response manipulation hooks
        r = dispatch_hook('response', hooks, r, **kwargs***REMOVED***

        # Persist cookies
        if r.history:

            # If the hooks create history then we want those cookies too
            for resp in r.history:
                extract_cookies_to_jar(self.cookies, resp.request, resp.raw***REMOVED***

        extract_cookies_to_jar(self.cookies, request, r.raw***REMOVED***

        # Redirect resolving generator.
        gen = self.resolve_redirects(r, request, **kwargs***REMOVED***

        # Resolve redirects if allowed.
        history = [resp for resp in gen***REMOVED*** if allow_redirects else [***REMOVED***

        # Shuffle things around if there's history.
        if history:
            # Insert the first (original***REMOVED*** request at the start
            history.insert(0, r***REMOVED***
            # Get the last request made
            r = history.pop(***REMOVED***
            r.history = history

        if not stream:
            r.content

        return r

    def merge_environment_settings(self, url, proxies, stream, verify, cert***REMOVED***:
        ***REMOVED***
        Check the environment and merge it with some settings.

        :rtype: dict
        ***REMOVED***
        # Gather clues from the surrounding environment.
        if self.trust_env:
            # Set environment's proxies.
            env_proxies = get_environ_proxies(url***REMOVED*** or {***REMOVED***
            for (k, v***REMOVED*** in env_proxies.items(***REMOVED***:
                proxies.setdefault(k, v***REMOVED***

            # Look for requests environment configuration and be compatible
            # with cURL.
            if verify is True or verify is None:
                verify = (os.environ.get('REQUESTS_CA_BUNDLE'***REMOVED*** or
                          os.environ.get('CURL_CA_BUNDLE'***REMOVED******REMOVED***

        # Merge all the kwargs.
        proxies = merge_setting(proxies, self.proxies***REMOVED***
        stream = merge_setting(stream, self.stream***REMOVED***
        verify = merge_setting(verify, self.verify***REMOVED***
        cert = merge_setting(cert, self.cert***REMOVED***

        return {'verify': verify, 'proxies': proxies, 'stream': stream,
                'cert': cert***REMOVED***

    def get_adapter(self, url***REMOVED***:
        ***REMOVED***
        Returns the appropriate connection adapter for the given URL.

        :rtype: requests.adapters.BaseAdapter
        ***REMOVED***
        for (prefix, adapter***REMOVED*** in self.adapters.items(***REMOVED***:

            if url.lower(***REMOVED***.startswith(prefix***REMOVED***:
                return adapter

        # Nothing matches :-/
        raise InvalidSchema("No connection adapters were found for '%s'" % url***REMOVED***

    def close(self***REMOVED***:
        ***REMOVED***Closes all adapters and as such the session***REMOVED***
        for v in self.adapters.values(***REMOVED***:
            v.close(***REMOVED***

    def mount(self, prefix, adapter***REMOVED***:
        ***REMOVED***Registers a connection adapter to a prefix.

        Adapters are sorted in descending order by key length.
        ***REMOVED***
        self.adapters[prefix***REMOVED*** = adapter
        keys_to_move = [k for k in self.adapters if len(k***REMOVED*** < len(prefix***REMOVED******REMOVED***

        for key in keys_to_move:
            self.adapters[key***REMOVED*** = self.adapters.pop(key***REMOVED***

    def __getstate__(self***REMOVED***:
        state = dict((attr, getattr(self, attr, None***REMOVED******REMOVED*** for attr in self.__attrs__***REMOVED***
        state['redirect_cache'***REMOVED*** = dict(self.redirect_cache***REMOVED***
        return state

    def __setstate__(self, state***REMOVED***:
        redirect_cache = state.pop('redirect_cache', {***REMOVED******REMOVED***
        for attr, value in state.items(***REMOVED***:
            setattr(self, attr, value***REMOVED***

        self.redirect_cache = RecentlyUsedContainer(REDIRECT_CACHE_SIZE***REMOVED***
        for redirect, to in redirect_cache.items(***REMOVED***:
            self.redirect_cache[redirect***REMOVED*** = to


def session(***REMOVED***:
    ***REMOVED***
    Returns a :class:`Session` for context-management.

    :rtype: Session
    ***REMOVED***

    return Session(***REMOVED***
