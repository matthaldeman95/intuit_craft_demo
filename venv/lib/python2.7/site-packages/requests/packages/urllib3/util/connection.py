from __future__ import absolute_import
import socket
***REMOVED***
    from select import poll, POLLIN
except ImportError:  # `poll` doesn't exist on OSX and other platforms
    poll = False
    ***REMOVED***
        from select import select
    except ImportError:  # `select` doesn't exist on AppEngine.
        select = False


def is_connection_dropped(conn***REMOVED***:  # Platform-specific
    ***REMOVED***
    Returns True if the connection is dropped and should be closed.

    :param conn:
        :class:`httplib.HTTPConnection` object.

    Note: For platforms like AppEngine, this will always return ``False`` to
    let the platform handle connection recycling transparently for us.
    ***REMOVED***
    sock = getattr(conn, 'sock', False***REMOVED***
    if sock is False:  # Platform-specific: AppEngine
        return False
    if sock is None:  # Connection already closed (such as by httplib***REMOVED***.
        return True

    if not poll:
        if not select:  # Platform-specific: AppEngine
            return False

        ***REMOVED***
            return select([sock***REMOVED***, [***REMOVED***, [***REMOVED***, 0.0***REMOVED***[0***REMOVED***
        except socket.error:
            return True

    # This version is better on platforms that support it.
    p = poll(***REMOVED***
    p.register(sock, POLLIN***REMOVED***
    for (fno, ev***REMOVED*** in p.poll(0.0***REMOVED***:
        if fno == sock.fileno(***REMOVED***:
            # Either data is buffered (bad***REMOVED***, or the connection is dropped.
            return True


# This function is copied from socket.py in the Python 2.7 standard
# library test suite. Added to its signature is only `socket_options`.
# One additional modification is that we avoid binding to IPv6 servers
# discovered in DNS if the system doesn't have IPv6 functionality.
def create_connection(address, timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
                      source_address=None, socket_options=None***REMOVED***:
    ***REMOVED***Connect to *address* and return the socket object.

    Convenience function.  Connect to *address* (a 2-tuple ``(host,
    port***REMOVED***``***REMOVED*** and return the socket object.  Passing the optional
    *timeout* parameter will set the timeout on the socket instance
    before attempting to connect.  If no *timeout* is supplied, the
    global default timeout setting returned by :func:`getdefaulttimeout`
    is used.  If *source_address* is set it must be a tuple of (host, port***REMOVED***
    for the socket to bind as a source address before making the connection.
    An host of '' or port 0 tells the OS to use the default.
    ***REMOVED***

    host, port = address
    if host.startswith('['***REMOVED***:
        host = host.strip('[***REMOVED***'***REMOVED***
    err = None

    # Using the value from allowed_gai_family(***REMOVED*** in the context of getaddrinfo lets
    # us select whether to work with IPv4 DNS records, IPv6 records, or both.
    # The original create_connection function always returns all records.
    family = allowed_gai_family(***REMOVED***

    for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM***REMOVED***:
        af, socktype, proto, canonname, sa = res
        sock = None
        ***REMOVED***
            sock = socket.socket(af, socktype, proto***REMOVED***

            # If provided, set socket level options before connecting.
            _set_socket_options(sock, socket_options***REMOVED***

            if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                sock.settimeout(timeout***REMOVED***
            if source_address:
                sock.bind(source_address***REMOVED***
            sock.connect(sa***REMOVED***
            return sock

        except socket.error as e:
            err = e
            if sock is not None:
                sock.close(***REMOVED***
                sock = None

    if err is not None:
        raise err

    raise socket.error("getaddrinfo returns an empty list"***REMOVED***


def _set_socket_options(sock, options***REMOVED***:
    if options is None:
        return

    for opt in options:
        sock.setsockopt(*opt***REMOVED***


def allowed_gai_family(***REMOVED***:
    ***REMOVED***This function is designed to work in the context of
    getaddrinfo, where family=socket.AF_UNSPEC is the default and
    will perform a DNS search for both IPv6 and IPv4 records.***REMOVED***

    family = socket.AF_INET
    if HAS_IPV6:
        family = socket.AF_UNSPEC
    return family


def _has_ipv6(host***REMOVED***:
    ***REMOVED*** Returns True if the system can bind an IPv6 address. ***REMOVED***
    sock = None
    has_ipv6 = False

    if socket.has_ipv6:
        # has_ipv6 returns true if cPython was compiled with IPv6 support.
        # It does not tell us if the system has IPv6 support enabled. To
        # determine that we must bind to an IPv6 address.
        # https://github.com/shazow/urllib3/pull/611
        # https://bugs.python.org/issue658327
        ***REMOVED***
            sock = socket.socket(socket.AF_INET6***REMOVED***
            sock.bind((host, 0***REMOVED******REMOVED***
            has_ipv6 = True
        except Exception:
            pass

    if sock:
        sock.close(***REMOVED***
    return has_ipv6

HAS_IPV6 = _has_ipv6('::1'***REMOVED***
