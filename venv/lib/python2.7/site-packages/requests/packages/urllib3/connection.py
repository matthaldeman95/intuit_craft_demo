from __future__ import absolute_import
import datetime
import logging
***REMOVED***
import sys
import socket
from socket import error as SocketError, timeout as SocketTimeout
import warnings
from .packages import six

***REMOVED***  # Python 3
    from http.client import HTTPConnection as _HTTPConnection
    from http.client import HTTPException  # noqa: unused in this module
except ImportError:
    from httplib import HTTPConnection as _HTTPConnection
    from httplib import HTTPException  # noqa: unused in this module

***REMOVED***  # Compiled with SSL?
    import ssl
    BaseSSLError = ssl.SSLError
except (ImportError, AttributeError***REMOVED***:  # Platform-specific: No SSL.
    ssl = None

    class BaseSSLError(BaseException***REMOVED***:
        pass


***REMOVED***  # Python 3:
    # Not a no-op, we're adding this to the namespace so it can be imported.
    ConnectionError = ConnectionError
except NameError:  # Python 2:
    class ConnectionError(Exception***REMOVED***:
        pass


from .exceptions import (
    NewConnectionError,
    ConnectTimeoutError,
    SubjectAltNameWarning,
    SystemTimeWarning,
***REMOVED***
from .packages.ssl_match_hostname import match_hostname, CertificateError

from .util.ssl_ import (
    resolve_cert_reqs,
    resolve_ssl_version,
    ssl_wrap_socket,
    assert_fingerprint,
***REMOVED***


from .util import connection

from ._collections import HTTPHeaderDict

log = logging.getLogger(__name__***REMOVED***

port_by_scheme = {
    'http': 80,
    'https': 443,
***REMOVED***

RECENT_DATE = datetime.date(2014, 1, 1***REMOVED***


class DummyConnection(object***REMOVED***:
    ***REMOVED***Used to detect a failed ConnectionCls import.***REMOVED***
    pass


class HTTPConnection(_HTTPConnection, object***REMOVED***:
    ***REMOVED***
    Based on httplib.HTTPConnection but provides an extra constructor
    backwards-compatibility layer between older and newer Pythons.

    Additional keyword parameters are used to configure attributes of the connection.
    Accepted parameters include:

      - ``strict``: See the documentation on :class:`urllib3.connectionpool.HTTPConnectionPool`
      - ``source_address``: Set the source address for the current connection.

        .. note:: This is ignored for Python 2.6. It is only applied for 2.7 and 3.x

      - ``socket_options``: Set specific options on the underlying socket. If not specified, then
        defaults are loaded from ``HTTPConnection.default_socket_options`` which includes disabling
        Nagle's algorithm (sets TCP_NODELAY to 1***REMOVED*** unless the connection is behind a proxy.

        For example, if you wish to enable TCP Keep Alive in addition to the defaults,
        you might pass::

            HTTPConnection.default_socket_options + [
                (socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1***REMOVED***,
            ***REMOVED***

        Or you may want to disable the defaults by passing an empty list (e.g., ``[***REMOVED***``***REMOVED***.
    ***REMOVED***

    default_port = port_by_scheme['http'***REMOVED***

    #: Disable Nagle's algorithm by default.
    #: ``[(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1***REMOVED******REMOVED***``
    default_socket_options = [(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1***REMOVED******REMOVED***

    #: Whether this connection verifies the host's certificate.
    is_verified = False

    def __init__(self, *args, **kw***REMOVED***:
        if six.PY3:  # Python 3
            kw.pop('strict', None***REMOVED***

        # Pre-set source_address in case we have an older Python like 2.6.
        self.source_address = kw.get('source_address'***REMOVED***

        if sys.version_info < (2, 7***REMOVED***:  # Python 2.6
            # _HTTPConnection on Python 2.6 will balk at this keyword arg, but
            # not newer versions. We can still use it when creating a
            # connection though, so we pop it *after* we have saved it as
            # self.source_address.
            kw.pop('source_address', None***REMOVED***

        #: The socket options provided by the user. If no options are
        #: provided, we use the default options.
        self.socket_options = kw.pop('socket_options', self.default_socket_options***REMOVED***

        # Superclass also sets self.source_address in Python 2.7+.
        _HTTPConnection.__init__(self, *args, **kw***REMOVED***

    def _new_conn(self***REMOVED***:
        ***REMOVED*** Establish a socket connection and set nodelay settings on it.

        :return: New socket connection.
        ***REMOVED***
        extra_kw = {***REMOVED***
        if self.source_address:
            extra_kw['source_address'***REMOVED*** = self.source_address

        if self.socket_options:
            extra_kw['socket_options'***REMOVED*** = self.socket_options

        ***REMOVED***
            conn = connection.create_connection(
                (self.host, self.port***REMOVED***, self.timeout, **extra_kw***REMOVED***

        except SocketTimeout as e:
            raise ConnectTimeoutError(
                self, "Connection to %s timed out. (connect timeout=%s***REMOVED***" %
                (self.host, self.timeout***REMOVED******REMOVED***

        except SocketError as e:
            raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e***REMOVED***

        return conn

    def _prepare_conn(self, conn***REMOVED***:
        self.sock = conn
        # the _tunnel_host attribute was added in python 2.6.3 (via
        # http://hg.python.org/cpython/rev/0f57b30a152f***REMOVED*** so pythons 2.6(0-2***REMOVED*** do
        # not have them.
        if getattr(self, '_tunnel_host', None***REMOVED***:
            # TODO: Fix tunnel so it doesn't depend on self.sock state.
            self._tunnel(***REMOVED***
            # Mark this connection as not reusable
            self.auto_open = 0

    def connect(self***REMOVED***:
        conn = self._new_conn(***REMOVED***
        self._prepare_conn(conn***REMOVED***

    def request_chunked(self, method, url, body=None, headers=None***REMOVED***:
        ***REMOVED***
        Alternative to the common request method, which sends the
        body with chunked encoding and not as one block
        ***REMOVED***
        headers = HTTPHeaderDict(headers if headers is not None else {***REMOVED******REMOVED***
        skip_accept_encoding = 'accept-encoding' in headers
        self.putrequest(method, url, skip_accept_encoding=skip_accept_encoding***REMOVED***
        for header, value in headers.items(***REMOVED***:
            self.putheader(header, value***REMOVED***
        if 'transfer-encoding' not in headers:
            self.putheader('Transfer-Encoding', 'chunked'***REMOVED***
        self.endheaders(***REMOVED***

        if body is not None:
            stringish_types = six.string_types + (six.binary_type,***REMOVED***
            if isinstance(body, stringish_types***REMOVED***:
                body = (body,***REMOVED***
            for chunk in body:
                if not chunk:
                    continue
                if not isinstance(chunk, six.binary_type***REMOVED***:
                    chunk = chunk.encode('utf8'***REMOVED***
                len_str = hex(len(chunk***REMOVED******REMOVED***[2:***REMOVED***
                self.send(len_str.encode('utf-8'***REMOVED******REMOVED***
                self.send(b'\r\n'***REMOVED***
                self.send(chunk***REMOVED***
                self.send(b'\r\n'***REMOVED***

        # After the if clause, to always have a closed body
        self.send(b'0\r\n\r\n'***REMOVED***


class HTTPSConnection(HTTPConnection***REMOVED***:
    default_port = port_by_scheme['https'***REMOVED***

    def __init__(self, host, port=None, key_file=None, cert_file=None,
                 strict=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT, **kw***REMOVED***:

        HTTPConnection.__init__(self, host, port, strict=strict,
                                timeout=timeout, **kw***REMOVED***

        self.key_file = key_file
        self.cert_file = cert_file

        # Required property for Google AppEngine 1.9.0 which otherwise causes
        # HTTPS requests to go out as HTTP. (See Issue #356***REMOVED***
        self._protocol = 'https'

    def connect(self***REMOVED***:
        conn = self._new_conn(***REMOVED***
        self._prepare_conn(conn***REMOVED***
        self.sock = ssl.wrap_socket(conn, self.key_file, self.cert_file***REMOVED***


class VerifiedHTTPSConnection(HTTPSConnection***REMOVED***:
    ***REMOVED***
    Based on httplib.HTTPSConnection but wraps the socket with
    SSL certification.
    ***REMOVED***
    cert_reqs = None
    ca_certs = None
    ca_cert_dir = None
    ssl_version = None
    assert_fingerprint = None

    def set_cert(self, key_file=None, cert_file=None,
                 cert_reqs=None, ca_certs=None,
                 assert_hostname=None, assert_fingerprint=None,
                 ca_cert_dir=None***REMOVED***:

        if (ca_certs or ca_cert_dir***REMOVED*** and cert_reqs is None:
            cert_reqs = 'CERT_REQUIRED'

        self.key_file = key_file
        self.cert_file = cert_file
        self.cert_reqs = cert_reqs
        self.assert_hostname = assert_hostname
        self.assert_fingerprint = assert_fingerprint
        self.ca_certs = ca_certs and os.path.expanduser(ca_certs***REMOVED***
        self.ca_cert_dir = ca_cert_dir and os.path.expanduser(ca_cert_dir***REMOVED***

    def connect(self***REMOVED***:
        # Add certificate verification
        conn = self._new_conn(***REMOVED***

        resolved_cert_reqs = resolve_cert_reqs(self.cert_reqs***REMOVED***
        resolved_ssl_version = resolve_ssl_version(self.ssl_version***REMOVED***

        hostname = self.host
        if getattr(self, '_tunnel_host', None***REMOVED***:
            # _tunnel_host was added in Python 2.6.3
            # (See: http://hg.python.org/cpython/rev/0f57b30a152f***REMOVED***

            self.sock = conn
            # Calls self._set_hostport(***REMOVED***, so self.host is
            # self._tunnel_host below.
            self._tunnel(***REMOVED***
            # Mark this connection as not reusable
            self.auto_open = 0

            # Override the host with the one we're requesting data from.
            hostname = self._tunnel_host

        is_time_off = datetime.date.today(***REMOVED*** < RECENT_DATE
        if is_time_off:
            warnings.warn((
                'System time is way off (before {0***REMOVED******REMOVED***. This will probably '
                'lead to SSL verification errors'***REMOVED***.format(RECENT_DATE***REMOVED***,
                SystemTimeWarning
            ***REMOVED***

        # Wrap socket using verification with the root certs in
        # trusted_root_certs
        self.sock = ssl_wrap_socket(conn, self.key_file, self.cert_file,
                                    cert_reqs=resolved_cert_reqs,
                                    ca_certs=self.ca_certs,
                                    ca_cert_dir=self.ca_cert_dir,
                                    server_hostname=hostname,
                                    ssl_version=resolved_ssl_version***REMOVED***

        if self.assert_fingerprint:
            assert_fingerprint(self.sock.getpeercert(binary_form=True***REMOVED***,
                               self.assert_fingerprint***REMOVED***
        elif resolved_cert_reqs != ssl.CERT_NONE \
                and self.assert_hostname is not False:
            cert = self.sock.getpeercert(***REMOVED***
            if not cert.get('subjectAltName', (***REMOVED******REMOVED***:
                warnings.warn((
                    'Certificate for {0***REMOVED*** has no `subjectAltName`, falling back to check for a '
                    '`commonName` for now. This feature is being removed by major browsers and '
                    'deprecated by RFC 2818. (See https://github.com/shazow/urllib3/issues/497 '
                    'for details.***REMOVED***'.format(hostname***REMOVED******REMOVED***,
                    SubjectAltNameWarning
                ***REMOVED***
            _match_hostname(cert, self.assert_hostname or hostname***REMOVED***

        self.is_verified = (resolved_cert_reqs == ssl.CERT_REQUIRED or
                            self.assert_fingerprint is not None***REMOVED***


def _match_hostname(cert, asserted_hostname***REMOVED***:
    ***REMOVED***
        match_hostname(cert, asserted_hostname***REMOVED***
    except CertificateError as e:
        log.error(
            'Certificate did not match expected hostname: %s. '
            'Certificate: %s', asserted_hostname, cert
        ***REMOVED***
        # Add cert to exception and reraise so client code can inspect
        # the cert when catching the exception, if they want to
        e._peer_cert = cert
        raise


if ssl:
    # Make a copy for testing.
    UnverifiedHTTPSConnection = HTTPSConnection
    HTTPSConnection = VerifiedHTTPSConnection
else:
    HTTPSConnection = DummyConnection
