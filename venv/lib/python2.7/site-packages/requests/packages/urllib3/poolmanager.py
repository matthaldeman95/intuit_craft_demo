from __future__ import absolute_import
import collections
import functools
import logging

***REMOVED***  # Python 3
    from urllib.parse import urljoin
except ImportError:
    from urlparse import urljoin

from ._collections import RecentlyUsedContainer
from .connectionpool import HTTPConnectionPool, HTTPSConnectionPool
from .connectionpool import port_by_scheme
from .exceptions import LocationValueError, MaxRetryError, ProxySchemeUnknown
from .request import RequestMethods
from .util.url import parse_url
from .util.retry import Retry


__all__ = ['PoolManager', 'ProxyManager', 'proxy_from_url'***REMOVED***


log = logging.getLogger(__name__***REMOVED***

SSL_KEYWORDS = ('key_file', 'cert_file', 'cert_reqs', 'ca_certs',
                'ssl_version', 'ca_cert_dir'***REMOVED***

# The base fields to use when determining what pool to get a connection from;
# these do not rely on the ``connection_pool_kw`` and can be determined by the
# URL and potentially the ``urllib3.connection.port_by_scheme`` dictionary.
#
# All custom key schemes should include the fields in this key at a minimum.
BasePoolKey = collections.namedtuple('BasePoolKey', ('scheme', 'host', 'port'***REMOVED******REMOVED***

# The fields to use when determining what pool to get a HTTP and HTTPS
# connection from. All additional fields must be present in the PoolManager's
# ``connection_pool_kw`` instance variable.
HTTPPoolKey = collections.namedtuple(
    'HTTPPoolKey', BasePoolKey._fields + ('timeout', 'retries', 'strict',
                                          'block', 'source_address'***REMOVED***
***REMOVED***
HTTPSPoolKey = collections.namedtuple(
    'HTTPSPoolKey', HTTPPoolKey._fields + SSL_KEYWORDS
***REMOVED***


def _default_key_normalizer(key_class, request_context***REMOVED***:
    ***REMOVED***
    Create a pool key of type ``key_class`` for a request.

    According to RFC 3986, both the scheme and host are case-insensitive.
    Therefore, this function normalizes both before constructing the pool
    key for an HTTPS request. If you wish to change this behaviour, provide
    alternate callables to ``key_fn_by_scheme``.

    :param key_class:
        The class to use when constructing the key. This should be a namedtuple
        with the ``scheme`` and ``host`` keys at a minimum.

    :param request_context:
        A dictionary-like object that contain the context for a request.
        It should contain a key for each field in the :class:`HTTPPoolKey`
    ***REMOVED***
    context = {***REMOVED***
    for key in key_class._fields:
        context[key***REMOVED*** = request_context.get(key***REMOVED***
    context['scheme'***REMOVED*** = context['scheme'***REMOVED***.lower(***REMOVED***
    context['host'***REMOVED*** = context['host'***REMOVED***.lower(***REMOVED***
    return key_class(**context***REMOVED***


# A dictionary that maps a scheme to a callable that creates a pool key.
# This can be used to alter the way pool keys are constructed, if desired.
# Each PoolManager makes a copy of this dictionary so they can be configured
# globally here, or individually on the instance.
key_fn_by_scheme = {
    'http': functools.partial(_default_key_normalizer, HTTPPoolKey***REMOVED***,
    'https': functools.partial(_default_key_normalizer, HTTPSPoolKey***REMOVED***,
***REMOVED***

pool_classes_by_scheme = {
    'http': HTTPConnectionPool,
    'https': HTTPSConnectionPool,
***REMOVED***


class PoolManager(RequestMethods***REMOVED***:
    ***REMOVED***
    Allows for arbitrary requests while transparently keeping track of
    necessary connection pools for you.

    :param num_pools:
        Number of connection pools to cache before discarding the least
        recently used pool.

    :param headers:
        Headers to include with all requests, unless other headers are given
        explicitly.

    :param \**connection_pool_kw:
        Additional parameters are used to create fresh
        :class:`urllib3.connectionpool.ConnectionPool` instances.

    Example::

        >>> manager = PoolManager(num_pools=2***REMOVED***
        >>> r = manager.request('GET', 'http://google.com/'***REMOVED***
        >>> r = manager.request('GET', 'http://google.com/mail'***REMOVED***
        >>> r = manager.request('GET', 'http://yahoo.com/'***REMOVED***
        >>> len(manager.pools***REMOVED***
        2

    ***REMOVED***

    proxy = None

    def __init__(self, num_pools=10, headers=None, **connection_pool_kw***REMOVED***:
        RequestMethods.__init__(self, headers***REMOVED***
        self.connection_pool_kw = connection_pool_kw
        self.pools = RecentlyUsedContainer(num_pools,
                                           dispose_func=lambda p: p.close(***REMOVED******REMOVED***

        # Locally set the pool classes and keys so other PoolManagers can
        # override them.
        self.pool_classes_by_scheme = pool_classes_by_scheme
        self.key_fn_by_scheme = key_fn_by_scheme.copy(***REMOVED***

    def __enter__(self***REMOVED***:
        return self

    def __exit__(self, exc_type, exc_val, exc_tb***REMOVED***:
        self.clear(***REMOVED***
        # Return False to re-raise any potential exceptions
        return False

    def _new_pool(self, scheme, host, port***REMOVED***:
        ***REMOVED***
        Create a new :class:`ConnectionPool` based on host, port and scheme.

        This method is used to actually create the connection pools handed out
        by :meth:`connection_from_url` and companion methods. It is intended
        to be overridden for customization.
        ***REMOVED***
        pool_cls = self.pool_classes_by_scheme[scheme***REMOVED***
        kwargs = self.connection_pool_kw
        if scheme == 'http':
            kwargs = self.connection_pool_kw.copy(***REMOVED***
            for kw in SSL_KEYWORDS:
                kwargs.pop(kw, None***REMOVED***

        return pool_cls(host, port, **kwargs***REMOVED***

    def clear(self***REMOVED***:
        ***REMOVED***
        Empty our store of pools and direct them all to close.

        This will not affect in-flight connections, but they will not be
        re-used after completion.
        ***REMOVED***
        self.pools.clear(***REMOVED***

    def connection_from_host(self, host, port=None, scheme='http'***REMOVED***:
        ***REMOVED***
        Get a :class:`ConnectionPool` based on the host, port, and scheme.

        If ``port`` isn't given, it will be derived from the ``scheme`` using
        ``urllib3.connectionpool.port_by_scheme``.
        ***REMOVED***

        if not host:
            raise LocationValueError("No host specified."***REMOVED***

        request_context = self.connection_pool_kw.copy(***REMOVED***
        request_context['scheme'***REMOVED*** = scheme or 'http'
        if not port:
            port = port_by_scheme.get(request_context['scheme'***REMOVED***.lower(***REMOVED***, 80***REMOVED***
        request_context['port'***REMOVED*** = port
        request_context['host'***REMOVED*** = host

        return self.connection_from_context(request_context***REMOVED***

    def connection_from_context(self, request_context***REMOVED***:
        ***REMOVED***
        Get a :class:`ConnectionPool` based on the request context.

        ``request_context`` must at least contain the ``scheme`` key and its
        value must be a key in ``key_fn_by_scheme`` instance variable.
        ***REMOVED***
        scheme = request_context['scheme'***REMOVED***.lower(***REMOVED***
        pool_key_constructor = self.key_fn_by_scheme[scheme***REMOVED***
        pool_key = pool_key_constructor(request_context***REMOVED***

        return self.connection_from_pool_key(pool_key***REMOVED***

    def connection_from_pool_key(self, pool_key***REMOVED***:
        ***REMOVED***
        Get a :class:`ConnectionPool` based on the provided pool key.

        ``pool_key`` should be a namedtuple that only contains immutable
        objects. At a minimum it must have the ``scheme``, ``host``, and
        ``port`` fields.
        ***REMOVED***
        with self.pools.lock:
            # If the scheme, host, or port doesn't match existing open
            # connections, open a new ConnectionPool.
            pool = self.pools.get(pool_key***REMOVED***
            if pool:
                return pool

            # Make a fresh ConnectionPool of the desired type
            pool = self._new_pool(pool_key.scheme, pool_key.host, pool_key.port***REMOVED***
            self.pools[pool_key***REMOVED*** = pool

        return pool

    def connection_from_url(self, url***REMOVED***:
        ***REMOVED***
        Similar to :func:`urllib3.connectionpool.connection_from_url` but
        doesn't pass any additional parameters to the
        :class:`urllib3.connectionpool.ConnectionPool` constructor.

        Additional parameters are taken from the :class:`.PoolManager`
        constructor.
        ***REMOVED***
        u = parse_url(url***REMOVED***
        return self.connection_from_host(u.host, port=u.port, scheme=u.scheme***REMOVED***

    def urlopen(self, method, url, redirect=True, **kw***REMOVED***:
        ***REMOVED***
        Same as :meth:`urllib3.connectionpool.HTTPConnectionPool.urlopen`
        with custom cross-host redirect logic and only sends the request-uri
        portion of the ``url``.

        The given ``url`` parameter must be absolute, such that an appropriate
        :class:`urllib3.connectionpool.ConnectionPool` can be chosen for it.
        ***REMOVED***
        u = parse_url(url***REMOVED***
        conn = self.connection_from_host(u.host, port=u.port, scheme=u.scheme***REMOVED***

        kw['assert_same_host'***REMOVED*** = False
        kw['redirect'***REMOVED*** = False
        if 'headers' not in kw:
            kw['headers'***REMOVED*** = self.headers

        if self.proxy is not None and u.scheme == "http":
            response = conn.urlopen(method, url, **kw***REMOVED***
        else:
            response = conn.urlopen(method, u.request_uri, **kw***REMOVED***

        redirect_location = redirect and response.get_redirect_location(***REMOVED***
        if not redirect_location:
            return response

        # Support relative URLs for redirecting.
        redirect_location = urljoin(url, redirect_location***REMOVED***

        # RFC 7231, Section 6.4.4
        if response.status == 303:
            method = 'GET'

        retries = kw.get('retries'***REMOVED***
        if not isinstance(retries, Retry***REMOVED***:
            retries = Retry.from_int(retries, redirect=redirect***REMOVED***

        ***REMOVED***
            retries = retries.increment(method, url, response=response, _pool=conn***REMOVED***
        except MaxRetryError:
            if retries.raise_on_redirect:
                raise
            return response

        kw['retries'***REMOVED*** = retries
        kw['redirect'***REMOVED*** = redirect

        log.info("Redirecting %s -> %s", url, redirect_location***REMOVED***
        return self.urlopen(method, redirect_location, **kw***REMOVED***


class ProxyManager(PoolManager***REMOVED***:
    ***REMOVED***
    Behaves just like :class:`PoolManager`, but sends all requests through
    the defined proxy, using the CONNECT method for HTTPS URLs.

    :param proxy_url:
        The URL of the proxy to be used.

    :param proxy_headers:
        A dictionary contaning headers that will be sent to the proxy. In case
        of HTTP they are being sent with each request, while in the
        HTTPS/CONNECT case they are sent only once. Could be used for proxy
        authentication.

    Example:
        >>> proxy = urllib3.ProxyManager('http://localhost:3128/'***REMOVED***
        >>> r1 = proxy.request('GET', 'http://google.com/'***REMOVED***
        >>> r2 = proxy.request('GET', 'http://httpbin.org/'***REMOVED***
        >>> len(proxy.pools***REMOVED***
        1
        >>> r3 = proxy.request('GET', 'https://httpbin.org/'***REMOVED***
        >>> r4 = proxy.request('GET', 'https://twitter.com/'***REMOVED***
        >>> len(proxy.pools***REMOVED***
        3

    ***REMOVED***

    def __init__(self, proxy_url, num_pools=10, headers=None,
                 proxy_headers=None, **connection_pool_kw***REMOVED***:

        if isinstance(proxy_url, HTTPConnectionPool***REMOVED***:
            proxy_url = '%s://%s:%i' % (proxy_url.scheme, proxy_url.host,
                                        proxy_url.port***REMOVED***
        proxy = parse_url(proxy_url***REMOVED***
        if not proxy.port:
            port = port_by_scheme.get(proxy.scheme, 80***REMOVED***
            proxy = proxy._replace(port=port***REMOVED***

        if proxy.scheme not in ("http", "https"***REMOVED***:
            raise ProxySchemeUnknown(proxy.scheme***REMOVED***

        self.proxy = proxy
        self.proxy_headers = proxy_headers or {***REMOVED***

        connection_pool_kw['_proxy'***REMOVED*** = self.proxy
        connection_pool_kw['_proxy_headers'***REMOVED*** = self.proxy_headers

        super(ProxyManager, self***REMOVED***.__init__(
            num_pools, headers, **connection_pool_kw***REMOVED***

    def connection_from_host(self, host, port=None, scheme='http'***REMOVED***:
        if scheme == "https":
            return super(ProxyManager, self***REMOVED***.connection_from_host(
                host, port, scheme***REMOVED***

        return super(ProxyManager, self***REMOVED***.connection_from_host(
            self.proxy.host, self.proxy.port, self.proxy.scheme***REMOVED***

    def _set_proxy_headers(self, url, headers=None***REMOVED***:
        ***REMOVED***
        Sets headers needed by proxies: specifically, the Accept and Host
        headers. Only sets headers not provided by the user.
        ***REMOVED***
        headers_ = {'Accept': '*/*'***REMOVED***

        netloc = parse_url(url***REMOVED***.netloc
        if netloc:
            headers_['Host'***REMOVED*** = netloc

        if headers:
            headers_.update(headers***REMOVED***
        return headers_

    def urlopen(self, method, url, redirect=True, **kw***REMOVED***:
        "Same as HTTP(S***REMOVED***ConnectionPool.urlopen, ``url`` must be absolute."
        u = parse_url(url***REMOVED***

        if u.scheme == "http":
            # For proxied HTTPS requests, httplib sets the necessary headers
            # on the CONNECT to the proxy. For HTTP, we'll definitely
            # need to set 'Host' at the very least.
            headers = kw.get('headers', self.headers***REMOVED***
            kw['headers'***REMOVED*** = self._set_proxy_headers(url, headers***REMOVED***

        return super(ProxyManager, self***REMOVED***.urlopen(method, url, redirect=redirect, **kw***REMOVED***


def proxy_from_url(url, **kw***REMOVED***:
    return ProxyManager(proxy_url=url, **kw***REMOVED***
