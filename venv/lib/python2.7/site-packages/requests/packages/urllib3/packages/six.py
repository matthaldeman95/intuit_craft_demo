***REMOVED***Utilities for writing code that runs on Python 2 and 3***REMOVED***

# Copyright (c***REMOVED*** 2010-2015 Benjamin Peterson
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"***REMOVED***, to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from __future__ import absolute_import

import functools
import itertools
import operator
import sys
import types

__author__ = "Benjamin Peterson <benjamin@python.org>"
__version__ = "1.10.0"


# Useful for very coarse version differentiation.
PY2 = sys.version_info[0***REMOVED*** == 2
PY3 = sys.version_info[0***REMOVED*** == 3
PY34 = sys.version_info[0:2***REMOVED*** >= (3, 4***REMOVED***

if PY3:
    string_types = str,
    integer_types = int,
    class_types = type,
    text_type = str
    binary_type = bytes

    MAXSIZE = sys.maxsize
else:
    string_types = basestring,
    integer_types = (int, long***REMOVED***
    class_types = (type, types.ClassType***REMOVED***
    text_type = unicode
    binary_type = str

    if sys.platform.startswith("java"***REMOVED***:
        # Jython always uses 32 bits.
        MAXSIZE = int((1 << 31***REMOVED*** - 1***REMOVED***
    else:
        # It's possible to have sizeof(long***REMOVED*** != sizeof(Py_ssize_t***REMOVED***.
        class X(object***REMOVED***:

            def __len__(self***REMOVED***:
                return 1 << 31
        ***REMOVED***
            len(X(***REMOVED******REMOVED***
        except OverflowError:
            # 32-bit
            MAXSIZE = int((1 << 31***REMOVED*** - 1***REMOVED***
        else:
            # 64-bit
            MAXSIZE = int((1 << 63***REMOVED*** - 1***REMOVED***
        del X


def _add_doc(func, doc***REMOVED***:
    ***REMOVED***Add documentation to a function.***REMOVED***
    func.__doc__ = doc


def _import_module(name***REMOVED***:
    ***REMOVED***Import module, returning the module after the last dot.***REMOVED***
    __import__(name***REMOVED***
    return sys.modules[name***REMOVED***


class _LazyDescr(object***REMOVED***:

    def __init__(self, name***REMOVED***:
        self.name = name

    def __get__(self, obj, tp***REMOVED***:
        result = self._resolve(***REMOVED***
        setattr(obj, self.name, result***REMOVED***  # Invokes __set__.
        ***REMOVED***
            # This is a bit ugly, but it avoids running this again by
            # removing this descriptor.
            delattr(obj.__class__, self.name***REMOVED***
        except AttributeError:
            pass
        return result


class MovedModule(_LazyDescr***REMOVED***:

    def __init__(self, name, old, new=None***REMOVED***:
        super(MovedModule, self***REMOVED***.__init__(name***REMOVED***
        if PY3:
            if new is None:
                new = name
            self.mod = new
        else:
            self.mod = old

    def _resolve(self***REMOVED***:
        return _import_module(self.mod***REMOVED***

    def __getattr__(self, attr***REMOVED***:
        _module = self._resolve(***REMOVED***
        value = getattr(_module, attr***REMOVED***
        setattr(self, attr, value***REMOVED***
        return value


class _LazyModule(types.ModuleType***REMOVED***:

    def __init__(self, name***REMOVED***:
        super(_LazyModule, self***REMOVED***.__init__(name***REMOVED***
        self.__doc__ = self.__class__.__doc__

    def __dir__(self***REMOVED***:
        attrs = ["__doc__", "__name__"***REMOVED***
        attrs += [attr.name for attr in self._moved_attributes***REMOVED***
        return attrs

    # Subclasses should override this
    _moved_attributes = [***REMOVED***


class MovedAttribute(_LazyDescr***REMOVED***:

    def __init__(self, name, old_mod, new_mod, old_attr=None, new_attr=None***REMOVED***:
        super(MovedAttribute, self***REMOVED***.__init__(name***REMOVED***
        if PY3:
            if new_mod is None:
                new_mod = name
            self.mod = new_mod
            if new_attr is None:
                if old_attr is None:
                    new_attr = name
                else:
                    new_attr = old_attr
            self.attr = new_attr
        else:
            self.mod = old_mod
            if old_attr is None:
                old_attr = name
            self.attr = old_attr

    def _resolve(self***REMOVED***:
        module = _import_module(self.mod***REMOVED***
        return getattr(module, self.attr***REMOVED***


class _SixMetaPathImporter(object***REMOVED***:

    ***REMOVED***
    A meta path importer to import six.moves and its submodules.

    This class implements a PEP302 finder and loader. It should be compatible
    with Python 2.5 and all existing versions of Python3
    ***REMOVED***

    def __init__(self, six_module_name***REMOVED***:
        self.name = six_module_name
        self.known_modules = {***REMOVED***

    def _add_module(self, mod, *fullnames***REMOVED***:
        for fullname in fullnames:
            self.known_modules[self.name + "." + fullname***REMOVED*** = mod

    def _get_module(self, fullname***REMOVED***:
        return self.known_modules[self.name + "." + fullname***REMOVED***

    def find_module(self, fullname, path=None***REMOVED***:
        if fullname in self.known_modules:
            return self
        return None

    def __get_module(self, fullname***REMOVED***:
        ***REMOVED***
            return self.known_modules[fullname***REMOVED***
        except KeyError:
            raise ImportError("This loader does not know module " + fullname***REMOVED***

    def load_module(self, fullname***REMOVED***:
        ***REMOVED***
            # in case of a reload
            return sys.modules[fullname***REMOVED***
        except KeyError:
            pass
        mod = self.__get_module(fullname***REMOVED***
        if isinstance(mod, MovedModule***REMOVED***:
            mod = mod._resolve(***REMOVED***
        else:
            mod.__loader__ = self
        sys.modules[fullname***REMOVED*** = mod
        return mod

    def is_package(self, fullname***REMOVED***:
        ***REMOVED***
        Return true, if the named module is a package.

        We need this method to get correct spec objects with
        Python 3.4 (see PEP451***REMOVED***
        ***REMOVED***
        return hasattr(self.__get_module(fullname***REMOVED***, "__path__"***REMOVED***

    def get_code(self, fullname***REMOVED***:
        ***REMOVED***Return None

        Required, if is_package is implemented***REMOVED***
        self.__get_module(fullname***REMOVED***  # eventually raises ImportError
        return None
    get_source = get_code  # same as get_code

_importer = _SixMetaPathImporter(__name__***REMOVED***


class _MovedItems(_LazyModule***REMOVED***:

    ***REMOVED***Lazy loading of moved objects***REMOVED***
    __path__ = [***REMOVED***  # mark as package


_moved_attributes = [
    MovedAttribute("cStringIO", "cStringIO", "io", "StringIO"***REMOVED***,
    MovedAttribute("filter", "itertools", "builtins", "ifilter", "filter"***REMOVED***,
    MovedAttribute("filterfalse", "itertools", "itertools", "ifilterfalse", "filterfalse"***REMOVED***,
    MovedAttribute("input", "__builtin__", "builtins", "raw_input", "input"***REMOVED***,
    MovedAttribute("intern", "__builtin__", "sys"***REMOVED***,
    MovedAttribute("map", "itertools", "builtins", "imap", "map"***REMOVED***,
    MovedAttribute("getcwd", "os", "os", "getcwdu", "getcwd"***REMOVED***,
    MovedAttribute("getcwdb", "os", "os", "getcwd", "getcwdb"***REMOVED***,
    MovedAttribute("range", "__builtin__", "builtins", "xrange", "range"***REMOVED***,
    MovedAttribute("reload_module", "__builtin__", "importlib" if PY34 else "imp", "reload"***REMOVED***,
    MovedAttribute("reduce", "__builtin__", "functools"***REMOVED***,
    MovedAttribute("shlex_quote", "pipes", "shlex", "quote"***REMOVED***,
    MovedAttribute("StringIO", "StringIO", "io"***REMOVED***,
    MovedAttribute("UserDict", "UserDict", "collections"***REMOVED***,
    MovedAttribute("UserList", "UserList", "collections"***REMOVED***,
    MovedAttribute("UserString", "UserString", "collections"***REMOVED***,
    MovedAttribute("xrange", "__builtin__", "builtins", "xrange", "range"***REMOVED***,
    MovedAttribute("zip", "itertools", "builtins", "izip", "zip"***REMOVED***,
    MovedAttribute("zip_longest", "itertools", "itertools", "izip_longest", "zip_longest"***REMOVED***,
    MovedModule("builtins", "__builtin__"***REMOVED***,
    MovedModule("configparser", "ConfigParser"***REMOVED***,
    MovedModule("copyreg", "copy_reg"***REMOVED***,
    MovedModule("dbm_gnu", "gdbm", "dbm.gnu"***REMOVED***,
    MovedModule("_dummy_thread", "dummy_thread", "_dummy_thread"***REMOVED***,
    MovedModule("http_cookiejar", "cookielib", "http.cookiejar"***REMOVED***,
    MovedModule("http_cookies", "Cookie", "http.cookies"***REMOVED***,
    MovedModule("html_entities", "htmlentitydefs", "html.entities"***REMOVED***,
    MovedModule("html_parser", "HTMLParser", "html.parser"***REMOVED***,
    MovedModule("http_client", "httplib", "http.client"***REMOVED***,
    MovedModule("email_mime_multipart", "email.MIMEMultipart", "email.mime.multipart"***REMOVED***,
    MovedModule("email_mime_nonmultipart", "email.MIMENonMultipart", "email.mime.nonmultipart"***REMOVED***,
    MovedModule("email_mime_text", "email.MIMEText", "email.mime.text"***REMOVED***,
    MovedModule("email_mime_base", "email.MIMEBase", "email.mime.base"***REMOVED***,
    MovedModule("BaseHTTPServer", "BaseHTTPServer", "http.server"***REMOVED***,
    MovedModule("CGIHTTPServer", "CGIHTTPServer", "http.server"***REMOVED***,
    MovedModule("SimpleHTTPServer", "SimpleHTTPServer", "http.server"***REMOVED***,
    MovedModule("cPickle", "cPickle", "pickle"***REMOVED***,
    MovedModule("queue", "Queue"***REMOVED***,
    MovedModule("reprlib", "repr"***REMOVED***,
    MovedModule("socketserver", "SocketServer"***REMOVED***,
    MovedModule("_thread", "thread", "_thread"***REMOVED***,
    MovedModule("tkinter", "Tkinter"***REMOVED***,
    MovedModule("tkinter_dialog", "Dialog", "tkinter.dialog"***REMOVED***,
    MovedModule("tkinter_filedialog", "FileDialog", "tkinter.filedialog"***REMOVED***,
    MovedModule("tkinter_scrolledtext", "ScrolledText", "tkinter.scrolledtext"***REMOVED***,
    MovedModule("tkinter_simpledialog", "SimpleDialog", "tkinter.simpledialog"***REMOVED***,
    MovedModule("tkinter_tix", "Tix", "tkinter.tix"***REMOVED***,
    MovedModule("tkinter_ttk", "ttk", "tkinter.ttk"***REMOVED***,
    MovedModule("tkinter_constants", "Tkconstants", "tkinter.constants"***REMOVED***,
    MovedModule("tkinter_dnd", "Tkdnd", "tkinter.dnd"***REMOVED***,
    MovedModule("tkinter_colorchooser", "tkColorChooser",
                "tkinter.colorchooser"***REMOVED***,
    MovedModule("tkinter_commondialog", "tkCommonDialog",
                "tkinter.commondialog"***REMOVED***,
    MovedModule("tkinter_tkfiledialog", "tkFileDialog", "tkinter.filedialog"***REMOVED***,
    MovedModule("tkinter_font", "tkFont", "tkinter.font"***REMOVED***,
    MovedModule("tkinter_messagebox", "tkMessageBox", "tkinter.messagebox"***REMOVED***,
    MovedModule("tkinter_tksimpledialog", "tkSimpleDialog",
                "tkinter.simpledialog"***REMOVED***,
    MovedModule("urllib_parse", __name__ + ".moves.urllib_parse", "urllib.parse"***REMOVED***,
    MovedModule("urllib_error", __name__ + ".moves.urllib_error", "urllib.error"***REMOVED***,
    MovedModule("urllib", __name__ + ".moves.urllib", __name__ + ".moves.urllib"***REMOVED***,
    MovedModule("urllib_robotparser", "robotparser", "urllib.robotparser"***REMOVED***,
    MovedModule("xmlrpc_client", "xmlrpclib", "xmlrpc.client"***REMOVED***,
    MovedModule("xmlrpc_server", "SimpleXMLRPCServer", "xmlrpc.server"***REMOVED***,
***REMOVED***
# Add windows specific modules.
if sys.platform == "win32":
    _moved_attributes += [
        MovedModule("winreg", "_winreg"***REMOVED***,
    ***REMOVED***

for attr in _moved_attributes:
    setattr(_MovedItems, attr.name, attr***REMOVED***
    if isinstance(attr, MovedModule***REMOVED***:
        _importer._add_module(attr, "moves." + attr.name***REMOVED***
del attr

_MovedItems._moved_attributes = _moved_attributes

moves = _MovedItems(__name__ + ".moves"***REMOVED***
_importer._add_module(moves, "moves"***REMOVED***


class Module_six_moves_urllib_parse(_LazyModule***REMOVED***:

    ***REMOVED***Lazy loading of moved objects in six.moves.urllib_parse***REMOVED***


_urllib_parse_moved_attributes = [
    MovedAttribute("ParseResult", "urlparse", "urllib.parse"***REMOVED***,
    MovedAttribute("SplitResult", "urlparse", "urllib.parse"***REMOVED***,
    MovedAttribute("parse_qs", "urlparse", "urllib.parse"***REMOVED***,
    MovedAttribute("parse_qsl", "urlparse", "urllib.parse"***REMOVED***,
    MovedAttribute("urldefrag", "urlparse", "urllib.parse"***REMOVED***,
    MovedAttribute("urljoin", "urlparse", "urllib.parse"***REMOVED***,
    MovedAttribute("urlparse", "urlparse", "urllib.parse"***REMOVED***,
    MovedAttribute("urlsplit", "urlparse", "urllib.parse"***REMOVED***,
    MovedAttribute("urlunparse", "urlparse", "urllib.parse"***REMOVED***,
    MovedAttribute("urlunsplit", "urlparse", "urllib.parse"***REMOVED***,
    MovedAttribute("quote", "urllib", "urllib.parse"***REMOVED***,
    MovedAttribute("quote_plus", "urllib", "urllib.parse"***REMOVED***,
    MovedAttribute("unquote", "urllib", "urllib.parse"***REMOVED***,
    MovedAttribute("unquote_plus", "urllib", "urllib.parse"***REMOVED***,
    MovedAttribute("urlencode", "urllib", "urllib.parse"***REMOVED***,
    MovedAttribute("splitquery", "urllib", "urllib.parse"***REMOVED***,
    MovedAttribute("splittag", "urllib", "urllib.parse"***REMOVED***,
    MovedAttribute("splituser", "urllib", "urllib.parse"***REMOVED***,
    MovedAttribute("uses_fragment", "urlparse", "urllib.parse"***REMOVED***,
    MovedAttribute("uses_netloc", "urlparse", "urllib.parse"***REMOVED***,
    MovedAttribute("uses_params", "urlparse", "urllib.parse"***REMOVED***,
    MovedAttribute("uses_query", "urlparse", "urllib.parse"***REMOVED***,
    MovedAttribute("uses_relative", "urlparse", "urllib.parse"***REMOVED***,
***REMOVED***
for attr in _urllib_parse_moved_attributes:
    setattr(Module_six_moves_urllib_parse, attr.name, attr***REMOVED***
del attr

Module_six_moves_urllib_parse._moved_attributes = _urllib_parse_moved_attributes

_importer._add_module(Module_six_moves_urllib_parse(__name__ + ".moves.urllib_parse"***REMOVED***,
                      "moves.urllib_parse", "moves.urllib.parse"***REMOVED***


class Module_six_moves_urllib_error(_LazyModule***REMOVED***:

    ***REMOVED***Lazy loading of moved objects in six.moves.urllib_error***REMOVED***


_urllib_error_moved_attributes = [
    MovedAttribute("URLError", "urllib2", "urllib.error"***REMOVED***,
    MovedAttribute("HTTPError", "urllib2", "urllib.error"***REMOVED***,
    MovedAttribute("ContentTooShortError", "urllib", "urllib.error"***REMOVED***,
***REMOVED***
for attr in _urllib_error_moved_attributes:
    setattr(Module_six_moves_urllib_error, attr.name, attr***REMOVED***
del attr

Module_six_moves_urllib_error._moved_attributes = _urllib_error_moved_attributes

_importer._add_module(Module_six_moves_urllib_error(__name__ + ".moves.urllib.error"***REMOVED***,
                      "moves.urllib_error", "moves.urllib.error"***REMOVED***


class Module_six_moves_urllib_request(_LazyModule***REMOVED***:

    ***REMOVED***Lazy loading of moved objects in six.moves.urllib_request***REMOVED***


_urllib_request_moved_attributes = [
    MovedAttribute("urlopen", "urllib2", "urllib.request"***REMOVED***,
    MovedAttribute("install_opener", "urllib2", "urllib.request"***REMOVED***,
    MovedAttribute("build_opener", "urllib2", "urllib.request"***REMOVED***,
    MovedAttribute("pathname2url", "urllib", "urllib.request"***REMOVED***,
    MovedAttribute("url2pathname", "urllib", "urllib.request"***REMOVED***,
    MovedAttribute("getproxies", "urllib", "urllib.request"***REMOVED***,
    MovedAttribute("Request", "urllib2", "urllib.request"***REMOVED***,
    MovedAttribute("OpenerDirector", "urllib2", "urllib.request"***REMOVED***,
    MovedAttribute("HTTPDefaultErrorHandler", "urllib2", "urllib.request"***REMOVED***,
    MovedAttribute("HTTPRedirectHandler", "urllib2", "urllib.request"***REMOVED***,
    MovedAttribute("HTTPCookieProcessor", "urllib2", "urllib.request"***REMOVED***,
    MovedAttribute("ProxyHandler", "urllib2", "urllib.request"***REMOVED***,
    MovedAttribute("BaseHandler", "urllib2", "urllib.request"***REMOVED***,
    MovedAttribute("HTTPPasswordMgr", "urllib2", "urllib.request"***REMOVED***,
    MovedAttribute("HTTPPasswordMgrWithDefaultRealm", "urllib2", "urllib.request"***REMOVED***,
    MovedAttribute("AbstractBasicAuthHandler", "urllib2", "urllib.request"***REMOVED***,
    MovedAttribute("HTTPBasicAuthHandler", "urllib2", "urllib.request"***REMOVED***,
    MovedAttribute("ProxyBasicAuthHandler", "urllib2", "urllib.request"***REMOVED***,
    MovedAttribute("AbstractDigestAuthHandler", "urllib2", "urllib.request"***REMOVED***,
    MovedAttribute("HTTPDigestAuthHandler", "urllib2", "urllib.request"***REMOVED***,
    MovedAttribute("ProxyDigestAuthHandler", "urllib2", "urllib.request"***REMOVED***,
    MovedAttribute("HTTPHandler", "urllib2", "urllib.request"***REMOVED***,
    MovedAttribute("HTTPSHandler", "urllib2", "urllib.request"***REMOVED***,
    MovedAttribute("FileHandler", "urllib2", "urllib.request"***REMOVED***,
    MovedAttribute("FTPHandler", "urllib2", "urllib.request"***REMOVED***,
    MovedAttribute("CacheFTPHandler", "urllib2", "urllib.request"***REMOVED***,
    MovedAttribute("UnknownHandler", "urllib2", "urllib.request"***REMOVED***,
    MovedAttribute("HTTPErrorProcessor", "urllib2", "urllib.request"***REMOVED***,
    MovedAttribute("urlretrieve", "urllib", "urllib.request"***REMOVED***,
    MovedAttribute("urlcleanup", "urllib", "urllib.request"***REMOVED***,
    MovedAttribute("URLopener", "urllib", "urllib.request"***REMOVED***,
    MovedAttribute("FancyURLopener", "urllib", "urllib.request"***REMOVED***,
    MovedAttribute("proxy_bypass", "urllib", "urllib.request"***REMOVED***,
***REMOVED***
for attr in _urllib_request_moved_attributes:
    setattr(Module_six_moves_urllib_request, attr.name, attr***REMOVED***
del attr

Module_six_moves_urllib_request._moved_attributes = _urllib_request_moved_attributes

_importer._add_module(Module_six_moves_urllib_request(__name__ + ".moves.urllib.request"***REMOVED***,
                      "moves.urllib_request", "moves.urllib.request"***REMOVED***


class Module_six_moves_urllib_response(_LazyModule***REMOVED***:

    ***REMOVED***Lazy loading of moved objects in six.moves.urllib_response***REMOVED***


_urllib_response_moved_attributes = [
    MovedAttribute("addbase", "urllib", "urllib.response"***REMOVED***,
    MovedAttribute("addclosehook", "urllib", "urllib.response"***REMOVED***,
    MovedAttribute("addinfo", "urllib", "urllib.response"***REMOVED***,
    MovedAttribute("addinfourl", "urllib", "urllib.response"***REMOVED***,
***REMOVED***
for attr in _urllib_response_moved_attributes:
    setattr(Module_six_moves_urllib_response, attr.name, attr***REMOVED***
del attr

Module_six_moves_urllib_response._moved_attributes = _urllib_response_moved_attributes

_importer._add_module(Module_six_moves_urllib_response(__name__ + ".moves.urllib.response"***REMOVED***,
                      "moves.urllib_response", "moves.urllib.response"***REMOVED***


class Module_six_moves_urllib_robotparser(_LazyModule***REMOVED***:

    ***REMOVED***Lazy loading of moved objects in six.moves.urllib_robotparser***REMOVED***


_urllib_robotparser_moved_attributes = [
    MovedAttribute("RobotFileParser", "robotparser", "urllib.robotparser"***REMOVED***,
***REMOVED***
for attr in _urllib_robotparser_moved_attributes:
    setattr(Module_six_moves_urllib_robotparser, attr.name, attr***REMOVED***
del attr

Module_six_moves_urllib_robotparser._moved_attributes = _urllib_robotparser_moved_attributes

_importer._add_module(Module_six_moves_urllib_robotparser(__name__ + ".moves.urllib.robotparser"***REMOVED***,
                      "moves.urllib_robotparser", "moves.urllib.robotparser"***REMOVED***


class Module_six_moves_urllib(types.ModuleType***REMOVED***:

    ***REMOVED***Create a six.moves.urllib namespace that resembles the Python 3 namespace***REMOVED***
    __path__ = [***REMOVED***  # mark as package
    parse = _importer._get_module("moves.urllib_parse"***REMOVED***
    error = _importer._get_module("moves.urllib_error"***REMOVED***
    request = _importer._get_module("moves.urllib_request"***REMOVED***
    response = _importer._get_module("moves.urllib_response"***REMOVED***
    robotparser = _importer._get_module("moves.urllib_robotparser"***REMOVED***

    def __dir__(self***REMOVED***:
        return ['parse', 'error', 'request', 'response', 'robotparser'***REMOVED***

_importer._add_module(Module_six_moves_urllib(__name__ + ".moves.urllib"***REMOVED***,
                      "moves.urllib"***REMOVED***


def add_move(move***REMOVED***:
    ***REMOVED***Add an item to six.moves.***REMOVED***
    setattr(_MovedItems, move.name, move***REMOVED***


def remove_move(name***REMOVED***:
    ***REMOVED***Remove item from six.moves.***REMOVED***
    ***REMOVED***
        delattr(_MovedItems, name***REMOVED***
    except AttributeError:
        ***REMOVED***
            del moves.__dict__[name***REMOVED***
        except KeyError:
            raise AttributeError("no such move, %r" % (name,***REMOVED******REMOVED***


if PY3:
    _meth_func = "__func__"
    _meth_self = "__self__"

    _func_closure = "__closure__"
    _func_code = "__code__"
    _func_defaults = "__defaults__"
    _func_globals = "__globals__"
else:
    _meth_func = "im_func"
    _meth_self = "im_self"

    _func_closure = "func_closure"
    _func_code = "func_code"
    _func_defaults = "func_defaults"
    _func_globals = "func_globals"


***REMOVED***
    advance_iterator = next
except NameError:
    def advance_iterator(it***REMOVED***:
        return it.next(***REMOVED***
next = advance_iterator


***REMOVED***
    callable = callable
except NameError:
    def callable(obj***REMOVED***:
        return any("__call__" in klass.__dict__ for klass in type(obj***REMOVED***.__mro__***REMOVED***


if PY3:
    def get_unbound_function(unbound***REMOVED***:
        return unbound

    create_bound_method = types.MethodType

    def create_unbound_method(func, cls***REMOVED***:
        return func

    Iterator = object
else:
    def get_unbound_function(unbound***REMOVED***:
        return unbound.im_func

    def create_bound_method(func, obj***REMOVED***:
        return types.MethodType(func, obj, obj.__class__***REMOVED***

    def create_unbound_method(func, cls***REMOVED***:
        return types.MethodType(func, None, cls***REMOVED***

    class Iterator(object***REMOVED***:

        def next(self***REMOVED***:
            return type(self***REMOVED***.__next__(self***REMOVED***

    callable = callable
_add_doc(get_unbound_function,
         ***REMOVED***Get the function out of a possibly unbound function***REMOVED******REMOVED***


get_method_function = operator.attrgetter(_meth_func***REMOVED***
get_method_self = operator.attrgetter(_meth_self***REMOVED***
get_function_closure = operator.attrgetter(_func_closure***REMOVED***
get_function_code = operator.attrgetter(_func_code***REMOVED***
get_function_defaults = operator.attrgetter(_func_defaults***REMOVED***
get_function_globals = operator.attrgetter(_func_globals***REMOVED***


if PY3:
    def iterkeys(d, **kw***REMOVED***:
        return iter(d.keys(**kw***REMOVED******REMOVED***

    def itervalues(d, **kw***REMOVED***:
        return iter(d.values(**kw***REMOVED******REMOVED***

    def iteritems(d, **kw***REMOVED***:
        return iter(d.items(**kw***REMOVED******REMOVED***

    def iterlists(d, **kw***REMOVED***:
        return iter(d.lists(**kw***REMOVED******REMOVED***

    viewkeys = operator.methodcaller("keys"***REMOVED***

    viewvalues = operator.methodcaller("values"***REMOVED***

    viewitems = operator.methodcaller("items"***REMOVED***
else:
    def iterkeys(d, **kw***REMOVED***:
        return d.iterkeys(**kw***REMOVED***

    def itervalues(d, **kw***REMOVED***:
        return d.itervalues(**kw***REMOVED***

    def iteritems(d, **kw***REMOVED***:
        return d.iteritems(**kw***REMOVED***

    def iterlists(d, **kw***REMOVED***:
        return d.iterlists(**kw***REMOVED***

    viewkeys = operator.methodcaller("viewkeys"***REMOVED***

    viewvalues = operator.methodcaller("viewvalues"***REMOVED***

    viewitems = operator.methodcaller("viewitems"***REMOVED***

_add_doc(iterkeys, "Return an iterator over the keys of a dictionary."***REMOVED***
_add_doc(itervalues, "Return an iterator over the values of a dictionary."***REMOVED***
_add_doc(iteritems,
         "Return an iterator over the (key, value***REMOVED*** pairs of a dictionary."***REMOVED***
_add_doc(iterlists,
         "Return an iterator over the (key, [values***REMOVED******REMOVED*** pairs of a dictionary."***REMOVED***


if PY3:
    def b(s***REMOVED***:
        return s.encode("latin-1"***REMOVED***

    def u(s***REMOVED***:
        return s
    unichr = chr
    import struct
    int2byte = struct.Struct(">B"***REMOVED***.pack
    del struct
    byte2int = operator.itemgetter(0***REMOVED***
    indexbytes = operator.getitem
    iterbytes = iter
    import io
    StringIO = io.StringIO
    BytesIO = io.BytesIO
    _assertCountEqual = "assertCountEqual"
    if sys.version_info[1***REMOVED*** <= 1:
        _assertRaisesRegex = "assertRaisesRegexp"
        _assertRegex = "assertRegexpMatches"
    else:
        _assertRaisesRegex = "assertRaisesRegex"
        _assertRegex = "assertRegex"
else:
    def b(s***REMOVED***:
        return s
    # Workaround for standalone backslash

    def u(s***REMOVED***:
        return unicode(s.replace(r'\\', r'\\\\'***REMOVED***, "unicode_escape"***REMOVED***
    unichr = unichr
    int2byte = chr

    def byte2int(bs***REMOVED***:
        return ord(bs[0***REMOVED******REMOVED***

    def indexbytes(buf, i***REMOVED***:
        return ord(buf[i***REMOVED******REMOVED***
    iterbytes = functools.partial(itertools.imap, ord***REMOVED***
    import StringIO
    StringIO = BytesIO = StringIO.StringIO
    _assertCountEqual = "assertItemsEqual"
    _assertRaisesRegex = "assertRaisesRegexp"
    _assertRegex = "assertRegexpMatches"
_add_doc(b, ***REMOVED***Byte literal***REMOVED******REMOVED***
_add_doc(u, ***REMOVED***Text literal***REMOVED******REMOVED***


def assertCountEqual(self, *args, **kwargs***REMOVED***:
    return getattr(self, _assertCountEqual***REMOVED***(*args, **kwargs***REMOVED***


def assertRaisesRegex(self, *args, **kwargs***REMOVED***:
    return getattr(self, _assertRaisesRegex***REMOVED***(*args, **kwargs***REMOVED***


def assertRegex(self, *args, **kwargs***REMOVED***:
    return getattr(self, _assertRegex***REMOVED***(*args, **kwargs***REMOVED***


if PY3:
    exec_ = getattr(moves.builtins, "exec"***REMOVED***

    def reraise(tp, value, tb=None***REMOVED***:
        if value is None:
            value = tp(***REMOVED***
        if value.__traceback__ is not tb:
            raise value.with_traceback(tb***REMOVED***
        raise value

else:
    def exec_(_code_, _globs_=None, _locs_=None***REMOVED***:
        ***REMOVED***Execute code in a namespace.***REMOVED***
        if _globs_ is None:
            frame = sys._getframe(1***REMOVED***
            _globs_ = frame.f_globals
            if _locs_ is None:
                _locs_ = frame.f_locals
            del frame
        elif _locs_ is None:
            _locs_ = _globs_
        exec(***REMOVED***exec _code_ in _globs_, _locs_***REMOVED******REMOVED***

    exec_(***REMOVED***def reraise(tp, value, tb=None***REMOVED***:
    raise tp, value, tb
***REMOVED******REMOVED***


if sys.version_info[:2***REMOVED*** == (3, 2***REMOVED***:
    exec_(***REMOVED***def raise_from(value, from_value***REMOVED***:
    if from_value is None:
        raise value
    raise value from from_value
***REMOVED******REMOVED***
elif sys.version_info[:2***REMOVED*** > (3, 2***REMOVED***:
    exec_(***REMOVED***def raise_from(value, from_value***REMOVED***:
    raise value from from_value
***REMOVED******REMOVED***
else:
    def raise_from(value, from_value***REMOVED***:
        raise value


print_ = getattr(moves.builtins, "print", None***REMOVED***
if print_ is None:
    def print_(*args, **kwargs***REMOVED***:
        ***REMOVED***The new-style print function for Python 2.4 and 2.5.***REMOVED***
        fp = kwargs.pop("file", sys.stdout***REMOVED***
        if fp is None:
            return

        def write(data***REMOVED***:
            if not isinstance(data, basestring***REMOVED***:
                data = str(data***REMOVED***
            # If the file has an encoding, encode unicode with it.
            if (isinstance(fp, file***REMOVED*** and
                    isinstance(data, unicode***REMOVED*** and
                    fp.encoding is not None***REMOVED***:
                errors = getattr(fp, "errors", None***REMOVED***
                if errors is None:
                    errors = "strict"
                data = data.encode(fp.encoding, errors***REMOVED***
            fp.write(data***REMOVED***
        want_unicode = False
        sep = kwargs.pop("sep", None***REMOVED***
        if sep is not None:
            if isinstance(sep, unicode***REMOVED***:
                want_unicode = True
            elif not isinstance(sep, str***REMOVED***:
                raise TypeError("sep must be None or a string"***REMOVED***
        end = kwargs.pop("end", None***REMOVED***
        if end is not None:
            if isinstance(end, unicode***REMOVED***:
                want_unicode = True
            elif not isinstance(end, str***REMOVED***:
                raise TypeError("end must be None or a string"***REMOVED***
        if kwargs:
            raise TypeError("invalid keyword arguments to print(***REMOVED***"***REMOVED***
        if not want_unicode:
            for arg in args:
                if isinstance(arg, unicode***REMOVED***:
                    want_unicode = True
                    break
        if want_unicode:
            newline = unicode("\n"***REMOVED***
            space = unicode(" "***REMOVED***
        else:
            newline = "\n"
            space = " "
        if sep is None:
            sep = space
        if end is None:
            end = newline
        for i, arg in enumerate(args***REMOVED***:
            if i:
                write(sep***REMOVED***
            write(arg***REMOVED***
        write(end***REMOVED***
if sys.version_info[:2***REMOVED*** < (3, 3***REMOVED***:
    _print = print_

    def print_(*args, **kwargs***REMOVED***:
        fp = kwargs.get("file", sys.stdout***REMOVED***
        flush = kwargs.pop("flush", False***REMOVED***
        _print(*args, **kwargs***REMOVED***
        if flush and fp is not None:
            fp.flush(***REMOVED***

_add_doc(reraise, ***REMOVED***Reraise an exception.***REMOVED******REMOVED***

if sys.version_info[0:2***REMOVED*** < (3, 4***REMOVED***:
    def wraps(wrapped, assigned=functools.WRAPPER_ASSIGNMENTS,
              updated=functools.WRAPPER_UPDATES***REMOVED***:
        def wrapper(f***REMOVED***:
            f = functools.wraps(wrapped, assigned, updated***REMOVED***(f***REMOVED***
            f.__wrapped__ = wrapped
            return f
        return wrapper
else:
    wraps = functools.wraps


def with_metaclass(meta, *bases***REMOVED***:
    ***REMOVED***Create a base class with a metaclass.***REMOVED***
    # This requires a bit of explanation: the basic idea is to make a dummy
    # metaclass for one level of class instantiation that replaces itself with
    # the actual metaclass.
    class metaclass(meta***REMOVED***:

        def __new__(cls, name, this_bases, d***REMOVED***:
            return meta(name, bases, d***REMOVED***
    return type.__new__(metaclass, 'temporary_class', (***REMOVED***, {***REMOVED******REMOVED***


def add_metaclass(metaclass***REMOVED***:
    ***REMOVED***Class decorator for creating a class with a metaclass.***REMOVED***
    def wrapper(cls***REMOVED***:
        orig_vars = cls.__dict__.copy(***REMOVED***
        slots = orig_vars.get('__slots__'***REMOVED***
        if slots is not None:
            if isinstance(slots, str***REMOVED***:
                slots = [slots***REMOVED***
            for slots_var in slots:
                orig_vars.pop(slots_var***REMOVED***
        orig_vars.pop('__dict__', None***REMOVED***
        orig_vars.pop('__weakref__', None***REMOVED***
        return metaclass(cls.__name__, cls.__bases__, orig_vars***REMOVED***
    return wrapper


def python_2_unicode_compatible(klass***REMOVED***:
    ***REMOVED***
    A decorator that defines __unicode__ and __str__ methods under Python 2.
    Under Python 3 it does nothing.

    To support Python 2 and 3 with a single code base, define a __str__ method
    returning text and apply this decorator to the class.
    ***REMOVED***
    if PY2:
        if '__str__' not in klass.__dict__:
            raise ValueError("@python_2_unicode_compatible cannot be applied "
                             "to %s because it doesn't define __str__(***REMOVED***." %
                             klass.__name__***REMOVED***
        klass.__unicode__ = klass.__str__
        klass.__str__ = lambda self: self.__unicode__(***REMOVED***.encode('utf-8'***REMOVED***
    return klass


# Complete the moves implementation.
# This code is at the end of this module to speed up module loading.
# Turn this module into a package.
__path__ = [***REMOVED***  # required for PEP 302 and PEP 451
__package__ = __name__  # see PEP 366 @ReservedAssignment
if globals(***REMOVED***.get("__spec__"***REMOVED*** is not None:
    __spec__.submodule_search_locations = [***REMOVED***  # PEP 451 @UndefinedVariable
# Remove other six meta path importers, since they cause problems. This can
# happen if six is removed from sys.modules and then reloaded. (Setuptools does
# this for some reason.***REMOVED***
if sys.meta_path:
    for i, importer in enumerate(sys.meta_path***REMOVED***:
        # Here's some real nastiness: Another "instance" of the six module might
        # be floating around. Therefore, we can't use isinstance(***REMOVED*** to check for
        # the six meta path importer, since the other six instance will have
        # inserted an importer with different class.
        if (type(importer***REMOVED***.__name__ == "_SixMetaPathImporter" and
                importer.name == __name__***REMOVED***:
            del sys.meta_path[i***REMOVED***
            break
    del i, importer
# Finally, add the importer to the meta path import hook.
sys.meta_path.append(_importer***REMOVED***
