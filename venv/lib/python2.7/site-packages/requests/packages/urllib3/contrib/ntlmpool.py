***REMOVED***
NTLM authenticating pool, contributed by erikcederstran

Issue #10, see: http://code.google.com/p/urllib3/issues/detail?id=10
***REMOVED***
from __future__ import absolute_import

***REMOVED***
    from http.client import HTTPSConnection
except ImportError:
    from httplib import HTTPSConnection
from logging import getLogger
from ntlm import ntlm

from urllib3 import HTTPSConnectionPool


log = getLogger(__name__***REMOVED***


class NTLMConnectionPool(HTTPSConnectionPool***REMOVED***:
    ***REMOVED***
    Implements an NTLM authentication version of an urllib3 connection pool
    ***REMOVED***

    scheme = 'https'

    def __init__(self, user, pw, authurl, *args, **kwargs***REMOVED***:
        ***REMOVED***
        authurl is a random URL on the server that is protected by NTLM.
        user is the Windows user, probably in the DOMAIN\\username format.
        pw is the password for the user.
        ***REMOVED***
        super(NTLMConnectionPool, self***REMOVED***.__init__(*args, **kwargs***REMOVED***
        self.authurl = authurl
        self.rawuser = user
        user_parts = user.split('\\', 1***REMOVED***
        self.domain = user_parts[0***REMOVED***.upper(***REMOVED***
        self.user = user_parts[1***REMOVED***
        self.pw = pw

    def _new_conn(self***REMOVED***:
        # Performs the NTLM handshake that secures the connection. The socket
        # must be kept open while requests are performed.
        self.num_connections += 1
        log.debug('Starting NTLM HTTPS connection no. %d: https://%s%s',
                  self.num_connections, self.host, self.authurl***REMOVED***

        headers = {***REMOVED***
        headers['Connection'***REMOVED*** = 'Keep-Alive'
        req_header = 'Authorization'
        resp_header = 'www-authenticate'

        conn = HTTPSConnection(host=self.host, port=self.port***REMOVED***

        # Send negotiation message
        headers[req_header***REMOVED*** = (
            'NTLM %s' % ntlm.create_NTLM_NEGOTIATE_MESSAGE(self.rawuser***REMOVED******REMOVED***
        log.debug('Request headers: %s', headers***REMOVED***
        conn.request('GET', self.authurl, None, headers***REMOVED***
        res = conn.getresponse(***REMOVED***
        reshdr = dict(res.getheaders(***REMOVED******REMOVED***
        log.debug('Response status: %s %s', res.status, res.reason***REMOVED***
        log.debug('Response headers: %s', reshdr***REMOVED***
        log.debug('Response data: %s [...***REMOVED***', res.read(100***REMOVED******REMOVED***

        # Remove the reference to the socket, so that it can not be closed by
        # the response object (we want to keep the socket open***REMOVED***
        res.fp = None

        # Server should respond with a challenge message
        auth_header_values = reshdr[resp_header***REMOVED***.split(', '***REMOVED***
        auth_header_value = None
        for s in auth_header_values:
            if s[:5***REMOVED*** == 'NTLM ':
                auth_header_value = s[5:***REMOVED***
        if auth_header_value is None:
            raise Exception('Unexpected %s response header: %s' %
                            (resp_header, reshdr[resp_header***REMOVED******REMOVED******REMOVED***

        # Send authentication message
        ServerChallenge, NegotiateFlags = \
            ntlm.parse_NTLM_CHALLENGE_MESSAGE(auth_header_value***REMOVED***
        auth_msg = ntlm.create_NTLM_AUTHENTICATE_MESSAGE(ServerChallenge,
                                                         self.user,
                                                         self.domain,
                                                         self.pw,
                                                         NegotiateFlags***REMOVED***
        headers[req_header***REMOVED*** = 'NTLM %s' % auth_msg
        log.debug('Request headers: %s', headers***REMOVED***
        conn.request('GET', self.authurl, None, headers***REMOVED***
        res = conn.getresponse(***REMOVED***
        log.debug('Response status: %s %s', res.status, res.reason***REMOVED***
        log.debug('Response headers: %s', dict(res.getheaders(***REMOVED******REMOVED******REMOVED***
        log.debug('Response data: %s [...***REMOVED***', res.read(***REMOVED***[:100***REMOVED******REMOVED***
        if res.status != 200:
            if res.status == 401:
                raise Exception('Server rejected request: wrong '
                                'username or password'***REMOVED***
            raise Exception('Wrong server response: %s %s' %
                            (res.status, res.reason***REMOVED******REMOVED***

        res.fp = None
        log.debug('Connection established'***REMOVED***
        return conn

    def urlopen(self, method, url, body=None, headers=None, retries=3,
                redirect=True, assert_same_host=True***REMOVED***:
        if headers is None:
            headers = {***REMOVED***
        headers['Connection'***REMOVED*** = 'Keep-Alive'
        return super(NTLMConnectionPool, self***REMOVED***.urlopen(method, url, body,
                                                       headers, retries,
                                                       redirect,
                                                       assert_same_host***REMOVED***
