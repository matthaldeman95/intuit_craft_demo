# -*- coding: utf-8 -*-

***REMOVED***
requests.auth
~~~~~~~~~~~~~

This module contains the authentication handlers for Requests.
***REMOVED***

***REMOVED***
import re
import time
import hashlib
import threading

from base64 import b64encode

from .compat import urlparse, str
from .cookies import extract_cookies_to_jar
from .utils import parse_dict_header, to_native_string
from .status_codes import codes

CONTENT_TYPE_FORM_URLENCODED = 'application/x-www-form-urlencoded'
CONTENT_TYPE_MULTI_PART = 'multipart/form-data'


def _basic_auth_str(username, password***REMOVED***:
    ***REMOVED***Returns a Basic Auth string.***REMOVED***

    authstr = 'Basic ' + to_native_string(
        b64encode(('%s:%s' % (username, password***REMOVED******REMOVED***.encode('latin1'***REMOVED******REMOVED***.strip(***REMOVED***
    ***REMOVED***

    return authstr


class AuthBase(object***REMOVED***:
    ***REMOVED***Base class that all auth implementations derive from***REMOVED***

    def __call__(self, r***REMOVED***:
        raise NotImplementedError('Auth hooks must be callable.'***REMOVED***


class HTTPBasicAuth(AuthBase***REMOVED***:
    ***REMOVED***Attaches HTTP Basic Authentication to the given Request object.***REMOVED***

    def __init__(self, username, password***REMOVED***:
        self.username = username
        self.password = password

    def __eq__(self, other***REMOVED***:
        return all([
            self.username == getattr(other, 'username', None***REMOVED***,
            self.password == getattr(other, 'password', None***REMOVED***
        ***REMOVED******REMOVED***

    def __ne__(self, other***REMOVED***:
        return not self == other

    def __call__(self, r***REMOVED***:
        r.headers['Authorization'***REMOVED*** = _basic_auth_str(self.username, self.password***REMOVED***
        return r


class HTTPProxyAuth(HTTPBasicAuth***REMOVED***:
    ***REMOVED***Attaches HTTP Proxy Authentication to a given Request object.***REMOVED***

    def __call__(self, r***REMOVED***:
        r.headers['Proxy-Authorization'***REMOVED*** = _basic_auth_str(self.username, self.password***REMOVED***
        return r


class HTTPDigestAuth(AuthBase***REMOVED***:
    ***REMOVED***Attaches HTTP Digest Authentication to the given Request object.***REMOVED***

    def __init__(self, username, password***REMOVED***:
        self.username = username
        self.password = password
        # Keep state in per-thread local storage
        self._thread_local = threading.local(***REMOVED***

    def init_per_thread_state(self***REMOVED***:
        # Ensure state is initialized just once per-thread
        if not hasattr(self._thread_local, 'init'***REMOVED***:
            self._thread_local.init = True
            self._thread_local.last_nonce = ''
            self._thread_local.nonce_count = 0
            self._thread_local.chal = {***REMOVED***
            self._thread_local.pos = None
            self._thread_local.num_401_calls = None

    def build_digest_header(self, method, url***REMOVED***:
        ***REMOVED***
        :rtype: str
        ***REMOVED***

        realm = self._thread_local.chal['realm'***REMOVED***
        nonce = self._thread_local.chal['nonce'***REMOVED***
        qop = self._thread_local.chal.get('qop'***REMOVED***
        algorithm = self._thread_local.chal.get('algorithm'***REMOVED***
        opaque = self._thread_local.chal.get('opaque'***REMOVED***
        hash_utf8 = None

        if algorithm is None:
            _algorithm = 'MD5'
        else:
            _algorithm = algorithm.upper(***REMOVED***
        # lambdas assume digest modules are imported at the top level
        if _algorithm == 'MD5' or _algorithm == 'MD5-SESS':
            def md5_utf8(x***REMOVED***:
                if isinstance(x, str***REMOVED***:
                    x = x.encode('utf-8'***REMOVED***
                return hashlib.md5(x***REMOVED***.hexdigest(***REMOVED***
            hash_utf8 = md5_utf8
        elif _algorithm == 'SHA':
            def sha_utf8(x***REMOVED***:
                if isinstance(x, str***REMOVED***:
                    x = x.encode('utf-8'***REMOVED***
                return hashlib.sha1(x***REMOVED***.hexdigest(***REMOVED***
            hash_utf8 = sha_utf8

        KD = lambda s, d: hash_utf8("%s:%s" % (s, d***REMOVED******REMOVED***

        if hash_utf8 is None:
            return None

        # XXX not implemented yet
        entdig = None
        p_parsed = urlparse(url***REMOVED***
        #: path is request-uri defined in RFC 2616 which should not be empty
        path = p_parsed.path or "/"
        if p_parsed.query:
            path += '?' + p_parsed.query

        A1 = '%s:%s:%s' % (self.username, realm, self.password***REMOVED***
        A2 = '%s:%s' % (method, path***REMOVED***

        HA1 = hash_utf8(A1***REMOVED***
        HA2 = hash_utf8(A2***REMOVED***

        if nonce == self._thread_local.last_nonce:
            self._thread_local.nonce_count += 1
        else:
            self._thread_local.nonce_count = 1
        ncvalue = '%08x' % self._thread_local.nonce_count
        s = str(self._thread_local.nonce_count***REMOVED***.encode('utf-8'***REMOVED***
        s += nonce.encode('utf-8'***REMOVED***
        s += time.ctime(***REMOVED***.encode('utf-8'***REMOVED***
        s += os.urandom(8***REMOVED***

        cnonce = (hashlib.sha1(s***REMOVED***.hexdigest(***REMOVED***[:16***REMOVED******REMOVED***
        if _algorithm == 'MD5-SESS':
            HA1 = hash_utf8('%s:%s:%s' % (HA1, nonce, cnonce***REMOVED******REMOVED***

        if not qop:
            respdig = KD(HA1, "%s:%s" % (nonce, HA2***REMOVED******REMOVED***
        elif qop == 'auth' or 'auth' in qop.split(','***REMOVED***:
            noncebit = "%s:%s:%s:%s:%s" % (
                nonce, ncvalue, cnonce, 'auth', HA2
                ***REMOVED***
            respdig = KD(HA1, noncebit***REMOVED***
        else:
            # XXX handle auth-int.
            return None

        self._thread_local.last_nonce = nonce

        # XXX should the partial digests be encoded too?
        base = 'username="%s", realm="%s", nonce="%s", uri="%s", ' \
               'response="%s"' % (self.username, realm, nonce, path, respdig***REMOVED***
        if opaque:
            base += ', opaque="%s"' % opaque
        if algorithm:
            base += ', algorithm="%s"' % algorithm
        if entdig:
            base += ', digest="%s"' % entdig
        if qop:
            base += ', qop="auth", nc=%s, cnonce="%s"' % (ncvalue, cnonce***REMOVED***

        return 'Digest %s' % (base***REMOVED***

    def handle_redirect(self, r, **kwargs***REMOVED***:
        ***REMOVED***Reset num_401_calls counter on redirects.***REMOVED***
        if r.is_redirect:
            self._thread_local.num_401_calls = 1

    def handle_401(self, r, **kwargs***REMOVED***:
        ***REMOVED***
        Takes the given response and tries digest-auth, if needed.

        :rtype: requests.Response
        ***REMOVED***

        if self._thread_local.pos is not None:
            # Rewind the file position indicator of the body to where
            # it was to resend the request.
            r.request.body.seek(self._thread_local.pos***REMOVED***
        s_auth = r.headers.get('www-authenticate', ''***REMOVED***

        if 'digest' in s_auth.lower(***REMOVED*** and self._thread_local.num_401_calls < 2:

            self._thread_local.num_401_calls += 1
            pat = re.compile(r'digest ', flags=re.IGNORECASE***REMOVED***
            self._thread_local.chal = parse_dict_header(pat.sub('', s_auth, count=1***REMOVED******REMOVED***

            # Consume content and release the original connection
            # to allow our new request to reuse the same one.
            r.content
            r.close(***REMOVED***
            prep = r.request.copy(***REMOVED***
            extract_cookies_to_jar(prep._cookies, r.request, r.raw***REMOVED***
            prep.prepare_cookies(prep._cookies***REMOVED***

            prep.headers['Authorization'***REMOVED*** = self.build_digest_header(
                prep.method, prep.url***REMOVED***
            _r = r.connection.send(prep, **kwargs***REMOVED***
            _r.history.append(r***REMOVED***
            _r.request = prep

            return _r

        self._thread_local.num_401_calls = 1
        return r

    def __call__(self, r***REMOVED***:
        # Initialize per-thread state, if needed
        self.init_per_thread_state(***REMOVED***
        # If we have a saved nonce, skip the 401
        if self._thread_local.last_nonce:
            r.headers['Authorization'***REMOVED*** = self.build_digest_header(r.method, r.url***REMOVED***
        ***REMOVED***
            self._thread_local.pos = r.body.tell(***REMOVED***
        except AttributeError:
            # In the case of HTTPDigestAuth being reused and the body of
            # the previous request was a file-like object, pos has the
            # file position of the previous body. Ensure it's set to
            # None.
            self._thread_local.pos = None
        r.register_hook('response', self.handle_401***REMOVED***
        r.register_hook('response', self.handle_redirect***REMOVED***
        self._thread_local.num_401_calls = 1

        return r

    def __eq__(self, other***REMOVED***:
        return all([
            self.username == getattr(other, 'username', None***REMOVED***,
            self.password == getattr(other, 'password', None***REMOVED***
        ***REMOVED******REMOVED***

    def __ne__(self, other***REMOVED***:
        return not self == other
