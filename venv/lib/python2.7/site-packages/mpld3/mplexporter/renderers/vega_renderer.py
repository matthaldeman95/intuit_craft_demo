import warnings
import json
import random
from .base import Renderer
from ..exporter import Exporter


class VegaRenderer(Renderer***REMOVED***:
    def open_figure(self, fig, props***REMOVED***:
        self.props = props
        self.figwidth = int(props['figwidth'***REMOVED*** * props['dpi'***REMOVED******REMOVED***
        self.figheight = int(props['figheight'***REMOVED*** * props['dpi'***REMOVED******REMOVED***
        self.data = [***REMOVED***
        self.scales = [***REMOVED***
        self.axes = [***REMOVED***
        self.marks = [***REMOVED***
            
    def open_axes(self, ax, props***REMOVED***:
        if len(self.axes***REMOVED*** > 0:
            warnings.warn("multiple axes not yet supported"***REMOVED***
        self.axes = [dict(type="x", scale="x", ticks=10***REMOVED***,
                     dict(type="y", scale="y", ticks=10***REMOVED******REMOVED***
        self.scales = [dict(name="x",
                            domain=props['xlim'***REMOVED***,
                            type="linear",
                            range="width",
                        ***REMOVED***,
                       dict(name="y",
                            domain=props['ylim'***REMOVED***,
                            type="linear",
                            range="height",
                        ***REMOVED***,***REMOVED***

    def draw_line(self, data, coordinates, style, label, mplobj=None***REMOVED***:
        if coordinates != 'data':
            warnings.warn("Only data coordinates supported. Skipping this"***REMOVED***
        dataname = "table{0:03d***REMOVED***".format(len(self.data***REMOVED*** + 1***REMOVED***

        # TODO: respect the other style settings
        self.data.append({'name': dataname,
                          'values': [dict(x=d[0***REMOVED***, y=d[1***REMOVED******REMOVED*** for d in data***REMOVED******REMOVED******REMOVED***
        self.marks.append({'type': 'line',
                           'from': {'data': dataname***REMOVED***,
                           'properties': {
                               "enter": {
                                   "interpolate": {"value": "monotone"***REMOVED***,
                                   "x": {"scale": "x", "field": "data.x"***REMOVED***,
                                   "y": {"scale": "y", "field": "data.y"***REMOVED***,
                                   "stroke": {"value": style['color'***REMOVED******REMOVED***,
                                   "strokeOpacity": {"value": style['alpha'***REMOVED******REMOVED***,
                                   "strokeWidth": {"value": style['linewidth'***REMOVED******REMOVED***,
                           ***REMOVED***
                       ***REMOVED***
                   ***REMOVED******REMOVED***

    def draw_markers(self, data, coordinates, style, label, mplobj=None***REMOVED***:
        if coordinates != 'data':
            warnings.warn("Only data coordinates supported. Skipping this"***REMOVED***
        dataname = "table{0:03d***REMOVED***".format(len(self.data***REMOVED*** + 1***REMOVED***

        # TODO: respect the other style settings
        self.data.append({'name': dataname,
                          'values': [dict(x=d[0***REMOVED***, y=d[1***REMOVED******REMOVED*** for d in data***REMOVED******REMOVED******REMOVED***
        self.marks.append({'type': 'symbol',
                           'from': {'data': dataname***REMOVED***,
                           'properties': {
                               "enter": {
                                   "interpolate": {"value": "monotone"***REMOVED***,
                                   "x": {"scale": "x", "field": "data.x"***REMOVED***,
                                   "y": {"scale": "y", "field": "data.y"***REMOVED***,
                                   "fill": {"value": style['facecolor'***REMOVED******REMOVED***,
                                   "fillOpacity": {"value": style['alpha'***REMOVED******REMOVED***,
                                   "stroke": {"value": style['edgecolor'***REMOVED******REMOVED***,
                                   "strokeOpacity": {"value": style['alpha'***REMOVED******REMOVED***,
                                   "strokeWidth": {"value": style['edgewidth'***REMOVED******REMOVED***,
                           ***REMOVED***
                       ***REMOVED***
                   ***REMOVED******REMOVED***

    def draw_text(self, text, position, coordinates, style,
                  text_type=None, mplobj=None***REMOVED***:
        if text_type == 'xlabel':
            self.axes[0***REMOVED***['title'***REMOVED*** = text
        elif text_type == 'ylabel':
            self.axes[1***REMOVED***['title'***REMOVED*** = text


class VegaHTML(object***REMOVED***:
    def __init__(self, renderer***REMOVED***:
        self.specification = dict(width=renderer.figwidth,
                                  height=renderer.figheight,
                                  data=renderer.data,
                                  scales=renderer.scales,
                                  axes=renderer.axes,
                                  marks=renderer.marks***REMOVED***

    def html(self***REMOVED***:
        ***REMOVED***Build the HTML representation for IPython.***REMOVED***
        id = random.randint(0, 2 ** 16***REMOVED***
        html = '<div id="vis%d"></div>' % id
        html += '<script>\n'
        html += VEGA_TEMPLATE % (json.dumps(self.specification***REMOVED***, id***REMOVED***
        html += '</script>\n'
        return html

    def _repr_html_(self***REMOVED***:
        return self.html(***REMOVED***


def fig_to_vega(fig, notebook=False***REMOVED***:
    ***REMOVED***Convert a matplotlib figure to vega dictionary

    if notebook=True, then return an object which will display in a notebook
    otherwise, return an HTML string.
    ***REMOVED***
    renderer = VegaRenderer(***REMOVED***
    Exporter(renderer***REMOVED***.run(fig***REMOVED***
    vega_html = VegaHTML(renderer***REMOVED***
    if notebook:
        return vega_html
    else:
        return vega_html.html(***REMOVED***


VEGA_TEMPLATE = ***REMOVED***
( function(***REMOVED*** {
  var _do_plot = function(***REMOVED*** {
    if ( (typeof vg == 'undefined'***REMOVED*** && (typeof IPython != 'undefined'***REMOVED******REMOVED*** {
      $([IPython.events***REMOVED******REMOVED***.on("vega_loaded.vincent", _do_plot***REMOVED***;
      return;
***REMOVED***
    vg.parse.spec(%s, function(chart***REMOVED*** {
      chart({el: "#vis%d"***REMOVED******REMOVED***.update(***REMOVED***;
***REMOVED******REMOVED***;
  ***REMOVED***;
  _do_plot(***REMOVED***;
***REMOVED******REMOVED***(***REMOVED***;
***REMOVED***
