import warnings
import itertools
from contextlib import contextmanager

import numpy as np
from matplotlib import transforms

from .. import utils
from .. import _py3k_compat as py3k


class Renderer(object***REMOVED***:
    @staticmethod
    def ax_zoomable(ax***REMOVED***:
        return bool(ax and ax.get_navigate(***REMOVED******REMOVED***

    @staticmethod
    def ax_has_xgrid(ax***REMOVED***:
        return bool(ax and ax.xaxis._gridOnMajor and ax.yaxis.get_gridlines(***REMOVED******REMOVED***

    @staticmethod
    def ax_has_ygrid(ax***REMOVED***:
        return bool(ax and ax.yaxis._gridOnMajor and ax.yaxis.get_gridlines(***REMOVED******REMOVED***

    @property
    def current_ax_zoomable(self***REMOVED***:
        return self.ax_zoomable(self._current_ax***REMOVED***

    @property
    def current_ax_has_xgrid(self***REMOVED***:
        return self.ax_has_xgrid(self._current_ax***REMOVED***

    @property
    def current_ax_has_ygrid(self***REMOVED***:
        return self.ax_has_ygrid(self._current_ax***REMOVED***

    @contextmanager
    def draw_figure(self, fig, props***REMOVED***:
        if hasattr(self, "_current_fig"***REMOVED*** and self._current_fig is not None:
            warnings.warn("figure embedded in figure: something is wrong"***REMOVED***
        self._current_fig = fig
        self._fig_props = props
        self.open_figure(fig=fig, props=props***REMOVED***
        yield
        self.close_figure(fig=fig***REMOVED***
        self._current_fig = None
        self._fig_props = {***REMOVED***

    @contextmanager
    def draw_axes(self, ax, props***REMOVED***:
        if hasattr(self, "_current_ax"***REMOVED*** and self._current_ax is not None:
            warnings.warn("axes embedded in axes: something is wrong"***REMOVED***
        self._current_ax = ax
        self._ax_props = props
        self.open_axes(ax=ax, props=props***REMOVED***
        yield
        self.close_axes(ax=ax***REMOVED***
        self._current_ax = None
        self._ax_props = {***REMOVED***

    @contextmanager
    def draw_legend(self, legend, props***REMOVED***:
        self._current_legend = legend
        self._legend_props = props
        self.open_legend(legend=legend, props=props***REMOVED***
        yield
        self.close_legend(legend=legend***REMOVED***
        self._current_legend = None
        self._legend_props = {***REMOVED***

    # Following are the functions which should be overloaded in subclasses

    def open_figure(self, fig, props***REMOVED***:
        ***REMOVED***
        Begin commands for a particular figure.

        Parameters
        ----------
        fig : matplotlib.Figure
            The Figure which will contain the ensuing axes and elements
        props : dictionary
            The dictionary of figure properties
        ***REMOVED***
        pass

    def close_figure(self, fig***REMOVED***:
        ***REMOVED***
        Finish commands for a particular figure.

        Parameters
        ----------
        fig : matplotlib.Figure
            The figure which is finished being drawn.
        ***REMOVED***
        pass

    def open_axes(self, ax, props***REMOVED***:
        ***REMOVED***
        Begin commands for a particular axes.

        Parameters
        ----------
        ax : matplotlib.Axes
            The Axes which will contain the ensuing axes and elements
        props : dictionary
            The dictionary of axes properties
        ***REMOVED***
        pass

    def close_axes(self, ax***REMOVED***:
        ***REMOVED***
        Finish commands for a particular axes.

        Parameters
        ----------
        ax : matplotlib.Axes
            The Axes which is finished being drawn.
        ***REMOVED***
        pass

    def open_legend(self, legend, props***REMOVED***:
        ***REMOVED***
        Beging commands for a particular legend.

        Parameters
        ----------
        legend : matplotlib.legend.Legend
                The Legend that will contain the ensuing elements
        props : dictionary
                The dictionary of legend properties
        ***REMOVED***
        pass

    def close_legend(self, legend***REMOVED***:
        ***REMOVED***
        Finish commands for a particular legend.

        Parameters
        ----------
        legend : matplotlib.legend.Legend
                The Legend which is finished being drawn
        ***REMOVED***
        pass

    def draw_marked_line(self, data, coordinates, linestyle, markerstyle,
                         label, mplobj=None***REMOVED***:
        ***REMOVED***Draw a line that also has markers.

        If this isn't reimplemented by a renderer object, by default, it will
        make a call to BOTH draw_line and draw_markers when both markerstyle
        and linestyle are not None in the same Line2D object.

        ***REMOVED***
        if linestyle is not None:
            self.draw_line(data, coordinates, linestyle, label, mplobj***REMOVED***
        if markerstyle is not None:
            self.draw_markers(data, coordinates, markerstyle, label, mplobj***REMOVED***

    def draw_line(self, data, coordinates, style, label, mplobj=None***REMOVED***:
        ***REMOVED***
        Draw a line. By default, draw the line via the draw_path(***REMOVED*** command.
        Some renderers might wish to override this and provide more
        fine-grained behavior.

        In matplotlib, lines are generally created via the plt.plot(***REMOVED*** command,
        though this command also can create marker collections.

        Parameters
        ----------
        data : array_like
            A shape (N, 2***REMOVED*** array of datapoints.
        coordinates : string
            A string code, which should be either 'data' for data coordinates,
            or 'figure' for figure (pixel***REMOVED*** coordinates.
        style : dictionary
            a dictionary specifying the appearance of the line.
        mplobj : matplotlib object
            the matplotlib plot element which generated this line
        ***REMOVED***
        pathcodes = ['M'***REMOVED*** + (data.shape[0***REMOVED*** - 1***REMOVED*** * ['L'***REMOVED***
        pathstyle = dict(facecolor='none', **style***REMOVED***
        pathstyle['edgecolor'***REMOVED*** = pathstyle.pop('color'***REMOVED***
        pathstyle['edgewidth'***REMOVED*** = pathstyle.pop('linewidth'***REMOVED***
        self.draw_path(data=data, coordinates=coordinates,
                       pathcodes=pathcodes, style=pathstyle, mplobj=mplobj***REMOVED***

    @staticmethod
    def _iter_path_collection(paths, path_transforms, offsets, styles***REMOVED***:
        ***REMOVED***Build an iterator over the elements of the path collection***REMOVED***
        N = max(len(paths***REMOVED***, len(offsets***REMOVED******REMOVED***

        if not path_transforms:
            path_transforms = [np.eye(3***REMOVED******REMOVED***

        edgecolor = styles['edgecolor'***REMOVED***
        if np.size(edgecolor***REMOVED*** == 0:
            edgecolor = ['none'***REMOVED***
        facecolor = styles['facecolor'***REMOVED***
        if np.size(facecolor***REMOVED*** == 0:
            facecolor = ['none'***REMOVED***

        elements = [paths, path_transforms, offsets,
                    edgecolor, styles['linewidth'***REMOVED***, facecolor***REMOVED***

        it = itertools
        return it.islice(py3k.zip(*py3k.map(it.cycle, elements***REMOVED******REMOVED***, N***REMOVED***

    def draw_path_collection(self, paths, path_coordinates, path_transforms,
                             offsets, offset_coordinates, offset_order,
                             styles, mplobj=None***REMOVED***:
        ***REMOVED***
        Draw a collection of paths. The paths, offsets, and styles are all
        iterables, and the number of paths is max(len(paths***REMOVED***, len(offsets***REMOVED******REMOVED***.

        By default, this is implemented via multiple calls to the draw_path(***REMOVED***
        function. For efficiency, Renderers may choose to customize this
        implementation.

        Examples of path collections created by matplotlib are scatter plots,
        histograms, contour plots, and many others.

        Parameters
        ----------
        paths : list
            list of tuples, where each tuple has two elements:
            (data, pathcodes***REMOVED***.  See draw_path(***REMOVED*** for a description of these.
        path_coordinates: string
            the coordinates code for the paths, which should be either
            'data' for data coordinates, or 'figure' for figure (pixel***REMOVED***
            coordinates.
        path_transforms: array_like
            an array of shape (*, 3, 3***REMOVED***, giving a series of 2D Affine
            transforms for the paths. These encode translations, rotations,
            and scalings in the standard way.
        offsets: array_like
            An array of offsets of shape (N, 2***REMOVED***
        offset_coordinates : string
            the coordinates code for the offsets, which should be either
            'data' for data coordinates, or 'figure' for figure (pixel***REMOVED***
            coordinates.
        offset_order : string
            either "before" or "after". This specifies whether the offset
            is applied before the path transform, or after.  The matplotlib
            backend equivalent is "before"->"data", "after"->"screen".
        styles: dictionary
            A dictionary in which each value is a list of length N, containing
            the style(s***REMOVED*** for the paths.
        mplobj : matplotlib object
            the matplotlib plot element which generated this collection
        ***REMOVED***
        if offset_order == "before":
            raise NotImplementedError("offset before transform"***REMOVED***

        for tup in self._iter_path_collection(paths, path_transforms,
                                              offsets, styles***REMOVED***:
            (path, path_transform, offset, ec, lw, fc***REMOVED*** = tup
            vertices, pathcodes = path
            path_transform = transforms.Affine2D(path_transform***REMOVED***
            vertices = path_transform.transform(vertices***REMOVED***
            # This is a hack:
            if path_coordinates == "figure":
                path_coordinates = "points"
            style = {"edgecolor": utils.color_to_hex(ec***REMOVED***,
                     "facecolor": utils.color_to_hex(fc***REMOVED***,
                     "edgewidth": lw,
                     "dasharray": "10,0",
                     "alpha": styles['alpha'***REMOVED***,
                     "zorder": styles['zorder'***REMOVED******REMOVED***
            self.draw_path(data=vertices, coordinates=path_coordinates,
                           pathcodes=pathcodes, style=style, offset=offset,
                           offset_coordinates=offset_coordinates,
                           mplobj=mplobj***REMOVED***

    def draw_markers(self, data, coordinates, style, label, mplobj=None***REMOVED***:
        ***REMOVED***
        Draw a set of markers. By default, this is done by repeatedly
        calling draw_path(***REMOVED***, but renderers should generally overload
        this method to provide a more efficient implementation.

        In matplotlib, markers are created using the plt.plot(***REMOVED*** command.

        Parameters
        ----------
        data : array_like
            A shape (N, 2***REMOVED*** array of datapoints.
        coordinates : string
            A string code, which should be either 'data' for data coordinates,
            or 'figure' for figure (pixel***REMOVED*** coordinates.
        style : dictionary
            a dictionary specifying the appearance of the markers.
        mplobj : matplotlib object
            the matplotlib plot element which generated this marker collection
        ***REMOVED***
        vertices, pathcodes = style['markerpath'***REMOVED***
        pathstyle = dict((key, style[key***REMOVED******REMOVED*** for key in ['alpha', 'edgecolor',
                                                       'facecolor', 'zorder',
                                                       'edgewidth'***REMOVED******REMOVED***
        pathstyle['dasharray'***REMOVED*** = "10,0"
        for vertex in data:
            self.draw_path(data=vertices, coordinates="points",
                           pathcodes=pathcodes, style=pathstyle,
                           offset=vertex, offset_coordinates=coordinates,
                           mplobj=mplobj***REMOVED***

    def draw_text(self, text, position, coordinates, style,
                  text_type=None, mplobj=None***REMOVED***:
        ***REMOVED***
        Draw text on the image.

        Parameters
        ----------
        text : string
            The text to draw
        position : tuple
            The (x, y***REMOVED*** position of the text
        coordinates : string
            A string code, which should be either 'data' for data coordinates,
            or 'figure' for figure (pixel***REMOVED*** coordinates.
        style : dictionary
            a dictionary specifying the appearance of the text.
        text_type : string or None
            if specified, a type of text such as "xlabel", "ylabel", "title"
        mplobj : matplotlib object
            the matplotlib plot element which generated this text
        ***REMOVED***
        raise NotImplementedError(***REMOVED***

    def draw_path(self, data, coordinates, pathcodes, style,
                  offset=None, offset_coordinates="data", mplobj=None***REMOVED***:
        ***REMOVED***
        Draw a path.

        In matplotlib, paths are created by filled regions, histograms,
        contour plots, patches, etc.

        Parameters
        ----------
        data : array_like
            A shape (N, 2***REMOVED*** array of datapoints.
        coordinates : string
            A string code, which should be either 'data' for data coordinates,
            'figure' for figure (pixel***REMOVED*** coordinates, or "points" for raw
            point coordinates (useful in conjunction with offsets, below***REMOVED***.
        pathcodes : list
            A list of single-character SVG pathcodes associated with the data.
            Path codes are one of ['M', 'm', 'L', 'l', 'Q', 'q', 'T', 't',
                                   'S', 's', 'C', 'c', 'Z', 'z'***REMOVED***
            See the SVG specification for details.  Note that some path codes
            consume more than one datapoint (while 'Z' consumes none***REMOVED***, so
            in general, the length of the pathcodes list will not be the same
            as that of the data array.
        style : dictionary
            a dictionary specifying the appearance of the line.
        offset : list (optional***REMOVED***
            the (x, y***REMOVED*** offset of the path. If not given, no offset will
            be used.
        offset_coordinates : string (optional***REMOVED***
            A string code, which should be either 'data' for data coordinates,
            or 'figure' for figure (pixel***REMOVED*** coordinates.
        mplobj : matplotlib object
            the matplotlib plot element which generated this path
        ***REMOVED***
        raise NotImplementedError(***REMOVED***

    def draw_image(self, imdata, extent, coordinates, style, mplobj=None***REMOVED***:
        ***REMOVED***
        Draw an image.

        Parameters
        ----------
        imdata : string
            base64 encoded png representation of the image
        extent : list
            the axes extent of the image: [xmin, xmax, ymin, ymax***REMOVED***
        coordinates: string
            A string code, which should be either 'data' for data coordinates,
            or 'figure' for figure (pixel***REMOVED*** coordinates.
        style : dictionary
            a dictionary specifying the appearance of the image
        mplobj : matplotlib object
            the matplotlib plot object which generated this image
        ***REMOVED***
        raise NotImplementedError(***REMOVED***
