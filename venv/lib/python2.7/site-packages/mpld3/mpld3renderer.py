***REMOVED***
mpld3 renderer
==============

This is the renderer class which implements the mplexporter framework for mpld3
***REMOVED***
__all__ = ["MPLD3Renderer"***REMOVED***

import random
import json
import jinja2
import itertools

import numpy as np

from .mplexporter.utils import color_to_hex
from .mplexporter.exporter import Exporter
from .mplexporter.renderers import Renderer

from .utils import get_id
from .plugins import get_plugins


class MPLD3Renderer(Renderer***REMOVED***:
    ***REMOVED***Renderer class for mpld3

    This renderer class plugs into the ``mplexporter`` package in order to
    convert matplotlib figures into a JSON-serializable dictionary
    representation which can be read by mpld3.js.
    ***REMOVED***
    def __init__(self***REMOVED***:
        self.figure_json = None
        self.axes_json = None
        self.finished_figures = [***REMOVED***

    @staticmethod
    def datalabel(i***REMOVED***:
        return "data{0:02d***REMOVED***".format(i***REMOVED***

    def add_data(self, data, key="data"***REMOVED***:
        ***REMOVED***Add a dataset to the current figure

        If the dataset matches any already added data, we use that instead.

        Parameters
        ----------
        data : array_like
            a shape [N,2***REMOVED*** array of data
        key : string (optional***REMOVED***
            the key to use for the data

        Returns
        -------
        datadict : dictionary
            datadict has the keys "data", "xindex", "yindex", which will
            be passed to the mpld3 JSON object.
        ***REMOVED***
        # Check if any column of the data exists elsewhere
        # If so, we'll use that dataset rather than duplicating it.
        data = np.asarray(data***REMOVED***
        if data.ndim != 2 and data.shape[1***REMOVED*** != 2:
            raise ValueError("Data is expected to be of size [N, 2***REMOVED***"***REMOVED***

        for (i, d***REMOVED*** in enumerate(self.datasets***REMOVED***:
            if data.shape[0***REMOVED*** != d.shape[0***REMOVED***:
                continue

            matches = np.array([np.all(col == d.T, axis=1***REMOVED*** for col in data.T***REMOVED******REMOVED***
            if not np.any(matches***REMOVED***:
                continue

            # If we get here, we've found a dataset with a matching column
            # we'll update this data with additional columns if necessary
            new_data = list(self.datasets[i***REMOVED***.T***REMOVED***
            indices = [***REMOVED***
            for j in range(data.shape[1***REMOVED******REMOVED***:
                whr = np.where(matches[j***REMOVED******REMOVED***[0***REMOVED***
                if len(whr***REMOVED***:
                    indices.append(whr[0***REMOVED******REMOVED***
                else:
                    # append a new column to the data
                    new_data.append(data[:, j***REMOVED******REMOVED***
                    indices.append(len(new_data***REMOVED*** - 1***REMOVED***

            self.datasets[i***REMOVED*** = np.asarray(new_data***REMOVED***.T
            datalabel = self.datalabel(i + 1***REMOVED***
            xindex, yindex = map(int, indices***REMOVED***
            break
        else:
            # else here can be thought of as "if no break"
            # if we get here, then there were no matching datasets
            self.datasets.append(data***REMOVED***
            datalabel = self.datalabel(len(self.datasets***REMOVED******REMOVED***
            xindex = 0
            yindex = 1

        self.datalabels.append(datalabel***REMOVED***
        return {key: datalabel, "xindex": xindex, "yindex": yindex***REMOVED***

    def open_figure(self, fig, props***REMOVED***:
        self.datasets = [***REMOVED***
        self.datalabels = [***REMOVED***
        self.figure_json = dict(width=props['figwidth'***REMOVED*** * props['dpi'***REMOVED***,
                                height=props['figheight'***REMOVED*** * props['dpi'***REMOVED***,
                                axes=[***REMOVED***,
                                data={***REMOVED***,
                                id=get_id(fig***REMOVED******REMOVED***

    def close_figure(self, fig***REMOVED***:
        additional_css = [***REMOVED***
        additional_js = [***REMOVED***
        for i, dataset in enumerate(self.datasets***REMOVED***:
            datalabel = self.datalabel(i + 1***REMOVED***
            self.figure_json['data'***REMOVED***[datalabel***REMOVED*** = np.asarray(dataset***REMOVED***.tolist(***REMOVED***
        self.figure_json["plugins"***REMOVED*** = [***REMOVED***
        for plugin in get_plugins(fig***REMOVED***:
            self.figure_json["plugins"***REMOVED***.append(plugin.get_dict(***REMOVED******REMOVED***
            additional_css.append(plugin.css(***REMOVED******REMOVED***
            additional_js.append(plugin.javascript(***REMOVED******REMOVED***
        self.finished_figures.append((fig, self.figure_json,
                                      "".join(additional_css***REMOVED***,
                                      "".join(additional_js***REMOVED******REMOVED******REMOVED***

    def open_axes(self, ax, props***REMOVED***:
        self.axes_json = dict(bbox=props['bounds'***REMOVED***,
                              xlim=props['xlim'***REMOVED***,
                              ylim=props['ylim'***REMOVED***,
                              xdomain=props['xdomain'***REMOVED***,
                              ydomain=props['ydomain'***REMOVED***,
                              xscale=props['xscale'***REMOVED***,
                              yscale=props['yscale'***REMOVED***,
                              axes=props['axes'***REMOVED***,
                              axesbg=props['axesbg'***REMOVED***,
                              axesbgalpha=props['axesbgalpha'***REMOVED***,
                              zoomable=bool(props['dynamic'***REMOVED******REMOVED***,
                              id=get_id(ax***REMOVED***,
                              lines=[***REMOVED***,
                              paths=[***REMOVED***,
                              markers=[***REMOVED***,
                              texts=[***REMOVED***,
                              collections=[***REMOVED***,
                              images=[***REMOVED******REMOVED***
        self.figure_json['axes'***REMOVED***.append(self.axes_json***REMOVED***

        # Get shared axes info
        xsib = ax.get_shared_x_axes(***REMOVED***.get_siblings(ax***REMOVED***
        ysib = ax.get_shared_y_axes(***REMOVED***.get_siblings(ax***REMOVED***
        self.axes_json['sharex'***REMOVED*** = [get_id(axi***REMOVED*** for axi in xsib
                                    if axi is not ax***REMOVED***
        self.axes_json['sharey'***REMOVED*** = [get_id(axi***REMOVED*** for axi in ysib
                                    if axi is not ax***REMOVED***

    def close_axes(self, ax***REMOVED***:
        self.axes_json = None

    # If draw_line(***REMOVED*** is not implemented, it will be delegated to draw_path
    # Should we get rid of this? There's not really any advantage here
    def draw_line(self, data, coordinates, style, label, mplobj=None***REMOVED***:
        line = self.add_data(data***REMOVED***
        line['coordinates'***REMOVED*** = coordinates
        line['id'***REMOVED*** = get_id(mplobj***REMOVED***
        for key in ['color', 'linewidth', 'dasharray', 'alpha', 'zorder'***REMOVED***:
            line[key***REMOVED*** = style[key***REMOVED***
        self.axes_json['lines'***REMOVED***.append(line***REMOVED***

    def draw_path(self, data, coordinates, pathcodes, style,
                  offset=None, offset_coordinates="data", mplobj=None***REMOVED***:
        path = self.add_data(data***REMOVED***
        path['coordinates'***REMOVED*** = coordinates
        path['pathcodes'***REMOVED*** = pathcodes
        path['id'***REMOVED*** = get_id(mplobj***REMOVED***
        if offset is not None:
            path['offset'***REMOVED*** = list(offset***REMOVED***
            path['offsetcoordinates'***REMOVED*** = offset_coordinates

        for key in ['dasharray', 'alpha', 'facecolor',
                    'edgecolor', 'edgewidth', 'zorder'***REMOVED***:
            path[key***REMOVED*** = style[key***REMOVED***
        self.axes_json['paths'***REMOVED***.append(path***REMOVED***

    # If draw_markers is not implemented, it will be delegated to draw_path
    def draw_markers(self, data, coordinates, style, label, mplobj=None***REMOVED***:
        markers = self.add_data(data***REMOVED***
        markers["coordinates"***REMOVED*** = coordinates
        markers['id'***REMOVED*** = get_id(mplobj, 'pts'***REMOVED***
        for key in ['facecolor', 'edgecolor', 'edgewidth',
                    'alpha', 'zorder'***REMOVED***:
            markers[key***REMOVED*** = style[key***REMOVED***
        if style.get('markerpath'***REMOVED***:
            vertices, codes = style['markerpath'***REMOVED***
            markers['markerpath'***REMOVED*** = (vertices.tolist(***REMOVED***, codes***REMOVED***
        self.axes_json['markers'***REMOVED***.append(markers***REMOVED***

    # If draw_path_collection is not implemented,
    # it will be delegated to draw_path
    def draw_path_collection(self, paths, path_coordinates, path_transforms,
                             offsets, offset_coordinates, offset_order,
                             styles, mplobj=None***REMOVED***:
        styles = dict(alphas=[styles['alpha'***REMOVED******REMOVED***,
                      edgecolors=[color_to_hex(ec***REMOVED***
                                  for ec in styles['edgecolor'***REMOVED******REMOVED***,
                      facecolors=[color_to_hex(fc***REMOVED***
                                  for fc in styles['facecolor'***REMOVED******REMOVED***,
                      edgewidths=styles['linewidth'***REMOVED***,
                      offsetcoordinates=offset_coordinates,
                      pathcoordinates=path_coordinates,
                      zorder=styles['zorder'***REMOVED******REMOVED***

        pathsdict = self.add_data(offsets, "offsets"***REMOVED***
        pathsdict['paths'***REMOVED*** = [(v.tolist(***REMOVED***, p***REMOVED*** for (v, p***REMOVED*** in paths***REMOVED***
        pathsdict['pathtransforms'***REMOVED*** = [(t[0, :2***REMOVED***.tolist(***REMOVED***
                                        + t[1, :2***REMOVED***.tolist(***REMOVED***
                                        + t[2, :2***REMOVED***.tolist(***REMOVED******REMOVED***
                                       for t in path_transforms***REMOVED***
        pathsdict.update(styles***REMOVED***
        pathsdict['id'***REMOVED*** = get_id(mplobj***REMOVED***
        self.axes_json['collections'***REMOVED***.append(pathsdict***REMOVED***

    def draw_text(self, text, position, coordinates, style,
                  text_type=None, mplobj=None***REMOVED***:
        text = dict(text=text,
                    position=tuple(position***REMOVED***,
                    coordinates=coordinates,
                    h_anchor=TEXT_HA_DICT[style['halign'***REMOVED******REMOVED***,
                    v_baseline=TEXT_VA_DICT[style['valign'***REMOVED******REMOVED***,
                    rotation=-style['rotation'***REMOVED***,
                    fontsize=style['fontsize'***REMOVED***,
                    color=style['color'***REMOVED***,
                    alpha=style['alpha'***REMOVED***,
                    zorder=style['zorder'***REMOVED***,
                    id=get_id(mplobj***REMOVED******REMOVED***
        self.axes_json['texts'***REMOVED***.append(text***REMOVED***

    def draw_image(self, imdata, extent, coordinates, style, mplobj=None***REMOVED***:
        image = dict(data=imdata, extent=extent, coordinates=coordinates***REMOVED***
        image.update(style***REMOVED***
        image['id'***REMOVED*** = get_id(mplobj***REMOVED***
        self.axes_json['images'***REMOVED***.append(image***REMOVED***


TEXT_VA_DICT = {'bottom': 'auto',
                'baseline': 'auto',
                'center': 'central',
                'top': 'hanging'***REMOVED***
TEXT_HA_DICT = {'left': 'start',
                'center': 'middle',
                'right': 'end'***REMOVED***
