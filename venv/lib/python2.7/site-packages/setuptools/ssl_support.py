***REMOVED***
import socket
import atexit
import re

from setuptools.extern.six.moves import urllib, http_client, map

import pkg_resources
from pkg_resources import ResolutionError, ExtractionError

***REMOVED***
    import ssl
except ImportError:
    ssl = None

__all__ = [
    'VerifyingHTTPSHandler', 'find_ca_bundle', 'is_available', 'cert_paths',
    'opener_for'
***REMOVED***

cert_paths = ***REMOVED***
/etc/pki/tls/certs/ca-bundle.crt
/etc/ssl/certs/ca-certificates.crt
/usr/share/ssl/certs/ca-bundle.crt
/usr/local/share/certs/ca-root.crt
/etc/ssl/cert.pem
/System/Library/OpenSSL/certs/cert.pem
/usr/local/share/certs/ca-root-nss.crt
/etc/ssl/ca-bundle.pem
***REMOVED***.strip(***REMOVED***.split(***REMOVED***

***REMOVED***
    HTTPSHandler = urllib.request.HTTPSHandler
    HTTPSConnection = http_client.HTTPSConnection
except AttributeError:
    HTTPSHandler = HTTPSConnection = object

is_available = ssl is not None and object not in (HTTPSHandler, HTTPSConnection***REMOVED***


***REMOVED***
    from ssl import CertificateError, match_hostname
except ImportError:
    ***REMOVED***
        from backports.ssl_match_hostname import CertificateError
        from backports.ssl_match_hostname import match_hostname
    except ImportError:
        CertificateError = None
        match_hostname = None

if not CertificateError:

    class CertificateError(ValueError***REMOVED***:
        pass


if not match_hostname:

    def _dnsname_match(dn, hostname, max_wildcards=1***REMOVED***:
        ***REMOVED***Matching according to RFC 6125, section 6.4.3

        http://tools.ietf.org/html/rfc6125#section-6.4.3
        ***REMOVED***
        pats = [***REMOVED***
        if not dn:
            return False

        # Ported from python3-syntax:
        # leftmost, *remainder = dn.split(r'.'***REMOVED***
        parts = dn.split(r'.'***REMOVED***
        leftmost = parts[0***REMOVED***
        remainder = parts[1:***REMOVED***

        wildcards = leftmost.count('*'***REMOVED***
        if wildcards > max_wildcards:
            # Issue #17980: avoid denials of service by refusing more
            # than one wildcard per fragment.  A survey of established
            # policy among SSL implementations showed it to be a
            # reasonable choice.
            raise CertificateError(
                "too many wildcards in certificate DNS name: " + repr(dn***REMOVED******REMOVED***

        # speed up common case w/o wildcards
        if not wildcards:
            return dn.lower(***REMOVED*** == hostname.lower(***REMOVED***

        # RFC 6125, section 6.4.3, subitem 1.
        # The client SHOULD NOT attempt to match a presented identifier in which
        # the wildcard character comprises a label other than the left-most label.
        if leftmost == '*':
            # When '*' is a fragment by itself, it matches a non-empty dotless
            # fragment.
            pats.append('[^.***REMOVED***+'***REMOVED***
        elif leftmost.startswith('xn--'***REMOVED*** or hostname.startswith('xn--'***REMOVED***:
            # RFC 6125, section 6.4.3, subitem 3.
            # The client SHOULD NOT attempt to match a presented identifier
            # where the wildcard character is embedded within an A-label or
            # U-label of an internationalized domain name.
            pats.append(re.escape(leftmost***REMOVED******REMOVED***
        else:
            # Otherwise, '*' matches any dotless string, e.g. www*
            pats.append(re.escape(leftmost***REMOVED***.replace(r'\*', '[^.***REMOVED****'***REMOVED******REMOVED***

        # add the remaining fragments, ignore any wildcards
        for frag in remainder:
            pats.append(re.escape(frag***REMOVED******REMOVED***

        pat = re.compile(r'\A' + r'\.'.join(pats***REMOVED*** + r'\Z', re.IGNORECASE***REMOVED***
        return pat.match(hostname***REMOVED***

    def match_hostname(cert, hostname***REMOVED***:
        ***REMOVED***Verify that *cert* (in decoded format as returned by
        SSLSocket.getpeercert(***REMOVED******REMOVED*** matches the *hostname*.  RFC 2818 and RFC 6125
        rules are followed, but IP addresses are not accepted for *hostname*.

        CertificateError is raised on failure. On success, the function
        returns nothing.
        ***REMOVED***
        if not cert:
            raise ValueError("empty or no certificate"***REMOVED***
        dnsnames = [***REMOVED***
        san = cert.get('subjectAltName', (***REMOVED******REMOVED***
        for key, value in san:
            if key == 'DNS':
                if _dnsname_match(value, hostname***REMOVED***:
                    return
                dnsnames.append(value***REMOVED***
        if not dnsnames:
            # The subject is only checked when there is no dNSName entry
            # in subjectAltName
            for sub in cert.get('subject', (***REMOVED******REMOVED***:
                for key, value in sub:
                    # XXX according to RFC 2818, the most specific Common Name
                    # must be used.
                    if key == 'commonName':
                        if _dnsname_match(value, hostname***REMOVED***:
                            return
                        dnsnames.append(value***REMOVED***
        if len(dnsnames***REMOVED*** > 1:
            raise CertificateError("hostname %r "
                "doesn't match either of %s"
                % (hostname, ', '.join(map(repr, dnsnames***REMOVED******REMOVED******REMOVED******REMOVED***
        elif len(dnsnames***REMOVED*** == 1:
            raise CertificateError("hostname %r "
                "doesn't match %r"
                % (hostname, dnsnames[0***REMOVED******REMOVED******REMOVED***
        else:
            raise CertificateError("no appropriate commonName or "
                "subjectAltName fields were found"***REMOVED***


class VerifyingHTTPSHandler(HTTPSHandler***REMOVED***:
    ***REMOVED***Simple verifying handler: no auth, subclasses, timeouts, etc.***REMOVED***

    def __init__(self, ca_bundle***REMOVED***:
        self.ca_bundle = ca_bundle
        HTTPSHandler.__init__(self***REMOVED***

    def https_open(self, req***REMOVED***:
        return self.do_open(
            lambda host, **kw: VerifyingHTTPSConn(host, self.ca_bundle, **kw***REMOVED***, req
        ***REMOVED***


class VerifyingHTTPSConn(HTTPSConnection***REMOVED***:
    ***REMOVED***Simple verifying connection: no auth, subclasses, timeouts, etc.***REMOVED***

    def __init__(self, host, ca_bundle, **kw***REMOVED***:
        HTTPSConnection.__init__(self, host, **kw***REMOVED***
        self.ca_bundle = ca_bundle

    def connect(self***REMOVED***:
        sock = socket.create_connection(
            (self.host, self.port***REMOVED***, getattr(self, 'source_address', None***REMOVED***
        ***REMOVED***

        # Handle the socket if a (proxy***REMOVED*** tunnel is present
        if hasattr(self, '_tunnel'***REMOVED*** and getattr(self, '_tunnel_host', None***REMOVED***:
            self.sock = sock
            self._tunnel(***REMOVED***
            # http://bugs.python.org/issue7776: Python>=3.4.1 and >=2.7.7
            # change self.host to mean the proxy server host when tunneling is
            # being used. Adapt, since we are interested in the destination
            # host for the match_hostname(***REMOVED*** comparison.
            actual_host = self._tunnel_host
        else:
            actual_host = self.host

        self.sock = ssl.wrap_socket(
            sock, cert_reqs=ssl.CERT_REQUIRED, ca_certs=self.ca_bundle
        ***REMOVED***
        ***REMOVED***
            match_hostname(self.sock.getpeercert(***REMOVED***, actual_host***REMOVED***
        except CertificateError:
            self.sock.shutdown(socket.SHUT_RDWR***REMOVED***
            self.sock.close(***REMOVED***
            raise


def opener_for(ca_bundle=None***REMOVED***:
    ***REMOVED***Get a urlopen(***REMOVED*** replacement that uses ca_bundle for verification***REMOVED***
    return urllib.request.build_opener(
        VerifyingHTTPSHandler(ca_bundle or find_ca_bundle(***REMOVED******REMOVED***
    ***REMOVED***.open


_wincerts = None


def get_win_certfile(***REMOVED***:
    global _wincerts
    if _wincerts is not None:
        return _wincerts.name

    ***REMOVED***
        from wincertstore import CertFile
    except ImportError:
        return None

    class MyCertFile(CertFile***REMOVED***:
        def __init__(self, stores=(***REMOVED***, certs=(***REMOVED******REMOVED***:
            CertFile.__init__(self***REMOVED***
            for store in stores:
                self.addstore(store***REMOVED***
            self.addcerts(certs***REMOVED***
            atexit.register(self.close***REMOVED***

        def close(self***REMOVED***:
            ***REMOVED***
                super(MyCertFile, self***REMOVED***.close(***REMOVED***
            except OSError:
                pass

    _wincerts = MyCertFile(stores=['CA', 'ROOT'***REMOVED******REMOVED***
    return _wincerts.name


def find_ca_bundle(***REMOVED***:
    ***REMOVED***Return an existing CA bundle path, or None***REMOVED***
    if os.name == 'nt':
        return get_win_certfile(***REMOVED***
    else:
        for cert_path in cert_paths:
            if os.path.isfile(cert_path***REMOVED***:
                return cert_path
    ***REMOVED***
        import certifi
        return certifi.where(***REMOVED***
    except (ImportError, ResolutionError, ExtractionError***REMOVED***:
        return None
