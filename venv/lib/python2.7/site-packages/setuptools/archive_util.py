***REMOVED***Utilities for extracting common archive formats***REMOVED***

import zipfile
import tarfile
***REMOVED***
import shutil
import posixpath
import contextlib
from distutils.errors import DistutilsError

from pkg_resources import ensure_directory, ContextualZipFile

__all__ = [
    "unpack_archive", "unpack_zipfile", "unpack_tarfile", "default_filter",
    "UnrecognizedFormat", "extraction_drivers", "unpack_directory",
***REMOVED***


class UnrecognizedFormat(DistutilsError***REMOVED***:
    ***REMOVED***Couldn't recognize the archive type***REMOVED***


def default_filter(src, dst***REMOVED***:
    ***REMOVED***The default progress/filter callback; returns True for all files***REMOVED***
    return dst


def unpack_archive(filename, extract_dir, progress_filter=default_filter,
        drivers=None***REMOVED***:
    ***REMOVED***Unpack `filename` to `extract_dir`, or raise ``UnrecognizedFormat``

    `progress_filter` is a function taking two arguments: a source path
    internal to the archive ('/'-separated***REMOVED***, and a filesystem path where it
    will be extracted.  The callback must return the desired extract path
    (which may be the same as the one passed in***REMOVED***, or else ``None`` to skip
    that file or directory.  The callback can thus be used to report on the
    progress of the extraction, as well as to filter the items extracted or
    alter their extraction paths.

    `drivers`, if supplied, must be a non-empty sequence of functions with the
    same signature as this function (minus the `drivers` argument***REMOVED***, that raise
    ``UnrecognizedFormat`` if they do not support extracting the designated
    archive type.  The `drivers` are tried in sequence until one is found that
    does not raise an error, or until all are exhausted (in which case
    ``UnrecognizedFormat`` is raised***REMOVED***.  If you do not supply a sequence of
    drivers, the module's ``extraction_drivers`` constant will be used, which
    means that ``unpack_zipfile`` and ``unpack_tarfile`` will be tried, in that
    order.
    ***REMOVED***
    for driver in drivers or extraction_drivers:
        ***REMOVED***
            driver(filename, extract_dir, progress_filter***REMOVED***
        except UnrecognizedFormat:
            continue
        else:
            return
    else:
        raise UnrecognizedFormat(
            "Not a recognized archive type: %s" % filename
        ***REMOVED***


def unpack_directory(filename, extract_dir, progress_filter=default_filter***REMOVED***:
    ***REMOVED***"Unpack" a directory, using the same interface as for archives

    Raises ``UnrecognizedFormat`` if `filename` is not a directory
    ***REMOVED***
    if not os.path.isdir(filename***REMOVED***:
        raise UnrecognizedFormat("%s is not a directory" % filename***REMOVED***

    paths = {
        filename: ('', extract_dir***REMOVED***,
***REMOVED***
    for base, dirs, files in os.walk(filename***REMOVED***:
        src, dst = paths[base***REMOVED***
        for d in dirs:
            paths[os.path.join(base, d***REMOVED******REMOVED*** = src + d + '/', os.path.join(dst, d***REMOVED***
        for f in files:
            target = os.path.join(dst, f***REMOVED***
            target = progress_filter(src + f, target***REMOVED***
            if not target:
                # skip non-files
                continue
            ensure_directory(target***REMOVED***
            f = os.path.join(base, f***REMOVED***
            shutil.copyfile(f, target***REMOVED***
            shutil.copystat(f, target***REMOVED***


def unpack_zipfile(filename, extract_dir, progress_filter=default_filter***REMOVED***:
    ***REMOVED***Unpack zip `filename` to `extract_dir`

    Raises ``UnrecognizedFormat`` if `filename` is not a zipfile (as determined
    by ``zipfile.is_zipfile(***REMOVED***``***REMOVED***.  See ``unpack_archive(***REMOVED***`` for an explanation
    of the `progress_filter` argument.
    ***REMOVED***

    if not zipfile.is_zipfile(filename***REMOVED***:
        raise UnrecognizedFormat("%s is not a zip file" % (filename,***REMOVED******REMOVED***

    with ContextualZipFile(filename***REMOVED*** as z:
        for info in z.infolist(***REMOVED***:
            name = info.filename

            # don't extract absolute paths or ones with .. in them
            if name.startswith('/'***REMOVED*** or '..' in name.split('/'***REMOVED***:
                continue

            target = os.path.join(extract_dir, *name.split('/'***REMOVED******REMOVED***
            target = progress_filter(name, target***REMOVED***
            if not target:
                continue
            if name.endswith('/'***REMOVED***:
                # directory
                ensure_directory(target***REMOVED***
            else:
                # file
                ensure_directory(target***REMOVED***
                data = z.read(info.filename***REMOVED***
                with open(target, 'wb'***REMOVED*** as f:
                    f.write(data***REMOVED***
            unix_attributes = info.external_attr >> 16
            if unix_attributes:
                os.chmod(target, unix_attributes***REMOVED***


def unpack_tarfile(filename, extract_dir, progress_filter=default_filter***REMOVED***:
    ***REMOVED***Unpack tar/tar.gz/tar.bz2 `filename` to `extract_dir`

    Raises ``UnrecognizedFormat`` if `filename` is not a tarfile (as determined
    by ``tarfile.open(***REMOVED***``***REMOVED***.  See ``unpack_archive(***REMOVED***`` for an explanation
    of the `progress_filter` argument.
    ***REMOVED***
    ***REMOVED***
        tarobj = tarfile.open(filename***REMOVED***
    except tarfile.TarError:
        raise UnrecognizedFormat(
            "%s is not a compressed or uncompressed tar file" % (filename,***REMOVED***
        ***REMOVED***
    with contextlib.closing(tarobj***REMOVED***:
        # don't do any chowning!
        tarobj.chown = lambda *args: None
        for member in tarobj:
            name = member.name
            # don't extract absolute paths or ones with .. in them
            if not name.startswith('/'***REMOVED*** and '..' not in name.split('/'***REMOVED***:
                prelim_dst = os.path.join(extract_dir, *name.split('/'***REMOVED******REMOVED***

                # resolve any links and to extract the link targets as normal
                # files
                while member is not None and (member.islnk(***REMOVED*** or member.issym(***REMOVED******REMOVED***:
                    linkpath = member.linkname
                    if member.issym(***REMOVED***:
                        base = posixpath.dirname(member.name***REMOVED***
                        linkpath = posixpath.join(base, linkpath***REMOVED***
                        linkpath = posixpath.normpath(linkpath***REMOVED***
                    member = tarobj._getmember(linkpath***REMOVED***

                if member is not None and (member.isfile(***REMOVED*** or member.isdir(***REMOVED******REMOVED***:
                    final_dst = progress_filter(name, prelim_dst***REMOVED***
                    if final_dst:
                        if final_dst.endswith(os.sep***REMOVED***:
                            final_dst = final_dst[:-1***REMOVED***
                        ***REMOVED***
                            # XXX Ugh
                            tarobj._extract_member(member, final_dst***REMOVED***
                        except tarfile.ExtractError:
                            # chown/chmod/mkfifo/mknode/makedev failed
                            pass
        return True


extraction_drivers = unpack_directory, unpack_zipfile, unpack_tarfile
