import re
import functools
import distutils.core
import distutils.errors
import distutils.extension

from setuptools.extern.six.moves import map

from .monkey import get_unpatched


def _have_cython(***REMOVED***:
    ***REMOVED***
    Return True if Cython can be imported.
    ***REMOVED***
    cython_impl = 'Cython.Distutils.build_ext'
    ***REMOVED***
        # from (cython_impl***REMOVED*** import build_ext
        __import__(cython_impl, fromlist=['build_ext'***REMOVED******REMOVED***.build_ext
        return True
    except Exception:
        pass
    return False


# for compatibility
have_pyrex = _have_cython

_Extension = get_unpatched(distutils.core.Extension***REMOVED***


class Extension(_Extension***REMOVED***:
    ***REMOVED***Extension that uses '.c' files in place of '.pyx' files***REMOVED***

    def __init__(self, name, sources, *args, **kw***REMOVED***:
        # The *args is needed for compatibility as calls may use positional
        # arguments. py_limited_api may be set only via keyword.
        self.py_limited_api = kw.pop("py_limited_api", False***REMOVED***
        _Extension.__init__(self, name, sources, *args, **kw***REMOVED***

    def _convert_pyx_sources_to_lang(self***REMOVED***:
        ***REMOVED***
        Replace sources with .pyx extensions to sources with the target
        language extension. This mechanism allows language authors to supply
        pre-converted sources but to prefer the .pyx sources.
        ***REMOVED***
        if _have_cython(***REMOVED***:
            # the build has Cython, so allow it to compile the .pyx files
            return
        lang = self.language or ''
        target_ext = '.cpp' if lang.lower(***REMOVED*** == 'c++' else '.c'
        sub = functools.partial(re.sub, '.pyx$', target_ext***REMOVED***
        self.sources = list(map(sub, self.sources***REMOVED******REMOVED***


class Library(Extension***REMOVED***:
    ***REMOVED***Just like a regular Extension, but built as a library instead***REMOVED***
