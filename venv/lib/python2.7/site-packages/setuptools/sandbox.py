***REMOVED***
import sys
import tempfile
import operator
import functools
import itertools
import re
import contextlib
import pickle

from setuptools.extern import six
from setuptools.extern.six.moves import builtins, map

import pkg_resources

if sys.platform.startswith('java'***REMOVED***:
    import org.python.modules.posix.PosixModule as _os
else:
    _os = sys.modules[os.name***REMOVED***
***REMOVED***
    _file = file
except NameError:
    _file = None
_open = open
from distutils.errors import DistutilsError
from pkg_resources import working_set

__all__ = [
    "AbstractSandbox", "DirectorySandbox", "SandboxViolation", "run_setup",
***REMOVED***


def _execfile(filename, globals, locals=None***REMOVED***:
    ***REMOVED***
    Python 3 implementation of execfile.
    ***REMOVED***
    mode = 'rb'
    with open(filename, mode***REMOVED*** as stream:
        script = stream.read(***REMOVED***
    # compile(***REMOVED*** function in Python 2.6 and 3.1 requires LF line endings.
    if sys.version_info[:2***REMOVED*** < (2, 7***REMOVED*** or sys.version_info[:2***REMOVED*** >= (3, 0***REMOVED*** and sys.version_info[:2***REMOVED*** < (3, 2***REMOVED***:
        script = script.replace(b'\r\n', b'\n'***REMOVED***
        script = script.replace(b'\r', b'\n'***REMOVED***
    if locals is None:
        locals = globals
    code = compile(script, filename, 'exec'***REMOVED***
    exec(code, globals, locals***REMOVED***


@contextlib.contextmanager
def save_argv(repl=None***REMOVED***:
    saved = sys.argv[:***REMOVED***
    if repl is not None:
        sys.argv[:***REMOVED*** = repl
    ***REMOVED***
        yield saved
    finally:
        sys.argv[:***REMOVED*** = saved


@contextlib.contextmanager
def save_path(***REMOVED***:
    saved = sys.path[:***REMOVED***
    ***REMOVED***
        yield saved
    finally:
        sys.path[:***REMOVED*** = saved


@contextlib.contextmanager
def override_temp(replacement***REMOVED***:
    ***REMOVED***
    Monkey-patch tempfile.tempdir with replacement, ensuring it exists
    ***REMOVED***
    if not os.path.isdir(replacement***REMOVED***:
        os.makedirs(replacement***REMOVED***

    saved = tempfile.tempdir

    tempfile.tempdir = replacement

    ***REMOVED***
        yield
    finally:
        tempfile.tempdir = saved


@contextlib.contextmanager
def pushd(target***REMOVED***:
    saved = os.getcwd(***REMOVED***
    os.chdir(target***REMOVED***
    ***REMOVED***
        yield saved
    finally:
        os.chdir(saved***REMOVED***


class UnpickleableException(Exception***REMOVED***:
    ***REMOVED***
    An exception representing another Exception that could not be pickled.
    ***REMOVED***

    @staticmethod
    def dump(type, exc***REMOVED***:
        ***REMOVED***
        Always return a dumped (pickled***REMOVED*** type and exc. If exc can't be pickled,
        wrap it in UnpickleableException first.
        ***REMOVED***
        ***REMOVED***
            return pickle.dumps(type***REMOVED***, pickle.dumps(exc***REMOVED***
        except Exception:
            # get UnpickleableException inside the sandbox
            from setuptools.sandbox import UnpickleableException as cls
            return cls.dump(cls, cls(repr(exc***REMOVED******REMOVED******REMOVED***


class ExceptionSaver:
    ***REMOVED***
    A Context Manager that will save an exception, serialized, and restore it
    later.
    ***REMOVED***

    def __enter__(self***REMOVED***:
        return self

    def __exit__(self, type, exc, tb***REMOVED***:
        if not exc:
            return

        # dump the exception
        self._saved = UnpickleableException.dump(type, exc***REMOVED***
        self._tb = tb

        # suppress the exception
        return True

    def resume(self***REMOVED***:
        "restore and re-raise any exception"

        if '_saved' not in vars(self***REMOVED***:
            return

        type, exc = map(pickle.loads, self._saved***REMOVED***
        six.reraise(type, exc, self._tb***REMOVED***


@contextlib.contextmanager
def save_modules(***REMOVED***:
    ***REMOVED***
    Context in which imported modules are saved.

    Translates exceptions internal to the context into the equivalent exception
    outside the context.
    ***REMOVED***
    saved = sys.modules.copy(***REMOVED***
    with ExceptionSaver(***REMOVED*** as saved_exc:
        yield saved

    sys.modules.update(saved***REMOVED***
    # remove any modules imported since
    del_modules = (
        mod_name for mod_name in sys.modules
        if mod_name not in saved
        # exclude any encodings modules. See #285
        and not mod_name.startswith('encodings.'***REMOVED***
    ***REMOVED***
    _clear_modules(del_modules***REMOVED***

    saved_exc.resume(***REMOVED***


def _clear_modules(module_names***REMOVED***:
    for mod_name in list(module_names***REMOVED***:
        del sys.modules[mod_name***REMOVED***


@contextlib.contextmanager
def save_pkg_resources_state(***REMOVED***:
    saved = pkg_resources.__getstate__(***REMOVED***
    ***REMOVED***
        yield saved
    finally:
        pkg_resources.__setstate__(saved***REMOVED***


@contextlib.contextmanager
def setup_context(setup_dir***REMOVED***:
    temp_dir = os.path.join(setup_dir, 'temp'***REMOVED***
    with save_pkg_resources_state(***REMOVED***:
        with save_modules(***REMOVED***:
            hide_setuptools(***REMOVED***
            with save_path(***REMOVED***:
                with save_argv(***REMOVED***:
                    with override_temp(temp_dir***REMOVED***:
                        with pushd(setup_dir***REMOVED***:
                            # ensure setuptools commands are available
                            __import__('setuptools'***REMOVED***
                            yield


def _needs_hiding(mod_name***REMOVED***:
    ***REMOVED***
    >>> _needs_hiding('setuptools'***REMOVED***
    True
    >>> _needs_hiding('pkg_resources'***REMOVED***
    True
    >>> _needs_hiding('setuptools_plugin'***REMOVED***
    False
    >>> _needs_hiding('setuptools.__init__'***REMOVED***
    True
    >>> _needs_hiding('distutils'***REMOVED***
    True
    >>> _needs_hiding('os'***REMOVED***
    False
    >>> _needs_hiding('Cython'***REMOVED***
    True
    ***REMOVED***
    pattern = re.compile('(setuptools|pkg_resources|distutils|Cython***REMOVED***(\.|$***REMOVED***'***REMOVED***
    return bool(pattern.match(mod_name***REMOVED******REMOVED***


def hide_setuptools(***REMOVED***:
    ***REMOVED***
    Remove references to setuptools' modules from sys.modules to allow the
    invocation to import the most appropriate setuptools. This technique is
    necessary to avoid issues such as #315 where setuptools upgrading itself
    would fail to find a function declared in the metadata.
    ***REMOVED***
    modules = filter(_needs_hiding, sys.modules***REMOVED***
    _clear_modules(modules***REMOVED***


def run_setup(setup_script, args***REMOVED***:
    ***REMOVED***Run a distutils setup script, sandboxed in its directory***REMOVED***
    setup_dir = os.path.abspath(os.path.dirname(setup_script***REMOVED******REMOVED***
    with setup_context(setup_dir***REMOVED***:
        ***REMOVED***
            sys.argv[:***REMOVED*** = [setup_script***REMOVED*** + list(args***REMOVED***
            sys.path.insert(0, setup_dir***REMOVED***
            # reset to include setup dir, w/clean callback list
            working_set.__init__(***REMOVED***
            working_set.callbacks.append(lambda dist: dist.activate(***REMOVED******REMOVED***

            def runner(***REMOVED***:
                ns = dict(__file__=setup_script, __name__='__main__'***REMOVED***
                _execfile(setup_script, ns***REMOVED***

            DirectorySandbox(setup_dir***REMOVED***.run(runner***REMOVED***
        except SystemExit as v:
            if v.args and v.args[0***REMOVED***:
                raise
            # Normal exit, just return


class AbstractSandbox:
    ***REMOVED***Wrap 'os' module and 'open(***REMOVED***' builtin for virtualizing setup scripts***REMOVED***

    _active = False

    def __init__(self***REMOVED***:
        self._attrs = [
            name for name in dir(_os***REMOVED***
            if not name.startswith('_'***REMOVED*** and hasattr(self, name***REMOVED***
        ***REMOVED***

    def _copy(self, source***REMOVED***:
        for name in self._attrs:
            setattr(os, name, getattr(source, name***REMOVED******REMOVED***

    def run(self, func***REMOVED***:
        ***REMOVED***Run 'func' under os sandboxing***REMOVED***
        ***REMOVED***
            self._copy(self***REMOVED***
            if _file:
                builtins.file = self._file
            builtins.open = self._open
            self._active = True
            return func(***REMOVED***
        finally:
            self._active = False
            if _file:
                builtins.file = _file
            builtins.open = _open
            self._copy(_os***REMOVED***

    def _mk_dual_path_wrapper(name***REMOVED***:
        original = getattr(_os, name***REMOVED***

        def wrap(self, src, dst, *args, **kw***REMOVED***:
            if self._active:
                src, dst = self._remap_pair(name, src, dst, *args, **kw***REMOVED***
            return original(src, dst, *args, **kw***REMOVED***

        return wrap

    for name in ["rename", "link", "symlink"***REMOVED***:
        if hasattr(_os, name***REMOVED***:
            locals(***REMOVED***[name***REMOVED*** = _mk_dual_path_wrapper(name***REMOVED***

    def _mk_single_path_wrapper(name, original=None***REMOVED***:
        original = original or getattr(_os, name***REMOVED***

        def wrap(self, path, *args, **kw***REMOVED***:
            if self._active:
                path = self._remap_input(name, path, *args, **kw***REMOVED***
            return original(path, *args, **kw***REMOVED***

        return wrap

    if _file:
        _file = _mk_single_path_wrapper('file', _file***REMOVED***
    _open = _mk_single_path_wrapper('open', _open***REMOVED***
    for name in [
        "stat", "listdir", "chdir", "open", "chmod", "chown", "mkdir",
        "remove", "unlink", "rmdir", "utime", "lchown", "chroot", "lstat",
        "startfile", "mkfifo", "mknod", "pathconf", "access"
    ***REMOVED***:
        if hasattr(_os, name***REMOVED***:
            locals(***REMOVED***[name***REMOVED*** = _mk_single_path_wrapper(name***REMOVED***

    def _mk_single_with_return(name***REMOVED***:
        original = getattr(_os, name***REMOVED***

        def wrap(self, path, *args, **kw***REMOVED***:
            if self._active:
                path = self._remap_input(name, path, *args, **kw***REMOVED***
                return self._remap_output(name, original(path, *args, **kw***REMOVED******REMOVED***
            return original(path, *args, **kw***REMOVED***

        return wrap

    for name in ['readlink', 'tempnam'***REMOVED***:
        if hasattr(_os, name***REMOVED***:
            locals(***REMOVED***[name***REMOVED*** = _mk_single_with_return(name***REMOVED***

    def _mk_query(name***REMOVED***:
        original = getattr(_os, name***REMOVED***

        def wrap(self, *args, **kw***REMOVED***:
            retval = original(*args, **kw***REMOVED***
            if self._active:
                return self._remap_output(name, retval***REMOVED***
            return retval

        return wrap

    for name in ['getcwd', 'tmpnam'***REMOVED***:
        if hasattr(_os, name***REMOVED***:
            locals(***REMOVED***[name***REMOVED*** = _mk_query(name***REMOVED***

    def _validate_path(self, path***REMOVED***:
        ***REMOVED***Called to remap or validate any path, whether input or output***REMOVED***
        return path

    def _remap_input(self, operation, path, *args, **kw***REMOVED***:
        ***REMOVED***Called for path inputs***REMOVED***
        return self._validate_path(path***REMOVED***

    def _remap_output(self, operation, path***REMOVED***:
        ***REMOVED***Called for path outputs***REMOVED***
        return self._validate_path(path***REMOVED***

    def _remap_pair(self, operation, src, dst, *args, **kw***REMOVED***:
        ***REMOVED***Called for path pairs like rename, link, and symlink operations***REMOVED***
        return (
            self._remap_input(operation + '-from', src, *args, **kw***REMOVED***,
            self._remap_input(operation + '-to', dst, *args, **kw***REMOVED***
        ***REMOVED***


if hasattr(os, 'devnull'***REMOVED***:
    _EXCEPTIONS = [os.devnull,***REMOVED***
else:
    _EXCEPTIONS = [***REMOVED***

***REMOVED***
    from win32com.client.gencache import GetGeneratePath
    _EXCEPTIONS.append(GetGeneratePath(***REMOVED******REMOVED***
    del GetGeneratePath
except ImportError:
    # it appears pywin32 is not installed, so no need to exclude.
    pass


class DirectorySandbox(AbstractSandbox***REMOVED***:
    ***REMOVED***Restrict operations to a single subdirectory - pseudo-chroot***REMOVED***

    write_ops = dict.fromkeys([
        "open", "chmod", "chown", "mkdir", "remove", "unlink", "rmdir",
        "utime", "lchown", "chroot", "mkfifo", "mknod", "tempnam",
    ***REMOVED******REMOVED***

    _exception_patterns = [
        # Allow lib2to3 to attempt to save a pickled grammar object (#121***REMOVED***
        '.*lib2to3.*\.pickle$',
    ***REMOVED***
    "exempt writing to paths that match the pattern"

    def __init__(self, sandbox, exceptions=_EXCEPTIONS***REMOVED***:
        self._sandbox = os.path.normcase(os.path.realpath(sandbox***REMOVED******REMOVED***
        self._prefix = os.path.join(self._sandbox, ''***REMOVED***
        self._exceptions = [
            os.path.normcase(os.path.realpath(path***REMOVED******REMOVED***
            for path in exceptions
        ***REMOVED***
        AbstractSandbox.__init__(self***REMOVED***

    def _violation(self, operation, *args, **kw***REMOVED***:
        from setuptools.sandbox import SandboxViolation
        raise SandboxViolation(operation, args, kw***REMOVED***

    if _file:

        def _file(self, path, mode='r', *args, **kw***REMOVED***:
            if mode not in ('r', 'rt', 'rb', 'rU', 'U'***REMOVED*** and not self._ok(path***REMOVED***:
                self._violation("file", path, mode, *args, **kw***REMOVED***
            return _file(path, mode, *args, **kw***REMOVED***

    def _open(self, path, mode='r', *args, **kw***REMOVED***:
        if mode not in ('r', 'rt', 'rb', 'rU', 'U'***REMOVED*** and not self._ok(path***REMOVED***:
            self._violation("open", path, mode, *args, **kw***REMOVED***
        return _open(path, mode, *args, **kw***REMOVED***

    def tmpnam(self***REMOVED***:
        self._violation("tmpnam"***REMOVED***

    def _ok(self, path***REMOVED***:
        active = self._active
        ***REMOVED***
            self._active = False
            realpath = os.path.normcase(os.path.realpath(path***REMOVED******REMOVED***
            return (
                self._exempted(realpath***REMOVED***
                or realpath == self._sandbox
                or realpath.startswith(self._prefix***REMOVED***
            ***REMOVED***
        finally:
            self._active = active

    def _exempted(self, filepath***REMOVED***:
        start_matches = (
            filepath.startswith(exception***REMOVED***
            for exception in self._exceptions
        ***REMOVED***
        pattern_matches = (
            re.match(pattern, filepath***REMOVED***
            for pattern in self._exception_patterns
        ***REMOVED***
        candidates = itertools.chain(start_matches, pattern_matches***REMOVED***
        return any(candidates***REMOVED***

    def _remap_input(self, operation, path, *args, **kw***REMOVED***:
        ***REMOVED***Called for path inputs***REMOVED***
        if operation in self.write_ops and not self._ok(path***REMOVED***:
            self._violation(operation, os.path.realpath(path***REMOVED***, *args, **kw***REMOVED***
        return path

    def _remap_pair(self, operation, src, dst, *args, **kw***REMOVED***:
        ***REMOVED***Called for path pairs like rename, link, and symlink operations***REMOVED***
        if not self._ok(src***REMOVED*** or not self._ok(dst***REMOVED***:
            self._violation(operation, src, dst, *args, **kw***REMOVED***
        return (src, dst***REMOVED***

    def open(self, file, flags, mode=0o777, *args, **kw***REMOVED***:
        ***REMOVED***Called for low-level os.open(***REMOVED******REMOVED***
        if flags & WRITE_FLAGS and not self._ok(file***REMOVED***:
            self._violation("os.open", file, flags, mode, *args, **kw***REMOVED***
        return _os.open(file, flags, mode, *args, **kw***REMOVED***


WRITE_FLAGS = functools.reduce(
    operator.or_, [getattr(_os, a, 0***REMOVED*** for a in
        "O_WRONLY O_RDWR O_APPEND O_CREAT O_TRUNC O_TEMPORARY".split(***REMOVED******REMOVED***
***REMOVED***


class SandboxViolation(DistutilsError***REMOVED***:
    ***REMOVED***A setup script attempted to modify the filesystem outside the sandbox***REMOVED***

    def __str__(self***REMOVED***:
        return ***REMOVED***SandboxViolation: %s%r %s

The package setup script has attempted to modify files on your system
that are not within the EasyInstall build area, and has been aborted.

This package cannot be safely installed by EasyInstall, and may not
support alternate installation locations even if you run its setup
script by hand.  Please inform the package's author and the EasyInstall
maintainers to find out if a fix or workaround is available.***REMOVED*** % self.args


#
