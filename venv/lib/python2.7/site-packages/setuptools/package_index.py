***REMOVED***PyPI and direct package downloading***REMOVED***
import sys
***REMOVED***
import re
import shutil
import socket
import base64
import hashlib
import itertools
from functools import wraps

***REMOVED***
    from urllib.parse import splituser
except ImportError:
    from urllib2 import splituser

from setuptools.extern import six
from setuptools.extern.six.moves import urllib, http_client, configparser, map

import setuptools
from pkg_resources import (
    CHECKOUT_DIST, Distribution, BINARY_DIST, normalize_path, SOURCE_DIST,
    require, Environment, find_distributions, safe_name, safe_version,
    to_filename, Requirement, DEVELOP_DIST,
***REMOVED***
from setuptools import ssl_support
from distutils import log
from distutils.errors import DistutilsError
from fnmatch import translate
from setuptools.py26compat import strip_fragment
from setuptools.py27compat import get_all_headers

EGG_FRAGMENT = re.compile(r'^egg=([-A-Za-z0-9_.***REMOVED***+***REMOVED***$'***REMOVED***
HREF = re.compile(***REMOVED***href\\s*=\\s*['"***REMOVED***?([^'"> ***REMOVED***+***REMOVED******REMOVED***, re.I***REMOVED***
# this is here to fix emacs' cruddy broken syntax highlighting
PYPI_MD5 = re.compile(
    '<a href="([^"#***REMOVED***+***REMOVED***">([^<***REMOVED***+***REMOVED***</a>\n\s+\\(<a (?:title="MD5 hash"\n\s+***REMOVED***'
    'href="[^?***REMOVED***+\?:action=show_md5&amp;digest=([0-9a-f***REMOVED***{32***REMOVED******REMOVED***">md5</a>\\***REMOVED***'
***REMOVED***
URL_SCHEME = re.compile('([-+.a-z0-9***REMOVED***{2,***REMOVED******REMOVED***:', re.I***REMOVED***.match
EXTENSIONS = ".tar.gz .tar.bz2 .tar .zip .tgz".split(***REMOVED***

__all__ = [
    'PackageIndex', 'distros_for_url', 'parse_bdist_wininst',
    'interpret_distro_name',
***REMOVED***

_SOCKET_TIMEOUT = 15

_tmpl = "setuptools/{setuptools.__version__***REMOVED*** Python-urllib/{py_major***REMOVED***"
user_agent = _tmpl.format(py_major=sys.version[:3***REMOVED***, **globals(***REMOVED******REMOVED***


def parse_requirement_arg(spec***REMOVED***:
    ***REMOVED***
        return Requirement.parse(spec***REMOVED***
    except ValueError:
        raise DistutilsError(
            "Not a URL, existing file, or requirement spec: %r" % (spec,***REMOVED***
        ***REMOVED***


def parse_bdist_wininst(name***REMOVED***:
    ***REMOVED***Return (base,pyversion***REMOVED*** or (None,None***REMOVED*** for possible .exe name***REMOVED***

    lower = name.lower(***REMOVED***
    base, py_ver, plat = None, None, None

    if lower.endswith('.exe'***REMOVED***:
        if lower.endswith('.win32.exe'***REMOVED***:
            base = name[:-10***REMOVED***
            plat = 'win32'
        elif lower.startswith('.win32-py', -16***REMOVED***:
            py_ver = name[-7:-4***REMOVED***
            base = name[:-16***REMOVED***
            plat = 'win32'
        elif lower.endswith('.win-amd64.exe'***REMOVED***:
            base = name[:-14***REMOVED***
            plat = 'win-amd64'
        elif lower.startswith('.win-amd64-py', -20***REMOVED***:
            py_ver = name[-7:-4***REMOVED***
            base = name[:-20***REMOVED***
            plat = 'win-amd64'
    return base, py_ver, plat


def egg_info_for_url(url***REMOVED***:
    parts = urllib.parse.urlparse(url***REMOVED***
    scheme, server, path, parameters, query, fragment = parts
    base = urllib.parse.unquote(path.split('/'***REMOVED***[-1***REMOVED******REMOVED***
    if server == 'sourceforge.net' and base == 'download':  # XXX Yuck
        base = urllib.parse.unquote(path.split('/'***REMOVED***[-2***REMOVED******REMOVED***
    if '#' in base:
        base, fragment = base.split('#', 1***REMOVED***
    return base, fragment


def distros_for_url(url, metadata=None***REMOVED***:
    ***REMOVED***Yield egg or source distribution objects that might be found at a URL***REMOVED***
    base, fragment = egg_info_for_url(url***REMOVED***
    for dist in distros_for_location(url, base, metadata***REMOVED***:
        yield dist
    if fragment:
        match = EGG_FRAGMENT.match(fragment***REMOVED***
        if match:
            for dist in interpret_distro_name(
                url, match.group(1***REMOVED***, metadata, precedence=CHECKOUT_DIST
            ***REMOVED***:
                yield dist


def distros_for_location(location, basename, metadata=None***REMOVED***:
    ***REMOVED***Yield egg or source distribution objects based on basename***REMOVED***
    if basename.endswith('.egg.zip'***REMOVED***:
        basename = basename[:-4***REMOVED***  # strip the .zip
    if basename.endswith('.egg'***REMOVED*** and '-' in basename:
        # only one, unambiguous interpretation
        return [Distribution.from_location(location, basename, metadata***REMOVED******REMOVED***
    if basename.endswith('.exe'***REMOVED***:
        win_base, py_ver, platform = parse_bdist_wininst(basename***REMOVED***
        if win_base is not None:
            return interpret_distro_name(
                location, win_base, metadata, py_ver, BINARY_DIST, platform
            ***REMOVED***
    # Try source distro extensions (.zip, .tgz, etc.***REMOVED***
    #
    for ext in EXTENSIONS:
        if basename.endswith(ext***REMOVED***:
            basename = basename[:-len(ext***REMOVED******REMOVED***
            return interpret_distro_name(location, basename, metadata***REMOVED***
    return [***REMOVED***  # no extension matched


def distros_for_filename(filename, metadata=None***REMOVED***:
    ***REMOVED***Yield possible egg or source distribution objects based on a filename***REMOVED***
    return distros_for_location(
        normalize_path(filename***REMOVED***, os.path.basename(filename***REMOVED***, metadata
    ***REMOVED***


def interpret_distro_name(
        location, basename, metadata, py_version=None, precedence=SOURCE_DIST,
        platform=None
        ***REMOVED***:
    ***REMOVED***Generate alternative interpretations of a source distro name

    Note: if `location` is a filesystem filename, you should call
    ``pkg_resources.normalize_path(***REMOVED***`` on it before passing it to this
    routine!
    ***REMOVED***
    # Generate alternative interpretations of a source distro name
    # Because some packages are ambiguous as to name/versions split
    # e.g. "adns-python-1.1.0", "egenix-mx-commercial", etc.
    # So, we generate each possible interepretation (e.g. "adns, python-1.1.0"
    # "adns-python, 1.1.0", and "adns-python-1.1.0, no version"***REMOVED***.  In practice,
    # the spurious interpretations should be ignored, because in the event
    # there's also an "adns" package, the spurious "python-1.1.0" version will
    # compare lower than any numeric version number, and is therefore unlikely
    # to match a request for it.  It's still a potential problem, though, and
    # in the long run PyPI and the distutils should go for "safe" names and
    # versions in distribution archive names (sdist and bdist***REMOVED***.

    parts = basename.split('-'***REMOVED***
    if not py_version and any(re.match('py\d\.\d$', p***REMOVED*** for p in parts[2:***REMOVED******REMOVED***:
        # it is a bdist_dumb, not an sdist -- bail out
        return

    for p in range(1, len(parts***REMOVED*** + 1***REMOVED***:
        yield Distribution(
            location, metadata, '-'.join(parts[:p***REMOVED******REMOVED***, '-'.join(parts[p:***REMOVED******REMOVED***,
            py_version=py_version, precedence=precedence,
            platform=platform
        ***REMOVED***


# From Python 2.7 docs
def unique_everseen(iterable, key=None***REMOVED***:
    "List unique elements, preserving order. Remember all elements ever seen."
    # unique_everseen('AAAABBBCCDAABBB'***REMOVED*** --> A B C D
    # unique_everseen('ABBCcAD', str.lower***REMOVED*** --> A B C D
    seen = set(***REMOVED***
    seen_add = seen.add
    if key is None:
        for element in six.moves.filterfalse(seen.__contains__, iterable***REMOVED***:
            seen_add(element***REMOVED***
            yield element
    else:
        for element in iterable:
            k = key(element***REMOVED***
            if k not in seen:
                seen_add(k***REMOVED***
                yield element


def unique_values(func***REMOVED***:
    ***REMOVED***
    Wrap a function returning an iterable such that the resulting iterable
    only ever yields unique items.
    ***REMOVED***

    @wraps(func***REMOVED***
    def wrapper(*args, **kwargs***REMOVED***:
        return unique_everseen(func(*args, **kwargs***REMOVED******REMOVED***

    return wrapper


REL = re.compile(***REMOVED***<([^>***REMOVED****\srel\s*=\s*['"***REMOVED***?([^'">***REMOVED***+***REMOVED***[^>***REMOVED*******REMOVED***>***REMOVED***, re.I***REMOVED***
# this line is here to fix emacs' cruddy broken syntax highlighting


@unique_values
def find_external_links(url, page***REMOVED***:
    ***REMOVED***Find rel="homepage" and rel="download" links in `page`, yielding URLs***REMOVED***

    for match in REL.finditer(page***REMOVED***:
        tag, rel = match.groups(***REMOVED***
        rels = set(map(str.strip, rel.lower(***REMOVED***.split(','***REMOVED******REMOVED******REMOVED***
        if 'homepage' in rels or 'download' in rels:
            for match in HREF.finditer(tag***REMOVED***:
                yield urllib.parse.urljoin(url, htmldecode(match.group(1***REMOVED******REMOVED******REMOVED***

    for tag in ("<th>Home Page", "<th>Download URL"***REMOVED***:
        pos = page.find(tag***REMOVED***
        if pos != -1:
            match = HREF.search(page, pos***REMOVED***
            if match:
                yield urllib.parse.urljoin(url, htmldecode(match.group(1***REMOVED******REMOVED******REMOVED***


class ContentChecker(object***REMOVED***:
    ***REMOVED***
    A null content checker that defines the interface for checking content
    ***REMOVED***

    def feed(self, block***REMOVED***:
        ***REMOVED***
        Feed a block of data to the hash.
        ***REMOVED***
        return

    def is_valid(self***REMOVED***:
        ***REMOVED***
        Check the hash. Return False if validation fails.
        ***REMOVED***
        return True

    def report(self, reporter, template***REMOVED***:
        ***REMOVED***
        Call reporter with information about the checker (hash name***REMOVED***
        substituted into the template.
        ***REMOVED***
        return


class HashChecker(ContentChecker***REMOVED***:
    pattern = re.compile(
        r'(?P<hash_name>sha1|sha224|sha384|sha256|sha512|md5***REMOVED***='
        r'(?P<expected>[a-f0-9***REMOVED***+***REMOVED***'
    ***REMOVED***

    def __init__(self, hash_name, expected***REMOVED***:
        self.hash_name = hash_name
        self.hash = hashlib.new(hash_name***REMOVED***
        self.expected = expected

    @classmethod
    def from_url(cls, url***REMOVED***:
        "Construct a (possibly null***REMOVED*** ContentChecker from a URL"
        fragment = urllib.parse.urlparse(url***REMOVED***[-1***REMOVED***
        if not fragment:
            return ContentChecker(***REMOVED***
        match = cls.pattern.search(fragment***REMOVED***
        if not match:
            return ContentChecker(***REMOVED***
        return cls(**match.groupdict(***REMOVED******REMOVED***

    def feed(self, block***REMOVED***:
        self.hash.update(block***REMOVED***

    def is_valid(self***REMOVED***:
        return self.hash.hexdigest(***REMOVED*** == self.expected

    def report(self, reporter, template***REMOVED***:
        msg = template % self.hash_name
        return reporter(msg***REMOVED***


class PackageIndex(Environment***REMOVED***:
    ***REMOVED***A distribution index that scans web pages for download URLs***REMOVED***

    def __init__(
            self, index_url="https://pypi.python.org/simple", hosts=('*',***REMOVED***,
            ca_bundle=None, verify_ssl=True, *args, **kw
            ***REMOVED***:
        Environment.__init__(self, *args, **kw***REMOVED***
        self.index_url = index_url + "/" [:not index_url.endswith('/'***REMOVED******REMOVED***
        self.scanned_urls = {***REMOVED***
        self.fetched_urls = {***REMOVED***
        self.package_pages = {***REMOVED***
        self.allows = re.compile('|'.join(map(translate, hosts***REMOVED******REMOVED******REMOVED***.match
        self.to_scan = [***REMOVED***
        use_ssl = (
            verify_ssl
            and ssl_support.is_available
            and (ca_bundle or ssl_support.find_ca_bundle(***REMOVED******REMOVED***
        ***REMOVED***
        if use_ssl:
            self.opener = ssl_support.opener_for(ca_bundle***REMOVED***
        else:
            self.opener = urllib.request.urlopen

    def process_url(self, url, retrieve=False***REMOVED***:
        ***REMOVED***Evaluate a URL as a possible download, and maybe retrieve it***REMOVED***
        if url in self.scanned_urls and not retrieve:
            return
        self.scanned_urls[url***REMOVED*** = True
        if not URL_SCHEME(url***REMOVED***:
            self.process_filename(url***REMOVED***
            return
        else:
            dists = list(distros_for_url(url***REMOVED******REMOVED***
            if dists:
                if not self.url_ok(url***REMOVED***:
                    return
                self.debug("Found link: %s", url***REMOVED***

        if dists or not retrieve or url in self.fetched_urls:
            list(map(self.add, dists***REMOVED******REMOVED***
            return  # don't need the actual page

        if not self.url_ok(url***REMOVED***:
            self.fetched_urls[url***REMOVED*** = True
            return

        self.info("Reading %s", url***REMOVED***
        self.fetched_urls[url***REMOVED*** = True  # prevent multiple fetch attempts
        tmpl = "Download error on %s: %%s -- Some packages may not be found!"
        f = self.open_url(url, tmpl % url***REMOVED***
        if f is None:
            return
        self.fetched_urls[f.url***REMOVED*** = True
        if 'html' not in f.headers.get('content-type', ''***REMOVED***.lower(***REMOVED***:
            f.close(***REMOVED***  # not html, we can't process it
            return

        base = f.url  # handle redirects
        page = f.read(***REMOVED***
        if not isinstance(page, str***REMOVED***:  # We are in Python 3 and got bytes. We want str.
            if isinstance(f, urllib.error.HTTPError***REMOVED***:
                # Errors have no charset, assume latin1:
                charset = 'latin-1'
            else:
                charset = f.headers.get_param('charset'***REMOVED*** or 'latin-1'
            page = page.decode(charset, "ignore"***REMOVED***
        f.close(***REMOVED***
        for match in HREF.finditer(page***REMOVED***:
            link = urllib.parse.urljoin(base, htmldecode(match.group(1***REMOVED******REMOVED******REMOVED***
            self.process_url(link***REMOVED***
        if url.startswith(self.index_url***REMOVED*** and getattr(f, 'code', None***REMOVED*** != 404:
            page = self.process_index(url, page***REMOVED***

    def process_filename(self, fn, nested=False***REMOVED***:
        # process filenames or directories
        if not os.path.exists(fn***REMOVED***:
            self.warn("Not found: %s", fn***REMOVED***
            return

        if os.path.isdir(fn***REMOVED*** and not nested:
            path = os.path.realpath(fn***REMOVED***
            for item in os.listdir(path***REMOVED***:
                self.process_filename(os.path.join(path, item***REMOVED***, True***REMOVED***

        dists = distros_for_filename(fn***REMOVED***
        if dists:
            self.debug("Found: %s", fn***REMOVED***
            list(map(self.add, dists***REMOVED******REMOVED***

    def url_ok(self, url, fatal=False***REMOVED***:
        s = URL_SCHEME(url***REMOVED***
        is_file = s and s.group(1***REMOVED***.lower(***REMOVED*** == 'file'
        if is_file or self.allows(urllib.parse.urlparse(url***REMOVED***[1***REMOVED******REMOVED***:
            return True
        msg = ("\nNote: Bypassing %s (disallowed host; see "
            "http://bit.ly/1dg9ijs for details***REMOVED***.\n"***REMOVED***
        if fatal:
            raise DistutilsError(msg % url***REMOVED***
        else:
            self.warn(msg, url***REMOVED***

    def scan_egg_links(self, search_path***REMOVED***:
        dirs = filter(os.path.isdir, search_path***REMOVED***
        egg_links = (
            (path, entry***REMOVED***
            for path in dirs
            for entry in os.listdir(path***REMOVED***
            if entry.endswith('.egg-link'***REMOVED***
        ***REMOVED***
        list(itertools.starmap(self.scan_egg_link, egg_links***REMOVED******REMOVED***

    def scan_egg_link(self, path, entry***REMOVED***:
        with open(os.path.join(path, entry***REMOVED******REMOVED*** as raw_lines:
            # filter non-empty lines
            lines = list(filter(None, map(str.strip, raw_lines***REMOVED******REMOVED******REMOVED***

        if len(lines***REMOVED*** != 2:
            # format is not recognized; punt
            return

        egg_path, setup_path = lines

        for dist in find_distributions(os.path.join(path, egg_path***REMOVED******REMOVED***:
            dist.location = os.path.join(path, *lines***REMOVED***
            dist.precedence = SOURCE_DIST
            self.add(dist***REMOVED***

    def process_index(self, url, page***REMOVED***:
        ***REMOVED***Process the contents of a PyPI page***REMOVED***

        def scan(link***REMOVED***:
            # Process a URL to see if it's for a package page
            if link.startswith(self.index_url***REMOVED***:
                parts = list(map(
                    urllib.parse.unquote, link[len(self.index_url***REMOVED***:***REMOVED***.split('/'***REMOVED***
                ***REMOVED******REMOVED***
                if len(parts***REMOVED*** == 2 and '#' not in parts[1***REMOVED***:
                    # it's a package page, sanitize and index it
                    pkg = safe_name(parts[0***REMOVED******REMOVED***
                    ver = safe_version(parts[1***REMOVED******REMOVED***
                    self.package_pages.setdefault(pkg.lower(***REMOVED***, {***REMOVED******REMOVED***[link***REMOVED*** = True
                    return to_filename(pkg***REMOVED***, to_filename(ver***REMOVED***
            return None, None

        # process an index page into the package-page index
        for match in HREF.finditer(page***REMOVED***:
            ***REMOVED***
                scan(urllib.parse.urljoin(url, htmldecode(match.group(1***REMOVED******REMOVED******REMOVED******REMOVED***
            except ValueError:
                pass

        pkg, ver = scan(url***REMOVED***  # ensure this page is in the page index
        if pkg:
            # process individual package page
            for new_url in find_external_links(url, page***REMOVED***:
                # Process the found URL
                base, frag = egg_info_for_url(new_url***REMOVED***
                if base.endswith('.py'***REMOVED*** and not frag:
                    if ver:
                        new_url += '#egg=%s-%s' % (pkg, ver***REMOVED***
                    else:
                        self.need_version_info(url***REMOVED***
                self.scan_url(new_url***REMOVED***

            return PYPI_MD5.sub(
                lambda m: '<a href="%s#md5=%s">%s</a>' % m.group(1, 3, 2***REMOVED***, page
            ***REMOVED***
        else:
            return ""  # no sense double-scanning non-package pages

    def need_version_info(self, url***REMOVED***:
        self.scan_all(
            "Page at %s links to .py file(s***REMOVED*** without version info; an index "
            "scan is required.", url
        ***REMOVED***

    def scan_all(self, msg=None, *args***REMOVED***:
        if self.index_url not in self.fetched_urls:
            if msg:
                self.warn(msg, *args***REMOVED***
            self.info(
                "Scanning index of all packages (this may take a while***REMOVED***"
            ***REMOVED***
        self.scan_url(self.index_url***REMOVED***

    def find_packages(self, requirement***REMOVED***:
        self.scan_url(self.index_url + requirement.unsafe_name + '/'***REMOVED***

        if not self.package_pages.get(requirement.key***REMOVED***:
            # Fall back to safe version of the name
            self.scan_url(self.index_url + requirement.project_name + '/'***REMOVED***

        if not self.package_pages.get(requirement.key***REMOVED***:
            # We couldn't find the target package, so search the index page too
            self.not_found_in_index(requirement***REMOVED***

        for url in list(self.package_pages.get(requirement.key, (***REMOVED******REMOVED******REMOVED***:
            # scan each page that might be related to the desired package
            self.scan_url(url***REMOVED***

    def obtain(self, requirement, installer=None***REMOVED***:
        self.prescan(***REMOVED***
        self.find_packages(requirement***REMOVED***
        for dist in self[requirement.key***REMOVED***:
            if dist in requirement:
                return dist
            self.debug("%s does not match %s", requirement, dist***REMOVED***
        return super(PackageIndex, self***REMOVED***.obtain(requirement, installer***REMOVED***

    def check_hash(self, checker, filename, tfp***REMOVED***:
        ***REMOVED***
        checker is a ContentChecker
        ***REMOVED***
        checker.report(self.debug,
            "Validating %%s checksum for %s" % filename***REMOVED***
        if not checker.is_valid(***REMOVED***:
            tfp.close(***REMOVED***
            os.unlink(filename***REMOVED***
            raise DistutilsError(
                "%s validation failed for %s; "
                "possible download problem?" % (
                                checker.hash.name, os.path.basename(filename***REMOVED******REMOVED***
            ***REMOVED***

    def add_find_links(self, urls***REMOVED***:
        ***REMOVED***Add `urls` to the list that will be prescanned for searches***REMOVED***
        for url in urls:
            if (
                self.to_scan is None        # if we have already "gone online"
                or not URL_SCHEME(url***REMOVED***      # or it's a local file/directory
                or url.startswith('file:'***REMOVED***
                or list(distros_for_url(url***REMOVED******REMOVED***   # or a direct package link
            ***REMOVED***:
                # then go ahead and process it now
                self.scan_url(url***REMOVED***
            else:
                # otherwise, defer retrieval till later
                self.to_scan.append(url***REMOVED***

    def prescan(self***REMOVED***:
        ***REMOVED***Scan urls scheduled for prescanning (e.g. --find-links***REMOVED******REMOVED***
        if self.to_scan:
            list(map(self.scan_url, self.to_scan***REMOVED******REMOVED***
        self.to_scan = None  # from now on, go ahead and process immediately

    def not_found_in_index(self, requirement***REMOVED***:
        if self[requirement.key***REMOVED***:  # we've seen at least one distro
            meth, msg = self.info, "Couldn't retrieve index page for %r"
        else:  # no distros seen for this name, might be misspelled
            meth, msg = (self.warn,
                "Couldn't find index page for %r (maybe misspelled?***REMOVED***"***REMOVED***
        meth(msg, requirement.unsafe_name***REMOVED***
        self.scan_all(***REMOVED***

    def download(self, spec, tmpdir***REMOVED***:
        ***REMOVED***Locate and/or download `spec` to `tmpdir`, returning a local path

        `spec` may be a ``Requirement`` object, or a string containing a URL,
        an existing local filename, or a project/version requirement spec
        (i.e. the string form of a ``Requirement`` object***REMOVED***.  If it is the URL
        of a .py file with an unambiguous ``#egg=name-version`` tag (i.e., one
        that escapes ``-`` as ``_`` throughout***REMOVED***, a trivial ``setup.py`` is
        automatically created alongside the downloaded file.

        If `spec` is a ``Requirement`` object or a string containing a
        project/version requirement spec, this method returns the location of
        a matching distribution (possibly after downloading it to `tmpdir`***REMOVED***.
        If `spec` is a locally existing file or directory name, it is simply
        returned unchanged.  If `spec` is a URL, it is downloaded to a subpath
        of `tmpdir`, and the local filename is returned.  Various errors may be
        raised if a problem occurs during downloading.
        ***REMOVED***
        if not isinstance(spec, Requirement***REMOVED***:
            scheme = URL_SCHEME(spec***REMOVED***
            if scheme:
                # It's a url, download it to tmpdir
                found = self._download_url(scheme.group(1***REMOVED***, spec, tmpdir***REMOVED***
                base, fragment = egg_info_for_url(spec***REMOVED***
                if base.endswith('.py'***REMOVED***:
                    found = self.gen_setup(found, fragment, tmpdir***REMOVED***
                return found
            elif os.path.exists(spec***REMOVED***:
                # Existing file or directory, just return it
                return spec
            else:
                spec = parse_requirement_arg(spec***REMOVED***
        return getattr(self.fetch_distribution(spec, tmpdir***REMOVED***, 'location', None***REMOVED***

    def fetch_distribution(
            self, requirement, tmpdir, force_scan=False, source=False,
            develop_ok=False, local_index=None
            ***REMOVED***:
        ***REMOVED***Obtain a distribution suitable for fulfilling `requirement`

        `requirement` must be a ``pkg_resources.Requirement`` instance.
        If necessary, or if the `force_scan` flag is set, the requirement is
        searched for in the (online***REMOVED*** package index as well as the locally
        installed packages.  If a distribution matching `requirement` is found,
        the returned distribution's ``location`` is the value you would have
        gotten from calling the ``download(***REMOVED***`` method with the matching
        distribution's URL or filename.  If no matching distribution is found,
        ``None`` is returned.

        If the `source` flag is set, only source distributions and source
        checkout links will be considered.  Unless the `develop_ok` flag is
        set, development and system eggs (i.e., those using the ``.egg-info``
        format***REMOVED*** will be ignored.
        ***REMOVED***
        # process a Requirement
        self.info("Searching for %s", requirement***REMOVED***
        skipped = {***REMOVED***
        dist = None

        def find(req, env=None***REMOVED***:
            if env is None:
                env = self
            # Find a matching distribution; may be called more than once

            for dist in env[req.key***REMOVED***:

                if dist.precedence == DEVELOP_DIST and not develop_ok:
                    if dist not in skipped:
                        self.warn("Skipping development or system egg: %s", dist***REMOVED***
                        skipped[dist***REMOVED*** = 1
                    continue

                if dist in req and (dist.precedence <= SOURCE_DIST or not source***REMOVED***:
                    dist.download_location = self.download(dist.location, tmpdir***REMOVED***
                    if os.path.exists(dist.download_location***REMOVED***:
                        return dist

        if force_scan:
            self.prescan(***REMOVED***
            self.find_packages(requirement***REMOVED***
            dist = find(requirement***REMOVED***

        if not dist and local_index is not None:
            dist = find(requirement, local_index***REMOVED***

        if dist is None:
            if self.to_scan is not None:
                self.prescan(***REMOVED***
            dist = find(requirement***REMOVED***

        if dist is None and not force_scan:
            self.find_packages(requirement***REMOVED***
            dist = find(requirement***REMOVED***

        if dist is None:
            self.warn(
                "No local packages or working download links found for %s%s",
                (source and "a source distribution of " or ""***REMOVED***,
                requirement,
            ***REMOVED***
        else:
            self.info("Best match: %s", dist***REMOVED***
            return dist.clone(location=dist.download_location***REMOVED***

    def fetch(self, requirement, tmpdir, force_scan=False, source=False***REMOVED***:
        ***REMOVED***Obtain a file suitable for fulfilling `requirement`

        DEPRECATED; use the ``fetch_distribution(***REMOVED***`` method now instead.  For
        backward compatibility, this routine is identical but returns the
        ``location`` of the downloaded distribution instead of a distribution
        object.
        ***REMOVED***
        dist = self.fetch_distribution(requirement, tmpdir, force_scan, source***REMOVED***
        if dist is not None:
            return dist.location
        return None

    def gen_setup(self, filename, fragment, tmpdir***REMOVED***:
        match = EGG_FRAGMENT.match(fragment***REMOVED***
        dists = match and [
            d for d in
            interpret_distro_name(filename, match.group(1***REMOVED***, None***REMOVED*** if d.version
        ***REMOVED*** or [***REMOVED***

        if len(dists***REMOVED*** == 1:  # unambiguous ``#egg`` fragment
            basename = os.path.basename(filename***REMOVED***

            # Make sure the file has been downloaded to the temp dir.
            if os.path.dirname(filename***REMOVED*** != tmpdir:
                dst = os.path.join(tmpdir, basename***REMOVED***
                from setuptools.command.easy_install import samefile
                if not samefile(filename, dst***REMOVED***:
                    shutil.copy2(filename, dst***REMOVED***
                    filename = dst

            with open(os.path.join(tmpdir, 'setup.py'***REMOVED***, 'w'***REMOVED*** as file:
                file.write(
                    "from setuptools import setup\n"
                    "setup(name=%r, version=%r, py_modules=[%r***REMOVED******REMOVED***\n"
                    % (
                        dists[0***REMOVED***.project_name, dists[0***REMOVED***.version,
                        os.path.splitext(basename***REMOVED***[0***REMOVED***
                    ***REMOVED***
                ***REMOVED***
            return filename

        elif match:
            raise DistutilsError(
                "Can't unambiguously interpret project/version identifier %r; "
                "any dashes in the name or version should be escaped using "
                "underscores. %r" % (fragment, dists***REMOVED***
            ***REMOVED***
        else:
            raise DistutilsError(
                "Can't process plain .py files without an '#egg=name-version'"
                " suffix to enable automatic setup script generation."
            ***REMOVED***

    dl_blocksize = 8192

    def _download_to(self, url, filename***REMOVED***:
        self.info("Downloading %s", url***REMOVED***
        # Download the file
        fp, info = None, None
        ***REMOVED***
            checker = HashChecker.from_url(url***REMOVED***
            fp = self.open_url(strip_fragment(url***REMOVED******REMOVED***
            if isinstance(fp, urllib.error.HTTPError***REMOVED***:
                raise DistutilsError(
                    "Can't download %s: %s %s" % (url, fp.code, fp.msg***REMOVED***
                ***REMOVED***
            headers = fp.info(***REMOVED***
            blocknum = 0
            bs = self.dl_blocksize
            size = -1
            if "content-length" in headers:
                # Some servers return multiple Content-Length headers :(
                sizes = get_all_headers(headers, 'Content-Length'***REMOVED***
                size = max(map(int, sizes***REMOVED******REMOVED***
                self.reporthook(url, filename, blocknum, bs, size***REMOVED***
            with open(filename, 'wb'***REMOVED*** as tfp:
                while True:
                    block = fp.read(bs***REMOVED***
                    if block:
                        checker.feed(block***REMOVED***
                        tfp.write(block***REMOVED***
                        blocknum += 1
                        self.reporthook(url, filename, blocknum, bs, size***REMOVED***
                    else:
                        break
                self.check_hash(checker, filename, tfp***REMOVED***
            return headers
        finally:
            if fp:
                fp.close(***REMOVED***

    def reporthook(self, url, filename, blocknum, blksize, size***REMOVED***:
        pass  # no-op

    def open_url(self, url, warning=None***REMOVED***:
        if url.startswith('file:'***REMOVED***:
            return local_open(url***REMOVED***
        ***REMOVED***
            return open_with_auth(url, self.opener***REMOVED***
        except (ValueError, http_client.InvalidURL***REMOVED*** as v:
            msg = ' '.join([str(arg***REMOVED*** for arg in v.args***REMOVED******REMOVED***
            if warning:
                self.warn(warning, msg***REMOVED***
            else:
                raise DistutilsError('%s %s' % (url, msg***REMOVED******REMOVED***
        except urllib.error.HTTPError as v:
            return v
        except urllib.error.URLError as v:
            if warning:
                self.warn(warning, v.reason***REMOVED***
            else:
                raise DistutilsError("Download error for %s: %s"
                                     % (url, v.reason***REMOVED******REMOVED***
        except http_client.BadStatusLine as v:
            if warning:
                self.warn(warning, v.line***REMOVED***
            else:
                raise DistutilsError(
                    '%s returned a bad status line. The server might be '
                    'down, %s' %
                    (url, v.line***REMOVED***
                ***REMOVED***
        except http_client.HTTPException as v:
            if warning:
                self.warn(warning, v***REMOVED***
            else:
                raise DistutilsError("Download error for %s: %s"
                                     % (url, v***REMOVED******REMOVED***

    def _download_url(self, scheme, url, tmpdir***REMOVED***:
        # Determine download filename
        #
        name, fragment = egg_info_for_url(url***REMOVED***
        if name:
            while '..' in name:
                name = name.replace('..', '.'***REMOVED***.replace('\\', '_'***REMOVED***
        else:
            name = "__downloaded__"  # default if URL has no path contents

        if name.endswith('.egg.zip'***REMOVED***:
            name = name[:-4***REMOVED***  # strip the extra .zip before download

        filename = os.path.join(tmpdir, name***REMOVED***

        # Download the file
        #
        if scheme == 'svn' or scheme.startswith('svn+'***REMOVED***:
            return self._download_svn(url, filename***REMOVED***
        elif scheme == 'git' or scheme.startswith('git+'***REMOVED***:
            return self._download_git(url, filename***REMOVED***
        elif scheme.startswith('hg+'***REMOVED***:
            return self._download_hg(url, filename***REMOVED***
        elif scheme == 'file':
            return urllib.request.url2pathname(urllib.parse.urlparse(url***REMOVED***[2***REMOVED******REMOVED***
        else:
            self.url_ok(url, True***REMOVED***  # raises error if not allowed
            return self._attempt_download(url, filename***REMOVED***

    def scan_url(self, url***REMOVED***:
        self.process_url(url, True***REMOVED***

    def _attempt_download(self, url, filename***REMOVED***:
        headers = self._download_to(url, filename***REMOVED***
        if 'html' in headers.get('content-type', ''***REMOVED***.lower(***REMOVED***:
            return self._download_html(url, headers, filename***REMOVED***
        else:
            return filename

    def _download_html(self, url, headers, filename***REMOVED***:
        file = open(filename***REMOVED***
        for line in file:
            if line.strip(***REMOVED***:
                # Check for a subversion index page
                if re.search(r'<title>([^- ***REMOVED***+ - ***REMOVED***?Revision \d+:', line***REMOVED***:
                    # it's a subversion index page:
                    file.close(***REMOVED***
                    os.unlink(filename***REMOVED***
                    return self._download_svn(url, filename***REMOVED***
                break  # not an index page
        file.close(***REMOVED***
        os.unlink(filename***REMOVED***
        raise DistutilsError("Unexpected HTML page found at " + url***REMOVED***

    def _download_svn(self, url, filename***REMOVED***:
        url = url.split('#', 1***REMOVED***[0***REMOVED***  # remove any fragment for svn's sake
        creds = ''
        if url.lower(***REMOVED***.startswith('svn:'***REMOVED*** and '@' in url:
            scheme, netloc, path, p, q, f = urllib.parse.urlparse(url***REMOVED***
            if not netloc and path.startswith('//'***REMOVED*** and '/' in path[2:***REMOVED***:
                netloc, path = path[2:***REMOVED***.split('/', 1***REMOVED***
                auth, host = splituser(netloc***REMOVED***
                if auth:
                    if ':' in auth:
                        user, pw = auth.split(':', 1***REMOVED***
                        creds = " --username=%s --password=%s" % (user, pw***REMOVED***
                    else:
                        creds = " --username=" + auth
                    netloc = host
                    parts = scheme, netloc, url, p, q, f
                    url = urllib.parse.urlunparse(parts***REMOVED***
        self.info("Doing subversion checkout from %s to %s", url, filename***REMOVED***
        os.system("svn checkout%s -q %s %s" % (creds, url, filename***REMOVED******REMOVED***
        return filename

    @staticmethod
    def _vcs_split_rev_from_url(url, pop_prefix=False***REMOVED***:
        scheme, netloc, path, query, frag = urllib.parse.urlsplit(url***REMOVED***

        scheme = scheme.split('+', 1***REMOVED***[-1***REMOVED***

        # Some fragment identification fails
        path = path.split('#', 1***REMOVED***[0***REMOVED***

        rev = None
        if '@' in path:
            path, rev = path.rsplit('@', 1***REMOVED***

        # Also, discard fragment
        url = urllib.parse.urlunsplit((scheme, netloc, path, query, ''***REMOVED******REMOVED***

        return url, rev

    def _download_git(self, url, filename***REMOVED***:
        filename = filename.split('#', 1***REMOVED***[0***REMOVED***
        url, rev = self._vcs_split_rev_from_url(url, pop_prefix=True***REMOVED***

        self.info("Doing git clone from %s to %s", url, filename***REMOVED***
        os.system("git clone --quiet %s %s" % (url, filename***REMOVED******REMOVED***

        if rev is not None:
            self.info("Checking out %s", rev***REMOVED***
            os.system("(cd %s && git checkout --quiet %s***REMOVED***" % (
                filename,
                rev,
            ***REMOVED******REMOVED***

        return filename

    def _download_hg(self, url, filename***REMOVED***:
        filename = filename.split('#', 1***REMOVED***[0***REMOVED***
        url, rev = self._vcs_split_rev_from_url(url, pop_prefix=True***REMOVED***

        self.info("Doing hg clone from %s to %s", url, filename***REMOVED***
        os.system("hg clone --quiet %s %s" % (url, filename***REMOVED******REMOVED***

        if rev is not None:
            self.info("Updating to %s", rev***REMOVED***
            os.system("(cd %s && hg up -C -r %s >&-***REMOVED***" % (
                filename,
                rev,
            ***REMOVED******REMOVED***

        return filename

    def debug(self, msg, *args***REMOVED***:
        log.debug(msg, *args***REMOVED***

    def info(self, msg, *args***REMOVED***:
        log.info(msg, *args***REMOVED***

    def warn(self, msg, *args***REMOVED***:
        log.warn(msg, *args***REMOVED***


# This pattern matches a character entity reference (a decimal numeric
# references, a hexadecimal numeric reference, or a named reference***REMOVED***.
entity_sub = re.compile(r'&(#(\d+|x[\da-fA-F***REMOVED***+***REMOVED***|[\w.:-***REMOVED***+***REMOVED***;?'***REMOVED***.sub


def uchr(c***REMOVED***:
    if not isinstance(c, int***REMOVED***:
        return c
    if c > 255:
        return six.unichr(c***REMOVED***
    return chr(c***REMOVED***


def decode_entity(match***REMOVED***:
    what = match.group(1***REMOVED***
    if what.startswith('#x'***REMOVED***:
        what = int(what[2:***REMOVED***, 16***REMOVED***
    elif what.startswith('#'***REMOVED***:
        what = int(what[1:***REMOVED******REMOVED***
    else:
        what = six.moves.html_entities.name2codepoint.get(what, match.group(0***REMOVED******REMOVED***
    return uchr(what***REMOVED***


def htmldecode(text***REMOVED***:
    ***REMOVED***Decode HTML entities in the given text.***REMOVED***
    return entity_sub(decode_entity, text***REMOVED***


def socket_timeout(timeout=15***REMOVED***:
    def _socket_timeout(func***REMOVED***:
        def _socket_timeout(*args, **kwargs***REMOVED***:
            old_timeout = socket.getdefaulttimeout(***REMOVED***
            socket.setdefaulttimeout(timeout***REMOVED***
            ***REMOVED***
                return func(*args, **kwargs***REMOVED***
            finally:
                socket.setdefaulttimeout(old_timeout***REMOVED***

        return _socket_timeout

    return _socket_timeout


def _encode_auth(auth***REMOVED***:
    ***REMOVED***
    A function compatible with Python 2.3-3.3 that will encode
    auth from a URL suitable for an HTTP header.
    >>> str(_encode_auth('username%3Apassword'***REMOVED******REMOVED***
    'dXNlcm5hbWU6cGFzc3dvcmQ='

    Long auth strings should not cause a newline to be inserted.
    >>> long_auth = 'username:' + 'password'*10
    >>> chr(10***REMOVED*** in str(_encode_auth(long_auth***REMOVED******REMOVED***
    False
    ***REMOVED***
    auth_s = urllib.parse.unquote(auth***REMOVED***
    # convert to bytes
    auth_bytes = auth_s.encode(***REMOVED***
    # use the legacy interface for Python 2.3 support
    encoded_bytes = base64.encodestring(auth_bytes***REMOVED***
    # convert back to a string
    encoded = encoded_bytes.decode(***REMOVED***
    # strip the trailing carriage return
    return encoded.replace('\n', ''***REMOVED***


class Credential(object***REMOVED***:
    ***REMOVED***
    A username/password pair. Use like a namedtuple.
    ***REMOVED***

    def __init__(self, username, password***REMOVED***:
        self.username = username
        self.password = password

    def __iter__(self***REMOVED***:
        yield self.username
        yield self.password

    def __str__(self***REMOVED***:
        return '%(username***REMOVED***s:%(password***REMOVED***s' % vars(self***REMOVED***


class PyPIConfig(configparser.RawConfigParser***REMOVED***:
    def __init__(self***REMOVED***:
        ***REMOVED***
        Load from ~/.pypirc
        ***REMOVED***
        defaults = dict.fromkeys(['username', 'password', 'repository'***REMOVED***, ''***REMOVED***
        configparser.RawConfigParser.__init__(self, defaults***REMOVED***

        rc = os.path.join(os.path.expanduser('~'***REMOVED***, '.pypirc'***REMOVED***
        if os.path.exists(rc***REMOVED***:
            self.read(rc***REMOVED***

    @property
    def creds_by_repository(self***REMOVED***:
        sections_with_repositories = [
            section for section in self.sections(***REMOVED***
            if self.get(section, 'repository'***REMOVED***.strip(***REMOVED***
        ***REMOVED***

        return dict(map(self._get_repo_cred, sections_with_repositories***REMOVED******REMOVED***

    def _get_repo_cred(self, section***REMOVED***:
        repo = self.get(section, 'repository'***REMOVED***.strip(***REMOVED***
        return repo, Credential(
            self.get(section, 'username'***REMOVED***.strip(***REMOVED***,
            self.get(section, 'password'***REMOVED***.strip(***REMOVED***,
        ***REMOVED***

    def find_credential(self, url***REMOVED***:
        ***REMOVED***
        If the URL indicated appears to be a repository defined in this
        config, return the credential for that repository.
        ***REMOVED***
        for repository, cred in self.creds_by_repository.items(***REMOVED***:
            if url.startswith(repository***REMOVED***:
                return cred


def open_with_auth(url, opener=urllib.request.urlopen***REMOVED***:
    ***REMOVED***Open a urllib2 request, handling HTTP authentication***REMOVED***

    scheme, netloc, path, params, query, frag = urllib.parse.urlparse(url***REMOVED***

    # Double scheme does not raise on Mac OS X as revealed by a
    # failing test. We would expect "nonnumeric port". Refs #20.
    if netloc.endswith(':'***REMOVED***:
        raise http_client.InvalidURL("nonnumeric port: ''"***REMOVED***

    if scheme in ('http', 'https'***REMOVED***:
        auth, host = splituser(netloc***REMOVED***
    else:
        auth = None

    if not auth:
        cred = PyPIConfig(***REMOVED***.find_credential(url***REMOVED***
        if cred:
            auth = str(cred***REMOVED***
            info = cred.username, url
            log.info('Authenticating as %s for %s (from .pypirc***REMOVED***', *info***REMOVED***

    if auth:
        auth = "Basic " + _encode_auth(auth***REMOVED***
        parts = scheme, host, path, params, query, frag
        new_url = urllib.parse.urlunparse(parts***REMOVED***
        request = urllib.request.Request(new_url***REMOVED***
        request.add_header("Authorization", auth***REMOVED***
    else:
        request = urllib.request.Request(url***REMOVED***

    request.add_header('User-Agent', user_agent***REMOVED***
    fp = opener(request***REMOVED***

    if auth:
        # Put authentication info back into request URL if same host,
        # so that links found on the page will work
        s2, h2, path2, param2, query2, frag2 = urllib.parse.urlparse(fp.url***REMOVED***
        if s2 == scheme and h2 == host:
            parts = s2, netloc, path2, param2, query2, frag2
            fp.url = urllib.parse.urlunparse(parts***REMOVED***

    return fp


# adding a timeout to avoid freezing package_index
open_with_auth = socket_timeout(_SOCKET_TIMEOUT***REMOVED***(open_with_auth***REMOVED***


def fix_sf_url(url***REMOVED***:
    return url  # backward compatibility


def local_open(url***REMOVED***:
    ***REMOVED***Read a local path, with special support for directories***REMOVED***
    scheme, server, path, param, query, frag = urllib.parse.urlparse(url***REMOVED***
    filename = urllib.request.url2pathname(path***REMOVED***
    if os.path.isfile(filename***REMOVED***:
        return urllib.request.urlopen(url***REMOVED***
    elif path.endswith('/'***REMOVED*** and os.path.isdir(filename***REMOVED***:
        files = [***REMOVED***
        for f in os.listdir(filename***REMOVED***:
            filepath = os.path.join(filename, f***REMOVED***
            if f == 'index.html':
                with open(filepath, 'r'***REMOVED*** as fp:
                    body = fp.read(***REMOVED***
                break
            elif os.path.isdir(filepath***REMOVED***:
                f += '/'
            files.append('<a href="{name***REMOVED***">{name***REMOVED***</a>'.format(name=f***REMOVED******REMOVED***
        else:
            tmpl = ("<html><head><title>{url***REMOVED***</title>"
                "</head><body>{files***REMOVED***</body></html>"***REMOVED***
            body = tmpl.format(url=url, files='\n'.join(files***REMOVED******REMOVED***
        status, message = 200, "OK"
    else:
        status, message, body = 404, "Path not found", "Not found"

    headers = {'content-type': 'text/html'***REMOVED***
    body_stream = six.StringIO(body***REMOVED***
    return urllib.error.HTTPError(url, status, message, headers, body_stream***REMOVED***
