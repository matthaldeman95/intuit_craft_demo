***REMOVED***
Improved support for Microsoft Visual C++ compilers.

Known supported compilers:
--------------------------
Microsoft Visual C++ 9.0:
    Microsoft Visual C++ Compiler for Python 2.7 (x86, amd64***REMOVED***;
    Microsoft Windows SDK 7.0 (x86, x64, ia64***REMOVED***;
    Microsoft Windows SDK 6.1 (x86, x64, ia64***REMOVED***

Microsoft Visual C++ 10.0:
    Microsoft Windows SDK 7.1 (x86, x64, ia64***REMOVED***

Microsoft Visual C++ 14.0:
    Microsoft Visual C++ Build Tools 2015 (x86, x64, arm***REMOVED***
***REMOVED***

***REMOVED***
import sys
import platform
import itertools
import distutils.errors
from pkg_resources.extern.packaging.version import LegacyVersion

from setuptools.extern.six.moves import filterfalse

from .monkey import get_unpatched

if platform.system(***REMOVED*** == 'Windows':
    from setuptools.extern.six.moves import winreg
    safe_env = os.environ
else:
    ***REMOVED***
    Mock winreg and environ so the module can be imported
    on this platform.
    ***REMOVED***

    class winreg:
        HKEY_USERS = None
        HKEY_CURRENT_USER = None
        HKEY_LOCAL_MACHINE = None
        HKEY_CLASSES_ROOT = None

    safe_env = dict(***REMOVED***

***REMOVED***
    from distutils.msvc9compiler import Reg
except ImportError:
    pass


def msvc9_find_vcvarsall(version***REMOVED***:
    ***REMOVED***
    Patched "distutils.msvc9compiler.find_vcvarsall" to use the standalone
    compiler build for Python (VCForPython***REMOVED***. Fall back to original behavior
    when the standalone compiler is not available.

    Redirect the path of "vcvarsall.bat".

    Known supported compilers
    -------------------------
    Microsoft Visual C++ 9.0:
        Microsoft Visual C++ Compiler for Python 2.7 (x86, amd64***REMOVED***

    Parameters
    ----------
    version: float
        Required Microsoft Visual C++ version.

    Return
    ------
    vcvarsall.bat path: str
    ***REMOVED***
    VC_BASE = r'Software\%sMicrosoft\DevDiv\VCForPython\%0.1f'
    key = VC_BASE % ('', version***REMOVED***
    ***REMOVED***
        # Per-user installs register the compiler path here
        productdir = Reg.get_value(key, "installdir"***REMOVED***
    except KeyError:
        ***REMOVED***
            # All-user installs on a 64-bit system register here
            key = VC_BASE % ('Wow6432Node\\', version***REMOVED***
            productdir = Reg.get_value(key, "installdir"***REMOVED***
        except KeyError:
            productdir = None

    if productdir:
        vcvarsall = os.path.os.path.join(productdir, "vcvarsall.bat"***REMOVED***
        if os.path.isfile(vcvarsall***REMOVED***:
            return vcvarsall

    return get_unpatched(msvc9_find_vcvarsall***REMOVED***(version***REMOVED***


def msvc9_query_vcvarsall(ver, arch='x86', *args, **kwargs***REMOVED***:
    ***REMOVED***
    Patched "distutils.msvc9compiler.query_vcvarsall" for support standalones
    compilers.

    Set environment without use of "vcvarsall.bat".

    Known supported compilers
    -------------------------
    Microsoft Visual C++ 9.0:
        Microsoft Visual C++ Compiler for Python 2.7 (x86, amd64***REMOVED***;
        Microsoft Windows SDK 7.0 (x86, x64, ia64***REMOVED***;
        Microsoft Windows SDK 6.1 (x86, x64, ia64***REMOVED***

    Microsoft Visual C++ 10.0:
        Microsoft Windows SDK 7.1 (x86, x64, ia64***REMOVED***

    Parameters
    ----------
    ver: float
        Required Microsoft Visual C++ version.
    arch: str
        Target architecture.

    Return
    ------
    environment: dict
    ***REMOVED***
    # Try to get environement from vcvarsall.bat (Classical way***REMOVED***
    ***REMOVED***
        orig = get_unpatched(msvc9_query_vcvarsall***REMOVED***
        return orig(ver, arch, *args, **kwargs***REMOVED***
    except distutils.errors.DistutilsPlatformError:
        # Pass error if Vcvarsall.bat is missing
        pass
    except ValueError:
        # Pass error if environment not set after executing vcvarsall.bat
        pass

    # If error, try to set environment directly
    ***REMOVED***
        return EnvironmentInfo(arch, ver***REMOVED***.return_env(***REMOVED***
    except distutils.errors.DistutilsPlatformError as exc:
        _augment_exception(exc, ver, arch***REMOVED***
        raise


def msvc14_get_vc_env(plat_spec***REMOVED***:
    ***REMOVED***
    Patched "distutils._msvccompiler._get_vc_env" for support standalones
    compilers.

    Set environment without use of "vcvarsall.bat".

    Known supported compilers
    -------------------------
    Microsoft Visual C++ 14.0:
        Microsoft Visual C++ Build Tools 2015 (x86, x64, arm***REMOVED***

    Parameters
    ----------
    plat_spec: str
        Target architecture.

    Return
    ------
    environment: dict
    ***REMOVED***
    # Try to get environment from vcvarsall.bat (Classical way***REMOVED***
    ***REMOVED***
        return get_unpatched(msvc14_get_vc_env***REMOVED***(plat_spec***REMOVED***
    except distutils.errors.DistutilsPlatformError:
        # Pass error Vcvarsall.bat is missing
        pass

    # If error, try to set environment directly
    ***REMOVED***
        return EnvironmentInfo(plat_spec, vc_min_ver=14.0***REMOVED***.return_env(***REMOVED***
    except distutils.errors.DistutilsPlatformError as exc:
        _augment_exception(exc, 14.0***REMOVED***
        raise


def msvc14_gen_lib_options(*args, **kwargs***REMOVED***:
    ***REMOVED***
    Patched "distutils._msvccompiler.gen_lib_options" for fix
    compatibility between "numpy.distutils" and "distutils._msvccompiler"
    (for Numpy < 1.11.2***REMOVED***
    ***REMOVED***
    if "numpy.distutils" in sys.modules:
        import numpy as np
        if LegacyVersion(np.__version__***REMOVED*** < LegacyVersion('1.11.2'***REMOVED***:
            return np.distutils.ccompiler.gen_lib_options(*args, **kwargs***REMOVED***
    return get_unpatched(msvc14_gen_lib_options***REMOVED***(*args, **kwargs***REMOVED***


def _augment_exception(exc, version, arch=''***REMOVED***:
    ***REMOVED***
    Add details to the exception message to help guide the user
    as to what action will resolve it.
    ***REMOVED***
    # Error if MSVC++ directory not found or environment not set
    message = exc.args[0***REMOVED***

    if "vcvarsall" in message.lower(***REMOVED*** or "visual c" in message.lower(***REMOVED***:
        # Special error message if MSVC++ not installed
        tmpl = 'Microsoft Visual C++ {version:0.1f***REMOVED*** is required.'
        message = tmpl.format(**locals(***REMOVED******REMOVED***
        msdownload = 'www.microsoft.com/download/details.aspx?id=%d'
        if version == 9.0:
            if arch.lower(***REMOVED***.find('ia64'***REMOVED*** > -1:
                # For VC++ 9.0, if IA64 support is needed, redirect user
                # to Windows SDK 7.0
                message += ' Get it with "Microsoft Windows SDK 7.0": '
                message += msdownload % 3138
            else:
                # For VC++ 9.0 redirect user to Vc++ for Python 2.7 :
                # This redirection link is maintained by Microsoft.
                # Contact vspython@microsoft.com if it needs updating.
                message += ' Get it from http://aka.ms/vcpython27'
        elif version == 10.0:
            # For VC++ 10.0 Redirect user to Windows SDK 7.1
            message += ' Get it with "Microsoft Windows SDK 7.1": '
            message += msdownload % 8279
        elif version >= 14.0:
            # For VC++ 14.0 Redirect user to Visual C++ Build Tools
            message += (' Get it with "Microsoft Visual C++ Build Tools": '
                        r'http://landinghub.visualstudio.com/'
                        'visual-cpp-build-tools'***REMOVED***

    exc.args = (message, ***REMOVED***


class PlatformInfo:
    ***REMOVED***
    Current and Target Architectures informations.

    Parameters
    ----------
    arch: str
        Target architecture.
    ***REMOVED***
    current_cpu = safe_env.get('processor_architecture', ''***REMOVED***.lower(***REMOVED***

    def __init__(self, arch***REMOVED***:
        self.arch = arch.lower(***REMOVED***.replace('x64', 'amd64'***REMOVED***

    @property
    def target_cpu(self***REMOVED***:
        return self.arch[self.arch.find('_'***REMOVED*** + 1:***REMOVED***

    def target_is_x86(self***REMOVED***:
        return self.target_cpu == 'x86'

    def current_is_x86(self***REMOVED***:
        return self.current_cpu == 'x86'

    def current_dir(self, hidex86=False, x64=False***REMOVED***:
        ***REMOVED***
        Current platform specific subfolder.

        Parameters
        ----------
        hidex86: bool
            return '' and not '\x86' if architecture is x86.
        x64: bool
            return '\x64' and not '\amd64' if architecture is amd64.

        Return
        ------
        subfolder: str
            '\target', or '' (see hidex86 parameter***REMOVED***
        ***REMOVED***
        return (
            '' if (self.current_cpu == 'x86' and hidex86***REMOVED*** else
            r'\x64' if (self.current_cpu == 'amd64' and x64***REMOVED*** else
            r'\%s' % self.current_cpu
        ***REMOVED***

    def target_dir(self, hidex86=False, x64=False***REMOVED***:
        ***REMOVED***
        Target platform specific subfolder.

        Parameters
        ----------
        hidex86: bool
            return '' and not '\x86' if architecture is x86.
        x64: bool
            return '\x64' and not '\amd64' if architecture is amd64.

        Return
        ------
        subfolder: str
            '\current', or '' (see hidex86 parameter***REMOVED***
        ***REMOVED***
        return (
            '' if (self.target_cpu == 'x86' and hidex86***REMOVED*** else
            r'\x64' if (self.target_cpu == 'amd64' and x64***REMOVED*** else
            r'\%s' % self.target_cpu
        ***REMOVED***

    def cross_dir(self, forcex86=False***REMOVED***:
        ***REMOVED***
        Cross platform specific subfolder.

        Parameters
        ----------
        forcex86: bool
            Use 'x86' as current architecture even if current acritecture is
            not x86.

        Return
        ------
        subfolder: str
            '' if target architecture is current architecture,
            '\current_target' if not.
        ***REMOVED***
        current = 'x86' if forcex86 else self.current_cpu
        return (
            '' if self.target_cpu == current else
            self.target_dir(***REMOVED***.replace('\\', '\\%s_' % current***REMOVED***
        ***REMOVED***


class RegistryInfo:
    ***REMOVED***
    Microsoft Visual Studio related registry informations.

    Parameters
    ----------
    platform_info: PlatformInfo
        "PlatformInfo" instance.
    ***REMOVED***
    HKEYS = (winreg.HKEY_USERS,
             winreg.HKEY_CURRENT_USER,
             winreg.HKEY_LOCAL_MACHINE,
             winreg.HKEY_CLASSES_ROOT***REMOVED***

    def __init__(self, platform_info***REMOVED***:
        self.pi = platform_info

    @property
    def visualstudio(self***REMOVED***:
        ***REMOVED***
        Microsoft Visual Studio root registry key.
        ***REMOVED***
        return 'VisualStudio'

    @property
    def sxs(self***REMOVED***:
        ***REMOVED***
        Microsoft Visual Studio SxS registry key.
        ***REMOVED***
        return os.path.join(self.visualstudio, 'SxS'***REMOVED***

    @property
    def vc(self***REMOVED***:
        ***REMOVED***
        Microsoft Visual C++ VC7 registry key.
        ***REMOVED***
        return os.path.join(self.sxs, 'VC7'***REMOVED***

    @property
    def vs(self***REMOVED***:
        ***REMOVED***
        Microsoft Visual Studio VS7 registry key.
        ***REMOVED***
        return os.path.join(self.sxs, 'VS7'***REMOVED***

    @property
    def vc_for_python(self***REMOVED***:
        ***REMOVED***
        Microsoft Visual C++ for Python registry key.
        ***REMOVED***
        return r'DevDiv\VCForPython'

    @property
    def microsoft_sdk(self***REMOVED***:
        ***REMOVED***
        Microsoft SDK registry key.
        ***REMOVED***
        return 'Microsoft SDKs'

    @property
    def windows_sdk(self***REMOVED***:
        ***REMOVED***
        Microsoft Windows/Platform SDK registry key.
        ***REMOVED***
        return os.path.join(self.microsoft_sdk, 'Windows'***REMOVED***

    @property
    def netfx_sdk(self***REMOVED***:
        ***REMOVED***
        Microsoft .NET Framework SDK registry key.
        ***REMOVED***
        return os.path.join(self.microsoft_sdk, 'NETFXSDK'***REMOVED***

    @property
    def windows_kits_roots(self***REMOVED***:
        ***REMOVED***
        Microsoft Windows Kits Roots registry key.
        ***REMOVED***
        return r'Windows Kits\Installed Roots'

    def microsoft(self, key, x86=False***REMOVED***:
        ***REMOVED***
        Return key in Microsoft software registry.

        Parameters
        ----------
        key: str
            Registry key path where look.
        x86: str
            Force x86 software registry.

        Return
        ------
        str: value
        ***REMOVED***
        node64 = '' if self.pi.current_is_x86(***REMOVED*** or x86 else r'\Wow6432Node'
        return os.path.join('Software', node64, 'Microsoft', key***REMOVED***

    def lookup(self, key, name***REMOVED***:
        ***REMOVED***
        Look for values in registry in Microsoft software registry.

        Parameters
        ----------
        key: str
            Registry key path where look.
        name: str
            Value name to find.

        Return
        ------
        str: value
        ***REMOVED***
        KEY_READ = winreg.KEY_READ
        openkey = winreg.OpenKey
        ms = self.microsoft
        for hkey in self.HKEYS:
            ***REMOVED***
                bkey = openkey(hkey, ms(key***REMOVED***, 0, KEY_READ***REMOVED***
            except (OSError, IOError***REMOVED***:
                if not self.pi.current_is_x86(***REMOVED***:
                    ***REMOVED***
                        bkey = openkey(hkey, ms(key, True***REMOVED***, 0, KEY_READ***REMOVED***
                    except (OSError, IOError***REMOVED***:
                        continue
                else:
                    continue
            ***REMOVED***
                return winreg.QueryValueEx(bkey, name***REMOVED***[0***REMOVED***
            except (OSError, IOError***REMOVED***:
                pass


class SystemInfo:
    ***REMOVED***
    Microsoft Windows and Visual Studio related system inormations.

    Parameters
    ----------
    registry_info: RegistryInfo
        "RegistryInfo" instance.
    vc_ver: float
        Required Microsoft Visual C++ version.
    ***REMOVED***

    # Variables and properties in this class use originals CamelCase variables
    # names from Microsoft source files for more easy comparaison.
    WinDir = safe_env.get('WinDir', ''***REMOVED***
    ProgramFiles = safe_env.get('ProgramFiles', ''***REMOVED***
    ProgramFilesx86 = safe_env.get('ProgramFiles(x86***REMOVED***', ProgramFiles***REMOVED***

    def __init__(self, registry_info, vc_ver=None***REMOVED***:
        self.ri = registry_info
        self.pi = self.ri.pi
        if vc_ver:
            self.vc_ver = vc_ver
        else:
            ***REMOVED***
                self.vc_ver = self.find_available_vc_vers(***REMOVED***[-1***REMOVED***
            except IndexError:
                err = 'No Microsoft Visual C++ version found'
                raise distutils.errors.DistutilsPlatformError(err***REMOVED***

    def find_available_vc_vers(self***REMOVED***:
        ***REMOVED***
        Find all available Microsoft Visual C++ versions.
        ***REMOVED***
        vckeys = (self.ri.vc, self.ri.vc_for_python***REMOVED***
        vc_vers = [***REMOVED***
        for hkey in self.ri.HKEYS:
            for key in vckeys:
                ***REMOVED***
                    bkey = winreg.OpenKey(hkey, key, 0, winreg.KEY_READ***REMOVED***
                except (OSError, IOError***REMOVED***:
                    continue
                subkeys, values, _ = winreg.QueryInfoKey(bkey***REMOVED***
                for i in range(values***REMOVED***:
                    ***REMOVED***
                        ver = float(winreg.EnumValue(bkey, i***REMOVED***[0***REMOVED******REMOVED***
                        if ver not in vc_vers:
                            vc_vers.append(ver***REMOVED***
                    except ValueError:
                        pass
                for i in range(subkeys***REMOVED***:
                    ***REMOVED***
                        ver = float(winreg.EnumKey(bkey, i***REMOVED******REMOVED***
                        if ver not in vc_vers:
                            vc_vers.append(ver***REMOVED***
                    except ValueError:
                        pass
        return sorted(vc_vers***REMOVED***

    @property
    def VSInstallDir(self***REMOVED***:
        ***REMOVED***
        Microsoft Visual Studio directory.
        ***REMOVED***
        # Default path
        name = 'Microsoft Visual Studio %0.1f' % self.vc_ver
        default = os.path.join(self.ProgramFilesx86, name***REMOVED***

        # Try to get path from registry, if fail use default path
        return self.ri.lookup(self.ri.vs, '%0.1f' % self.vc_ver***REMOVED*** or default

    @property
    def VCInstallDir(self***REMOVED***:
        ***REMOVED***
        Microsoft Visual C++ directory.
        ***REMOVED***
        # Default path
        default = r'Microsoft Visual Studio %0.1f\VC' % self.vc_ver
        guess_vc = os.path.join(self.ProgramFilesx86, default***REMOVED***

        # Try to get "VC++ for Python" path from registry as default path
        reg_path = os.path.join(self.ri.vc_for_python, '%0.1f' % self.vc_ver***REMOVED***
        python_vc = self.ri.lookup(reg_path, 'installdir'***REMOVED***
        default_vc = os.path.join(python_vc, 'VC'***REMOVED*** if python_vc else guess_vc

        # Try to get path from registry, if fail use default path
        path = self.ri.lookup(self.ri.vc, '%0.1f' % self.vc_ver***REMOVED*** or default_vc

        if not os.path.isdir(path***REMOVED***:
            msg = 'Microsoft Visual C++ directory not found'
            raise distutils.errors.DistutilsPlatformError(msg***REMOVED***

        return path

    @property
    def WindowsSdkVersion(self***REMOVED***:
        ***REMOVED***
        Microsoft Windows SDK versions.
        ***REMOVED***
        # Set Windows SDK versions for specified MSVC++ version
        if self.vc_ver <= 9.0:
            return ('7.0', '6.1', '6.0a'***REMOVED***
        elif self.vc_ver == 10.0:
            return ('7.1', '7.0a'***REMOVED***
        elif self.vc_ver == 11.0:
            return ('8.0', '8.0a'***REMOVED***
        elif self.vc_ver == 12.0:
            return ('8.1', '8.1a'***REMOVED***
        elif self.vc_ver >= 14.0:
            return ('10.0', '8.1'***REMOVED***

    @property
    def WindowsSdkDir(self***REMOVED***:
        ***REMOVED***
        Microsoft Windows SDK directory.
        ***REMOVED***
        sdkdir = ''
        for ver in self.WindowsSdkVersion:
            # Try to get it from registry
            loc = os.path.join(self.ri.windows_sdk, 'v%s' % ver***REMOVED***
            sdkdir = self.ri.lookup(loc, 'installationfolder'***REMOVED***
            if sdkdir:
                break
        if not sdkdir or not os.path.isdir(sdkdir***REMOVED***:
            # Try to get "VC++ for Python" version from registry
            path = os.path.join(self.ri.vc_for_python, '%0.1f' % self.vc_ver***REMOVED***
            install_base = self.ri.lookup(path, 'installdir'***REMOVED***
            if install_base:
                sdkdir = os.path.join(install_base, 'WinSDK'***REMOVED***
        if not sdkdir or not os.path.isdir(sdkdir***REMOVED***:
            # If fail, use default new path
            for ver in self.WindowsSdkVersion:
                intver = ver[:ver.rfind('.'***REMOVED******REMOVED***
                path = r'Microsoft SDKs\Windows Kits\%s' % (intver***REMOVED***
                d = os.path.join(self.ProgramFiles, path***REMOVED***
                if os.path.isdir(d***REMOVED***:
                    sdkdir = d
        if not sdkdir or not os.path.isdir(sdkdir***REMOVED***:
            # If fail, use default old path
            for ver in self.WindowsSdkVersion:
                path = r'Microsoft SDKs\Windows\v%s' % ver
                d = os.path.join(self.ProgramFiles, path***REMOVED***
                if os.path.isdir(d***REMOVED***:
                    sdkdir = d
        if not sdkdir:
            # If fail, use Platform SDK
            sdkdir = os.path.join(self.VCInstallDir, 'PlatformSDK'***REMOVED***
        return sdkdir

    @property
    def WindowsSDKExecutablePath(self***REMOVED***:
        ***REMOVED***
        Microsoft Windows SDK executable directory.
        ***REMOVED***
        # Find WinSDK NetFx Tools registry dir name
        if self.vc_ver <= 11.0:
            netfxver = 35
            arch = ''
        else:
            netfxver = 40
            hidex86 = True if self.vc_ver <= 12.0 else False
            arch = self.pi.current_dir(x64=True, hidex86=hidex86***REMOVED***
        fx = 'WinSDK-NetFx%dTools%s' % (netfxver, arch.replace('\\', '-'***REMOVED******REMOVED***

        # liste all possibles registry paths
        regpaths = [***REMOVED***
        if self.vc_ver >= 14.0:
            for ver in self.NetFxSdkVersion:
                regpaths += [os.path.join(self.ri.netfx_sdk, ver, fx***REMOVED******REMOVED***

        for ver in self.WindowsSdkVersion:
            regpaths += [os.path.join(self.ri.windows_sdk, 'v%sA' % ver, fx***REMOVED******REMOVED***

        # Return installation folder from the more recent path
        for path in regpaths:
            execpath = self.ri.lookup(path, 'installationfolder'***REMOVED***
            if execpath:
                break
        return execpath

    @property
    def FSharpInstallDir(self***REMOVED***:
        ***REMOVED***
        Microsoft Visual F# directory.
        ***REMOVED***
        path = r'%0.1f\Setup\F#' % self.vc_ver
        path = os.path.join(self.ri.visualstudio, path***REMOVED***
        return self.ri.lookup(path, 'productdir'***REMOVED*** or ''

    @property
    def UniversalCRTSdkDir(self***REMOVED***:
        ***REMOVED***
        Microsoft Universal CRT SDK directory.
        ***REMOVED***
        # Set Kit Roots versions for specified MSVC++ version
        if self.vc_ver >= 14.0:
            vers = ('10', '81'***REMOVED***
        else:
            vers = (***REMOVED***

        # Find path of the more recent Kit
        for ver in vers:
            sdkdir = self.ri.lookup(self.ri.windows_kits_roots,
                                    'kitsroot%s' % ver***REMOVED***
            if sdkdir:
                break
        return sdkdir or ''

    @property
    def NetFxSdkVersion(self***REMOVED***:
        ***REMOVED***
        Microsoft .NET Framework SDK versions.
        ***REMOVED***
        # Set FxSdk versions for specified MSVC++ version
        if self.vc_ver >= 14.0:
            return ('4.6.1', '4.6'***REMOVED***
        else:
            return (***REMOVED***

    @property
    def NetFxSdkDir(self***REMOVED***:
        ***REMOVED***
        Microsoft .NET Framework SDK directory.
        ***REMOVED***
        for ver in self.NetFxSdkVersion:
            loc = os.path.join(self.ri.netfx_sdk, ver***REMOVED***
            sdkdir = self.ri.lookup(loc, 'kitsinstallationfolder'***REMOVED***
            if sdkdir:
                break
        return sdkdir or ''

    @property
    def FrameworkDir32(self***REMOVED***:
        ***REMOVED***
        Microsoft .NET Framework 32bit directory.
        ***REMOVED***
        # Default path
        guess_fw = os.path.join(self.WinDir, r'Microsoft.NET\Framework'***REMOVED***

        # Try to get path from registry, if fail use default path
        return self.ri.lookup(self.ri.vc, 'frameworkdir32'***REMOVED*** or guess_fw

    @property
    def FrameworkDir64(self***REMOVED***:
        ***REMOVED***
        Microsoft .NET Framework 64bit directory.
        ***REMOVED***
        # Default path
        guess_fw = os.path.join(self.WinDir, r'Microsoft.NET\Framework64'***REMOVED***

        # Try to get path from registry, if fail use default path
        return self.ri.lookup(self.ri.vc, 'frameworkdir64'***REMOVED*** or guess_fw

    @property
    def FrameworkVersion32(self***REMOVED***:
        ***REMOVED***
        Microsoft .NET Framework 32bit versions.
        ***REMOVED***
        return self._find_dot_net_versions(32***REMOVED***

    @property
    def FrameworkVersion64(self***REMOVED***:
        ***REMOVED***
        Microsoft .NET Framework 64bit versions.
        ***REMOVED***
        return self._find_dot_net_versions(64***REMOVED***

    def _find_dot_net_versions(self, bits=32***REMOVED***:
        ***REMOVED***
        Find Microsoft .NET Framework versions.

        Parameters
        ----------
        bits: int
            Platform number of bits: 32 or 64.
        ***REMOVED***
        # Find actual .NET version
        ver = self.ri.lookup(self.ri.vc, 'frameworkver%d' % bits***REMOVED*** or ''

        # Set .NET versions for specified MSVC++ version
        if self.vc_ver >= 12.0:
            frameworkver = (ver, 'v4.0'***REMOVED***
        elif self.vc_ver >= 10.0:
            frameworkver = ('v4.0.30319' if ver.lower(***REMOVED***[:2***REMOVED*** != 'v4' else ver,
                            'v3.5'***REMOVED***
        elif self.vc_ver == 9.0:
            frameworkver = ('v3.5', 'v2.0.50727'***REMOVED***
        if self.vc_ver == 8.0:
            frameworkver = ('v3.0', 'v2.0.50727'***REMOVED***
        return frameworkver


class EnvironmentInfo:
    ***REMOVED***
    Return environment variables for specified Microsoft Visual C++ version
    and platform : Lib, Include, Path and libpath.

    This function is compatible with Microsoft Visual C++ 9.0 to 14.0.

    Script created by analysing Microsoft environment configuration files like
    "vcvars[...***REMOVED***.bat", "SetEnv.Cmd", "vcbuildtools.bat", ...

    Parameters
    ----------
    arch: str
        Target architecture.
    vc_ver: float
        Required Microsoft Visual C++ version. If not set, autodetect the last
        version.
    vc_min_ver: float
        Minimum Microsoft Visual C++ version.
    ***REMOVED***

    # Variables and properties in this class use originals CamelCase variables
    # names from Microsoft source files for more easy comparaison.

    def __init__(self, arch, vc_ver=None, vc_min_ver=None***REMOVED***:
        self.pi = PlatformInfo(arch***REMOVED***
        self.ri = RegistryInfo(self.pi***REMOVED***
        self.si = SystemInfo(self.ri, vc_ver***REMOVED***

        if vc_min_ver:
            if self.vc_ver < vc_min_ver:
                err = 'No suitable Microsoft Visual C++ version found'
                raise distutils.errors.DistutilsPlatformError(err***REMOVED***

    @property
    def vc_ver(self***REMOVED***:
        ***REMOVED***
        Microsoft Visual C++ version.
        ***REMOVED***
        return self.si.vc_ver

    @property
    def VSTools(self***REMOVED***:
        ***REMOVED***
        Microsoft Visual Studio Tools
        ***REMOVED***
        paths = [r'Common7\IDE', r'Common7\Tools'***REMOVED***

        if self.vc_ver >= 14.0:
            arch_subdir = self.pi.current_dir(hidex86=True, x64=True***REMOVED***
            paths += [r'Common7\IDE\CommonExtensions\Microsoft\TestWindow'***REMOVED***
            paths += [r'Team Tools\Performance Tools'***REMOVED***
            paths += [r'Team Tools\Performance Tools%s' % arch_subdir***REMOVED***

        return [os.path.join(self.si.VSInstallDir, path***REMOVED*** for path in paths***REMOVED***

    @property
    def VCIncludes(self***REMOVED***:
        ***REMOVED***
        Microsoft Visual C++ & Microsoft Foundation Class Includes
        ***REMOVED***
        return [os.path.join(self.si.VCInstallDir, 'Include'***REMOVED***,
                os.path.join(self.si.VCInstallDir, r'ATLMFC\Include'***REMOVED******REMOVED***

    @property
    def VCLibraries(self***REMOVED***:
        ***REMOVED***
        Microsoft Visual C++ & Microsoft Foundation Class Libraries
        ***REMOVED***
        arch_subdir = self.pi.target_dir(hidex86=True***REMOVED***
        paths = ['Lib%s' % arch_subdir, r'ATLMFC\Lib%s' % arch_subdir***REMOVED***

        if self.vc_ver >= 14.0:
            paths += [r'Lib\store%s' % arch_subdir***REMOVED***

        return [os.path.join(self.si.VCInstallDir, path***REMOVED*** for path in paths***REMOVED***

    @property
    def VCStoreRefs(self***REMOVED***:
        ***REMOVED***
        Microsoft Visual C++ store references Libraries
        ***REMOVED***
        if self.vc_ver < 14.0:
            return [***REMOVED***
        return [os.path.join(self.si.VCInstallDir, r'Lib\store\references'***REMOVED******REMOVED***

    @property
    def VCTools(self***REMOVED***:
        ***REMOVED***
        Microsoft Visual C++ Tools
        ***REMOVED***
        si = self.si
        tools = [os.path.join(si.VCInstallDir, 'VCPackages'***REMOVED******REMOVED***

        forcex86 = True if self.vc_ver <= 10.0 else False
        arch_subdir = self.pi.cross_dir(forcex86***REMOVED***
        if arch_subdir:
            tools += [os.path.join(si.VCInstallDir, 'Bin%s' % arch_subdir***REMOVED******REMOVED***

        if self.vc_ver >= 14.0:
            path = 'Bin%s' % self.pi.current_dir(hidex86=True***REMOVED***
            tools += [os.path.join(si.VCInstallDir, path***REMOVED******REMOVED***

        else:
            tools += [os.path.join(si.VCInstallDir, 'Bin'***REMOVED******REMOVED***

        return tools

    @property
    def OSLibraries(self***REMOVED***:
        ***REMOVED***
        Microsoft Windows SDK Libraries
        ***REMOVED***
        if self.vc_ver <= 10.0:
            arch_subdir = self.pi.target_dir(hidex86=True, x64=True***REMOVED***
            return [os.path.join(self.si.WindowsSdkDir, 'Lib%s' % arch_subdir***REMOVED******REMOVED***

        else:
            arch_subdir = self.pi.target_dir(x64=True***REMOVED***
            lib = os.path.join(self.si.WindowsSdkDir, 'lib'***REMOVED***
            libver = self._get_content_dirname(lib***REMOVED***
            return [os.path.join(lib, '%sum%s' % (libver, arch_subdir***REMOVED******REMOVED******REMOVED***

    @property
    def OSIncludes(self***REMOVED***:
        ***REMOVED***
        Microsoft Windows SDK Include
        ***REMOVED***
        include = os.path.join(self.si.WindowsSdkDir, 'include'***REMOVED***

        if self.vc_ver <= 10.0:
            return [include, os.path.join(include, 'gl'***REMOVED******REMOVED***

        else:
            if self.vc_ver >= 14.0:
                sdkver = self._get_content_dirname(include***REMOVED***
            else:
                sdkver = ''
            return [os.path.join(include, '%sshared' % sdkver***REMOVED***,
                    os.path.join(include, '%sum' % sdkver***REMOVED***,
                    os.path.join(include, '%swinrt' % sdkver***REMOVED******REMOVED***

    @property
    def OSLibpath(self***REMOVED***:
        ***REMOVED***
        Microsoft Windows SDK Libraries Paths
        ***REMOVED***
        ref = os.path.join(self.si.WindowsSdkDir, 'References'***REMOVED***
        libpath = [***REMOVED***

        if self.vc_ver <= 9.0:
            libpath += self.OSLibraries

        if self.vc_ver >= 11.0:
            libpath += [os.path.join(ref, r'CommonConfiguration\Neutral'***REMOVED******REMOVED***

        if self.vc_ver >= 14.0:
            libpath += [
                ref,
                os.path.join(self.si.WindowsSdkDir, 'UnionMetadata'***REMOVED***,
                os.path.join(
                    ref,
                    'Windows.Foundation.UniversalApiContract',
                    '1.0.0.0',
                ***REMOVED***,
                os.path.join(
                    ref,
                    'Windows.Foundation.FoundationContract',
                    '1.0.0.0',
                ***REMOVED***,
                os.path.join(
                    ref,
                    'Windows.Networking.Connectivity.WwanContract',
                    '1.0.0.0',
                ***REMOVED***,
                os.path.join(
                    self.si.WindowsSdkDir,
                    'ExtensionSDKs',
                    'Microsoft.VCLibs',
                    '%0.1f' % self.vc_ver,
                    'References',
                    'CommonConfiguration',
                    'neutral',
                ***REMOVED***,
            ***REMOVED***
        return libpath

    @property
    def SdkTools(self***REMOVED***:
        ***REMOVED***
        Microsoft Windows SDK Tools
        ***REMOVED***
        bin_dir = 'Bin' if self.vc_ver <= 11.0 else r'Bin\x86'
        tools = [os.path.join(self.si.WindowsSdkDir, bin_dir***REMOVED******REMOVED***

        if not self.pi.current_is_x86(***REMOVED***:
            arch_subdir = self.pi.current_dir(x64=True***REMOVED***
            path = 'Bin%s' % arch_subdir
            tools += [os.path.join(self.si.WindowsSdkDir, path***REMOVED******REMOVED***

        if self.vc_ver == 10.0 or self.vc_ver == 11.0:
            if self.pi.target_is_x86(***REMOVED***:
                arch_subdir = ''
            else:
                arch_subdir = self.pi.current_dir(hidex86=True, x64=True***REMOVED***
            path = r'Bin\NETFX 4.0 Tools%s' % arch_subdir
            tools += [os.path.join(self.si.WindowsSdkDir, path***REMOVED******REMOVED***

        if self.si.WindowsSDKExecutablePath:
            tools += [self.si.WindowsSDKExecutablePath***REMOVED***

        return tools

    @property
    def SdkSetup(self***REMOVED***:
        ***REMOVED***
        Microsoft Windows SDK Setup
        ***REMOVED***
        if self.vc_ver > 9.0:
            return [***REMOVED***

        return [os.path.join(self.si.WindowsSdkDir, 'Setup'***REMOVED******REMOVED***

    @property
    def FxTools(self***REMOVED***:
        ***REMOVED***
        Microsoft .NET Framework Tools
        ***REMOVED***
        pi = self.pi
        si = self.si

        if self.vc_ver <= 10.0:
            include32 = True
            include64 = not pi.target_is_x86(***REMOVED*** and not pi.current_is_x86(***REMOVED***
        else:
            include32 = pi.target_is_x86(***REMOVED*** or pi.current_is_x86(***REMOVED***
            include64 = pi.current_cpu == 'amd64' or pi.target_cpu == 'amd64'

        tools = [***REMOVED***
        if include32:
            tools += [os.path.join(si.FrameworkDir32, ver***REMOVED***
                      for ver in si.FrameworkVersion32***REMOVED***
        if include64:
            tools += [os.path.join(si.FrameworkDir64, ver***REMOVED***
                      for ver in si.FrameworkVersion64***REMOVED***
        return tools

    @property
    def NetFxSDKLibraries(self***REMOVED***:
        ***REMOVED***
        Microsoft .Net Framework SDK Libraries
        ***REMOVED***
        if self.vc_ver < 14.0 or not self.si.NetFxSdkDir:
            return [***REMOVED***

        arch_subdir = self.pi.target_dir(x64=True***REMOVED***
        return [os.path.join(self.si.NetFxSdkDir, r'lib\um%s' % arch_subdir***REMOVED******REMOVED***

    @property
    def NetFxSDKIncludes(self***REMOVED***:
        ***REMOVED***
        Microsoft .Net Framework SDK Includes
        ***REMOVED***
        if self.vc_ver < 14.0 or not self.si.NetFxSdkDir:
            return [***REMOVED***

        return [os.path.join(self.si.NetFxSdkDir, r'include\um'***REMOVED******REMOVED***

    @property
    def VsTDb(self***REMOVED***:
        ***REMOVED***
        Microsoft Visual Studio Team System Database
        ***REMOVED***
        return [os.path.join(self.si.VSInstallDir, r'VSTSDB\Deploy'***REMOVED******REMOVED***

    @property
    def MSBuild(self***REMOVED***:
        ***REMOVED***
        Microsoft Build Engine
        ***REMOVED***
        if self.vc_ver < 12.0:
            return [***REMOVED***

        arch_subdir = self.pi.current_dir(hidex86=True***REMOVED***
        path = r'MSBuild\%0.1f\bin%s' % (self.vc_ver, arch_subdir***REMOVED***
        return [os.path.join(self.si.ProgramFilesx86, path***REMOVED******REMOVED***

    @property
    def HTMLHelpWorkshop(self***REMOVED***:
        ***REMOVED***
        Microsoft HTML Help Workshop
        ***REMOVED***
        if self.vc_ver < 11.0:
            return [***REMOVED***

        return [os.path.join(self.si.ProgramFilesx86, 'HTML Help Workshop'***REMOVED******REMOVED***

    @property
    def UCRTLibraries(self***REMOVED***:
        ***REMOVED***
        Microsoft Universal CRT Libraries
        ***REMOVED***
        if self.vc_ver < 14.0:
            return [***REMOVED***

        arch_subdir = self.pi.target_dir(x64=True***REMOVED***
        lib = os.path.join(self.si.UniversalCRTSdkDir, 'lib'***REMOVED***
        ucrtver = self._get_content_dirname(lib***REMOVED***
        return [os.path.join(lib, '%sucrt%s' % (ucrtver, arch_subdir***REMOVED******REMOVED******REMOVED***

    @property
    def UCRTIncludes(self***REMOVED***:
        ***REMOVED***
        Microsoft Universal CRT Include
        ***REMOVED***
        if self.vc_ver < 14.0:
            return [***REMOVED***

        include = os.path.join(self.si.UniversalCRTSdkDir, 'include'***REMOVED***
        ucrtver = self._get_content_dirname(include***REMOVED***
        return [os.path.join(include, '%sucrt' % ucrtver***REMOVED******REMOVED***

    @property
    def FSharp(self***REMOVED***:
        ***REMOVED***
        Microsoft Visual F#
        ***REMOVED***
        if self.vc_ver < 11.0 and self.vc_ver > 12.0:
            return [***REMOVED***

        return self.si.FSharpInstallDir

    @property
    def VCRuntimeRedist(self***REMOVED***:
        ***REMOVED***
        Microsoft Visual C++ runtime redistribuable dll
        ***REMOVED***
        arch_subdir = self.pi.target_dir(x64=True***REMOVED***
        vcruntime = 'redist%s\\Microsoft.VC%d0.CRT\\vcruntime%d0.dll'
        vcruntime = vcruntime % (arch_subdir, self.vc_ver, self.vc_ver***REMOVED***
        return os.path.join(self.si.VCInstallDir, vcruntime***REMOVED***

    def return_env(self, exists=True***REMOVED***:
        ***REMOVED***
        Return environment dict.

        Parameters
        ----------
        exists: bool
            It True, only return existing paths.
        ***REMOVED***
        env = dict(
            include=self._build_paths('include',
                                      [self.VCIncludes,
                                       self.OSIncludes,
                                       self.UCRTIncludes,
                                       self.NetFxSDKIncludes***REMOVED***,
                                      exists***REMOVED***,
            lib=self._build_paths('lib',
                                  [self.VCLibraries,
                                   self.OSLibraries,
                                   self.FxTools,
                                   self.UCRTLibraries,
                                   self.NetFxSDKLibraries***REMOVED***,
                                  exists***REMOVED***,
            libpath=self._build_paths('libpath',
                                      [self.VCLibraries,
                                       self.FxTools,
                                       self.VCStoreRefs,
                                       self.OSLibpath***REMOVED***,
                                      exists***REMOVED***,
            path=self._build_paths('path',
                                   [self.VCTools,
                                    self.VSTools,
                                    self.VsTDb,
                                    self.SdkTools,
                                    self.SdkSetup,
                                    self.FxTools,
                                    self.MSBuild,
                                    self.HTMLHelpWorkshop,
                                    self.FSharp***REMOVED***,
                                   exists***REMOVED***,
        ***REMOVED***
        if self.vc_ver >= 14 and os.path.isfile(self.VCRuntimeRedist***REMOVED***:
            env['py_vcruntime_redist'***REMOVED*** = self.VCRuntimeRedist
        return env

    def _build_paths(self, name, spec_path_lists, exists***REMOVED***:
        ***REMOVED***
        Given an environment variable name and specified paths,
        return a pathsep-separated string of paths containing
        unique, extant, directories from those paths and from
        the environment variable. Raise an error if no paths
        are resolved.
        ***REMOVED***
        # flatten spec_path_lists
        spec_paths = itertools.chain.from_iterable(spec_path_lists***REMOVED***
        env_paths = safe_env.get(name, ''***REMOVED***.split(os.pathsep***REMOVED***
        paths = itertools.chain(spec_paths, env_paths***REMOVED***
        extant_paths = list(filter(os.path.isdir, paths***REMOVED******REMOVED*** if exists else paths
        if not extant_paths:
            msg = "%s environment variable is empty" % name.upper(***REMOVED***
            raise distutils.errors.DistutilsPlatformError(msg***REMOVED***
        unique_paths = self._unique_everseen(extant_paths***REMOVED***
        return os.pathsep.join(unique_paths***REMOVED***

    # from Python docs
    def _unique_everseen(self, iterable, key=None***REMOVED***:
        ***REMOVED***
        List unique elements, preserving order.
        Remember all elements ever seen.

        _unique_everseen('AAAABBBCCDAABBB'***REMOVED*** --> A B C D

        _unique_everseen('ABBCcAD', str.lower***REMOVED*** --> A B C D
        ***REMOVED***
        seen = set(***REMOVED***
        seen_add = seen.add
        if key is None:
            for element in filterfalse(seen.__contains__, iterable***REMOVED***:
                seen_add(element***REMOVED***
                yield element
        else:
            for element in iterable:
                k = key(element***REMOVED***
                if k not in seen:
                    seen_add(k***REMOVED***
                    yield element

    def _get_content_dirname(self, path***REMOVED***:
        ***REMOVED***
        Return name of the first dir in path or '' if no dir found.

        Parameters
        ----------
        path: str
            Path where search dir.

        Return
        ------
        foldername: str
            "name\" or ""
        ***REMOVED***
        ***REMOVED***
            name = os.listdir(path***REMOVED***
            if name:
                return '%s\\' % name[0***REMOVED***
            return ''
        except (OSError, IOError***REMOVED***:
            return ''
