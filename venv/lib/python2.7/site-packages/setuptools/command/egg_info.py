***REMOVED***setuptools.command.egg_info

Create a distribution's .egg-info directory and contents***REMOVED***

from distutils.filelist import FileList as _FileList
from distutils.errors import DistutilsInternalError
from distutils.util import convert_path
from distutils import log
import distutils.errors
import distutils.filelist
***REMOVED***
import re
import sys
import io
import warnings
import time
import collections

from setuptools.extern import six
from setuptools.extern.six.moves import map

from setuptools import Command
from setuptools.command.sdist import sdist
from setuptools.command.sdist import walk_revctrl
from setuptools.command.setopt import edit_config
from setuptools.command import bdist_egg
from pkg_resources import (
    parse_requirements, safe_name, parse_version,
    safe_version, yield_lines, EntryPoint, iter_entry_points, to_filename***REMOVED***
import setuptools.unicode_utils as unicode_utils
from setuptools.glob import glob

from pkg_resources.extern import packaging

***REMOVED***
    from setuptools_svn import svn_utils
except ImportError:
    pass


def translate_pattern(glob***REMOVED***:
    ***REMOVED***
    Translate a file path glob like '*.txt' in to a regular expression.
    This differs from fnmatch.translate which allows wildcards to match
    directory separators. It also knows about '**/' which matches any number of
    directories.
    ***REMOVED***
    pat = ''

    # This will split on '/' within [character classes***REMOVED***. This is deliberate.
    chunks = glob.split(os.path.sep***REMOVED***

    sep = re.escape(os.sep***REMOVED***
    valid_char = '[^%s***REMOVED***' % (sep,***REMOVED***

    for c, chunk in enumerate(chunks***REMOVED***:
        last_chunk = c == len(chunks***REMOVED*** - 1

        # Chunks that are a literal ** are globstars. They match anything.
        if chunk == '**':
            if last_chunk:
                # Match anything if this is the last component
                pat += '.*'
            else:
                # Match '(name/***REMOVED****'
                pat += '(?:%s+%s***REMOVED****' % (valid_char, sep***REMOVED***
            continue  # Break here as the whole path component has been handled

        # Find any special characters in the remainder
        i = 0
        chunk_len = len(chunk***REMOVED***
        while i < chunk_len:
            char = chunk[i***REMOVED***
            if char == '*':
                # Match any number of name characters
                pat += valid_char + '*'
            elif char == '?':
                # Match a name character
                pat += valid_char
            elif char == '[':
                # Character class
                inner_i = i + 1
                # Skip initial !/***REMOVED*** chars
                if inner_i < chunk_len and chunk[inner_i***REMOVED*** == '!':
                    inner_i = inner_i + 1
                if inner_i < chunk_len and chunk[inner_i***REMOVED*** == '***REMOVED***':
                    inner_i = inner_i + 1

                # Loop till the closing ***REMOVED*** is found
                while inner_i < chunk_len and chunk[inner_i***REMOVED*** != '***REMOVED***':
                    inner_i = inner_i + 1

                if inner_i >= chunk_len:
                    # Got to the end of the string without finding a closing ***REMOVED***
                    # Do not treat this as a matching group, but as a literal [
                    pat += re.escape(char***REMOVED***
                else:
                    # Grab the insides of the [brackets***REMOVED***
                    inner = chunk[i + 1:inner_i***REMOVED***
                    char_class = ''

                    # Class negation
                    if inner[0***REMOVED*** == '!':
                        char_class = '^'
                        inner = inner[1:***REMOVED***

                    char_class += re.escape(inner***REMOVED***
                    pat += '[%s***REMOVED***' % (char_class,***REMOVED***

                    # Skip to the end ***REMOVED***
                    i = inner_i
            else:
                pat += re.escape(char***REMOVED***
            i += 1

        # Join each chunk with the dir separator
        if not last_chunk:
            pat += sep

    return re.compile(pat + r'\Z(?ms***REMOVED***'***REMOVED***


class egg_info(Command***REMOVED***:
    description = "create a distribution's .egg-info directory"

    user_options = [
        ('egg-base=', 'e', "directory containing .egg-info directories"
                           " (default: top of the source tree***REMOVED***"***REMOVED***,
        ('tag-svn-revision', 'r',
         "Add subversion revision ID to version number"***REMOVED***,
        ('tag-date', 'd', "Add date stamp (e.g. 20050528***REMOVED*** to version number"***REMOVED***,
        ('tag-build=', 'b', "Specify explicit tag to add to version number"***REMOVED***,
        ('no-svn-revision', 'R',
         "Don't add subversion revision ID [default***REMOVED***"***REMOVED***,
        ('no-date', 'D', "Don't include date stamp [default***REMOVED***"***REMOVED***,
    ***REMOVED***

    boolean_options = ['tag-date', 'tag-svn-revision'***REMOVED***
    negative_opt = {
        'no-svn-revision': 'tag-svn-revision',
        'no-date': 'tag-date',
***REMOVED***

    def initialize_options(self***REMOVED***:
        self.egg_name = None
        self.egg_version = None
        self.egg_base = None
        self.egg_info = None
        self.tag_build = None
        self.tag_svn_revision = 0
        self.tag_date = 0
        self.broken_egg_info = False
        self.vtags = None

    def save_version_info(self, filename***REMOVED***:
        ***REMOVED***
        Materialize the values of svn_revision and date into the
        build tag. Install these keys in a deterministic order
        to avoid arbitrary reordering on subsequent builds.
        ***REMOVED***
        # python 2.6 compatibility
        odict = getattr(collections, 'OrderedDict', dict***REMOVED***
        egg_info = odict(***REMOVED***
        # follow the order these keys would have been added
        # when PYTHONHASHSEED=0
        egg_info['tag_build'***REMOVED*** = self.tags(***REMOVED***
        egg_info['tag_date'***REMOVED*** = 0
        egg_info['tag_svn_revision'***REMOVED*** = 0
        edit_config(filename, dict(egg_info=egg_info***REMOVED******REMOVED***

    def finalize_options(self***REMOVED***:
        self.egg_name = safe_name(self.distribution.get_name(***REMOVED******REMOVED***
        self.vtags = self.tags(***REMOVED***
        self.egg_version = self.tagged_version(***REMOVED***

        parsed_version = parse_version(self.egg_version***REMOVED***

        ***REMOVED***
            is_version = isinstance(parsed_version, packaging.version.Version***REMOVED***
            spec = (
                "%s==%s" if is_version else "%s===%s"
            ***REMOVED***
            list(
                parse_requirements(spec % (self.egg_name, self.egg_version***REMOVED******REMOVED***
            ***REMOVED***
        except ValueError:
            raise distutils.errors.DistutilsOptionError(
                "Invalid distribution name or version syntax: %s-%s" %
                (self.egg_name, self.egg_version***REMOVED***
            ***REMOVED***

        if self.egg_base is None:
            dirs = self.distribution.package_dir
            self.egg_base = (dirs or {***REMOVED******REMOVED***.get('', os.curdir***REMOVED***

        self.ensure_dirname('egg_base'***REMOVED***
        self.egg_info = to_filename(self.egg_name***REMOVED*** + '.egg-info'
        if self.egg_base != os.curdir:
            self.egg_info = os.path.join(self.egg_base, self.egg_info***REMOVED***
        if '-' in self.egg_name:
            self.check_broken_egg_info(***REMOVED***

        # Set package version for the benefit of dumber commands
        # (e.g. sdist, bdist_wininst, etc.***REMOVED***
        #
        self.distribution.metadata.version = self.egg_version

        # If we bootstrapped around the lack of a PKG-INFO, as might be the
        # case in a fresh checkout, make sure that any special tags get added
        # to the version info
        #
        pd = self.distribution._patched_dist
        if pd is not None and pd.key == self.egg_name.lower(***REMOVED***:
            pd._version = self.egg_version
            pd._parsed_version = parse_version(self.egg_version***REMOVED***
            self.distribution._patched_dist = None

    def write_or_delete_file(self, what, filename, data, force=False***REMOVED***:
        ***REMOVED***Write `data` to `filename` or delete if empty

        If `data` is non-empty, this routine is the same as ``write_file(***REMOVED***``.
        If `data` is empty but not ``None``, this is the same as calling
        ``delete_file(filename***REMOVED***`.  If `data` is ``None``, then this is a no-op
        unless `filename` exists, in which case a warning is issued about the
        orphaned file (if `force` is false***REMOVED***, or deleted (if `force` is true***REMOVED***.
        ***REMOVED***
        if data:
            self.write_file(what, filename, data***REMOVED***
        elif os.path.exists(filename***REMOVED***:
            if data is None and not force:
                log.warn(
                    "%s not set in setup(***REMOVED***, but %s exists", what, filename
                ***REMOVED***
                return
            else:
                self.delete_file(filename***REMOVED***

    def write_file(self, what, filename, data***REMOVED***:
        ***REMOVED***Write `data` to `filename` (if not a dry run***REMOVED*** after announcing it

        `what` is used in a log message to identify what is being written
        to the file.
        ***REMOVED***
        log.info("writing %s to %s", what, filename***REMOVED***
        if six.PY3:
            data = data.encode("utf-8"***REMOVED***
        if not self.dry_run:
            f = open(filename, 'wb'***REMOVED***
            f.write(data***REMOVED***
            f.close(***REMOVED***

    def delete_file(self, filename***REMOVED***:
        ***REMOVED***Delete `filename` (if not a dry run***REMOVED*** after announcing it***REMOVED***
        log.info("deleting %s", filename***REMOVED***
        if not self.dry_run:
            os.unlink(filename***REMOVED***

    def tagged_version(self***REMOVED***:
        version = self.distribution.get_version(***REMOVED***
        # egg_info may be called more than once for a distribution,
        # in which case the version string already contains all tags.
        if self.vtags and version.endswith(self.vtags***REMOVED***:
            return safe_version(version***REMOVED***
        return safe_version(version + self.vtags***REMOVED***

    def run(self***REMOVED***:
        self.mkpath(self.egg_info***REMOVED***
        installer = self.distribution.fetch_build_egg
        for ep in iter_entry_points('egg_info.writers'***REMOVED***:
            ep.require(installer=installer***REMOVED***
            writer = ep.resolve(***REMOVED***
            writer(self, ep.name, os.path.join(self.egg_info, ep.name***REMOVED******REMOVED***

        # Get rid of native_libs.txt if it was put there by older bdist_egg
        nl = os.path.join(self.egg_info, "native_libs.txt"***REMOVED***
        if os.path.exists(nl***REMOVED***:
            self.delete_file(nl***REMOVED***

        self.find_sources(***REMOVED***

    def tags(self***REMOVED***:
        version = ''
        if self.tag_build:
            version += self.tag_build
        if self.tag_svn_revision:
            warnings.warn(
                "tag_svn_revision is deprecated and will not be honored "
                "in a future release"
            ***REMOVED***
            version += '-r%s' % self.get_svn_revision(***REMOVED***
        if self.tag_date:
            version += time.strftime("-%Y%m%d"***REMOVED***
        return version

    @staticmethod
    def get_svn_revision(***REMOVED***:
        if 'svn_utils' not in globals(***REMOVED***:
            return "0"
        return str(svn_utils.SvnInfo.load(os.curdir***REMOVED***.get_revision(***REMOVED******REMOVED***

    def find_sources(self***REMOVED***:
        ***REMOVED***Generate SOURCES.txt manifest file***REMOVED***
        manifest_filename = os.path.join(self.egg_info, "SOURCES.txt"***REMOVED***
        mm = manifest_maker(self.distribution***REMOVED***
        mm.manifest = manifest_filename
        mm.run(***REMOVED***
        self.filelist = mm.filelist

    def check_broken_egg_info(self***REMOVED***:
        bei = self.egg_name + '.egg-info'
        if self.egg_base != os.curdir:
            bei = os.path.join(self.egg_base, bei***REMOVED***
        if os.path.exists(bei***REMOVED***:
            log.warn(
                "-" * 78 + '\n'
                "Note: Your current .egg-info directory has a '-' in its name;"
                '\nthis will not work correctly with "setup.py develop".\n\n'
                'Please rename %s to %s to correct this problem.\n' + '-' * 78,
                bei, self.egg_info
            ***REMOVED***
            self.broken_egg_info = self.egg_info
            self.egg_info = bei  # make it work for now


class FileList(_FileList***REMOVED***:
    # Implementations of the various MANIFEST.in commands

    def process_template_line(self, line***REMOVED***:
        # Parse the line: split it up, make sure the right number of words
        # is there, and return the relevant words.  'action' is always
        # defined: it's the first word of the line.  Which of the other
        # three are defined depends on the action; it'll be either
        # patterns, (dir and patterns***REMOVED***, or (dir_pattern***REMOVED***.
        (action, patterns, dir, dir_pattern***REMOVED*** = self._parse_template_line(line***REMOVED***

        # OK, now we know that the action is valid and we have the
        # right number of words on the line for that action -- so we
        # can proceed with minimal error-checking.
        if action == 'include':
            self.debug_print("include " + ' '.join(patterns***REMOVED******REMOVED***
            for pattern in patterns:
                if not self.include(pattern***REMOVED***:
                    log.warn("warning: no files found matching '%s'", pattern***REMOVED***

        elif action == 'exclude':
            self.debug_print("exclude " + ' '.join(patterns***REMOVED******REMOVED***
            for pattern in patterns:
                if not self.exclude(pattern***REMOVED***:
                    log.warn(("warning: no previously-included files "
                              "found matching '%s'"***REMOVED***, pattern***REMOVED***

        elif action == 'global-include':
            self.debug_print("global-include " + ' '.join(patterns***REMOVED******REMOVED***
            for pattern in patterns:
                if not self.global_include(pattern***REMOVED***:
                    log.warn(("warning: no files found matching '%s' "
                              "anywhere in distribution"***REMOVED***, pattern***REMOVED***

        elif action == 'global-exclude':
            self.debug_print("global-exclude " + ' '.join(patterns***REMOVED******REMOVED***
            for pattern in patterns:
                if not self.global_exclude(pattern***REMOVED***:
                    log.warn(("warning: no previously-included files matching "
                              "'%s' found anywhere in distribution"***REMOVED***,
                             pattern***REMOVED***

        elif action == 'recursive-include':
            self.debug_print("recursive-include %s %s" %
                             (dir, ' '.join(patterns***REMOVED******REMOVED******REMOVED***
            for pattern in patterns:
                if not self.recursive_include(dir, pattern***REMOVED***:
                    log.warn(("warning: no files found matching '%s' "
                              "under directory '%s'"***REMOVED***,
                             pattern, dir***REMOVED***

        elif action == 'recursive-exclude':
            self.debug_print("recursive-exclude %s %s" %
                             (dir, ' '.join(patterns***REMOVED******REMOVED******REMOVED***
            for pattern in patterns:
                if not self.recursive_exclude(dir, pattern***REMOVED***:
                    log.warn(("warning: no previously-included files matching "
                              "'%s' found under directory '%s'"***REMOVED***,
                             pattern, dir***REMOVED***

        elif action == 'graft':
            self.debug_print("graft " + dir_pattern***REMOVED***
            if not self.graft(dir_pattern***REMOVED***:
                log.warn("warning: no directories found matching '%s'",
                         dir_pattern***REMOVED***

        elif action == 'prune':
            self.debug_print("prune " + dir_pattern***REMOVED***
            if not self.prune(dir_pattern***REMOVED***:
                log.warn(("no previously-included directories found "
                          "matching '%s'"***REMOVED***, dir_pattern***REMOVED***

        else:
            raise DistutilsInternalError(
                "this cannot happen: invalid action '%s'" % action***REMOVED***

    def _remove_files(self, predicate***REMOVED***:
        ***REMOVED***
        Remove all files from the file list that match the predicate.
        Return True if any matching files were removed
        ***REMOVED***
        found = False
        for i in range(len(self.files***REMOVED*** - 1, -1, -1***REMOVED***:
            if predicate(self.files[i***REMOVED******REMOVED***:
                self.debug_print(" removing " + self.files[i***REMOVED******REMOVED***
                del self.files[i***REMOVED***
                found = True
        return found

    def include(self, pattern***REMOVED***:
        ***REMOVED***Include files that match 'pattern'.***REMOVED***
        found = [f for f in glob(pattern***REMOVED*** if not os.path.isdir(f***REMOVED******REMOVED***
        self.extend(found***REMOVED***
        return bool(found***REMOVED***

    def exclude(self, pattern***REMOVED***:
        ***REMOVED***Exclude files that match 'pattern'.***REMOVED***
        match = translate_pattern(pattern***REMOVED***
        return self._remove_files(match.match***REMOVED***

    def recursive_include(self, dir, pattern***REMOVED***:
        ***REMOVED***
        Include all files anywhere in 'dir/' that match the pattern.
        ***REMOVED***
        full_pattern = os.path.join(dir, '**', pattern***REMOVED***
        found = [f for f in glob(full_pattern, recursive=True***REMOVED***
                 if not os.path.isdir(f***REMOVED******REMOVED***
        self.extend(found***REMOVED***
        return bool(found***REMOVED***

    def recursive_exclude(self, dir, pattern***REMOVED***:
        ***REMOVED***
        Exclude any file anywhere in 'dir/' that match the pattern.
        ***REMOVED***
        match = translate_pattern(os.path.join(dir, '**', pattern***REMOVED******REMOVED***
        return self._remove_files(match.match***REMOVED***

    def graft(self, dir***REMOVED***:
        ***REMOVED***Include all files from 'dir/'.***REMOVED***
        found = distutils.filelist.findall(dir***REMOVED***
        self.extend(found***REMOVED***
        return bool(found***REMOVED***

    def prune(self, dir***REMOVED***:
        ***REMOVED***Filter out files from 'dir/'.***REMOVED***
        match = translate_pattern(os.path.join(dir, '**'***REMOVED******REMOVED***
        return self._remove_files(match.match***REMOVED***

    def global_include(self, pattern***REMOVED***:
        ***REMOVED***
        Include all files anywhere in the current directory that match the
        pattern. This is very inefficient on large file trees.
        ***REMOVED***
        if self.allfiles is None:
            self.findall(***REMOVED***
        match = translate_pattern(os.path.join('**', pattern***REMOVED******REMOVED***
        found = [f for f in self.allfiles if match.match(f***REMOVED******REMOVED***
        self.extend(found***REMOVED***
        return bool(found***REMOVED***

    def global_exclude(self, pattern***REMOVED***:
        ***REMOVED***
        Exclude all files anywhere that match the pattern.
        ***REMOVED***
        match = translate_pattern(os.path.join('**', pattern***REMOVED******REMOVED***
        return self._remove_files(match.match***REMOVED***

    def append(self, item***REMOVED***:
        if item.endswith('\r'***REMOVED***:  # Fix older sdists built on Windows
            item = item[:-1***REMOVED***
        path = convert_path(item***REMOVED***

        if self._safe_path(path***REMOVED***:
            self.files.append(path***REMOVED***

    def extend(self, paths***REMOVED***:
        self.files.extend(filter(self._safe_path, paths***REMOVED******REMOVED***

    def _repair(self***REMOVED***:
        ***REMOVED***
        Replace self.files with only safe paths

        Because some owners of FileList manipulate the underlying
        ``files`` attribute directly, this method must be called to
        repair those paths.
        ***REMOVED***
        self.files = list(filter(self._safe_path, self.files***REMOVED******REMOVED***

    def _safe_path(self, path***REMOVED***:
        enc_warn = "'%s' not %s encodable -- skipping"

        # To avoid accidental trans-codings errors, first to unicode
        u_path = unicode_utils.filesys_decode(path***REMOVED***
        if u_path is None:
            log.warn("'%s' in unexpected encoding -- skipping" % path***REMOVED***
            return False

        # Must ensure utf-8 encodability
        utf8_path = unicode_utils.try_encode(u_path, "utf-8"***REMOVED***
        if utf8_path is None:
            log.warn(enc_warn, path, 'utf-8'***REMOVED***
            return False

        ***REMOVED***
            # accept is either way checks out
            if os.path.exists(u_path***REMOVED*** or os.path.exists(utf8_path***REMOVED***:
                return True
        # this will catch any encode errors decoding u_path
        except UnicodeEncodeError:
            log.warn(enc_warn, path, sys.getfilesystemencoding(***REMOVED******REMOVED***


class manifest_maker(sdist***REMOVED***:
    template = "MANIFEST.in"

    def initialize_options(self***REMOVED***:
        self.use_defaults = 1
        self.prune = 1
        self.manifest_only = 1
        self.force_manifest = 1

    def finalize_options(self***REMOVED***:
        pass

    def run(self***REMOVED***:
        self.filelist = FileList(***REMOVED***
        if not os.path.exists(self.manifest***REMOVED***:
            self.write_manifest(***REMOVED***  # it must exist so it'll get in the list
        self.add_defaults(***REMOVED***
        if os.path.exists(self.template***REMOVED***:
            self.read_template(***REMOVED***
        self.prune_file_list(***REMOVED***
        self.filelist.sort(***REMOVED***
        self.filelist.remove_duplicates(***REMOVED***
        self.write_manifest(***REMOVED***

    def _manifest_normalize(self, path***REMOVED***:
        path = unicode_utils.filesys_decode(path***REMOVED***
        return path.replace(os.sep, '/'***REMOVED***

    def write_manifest(self***REMOVED***:
        ***REMOVED***
        Write the file list in 'self.filelist' to the manifest file
        named by 'self.manifest'.
        ***REMOVED***
        self.filelist._repair(***REMOVED***

        # Now _repairs should encodability, but not unicode
        files = [self._manifest_normalize(f***REMOVED*** for f in self.filelist.files***REMOVED***
        msg = "writing manifest file '%s'" % self.manifest
        self.execute(write_file, (self.manifest, files***REMOVED***, msg***REMOVED***

    def warn(self, msg***REMOVED***:  # suppress missing-file warnings from sdist
        if not msg.startswith("standard file not found:"***REMOVED***:
            sdist.warn(self, msg***REMOVED***

    def add_defaults(self***REMOVED***:
        sdist.add_defaults(self***REMOVED***
        self.filelist.append(self.template***REMOVED***
        self.filelist.append(self.manifest***REMOVED***
        rcfiles = list(walk_revctrl(***REMOVED******REMOVED***
        if rcfiles:
            self.filelist.extend(rcfiles***REMOVED***
        elif os.path.exists(self.manifest***REMOVED***:
            self.read_manifest(***REMOVED***
        ei_cmd = self.get_finalized_command('egg_info'***REMOVED***
        self.filelist.graft(ei_cmd.egg_info***REMOVED***

    def prune_file_list(self***REMOVED***:
        build = self.get_finalized_command('build'***REMOVED***
        base_dir = self.distribution.get_fullname(***REMOVED***
        self.filelist.prune(build.build_base***REMOVED***
        self.filelist.prune(base_dir***REMOVED***
        sep = re.escape(os.sep***REMOVED***
        self.filelist.exclude_pattern(r'(^|' + sep + r'***REMOVED***(RCS|CVS|\.svn***REMOVED***' + sep,
                                      is_regex=1***REMOVED***


def write_file(filename, contents***REMOVED***:
    ***REMOVED***Create a file with the specified name and write 'contents' (a
    sequence of strings without line terminators***REMOVED*** to it.
    ***REMOVED***
    contents = "\n".join(contents***REMOVED***

    # assuming the contents has been vetted for utf-8 encoding
    contents = contents.encode("utf-8"***REMOVED***

    with open(filename, "wb"***REMOVED*** as f:  # always write POSIX-style manifest
        f.write(contents***REMOVED***


def write_pkg_info(cmd, basename, filename***REMOVED***:
    log.info("writing %s", filename***REMOVED***
    if not cmd.dry_run:
        metadata = cmd.distribution.metadata
        metadata.version, oldver = cmd.egg_version, metadata.version
        metadata.name, oldname = cmd.egg_name, metadata.name
        ***REMOVED***
            # write unescaped data to PKG-INFO, so older pkg_resources
            # can still parse it
            metadata.write_pkg_info(cmd.egg_info***REMOVED***
        finally:
            metadata.name, metadata.version = oldname, oldver

        safe = getattr(cmd.distribution, 'zip_safe', None***REMOVED***

        bdist_egg.write_safety_flag(cmd.egg_info, safe***REMOVED***


def warn_depends_obsolete(cmd, basename, filename***REMOVED***:
    if os.path.exists(filename***REMOVED***:
        log.warn(
            "WARNING: 'depends.txt' is not used by setuptools 0.6!\n"
            "Use the install_requires/extras_require setup(***REMOVED*** args instead."
        ***REMOVED***


def _write_requirements(stream, reqs***REMOVED***:
    lines = yield_lines(reqs or (***REMOVED******REMOVED***
    append_cr = lambda line: line + '\n'
    lines = map(append_cr, lines***REMOVED***
    stream.writelines(lines***REMOVED***


def write_requirements(cmd, basename, filename***REMOVED***:
    dist = cmd.distribution
    data = six.StringIO(***REMOVED***
    _write_requirements(data, dist.install_requires***REMOVED***
    extras_require = dist.extras_require or {***REMOVED***
    for extra in sorted(extras_require***REMOVED***:
        data.write('\n[{extra***REMOVED******REMOVED***\n'.format(**vars(***REMOVED******REMOVED******REMOVED***
        _write_requirements(data, extras_require[extra***REMOVED******REMOVED***
    cmd.write_or_delete_file("requirements", filename, data.getvalue(***REMOVED******REMOVED***


def write_setup_requirements(cmd, basename, filename***REMOVED***:
    data = StringIO(***REMOVED***
    _write_requirements(data, cmd.distribution.setup_requires***REMOVED***
    cmd.write_or_delete_file("setup-requirements", filename, data.getvalue(***REMOVED******REMOVED***


def write_toplevel_names(cmd, basename, filename***REMOVED***:
    pkgs = dict.fromkeys(
        [
            k.split('.', 1***REMOVED***[0***REMOVED***
            for k in cmd.distribution.iter_distribution_names(***REMOVED***
        ***REMOVED***
    ***REMOVED***
    cmd.write_file("top-level names", filename, '\n'.join(sorted(pkgs***REMOVED******REMOVED*** + '\n'***REMOVED***


def overwrite_arg(cmd, basename, filename***REMOVED***:
    write_arg(cmd, basename, filename, True***REMOVED***


def write_arg(cmd, basename, filename, force=False***REMOVED***:
    argname = os.path.splitext(basename***REMOVED***[0***REMOVED***
    value = getattr(cmd.distribution, argname, None***REMOVED***
    if value is not None:
        value = '\n'.join(value***REMOVED*** + '\n'
    cmd.write_or_delete_file(argname, filename, value, force***REMOVED***


def write_entries(cmd, basename, filename***REMOVED***:
    ep = cmd.distribution.entry_points

    if isinstance(ep, six.string_types***REMOVED*** or ep is None:
        data = ep
    elif ep is not None:
        data = [***REMOVED***
        for section, contents in sorted(ep.items(***REMOVED******REMOVED***:
            if not isinstance(contents, six.string_types***REMOVED***:
                contents = EntryPoint.parse_group(section, contents***REMOVED***
                contents = '\n'.join(sorted(map(str, contents.values(***REMOVED******REMOVED******REMOVED******REMOVED***
            data.append('[%s***REMOVED***\n%s\n\n' % (section, contents***REMOVED******REMOVED***
        data = ''.join(data***REMOVED***

    cmd.write_or_delete_file('entry points', filename, data, True***REMOVED***


def get_pkg_info_revision(***REMOVED***:
    ***REMOVED***
    Get a -r### off of PKG-INFO Version in case this is an sdist of
    a subversion revision.
    ***REMOVED***
    warnings.warn("get_pkg_info_revision is deprecated.", DeprecationWarning***REMOVED***
    if os.path.exists('PKG-INFO'***REMOVED***:
        with io.open('PKG-INFO'***REMOVED*** as f:
            for line in f:
                match = re.match(r"Version:.*-r(\d+***REMOVED***\s*$", line***REMOVED***
                if match:
                    return int(match.group(1***REMOVED******REMOVED***
    return 0
