from distutils.util import convert_path
from distutils import log
from distutils.errors import DistutilsError, DistutilsOptionError
***REMOVED***
import glob
import io

from setuptools.extern import six

from pkg_resources import Distribution, PathMetadata, normalize_path
from setuptools.command.easy_install import easy_install
import setuptools


class develop(easy_install***REMOVED***:
    ***REMOVED***Set up package for development***REMOVED***

    description = "install package in 'development mode'"

    user_options = easy_install.user_options + [
        ("uninstall", "u", "Uninstall this source package"***REMOVED***,
        ("egg-path=", None, "Set the path to be used in the .egg-link file"***REMOVED***,
    ***REMOVED***

    boolean_options = easy_install.boolean_options + ['uninstall'***REMOVED***

    command_consumes_arguments = False  # override base

    def run(self***REMOVED***:
        if self.uninstall:
            self.multi_version = True
            self.uninstall_link(***REMOVED***
        else:
            self.install_for_development(***REMOVED***
        self.warn_deprecated_options(***REMOVED***

    def initialize_options(self***REMOVED***:
        self.uninstall = None
        self.egg_path = None
        easy_install.initialize_options(self***REMOVED***
        self.setup_path = None
        self.always_copy_from = '.'  # always copy eggs installed in curdir

    def finalize_options(self***REMOVED***:
        ei = self.get_finalized_command("egg_info"***REMOVED***
        if ei.broken_egg_info:
            template = "Please rename %r to %r before using 'develop'"
            args = ei.egg_info, ei.broken_egg_info
            raise DistutilsError(template % args***REMOVED***
        self.args = [ei.egg_name***REMOVED***

        easy_install.finalize_options(self***REMOVED***
        self.expand_basedirs(***REMOVED***
        self.expand_dirs(***REMOVED***
        # pick up setup-dir .egg files only: no .egg-info
        self.package_index.scan(glob.glob('*.egg'***REMOVED******REMOVED***

        egg_link_fn = ei.egg_name + '.egg-link'
        self.egg_link = os.path.join(self.install_dir, egg_link_fn***REMOVED***
        self.egg_base = ei.egg_base
        if self.egg_path is None:
            self.egg_path = os.path.abspath(ei.egg_base***REMOVED***

        target = normalize_path(self.egg_base***REMOVED***
        egg_path = normalize_path(os.path.join(self.install_dir,
                                               self.egg_path***REMOVED******REMOVED***
        if egg_path != target:
            raise DistutilsOptionError(
                "--egg-path must be a relative path from the install"
                " directory to " + target
            ***REMOVED***

        # Make a distribution for the package's source
        self.dist = Distribution(
            target,
            PathMetadata(target, os.path.abspath(ei.egg_info***REMOVED******REMOVED***,
            project_name=ei.egg_name
        ***REMOVED***

        p = self.egg_base.replace(os.sep, '/'***REMOVED***
        if p != os.curdir:
            p = '../' * (p.count('/'***REMOVED*** + 1***REMOVED***
        self.setup_path = p
        p = normalize_path(os.path.join(self.install_dir, self.egg_path, p***REMOVED******REMOVED***
        if p != normalize_path(os.curdir***REMOVED***:
            raise DistutilsOptionError(
                "Can't get a consistent path to setup script from"
                " installation directory", p, normalize_path(os.curdir***REMOVED******REMOVED***

    def install_for_development(self***REMOVED***:
        if six.PY3 and getattr(self.distribution, 'use_2to3', False***REMOVED***:
            # If we run 2to3 we can not do this inplace:

            # Ensure metadata is up-to-date
            self.reinitialize_command('build_py', inplace=0***REMOVED***
            self.run_command('build_py'***REMOVED***
            bpy_cmd = self.get_finalized_command("build_py"***REMOVED***
            build_path = normalize_path(bpy_cmd.build_lib***REMOVED***

            # Build extensions
            self.reinitialize_command('egg_info', egg_base=build_path***REMOVED***
            self.run_command('egg_info'***REMOVED***

            self.reinitialize_command('build_ext', inplace=0***REMOVED***
            self.run_command('build_ext'***REMOVED***

            # Fixup egg-link and easy-install.pth
            ei_cmd = self.get_finalized_command("egg_info"***REMOVED***
            self.egg_path = build_path
            self.dist.location = build_path
            # XXX
            self.dist._provider = PathMetadata(build_path, ei_cmd.egg_info***REMOVED***
        else:
            # Without 2to3 inplace works fine:
            self.run_command('egg_info'***REMOVED***

            # Build extensions in-place
            self.reinitialize_command('build_ext', inplace=1***REMOVED***
            self.run_command('build_ext'***REMOVED***

        self.install_site_py(***REMOVED***  # ensure that target dir is site-safe
        if setuptools.bootstrap_install_from:
            self.easy_install(setuptools.bootstrap_install_from***REMOVED***
            setuptools.bootstrap_install_from = None

        # create an .egg-link in the installation dir, pointing to our egg
        log.info("Creating %s (link to %s***REMOVED***", self.egg_link, self.egg_base***REMOVED***
        if not self.dry_run:
            with open(self.egg_link, "w"***REMOVED*** as f:
                f.write(self.egg_path + "\n" + self.setup_path***REMOVED***
        # postprocess the installed distro, fixing up .pth, installing scripts,
        # and handling requirements
        self.process_distribution(None, self.dist, not self.no_deps***REMOVED***

    def uninstall_link(self***REMOVED***:
        if os.path.exists(self.egg_link***REMOVED***:
            log.info("Removing %s (link to %s***REMOVED***", self.egg_link, self.egg_base***REMOVED***
            egg_link_file = open(self.egg_link***REMOVED***
            contents = [line.rstrip(***REMOVED*** for line in egg_link_file***REMOVED***
            egg_link_file.close(***REMOVED***
            if contents not in ([self.egg_path***REMOVED***,
                                [self.egg_path, self.setup_path***REMOVED******REMOVED***:
                log.warn("Link points to %s: uninstall aborted", contents***REMOVED***
                return
            if not self.dry_run:
                os.unlink(self.egg_link***REMOVED***
        if not self.dry_run:
            self.update_pth(self.dist***REMOVED***  # remove any .pth link to us
        if self.distribution.scripts:
            # XXX should also check for entry point scripts!
            log.warn("Note: you must uninstall or replace scripts manually!"***REMOVED***

    def install_egg_scripts(self, dist***REMOVED***:
        if dist is not self.dist:
            # Installing a dependency, so fall back to normal behavior
            return easy_install.install_egg_scripts(self, dist***REMOVED***

        # create wrapper scripts in the script dir, pointing to dist.scripts

        # new-style...
        self.install_wrapper_scripts(dist***REMOVED***

        # ...and old-style
        for script_name in self.distribution.scripts or [***REMOVED***:
            script_path = os.path.abspath(convert_path(script_name***REMOVED******REMOVED***
            script_name = os.path.basename(script_path***REMOVED***
            with io.open(script_path***REMOVED*** as strm:
                script_text = strm.read(***REMOVED***
            self.install_script(dist, script_name, script_text, script_path***REMOVED***

    def install_wrapper_scripts(self, dist***REMOVED***:
        dist = VersionlessRequirement(dist***REMOVED***
        return easy_install.install_wrapper_scripts(self, dist***REMOVED***


class VersionlessRequirement(object***REMOVED***:
    ***REMOVED***
    Adapt a pkg_resources.Distribution to simply return the project
    name as the 'requirement' so that scripts will work across
    multiple versions.

    >>> dist = Distribution(project_name='foo', version='1.0'***REMOVED***
    >>> str(dist.as_requirement(***REMOVED******REMOVED***
    'foo==1.0'
    >>> adapted_dist = VersionlessRequirement(dist***REMOVED***
    >>> str(adapted_dist.as_requirement(***REMOVED******REMOVED***
    'foo'
    ***REMOVED***

    def __init__(self, dist***REMOVED***:
        self.__dist = dist

    def __getattr__(self, name***REMOVED***:
        return getattr(self.__dist, name***REMOVED***

    def as_requirement(self***REMOVED***:
        return self.project_name
