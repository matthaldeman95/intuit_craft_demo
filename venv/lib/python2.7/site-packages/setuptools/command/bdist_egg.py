***REMOVED***setuptools.command.bdist_egg

Build .egg distributions***REMOVED***

from distutils.errors import DistutilsSetupError
from distutils.dir_util import remove_tree, mkpath
from distutils import log
from types import CodeType
import sys
***REMOVED***
import textwrap
import marshal

from setuptools.extern import six

from pkg_resources import get_build_platform, Distribution, ensure_directory
from pkg_resources import EntryPoint
from setuptools.extension import Library
from setuptools import Command

***REMOVED***
    # Python 2.7 or >=3.2
    from sysconfig import get_path, get_python_version

    def _get_purelib(***REMOVED***:
        return get_path("purelib"***REMOVED***
except ImportError:
    from distutils.sysconfig import get_python_lib, get_python_version

    def _get_purelib(***REMOVED***:
        return get_python_lib(False***REMOVED***


def strip_module(filename***REMOVED***:
    if '.' in filename:
        filename = os.path.splitext(filename***REMOVED***[0***REMOVED***
    if filename.endswith('module'***REMOVED***:
        filename = filename[:-6***REMOVED***
    return filename


def write_stub(resource, pyfile***REMOVED***:
    _stub_template = textwrap.dedent(***REMOVED***
        def __bootstrap__(***REMOVED***:
            global __bootstrap__, __loader__, __file__
            import sys, pkg_resources, imp
            __file__ = pkg_resources.resource_filename(__name__, %r***REMOVED***
            __loader__ = None; del __bootstrap__, __loader__
            imp.load_dynamic(__name__,__file__***REMOVED***
        __bootstrap__(***REMOVED***
        ***REMOVED******REMOVED***.lstrip(***REMOVED***
    with open(pyfile, 'w'***REMOVED*** as f:
        f.write(_stub_template % resource***REMOVED***


class bdist_egg(Command***REMOVED***:
    description = "create an \"egg\" distribution"

    user_options = [
        ('bdist-dir=', 'b',
         "temporary directory for creating the distribution"***REMOVED***,
        ('plat-name=', 'p', "platform name to embed in generated filenames "
                            "(default: %s***REMOVED***" % get_build_platform(***REMOVED******REMOVED***,
        ('exclude-source-files', None,
         "remove all .py files from the generated egg"***REMOVED***,
        ('keep-temp', 'k',
         "keep the pseudo-installation tree around after " +
         "creating the distribution archive"***REMOVED***,
        ('dist-dir=', 'd',
         "directory to put final built distributions in"***REMOVED***,
        ('skip-build', None,
         "skip rebuilding everything (for testing/debugging***REMOVED***"***REMOVED***,
    ***REMOVED***

    boolean_options = [
        'keep-temp', 'skip-build', 'exclude-source-files'
    ***REMOVED***

    def initialize_options(self***REMOVED***:
        self.bdist_dir = None
        self.plat_name = None
        self.keep_temp = 0
        self.dist_dir = None
        self.skip_build = 0
        self.egg_output = None
        self.exclude_source_files = None

    def finalize_options(self***REMOVED***:
        ei_cmd = self.ei_cmd = self.get_finalized_command("egg_info"***REMOVED***
        self.egg_info = ei_cmd.egg_info

        if self.bdist_dir is None:
            bdist_base = self.get_finalized_command('bdist'***REMOVED***.bdist_base
            self.bdist_dir = os.path.join(bdist_base, 'egg'***REMOVED***

        if self.plat_name is None:
            self.plat_name = get_build_platform(***REMOVED***

        self.set_undefined_options('bdist', ('dist_dir', 'dist_dir'***REMOVED******REMOVED***

        if self.egg_output is None:

            # Compute filename of the output egg
            basename = Distribution(
                None, None, ei_cmd.egg_name, ei_cmd.egg_version,
                get_python_version(***REMOVED***,
                self.distribution.has_ext_modules(***REMOVED*** and self.plat_name
            ***REMOVED***.egg_name(***REMOVED***

            self.egg_output = os.path.join(self.dist_dir, basename + '.egg'***REMOVED***

    def do_install_data(self***REMOVED***:
        # Hack for packages that install data to install's --install-lib
        self.get_finalized_command('install'***REMOVED***.install_lib = self.bdist_dir

        site_packages = os.path.normcase(os.path.realpath(_get_purelib(***REMOVED******REMOVED******REMOVED***
        old, self.distribution.data_files = self.distribution.data_files, [***REMOVED***

        for item in old:
            if isinstance(item, tuple***REMOVED*** and len(item***REMOVED*** == 2:
                if os.path.isabs(item[0***REMOVED******REMOVED***:
                    realpath = os.path.realpath(item[0***REMOVED******REMOVED***
                    normalized = os.path.normcase(realpath***REMOVED***
                    if normalized == site_packages or normalized.startswith(
                        site_packages + os.sep
                    ***REMOVED***:
                        item = realpath[len(site_packages***REMOVED*** + 1:***REMOVED***, item[1***REMOVED***
                        # XXX else: raise ???
            self.distribution.data_files.append(item***REMOVED***

        ***REMOVED***
            log.info("installing package data to %s", self.bdist_dir***REMOVED***
            self.call_command('install_data', force=0, root=None***REMOVED***
        finally:
            self.distribution.data_files = old

    def get_outputs(self***REMOVED***:
        return [self.egg_output***REMOVED***

    def call_command(self, cmdname, **kw***REMOVED***:
        ***REMOVED***Invoke reinitialized command `cmdname` with keyword args***REMOVED***
        for dirname in INSTALL_DIRECTORY_ATTRS:
            kw.setdefault(dirname, self.bdist_dir***REMOVED***
        kw.setdefault('skip_build', self.skip_build***REMOVED***
        kw.setdefault('dry_run', self.dry_run***REMOVED***
        cmd = self.reinitialize_command(cmdname, **kw***REMOVED***
        self.run_command(cmdname***REMOVED***
        return cmd

    def run(self***REMOVED***:
        # Generate metadata first
        self.run_command("egg_info"***REMOVED***
        # We run install_lib before install_data, because some data hacks
        # pull their data path from the install_lib command.
        log.info("installing library code to %s", self.bdist_dir***REMOVED***
        instcmd = self.get_finalized_command('install'***REMOVED***
        old_root = instcmd.root
        instcmd.root = None
        if self.distribution.has_c_libraries(***REMOVED*** and not self.skip_build:
            self.run_command('build_clib'***REMOVED***
        cmd = self.call_command('install_lib', warn_dir=0***REMOVED***
        instcmd.root = old_root

        all_outputs, ext_outputs = self.get_ext_outputs(***REMOVED***
        self.stubs = [***REMOVED***
        to_compile = [***REMOVED***
        for (p, ext_name***REMOVED*** in enumerate(ext_outputs***REMOVED***:
            filename, ext = os.path.splitext(ext_name***REMOVED***
            pyfile = os.path.join(self.bdist_dir, strip_module(filename***REMOVED*** +
                                  '.py'***REMOVED***
            self.stubs.append(pyfile***REMOVED***
            log.info("creating stub loader for %s", ext_name***REMOVED***
            if not self.dry_run:
                write_stub(os.path.basename(ext_name***REMOVED***, pyfile***REMOVED***
            to_compile.append(pyfile***REMOVED***
            ext_outputs[p***REMOVED*** = ext_name.replace(os.sep, '/'***REMOVED***

        if to_compile:
            cmd.byte_compile(to_compile***REMOVED***
        if self.distribution.data_files:
            self.do_install_data(***REMOVED***

        # Make the EGG-INFO directory
        archive_root = self.bdist_dir
        egg_info = os.path.join(archive_root, 'EGG-INFO'***REMOVED***
        self.mkpath(egg_info***REMOVED***
        if self.distribution.scripts:
            script_dir = os.path.join(egg_info, 'scripts'***REMOVED***
            log.info("installing scripts to %s", script_dir***REMOVED***
            self.call_command('install_scripts', install_dir=script_dir,
                              no_ep=1***REMOVED***

        self.copy_metadata_to(egg_info***REMOVED***
        native_libs = os.path.join(egg_info, "native_libs.txt"***REMOVED***
        if all_outputs:
            log.info("writing %s", native_libs***REMOVED***
            if not self.dry_run:
                ensure_directory(native_libs***REMOVED***
                libs_file = open(native_libs, 'wt'***REMOVED***
                libs_file.write('\n'.join(all_outputs***REMOVED******REMOVED***
                libs_file.write('\n'***REMOVED***
                libs_file.close(***REMOVED***
        elif os.path.isfile(native_libs***REMOVED***:
            log.info("removing %s", native_libs***REMOVED***
            if not self.dry_run:
                os.unlink(native_libs***REMOVED***

        write_safety_flag(
            os.path.join(archive_root, 'EGG-INFO'***REMOVED***, self.zip_safe(***REMOVED***
        ***REMOVED***

        if os.path.exists(os.path.join(self.egg_info, 'depends.txt'***REMOVED******REMOVED***:
            log.warn(
                "WARNING: 'depends.txt' will not be used by setuptools 0.6!\n"
                "Use the install_requires/extras_require setup(***REMOVED*** args instead."
            ***REMOVED***

        if self.exclude_source_files:
            self.zap_pyfiles(***REMOVED***

        # Make the archive
        make_zipfile(self.egg_output, archive_root, verbose=self.verbose,
                     dry_run=self.dry_run, mode=self.gen_header(***REMOVED******REMOVED***
        if not self.keep_temp:
            remove_tree(self.bdist_dir, dry_run=self.dry_run***REMOVED***

        # Add to 'Distribution.dist_files' so that the "upload" command works
        getattr(self.distribution, 'dist_files', [***REMOVED******REMOVED***.append(
            ('bdist_egg', get_python_version(***REMOVED***, self.egg_output***REMOVED******REMOVED***

    def zap_pyfiles(self***REMOVED***:
        log.info("Removing .py files from temporary directory"***REMOVED***
        for base, dirs, files in walk_egg(self.bdist_dir***REMOVED***:
            for name in files:
                if name.endswith('.py'***REMOVED***:
                    path = os.path.join(base, name***REMOVED***
                    log.debug("Deleting %s", path***REMOVED***
                    os.unlink(path***REMOVED***

    def zip_safe(self***REMOVED***:
        safe = getattr(self.distribution, 'zip_safe', None***REMOVED***
        if safe is not None:
            return safe
        log.warn("zip_safe flag not set; analyzing archive contents..."***REMOVED***
        return analyze_egg(self.bdist_dir, self.stubs***REMOVED***

    def gen_header(self***REMOVED***:
        epm = EntryPoint.parse_map(self.distribution.entry_points or ''***REMOVED***
        ep = epm.get('setuptools.installation', {***REMOVED******REMOVED***.get('eggsecutable'***REMOVED***
        if ep is None:
            return 'w'  # not an eggsecutable, do it the usual way.

        if not ep.attrs or ep.extras:
            raise DistutilsSetupError(
                "eggsecutable entry point (%r***REMOVED*** cannot have 'extras' "
                "or refer to a module" % (ep,***REMOVED***
            ***REMOVED***

        pyver = sys.version[:3***REMOVED***
        pkg = ep.module_name
        full = '.'.join(ep.attrs***REMOVED***
        base = ep.attrs[0***REMOVED***
        basename = os.path.basename(self.egg_output***REMOVED***

        header = (
            "#!/bin/sh\n"
            'if [ `basename $0` = "%(basename***REMOVED***s" ***REMOVED***\n'
            'then exec python%(pyver***REMOVED***s -c "'
            "import sys, os; sys.path.insert(0, os.path.abspath('$0'***REMOVED******REMOVED***; "
            "from %(pkg***REMOVED***s import %(base***REMOVED***s; sys.exit(%(full***REMOVED***s(***REMOVED******REMOVED***"
            '" "$@"\n'
            'else\n'
            '  echo $0 is not the correct name for this egg file.\n'
            '  echo Please rename it back to %(basename***REMOVED***s and try again.\n'
            '  exec false\n'
            'fi\n'
        ***REMOVED*** % locals(***REMOVED***

        if not self.dry_run:
            mkpath(os.path.dirname(self.egg_output***REMOVED***, dry_run=self.dry_run***REMOVED***
            f = open(self.egg_output, 'w'***REMOVED***
            f.write(header***REMOVED***
            f.close(***REMOVED***
        return 'a'

    def copy_metadata_to(self, target_dir***REMOVED***:
        "Copy metadata (egg info***REMOVED*** to the target_dir"
        # normalize the path (so that a forward-slash in egg_info will
        # match using startswith below***REMOVED***
        norm_egg_info = os.path.normpath(self.egg_info***REMOVED***
        prefix = os.path.join(norm_egg_info, ''***REMOVED***
        for path in self.ei_cmd.filelist.files:
            if path.startswith(prefix***REMOVED***:
                target = os.path.join(target_dir, path[len(prefix***REMOVED***:***REMOVED******REMOVED***
                ensure_directory(target***REMOVED***
                self.copy_file(path, target***REMOVED***

    def get_ext_outputs(self***REMOVED***:
        ***REMOVED***Get a list of relative paths to C extensions in the output distro***REMOVED***

        all_outputs = [***REMOVED***
        ext_outputs = [***REMOVED***

        paths = {self.bdist_dir: ''***REMOVED***
        for base, dirs, files in os.walk(self.bdist_dir***REMOVED***:
            for filename in files:
                if os.path.splitext(filename***REMOVED***[1***REMOVED***.lower(***REMOVED*** in NATIVE_EXTENSIONS:
                    all_outputs.append(paths[base***REMOVED*** + filename***REMOVED***
            for filename in dirs:
                paths[os.path.join(base, filename***REMOVED******REMOVED*** = (paths[base***REMOVED*** +
                                                       filename + '/'***REMOVED***

        if self.distribution.has_ext_modules(***REMOVED***:
            build_cmd = self.get_finalized_command('build_ext'***REMOVED***
            for ext in build_cmd.extensions:
                if isinstance(ext, Library***REMOVED***:
                    continue
                fullname = build_cmd.get_ext_fullname(ext.name***REMOVED***
                filename = build_cmd.get_ext_filename(fullname***REMOVED***
                if not os.path.basename(filename***REMOVED***.startswith('dl-'***REMOVED***:
                    if os.path.exists(os.path.join(self.bdist_dir, filename***REMOVED******REMOVED***:
                        ext_outputs.append(filename***REMOVED***

        return all_outputs, ext_outputs


NATIVE_EXTENSIONS = dict.fromkeys('.dll .so .dylib .pyd'.split(***REMOVED******REMOVED***


def walk_egg(egg_dir***REMOVED***:
    ***REMOVED***Walk an unpacked egg's contents, skipping the metadata directory***REMOVED***
    walker = os.walk(egg_dir***REMOVED***
    base, dirs, files = next(walker***REMOVED***
    if 'EGG-INFO' in dirs:
        dirs.remove('EGG-INFO'***REMOVED***
    yield base, dirs, files
    for bdf in walker:
        yield bdf


def analyze_egg(egg_dir, stubs***REMOVED***:
    # check for existing flag in EGG-INFO
    for flag, fn in safety_flags.items(***REMOVED***:
        if os.path.exists(os.path.join(egg_dir, 'EGG-INFO', fn***REMOVED******REMOVED***:
            return flag
    if not can_scan(***REMOVED***:
        return False
    safe = True
    for base, dirs, files in walk_egg(egg_dir***REMOVED***:
        for name in files:
            if name.endswith('.py'***REMOVED*** or name.endswith('.pyw'***REMOVED***:
                continue
            elif name.endswith('.pyc'***REMOVED*** or name.endswith('.pyo'***REMOVED***:
                # always scan, even if we already know we're not safe
                safe = scan_module(egg_dir, base, name, stubs***REMOVED*** and safe
    return safe


def write_safety_flag(egg_dir, safe***REMOVED***:
    # Write or remove zip safety flag file(s***REMOVED***
    for flag, fn in safety_flags.items(***REMOVED***:
        fn = os.path.join(egg_dir, fn***REMOVED***
        if os.path.exists(fn***REMOVED***:
            if safe is None or bool(safe***REMOVED*** != flag:
                os.unlink(fn***REMOVED***
        elif safe is not None and bool(safe***REMOVED*** == flag:
            f = open(fn, 'wt'***REMOVED***
            f.write('\n'***REMOVED***
            f.close(***REMOVED***


safety_flags = {
    True: 'zip-safe',
    False: 'not-zip-safe',
***REMOVED***


def scan_module(egg_dir, base, name, stubs***REMOVED***:
    ***REMOVED***Check whether module possibly uses unsafe-for-zipfile stuff***REMOVED***

    filename = os.path.join(base, name***REMOVED***
    if filename[:-1***REMOVED*** in stubs:
        return True  # Extension module
    pkg = base[len(egg_dir***REMOVED*** + 1:***REMOVED***.replace(os.sep, '.'***REMOVED***
    module = pkg + (pkg and '.' or ''***REMOVED*** + os.path.splitext(name***REMOVED***[0***REMOVED***
    if sys.version_info < (3, 3***REMOVED***:
        skip = 8  # skip magic & date
    else:
        skip = 12  # skip magic & date & file size
    f = open(filename, 'rb'***REMOVED***
    f.read(skip***REMOVED***
    code = marshal.load(f***REMOVED***
    f.close(***REMOVED***
    safe = True
    symbols = dict.fromkeys(iter_symbols(code***REMOVED******REMOVED***
    for bad in ['__file__', '__path__'***REMOVED***:
        if bad in symbols:
            log.warn("%s: module references %s", module, bad***REMOVED***
            safe = False
    if 'inspect' in symbols:
        for bad in [
            'getsource', 'getabsfile', 'getsourcefile', 'getfile'
            'getsourcelines', 'findsource', 'getcomments', 'getframeinfo',
            'getinnerframes', 'getouterframes', 'stack', 'trace'
        ***REMOVED***:
            if bad in symbols:
                log.warn("%s: module MAY be using inspect.%s", module, bad***REMOVED***
                safe = False
    return safe


def iter_symbols(code***REMOVED***:
    ***REMOVED***Yield names and strings used by `code` and its nested code objects***REMOVED***
    for name in code.co_names:
        yield name
    for const in code.co_consts:
        if isinstance(const, six.string_types***REMOVED***:
            yield const
        elif isinstance(const, CodeType***REMOVED***:
            for name in iter_symbols(const***REMOVED***:
                yield name


def can_scan(***REMOVED***:
    if not sys.platform.startswith('java'***REMOVED*** and sys.platform != 'cli':
        # CPython, PyPy, etc.
        return True
    log.warn("Unable to analyze compiled code on this platform."***REMOVED***
    log.warn("Please ask the author to include a 'zip_safe'"
             " setting (either True or False***REMOVED*** in the package's setup.py"***REMOVED***


# Attribute names of options for commands that might need to be convinced to
# install to the egg build directory

INSTALL_DIRECTORY_ATTRS = [
    'install_lib', 'install_dir', 'install_data', 'install_base'
***REMOVED***


def make_zipfile(zip_filename, base_dir, verbose=0, dry_run=0, compress=True,
                 mode='w'***REMOVED***:
    ***REMOVED***Create a zip file from all the files under 'base_dir'.  The output
    zip file will be named 'base_dir' + ".zip".  Uses either the "zipfile"
    Python module (if available***REMOVED*** or the InfoZIP "zip" utility (if installed
    and found on the default search path***REMOVED***.  If neither tool is available,
    raises DistutilsExecError.  Returns the name of the output zip file.
    ***REMOVED***
    import zipfile

    mkpath(os.path.dirname(zip_filename***REMOVED***, dry_run=dry_run***REMOVED***
    log.info("creating '%s' and adding '%s' to it", zip_filename, base_dir***REMOVED***

    def visit(z, dirname, names***REMOVED***:
        for name in names:
            path = os.path.normpath(os.path.join(dirname, name***REMOVED******REMOVED***
            if os.path.isfile(path***REMOVED***:
                p = path[len(base_dir***REMOVED*** + 1:***REMOVED***
                if not dry_run:
                    z.write(path, p***REMOVED***
                log.debug("adding '%s'", p***REMOVED***

    compression = zipfile.ZIP_DEFLATED if compress else zipfile.ZIP_STORED
    if not dry_run:
        z = zipfile.ZipFile(zip_filename, mode, compression=compression***REMOVED***
        for dirname, dirs, files in os.walk(base_dir***REMOVED***:
            visit(z, dirname, files***REMOVED***
        z.close(***REMOVED***
    else:
        for dirname, dirs, files in os.walk(base_dir***REMOVED***:
            visit(None, dirname, files***REMOVED***
    return zip_filename
