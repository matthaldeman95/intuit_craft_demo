***REMOVED***
import sys
import itertools
import imp
from distutils.command.build_ext import build_ext as _du_build_ext
from distutils.file_util import copy_file
from distutils.ccompiler import new_compiler
from distutils.sysconfig import customize_compiler, get_config_var
from distutils.errors import DistutilsError
from distutils import log

from setuptools.extension import Library
from setuptools.extern import six

***REMOVED***
    # Attempt to use Cython for building extensions, if available
    from Cython.Distutils.build_ext import build_ext as _build_ext
except ImportError:
    _build_ext = _du_build_ext

# make sure _config_vars is initialized
get_config_var("LDSHARED"***REMOVED***
from distutils.sysconfig import _config_vars as _CONFIG_VARS


def _customize_compiler_for_shlib(compiler***REMOVED***:
    if sys.platform == "darwin":
        # building .dylib requires additional compiler flags on OSX; here we
        # temporarily substitute the pyconfig.h variables so that distutils'
        # 'customize_compiler' uses them before we build the shared libraries.
        tmp = _CONFIG_VARS.copy(***REMOVED***
        ***REMOVED***
            # XXX Help!  I don't have any idea whether these are right...
            _CONFIG_VARS['LDSHARED'***REMOVED*** = (
                "gcc -Wl,-x -dynamiclib -undefined dynamic_lookup"***REMOVED***
            _CONFIG_VARS['CCSHARED'***REMOVED*** = " -dynamiclib"
            _CONFIG_VARS['SO'***REMOVED*** = ".dylib"
            customize_compiler(compiler***REMOVED***
        finally:
            _CONFIG_VARS.clear(***REMOVED***
            _CONFIG_VARS.update(tmp***REMOVED***
    else:
        customize_compiler(compiler***REMOVED***


have_rtld = False
use_stubs = False
libtype = 'shared'

if sys.platform == "darwin":
    use_stubs = True
elif os.name != 'nt':
    ***REMOVED***
        import dl
        use_stubs = have_rtld = hasattr(dl, 'RTLD_NOW'***REMOVED***
    except ImportError:
        pass

if_dl = lambda s: s if have_rtld else ''


def get_abi3_suffix(***REMOVED***:
    ***REMOVED***Return the file extension for an abi3-compliant Extension(***REMOVED******REMOVED***
    for suffix, _, _ in (s for s in imp.get_suffixes(***REMOVED*** if s[2***REMOVED*** == imp.C_EXTENSION***REMOVED***:
        if '.abi3' in suffix:   # Unix
            return suffix
        elif suffix == '.pyd':  # Windows
            return suffix


class build_ext(_build_ext***REMOVED***:
    def run(self***REMOVED***:
        ***REMOVED***Build extensions in build directory, then copy if --inplace***REMOVED***
        old_inplace, self.inplace = self.inplace, 0
        _build_ext.run(self***REMOVED***
        self.inplace = old_inplace
        if old_inplace:
            self.copy_extensions_to_source(***REMOVED***

    def copy_extensions_to_source(self***REMOVED***:
        build_py = self.get_finalized_command('build_py'***REMOVED***
        for ext in self.extensions:
            fullname = self.get_ext_fullname(ext.name***REMOVED***
            filename = self.get_ext_filename(fullname***REMOVED***
            modpath = fullname.split('.'***REMOVED***
            package = '.'.join(modpath[:-1***REMOVED******REMOVED***
            package_dir = build_py.get_package_dir(package***REMOVED***
            dest_filename = os.path.join(package_dir,
                                         os.path.basename(filename***REMOVED******REMOVED***
            src_filename = os.path.join(self.build_lib, filename***REMOVED***

            # Always copy, even if source is older than destination, to ensure
            # that the right extensions for the current Python/platform are
            # used.
            copy_file(
                src_filename, dest_filename, verbose=self.verbose,
                dry_run=self.dry_run
            ***REMOVED***
            if ext._needs_stub:
                self.write_stub(package_dir or os.curdir, ext, True***REMOVED***

    def get_ext_filename(self, fullname***REMOVED***:
        filename = _build_ext.get_ext_filename(self, fullname***REMOVED***
        if fullname in self.ext_map:
            ext = self.ext_map[fullname***REMOVED***
            use_abi3 = (
                six.PY3
                and getattr(ext, 'py_limited_api'***REMOVED***
                and get_abi3_suffix(***REMOVED***
            ***REMOVED***
            if use_abi3:
                so_ext = get_config_var('EXT_SUFFIX'***REMOVED***
                filename = filename[:-len(so_ext***REMOVED******REMOVED***
                filename = filename + get_abi3_suffix(***REMOVED***
            if isinstance(ext, Library***REMOVED***:
                fn, ext = os.path.splitext(filename***REMOVED***
                return self.shlib_compiler.library_filename(fn, libtype***REMOVED***
            elif use_stubs and ext._links_to_dynamic:
                d, fn = os.path.split(filename***REMOVED***
                return os.path.join(d, 'dl-' + fn***REMOVED***
        return filename

    def initialize_options(self***REMOVED***:
        _build_ext.initialize_options(self***REMOVED***
        self.shlib_compiler = None
        self.shlibs = [***REMOVED***
        self.ext_map = {***REMOVED***

    def finalize_options(self***REMOVED***:
        _build_ext.finalize_options(self***REMOVED***
        self.extensions = self.extensions or [***REMOVED***
        self.check_extensions_list(self.extensions***REMOVED***
        self.shlibs = [ext for ext in self.extensions
                       if isinstance(ext, Library***REMOVED******REMOVED***
        if self.shlibs:
            self.setup_shlib_compiler(***REMOVED***
        for ext in self.extensions:
            ext._full_name = self.get_ext_fullname(ext.name***REMOVED***
        for ext in self.extensions:
            fullname = ext._full_name
            self.ext_map[fullname***REMOVED*** = ext

            # distutils 3.1 will also ask for module names
            # XXX what to do with conflicts?
            self.ext_map[fullname.split('.'***REMOVED***[-1***REMOVED******REMOVED*** = ext

            ltd = self.shlibs and self.links_to_dynamic(ext***REMOVED*** or False
            ns = ltd and use_stubs and not isinstance(ext, Library***REMOVED***
            ext._links_to_dynamic = ltd
            ext._needs_stub = ns
            filename = ext._file_name = self.get_ext_filename(fullname***REMOVED***
            libdir = os.path.dirname(os.path.join(self.build_lib, filename***REMOVED******REMOVED***
            if ltd and libdir not in ext.library_dirs:
                ext.library_dirs.append(libdir***REMOVED***
            if ltd and use_stubs and os.curdir not in ext.runtime_library_dirs:
                ext.runtime_library_dirs.append(os.curdir***REMOVED***

    def setup_shlib_compiler(self***REMOVED***:
        compiler = self.shlib_compiler = new_compiler(
            compiler=self.compiler, dry_run=self.dry_run, force=self.force
        ***REMOVED***
        _customize_compiler_for_shlib(compiler***REMOVED***

        if self.include_dirs is not None:
            compiler.set_include_dirs(self.include_dirs***REMOVED***
        if self.define is not None:
            # 'define' option is a list of (name,value***REMOVED*** tuples
            for (name, value***REMOVED*** in self.define:
                compiler.define_macro(name, value***REMOVED***
        if self.undef is not None:
            for macro in self.undef:
                compiler.undefine_macro(macro***REMOVED***
        if self.libraries is not None:
            compiler.set_libraries(self.libraries***REMOVED***
        if self.library_dirs is not None:
            compiler.set_library_dirs(self.library_dirs***REMOVED***
        if self.rpath is not None:
            compiler.set_runtime_library_dirs(self.rpath***REMOVED***
        if self.link_objects is not None:
            compiler.set_link_objects(self.link_objects***REMOVED***

        # hack so distutils' build_extension(***REMOVED*** builds a library instead
        compiler.link_shared_object = link_shared_object.__get__(compiler***REMOVED***

    def get_export_symbols(self, ext***REMOVED***:
        if isinstance(ext, Library***REMOVED***:
            return ext.export_symbols
        return _build_ext.get_export_symbols(self, ext***REMOVED***

    def build_extension(self, ext***REMOVED***:
        ext._convert_pyx_sources_to_lang(***REMOVED***
        _compiler = self.compiler
        ***REMOVED***
            if isinstance(ext, Library***REMOVED***:
                self.compiler = self.shlib_compiler
            _build_ext.build_extension(self, ext***REMOVED***
            if ext._needs_stub:
                cmd = self.get_finalized_command('build_py'***REMOVED***.build_lib
                self.write_stub(cmd, ext***REMOVED***
        finally:
            self.compiler = _compiler

    def links_to_dynamic(self, ext***REMOVED***:
        ***REMOVED***Return true if 'ext' links to a dynamic lib in the same package***REMOVED***
        # XXX this should check to ensure the lib is actually being built
        # XXX as dynamic, and not just using a locally-found version or a
        # XXX static-compiled version
        libnames = dict.fromkeys([lib._full_name for lib in self.shlibs***REMOVED******REMOVED***
        pkg = '.'.join(ext._full_name.split('.'***REMOVED***[:-1***REMOVED*** + [''***REMOVED******REMOVED***
        return any(pkg + libname in libnames for libname in ext.libraries***REMOVED***

    def get_outputs(self***REMOVED***:
        return _build_ext.get_outputs(self***REMOVED*** + self.__get_stubs_outputs(***REMOVED***

    def __get_stubs_outputs(self***REMOVED***:
        # assemble the base name for each extension that needs a stub
        ns_ext_bases = (
            os.path.join(self.build_lib, *ext._full_name.split('.'***REMOVED******REMOVED***
            for ext in self.extensions
            if ext._needs_stub
        ***REMOVED***
        # pair each base with the extension
        pairs = itertools.product(ns_ext_bases, self.__get_output_extensions(***REMOVED******REMOVED***
        return list(base + fnext for base, fnext in pairs***REMOVED***

    def __get_output_extensions(self***REMOVED***:
        yield '.py'
        yield '.pyc'
        if self.get_finalized_command('build_py'***REMOVED***.optimize:
            yield '.pyo'

    def write_stub(self, output_dir, ext, compile=False***REMOVED***:
        log.info("writing stub loader for %s to %s", ext._full_name,
                 output_dir***REMOVED***
        stub_file = (os.path.join(output_dir, *ext._full_name.split('.'***REMOVED******REMOVED*** +
                     '.py'***REMOVED***
        if compile and os.path.exists(stub_file***REMOVED***:
            raise DistutilsError(stub_file + " already exists! Please delete."***REMOVED***
        if not self.dry_run:
            f = open(stub_file, 'w'***REMOVED***
            f.write(
                '\n'.join([
                    "def __bootstrap__(***REMOVED***:",
                    "   global __bootstrap__, __file__, __loader__",
                    "   import sys, os, pkg_resources, imp" + if_dl(", dl"***REMOVED***,
                    "   __file__ = pkg_resources.resource_filename"
                    "(__name__,%r***REMOVED***"
                    % os.path.basename(ext._file_name***REMOVED***,
                    "   del __bootstrap__",
                    "   if '__loader__' in globals(***REMOVED***:",
                    "       del __loader__",
                    if_dl("   old_flags = sys.getdlopenflags(***REMOVED***"***REMOVED***,
                    "   old_dir = os.getcwd(***REMOVED***",
                    "   ***REMOVED***",
                    "     os.chdir(os.path.dirname(__file__***REMOVED******REMOVED***",
                    if_dl("     sys.setdlopenflags(dl.RTLD_NOW***REMOVED***"***REMOVED***,
                    "     imp.load_dynamic(__name__,__file__***REMOVED***",
                    "   finally:",
                    if_dl("     sys.setdlopenflags(old_flags***REMOVED***"***REMOVED***,
                    "     os.chdir(old_dir***REMOVED***",
                    "__bootstrap__(***REMOVED***",
                    ""  # terminal \n
                ***REMOVED******REMOVED***
            ***REMOVED***
            f.close(***REMOVED***
        if compile:
            from distutils.util import byte_compile

            byte_compile([stub_file***REMOVED***, optimize=0,
                         force=True, dry_run=self.dry_run***REMOVED***
            optimize = self.get_finalized_command('install_lib'***REMOVED***.optimize
            if optimize > 0:
                byte_compile([stub_file***REMOVED***, optimize=optimize,
                             force=True, dry_run=self.dry_run***REMOVED***
            if os.path.exists(stub_file***REMOVED*** and not self.dry_run:
                os.unlink(stub_file***REMOVED***


if use_stubs or os.name == 'nt':
    # Build shared libraries
    #
    def link_shared_object(
            self, objects, output_libname, output_dir=None, libraries=None,
            library_dirs=None, runtime_library_dirs=None, export_symbols=None,
            debug=0, extra_preargs=None, extra_postargs=None, build_temp=None,
            target_lang=None***REMOVED***:
        self.link(
            self.SHARED_LIBRARY, objects, output_libname,
            output_dir, libraries, library_dirs, runtime_library_dirs,
            export_symbols, debug, extra_preargs, extra_postargs,
            build_temp, target_lang
        ***REMOVED***
else:
    # Build static libraries everywhere else
    libtype = 'static'

    def link_shared_object(
            self, objects, output_libname, output_dir=None, libraries=None,
            library_dirs=None, runtime_library_dirs=None, export_symbols=None,
            debug=0, extra_preargs=None, extra_postargs=None, build_temp=None,
            target_lang=None***REMOVED***:
        # XXX we need to either disallow these attrs on Library instances,
        # or warn/abort here if set, or something...
        # libraries=None, library_dirs=None, runtime_library_dirs=None,
        # export_symbols=None, extra_preargs=None, extra_postargs=None,
        # build_temp=None

        assert output_dir is None  # distutils build_ext doesn't pass this
        output_dir, filename = os.path.split(output_libname***REMOVED***
        basename, ext = os.path.splitext(filename***REMOVED***
        if self.library_filename("x"***REMOVED***.startswith('lib'***REMOVED***:
            # strip 'lib' prefix; this is kludgy if some platform uses
            # a different prefix
            basename = basename[3:***REMOVED***

        self.create_static_lib(
            objects, basename, output_dir, debug, target_lang
        ***REMOVED***
