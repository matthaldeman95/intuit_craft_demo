***REMOVED***
import operator
import sys
import contextlib
import itertools
from distutils.errors import DistutilsOptionError
from unittest import TestLoader

from setuptools.extern import six
from setuptools.extern.six.moves import map, filter

from pkg_resources import (resource_listdir, resource_exists, normalize_path,
                           working_set, _namespace_packages,
                           add_activation_listener, require, EntryPoint***REMOVED***
from setuptools import Command
from setuptools.py31compat import unittest_main


class ScanningLoader(TestLoader***REMOVED***:
    def loadTestsFromModule(self, module, pattern=None***REMOVED***:
        ***REMOVED***Return a suite of all tests cases contained in the given module

        If the module is a package, load tests from all the modules in it.
        If the module has an ``additional_tests`` function, call it and add
        the return value to the tests.
        ***REMOVED***
        tests = [***REMOVED***
        tests.append(TestLoader.loadTestsFromModule(self, module***REMOVED******REMOVED***

        if hasattr(module, "additional_tests"***REMOVED***:
            tests.append(module.additional_tests(***REMOVED******REMOVED***

        if hasattr(module, '__path__'***REMOVED***:
            for file in resource_listdir(module.__name__, ''***REMOVED***:
                if file.endswith('.py'***REMOVED*** and file != '__init__.py':
                    submodule = module.__name__ + '.' + file[:-3***REMOVED***
                else:
                    if resource_exists(module.__name__, file + '/__init__.py'***REMOVED***:
                        submodule = module.__name__ + '.' + file
                    else:
                        continue
                tests.append(self.loadTestsFromName(submodule***REMOVED******REMOVED***

        if len(tests***REMOVED*** != 1:
            return self.suiteClass(tests***REMOVED***
        else:
            return tests[0***REMOVED***  # don't create a nested suite for only one return


# adapted from jaraco.classes.properties:NonDataProperty
class NonDataProperty(object***REMOVED***:
    def __init__(self, fget***REMOVED***:
        self.fget = fget

    def __get__(self, obj, objtype=None***REMOVED***:
        if obj is None:
            return self
        return self.fget(obj***REMOVED***


class test(Command***REMOVED***:
    ***REMOVED***Command to run unit tests after in-place build***REMOVED***

    description = "run unit tests after in-place build"

    user_options = [
        ('test-module=', 'm', "Run 'test_suite' in specified module"***REMOVED***,
        ('test-suite=', 's',
         "Test suite to run (e.g. 'some_module.test_suite'***REMOVED***"***REMOVED***,
        ('test-runner=', 'r', "Test runner to use"***REMOVED***,
    ***REMOVED***

    def initialize_options(self***REMOVED***:
        self.test_suite = None
        self.test_module = None
        self.test_loader = None
        self.test_runner = None

    def finalize_options(self***REMOVED***:

        if self.test_suite and self.test_module:
            msg = "You may specify a module or a suite, but not both"
            raise DistutilsOptionError(msg***REMOVED***

        if self.test_suite is None:
            if self.test_module is None:
                self.test_suite = self.distribution.test_suite
            else:
                self.test_suite = self.test_module + ".test_suite"

        if self.test_loader is None:
            self.test_loader = getattr(self.distribution, 'test_loader', None***REMOVED***
        if self.test_loader is None:
            self.test_loader = "setuptools.command.test:ScanningLoader"
        if self.test_runner is None:
            self.test_runner = getattr(self.distribution, 'test_runner', None***REMOVED***

    @NonDataProperty
    def test_args(self***REMOVED***:
        return list(self._test_args(***REMOVED******REMOVED***

    def _test_args(self***REMOVED***:
        if self.verbose:
            yield '--verbose'
        if self.test_suite:
            yield self.test_suite

    def with_project_on_sys_path(self, func***REMOVED***:
        ***REMOVED***
        Backward compatibility for project_on_sys_path context.
        ***REMOVED***
        with self.project_on_sys_path(***REMOVED***:
            func(***REMOVED***

    @contextlib.contextmanager
    def project_on_sys_path(self, include_dists=[***REMOVED******REMOVED***:
        with_2to3 = six.PY3 and getattr(self.distribution, 'use_2to3', False***REMOVED***

        if with_2to3:
            # If we run 2to3 we can not do this inplace:

            # Ensure metadata is up-to-date
            self.reinitialize_command('build_py', inplace=0***REMOVED***
            self.run_command('build_py'***REMOVED***
            bpy_cmd = self.get_finalized_command("build_py"***REMOVED***
            build_path = normalize_path(bpy_cmd.build_lib***REMOVED***

            # Build extensions
            self.reinitialize_command('egg_info', egg_base=build_path***REMOVED***
            self.run_command('egg_info'***REMOVED***

            self.reinitialize_command('build_ext', inplace=0***REMOVED***
            self.run_command('build_ext'***REMOVED***
        else:
            # Without 2to3 inplace works fine:
            self.run_command('egg_info'***REMOVED***

            # Build extensions in-place
            self.reinitialize_command('build_ext', inplace=1***REMOVED***
            self.run_command('build_ext'***REMOVED***

        ei_cmd = self.get_finalized_command("egg_info"***REMOVED***

        old_path = sys.path[:***REMOVED***
        old_modules = sys.modules.copy(***REMOVED***

        ***REMOVED***
            project_path = normalize_path(ei_cmd.egg_base***REMOVED***
            sys.path.insert(0, project_path***REMOVED***
            working_set.__init__(***REMOVED***
            add_activation_listener(lambda dist: dist.activate(***REMOVED******REMOVED***
            require('%s==%s' % (ei_cmd.egg_name, ei_cmd.egg_version***REMOVED******REMOVED***
            with self.paths_on_pythonpath([project_path***REMOVED******REMOVED***:
                yield
        finally:
            sys.path[:***REMOVED*** = old_path
            sys.modules.clear(***REMOVED***
            sys.modules.update(old_modules***REMOVED***
            working_set.__init__(***REMOVED***

    @staticmethod
    @contextlib.contextmanager
    def paths_on_pythonpath(paths***REMOVED***:
        ***REMOVED***
        Add the indicated paths to the head of the PYTHONPATH environment
        variable so that subprocesses will also see the packages at
        these paths.

        Do this in a context that restores the value on exit.
        ***REMOVED***
        nothing = object(***REMOVED***
        orig_pythonpath = os.environ.get('PYTHONPATH', nothing***REMOVED***
        current_pythonpath = os.environ.get('PYTHONPATH', ''***REMOVED***
        ***REMOVED***
            prefix = os.pathsep.join(paths***REMOVED***
            to_join = filter(None, [prefix, current_pythonpath***REMOVED******REMOVED***
            new_path = os.pathsep.join(to_join***REMOVED***
            if new_path:
                os.environ['PYTHONPATH'***REMOVED*** = new_path
            yield
        finally:
            if orig_pythonpath is nothing:
                os.environ.pop('PYTHONPATH', None***REMOVED***
            else:
                os.environ['PYTHONPATH'***REMOVED*** = orig_pythonpath

    @staticmethod
    def install_dists(dist***REMOVED***:
        ***REMOVED***
        Install the requirements indicated by self.distribution and
        return an iterable of the dists that were built.
        ***REMOVED***
        ir_d = dist.fetch_build_eggs(dist.install_requires or [***REMOVED******REMOVED***
        tr_d = dist.fetch_build_eggs(dist.tests_require or [***REMOVED******REMOVED***
        return itertools.chain(ir_d, tr_d***REMOVED***

    def run(self***REMOVED***:
        installed_dists = self.install_dists(self.distribution***REMOVED***

        cmd = ' '.join(self._argv***REMOVED***
        if self.dry_run:
            self.announce('skipping "%s" (dry run***REMOVED***' % cmd***REMOVED***
            return

        self.announce('running "%s"' % cmd***REMOVED***

        paths = map(operator.attrgetter('location'***REMOVED***, installed_dists***REMOVED***
        with self.paths_on_pythonpath(paths***REMOVED***:
            with self.project_on_sys_path(***REMOVED***:
                self.run_tests(***REMOVED***

    def run_tests(self***REMOVED***:
        # Purge modules under test from sys.modules. The test loader will
        # re-import them from the build location. Required when 2to3 is used
        # with namespace packages.
        if six.PY3 and getattr(self.distribution, 'use_2to3', False***REMOVED***:
            module = self.test_suite.split('.'***REMOVED***[0***REMOVED***
            if module in _namespace_packages:
                del_modules = [***REMOVED***
                if module in sys.modules:
                    del_modules.append(module***REMOVED***
                module += '.'
                for name in sys.modules:
                    if name.startswith(module***REMOVED***:
                        del_modules.append(name***REMOVED***
                list(map(sys.modules.__delitem__, del_modules***REMOVED******REMOVED***

        unittest_main(
            None, None, self._argv,
            testLoader=self._resolve_as_ep(self.test_loader***REMOVED***,
            testRunner=self._resolve_as_ep(self.test_runner***REMOVED***,
        ***REMOVED***

    @property
    def _argv(self***REMOVED***:
        return ['unittest'***REMOVED*** + self.test_args

    @staticmethod
    def _resolve_as_ep(val***REMOVED***:
        ***REMOVED***
        Load the indicated attribute value, called, as a as if it were
        specified as an entry point.
        ***REMOVED***
        if val is None:
            return
        parsed = EntryPoint.parse("x=" + val***REMOVED***
        return parsed.resolve(***REMOVED***(***REMOVED***
