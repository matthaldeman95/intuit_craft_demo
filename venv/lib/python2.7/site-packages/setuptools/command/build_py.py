from glob import glob
from distutils.util import convert_path
import distutils.command.build_py as orig
***REMOVED***
import fnmatch
import textwrap
import io
import distutils.errors
import itertools

from setuptools.extern import six
from setuptools.extern.six.moves import map, filter, filterfalse

***REMOVED***
    from setuptools.lib2to3_ex import Mixin2to3
except ImportError:

    class Mixin2to3:
        def run_2to3(self, files, doctests=True***REMOVED***:
            "do nothing"


class build_py(orig.build_py, Mixin2to3***REMOVED***:
    ***REMOVED***Enhanced 'build_py' command that includes data files with packages

    The data files are specified via a 'package_data' argument to 'setup(***REMOVED***'.
    See 'setuptools.dist.Distribution' for more details.

    Also, this version of the 'build_py' command allows you to specify both
    'py_modules' and 'packages' in the same setup operation.
    ***REMOVED***

    def finalize_options(self***REMOVED***:
        orig.build_py.finalize_options(self***REMOVED***
        self.package_data = self.distribution.package_data
        self.exclude_package_data = (self.distribution.exclude_package_data or
                                 ***REMOVED******REMOVED******REMOVED***
        if 'data_files' in self.__dict__:
            del self.__dict__['data_files'***REMOVED***
        self.__updated_files = [***REMOVED***
        self.__doctests_2to3 = [***REMOVED***

    def run(self***REMOVED***:
        ***REMOVED***Build modules, packages, and copy data files to build directory***REMOVED***
        if not self.py_modules and not self.packages:
            return

        if self.py_modules:
            self.build_modules(***REMOVED***

        if self.packages:
            self.build_packages(***REMOVED***
            self.build_package_data(***REMOVED***

        self.run_2to3(self.__updated_files, False***REMOVED***
        self.run_2to3(self.__updated_files, True***REMOVED***
        self.run_2to3(self.__doctests_2to3, True***REMOVED***

        # Only compile actual .py files, using our base class' idea of what our
        # output files are.
        self.byte_compile(orig.build_py.get_outputs(self, include_bytecode=0***REMOVED******REMOVED***

    def __getattr__(self, attr***REMOVED***:
        "lazily compute data files"
        if attr == 'data_files':
            self.data_files = self._get_data_files(***REMOVED***
            return self.data_files
        return orig.build_py.__getattr__(self, attr***REMOVED***

    def build_module(self, module, module_file, package***REMOVED***:
        if six.PY2 and isinstance(package, six.string_types***REMOVED***:
            # avoid errors on Python 2 when unicode is passed (#190***REMOVED***
            package = package.split('.'***REMOVED***
        outfile, copied = orig.build_py.build_module(self, module, module_file,
                                                     package***REMOVED***
        if copied:
            self.__updated_files.append(outfile***REMOVED***
        return outfile, copied

    def _get_data_files(self***REMOVED***:
        ***REMOVED***Generate list of '(package,src_dir,build_dir,filenames***REMOVED***' tuples***REMOVED***
        self.analyze_manifest(***REMOVED***
        return list(map(self._get_pkg_data_files, self.packages or (***REMOVED******REMOVED******REMOVED***

    def _get_pkg_data_files(self, package***REMOVED***:
        # Locate package source directory
        src_dir = self.get_package_dir(package***REMOVED***

        # Compute package build directory
        build_dir = os.path.join(*([self.build_lib***REMOVED*** + package.split('.'***REMOVED******REMOVED******REMOVED***

        # Strip directory from globbed filenames
        filenames = [
            os.path.relpath(file, src_dir***REMOVED***
            for file in self.find_data_files(package, src_dir***REMOVED***
        ***REMOVED***
        return package, src_dir, build_dir, filenames

    def find_data_files(self, package, src_dir***REMOVED***:
        ***REMOVED***Return filenames for package's data files in 'src_dir'***REMOVED***
        patterns = self._get_platform_patterns(
            self.package_data,
            package,
            src_dir,
        ***REMOVED***
        globs_expanded = map(glob, patterns***REMOVED***
        # flatten the expanded globs into an iterable of matches
        globs_matches = itertools.chain.from_iterable(globs_expanded***REMOVED***
        glob_files = filter(os.path.isfile, globs_matches***REMOVED***
        files = itertools.chain(
            self.manifest_files.get(package, [***REMOVED******REMOVED***,
            glob_files,
        ***REMOVED***
        return self.exclude_data_files(package, src_dir, files***REMOVED***

    def build_package_data(self***REMOVED***:
        ***REMOVED***Copy data files into build directory***REMOVED***
        for package, src_dir, build_dir, filenames in self.data_files:
            for filename in filenames:
                target = os.path.join(build_dir, filename***REMOVED***
                self.mkpath(os.path.dirname(target***REMOVED******REMOVED***
                srcfile = os.path.join(src_dir, filename***REMOVED***
                outf, copied = self.copy_file(srcfile, target***REMOVED***
                srcfile = os.path.abspath(srcfile***REMOVED***
                if (copied and
                        srcfile in self.distribution.convert_2to3_doctests***REMOVED***:
                    self.__doctests_2to3.append(outf***REMOVED***

    def analyze_manifest(self***REMOVED***:
        self.manifest_files = mf = {***REMOVED***
        if not self.distribution.include_package_data:
            return
        src_dirs = {***REMOVED***
        for package in self.packages or (***REMOVED***:
            # Locate package source directory
            src_dirs[assert_relative(self.get_package_dir(package***REMOVED******REMOVED******REMOVED*** = package

        self.run_command('egg_info'***REMOVED***
        ei_cmd = self.get_finalized_command('egg_info'***REMOVED***
        for path in ei_cmd.filelist.files:
            d, f = os.path.split(assert_relative(path***REMOVED******REMOVED***
            prev = None
            oldf = f
            while d and d != prev and d not in src_dirs:
                prev = d
                d, df = os.path.split(d***REMOVED***
                f = os.path.join(df, f***REMOVED***
            if d in src_dirs:
                if path.endswith('.py'***REMOVED*** and f == oldf:
                    continue  # it's a module, not data
                mf.setdefault(src_dirs[d***REMOVED***, [***REMOVED******REMOVED***.append(path***REMOVED***

    def get_data_files(self***REMOVED***:
        pass  # Lazily compute data files in _get_data_files(***REMOVED*** function.

    def check_package(self, package, package_dir***REMOVED***:
        ***REMOVED***Check namespace packages' __init__ for declare_namespace***REMOVED***
        ***REMOVED***
            return self.packages_checked[package***REMOVED***
        except KeyError:
            pass

        init_py = orig.build_py.check_package(self, package, package_dir***REMOVED***
        self.packages_checked[package***REMOVED*** = init_py

        if not init_py or not self.distribution.namespace_packages:
            return init_py

        for pkg in self.distribution.namespace_packages:
            if pkg == package or pkg.startswith(package + '.'***REMOVED***:
                break
        else:
            return init_py

        with io.open(init_py, 'rb'***REMOVED*** as f:
            contents = f.read(***REMOVED***
        if b'declare_namespace' not in contents:
            raise distutils.errors.DistutilsError(
                "Namespace package problem: %s is a namespace package, but "
                "its\n__init__.py does not call declare_namespace(***REMOVED***! Please "
                'fix it.\n(See the setuptools manual under '
                '"Namespace Packages" for details.***REMOVED***\n"' % (package,***REMOVED***
            ***REMOVED***
        return init_py

    def initialize_options(self***REMOVED***:
        self.packages_checked = {***REMOVED***
        orig.build_py.initialize_options(self***REMOVED***

    def get_package_dir(self, package***REMOVED***:
        res = orig.build_py.get_package_dir(self, package***REMOVED***
        if self.distribution.src_root is not None:
            return os.path.join(self.distribution.src_root, res***REMOVED***
        return res

    def exclude_data_files(self, package, src_dir, files***REMOVED***:
        ***REMOVED***Filter filenames for package's data files in 'src_dir'***REMOVED***
        files = list(files***REMOVED***
        patterns = self._get_platform_patterns(
            self.exclude_package_data,
            package,
            src_dir,
        ***REMOVED***
        match_groups = (
            fnmatch.filter(files, pattern***REMOVED***
            for pattern in patterns
        ***REMOVED***
        # flatten the groups of matches into an iterable of matches
        matches = itertools.chain.from_iterable(match_groups***REMOVED***
        bad = set(matches***REMOVED***
        keepers = (
            fn
            for fn in files
            if fn not in bad
        ***REMOVED***
        # ditch dupes
        return list(_unique_everseen(keepers***REMOVED******REMOVED***

    @staticmethod
    def _get_platform_patterns(spec, package, src_dir***REMOVED***:
        ***REMOVED***
        yield platfrom-specific path patterns (suitable for glob
        or fn_match***REMOVED*** from a glob-based spec (such as
        self.package_data or self.exclude_package_data***REMOVED***
        matching package in src_dir.
        ***REMOVED***
        raw_patterns = itertools.chain(
            spec.get('', [***REMOVED******REMOVED***,
            spec.get(package, [***REMOVED******REMOVED***,
        ***REMOVED***
        return (
            # Each pattern has to be converted to a platform-specific path
            os.path.join(src_dir, convert_path(pattern***REMOVED******REMOVED***
            for pattern in raw_patterns
        ***REMOVED***


# from Python docs
def _unique_everseen(iterable, key=None***REMOVED***:
    "List unique elements, preserving order. Remember all elements ever seen."
    # unique_everseen('AAAABBBCCDAABBB'***REMOVED*** --> A B C D
    # unique_everseen('ABBCcAD', str.lower***REMOVED*** --> A B C D
    seen = set(***REMOVED***
    seen_add = seen.add
    if key is None:
        for element in filterfalse(seen.__contains__, iterable***REMOVED***:
            seen_add(element***REMOVED***
            yield element
    else:
        for element in iterable:
            k = key(element***REMOVED***
            if k not in seen:
                seen_add(k***REMOVED***
                yield element


def assert_relative(path***REMOVED***:
    if not os.path.isabs(path***REMOVED***:
        return path
    from distutils.errors import DistutilsSetupError

    msg = textwrap.dedent(***REMOVED***
        Error: setup script specifies an absolute path:

            %s

        setup(***REMOVED*** arguments must *always* be /-separated paths relative to the
        setup.py directory, *never* absolute paths.
        ***REMOVED******REMOVED***.lstrip(***REMOVED*** % path
    raise DistutilsSetupError(msg***REMOVED***
