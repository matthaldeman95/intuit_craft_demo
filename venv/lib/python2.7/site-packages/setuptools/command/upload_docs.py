# -*- coding: utf-8 -*-
***REMOVED***upload_docs

Implements a Distutils 'upload_docs' subcommand (upload documentation to
PyPI's pythonhosted.org***REMOVED***.
***REMOVED***

from base64 import standard_b64encode
from distutils import log
from distutils.errors import DistutilsOptionError
***REMOVED***
import socket
import zipfile
import tempfile
import shutil
import itertools
import functools

from setuptools.extern import six
from setuptools.extern.six.moves import http_client, urllib

from pkg_resources import iter_entry_points
from .upload import upload


def _encode(s***REMOVED***:
    errors = 'surrogateescape' if six.PY3 else 'strict'
    return s.encode('utf-8', errors***REMOVED***


class upload_docs(upload***REMOVED***:
    # override the default repository as upload_docs isn't
    # supported by Warehouse (and won't be***REMOVED***.
    DEFAULT_REPOSITORY = 'https://pypi.python.org/pypi/'

    description = 'Upload documentation to PyPI'

    user_options = [
        ('repository=', 'r',
         "url of repository [default: %s***REMOVED***" % upload.DEFAULT_REPOSITORY***REMOVED***,
        ('show-response', None,
         'display full response text from server'***REMOVED***,
        ('upload-dir=', None, 'directory to upload'***REMOVED***,
    ***REMOVED***
    boolean_options = upload.boolean_options

    def has_sphinx(self***REMOVED***:
        if self.upload_dir is None:
            for ep in iter_entry_points('distutils.commands', 'build_sphinx'***REMOVED***:
                return True

    sub_commands = [('build_sphinx', has_sphinx***REMOVED******REMOVED***

    def initialize_options(self***REMOVED***:
        upload.initialize_options(self***REMOVED***
        self.upload_dir = None
        self.target_dir = None

    def finalize_options(self***REMOVED***:
        log.warn("Upload_docs command is deprecated. Use RTD instead."***REMOVED***
        upload.finalize_options(self***REMOVED***
        if self.upload_dir is None:
            if self.has_sphinx(***REMOVED***:
                build_sphinx = self.get_finalized_command('build_sphinx'***REMOVED***
                self.target_dir = build_sphinx.builder_target_dir
            else:
                build = self.get_finalized_command('build'***REMOVED***
                self.target_dir = os.path.join(build.build_base, 'docs'***REMOVED***
        else:
            self.ensure_dirname('upload_dir'***REMOVED***
            self.target_dir = self.upload_dir
        self.announce('Using upload directory %s' % self.target_dir***REMOVED***

    def create_zipfile(self, filename***REMOVED***:
        zip_file = zipfile.ZipFile(filename, "w"***REMOVED***
        ***REMOVED***
            self.mkpath(self.target_dir***REMOVED***  # just in case
            for root, dirs, files in os.walk(self.target_dir***REMOVED***:
                if root == self.target_dir and not files:
                    raise DistutilsOptionError(
                        "no files found in upload directory '%s'"
                        % self.target_dir***REMOVED***
                for name in files:
                    full = os.path.join(root, name***REMOVED***
                    relative = root[len(self.target_dir***REMOVED***:***REMOVED***.lstrip(os.path.sep***REMOVED***
                    dest = os.path.join(relative, name***REMOVED***
                    zip_file.write(full, dest***REMOVED***
        finally:
            zip_file.close(***REMOVED***

    def run(self***REMOVED***:
        # Run sub commands
        for cmd_name in self.get_sub_commands(***REMOVED***:
            self.run_command(cmd_name***REMOVED***

        tmp_dir = tempfile.mkdtemp(***REMOVED***
        name = self.distribution.metadata.get_name(***REMOVED***
        zip_file = os.path.join(tmp_dir, "%s.zip" % name***REMOVED***
        ***REMOVED***
            self.create_zipfile(zip_file***REMOVED***
            self.upload_file(zip_file***REMOVED***
        finally:
            shutil.rmtree(tmp_dir***REMOVED***

    @staticmethod
    def _build_part(item, sep_boundary***REMOVED***:
        key, values = item
        title = '\nContent-Disposition: form-data; name="%s"' % key
        # handle multiple entries for the same name
        if not isinstance(values, list***REMOVED***:
            values = [values***REMOVED***
        for value in values:
            if isinstance(value, tuple***REMOVED***:
                title += '; filename="%s"' % value[0***REMOVED***
                value = value[1***REMOVED***
            else:
                value = _encode(value***REMOVED***
            yield sep_boundary
            yield _encode(title***REMOVED***
            yield b"\n\n"
            yield value
            if value and value[-1:***REMOVED*** == b'\r':
                yield b'\n'  # write an extra newline (lurve Macs***REMOVED***

    @classmethod
    def _build_multipart(cls, data***REMOVED***:
        ***REMOVED***
        Build up the MIME payload for the POST data
        ***REMOVED***
        boundary = b'--------------GHSKFJDLGDS7543FJKLFHRE75642756743254'
        sep_boundary = b'\n--' + boundary
        end_boundary = sep_boundary + b'--'
        end_items = end_boundary, b"\n",
        builder = functools.partial(
            cls._build_part,
            sep_boundary=sep_boundary,
        ***REMOVED***
        part_groups = map(builder, data.items(***REMOVED******REMOVED***
        parts = itertools.chain.from_iterable(part_groups***REMOVED***
        body_items = itertools.chain(parts, end_items***REMOVED***
        content_type = 'multipart/form-data; boundary=%s' % boundary
        return b''.join(body_items***REMOVED***, content_type

    def upload_file(self, filename***REMOVED***:
        with open(filename, 'rb'***REMOVED*** as f:
            content = f.read(***REMOVED***
        meta = self.distribution.metadata
        data = {
            ':action': 'doc_upload',
            'name': meta.get_name(***REMOVED***,
            'content': (os.path.basename(filename***REMOVED***, content***REMOVED***,
    ***REMOVED***
        # set up the authentication
        credentials = _encode(self.username + ':' + self.password***REMOVED***
        credentials = standard_b64encode(credentials***REMOVED***
        if six.PY3:
            credentials = credentials.decode('ascii'***REMOVED***
        auth = "Basic " + credentials

        body, ct = self._build_multipart(data***REMOVED***

        self.announce("Submitting documentation to %s" % (self.repository***REMOVED***,
                      log.INFO***REMOVED***

        # build the Request
        # We can't use urllib2 since we need to send the Basic
        # auth right with the first request
        schema, netloc, url, params, query, fragments = \
            urllib.parse.urlparse(self.repository***REMOVED***
        assert not params and not query and not fragments
        if schema == 'http':
            conn = http_client.HTTPConnection(netloc***REMOVED***
        elif schema == 'https':
            conn = http_client.HTTPSConnection(netloc***REMOVED***
        else:
            raise AssertionError("unsupported schema " + schema***REMOVED***

        data = ''
        ***REMOVED***
            conn.connect(***REMOVED***
            conn.putrequest("POST", url***REMOVED***
            content_type = ct
            conn.putheader('Content-type', content_type***REMOVED***
            conn.putheader('Content-length', str(len(body***REMOVED******REMOVED******REMOVED***
            conn.putheader('Authorization', auth***REMOVED***
            conn.endheaders(***REMOVED***
            conn.send(body***REMOVED***
        except socket.error as e:
            self.announce(str(e***REMOVED***, log.ERROR***REMOVED***
            return

        r = conn.getresponse(***REMOVED***
        if r.status == 200:
            self.announce('Server response (%s***REMOVED***: %s' % (r.status, r.reason***REMOVED***,
                          log.INFO***REMOVED***
        elif r.status == 301:
            location = r.getheader('Location'***REMOVED***
            if location is None:
                location = 'https://pythonhosted.org/%s/' % meta.get_name(***REMOVED***
            self.announce('Upload successful. Visit %s' % location,
                          log.INFO***REMOVED***
        else:
            self.announce('Upload failed (%s***REMOVED***: %s' % (r.status, r.reason***REMOVED***,
                          log.ERROR***REMOVED***
        if self.show_response:
            print('-' * 75, r.read(***REMOVED***, '-' * 75***REMOVED***
