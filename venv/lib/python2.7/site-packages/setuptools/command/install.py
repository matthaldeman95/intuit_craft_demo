from distutils.errors import DistutilsArgError
import inspect
import glob
import warnings
import platform
import distutils.command.install as orig

import setuptools

# Prior to numpy 1.9, NumPy relies on the '_install' name, so provide it for
# now. See https://github.com/pypa/setuptools/issues/199/
_install = orig.install


class install(orig.install***REMOVED***:
    ***REMOVED***Use easy_install to install the package, w/dependencies***REMOVED***

    user_options = orig.install.user_options + [
        ('old-and-unmanageable', None, "Try not to use this!"***REMOVED***,
        ('single-version-externally-managed', None,
         "used by system package builders to create 'flat' eggs"***REMOVED***,
    ***REMOVED***
    boolean_options = orig.install.boolean_options + [
        'old-and-unmanageable', 'single-version-externally-managed',
    ***REMOVED***
    new_commands = [
        ('install_egg_info', lambda self: True***REMOVED***,
        ('install_scripts', lambda self: True***REMOVED***,
    ***REMOVED***
    _nc = dict(new_commands***REMOVED***

    def initialize_options(self***REMOVED***:
        orig.install.initialize_options(self***REMOVED***
        self.old_and_unmanageable = None
        self.single_version_externally_managed = None

    def finalize_options(self***REMOVED***:
        orig.install.finalize_options(self***REMOVED***
        if self.root:
            self.single_version_externally_managed = True
        elif self.single_version_externally_managed:
            if not self.root and not self.record:
                raise DistutilsArgError(
                    "You must specify --record or --root when building system"
                    " packages"
                ***REMOVED***

    def handle_extra_path(self***REMOVED***:
        if self.root or self.single_version_externally_managed:
            # explicit backward-compatibility mode, allow extra_path to work
            return orig.install.handle_extra_path(self***REMOVED***

        # Ignore extra_path when installing an egg (or being run by another
        # command without --root or --single-version-externally-managed
        self.path_file = None
        self.extra_dirs = ''

    def run(self***REMOVED***:
        # Explicit request for old-style install?  Just do it
        if self.old_and_unmanageable or self.single_version_externally_managed:
            return orig.install.run(self***REMOVED***

        if not self._called_from_setup(inspect.currentframe(***REMOVED******REMOVED***:
            # Run in backward-compatibility mode to support bdist_* commands.
            orig.install.run(self***REMOVED***
        else:
            self.do_egg_install(***REMOVED***

    @staticmethod
    def _called_from_setup(run_frame***REMOVED***:
        ***REMOVED***
        Attempt to detect whether run(***REMOVED*** was called from setup(***REMOVED*** or by another
        command.  If called by setup(***REMOVED***, the parent caller will be the
        'run_command' method in 'distutils.dist', and *its* caller will be
        the 'run_commands' method.  If called any other way, the
        immediate caller *might* be 'run_command', but it won't have been
        called by 'run_commands'. Return True in that case or if a call stack
        is unavailable. Return False otherwise.
        ***REMOVED***
        if run_frame is None:
            msg = "Call stack not available. bdist_* commands may fail."
            warnings.warn(msg***REMOVED***
            if platform.python_implementation(***REMOVED*** == 'IronPython':
                msg = "For best results, pass -X:Frames to enable call stack."
                warnings.warn(msg***REMOVED***
            return True
        res = inspect.getouterframes(run_frame***REMOVED***[2***REMOVED***
        caller, = res[:1***REMOVED***
        info = inspect.getframeinfo(caller***REMOVED***
        caller_module = caller.f_globals.get('__name__', ''***REMOVED***
        return (
            caller_module == 'distutils.dist'
            and info.function == 'run_commands'
        ***REMOVED***

    def do_egg_install(self***REMOVED***:

        easy_install = self.distribution.get_command_class('easy_install'***REMOVED***

        cmd = easy_install(
            self.distribution, args="x", root=self.root, record=self.record,
        ***REMOVED***
        cmd.ensure_finalized(***REMOVED***  # finalize before bdist_egg munges install cmd
        cmd.always_copy_from = '.'  # make sure local-dir eggs get installed

        # pick up setup-dir .egg files only: no .egg-info
        cmd.package_index.scan(glob.glob('*.egg'***REMOVED******REMOVED***

        self.run_command('bdist_egg'***REMOVED***
        args = [self.distribution.get_command_obj('bdist_egg'***REMOVED***.egg_output***REMOVED***

        if setuptools.bootstrap_install_from:
            # Bootstrap self-installation of setuptools
            args.insert(0, setuptools.bootstrap_install_from***REMOVED***

        cmd.args = args
        cmd.run(***REMOVED***
        setuptools.bootstrap_install_from = None


# XXX Python 3.1 doesn't see _nc if this is inside the class
install.sub_commands = (
    [cmd for cmd in orig.install.sub_commands if cmd[0***REMOVED*** not in install._nc***REMOVED*** +
    install.new_commands
***REMOVED***
