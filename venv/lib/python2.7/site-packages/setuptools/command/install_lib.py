***REMOVED***
import imp
from itertools import product, starmap
import distutils.command.install_lib as orig


class install_lib(orig.install_lib***REMOVED***:
    ***REMOVED***Don't add compiled flags to filenames of non-Python files***REMOVED***

    def run(self***REMOVED***:
        self.build(***REMOVED***
        outfiles = self.install(***REMOVED***
        if outfiles is not None:
            # always compile, in case we have any extension stubs to deal with
            self.byte_compile(outfiles***REMOVED***

    def get_exclusions(self***REMOVED***:
        ***REMOVED***
        Return a collections.Sized collections.Container of paths to be
        excluded for single_version_externally_managed installations.
        ***REMOVED***
        all_packages = (
            pkg
            for ns_pkg in self._get_SVEM_NSPs(***REMOVED***
            for pkg in self._all_packages(ns_pkg***REMOVED***
        ***REMOVED***

        excl_specs = product(all_packages, self._gen_exclusion_paths(***REMOVED******REMOVED***
        return set(starmap(self._exclude_pkg_path, excl_specs***REMOVED******REMOVED***

    def _exclude_pkg_path(self, pkg, exclusion_path***REMOVED***:
        ***REMOVED***
        Given a package name and exclusion path within that package,
        compute the full exclusion path.
        ***REMOVED***
        parts = pkg.split('.'***REMOVED*** + [exclusion_path***REMOVED***
        return os.path.join(self.install_dir, *parts***REMOVED***

    @staticmethod
    def _all_packages(pkg_name***REMOVED***:
        ***REMOVED***
        >>> list(install_lib._all_packages('foo.bar.baz'***REMOVED******REMOVED***
        ['foo.bar.baz', 'foo.bar', 'foo'***REMOVED***
        ***REMOVED***
        while pkg_name:
            yield pkg_name
            pkg_name, sep, child = pkg_name.rpartition('.'***REMOVED***

    def _get_SVEM_NSPs(self***REMOVED***:
        ***REMOVED***
        Get namespace packages (list***REMOVED*** but only for
        single_version_externally_managed installations and empty otherwise.
        ***REMOVED***
        # TODO: is it necessary to short-circuit here? i.e. what's the cost
        # if get_finalized_command is called even when namespace_packages is
        # False?
        if not self.distribution.namespace_packages:
            return [***REMOVED***

        install_cmd = self.get_finalized_command('install'***REMOVED***
        svem = install_cmd.single_version_externally_managed

        return self.distribution.namespace_packages if svem else [***REMOVED***

    @staticmethod
    def _gen_exclusion_paths(***REMOVED***:
        ***REMOVED***
        Generate file paths to be excluded for namespace packages (bytecode
        cache files***REMOVED***.
        ***REMOVED***
        # always exclude the package module itself
        yield '__init__.py'

        yield '__init__.pyc'
        yield '__init__.pyo'

        if not hasattr(imp, 'get_tag'***REMOVED***:
            return

        base = os.path.join('__pycache__', '__init__.' + imp.get_tag(***REMOVED******REMOVED***
        yield base + '.pyc'
        yield base + '.pyo'
        yield base + '.opt-1.pyc'
        yield base + '.opt-2.pyc'

    def copy_tree(
            self, infile, outfile,
            preserve_mode=1, preserve_times=1, preserve_symlinks=0, level=1
    ***REMOVED***:
        assert preserve_mode and preserve_times and not preserve_symlinks
        exclude = self.get_exclusions(***REMOVED***

        if not exclude:
            return orig.install_lib.copy_tree(self, infile, outfile***REMOVED***

        # Exclude namespace package __init__.py* files from the output

        from setuptools.archive_util import unpack_directory
        from distutils import log

        outfiles = [***REMOVED***

        def pf(src, dst***REMOVED***:
            if dst in exclude:
                log.warn("Skipping installation of %s (namespace package***REMOVED***",
                         dst***REMOVED***
                return False

            log.info("copying %s -> %s", src, os.path.dirname(dst***REMOVED******REMOVED***
            outfiles.append(dst***REMOVED***
            return dst

        unpack_directory(infile, outfile, pf***REMOVED***
        return outfiles

    def get_outputs(self***REMOVED***:
        outputs = orig.install_lib.get_outputs(self***REMOVED***
        exclude = self.get_exclusions(***REMOVED***
        if exclude:
            return [f for f in outputs if f not in exclude***REMOVED***
        return outputs
