***REMOVED***
Filename globbing utility. Mostly a copy of `glob` from Python 3.5.

Changes include:
 * `yield from` and PEP3102 `*` removed.
 * `bytes` changed to `six.binary_type`.
 * Hidden files are not ignored.
***REMOVED***

***REMOVED***
import re
import fnmatch
from setuptools.extern.six import binary_type

__all__ = ["glob", "iglob", "escape"***REMOVED***


def glob(pathname, recursive=False***REMOVED***:
    ***REMOVED***Return a list of paths matching a pathname pattern.

    The pattern may contain simple shell-style wildcards a la
    fnmatch. However, unlike fnmatch, filenames starting with a
    dot are special cases that are not matched by '*' and '?'
    patterns.

    If recursive is true, the pattern '**' will match any files and
    zero or more directories and subdirectories.
    ***REMOVED***
    return list(iglob(pathname, recursive=recursive***REMOVED******REMOVED***


def iglob(pathname, recursive=False***REMOVED***:
    ***REMOVED***Return an iterator which yields the paths matching a pathname pattern.

    The pattern may contain simple shell-style wildcards a la
    fnmatch. However, unlike fnmatch, filenames starting with a
    dot are special cases that are not matched by '*' and '?'
    patterns.

    If recursive is true, the pattern '**' will match any files and
    zero or more directories and subdirectories.
    ***REMOVED***
    it = _iglob(pathname, recursive***REMOVED***
    if recursive and _isrecursive(pathname***REMOVED***:
        s = next(it***REMOVED***  # skip empty string
        assert not s
    return it


def _iglob(pathname, recursive***REMOVED***:
    dirname, basename = os.path.split(pathname***REMOVED***
    if not has_magic(pathname***REMOVED***:
        if basename:
            if os.path.lexists(pathname***REMOVED***:
                yield pathname
        else:
            # Patterns ending with a slash should match only directories
            if os.path.isdir(dirname***REMOVED***:
                yield pathname
        return
    if not dirname:
        if recursive and _isrecursive(basename***REMOVED***:
            for x in glob2(dirname, basename***REMOVED***:
                yield x
        else:
            for x in glob1(dirname, basename***REMOVED***:
                yield x
        return
    # `os.path.split(***REMOVED***` returns the argument itself as a dirname if it is a
    # drive or UNC path.  Prevent an infinite recursion if a drive or UNC path
    # contains magic characters (i.e. r'\\?\C:'***REMOVED***.
    if dirname != pathname and has_magic(dirname***REMOVED***:
        dirs = _iglob(dirname, recursive***REMOVED***
    else:
        dirs = [dirname***REMOVED***
    if has_magic(basename***REMOVED***:
        if recursive and _isrecursive(basename***REMOVED***:
            glob_in_dir = glob2
        else:
            glob_in_dir = glob1
    else:
        glob_in_dir = glob0
    for dirname in dirs:
        for name in glob_in_dir(dirname, basename***REMOVED***:
            yield os.path.join(dirname, name***REMOVED***


# These 2 helper functions non-recursively glob inside a literal directory.
# They return a list of basenames. `glob1` accepts a pattern while `glob0`
# takes a literal basename (so it only has to check for its existence***REMOVED***.


def glob1(dirname, pattern***REMOVED***:
    if not dirname:
        if isinstance(pattern, binary_type***REMOVED***:
            dirname = os.curdir.encode('ASCII'***REMOVED***
        else:
            dirname = os.curdir
    ***REMOVED***
        names = os.listdir(dirname***REMOVED***
    except OSError:
        return [***REMOVED***
    return fnmatch.filter(names, pattern***REMOVED***


def glob0(dirname, basename***REMOVED***:
    if not basename:
        # `os.path.split(***REMOVED***` returns an empty basename for paths ending with a
        # directory separator.  'q*x/' should match only directories.
        if os.path.isdir(dirname***REMOVED***:
            return [basename***REMOVED***
    else:
        if os.path.lexists(os.path.join(dirname, basename***REMOVED******REMOVED***:
            return [basename***REMOVED***
    return [***REMOVED***


# This helper function recursively yields relative pathnames inside a literal
# directory.


def glob2(dirname, pattern***REMOVED***:
    assert _isrecursive(pattern***REMOVED***
    yield pattern[:0***REMOVED***
    for x in _rlistdir(dirname***REMOVED***:
        yield x


# Recursively yields relative pathnames inside a literal directory.
def _rlistdir(dirname***REMOVED***:
    if not dirname:
        if isinstance(dirname, binary_type***REMOVED***:
            dirname = binary_type(os.curdir, 'ASCII'***REMOVED***
        else:
            dirname = os.curdir
    ***REMOVED***
        names = os.listdir(dirname***REMOVED***
    except os.error:
        return
    for x in names:
        yield x
        path = os.path.join(dirname, x***REMOVED*** if dirname else x
        for y in _rlistdir(path***REMOVED***:
            yield os.path.join(x, y***REMOVED***


magic_check = re.compile('([*?[***REMOVED******REMOVED***'***REMOVED***
magic_check_bytes = re.compile(b'([*?[***REMOVED******REMOVED***'***REMOVED***


def has_magic(s***REMOVED***:
    if isinstance(s, binary_type***REMOVED***:
        match = magic_check_bytes.search(s***REMOVED***
    else:
        match = magic_check.search(s***REMOVED***
    return match is not None


def _isrecursive(pattern***REMOVED***:
    if isinstance(pattern, binary_type***REMOVED***:
        return pattern == b'**'
    else:
        return pattern == '**'


def escape(pathname***REMOVED***:
    ***REMOVED***Escape all special characters.
    ***REMOVED***
    # Escaping is done by wrapping any of "*?[" between square brackets.
    # Metacharacters do not work in the drive part and shouldn't be escaped.
    drive, pathname = os.path.splitdrive(pathname***REMOVED***
    if isinstance(pathname, binary_type***REMOVED***:
        pathname = magic_check_bytes.sub(br'[\1***REMOVED***', pathname***REMOVED***
    else:
        pathname = magic_check.sub(r'[\1***REMOVED***', pathname***REMOVED***
    return drive + pathname
