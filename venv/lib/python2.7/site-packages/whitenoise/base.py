from email.utils import formatdate
***REMOVED***
from posixpath import normpath
from wsgiref.headers import Headers
from wsgiref.util import FileWrapper

from .media_types import MediaTypes
from .static_file import StaticFile
from .utils import (decode_if_byte_string, decode_path_info,
                    ensure_leading_trailing_slash, MissingFileError,
                    stat_regular_file***REMOVED***


class WhiteNoise(object***REMOVED***:

    # Ten years is what nginx sets a max age if you use 'expires max;'
    # so we'll follow its lead
    FOREVER = 10*365*24*60*60

    # Attributes that can be set by keyword args in the constructor
    config_attrs = ('autorefresh', 'max_age', 'allow_all_origins', 'charset',
                    'mimetypes', 'add_headers_function'***REMOVED***
    # Re-check the filesystem on every request so that any changes are
    # automatically picked up. NOTE: For use in development only, not supported
    # in production
    autorefresh = False
    max_age = 60
    # Set 'Access-Control-Allow-Orign: *' header on all files.
    # As these are all public static files this is safe (See
    # http://www.w3.org/TR/cors/#security***REMOVED*** and ensures that things (e.g
    # webfonts in Firefox***REMOVED*** still work as expected when your static files are
    # served from a CDN, rather than your primary domain.
    allow_all_origins = True
    charset = 'utf-8'
    # Custom mime types
    mimetypes = None
    # Callback for adding custom logic when setting headers
    add_headers_function = None

    def __init__(self, application, root=None, prefix=None, **kwargs***REMOVED***:
        for attr in self.config_attrs:
            ***REMOVED***
                value = kwargs.pop(attr***REMOVED***
            except KeyError:
                pass
            else:
                value = decode_if_byte_string(value***REMOVED***
                setattr(self, attr, value***REMOVED***
        if kwargs:
            raise TypeError("Unexpected keyword argument '{0***REMOVED***'".format(
                list(kwargs.keys(***REMOVED******REMOVED***[0***REMOVED******REMOVED******REMOVED***
        self.media_types = MediaTypes(extra_types=self.mimetypes***REMOVED***
        self.application = application
        self.files = {***REMOVED***
        self.directories = [***REMOVED***
        if root is not None:
            self.add_files(root, prefix***REMOVED***

    def __call__(self, environ, start_response***REMOVED***:
        path = decode_path_info(environ['PATH_INFO'***REMOVED******REMOVED***
        if self.autorefresh:
            static_file = self.find_file(path***REMOVED***
        else:
            static_file = self.files.get(path***REMOVED***
        if static_file is None:
            return self.application(environ, start_response***REMOVED***
        else:
            return self.serve(static_file, environ, start_response***REMOVED***

    def serve(self, static_file, environ, start_response***REMOVED***:
        response = static_file.get_response(environ['REQUEST_METHOD'***REMOVED***, environ***REMOVED***
        status_line = '{***REMOVED*** {***REMOVED***'.format(response.status, response.status.phrase***REMOVED***
        start_response(status_line, list(response.headers***REMOVED******REMOVED***
        if response.file is not None:
            file_wrapper = environ.get('wsgi.file_wrapper', FileWrapper***REMOVED***
            return file_wrapper(response.file***REMOVED***
        else:
            return [***REMOVED***

    def add_files(self, root, prefix=None***REMOVED***:
        root = decode_if_byte_string(root***REMOVED***
        prefix = decode_if_byte_string(prefix***REMOVED***
        prefix = ensure_leading_trailing_slash(prefix***REMOVED***
        if self.autorefresh:
            # Later calls to `add_files` overwrite earlier ones, hence we need
            # to store the list of directories in reverse order so later ones
            # match first when they're checked in "autorefresh" mode
            self.directories.insert(0, (root, prefix***REMOVED******REMOVED***
        else:
            self.update_files_dictionary(root, prefix***REMOVED***

    def update_files_dictionary(self, root, prefix***REMOVED***:
        for directory, _, filenames in os.walk(root, followlinks=True***REMOVED***:
            for filename in filenames:
                path = os.path.join(directory, filename***REMOVED***
                url = prefix + os.path.relpath(path, root***REMOVED***.replace('\\', '/'***REMOVED***
                self.files[url***REMOVED*** = self.get_static_file(path, url***REMOVED***

    def find_file(self, url***REMOVED***:
        # Don't bother checking URLs which could only ever be directories
        if not url or url[-1***REMOVED*** == '/':
            return
        # Attempt to mitigate path traversal attacks. Not sure if this is
        # sufficient, hence the warning that "autorefresh" is a development
        # only feature and not for production use
        if normpath(url***REMOVED*** != url:
            return
        for root, prefix in self.directories:
            if url.startswith(prefix***REMOVED***:
                path = os.path.join(root, url[len(prefix***REMOVED***:***REMOVED******REMOVED***
                ***REMOVED***
                    return self.get_static_file(path, url***REMOVED***
                except MissingFileError:
                    pass

    def get_static_file(self, path, url***REMOVED***:
        headers = Headers([***REMOVED******REMOVED***
        self.add_stat_headers(headers, path, url***REMOVED***
        self.add_mime_headers(headers, path, url***REMOVED***
        self.add_cache_headers(headers, path, url***REMOVED***
        self.add_cors_headers(headers, path, url***REMOVED***
        self.add_extra_headers(headers, path, url***REMOVED***
        if self.add_headers_function:
            self.add_headers_function(headers, path, url***REMOVED***
        return StaticFile(path, headers***REMOVED***

    def add_stat_headers(self, headers, path, url***REMOVED***:
        file_stat = stat_regular_file(path***REMOVED***
        headers['Last-Modified'***REMOVED*** = formatdate(file_stat.st_mtime, usegmt=True***REMOVED***
        headers['Content-Length'***REMOVED*** = str(file_stat.st_size***REMOVED***

    def add_mime_headers(self, headers, path, url***REMOVED***:
        media_type = self.media_types.get_type(path***REMOVED***
        charset = self.get_charset(media_type, path, url***REMOVED***
        params = {'charset': str(charset***REMOVED******REMOVED*** if charset else {***REMOVED***
        headers.add_header('Content-Type', str(media_type***REMOVED***, **params***REMOVED***

    def get_charset(self, media_type, path, url***REMOVED***:
        if (media_type.startswith('text/'***REMOVED*** or
                media_type == 'application/javascript'***REMOVED***:
            return self.charset

    def add_cache_headers(self, headers, path, url***REMOVED***:
        if self.is_immutable_file(path, url***REMOVED***:
            max_age = self.FOREVER
        else:
            max_age = self.max_age
        if max_age is not None:
            cache_control = 'public, max-age={0***REMOVED***'.format(max_age***REMOVED***
            headers['Cache-Control'***REMOVED*** = cache_control

    def is_immutable_file(self, path, url***REMOVED***:
        ***REMOVED***
        This should be implemented by sub-classes (see e.g. DjangoWhiteNoise***REMOVED***
        ***REMOVED***
        return False

    def add_cors_headers(self, headers, path, url***REMOVED***:
        if self.allow_all_origins:
            headers['Access-Control-Allow-Origin'***REMOVED*** = '*'

    def add_extra_headers(self, headers, path, url***REMOVED***:
        ***REMOVED***
        This is provided as a hook for sub-classes, by default a no-op
        ***REMOVED***
        pass
