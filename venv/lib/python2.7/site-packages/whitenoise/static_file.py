from collections import namedtuple
from email.utils import parsedate
***REMOVED***
    from http import HTTPStatus
except ImportError:
    from .httpstatus_backport import HTTPStatus
import re
from wsgiref.headers import Headers

from .utils import MissingFileError, stat_regular_file


Response = namedtuple('Response', ('status', 'headers', 'file'***REMOVED******REMOVED***

NOT_ALLOWED = Response(HTTPStatus.METHOD_NOT_ALLOWED,
                       (('Allow', 'GET, HEAD'***REMOVED***,***REMOVED***,
                       None***REMOVED***

ACCEPT_GZIP_RE = re.compile(r'\bgzip\b'***REMOVED***
ACCEPT_BROTLI_RE = re.compile(r'\bbr\b'***REMOVED***

# Headers which should be returned with a 304 Not Modified response as
# specified here: http://tools.ietf.org/html/rfc7232#section-4.1
NOT_MODIFIED_HEADERS = ('Cache-Control', 'Content-Location', 'Date', 'ETag',
                        'Expires', 'Vary'***REMOVED***
NOT_MODIFIED_HEADER_RE = re.compile('^({***REMOVED******REMOVED***$'.format(
        '|'.join(map(re.escape, NOT_MODIFIED_HEADERS***REMOVED******REMOVED******REMOVED***, re.IGNORECASE***REMOVED***


class StaticFile(object***REMOVED***:

    def __init__(self, path, headers***REMOVED***:
        plain_file, gzip_file, brotli_file = get_alternatives(path, headers***REMOVED***
        self.plain_file = file_tuple(plain_file***REMOVED***
        self.gzip_file = file_tuple(gzip_file***REMOVED***
        self.brotli_file = file_tuple(brotli_file***REMOVED***
        self.last_modified = parsedate(headers['Last-Modified'***REMOVED******REMOVED***
        self.not_modified_response = get_not_modified_response(self.plain_file[1***REMOVED******REMOVED***

    def get_response(self, method, request_headers***REMOVED***:
        if method != 'GET' and method != 'HEAD':
            return NOT_ALLOWED
        elif self.file_not_modified(request_headers***REMOVED***:
            return self.not_modified_response
        path, headers = self.get_path_and_headers(request_headers***REMOVED***
        if method != 'HEAD':
            file_handle = open(path, 'rb'***REMOVED***
        else:
            file_handle = None
        return Response(HTTPStatus.OK, headers, file_handle***REMOVED***

    def get_path_and_headers(self, request_headers***REMOVED***:
        accept_encoding = request_headers.get('HTTP_ACCEPT_ENCODING', ''***REMOVED***
        if self.brotli_file and ACCEPT_BROTLI_RE.search(accept_encoding***REMOVED***:
            return self.brotli_file
        if self.gzip_file and ACCEPT_GZIP_RE.search(accept_encoding***REMOVED***:
            return self.gzip_file
        return self.plain_file

    def file_not_modified(self, request_headers***REMOVED***:
        ***REMOVED***
            last_requested = request_headers['HTTP_IF_MODIFIED_SINCE'***REMOVED***
        except KeyError:
            return False
        return parsedate(last_requested***REMOVED*** >= self.last_modified


def get_alternatives(path, headers***REMOVED***:
    gzip_file = get_alternative_encoding(path, headers, '.gz', 'gzip'***REMOVED***
    brotli_file = get_alternative_encoding(path, headers, '.br', 'br'***REMOVED***
    if gzip_file or brotli_file:
        headers['Vary'***REMOVED*** = 'Accept-Encoding'
    plain_file = (path, headers***REMOVED***
    return plain_file, gzip_file, brotli_file


def get_alternative_encoding(path, headers, suffix, encoding***REMOVED***:
    alt_path = path + suffix
    ***REMOVED***
        alt_size = stat_regular_file(alt_path***REMOVED***.st_size
    except MissingFileError:
        return None
    alt_headers = Headers(headers.items(***REMOVED******REMOVED***
    alt_headers['Vary'***REMOVED*** = 'Accept-Encoding'
    alt_headers['Content-Encoding'***REMOVED*** = encoding
    alt_headers['Content-Length'***REMOVED*** = str(alt_size***REMOVED***
    return alt_path, alt_headers


def file_tuple(path_and_headers***REMOVED***:
    if path_and_headers is None:
        return None
    else:
        path, headers = path_and_headers
        return path, tuple(headers.items(***REMOVED******REMOVED***


def get_not_modified_response(headers***REMOVED***:
    not_modified_headers = tuple([
        item for item in headers
        if NOT_MODIFIED_HEADER_RE.match(item[0***REMOVED******REMOVED******REMOVED******REMOVED***
    return Response(HTTPStatus.NOT_MODIFIED,  not_modified_headers, None***REMOVED***
