from __future__ import print_function, division, unicode_literals

import gzip
***REMOVED***
import re
***REMOVED***
    from io import BytesIO
except ImportError:
    from cStringIO import StringIO as BytesIO

***REMOVED***
    import brotli
    brotli_installed = True
except ImportError:
    brotli_installed = False


class Compressor(object***REMOVED***:

    # Extensions that it's not worth trying to compress
    SKIP_COMPRESS_EXTENSIONS = (
        # Images
        'jpg', 'jpeg', 'png', 'gif', 'webp',
        # Compressed files
        'zip', 'gz', 'tgz', 'bz2', 'tbz',
        # Flash
        'swf', 'flv',
        # Fonts
        'woff', 'woff2'***REMOVED***

    def __init__(self, extensions=None, use_gzip=True, use_brotli=True,
                 log=print, quiet=False***REMOVED***:
        if extensions is None:
            extensions = self.SKIP_COMPRESS_EXTENSIONS
        self.extension_re = self.get_extension_re(extensions***REMOVED***
        self.use_gzip = use_gzip
        self.use_brotli = use_brotli and brotli_installed
        if not quiet:
            self.log = log

    @staticmethod
    def get_extension_re(extensions***REMOVED***:
        if not extensions:
            return re.compile('^$'***REMOVED***
        else:
            return re.compile(
                r'\.({0***REMOVED******REMOVED***$'.format('|'.join(map(re.escape, extensions***REMOVED******REMOVED******REMOVED***,
                re.IGNORECASE***REMOVED***

    def should_compress(self, filename***REMOVED***:
        return not self.extension_re.search(filename***REMOVED***

    def log(self, message***REMOVED***:
        pass

    def compress(self, path***REMOVED***:
        with open(path, 'rb'***REMOVED*** as f:
            data = f.read(***REMOVED***
        size = len(data***REMOVED***
        if self.use_brotli:
            compressed = self.compress_brotli(data***REMOVED***
            success = self.write_data(compressed, size, path, '.br', 'Brotli'***REMOVED***
            # If Brotli compression wasn't effective gzip won't be either
            if not success:
                return
        if self.use_gzip:
            compressed = self.compress_gzip(data***REMOVED***
            self.write_data(compressed, size, path, '.gz', 'Gzip'***REMOVED***

    @staticmethod
    def compress_gzip(data***REMOVED***:
        output = BytesIO(***REMOVED***
        # Explicitly set mtime to 0 so gzip content is fully determined
        # by file content (0 = "no timestamp" according to gzip spec***REMOVED***
        with gzip.GzipFile(filename='', mode='wb', fileobj=output,
                           compresslevel=9, mtime=0***REMOVED*** as gz_file:
            gz_file.write(data***REMOVED***
        return output.getvalue(***REMOVED***

    @staticmethod
    def compress_brotli(data***REMOVED***:
        return brotli.compress(data***REMOVED***

    def write_data(self, data, orig_size, path, suffix, compression***REMOVED***:
        compressed_size = len(data***REMOVED***
        if not self.compressed_effectively(orig_size, compressed_size***REMOVED***:
            self.log('Skipping {0***REMOVED*** ({1***REMOVED*** compression not effective***REMOVED***'.format(
                     path, compression***REMOVED******REMOVED***
            return False
        else:
            self.log('{0***REMOVED*** compressed {1***REMOVED*** ({2***REMOVED***K -> {3***REMOVED***K***REMOVED***'.format(
                    compression, path, orig_size // 1024,
                    compressed_size // 1024***REMOVED******REMOVED***
            with open(path + suffix, 'wb'***REMOVED*** as f:
                f.write(data***REMOVED***
            return True

    @staticmethod
    def compressed_effectively(orig_size, compressed_size***REMOVED***:
        if orig_size == 0:
            return False
        ratio = compressed_size / orig_size
        return ratio <= 0.95


def main(root, **kwargs***REMOVED***:
    compressor = Compressor(**kwargs***REMOVED***
    for dirpath, dirs, files in os.walk(root***REMOVED***:
        for filename in files:
            if compressor.should_compress(filename***REMOVED***:
                path = os.path.join(dirpath, filename***REMOVED***
                compressor.compress(path***REMOVED***


if __name__ == '__main__':
    import argparse
    parser = argparse.ArgumentParser(
            description="Search for all files inside <root> *not* matching "
                        "<extensions> and produce compressed versions with "
                        "'.gz' and '.br' suffixes (as long as this results in a "
                        "smaller file***REMOVED***"***REMOVED***
    parser.add_argument('-q', '--quiet', help="Don't produce log output",
                        action='store_true'***REMOVED***
    parser.add_argument('--no-gzip', help="Don't produce gzip '.gz' files",
                        action='store_false', dest='use_gzip'***REMOVED***
    parser.add_argument('--no-brotli', help="Don't produce brotli '.br' files",
                        action='store_false', dest='use_brotli'***REMOVED***
    parser.add_argument('root', help='Path root from which to search for files'***REMOVED***
    parser.add_argument('extensions',
                        nargs='*',
                        help='File extensions to exclude from compression '
                             '(default: {***REMOVED******REMOVED***'.format(', '.join(
                                 Compressor.SKIP_COMPRESS_EXTENSIONS***REMOVED******REMOVED***,
                        default=Compressor.SKIP_COMPRESS_EXTENSIONS***REMOVED***
    args = parser.parse_args(***REMOVED***
    main(**vars(args***REMOVED******REMOVED***
