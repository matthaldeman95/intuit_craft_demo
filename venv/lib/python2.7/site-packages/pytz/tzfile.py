#!/usr/bin/env python
'''
$Id: tzfile.py,v 1.8 2004/06/03 00:15:24 zenzen Exp $
'''

***REMOVED***
    from cStringIO import StringIO
except ImportError:
    from io import StringIO
from datetime import datetime, timedelta
from struct import unpack, calcsize

from pytz.tzinfo import StaticTzInfo, DstTzInfo, memorized_ttinfo
from pytz.tzinfo import memorized_datetime, memorized_timedelta

def _byte_string(s***REMOVED***:
    ***REMOVED***Cast a string or byte string to an ASCII byte string.***REMOVED***
    return s.encode('ASCII'***REMOVED***

_NULL = _byte_string('\0'***REMOVED***

def _std_string(s***REMOVED***:
    ***REMOVED***Cast a string or byte string to an ASCII string.***REMOVED***
    return str(s.decode('ASCII'***REMOVED******REMOVED***

def build_tzinfo(zone, fp***REMOVED***:
    head_fmt = '>4s c 15x 6l'
    head_size = calcsize(head_fmt***REMOVED***
    (magic, format, ttisgmtcnt, ttisstdcnt,leapcnt, timecnt,
        typecnt, charcnt***REMOVED*** =  unpack(head_fmt, fp.read(head_size***REMOVED******REMOVED***

    # Make sure it is a tzfile(5***REMOVED*** file
    assert magic == _byte_string('TZif'***REMOVED***, 'Got magic %s' % repr(magic***REMOVED***

    # Read out the transition times, localtime indices and ttinfo structures.
    data_fmt = '>%(timecnt***REMOVED***dl %(timecnt***REMOVED***dB %(ttinfo***REMOVED***s %(charcnt***REMOVED***ds' % dict(
        timecnt=timecnt, ttinfo='lBB'*typecnt, charcnt=charcnt***REMOVED***
    data_size = calcsize(data_fmt***REMOVED***
    data = unpack(data_fmt, fp.read(data_size***REMOVED******REMOVED***

    # make sure we unpacked the right number of values
    assert len(data***REMOVED*** == 2 * timecnt + 3 * typecnt + 1
    transitions = [memorized_datetime(trans***REMOVED***
                   for trans in data[:timecnt***REMOVED******REMOVED***
    lindexes = list(data[timecnt:2 * timecnt***REMOVED******REMOVED***
    ttinfo_raw = data[2 * timecnt:-1***REMOVED***
    tznames_raw = data[-1***REMOVED***
    del data

    # Process ttinfo into separate structs
    ttinfo = [***REMOVED***
    tznames = {***REMOVED***
    i = 0
    while i < len(ttinfo_raw***REMOVED***:
        # have we looked up this timezone name yet?
        tzname_offset = ttinfo_raw[i+2***REMOVED***
        if tzname_offset not in tznames:
            nul = tznames_raw.find(_NULL, tzname_offset***REMOVED***
            if nul < 0:
                nul = len(tznames_raw***REMOVED***
            tznames[tzname_offset***REMOVED*** = _std_string(
                tznames_raw[tzname_offset:nul***REMOVED******REMOVED***
        ttinfo.append((ttinfo_raw[i***REMOVED***,
                       bool(ttinfo_raw[i+1***REMOVED******REMOVED***,
                       tznames[tzname_offset***REMOVED******REMOVED******REMOVED***
        i += 3

    # Now build the timezone object
    if len(ttinfo***REMOVED*** ==1 or len(transitions***REMOVED*** == 0:
        ttinfo[0***REMOVED***[0***REMOVED***, ttinfo[0***REMOVED***[2***REMOVED***
        cls = type(zone, (StaticTzInfo,***REMOVED***, dict(
            zone=zone,
            _utcoffset=memorized_timedelta(ttinfo[0***REMOVED***[0***REMOVED******REMOVED***,
            _tzname=ttinfo[0***REMOVED***[2***REMOVED******REMOVED******REMOVED***
    else:
        # Early dates use the first standard time ttinfo
        i = 0
        while ttinfo[i***REMOVED***[1***REMOVED***:
            i += 1
        if ttinfo[i***REMOVED*** == ttinfo[lindexes[0***REMOVED******REMOVED***:
            transitions[0***REMOVED*** = datetime.min
        else:
            transitions.insert(0, datetime.min***REMOVED***
            lindexes.insert(0, i***REMOVED***

        # calculate transition info
        transition_info = [***REMOVED***
        for i in range(len(transitions***REMOVED******REMOVED***:
            inf = ttinfo[lindexes[i***REMOVED******REMOVED***
            utcoffset = inf[0***REMOVED***
            if not inf[1***REMOVED***:
                dst = 0
            else:
                for j in range(i-1, -1, -1***REMOVED***:
                    prev_inf = ttinfo[lindexes[j***REMOVED******REMOVED***
                    if not prev_inf[1***REMOVED***:
                        break
                dst = inf[0***REMOVED*** - prev_inf[0***REMOVED*** # dst offset

                # Bad dst? Look further. DST > 24 hours happens when
                # a timzone has moved across the international dateline.
                if dst <= 0 or dst > 3600*3:
                    for j in range(i+1, len(transitions***REMOVED******REMOVED***:
                        stdinf = ttinfo[lindexes[j***REMOVED******REMOVED***
                        if not stdinf[1***REMOVED***:
                            dst = inf[0***REMOVED*** - stdinf[0***REMOVED***
                            if dst > 0:
                                break # Found a useful std time.

            tzname = inf[2***REMOVED***

            # Round utcoffset and dst to the nearest minute or the
            # datetime library will complain. Conversions to these timezones
            # might be up to plus or minus 30 seconds out, but it is
            # the best we can do.
            utcoffset = int((utcoffset + 30***REMOVED*** // 60***REMOVED*** * 60
            dst = int((dst + 30***REMOVED*** // 60***REMOVED*** * 60
            transition_info.append(memorized_ttinfo(utcoffset, dst, tzname***REMOVED******REMOVED***

        cls = type(zone, (DstTzInfo,***REMOVED***, dict(
            zone=zone,
            _utc_transition_times=transitions,
            _transition_info=transition_info***REMOVED******REMOVED***

    return cls(***REMOVED***

if __name__ == '__main__':
    ***REMOVED***.path
    from pprint import pprint
    base = os.path.join(os.path.dirname(__file__***REMOVED***, 'zoneinfo'***REMOVED***
    tz = build_tzinfo('Australia/Melbourne',
                      open(os.path.join(base,'Australia','Melbourne'***REMOVED***, 'rb'***REMOVED******REMOVED***
    tz = build_tzinfo('US/Eastern',
                      open(os.path.join(base,'US','Eastern'***REMOVED***, 'rb'***REMOVED******REMOVED***
    pprint(tz._utc_transition_times***REMOVED***
    #print tz.asPython(4***REMOVED***
    #print tz.transitions_mapping
