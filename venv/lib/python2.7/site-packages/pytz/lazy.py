from threading import RLock
***REMOVED***
    from UserDict import DictMixin
except ImportError:
    from collections import Mapping as DictMixin


# With lazy loading, we might end up with multiple threads triggering
# it at the same time. We need a lock.
_fill_lock = RLock(***REMOVED***


class LazyDict(DictMixin***REMOVED***:
    ***REMOVED***Dictionary populated on first use.***REMOVED***
    data = None
    def __getitem__(self, key***REMOVED***:
        if self.data is None:
            _fill_lock.acquire(***REMOVED***
            ***REMOVED***
                if self.data is None:
                    self._fill(***REMOVED***
            finally:
                _fill_lock.release(***REMOVED***
        return self.data[key.upper(***REMOVED******REMOVED***

    def __contains__(self, key***REMOVED***:
        if self.data is None:
            _fill_lock.acquire(***REMOVED***
            ***REMOVED***
                if self.data is None:
                    self._fill(***REMOVED***
            finally:
                _fill_lock.release(***REMOVED***
        return key in self.data

    def __iter__(self***REMOVED***:
        if self.data is None:
            _fill_lock.acquire(***REMOVED***
            ***REMOVED***
                if self.data is None:
                    self._fill(***REMOVED***
            finally:
                _fill_lock.release(***REMOVED***
        return iter(self.data***REMOVED***

    def __len__(self***REMOVED***:
        if self.data is None:
            _fill_lock.acquire(***REMOVED***
            ***REMOVED***
                if self.data is None:
                    self._fill(***REMOVED***
            finally:
                _fill_lock.release(***REMOVED***
        return len(self.data***REMOVED***

    def keys(self***REMOVED***:
        if self.data is None:
            _fill_lock.acquire(***REMOVED***
            ***REMOVED***
                if self.data is None:
                    self._fill(***REMOVED***
            finally:
                _fill_lock.release(***REMOVED***
        return self.data.keys(***REMOVED***


class LazyList(list***REMOVED***:
    ***REMOVED***List populated on first use.***REMOVED***

    _props = [
        '__str__', '__repr__', '__unicode__',
        '__hash__', '__sizeof__', '__cmp__',
        '__lt__', '__le__', '__eq__', '__ne__', '__gt__', '__ge__',
        'append', 'count', 'index', 'extend', 'insert', 'pop', 'remove',
        'reverse', 'sort', '__add__', '__radd__', '__iadd__', '__mul__',
        '__rmul__', '__imul__', '__contains__', '__len__', '__nonzero__',
        '__getitem__', '__setitem__', '__delitem__', '__iter__',
        '__reversed__', '__getslice__', '__setslice__', '__delslice__'***REMOVED***

    def __new__(cls, fill_iter=None***REMOVED***:

        if fill_iter is None:
            return list(***REMOVED***

        # We need a new class as we will be dynamically messing with its
        # methods.
        class LazyList(list***REMOVED***:
            pass

        fill_iter = [fill_iter***REMOVED***

        def lazy(name***REMOVED***:
            def _lazy(self, *args, **kw***REMOVED***:
                _fill_lock.acquire(***REMOVED***
                ***REMOVED***
                    if len(fill_iter***REMOVED*** > 0:
                        list.extend(self, fill_iter.pop(***REMOVED******REMOVED***
                        for method_name in cls._props:
                            delattr(LazyList, method_name***REMOVED***
                finally:
                    _fill_lock.release(***REMOVED***
                return getattr(list, name***REMOVED***(self, *args, **kw***REMOVED***
            return _lazy

        for name in cls._props:
            setattr(LazyList, name, lazy(name***REMOVED******REMOVED***

        new_list = LazyList(***REMOVED***
        return new_list

# Not all versions of Python declare the same magic methods.
# Filter out properties that don't exist in this version of Python
# from the list.
LazyList._props = [prop for prop in LazyList._props if hasattr(list, prop***REMOVED******REMOVED***


class LazySet(set***REMOVED***:
    ***REMOVED***Set populated on first use.***REMOVED***

    _props = (
        '__str__', '__repr__', '__unicode__',
        '__hash__', '__sizeof__', '__cmp__',
        '__lt__', '__le__', '__eq__', '__ne__', '__gt__', '__ge__',
        '__contains__', '__len__', '__nonzero__',
        '__getitem__', '__setitem__', '__delitem__', '__iter__',
        '__sub__', '__and__', '__xor__', '__or__',
        '__rsub__', '__rand__', '__rxor__', '__ror__',
        '__isub__', '__iand__', '__ixor__', '__ior__',
        'add', 'clear', 'copy', 'difference', 'difference_update',
        'discard', 'intersection', 'intersection_update', 'isdisjoint',
        'issubset', 'issuperset', 'pop', 'remove',
        'symmetric_difference', 'symmetric_difference_update',
        'union', 'update'***REMOVED***

    def __new__(cls, fill_iter=None***REMOVED***:

        if fill_iter is None:
            return set(***REMOVED***

        class LazySet(set***REMOVED***:
            pass

        fill_iter = [fill_iter***REMOVED***

        def lazy(name***REMOVED***:
            def _lazy(self, *args, **kw***REMOVED***:
                _fill_lock.acquire(***REMOVED***
                ***REMOVED***
                    if len(fill_iter***REMOVED*** > 0:
                        for i in fill_iter.pop(***REMOVED***:
                            set.add(self, i***REMOVED***
                        for method_name in cls._props:
                            delattr(LazySet, method_name***REMOVED***
                finally:
                    _fill_lock.release(***REMOVED***
                return getattr(set, name***REMOVED***(self, *args, **kw***REMOVED***
            return _lazy

        for name in cls._props:
            setattr(LazySet, name, lazy(name***REMOVED******REMOVED***

        new_set = LazySet(***REMOVED***
        return new_set

# Not all versions of Python declare the same magic methods.
# Filter out properties that don't exist in this version of Python
# from the list.
LazySet._props = [prop for prop in LazySet._props if hasattr(set, prop***REMOVED******REMOVED***
