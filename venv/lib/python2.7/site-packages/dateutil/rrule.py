# -*- coding: utf-8 -*-
***REMOVED***
The rrule module offers a small, complete, and very fast, implementation of
the recurrence rules documented in the
`iCalendar RFC <http://www.ietf.org/rfc/rfc2445.txt>`_,
including support for caching of results.
***REMOVED***
import itertools
import datetime
import calendar
import sys

***REMOVED***
    from math import gcd
except ImportError:
    from fractions import gcd

from six import advance_iterator, integer_types
from six.moves import _thread
import heapq

# For warning about deprecation of until and count
from warnings import warn

__all__ = ["rrule", "rruleset", "rrulestr",
           "YEARLY", "MONTHLY", "WEEKLY", "DAILY",
           "HOURLY", "MINUTELY", "SECONDLY",
           "MO", "TU", "WE", "TH", "FR", "SA", "SU"***REMOVED***

# Every mask is 7 days longer to handle cross-year weekly periods.
M366MASK = tuple([1***REMOVED****31+[2***REMOVED****29+[3***REMOVED****31+[4***REMOVED****30+[5***REMOVED****31+[6***REMOVED****30 +
                 [7***REMOVED****31+[8***REMOVED****31+[9***REMOVED****30+[10***REMOVED****31+[11***REMOVED****30+[12***REMOVED****31+[1***REMOVED****7***REMOVED***
M365MASK = list(M366MASK***REMOVED***
M29, M30, M31 = list(range(1, 30***REMOVED******REMOVED***, list(range(1, 31***REMOVED******REMOVED***, list(range(1, 32***REMOVED******REMOVED***
MDAY366MASK = tuple(M31+M29+M31+M30+M31+M30+M31+M31+M30+M31+M30+M31+M31[:7***REMOVED******REMOVED***
MDAY365MASK = list(MDAY366MASK***REMOVED***
M29, M30, M31 = list(range(-29, 0***REMOVED******REMOVED***, list(range(-30, 0***REMOVED******REMOVED***, list(range(-31, 0***REMOVED******REMOVED***
NMDAY366MASK = tuple(M31+M29+M31+M30+M31+M30+M31+M31+M30+M31+M30+M31+M31[:7***REMOVED******REMOVED***
NMDAY365MASK = list(NMDAY366MASK***REMOVED***
M366RANGE = (0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366***REMOVED***
M365RANGE = (0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365***REMOVED***
WDAYMASK = [0, 1, 2, 3, 4, 5, 6***REMOVED****55
del M29, M30, M31, M365MASK[59***REMOVED***, MDAY365MASK[59***REMOVED***, NMDAY365MASK[31***REMOVED***
MDAY365MASK = tuple(MDAY365MASK***REMOVED***
M365MASK = tuple(M365MASK***REMOVED***

FREQNAMES = ['YEARLY','MONTHLY','WEEKLY','DAILY','HOURLY','MINUTELY','SECONDLY'***REMOVED***

(YEARLY,
 MONTHLY,
 WEEKLY,
 DAILY,
 HOURLY,
 MINUTELY,
 SECONDLY***REMOVED*** = list(range(7***REMOVED******REMOVED***

# Imported on demand.
easter = None
parser = None


class weekday(object***REMOVED***:
    __slots__ = ["weekday", "n"***REMOVED***

    def __init__(self, weekday, n=None***REMOVED***:
        if n == 0:
            raise ValueError("Can't create weekday with n == 0"***REMOVED***

        self.weekday = weekday
        self.n = n

    def __call__(self, n***REMOVED***:
        if n == self.n:
            return self
        else:
            return self.__class__(self.weekday, n***REMOVED***

    def __eq__(self, other***REMOVED***:
        ***REMOVED***
            if self.weekday != other.weekday or self.n != other.n:
                return False
        except AttributeError:
            return False
        return True

    def __repr__(self***REMOVED***:
        s = ("MO", "TU", "WE", "TH", "FR", "SA", "SU"***REMOVED***[self.weekday***REMOVED***
        if not self.n:
            return s
        else:
            return "%s(%+d***REMOVED***" % (s, self.n***REMOVED***

MO, TU, WE, TH, FR, SA, SU = weekdays = tuple([weekday(x***REMOVED*** for x in range(7***REMOVED******REMOVED******REMOVED***


def _invalidates_cache(f***REMOVED***:
    ***REMOVED***
    Decorator for rruleset methods which may invalidate the
    cached length.
    ***REMOVED***
    def inner_func(self, *args, **kwargs***REMOVED***:
        rv = f(self, *args, **kwargs***REMOVED***
        self._invalidate_cache(***REMOVED***
        return rv

    return inner_func


class rrulebase(object***REMOVED***:
    def __init__(self, cache=False***REMOVED***:
        if cache:
            self._cache = [***REMOVED***
            self._cache_lock = _thread.allocate_lock(***REMOVED***
            self._invalidate_cache(***REMOVED***
        else:
            self._cache = None
            self._cache_complete = False
            self._len = None

    def __iter__(self***REMOVED***:
        if self._cache_complete:
            return iter(self._cache***REMOVED***
        elif self._cache is None:
            return self._iter(***REMOVED***
        else:
            return self._iter_cached(***REMOVED***

    def _invalidate_cache(self***REMOVED***:
        if self._cache is not None:
            self._cache = [***REMOVED***
            self._cache_complete = False
            self._cache_gen = self._iter(***REMOVED***

            if self._cache_lock.locked(***REMOVED***:
                self._cache_lock.release(***REMOVED***

        self._len = None

    def _iter_cached(self***REMOVED***:
        i = 0
        gen = self._cache_gen
        cache = self._cache
        acquire = self._cache_lock.acquire
        release = self._cache_lock.release
        while gen:
            if i == len(cache***REMOVED***:
                acquire(***REMOVED***
                if self._cache_complete:
                    break
                ***REMOVED***
                    for j in range(10***REMOVED***:
                        cache.append(advance_iterator(gen***REMOVED******REMOVED***
                except StopIteration:
                    self._cache_gen = gen = None
                    self._cache_complete = True
                    break
                release(***REMOVED***
            yield cache[i***REMOVED***
            i += 1
        while i < self._len:
            yield cache[i***REMOVED***
            i += 1

    def __getitem__(self, item***REMOVED***:
        if self._cache_complete:
            return self._cache[item***REMOVED***
        elif isinstance(item, slice***REMOVED***:
            if item.step and item.step < 0:
                return list(iter(self***REMOVED******REMOVED***[item***REMOVED***
            else:
                return list(itertools.islice(self,
                                             item.start or 0,
                                             item.stop or sys.maxsize,
                                             item.step or 1***REMOVED******REMOVED***
        elif item >= 0:
            gen = iter(self***REMOVED***
            ***REMOVED***
                for i in range(item+1***REMOVED***:
                    res = advance_iterator(gen***REMOVED***
            except StopIteration:
                raise IndexError
            return res
        else:
            return list(iter(self***REMOVED******REMOVED***[item***REMOVED***

    def __contains__(self, item***REMOVED***:
        if self._cache_complete:
            return item in self._cache
        else:
            for i in self:
                if i == item:
                    return True
                elif i > item:
                    return False
        return False

    # __len__(***REMOVED*** introduces a large performance penality.
    def count(self***REMOVED***:
        ***REMOVED*** Returns the number of recurrences in this set. It will have go
            trough the whole recurrence, if this hasn't been done before. ***REMOVED***
        if self._len is None:
            for x in self:
                pass
        return self._len

    def before(self, dt, inc=False***REMOVED***:
        ***REMOVED*** Returns the last recurrence before the given datetime instance. The
            inc keyword defines what happens if dt is an occurrence. With
            inc=True, if dt itself is an occurrence, it will be returned. ***REMOVED***
        if self._cache_complete:
            gen = self._cache
        else:
            gen = self
        last = None
        if inc:
            for i in gen:
                if i > dt:
                    break
                last = i
        else:
            for i in gen:
                if i >= dt:
                    break
                last = i
        return last

    def after(self, dt, inc=False***REMOVED***:
        ***REMOVED*** Returns the first recurrence after the given datetime instance. The
            inc keyword defines what happens if dt is an occurrence. With
            inc=True, if dt itself is an occurrence, it will be returned.  ***REMOVED***
        if self._cache_complete:
            gen = self._cache
        else:
            gen = self
        if inc:
            for i in gen:
                if i >= dt:
                    return i
        else:
            for i in gen:
                if i > dt:
                    return i
        return None

    def xafter(self, dt, count=None, inc=False***REMOVED***:
        ***REMOVED***
        Generator which yields up to `count` recurrences after the given
        datetime instance, equivalent to `after`.

        :param dt:
            The datetime at which to start generating recurrences.

        :param count:
            The maximum number of recurrences to generate. If `None` (default***REMOVED***,
            dates are generated until the recurrence rule is exhausted.

        :param inc:
            If `dt` is an instance of the rule and `inc` is `True`, it is
            included in the output.

        :yields: Yields a sequence of `datetime` objects.
        ***REMOVED***

        if self._cache_complete:
            gen = self._cache
        else:
            gen = self

        # Select the comparison function
        if inc:
            comp = lambda dc, dtc: dc >= dtc
        else:
            comp = lambda dc, dtc: dc > dtc

        # Generate dates
        n = 0
        for d in gen:
            if comp(d, dt***REMOVED***:
                yield d

                if count is not None:
                    n += 1
                    if n >= count:
                        break

    def between(self, after, before, inc=False, count=1***REMOVED***:
        ***REMOVED*** Returns all the occurrences of the rrule between after and before.
        The inc keyword defines what happens if after and/or before are
        themselves occurrences. With inc=True, they will be included in the
        list, if they are found in the recurrence set. ***REMOVED***
        if self._cache_complete:
            gen = self._cache
        else:
            gen = self
        started = False
        l = [***REMOVED***
        if inc:
            for i in gen:
                if i > before:
                    break
                elif not started:
                    if i >= after:
                        started = True
                        l.append(i***REMOVED***
                else:
                    l.append(i***REMOVED***
        else:
            for i in gen:
                if i >= before:
                    break
                elif not started:
                    if i > after:
                        started = True
                        l.append(i***REMOVED***
                else:
                    l.append(i***REMOVED***
        return l


class rrule(rrulebase***REMOVED***:
    ***REMOVED***
    That's the base of the rrule operation. It accepts all the keywords
    defined in the RFC as its constructor parameters (except byday,
    which was renamed to byweekday***REMOVED*** and more. The constructor prototype is::

            rrule(freq***REMOVED***

    Where freq must be one of YEARLY, MONTHLY, WEEKLY, DAILY, HOURLY, MINUTELY,
    or SECONDLY.

    .. note::
        Per RFC section 3.3.10, recurrence instances falling on invalid dates
        and times are ignored rather than coerced:

            Recurrence rules may generate recurrence instances with an invalid
            date (e.g., February 30***REMOVED*** or nonexistent local time (e.g., 1:30 AM
            on a day where the local time is moved forward by an hour at 1:00
            AM***REMOVED***.  Such recurrence instances MUST be ignored and MUST NOT be
            counted as part of the recurrence set.

        This can lead to possibly surprising behavior when, for example, the
        start date occurs at the end of the month:

        >>> from dateutil.rrule import rrule, MONTHLY
        >>> from datetime import datetime
        >>> start_date = datetime(2014, 12, 31***REMOVED***
        >>> list(rrule(freq=MONTHLY, count=4, dtstart=start_date***REMOVED******REMOVED***
        ... # doctest: +NORMALIZE_WHITESPACE
        [datetime.datetime(2014, 12, 31, 0, 0***REMOVED***,
         datetime.datetime(2015, 1, 31, 0, 0***REMOVED***,
         datetime.datetime(2015, 3, 31, 0, 0***REMOVED***,
         datetime.datetime(2015, 5, 31, 0, 0***REMOVED******REMOVED***

    Additionally, it supports the following keyword arguments:

    :param cache:
        If given, it must be a boolean value specifying to enable or disable
        caching of results. If you will use the same rrule instance multiple
        times, enabling caching will improve the performance considerably.
    :param dtstart:
        The recurrence start. Besides being the base for the recurrence,
        missing parameters in the final recurrence instances will also be
        extracted from this date. If not given, datetime.now(***REMOVED*** will be used
        instead.
    :param interval:
        The interval between each freq iteration. For example, when using
        YEARLY, an interval of 2 means once every two years, but with HOURLY,
        it means once every two hours. The default interval is 1.
    :param wkst:
        The week start day. Must be one of the MO, TU, WE constants, or an
        integer, specifying the first day of the week. This will affect
        recurrences based on weekly periods. The default week start is got
        from calendar.firstweekday(***REMOVED***, and may be modified by
        calendar.setfirstweekday(***REMOVED***.
    :param count:
        How many occurrences will be generated.

        .. note::
            As of version 2.5.0, the use of the ``until`` keyword together
            with the ``count`` keyword is deprecated per RFC-2445 Sec. 4.3.10.
    :param until:
        If given, this must be a datetime instance, that will specify the
        limit of the recurrence. The last recurrence in the rule is the greatest
        datetime that is less than or equal to the value specified in the
        ``until`` parameter.
        
        .. note::
            As of version 2.5.0, the use of the ``until`` keyword together
            with the ``count`` keyword is deprecated per RFC-2445 Sec. 4.3.10.
    :param bysetpos:
        If given, it must be either an integer, or a sequence of integers,
        positive or negative. Each given integer will specify an occurrence
        number, corresponding to the nth occurrence of the rule inside the
        frequency period. For example, a bysetpos of -1 if combined with a
        MONTHLY frequency, and a byweekday of (MO, TU, WE, TH, FR***REMOVED***, will
        result in the last work day of every month.
    :param bymonth:
        If given, it must be either an integer, or a sequence of integers,
        meaning the months to apply the recurrence to.
    :param bymonthday:
        If given, it must be either an integer, or a sequence of integers,
        meaning the month days to apply the recurrence to.
    :param byyearday:
        If given, it must be either an integer, or a sequence of integers,
        meaning the year days to apply the recurrence to.
    :param byweekno:
        If given, it must be either an integer, or a sequence of integers,
        meaning the week numbers to apply the recurrence to. Week numbers
        have the meaning described in ISO8601, that is, the first week of
        the year is that containing at least four days of the new year.
    :param byweekday:
        If given, it must be either an integer (0 == MO***REMOVED***, a sequence of
        integers, one of the weekday constants (MO, TU, etc***REMOVED***, or a sequence
        of these constants. When given, these variables will define the
        weekdays where the recurrence will be applied. It's also possible to
        use an argument n for the weekday instances, which will mean the nth
        occurrence of this weekday in the period. For example, with MONTHLY,
        or with YEARLY and BYMONTH, using FR(+1***REMOVED*** in byweekday will specify the
        first friday of the month where the recurrence happens. Notice that in
        the RFC documentation, this is specified as BYDAY, but was renamed to
        avoid the ambiguity of that keyword.
    :param byhour:
        If given, it must be either an integer, or a sequence of integers,
        meaning the hours to apply the recurrence to.
    :param byminute:
        If given, it must be either an integer, or a sequence of integers,
        meaning the minutes to apply the recurrence to.
    :param bysecond:
        If given, it must be either an integer, or a sequence of integers,
        meaning the seconds to apply the recurrence to.
    :param byeaster:
        If given, it must be either an integer, or a sequence of integers,
        positive or negative. Each integer will define an offset from the
        Easter Sunday. Passing the offset 0 to byeaster will yield the Easter
        Sunday itself. This is an extension to the RFC specification.
     ***REMOVED***
    def __init__(self, freq, dtstart=None,
                 interval=1, wkst=None, count=None, until=None, bysetpos=None,
                 bymonth=None, bymonthday=None, byyearday=None, byeaster=None,
                 byweekno=None, byweekday=None,
                 byhour=None, byminute=None, bysecond=None,
                 cache=False***REMOVED***:
        super(rrule, self***REMOVED***.__init__(cache***REMOVED***
        global easter
        if not dtstart:
            dtstart = datetime.datetime.now(***REMOVED***.replace(microsecond=0***REMOVED***
        elif not isinstance(dtstart, datetime.datetime***REMOVED***:
            dtstart = datetime.datetime.fromordinal(dtstart.toordinal(***REMOVED******REMOVED***
        else:
            dtstart = dtstart.replace(microsecond=0***REMOVED***
        self._dtstart = dtstart
        self._tzinfo = dtstart.tzinfo
        self._freq = freq
        self._interval = interval
        self._count = count

        # Cache the original byxxx rules, if they are provided, as the _byxxx
        # attributes do not necessarily map to the inputs, and this can be
        # a problem in generating the strings. Only store things if they've
        # been supplied (the string retrieval will just use .get(***REMOVED******REMOVED***
        self._original_rule = {***REMOVED***

        if until and not isinstance(until, datetime.datetime***REMOVED***:
            until = datetime.datetime.fromordinal(until.toordinal(***REMOVED******REMOVED***
        self._until = until

        if count and until:
            warn("Using both 'count' and 'until' is inconsistent with RFC 2445"
                 " and has been deprecated in dateutil. Future versions will "
                 "raise an error.", DeprecationWarning***REMOVED***

        if wkst is None:
            self._wkst = calendar.firstweekday(***REMOVED***
        elif isinstance(wkst, integer_types***REMOVED***:
            self._wkst = wkst
        else:
            self._wkst = wkst.weekday

        if bysetpos is None:
            self._bysetpos = None
        elif isinstance(bysetpos, integer_types***REMOVED***:
            if bysetpos == 0 or not (-366 <= bysetpos <= 366***REMOVED***:
                raise ValueError("bysetpos must be between 1 and 366, "
                                 "or between -366 and -1"***REMOVED***
            self._bysetpos = (bysetpos,***REMOVED***
        else:
            self._bysetpos = tuple(bysetpos***REMOVED***
            for pos in self._bysetpos:
                if pos == 0 or not (-366 <= pos <= 366***REMOVED***:
                    raise ValueError("bysetpos must be between 1 and 366, "
                                     "or between -366 and -1"***REMOVED***

        if self._bysetpos:
            self._original_rule['bysetpos'***REMOVED*** = self._bysetpos

        if (byweekno is None and byyearday is None and bymonthday is None and
                byweekday is None and byeaster is None***REMOVED***:
            if freq == YEARLY:
                if bymonth is None:
                    bymonth = dtstart.month
                    self._original_rule['bymonth'***REMOVED*** = None
                bymonthday = dtstart.day
                self._original_rule['bymonthday'***REMOVED*** = None
            elif freq == MONTHLY:
                bymonthday = dtstart.day
                self._original_rule['bymonthday'***REMOVED*** = None
            elif freq == WEEKLY:
                byweekday = dtstart.weekday(***REMOVED***
                self._original_rule['byweekday'***REMOVED*** = None

        # bymonth
        if bymonth is None:
            self._bymonth = None
        else:
            if isinstance(bymonth, integer_types***REMOVED***:
                bymonth = (bymonth,***REMOVED***

            self._bymonth = tuple(sorted(set(bymonth***REMOVED******REMOVED******REMOVED***

            if 'bymonth' not in self._original_rule:
                self._original_rule['bymonth'***REMOVED*** = self._bymonth

        # byyearday
        if byyearday is None:
            self._byyearday = None
        else:
            if isinstance(byyearday, integer_types***REMOVED***:
                byyearday = (byyearday,***REMOVED***

            self._byyearday = tuple(sorted(set(byyearday***REMOVED******REMOVED******REMOVED***
            self._original_rule['byyearday'***REMOVED*** = self._byyearday

        # byeaster
        if byeaster is not None:
            if not easter:
                from dateutil import easter
            if isinstance(byeaster, integer_types***REMOVED***:
                self._byeaster = (byeaster,***REMOVED***
            else:
                self._byeaster = tuple(sorted(byeaster***REMOVED******REMOVED***

            self._original_rule['byeaster'***REMOVED*** = self._byeaster
        else:
            self._byeaster = None

        # bymonthday
        if bymonthday is None:
            self._bymonthday = (***REMOVED***
            self._bynmonthday = (***REMOVED***
        else:
            if isinstance(bymonthday, integer_types***REMOVED***:
                bymonthday = (bymonthday,***REMOVED***

            bymonthday = set(bymonthday***REMOVED***            # Ensure it's unique

            self._bymonthday = tuple(sorted([x for x in bymonthday if x > 0***REMOVED******REMOVED******REMOVED***
            self._bynmonthday = tuple(sorted([x for x in bymonthday if x < 0***REMOVED******REMOVED******REMOVED***

            # Storing positive numbers first, then negative numbers
            if 'bymonthday' not in self._original_rule:
                self._original_rule['bymonthday'***REMOVED*** = tuple(
                    itertools.chain(self._bymonthday, self._bynmonthday***REMOVED******REMOVED***

        # byweekno
        if byweekno is None:
            self._byweekno = None
        else:
            if isinstance(byweekno, integer_types***REMOVED***:
                byweekno = (byweekno,***REMOVED***

            self._byweekno = tuple(sorted(set(byweekno***REMOVED******REMOVED******REMOVED***

            self._original_rule['byweekno'***REMOVED*** = self._byweekno

        # byweekday / bynweekday
        if byweekday is None:
            self._byweekday = None
            self._bynweekday = None
        else:
            # If it's one of the valid non-sequence types, convert to a
            # single-element sequence before the iterator that builds the
            # byweekday set.
            if isinstance(byweekday, integer_types***REMOVED*** or hasattr(byweekday, "n"***REMOVED***:
                byweekday = (byweekday,***REMOVED***

            self._byweekday = set(***REMOVED***
            self._bynweekday = set(***REMOVED***
            for wday in byweekday:
                if isinstance(wday, integer_types***REMOVED***:
                    self._byweekday.add(wday***REMOVED***
                elif not wday.n or freq > MONTHLY:
                    self._byweekday.add(wday.weekday***REMOVED***
                else:
                    self._bynweekday.add((wday.weekday, wday.n***REMOVED******REMOVED***

            if not self._byweekday:
                self._byweekday = None
            elif not self._bynweekday:
                self._bynweekday = None

            if self._byweekday is not None:
                self._byweekday = tuple(sorted(self._byweekday***REMOVED******REMOVED***
                orig_byweekday = [weekday(x***REMOVED*** for x in self._byweekday***REMOVED***
            else:
                orig_byweekday = tuple(***REMOVED***

            if self._bynweekday is not None:
                self._bynweekday = tuple(sorted(self._bynweekday***REMOVED******REMOVED***
                orig_bynweekday = [weekday(*x***REMOVED*** for x in self._bynweekday***REMOVED***
            else:
                orig_bynweekday = tuple(***REMOVED***

            if 'byweekday' not in self._original_rule:
                self._original_rule['byweekday'***REMOVED*** = tuple(itertools.chain(
                    orig_byweekday, orig_bynweekday***REMOVED******REMOVED***

        # byhour
        if byhour is None:
            if freq < HOURLY:
                self._byhour = set((dtstart.hour,***REMOVED******REMOVED***
            else:
                self._byhour = None
        else:
            if isinstance(byhour, integer_types***REMOVED***:
                byhour = (byhour,***REMOVED***

            if freq == HOURLY:
                self._byhour = self.__construct_byset(start=dtstart.hour,
                                                      byxxx=byhour,
                                                      base=24***REMOVED***
            else:
                self._byhour = set(byhour***REMOVED***

            self._byhour = tuple(sorted(self._byhour***REMOVED******REMOVED***
            self._original_rule['byhour'***REMOVED*** = self._byhour

        # byminute
        if byminute is None:
            if freq < MINUTELY:
                self._byminute = set((dtstart.minute,***REMOVED******REMOVED***
            else:
                self._byminute = None
        else:
            if isinstance(byminute, integer_types***REMOVED***:
                byminute = (byminute,***REMOVED***

            if freq == MINUTELY:
                self._byminute = self.__construct_byset(start=dtstart.minute,
                                                        byxxx=byminute,
                                                        base=60***REMOVED***
            else:
                self._byminute = set(byminute***REMOVED***

            self._byminute = tuple(sorted(self._byminute***REMOVED******REMOVED***
            self._original_rule['byminute'***REMOVED*** = self._byminute

        # bysecond
        if bysecond is None:
            if freq < SECONDLY:
                self._bysecond = ((dtstart.second,***REMOVED******REMOVED***
            else:
                self._bysecond = None
        else:
            if isinstance(bysecond, integer_types***REMOVED***:
                bysecond = (bysecond,***REMOVED***

            self._bysecond = set(bysecond***REMOVED***

            if freq == SECONDLY:
                self._bysecond = self.__construct_byset(start=dtstart.second,
                                                        byxxx=bysecond,
                                                        base=60***REMOVED***
            else:
                self._bysecond = set(bysecond***REMOVED***

            self._bysecond = tuple(sorted(self._bysecond***REMOVED******REMOVED***
            self._original_rule['bysecond'***REMOVED*** = self._bysecond

        if self._freq >= HOURLY:
            self._timeset = None
        else:
            self._timeset = [***REMOVED***
            for hour in self._byhour:
                for minute in self._byminute:
                    for second in self._bysecond:
                        self._timeset.append(
                            datetime.time(hour, minute, second,
                                          tzinfo=self._tzinfo***REMOVED******REMOVED***
            self._timeset.sort(***REMOVED***
            self._timeset = tuple(self._timeset***REMOVED***

    def __str__(self***REMOVED***:
        ***REMOVED***
        Output a string that would generate this RRULE if passed to rrulestr.
        This is mostly compatible with RFC2445, except for the
        dateutil-specific extension BYEASTER.
        ***REMOVED***

        output = [***REMOVED***
        h, m, s = [None***REMOVED*** * 3
        if self._dtstart:
            output.append(self._dtstart.strftime('DTSTART:%Y%m%dT%H%M%S'***REMOVED******REMOVED***
            h, m, s = self._dtstart.timetuple(***REMOVED***[3:6***REMOVED***

        parts = ['FREQ=' + FREQNAMES[self._freq***REMOVED******REMOVED***
        if self._interval != 1:
            parts.append('INTERVAL=' + str(self._interval***REMOVED******REMOVED***

        if self._wkst:
            parts.append('WKST=' + str(self._wkst***REMOVED******REMOVED***

        if self._count:
            parts.append('COUNT=' + str(self._count***REMOVED******REMOVED***

        if self._until:
            parts.append(self._until.strftime('UNTIL=%Y%m%dT%H%M%S'***REMOVED******REMOVED***

        if self._original_rule.get('byweekday'***REMOVED*** is not None:
            # The str(***REMOVED*** method on weekday objects doesn't generate
            # RFC2445-compliant strings, so we should modify that.
            original_rule = dict(self._original_rule***REMOVED***
            wday_strings = [***REMOVED***
            for wday in original_rule['byweekday'***REMOVED***:
                if wday.n:
                    wday_strings.append('{n:+d***REMOVED***{wday***REMOVED***'.format(
                        n=wday.n,
                        wday=repr(wday***REMOVED***[0:2***REMOVED******REMOVED******REMOVED***
                else:
                    wday_strings.append(repr(wday***REMOVED******REMOVED***

            original_rule['byweekday'***REMOVED*** = wday_strings
        else:
            original_rule = self._original_rule

        partfmt = '{name***REMOVED***={vals***REMOVED***'
        for name, key in [('BYSETPOS', 'bysetpos'***REMOVED***,
                          ('BYMONTH', 'bymonth'***REMOVED***,
                          ('BYMONTHDAY', 'bymonthday'***REMOVED***,
                          ('BYYEARDAY', 'byyearday'***REMOVED***,
                          ('BYWEEKNO', 'byweekno'***REMOVED***,
                          ('BYDAY', 'byweekday'***REMOVED***,
                          ('BYHOUR', 'byhour'***REMOVED***,
                          ('BYMINUTE', 'byminute'***REMOVED***,
                          ('BYSECOND', 'bysecond'***REMOVED***,
                          ('BYEASTER', 'byeaster'***REMOVED******REMOVED***:
            value = original_rule.get(key***REMOVED***
            if value:
                parts.append(partfmt.format(name=name, vals=(','.join(str(v***REMOVED***
                                                             for v in value***REMOVED******REMOVED******REMOVED******REMOVED***

        output.append(';'.join(parts***REMOVED******REMOVED***
        return '\n'.join(output***REMOVED***

    def _iter(self***REMOVED***:
        year, month, day, hour, minute, second, weekday, yearday, _ = \
            self._dtstart.timetuple(***REMOVED***

        # Some local variables to speed things up a bit
        freq = self._freq
        interval = self._interval
        wkst = self._wkst
        until = self._until
        bymonth = self._bymonth
        byweekno = self._byweekno
        byyearday = self._byyearday
        byweekday = self._byweekday
        byeaster = self._byeaster
        bymonthday = self._bymonthday
        bynmonthday = self._bynmonthday
        bysetpos = self._bysetpos
        byhour = self._byhour
        byminute = self._byminute
        bysecond = self._bysecond

        ii = _iterinfo(self***REMOVED***
        ii.rebuild(year, month***REMOVED***

        getdayset = {YEARLY: ii.ydayset,
                     MONTHLY: ii.mdayset,
                     WEEKLY: ii.wdayset,
                     DAILY: ii.ddayset,
                     HOURLY: ii.ddayset,
                     MINUTELY: ii.ddayset,
                     SECONDLY: ii.ddayset***REMOVED***[freq***REMOVED***

        if freq < HOURLY:
            timeset = self._timeset
        else:
            gettimeset = {HOURLY: ii.htimeset,
                          MINUTELY: ii.mtimeset,
                          SECONDLY: ii.stimeset***REMOVED***[freq***REMOVED***
            if ((freq >= HOURLY and
                 self._byhour and hour not in self._byhour***REMOVED*** or
                (freq >= MINUTELY and
                 self._byminute and minute not in self._byminute***REMOVED*** or
                (freq >= SECONDLY and
                 self._bysecond and second not in self._bysecond***REMOVED******REMOVED***:
                timeset = (***REMOVED***
            else:
                timeset = gettimeset(hour, minute, second***REMOVED***

        total = 0
        count = self._count
        while True:
            # Get dayset with the right frequency
            dayset, start, end = getdayset(year, month, day***REMOVED***

            # Do the "hard" work ;-***REMOVED***
            filtered = False
            for i in dayset[start:end***REMOVED***:
                if ((bymonth and ii.mmask[i***REMOVED*** not in bymonth***REMOVED*** or
                    (byweekno and not ii.wnomask[i***REMOVED******REMOVED*** or
                    (byweekday and ii.wdaymask[i***REMOVED*** not in byweekday***REMOVED*** or
                    (ii.nwdaymask and not ii.nwdaymask[i***REMOVED******REMOVED*** or
                    (byeaster and not ii.eastermask[i***REMOVED******REMOVED*** or
                    ((bymonthday or bynmonthday***REMOVED*** and
                     ii.mdaymask[i***REMOVED*** not in bymonthday and
                     ii.nmdaymask[i***REMOVED*** not in bynmonthday***REMOVED*** or
                    (byyearday and
                     ((i < ii.yearlen and i+1 not in byyearday and
                       -ii.yearlen+i not in byyearday***REMOVED*** or
                      (i >= ii.yearlen and i+1-ii.yearlen not in byyearday and
                       -ii.nextyearlen+i-ii.yearlen not in byyearday***REMOVED******REMOVED******REMOVED******REMOVED***:
                    dayset[i***REMOVED*** = None
                    filtered = True

            # Output results
            if bysetpos and timeset:
                poslist = [***REMOVED***
                for pos in bysetpos:
                    if pos < 0:
                        daypos, timepos = divmod(pos, len(timeset***REMOVED******REMOVED***
                    else:
                        daypos, timepos = divmod(pos-1, len(timeset***REMOVED******REMOVED***
                    ***REMOVED***
                        i = [x for x in dayset[start:end***REMOVED***
                             if x is not None***REMOVED***[daypos***REMOVED***
                        time = timeset[timepos***REMOVED***
                    except IndexError:
                        pass
                    else:
                        date = datetime.date.fromordinal(ii.yearordinal+i***REMOVED***
                        res = datetime.datetime.combine(date, time***REMOVED***
                        if res not in poslist:
                            poslist.append(res***REMOVED***
                poslist.sort(***REMOVED***
                for res in poslist:
                    if until and res > until:
                        self._len = total
                        return
                    elif res >= self._dtstart:
                        total += 1
                        yield res
                        if count:
                            count -= 1
                            if not count:
                                self._len = total
                                return
            else:
                for i in dayset[start:end***REMOVED***:
                    if i is not None:
                        date = datetime.date.fromordinal(ii.yearordinal + i***REMOVED***
                        for time in timeset:
                            res = datetime.datetime.combine(date, time***REMOVED***
                            if until and res > until:
                                self._len = total
                                return
                            elif res >= self._dtstart:
                                total += 1
                                yield res
                                if count:
                                    count -= 1
                                    if not count:
                                        self._len = total
                                        return

            # Handle frequency and interval
            fixday = False
            if freq == YEARLY:
                year += interval
                if year > datetime.MAXYEAR:
                    self._len = total
                    return
                ii.rebuild(year, month***REMOVED***
            elif freq == MONTHLY:
                month += interval
                if month > 12:
                    div, mod = divmod(month, 12***REMOVED***
                    month = mod
                    year += div
                    if month == 0:
                        month = 12
                        year -= 1
                    if year > datetime.MAXYEAR:
                        self._len = total
                        return
                ii.rebuild(year, month***REMOVED***
            elif freq == WEEKLY:
                if wkst > weekday:
                    day += -(weekday+1+(6-wkst***REMOVED******REMOVED***+self._interval*7
                else:
                    day += -(weekday-wkst***REMOVED***+self._interval*7
                weekday = wkst
                fixday = True
            elif freq == DAILY:
                day += interval
                fixday = True
            elif freq == HOURLY:
                if filtered:
                    # Jump to one iteration before next day
                    hour += ((23-hour***REMOVED***//interval***REMOVED****interval

                if byhour:
                    ndays, hour = self.__mod_distance(value=hour,
                                                      byxxx=self._byhour,
                                                      base=24***REMOVED***
                else:
                    ndays, hour = divmod(hour+interval, 24***REMOVED***

                if ndays:
                    day += ndays
                    fixday = True

                timeset = gettimeset(hour, minute, second***REMOVED***
            elif freq == MINUTELY:
                if filtered:
                    # Jump to one iteration before next day
                    minute += ((1439-(hour*60+minute***REMOVED******REMOVED***//interval***REMOVED****interval

                valid = False
                rep_rate = (24*60***REMOVED***
                for j in range(rep_rate // gcd(interval, rep_rate***REMOVED******REMOVED***:
                    if byminute:
                        nhours, minute = \
                            self.__mod_distance(value=minute,
                                                byxxx=self._byminute,
                                                base=60***REMOVED***
                    else:
                        nhours, minute = divmod(minute+interval, 60***REMOVED***

                    div, hour = divmod(hour+nhours, 24***REMOVED***
                    if div:
                        day += div
                        fixday = True
                        filtered = False

                    if not byhour or hour in byhour:
                        valid = True
                        break

                if not valid:
                    raise ValueError('Invalid combination of interval and ' +
                                     'byhour resulting in empty rule.'***REMOVED***

                timeset = gettimeset(hour, minute, second***REMOVED***
            elif freq == SECONDLY:
                if filtered:
                    # Jump to one iteration before next day
                    second += (((86399 - (hour * 3600 + minute * 60 + second***REMOVED******REMOVED***
                                // interval***REMOVED*** * interval***REMOVED***

                rep_rate = (24 * 3600***REMOVED***
                valid = False
                for j in range(0, rep_rate // gcd(interval, rep_rate***REMOVED******REMOVED***:
                    if bysecond:
                        nminutes, second = \
                            self.__mod_distance(value=second,
                                                byxxx=self._bysecond,
                                                base=60***REMOVED***
                    else:
                        nminutes, second = divmod(second+interval, 60***REMOVED***

                    div, minute = divmod(minute+nminutes, 60***REMOVED***
                    if div:
                        hour += div
                        div, hour = divmod(hour, 24***REMOVED***
                        if div:
                            day += div
                            fixday = True

                    if ((not byhour or hour in byhour***REMOVED*** and
                            (not byminute or minute in byminute***REMOVED*** and
                            (not bysecond or second in bysecond***REMOVED******REMOVED***:
                        valid = True
                        break

                if not valid:
                    raise ValueError('Invalid combination of interval, ' +
                                     'byhour and byminute resulting in empty' +
                                     ' rule.'***REMOVED***

                timeset = gettimeset(hour, minute, second***REMOVED***

            if fixday and day > 28:
                daysinmonth = calendar.monthrange(year, month***REMOVED***[1***REMOVED***
                if day > daysinmonth:
                    while day > daysinmonth:
                        day -= daysinmonth
                        month += 1
                        if month == 13:
                            month = 1
                            year += 1
                            if year > datetime.MAXYEAR:
                                self._len = total
                                return
                        daysinmonth = calendar.monthrange(year, month***REMOVED***[1***REMOVED***
                    ii.rebuild(year, month***REMOVED***

    def __construct_byset(self, start, byxxx, base***REMOVED***:
        ***REMOVED***
        If a `BYXXX` sequence is passed to the constructor at the same level as
        `FREQ` (e.g. `FREQ=HOURLY,BYHOUR={2,4,7***REMOVED***,INTERVAL=3`***REMOVED***, there are some
        specifications which cannot be reached given some starting conditions.

        This occurs whenever the interval is not coprime with the base of a
        given unit and the difference between the starting position and the
        ending position is not coprime with the greatest common denominator
        between the interval and the base. For example, with a FREQ of hourly
        starting at 17:00 and an interval of 4, the only valid values for
        BYHOUR would be {21, 1, 5, 9, 13, 17***REMOVED***, because 4 and 24 are not
        coprime.

        :param start:
            Specifies the starting position.
        :param byxxx:
            An iterable containing the list of allowed values.
        :param base:
            The largest allowable value for the specified frequency (e.g.
            24 hours, 60 minutes***REMOVED***.

        This does not preserve the type of the iterable, returning a set, since
        the values should be unique and the order is irrelevant, this will
        speed up later lookups.

        In the event of an empty set, raises a :exception:`ValueError`, as this
        results in an empty rrule.
        ***REMOVED***

        cset = set(***REMOVED***

        # Support a single byxxx value.
        if isinstance(byxxx, integer_types***REMOVED***:
            byxxx = (byxxx, ***REMOVED***

        for num in byxxx:
            i_gcd = gcd(self._interval, base***REMOVED***
            # Use divmod rather than % because we need to wrap negative nums.
            if i_gcd == 1 or divmod(num - start, i_gcd***REMOVED***[1***REMOVED*** == 0:
                cset.add(num***REMOVED***

        if len(cset***REMOVED*** == 0:
            raise ValueError("Invalid rrule byxxx generates an empty set."***REMOVED***

        return cset

    def __mod_distance(self, value, byxxx, base***REMOVED***:
        ***REMOVED***
        Calculates the next value in a sequence where the `FREQ` parameter is
        specified along with a `BYXXX` parameter at the same "level"
        (e.g. `HOURLY` specified with `BYHOUR`***REMOVED***.

        :param value:
            The old value of the component.
        :param byxxx:
            The `BYXXX` set, which should have been generated by
            `rrule._construct_byset`, or something else which checks that a
            valid rule is present.
        :param base:
            The largest allowable value for the specified frequency (e.g.
            24 hours, 60 minutes***REMOVED***.

        If a valid value is not found after `base` iterations (the maximum
        number before the sequence would start to repeat***REMOVED***, this raises a
        :exception:`ValueError`, as no valid values were found.

        This returns a tuple of `divmod(n*interval, base***REMOVED***`, where `n` is the
        smallest number of `interval` repetitions until the next specified
        value in `byxxx` is found.
        ***REMOVED***
        accumulator = 0
        for ii in range(1, base + 1***REMOVED***:
            # Using divmod(***REMOVED*** over % to account for negative intervals
            div, value = divmod(value + self._interval, base***REMOVED***
            accumulator += div
            if value in byxxx:
                return (accumulator, value***REMOVED***


class _iterinfo(object***REMOVED***:
    __slots__ = ["rrule", "lastyear", "lastmonth",
                 "yearlen", "nextyearlen", "yearordinal", "yearweekday",
                 "mmask", "mrange", "mdaymask", "nmdaymask",
                 "wdaymask", "wnomask", "nwdaymask", "eastermask"***REMOVED***

    def __init__(self, rrule***REMOVED***:
        for attr in self.__slots__:
            setattr(self, attr, None***REMOVED***
        self.rrule = rrule

    def rebuild(self, year, month***REMOVED***:
        # Every mask is 7 days longer to handle cross-year weekly periods.
        rr = self.rrule
        if year != self.lastyear:
            self.yearlen = 365 + calendar.isleap(year***REMOVED***
            self.nextyearlen = 365 + calendar.isleap(year + 1***REMOVED***
            firstyday = datetime.date(year, 1, 1***REMOVED***
            self.yearordinal = firstyday.toordinal(***REMOVED***
            self.yearweekday = firstyday.weekday(***REMOVED***

            wday = datetime.date(year, 1, 1***REMOVED***.weekday(***REMOVED***
            if self.yearlen == 365:
                self.mmask = M365MASK
                self.mdaymask = MDAY365MASK
                self.nmdaymask = NMDAY365MASK
                self.wdaymask = WDAYMASK[wday:***REMOVED***
                self.mrange = M365RANGE
            else:
                self.mmask = M366MASK
                self.mdaymask = MDAY366MASK
                self.nmdaymask = NMDAY366MASK
                self.wdaymask = WDAYMASK[wday:***REMOVED***
                self.mrange = M366RANGE

            if not rr._byweekno:
                self.wnomask = None
            else:
                self.wnomask = [0***REMOVED****(self.yearlen+7***REMOVED***
                # no1wkst = firstwkst = self.wdaymask.index(rr._wkst***REMOVED***
                no1wkst = firstwkst = (7-self.yearweekday+rr._wkst***REMOVED*** % 7
                if no1wkst >= 4:
                    no1wkst = 0
                    # Number of days in the year, plus the days we got
                    # from last year.
                    wyearlen = self.yearlen+(self.yearweekday-rr._wkst***REMOVED*** % 7
                else:
                    # Number of days in the year, minus the days we
                    # left in last year.
                    wyearlen = self.yearlen-no1wkst
                div, mod = divmod(wyearlen, 7***REMOVED***
                numweeks = div+mod//4
                for n in rr._byweekno:
                    if n < 0:
                        n += numweeks+1
                    if not (0 < n <= numweeks***REMOVED***:
                        continue
                    if n > 1:
                        i = no1wkst+(n-1***REMOVED****7
                        if no1wkst != firstwkst:
                            i -= 7-firstwkst
                    else:
                        i = no1wkst
                    for j in range(7***REMOVED***:
                        self.wnomask[i***REMOVED*** = 1
                        i += 1
                        if self.wdaymask[i***REMOVED*** == rr._wkst:
                            break
                if 1 in rr._byweekno:
                    # Check week number 1 of next year as well
                    # TODO: Check -numweeks for next year.
                    i = no1wkst+numweeks*7
                    if no1wkst != firstwkst:
                        i -= 7-firstwkst
                    if i < self.yearlen:
                        # If week starts in next year, we
                        # don't care about it.
                        for j in range(7***REMOVED***:
                            self.wnomask[i***REMOVED*** = 1
                            i += 1
                            if self.wdaymask[i***REMOVED*** == rr._wkst:
                                break
                if no1wkst:
                    # Check last week number of last year as
                    # well. If no1wkst is 0, either the year
                    # started on week start, or week number 1
                    # got days from last year, so there are no
                    # days from last year's last week number in
                    # this year.
                    if -1 not in rr._byweekno:
                        lyearweekday = datetime.date(year-1, 1, 1***REMOVED***.weekday(***REMOVED***
                        lno1wkst = (7-lyearweekday+rr._wkst***REMOVED*** % 7
                        lyearlen = 365+calendar.isleap(year-1***REMOVED***
                        if lno1wkst >= 4:
                            lno1wkst = 0
                            lnumweeks = 52+(lyearlen +
                                            (lyearweekday-rr._wkst***REMOVED*** % 7***REMOVED*** % 7//4
                        else:
                            lnumweeks = 52+(self.yearlen-no1wkst***REMOVED*** % 7//4
                    else:
                        lnumweeks = -1
                    if lnumweeks in rr._byweekno:
                        for i in range(no1wkst***REMOVED***:
                            self.wnomask[i***REMOVED*** = 1

        if (rr._bynweekday and (month != self.lastmonth or
                                year != self.lastyear***REMOVED******REMOVED***:
            ranges = [***REMOVED***
            if rr._freq == YEARLY:
                if rr._bymonth:
                    for month in rr._bymonth:
                        ranges.append(self.mrange[month-1:month+1***REMOVED******REMOVED***
                else:
                    ranges = [(0, self.yearlen***REMOVED******REMOVED***
            elif rr._freq == MONTHLY:
                ranges = [self.mrange[month-1:month+1***REMOVED******REMOVED***
            if ranges:
                # Weekly frequency won't get here, so we may not
                # care about cross-year weekly periods.
                self.nwdaymask = [0***REMOVED****self.yearlen
                for first, last in ranges:
                    last -= 1
                    for wday, n in rr._bynweekday:
                        if n < 0:
                            i = last+(n+1***REMOVED****7
                            i -= (self.wdaymask[i***REMOVED***-wday***REMOVED*** % 7
                        else:
                            i = first+(n-1***REMOVED****7
                            i += (7-self.wdaymask[i***REMOVED***+wday***REMOVED*** % 7
                        if first <= i <= last:
                            self.nwdaymask[i***REMOVED*** = 1

        if rr._byeaster:
            self.eastermask = [0***REMOVED****(self.yearlen+7***REMOVED***
            eyday = easter.easter(year***REMOVED***.toordinal(***REMOVED***-self.yearordinal
            for offset in rr._byeaster:
                self.eastermask[eyday+offset***REMOVED*** = 1

        self.lastyear = year
        self.lastmonth = month

    def ydayset(self, year, month, day***REMOVED***:
        return list(range(self.yearlen***REMOVED******REMOVED***, 0, self.yearlen

    def mdayset(self, year, month, day***REMOVED***:
        dset = [None***REMOVED****self.yearlen
        start, end = self.mrange[month-1:month+1***REMOVED***
        for i in range(start, end***REMOVED***:
            dset[i***REMOVED*** = i
        return dset, start, end

    def wdayset(self, year, month, day***REMOVED***:
        # We need to handle cross-year weeks here.
        dset = [None***REMOVED****(self.yearlen+7***REMOVED***
        i = datetime.date(year, month, day***REMOVED***.toordinal(***REMOVED***-self.yearordinal
        start = i
        for j in range(7***REMOVED***:
            dset[i***REMOVED*** = i
            i += 1
            # if (not (0 <= i < self.yearlen***REMOVED*** or
            #    self.wdaymask[i***REMOVED*** == self.rrule._wkst***REMOVED***:
            # This will cross the year boundary, if necessary.
            if self.wdaymask[i***REMOVED*** == self.rrule._wkst:
                break
        return dset, start, i

    def ddayset(self, year, month, day***REMOVED***:
        dset = [None***REMOVED*** * self.yearlen
        i = datetime.date(year, month, day***REMOVED***.toordinal(***REMOVED*** - self.yearordinal
        dset[i***REMOVED*** = i
        return dset, i, i + 1

    def htimeset(self, hour, minute, second***REMOVED***:
        tset = [***REMOVED***
        rr = self.rrule
        for minute in rr._byminute:
            for second in rr._bysecond:
                tset.append(datetime.time(hour, minute, second,
                                          tzinfo=rr._tzinfo***REMOVED******REMOVED***
        tset.sort(***REMOVED***
        return tset

    def mtimeset(self, hour, minute, second***REMOVED***:
        tset = [***REMOVED***
        rr = self.rrule
        for second in rr._bysecond:
            tset.append(datetime.time(hour, minute, second, tzinfo=rr._tzinfo***REMOVED******REMOVED***
        tset.sort(***REMOVED***
        return tset

    def stimeset(self, hour, minute, second***REMOVED***:
        return (datetime.time(hour, minute, second,
                tzinfo=self.rrule._tzinfo***REMOVED***,***REMOVED***


class rruleset(rrulebase***REMOVED***:
    ***REMOVED*** The rruleset type allows more complex recurrence setups, mixing
    multiple rules, dates, exclusion rules, and exclusion dates. The type
    constructor takes the following keyword arguments:

    :param cache: If True, caching of results will be enabled, improving
                  performance of multiple queries considerably. ***REMOVED***

    class _genitem(object***REMOVED***:
        def __init__(self, genlist, gen***REMOVED***:
            ***REMOVED***
                self.dt = advance_iterator(gen***REMOVED***
                genlist.append(self***REMOVED***
            except StopIteration:
                pass
            self.genlist = genlist
            self.gen = gen

        def __next__(self***REMOVED***:
            ***REMOVED***
                self.dt = advance_iterator(self.gen***REMOVED***
            except StopIteration:
                if self.genlist[0***REMOVED*** is self:
                    heapq.heappop(self.genlist***REMOVED***
                else:
                    self.genlist.remove(self***REMOVED***
                    heapq.heapify(self.genlist***REMOVED***

        next = __next__

        def __lt__(self, other***REMOVED***:
            return self.dt < other.dt

        def __gt__(self, other***REMOVED***:
            return self.dt > other.dt

        def __eq__(self, other***REMOVED***:
            return self.dt == other.dt

        def __ne__(self, other***REMOVED***:
            return self.dt != other.dt

    def __init__(self, cache=False***REMOVED***:
        super(rruleset, self***REMOVED***.__init__(cache***REMOVED***
        self._rrule = [***REMOVED***
        self._rdate = [***REMOVED***
        self._exrule = [***REMOVED***
        self._exdate = [***REMOVED***

    @_invalidates_cache
    def rrule(self, rrule***REMOVED***:
        ***REMOVED*** Include the given :py:class:`rrule` instance in the recurrence set
            generation. ***REMOVED***
        self._rrule.append(rrule***REMOVED***

    @_invalidates_cache
    def rdate(self, rdate***REMOVED***:
        ***REMOVED*** Include the given :py:class:`datetime` instance in the recurrence
            set generation. ***REMOVED***
        self._rdate.append(rdate***REMOVED***

    @_invalidates_cache
    def exrule(self, exrule***REMOVED***:
        ***REMOVED*** Include the given rrule instance in the recurrence set exclusion
            list. Dates which are part of the given recurrence rules will not
            be generated, even if some inclusive rrule or rdate matches them.
        ***REMOVED***
        self._exrule.append(exrule***REMOVED***

    @_invalidates_cache
    def exdate(self, exdate***REMOVED***:
        ***REMOVED*** Include the given datetime instance in the recurrence set
            exclusion list. Dates included that way will not be generated,
            even if some inclusive rrule or rdate matches them. ***REMOVED***
        self._exdate.append(exdate***REMOVED***

    def _iter(self***REMOVED***:
        rlist = [***REMOVED***
        self._rdate.sort(***REMOVED***
        self._genitem(rlist, iter(self._rdate***REMOVED******REMOVED***
        for gen in [iter(x***REMOVED*** for x in self._rrule***REMOVED***:
            self._genitem(rlist, gen***REMOVED***
        exlist = [***REMOVED***
        self._exdate.sort(***REMOVED***
        self._genitem(exlist, iter(self._exdate***REMOVED******REMOVED***
        for gen in [iter(x***REMOVED*** for x in self._exrule***REMOVED***:
            self._genitem(exlist, gen***REMOVED***
        lastdt = None
        total = 0
        heapq.heapify(rlist***REMOVED***
        heapq.heapify(exlist***REMOVED***
        while rlist:
            ritem = rlist[0***REMOVED***
            if not lastdt or lastdt != ritem.dt:
                while exlist and exlist[0***REMOVED*** < ritem:
                    exitem = exlist[0***REMOVED***
                    advance_iterator(exitem***REMOVED***
                    if exlist and exlist[0***REMOVED*** is exitem:
                        heapq.heapreplace(exlist, exitem***REMOVED***
                if not exlist or ritem != exlist[0***REMOVED***:
                    total += 1
                    yield ritem.dt
                lastdt = ritem.dt
            advance_iterator(ritem***REMOVED***
            if rlist and rlist[0***REMOVED*** is ritem:
                heapq.heapreplace(rlist, ritem***REMOVED***
        self._len = total


class _rrulestr(object***REMOVED***:

    _freq_map = {"YEARLY": YEARLY,
                 "MONTHLY": MONTHLY,
                 "WEEKLY": WEEKLY,
                 "DAILY": DAILY,
                 "HOURLY": HOURLY,
                 "MINUTELY": MINUTELY,
                 "SECONDLY": SECONDLY***REMOVED***

    _weekday_map = {"MO": 0, "TU": 1, "WE": 2, "TH": 3,
                    "FR": 4, "SA": 5, "SU": 6***REMOVED***

    def _handle_int(self, rrkwargs, name, value, **kwargs***REMOVED***:
        rrkwargs[name.lower(***REMOVED******REMOVED*** = int(value***REMOVED***

    def _handle_int_list(self, rrkwargs, name, value, **kwargs***REMOVED***:
        rrkwargs[name.lower(***REMOVED******REMOVED*** = [int(x***REMOVED*** for x in value.split(','***REMOVED******REMOVED***

    _handle_INTERVAL = _handle_int
    _handle_COUNT = _handle_int
    _handle_BYSETPOS = _handle_int_list
    _handle_BYMONTH = _handle_int_list
    _handle_BYMONTHDAY = _handle_int_list
    _handle_BYYEARDAY = _handle_int_list
    _handle_BYEASTER = _handle_int_list
    _handle_BYWEEKNO = _handle_int_list
    _handle_BYHOUR = _handle_int_list
    _handle_BYMINUTE = _handle_int_list
    _handle_BYSECOND = _handle_int_list

    def _handle_FREQ(self, rrkwargs, name, value, **kwargs***REMOVED***:
        rrkwargs["freq"***REMOVED*** = self._freq_map[value***REMOVED***

    def _handle_UNTIL(self, rrkwargs, name, value, **kwargs***REMOVED***:
        global parser
        if not parser:
            from dateutil import parser
        ***REMOVED***
            rrkwargs["until"***REMOVED*** = parser.parse(value,
                                             ignoretz=kwargs.get("ignoretz"***REMOVED***,
                                             tzinfos=kwargs.get("tzinfos"***REMOVED******REMOVED***
        except ValueError:
            raise ValueError("invalid until date"***REMOVED***

    def _handle_WKST(self, rrkwargs, name, value, **kwargs***REMOVED***:
        rrkwargs["wkst"***REMOVED*** = self._weekday_map[value***REMOVED***

    def _handle_BYWEEKDAY(self, rrkwargs, name, value, **kwargs***REMOVED***:
        ***REMOVED***
        Two ways to specify this: +1MO or MO(+1***REMOVED***
        ***REMOVED***
        l = [***REMOVED***
        for wday in value.split(','***REMOVED***:
            if '(' in wday:
                # If it's of the form TH(+1***REMOVED***, etc.
                splt = wday.split('('***REMOVED***
                w = splt[0***REMOVED***
                n = int(splt[1***REMOVED***[:-1***REMOVED******REMOVED***
            elif len(wday***REMOVED***:
                # If it's of the form +1MO
                for i in range(len(wday***REMOVED******REMOVED***:
                    if wday[i***REMOVED*** not in '+-0123456789':
                        break
                n = wday[:i***REMOVED*** or None
                w = wday[i:***REMOVED***
                if n:
                    n = int(n***REMOVED***
            else:
                raise ValueError("Invalid (empty***REMOVED*** BYDAY specification."***REMOVED***

            l.append(weekdays[self._weekday_map[w***REMOVED******REMOVED***(n***REMOVED******REMOVED***
        rrkwargs["byweekday"***REMOVED*** = l

    _handle_BYDAY = _handle_BYWEEKDAY

    def _parse_rfc_rrule(self, line,
                         dtstart=None,
                         cache=False,
                         ignoretz=False,
                         tzinfos=None***REMOVED***:
        if line.find(':'***REMOVED*** != -1:
            name, value = line.split(':'***REMOVED***
            if name != "RRULE":
                raise ValueError("unknown parameter name"***REMOVED***
        else:
            value = line
        rrkwargs = {***REMOVED***
        for pair in value.split(';'***REMOVED***:
            name, value = pair.split('='***REMOVED***
            name = name.upper(***REMOVED***
            value = value.upper(***REMOVED***
            ***REMOVED***
                getattr(self, "_handle_"+name***REMOVED***(rrkwargs, name, value,
                                               ignoretz=ignoretz,
                                               tzinfos=tzinfos***REMOVED***
            except AttributeError:
                raise ValueError("unknown parameter '%s'" % name***REMOVED***
            except (KeyError, ValueError***REMOVED***:
                raise ValueError("invalid '%s': %s" % (name, value***REMOVED******REMOVED***
        return rrule(dtstart=dtstart, cache=cache, **rrkwargs***REMOVED***

    def _parse_rfc(self, s,
                   dtstart=None,
                   cache=False,
                   unfold=False,
                   forceset=False,
                   compatible=False,
                   ignoretz=False,
                   tzinfos=None***REMOVED***:
        global parser
        if compatible:
            forceset = True
            unfold = True
        s = s.upper(***REMOVED***
        if not s.strip(***REMOVED***:
            raise ValueError("empty string"***REMOVED***
        if unfold:
            lines = s.splitlines(***REMOVED***
            i = 0
            while i < len(lines***REMOVED***:
                line = lines[i***REMOVED***.rstrip(***REMOVED***
                if not line:
                    del lines[i***REMOVED***
                elif i > 0 and line[0***REMOVED*** == " ":
                    lines[i-1***REMOVED*** += line[1:***REMOVED***
                    del lines[i***REMOVED***
                else:
                    i += 1
        else:
            lines = s.split(***REMOVED***
        if (not forceset and len(lines***REMOVED*** == 1 and (s.find(':'***REMOVED*** == -1 or
                                                  s.startswith('RRULE:'***REMOVED******REMOVED******REMOVED***:
            return self._parse_rfc_rrule(lines[0***REMOVED***, cache=cache,
                                         dtstart=dtstart, ignoretz=ignoretz,
                                         tzinfos=tzinfos***REMOVED***
        else:
            rrulevals = [***REMOVED***
            rdatevals = [***REMOVED***
            exrulevals = [***REMOVED***
            exdatevals = [***REMOVED***
            for line in lines:
                if not line:
                    continue
                if line.find(':'***REMOVED*** == -1:
                    name = "RRULE"
                    value = line
                else:
                    name, value = line.split(':', 1***REMOVED***
                parms = name.split(';'***REMOVED***
                if not parms:
                    raise ValueError("empty property name"***REMOVED***
                name = parms[0***REMOVED***
                parms = parms[1:***REMOVED***
                if name == "RRULE":
                    for parm in parms:
                        raise ValueError("unsupported RRULE parm: "+parm***REMOVED***
                    rrulevals.append(value***REMOVED***
                elif name == "RDATE":
                    for parm in parms:
                        if parm != "VALUE=DATE-TIME":
                            raise ValueError("unsupported RDATE parm: "+parm***REMOVED***
                    rdatevals.append(value***REMOVED***
                elif name == "EXRULE":
                    for parm in parms:
                        raise ValueError("unsupported EXRULE parm: "+parm***REMOVED***
                    exrulevals.append(value***REMOVED***
                elif name == "EXDATE":
                    for parm in parms:
                        if parm != "VALUE=DATE-TIME":
                            raise ValueError("unsupported RDATE parm: "+parm***REMOVED***
                    exdatevals.append(value***REMOVED***
                elif name == "DTSTART":
                    for parm in parms:
                        raise ValueError("unsupported DTSTART parm: "+parm***REMOVED***
                    if not parser:
                        from dateutil import parser
                    dtstart = parser.parse(value, ignoretz=ignoretz,
                                           tzinfos=tzinfos***REMOVED***
                else:
                    raise ValueError("unsupported property: "+name***REMOVED***
            if (forceset or len(rrulevals***REMOVED*** > 1 or rdatevals
                    or exrulevals or exdatevals***REMOVED***:
                if not parser and (rdatevals or exdatevals***REMOVED***:
                    from dateutil import parser
                rset = rruleset(cache=cache***REMOVED***
                for value in rrulevals:
                    rset.rrule(self._parse_rfc_rrule(value, dtstart=dtstart,
                                                     ignoretz=ignoretz,
                                                     tzinfos=tzinfos***REMOVED******REMOVED***
                for value in rdatevals:
                    for datestr in value.split(','***REMOVED***:
                        rset.rdate(parser.parse(datestr,
                                                ignoretz=ignoretz,
                                                tzinfos=tzinfos***REMOVED******REMOVED***
                for value in exrulevals:
                    rset.exrule(self._parse_rfc_rrule(value, dtstart=dtstart,
                                                      ignoretz=ignoretz,
                                                      tzinfos=tzinfos***REMOVED******REMOVED***
                for value in exdatevals:
                    for datestr in value.split(','***REMOVED***:
                        rset.exdate(parser.parse(datestr,
                                                 ignoretz=ignoretz,
                                                 tzinfos=tzinfos***REMOVED******REMOVED***
                if compatible and dtstart:
                    rset.rdate(dtstart***REMOVED***
                return rset
            else:
                return self._parse_rfc_rrule(rrulevals[0***REMOVED***,
                                             dtstart=dtstart,
                                             cache=cache,
                                             ignoretz=ignoretz,
                                             tzinfos=tzinfos***REMOVED***

    def __call__(self, s, **kwargs***REMOVED***:
        return self._parse_rfc(s, **kwargs***REMOVED***

rrulestr = _rrulestr(***REMOVED***

# vim:ts=4:sw=4:et
