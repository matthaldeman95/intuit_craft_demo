# -*- coding: utf-8 -*-
***REMOVED***
This module offers timezone implementations subclassing the abstract
:py:`datetime.tzinfo` type. There are classes to handle tzfile format files
(usually are in :file:`/etc/localtime`, :file:`/usr/share/zoneinfo`, etc***REMOVED***, TZ
environment string (in all known formats***REMOVED***, given ranges (with help from
relative deltas***REMOVED***, local machine timezone, fixed offset timezone, and UTC
timezone.
***REMOVED***
import datetime
import struct
import time
import sys
***REMOVED***

from six import string_types, PY3
from ._common import tzname_in_python2

***REMOVED***
    from .win import tzwin, tzwinlocal
except ImportError:
    tzwin = tzwinlocal = None

relativedelta = None
parser = None
rrule = None

ZERO = datetime.timedelta(0***REMOVED***
EPOCHORDINAL = datetime.datetime.utcfromtimestamp(0***REMOVED***.toordinal(***REMOVED***

class tzutc(datetime.tzinfo***REMOVED***:

    def utcoffset(self, dt***REMOVED***:
        return ZERO

    def dst(self, dt***REMOVED***:
        return ZERO

    @tzname_in_python2
    def tzname(self, dt***REMOVED***:
        return "UTC"

    def __eq__(self, other***REMOVED***:
        return (isinstance(other, tzutc***REMOVED*** or
                (isinstance(other, tzoffset***REMOVED*** and other._offset == ZERO***REMOVED******REMOVED***

    def __ne__(self, other***REMOVED***:
        return not self.__eq__(other***REMOVED***

    def __repr__(self***REMOVED***:
        return "%s(***REMOVED***" % self.__class__.__name__

    __reduce__ = object.__reduce__


class tzoffset(datetime.tzinfo***REMOVED***:

    def __init__(self, name, offset***REMOVED***:
        self._name = name
        self._offset = datetime.timedelta(seconds=offset***REMOVED***

    def utcoffset(self, dt***REMOVED***:
        return self._offset

    def dst(self, dt***REMOVED***:
        return ZERO

    @tzname_in_python2
    def tzname(self, dt***REMOVED***:
        return self._name

    def __eq__(self, other***REMOVED***:
        return (isinstance(other, tzoffset***REMOVED*** and
                self._offset == other._offset***REMOVED***

    def __ne__(self, other***REMOVED***:
        return not self.__eq__(other***REMOVED***

    def __repr__(self***REMOVED***:
        return "%s(%s, %s***REMOVED***" % (self.__class__.__name__,
                               repr(self._name***REMOVED***,
                               self._offset.days*86400+self._offset.seconds***REMOVED***

    __reduce__ = object.__reduce__


class tzlocal(datetime.tzinfo***REMOVED***:
    def __init__(self***REMOVED***:
        self._std_offset = datetime.timedelta(seconds=-time.timezone***REMOVED***
        if time.daylight:
            self._dst_offset = datetime.timedelta(seconds=-time.altzone***REMOVED***
        else:
            self._dst_offset = self._std_offset

    def utcoffset(self, dt***REMOVED***:
        if dt is None:
            return dt

        if self._isdst(dt***REMOVED***:
            return self._dst_offset
        else:
            return self._std_offset

    def dst(self, dt***REMOVED***:
        if self._isdst(dt***REMOVED***:
            return self._dst_offset-self._std_offset
        else:
            return ZERO

    @tzname_in_python2
    def tzname(self, dt***REMOVED***:
        return time.tzname[self._isdst(dt***REMOVED******REMOVED***

    def _isdst(self, dt***REMOVED***:
        # We can't use mktime here. It is unstable when deciding if
        # the hour near to a change is DST or not.
        #
        # timestamp = time.mktime((dt.year, dt.month, dt.day, dt.hour,
        #                         dt.minute, dt.second, dt.weekday(***REMOVED***, 0, -1***REMOVED******REMOVED***
        # return time.localtime(timestamp***REMOVED***.tm_isdst
        #
        # The code above yields the following result:
        #
        # >>> import tz, datetime
        # >>> t = tz.tzlocal(***REMOVED***
        # >>> datetime.datetime(2003,2,15,23,tzinfo=t***REMOVED***.tzname(***REMOVED***
        # 'BRDT'
        # >>> datetime.datetime(2003,2,16,0,tzinfo=t***REMOVED***.tzname(***REMOVED***
        # 'BRST'
        # >>> datetime.datetime(2003,2,15,23,tzinfo=t***REMOVED***.tzname(***REMOVED***
        # 'BRST'
        # >>> datetime.datetime(2003,2,15,22,tzinfo=t***REMOVED***.tzname(***REMOVED***
        # 'BRDT'
        # >>> datetime.datetime(2003,2,15,23,tzinfo=t***REMOVED***.tzname(***REMOVED***
        # 'BRDT'
        #
        # Here is a more stable implementation:
        #
        timestamp = ((dt.toordinal(***REMOVED*** - EPOCHORDINAL***REMOVED*** * 86400
                     + dt.hour * 3600
                     + dt.minute * 60
                     + dt.second***REMOVED***
        return time.localtime(timestamp+time.timezone***REMOVED***.tm_isdst

    def __eq__(self, other***REMOVED***:
        return (isinstance(other, tzlocal***REMOVED*** and
                (self._std_offset == other._std_offset and
                 self._dst_offset == other._dst_offset***REMOVED******REMOVED***

    def __ne__(self, other***REMOVED***:
        return not self.__eq__(other***REMOVED***

    def __repr__(self***REMOVED***:
        return "%s(***REMOVED***" % self.__class__.__name__

    __reduce__ = object.__reduce__


class _ttinfo(object***REMOVED***:
    __slots__ = ["offset", "delta", "isdst", "abbr", "isstd", "isgmt"***REMOVED***

    def __init__(self***REMOVED***:
        for attr in self.__slots__:
            setattr(self, attr, None***REMOVED***

    def __repr__(self***REMOVED***:
        l = [***REMOVED***
        for attr in self.__slots__:
            value = getattr(self, attr***REMOVED***
            if value is not None:
                l.append("%s=%s" % (attr, repr(value***REMOVED******REMOVED******REMOVED***
        return "%s(%s***REMOVED***" % (self.__class__.__name__, ", ".join(l***REMOVED******REMOVED***

    def __eq__(self, other***REMOVED***:
        if not isinstance(other, _ttinfo***REMOVED***:
            return False
        return (self.offset == other.offset and
                self.delta == other.delta and
                self.isdst == other.isdst and
                self.abbr == other.abbr and
                self.isstd == other.isstd and
                self.isgmt == other.isgmt***REMOVED***

    def __ne__(self, other***REMOVED***:
        return not self.__eq__(other***REMOVED***

    def __getstate__(self***REMOVED***:
        state = {***REMOVED***
        for name in self.__slots__:
            state[name***REMOVED*** = getattr(self, name, None***REMOVED***
        return state

    def __setstate__(self, state***REMOVED***:
        for name in self.__slots__:
            if name in state:
                setattr(self, name, state[name***REMOVED******REMOVED***


class tzfile(datetime.tzinfo***REMOVED***:

    # http://www.twinsun.com/tz/tz-link.htm
    # ftp://ftp.iana.org/tz/tz*.tar.gz

    def __init__(self, fileobj, filename=None***REMOVED***:
        file_opened_here = False
        if isinstance(fileobj, string_types***REMOVED***:
            self._filename = fileobj
            fileobj = open(fileobj, 'rb'***REMOVED***
            file_opened_here = True
        elif filename is not None:
            self._filename = filename
        elif hasattr(fileobj, "name"***REMOVED***:
            self._filename = fileobj.name
        else:
            self._filename = repr(fileobj***REMOVED***

        # From tzfile(5***REMOVED***:
        #
        # The time zone information files used by tzset(3***REMOVED***
        # begin with the magic characters "TZif" to identify
        # them as time zone information files, followed by
        # sixteen bytes reserved for future use, followed by
        # six four-byte values of type long, written in a
        # ``standard'' byte order (the high-order  byte
        # of the value is written first***REMOVED***.
        ***REMOVED***
            if fileobj.read(4***REMOVED***.decode(***REMOVED*** != "TZif":
                raise ValueError("magic not found"***REMOVED***

            fileobj.read(16***REMOVED***

            (
                # The number of UTC/local indicators stored in the file.
                ttisgmtcnt,

                # The number of standard/wall indicators stored in the file.
                ttisstdcnt,

                # The number of leap seconds for which data is
                # stored in the file.
                leapcnt,

                # The number of "transition times" for which data
                # is stored in the file.
                timecnt,

                # The number of "local time types" for which data
                # is stored in the file (must not be zero***REMOVED***.
                typecnt,

                # The  number  of  characters  of "time zone
                # abbreviation strings" stored in the file.
                charcnt,

            ***REMOVED*** = struct.unpack(">6l", fileobj.read(24***REMOVED******REMOVED***

            # The above header is followed by tzh_timecnt four-byte
            # values  of  type long,  sorted  in ascending order.
            # These values are written in ``standard'' byte order.
            # Each is used as a transition time (as  returned  by
            # time(2***REMOVED******REMOVED*** at which the rules for computing local time
            # change.

            if timecnt:
                self._trans_list = struct.unpack(">%dl" % timecnt,
                                                 fileobj.read(timecnt*4***REMOVED******REMOVED***
            else:
                self._trans_list = [***REMOVED***

            # Next come tzh_timecnt one-byte values of type unsigned
            # char; each one tells which of the different types of
            # ``local time'' types described in the file is associated
            # with the same-indexed transition time. These values
            # serve as indices into an array of ttinfo structures that
            # appears next in the file.

            if timecnt:
                self._trans_idx = struct.unpack(">%dB" % timecnt,
                                                fileobj.read(timecnt***REMOVED******REMOVED***
            else:
                self._trans_idx = [***REMOVED***

            # Each ttinfo structure is written as a four-byte value
            # for tt_gmtoff  of  type long,  in  a  standard  byte
            # order, followed  by a one-byte value for tt_isdst
            # and a one-byte  value  for  tt_abbrind.   In  each
            # structure, tt_gmtoff  gives  the  number  of
            # seconds to be added to UTC, tt_isdst tells whether
            # tm_isdst should be set by  localtime(3***REMOVED***,  and
            # tt_abbrind serves  as an index into the array of
            # time zone abbreviation characters that follow the
            # ttinfo structure(s***REMOVED*** in the file.

            ttinfo = [***REMOVED***

            for i in range(typecnt***REMOVED***:
                ttinfo.append(struct.unpack(">lbb", fileobj.read(6***REMOVED******REMOVED******REMOVED***

            abbr = fileobj.read(charcnt***REMOVED***.decode(***REMOVED***

            # Then there are tzh_leapcnt pairs of four-byte
            # values, written in  standard byte  order;  the
            # first  value  of  each pair gives the time (as
            # returned by time(2***REMOVED******REMOVED*** at which a leap second
            # occurs;  the  second  gives the  total  number of
            # leap seconds to be applied after the given time.
            # The pairs of values are sorted in ascending order
            # by time.

            # Not used, for now (but read anyway for correct file position***REMOVED***
            if leapcnt:
                leap = struct.unpack(">%dl" % (leapcnt*2***REMOVED***,
                                     fileobj.read(leapcnt*8***REMOVED******REMOVED***

            # Then there are tzh_ttisstdcnt standard/wall
            # indicators, each stored as a one-byte value;
            # they tell whether the transition times associated
            # with local time types were specified as standard
            # time or wall clock time, and are used when
            # a time zone file is used in handling POSIX-style
            # time zone environment variables.

            if ttisstdcnt:
                isstd = struct.unpack(">%db" % ttisstdcnt,
                                      fileobj.read(ttisstdcnt***REMOVED******REMOVED***

            # Finally, there are tzh_ttisgmtcnt UTC/local
            # indicators, each stored as a one-byte value;
            # they tell whether the transition times associated
            # with local time types were specified as UTC or
            # local time, and are used when a time zone file
            # is used in handling POSIX-style time zone envi-
            # ronment variables.

            if ttisgmtcnt:
                isgmt = struct.unpack(">%db" % ttisgmtcnt,
                                      fileobj.read(ttisgmtcnt***REMOVED******REMOVED***

            # ** Everything has been read **
        finally:
            if file_opened_here:
                fileobj.close(***REMOVED***

        # Build ttinfo list
        self._ttinfo_list = [***REMOVED***
        for i in range(typecnt***REMOVED***:
            gmtoff, isdst, abbrind = ttinfo[i***REMOVED***
            # Round to full-minutes if that's not the case. Python's
            # datetime doesn't accept sub-minute timezones. Check
            # http://python.org/sf/1447945 for some information.
            gmtoff = (gmtoff+30***REMOVED***//60*60
            tti = _ttinfo(***REMOVED***
            tti.offset = gmtoff
            tti.delta = datetime.timedelta(seconds=gmtoff***REMOVED***
            tti.isdst = isdst
            tti.abbr = abbr[abbrind:abbr.find('\x00', abbrind***REMOVED******REMOVED***
            tti.isstd = (ttisstdcnt > i and isstd[i***REMOVED*** != 0***REMOVED***
            tti.isgmt = (ttisgmtcnt > i and isgmt[i***REMOVED*** != 0***REMOVED***
            self._ttinfo_list.append(tti***REMOVED***

        # Replace ttinfo indexes for ttinfo objects.
        trans_idx = [***REMOVED***
        for idx in self._trans_idx:
            trans_idx.append(self._ttinfo_list[idx***REMOVED******REMOVED***
        self._trans_idx = tuple(trans_idx***REMOVED***

        # Set standard, dst, and before ttinfos. before will be
        # used when a given time is before any transitions,
        # and will be set to the first non-dst ttinfo, or to
        # the first dst, if all of them are dst.
        self._ttinfo_std = None
        self._ttinfo_dst = None
        self._ttinfo_before = None
        if self._ttinfo_list:
            if not self._trans_list:
                self._ttinfo_std = self._ttinfo_first = self._ttinfo_list[0***REMOVED***
            else:
                for i in range(timecnt-1, -1, -1***REMOVED***:
                    tti = self._trans_idx[i***REMOVED***
                    if not self._ttinfo_std and not tti.isdst:
                        self._ttinfo_std = tti
                    elif not self._ttinfo_dst and tti.isdst:
                        self._ttinfo_dst = tti
                    if self._ttinfo_std and self._ttinfo_dst:
                        break
                else:
                    if self._ttinfo_dst and not self._ttinfo_std:
                        self._ttinfo_std = self._ttinfo_dst

                for tti in self._ttinfo_list:
                    if not tti.isdst:
                        self._ttinfo_before = tti
                        break
                else:
                    self._ttinfo_before = self._ttinfo_list[0***REMOVED***

        # Now fix transition times to become relative to wall time.
        #
        # I'm not sure about this. In my tests, the tz source file
        # is setup to wall time, and in the binary file isstd and
        # isgmt are off, so it should be in wall time. OTOH, it's
        # always in gmt time. Let me know if you have comments
        # about this.
        laststdoffset = 0
        self._trans_list = list(self._trans_list***REMOVED***
        for i in range(len(self._trans_list***REMOVED******REMOVED***:
            tti = self._trans_idx[i***REMOVED***
            if not tti.isdst:
                # This is std time.
                self._trans_list[i***REMOVED*** += tti.offset
                laststdoffset = tti.offset
            else:
                # This is dst time. Convert to std.
                self._trans_list[i***REMOVED*** += laststdoffset
        self._trans_list = tuple(self._trans_list***REMOVED***

    def _find_ttinfo(self, dt, laststd=0***REMOVED***:
        timestamp = ((dt.toordinal(***REMOVED*** - EPOCHORDINAL***REMOVED*** * 86400
                     + dt.hour * 3600
                     + dt.minute * 60
                     + dt.second***REMOVED***
        idx = 0
        for trans in self._trans_list:
            if timestamp < trans:
                break
            idx += 1
        else:
            return self._ttinfo_std
        if idx == 0:
            return self._ttinfo_before
        if laststd:
            while idx > 0:
                tti = self._trans_idx[idx-1***REMOVED***
                if not tti.isdst:
                    return tti
                idx -= 1
            else:
                return self._ttinfo_std
        else:
            return self._trans_idx[idx-1***REMOVED***

    def utcoffset(self, dt***REMOVED***:
        if dt is None:
            return None

        if not self._ttinfo_std:
            return ZERO
        return self._find_ttinfo(dt***REMOVED***.delta

    def dst(self, dt***REMOVED***:
        if not self._ttinfo_dst:
            return ZERO
        tti = self._find_ttinfo(dt***REMOVED***
        if not tti.isdst:
            return ZERO

        # The documentation says that utcoffset(***REMOVED***-dst(***REMOVED*** must
        # be constant for every dt.
        return tti.delta-self._find_ttinfo(dt, laststd=1***REMOVED***.delta

        # An alternative for that would be:
        #
        # return self._ttinfo_dst.offset-self._ttinfo_std.offset
        #
        # However, this class stores historical changes in the
        # dst offset, so I belive that this wouldn't be the right
        # way to implement this.

    @tzname_in_python2
    def tzname(self, dt***REMOVED***:
        if not self._ttinfo_std:
            return None
        return self._find_ttinfo(dt***REMOVED***.abbr

    def __eq__(self, other***REMOVED***:
        if not isinstance(other, tzfile***REMOVED***:
            return False
        return (self._trans_list == other._trans_list and
                self._trans_idx == other._trans_idx and
                self._ttinfo_list == other._ttinfo_list***REMOVED***

    def __ne__(self, other***REMOVED***:
        return not self.__eq__(other***REMOVED***

    def __repr__(self***REMOVED***:
        return "%s(%s***REMOVED***" % (self.__class__.__name__, repr(self._filename***REMOVED******REMOVED***

    def __reduce__(self***REMOVED***:
        if not os.path.isfile(self._filename***REMOVED***:
            raise ValueError("Unpickable %s class" % self.__class__.__name__***REMOVED***
        return (self.__class__, (self._filename,***REMOVED******REMOVED***


class tzrange(datetime.tzinfo***REMOVED***:
    def __init__(self, stdabbr, stdoffset=None,
                 dstabbr=None, dstoffset=None,
                 start=None, end=None***REMOVED***:
        global relativedelta
        if not relativedelta:
            from dateutil import relativedelta
        self._std_abbr = stdabbr
        self._dst_abbr = dstabbr
        if stdoffset is not None:
            self._std_offset = datetime.timedelta(seconds=stdoffset***REMOVED***
        else:
            self._std_offset = ZERO
        if dstoffset is not None:
            self._dst_offset = datetime.timedelta(seconds=dstoffset***REMOVED***
        elif dstabbr and stdoffset is not None:
            self._dst_offset = self._std_offset+datetime.timedelta(hours=+1***REMOVED***
        else:
            self._dst_offset = ZERO
        if dstabbr and start is None:
            self._start_delta = relativedelta.relativedelta(
                hours=+2, month=4, day=1, weekday=relativedelta.SU(+1***REMOVED******REMOVED***
        else:
            self._start_delta = start
        if dstabbr and end is None:
            self._end_delta = relativedelta.relativedelta(
                hours=+1, month=10, day=31, weekday=relativedelta.SU(-1***REMOVED******REMOVED***
        else:
            self._end_delta = end

    def utcoffset(self, dt***REMOVED***:
        if dt is None:
            return None

        if self._isdst(dt***REMOVED***:
            return self._dst_offset
        else:
            return self._std_offset

    def dst(self, dt***REMOVED***:
        if self._isdst(dt***REMOVED***:
            return self._dst_offset-self._std_offset
        else:
            return ZERO

    @tzname_in_python2
    def tzname(self, dt***REMOVED***:
        if self._isdst(dt***REMOVED***:
            return self._dst_abbr
        else:
            return self._std_abbr

    def _isdst(self, dt***REMOVED***:
        if not self._start_delta:
            return False
        year = datetime.datetime(dt.year, 1, 1***REMOVED***
        start = year+self._start_delta
        end = year+self._end_delta
        dt = dt.replace(tzinfo=None***REMOVED***
        if start < end:
            return dt >= start and dt < end
        else:
            return dt >= start or dt < end

    def __eq__(self, other***REMOVED***:
        if not isinstance(other, tzrange***REMOVED***:
            return False
        return (self._std_abbr == other._std_abbr and
                self._dst_abbr == other._dst_abbr and
                self._std_offset == other._std_offset and
                self._dst_offset == other._dst_offset and
                self._start_delta == other._start_delta and
                self._end_delta == other._end_delta***REMOVED***

    def __ne__(self, other***REMOVED***:
        return not self.__eq__(other***REMOVED***

    def __repr__(self***REMOVED***:
        return "%s(...***REMOVED***" % self.__class__.__name__

    __reduce__ = object.__reduce__


class tzstr(tzrange***REMOVED***:

    def __init__(self, s***REMOVED***:
        global parser
        if not parser:
            from dateutil import parser
        self._s = s

        res = parser._parsetz(s***REMOVED***
        if res is None:
            raise ValueError("unknown string format"***REMOVED***

        # Here we break the compatibility with the TZ variable handling.
        # GMT-3 actually *means* the timezone -3.
        if res.stdabbr in ("GMT", "UTC"***REMOVED***:
            res.stdoffset *= -1

        # We must initialize it first, since _delta(***REMOVED*** needs
        # _std_offset and _dst_offset set. Use False in start/end
        # to avoid building it two times.
        tzrange.__init__(self, res.stdabbr, res.stdoffset,
                         res.dstabbr, res.dstoffset,
                         start=False, end=False***REMOVED***

        if not res.dstabbr:
            self._start_delta = None
            self._end_delta = None
        else:
            self._start_delta = self._delta(res.start***REMOVED***
            if self._start_delta:
                self._end_delta = self._delta(res.end, isend=1***REMOVED***

    def _delta(self, x, isend=0***REMOVED***:
        kwargs = {***REMOVED***
        if x.month is not None:
            kwargs["month"***REMOVED*** = x.month
            if x.weekday is not None:
                kwargs["weekday"***REMOVED*** = relativedelta.weekday(x.weekday, x.week***REMOVED***
                if x.week > 0:
                    kwargs["day"***REMOVED*** = 1
                else:
                    kwargs["day"***REMOVED*** = 31
            elif x.day:
                kwargs["day"***REMOVED*** = x.day
        elif x.yday is not None:
            kwargs["yearday"***REMOVED*** = x.yday
        elif x.jyday is not None:
            kwargs["nlyearday"***REMOVED*** = x.jyday
        if not kwargs:
            # Default is to start on first sunday of april, and end
            # on last sunday of october.
            if not isend:
                kwargs["month"***REMOVED*** = 4
                kwargs["day"***REMOVED*** = 1
                kwargs["weekday"***REMOVED*** = relativedelta.SU(+1***REMOVED***
            else:
                kwargs["month"***REMOVED*** = 10
                kwargs["day"***REMOVED*** = 31
                kwargs["weekday"***REMOVED*** = relativedelta.SU(-1***REMOVED***
        if x.time is not None:
            kwargs["seconds"***REMOVED*** = x.time
        else:
            # Default is 2AM.
            kwargs["seconds"***REMOVED*** = 7200
        if isend:
            # Convert to standard time, to follow the documented way
            # of working with the extra hour. See the documentation
            # of the tzinfo class.
            delta = self._dst_offset-self._std_offset
            kwargs["seconds"***REMOVED*** -= delta.seconds+delta.days*86400
        return relativedelta.relativedelta(**kwargs***REMOVED***

    def __repr__(self***REMOVED***:
        return "%s(%s***REMOVED***" % (self.__class__.__name__, repr(self._s***REMOVED******REMOVED***


class _tzicalvtzcomp(object***REMOVED***:
    def __init__(self, tzoffsetfrom, tzoffsetto, isdst,
                 tzname=None, rrule=None***REMOVED***:
        self.tzoffsetfrom = datetime.timedelta(seconds=tzoffsetfrom***REMOVED***
        self.tzoffsetto = datetime.timedelta(seconds=tzoffsetto***REMOVED***
        self.tzoffsetdiff = self.tzoffsetto-self.tzoffsetfrom
        self.isdst = isdst
        self.tzname = tzname
        self.rrule = rrule


class _tzicalvtz(datetime.tzinfo***REMOVED***:
    def __init__(self, tzid, comps=[***REMOVED******REMOVED***:
        self._tzid = tzid
        self._comps = comps
        self._cachedate = [***REMOVED***
        self._cachecomp = [***REMOVED***

    def _find_comp(self, dt***REMOVED***:
        if len(self._comps***REMOVED*** == 1:
            return self._comps[0***REMOVED***
        dt = dt.replace(tzinfo=None***REMOVED***
        ***REMOVED***
            return self._cachecomp[self._cachedate.index(dt***REMOVED******REMOVED***
        except ValueError:
            pass
        lastcomp = None
        lastcompdt = None
        for comp in self._comps:
            if not comp.isdst:
                # Handle the extra hour in DST -> STD
                compdt = comp.rrule.before(dt-comp.tzoffsetdiff, inc=True***REMOVED***
            else:
                compdt = comp.rrule.before(dt, inc=True***REMOVED***
            if compdt and (not lastcompdt or lastcompdt < compdt***REMOVED***:
                lastcompdt = compdt
                lastcomp = comp
        if not lastcomp:
            # RFC says nothing about what to do when a given
            # time is before the first onset date. We'll look for the
            # first standard component, or the first component, if
            # none is found.
            for comp in self._comps:
                if not comp.isdst:
                    lastcomp = comp
                    break
            else:
                lastcomp = comp[0***REMOVED***
        self._cachedate.insert(0, dt***REMOVED***
        self._cachecomp.insert(0, lastcomp***REMOVED***
        if len(self._cachedate***REMOVED*** > 10:
            self._cachedate.pop(***REMOVED***
            self._cachecomp.pop(***REMOVED***
        return lastcomp

    def utcoffset(self, dt***REMOVED***:
        if dt is None:
            return None

        return self._find_comp(dt***REMOVED***.tzoffsetto

    def dst(self, dt***REMOVED***:
        comp = self._find_comp(dt***REMOVED***
        if comp.isdst:
            return comp.tzoffsetdiff
        else:
            return ZERO

    @tzname_in_python2
    def tzname(self, dt***REMOVED***:
        return self._find_comp(dt***REMOVED***.tzname

    def __repr__(self***REMOVED***:
        return "<tzicalvtz %s>" % repr(self._tzid***REMOVED***

    __reduce__ = object.__reduce__


class tzical(object***REMOVED***:
    def __init__(self, fileobj***REMOVED***:
        global rrule
        if not rrule:
            from dateutil import rrule

        if isinstance(fileobj, string_types***REMOVED***:
            self._s = fileobj
            # ical should be encoded in UTF-8 with CRLF
            fileobj = open(fileobj, 'r'***REMOVED***
        elif hasattr(fileobj, "name"***REMOVED***:
            self._s = fileobj.name
        else:
            self._s = repr(fileobj***REMOVED***

        self._vtz = {***REMOVED***

        self._parse_rfc(fileobj.read(***REMOVED******REMOVED***

    def keys(self***REMOVED***:
        return list(self._vtz.keys(***REMOVED******REMOVED***

    def get(self, tzid=None***REMOVED***:
        if tzid is None:
            keys = list(self._vtz.keys(***REMOVED******REMOVED***
            if len(keys***REMOVED*** == 0:
                raise ValueError("no timezones defined"***REMOVED***
            elif len(keys***REMOVED*** > 1:
                raise ValueError("more than one timezone available"***REMOVED***
            tzid = keys[0***REMOVED***
        return self._vtz.get(tzid***REMOVED***

    def _parse_offset(self, s***REMOVED***:
        s = s.strip(***REMOVED***
        if not s:
            raise ValueError("empty offset"***REMOVED***
        if s[0***REMOVED*** in ('+', '-'***REMOVED***:
            signal = (-1, +1***REMOVED***[s[0***REMOVED*** == '+'***REMOVED***
            s = s[1:***REMOVED***
        else:
            signal = +1
        if len(s***REMOVED*** == 4:
            return (int(s[:2***REMOVED******REMOVED****3600+int(s[2:***REMOVED******REMOVED****60***REMOVED****signal
        elif len(s***REMOVED*** == 6:
            return (int(s[:2***REMOVED******REMOVED****3600+int(s[2:4***REMOVED******REMOVED****60+int(s[4:***REMOVED******REMOVED******REMOVED****signal
        else:
            raise ValueError("invalid offset: "+s***REMOVED***

    def _parse_rfc(self, s***REMOVED***:
        lines = s.splitlines(***REMOVED***
        if not lines:
            raise ValueError("empty string"***REMOVED***

        # Unfold
        i = 0
        while i < len(lines***REMOVED***:
            line = lines[i***REMOVED***.rstrip(***REMOVED***
            if not line:
                del lines[i***REMOVED***
            elif i > 0 and line[0***REMOVED*** == " ":
                lines[i-1***REMOVED*** += line[1:***REMOVED***
                del lines[i***REMOVED***
            else:
                i += 1

        tzid = None
        comps = [***REMOVED***
        invtz = False
        comptype = None
        for line in lines:
            if not line:
                continue
            name, value = line.split(':', 1***REMOVED***
            parms = name.split(';'***REMOVED***
            if not parms:
                raise ValueError("empty property name"***REMOVED***
            name = parms[0***REMOVED***.upper(***REMOVED***
            parms = parms[1:***REMOVED***
            if invtz:
                if name == "BEGIN":
                    if value in ("STANDARD", "DAYLIGHT"***REMOVED***:
                        # Process component
                        pass
                    else:
                        raise ValueError("unknown component: "+value***REMOVED***
                    comptype = value
                    founddtstart = False
                    tzoffsetfrom = None
                    tzoffsetto = None
                    rrulelines = [***REMOVED***
                    tzname = None
                elif name == "END":
                    if value == "VTIMEZONE":
                        if comptype:
                            raise ValueError("component not closed: "+comptype***REMOVED***
                        if not tzid:
                            raise ValueError("mandatory TZID not found"***REMOVED***
                        if not comps:
                            raise ValueError(
                                "at least one component is needed"***REMOVED***
                        # Process vtimezone
                        self._vtz[tzid***REMOVED*** = _tzicalvtz(tzid, comps***REMOVED***
                        invtz = False
                    elif value == comptype:
                        if not founddtstart:
                            raise ValueError("mandatory DTSTART not found"***REMOVED***
                        if tzoffsetfrom is None:
                            raise ValueError(
                                "mandatory TZOFFSETFROM not found"***REMOVED***
                        if tzoffsetto is None:
                            raise ValueError(
                                "mandatory TZOFFSETFROM not found"***REMOVED***
                        # Process component
                        rr = None
                        if rrulelines:
                            rr = rrule.rrulestr("\n".join(rrulelines***REMOVED***,
                                                compatible=True,
                                                ignoretz=True,
                                                cache=True***REMOVED***
                        comp = _tzicalvtzcomp(tzoffsetfrom, tzoffsetto,
                                              (comptype == "DAYLIGHT"***REMOVED***,
                                              tzname, rr***REMOVED***
                        comps.append(comp***REMOVED***
                        comptype = None
                    else:
                        raise ValueError("invalid component end: "+value***REMOVED***
                elif comptype:
                    if name == "DTSTART":
                        rrulelines.append(line***REMOVED***
                        founddtstart = True
                    elif name in ("RRULE", "RDATE", "EXRULE", "EXDATE"***REMOVED***:
                        rrulelines.append(line***REMOVED***
                    elif name == "TZOFFSETFROM":
                        if parms:
                            raise ValueError(
                                "unsupported %s parm: %s " % (name, parms[0***REMOVED******REMOVED******REMOVED***
                        tzoffsetfrom = self._parse_offset(value***REMOVED***
                    elif name == "TZOFFSETTO":
                        if parms:
                            raise ValueError(
                                "unsupported TZOFFSETTO parm: "+parms[0***REMOVED******REMOVED***
                        tzoffsetto = self._parse_offset(value***REMOVED***
                    elif name == "TZNAME":
                        if parms:
                            raise ValueError(
                                "unsupported TZNAME parm: "+parms[0***REMOVED******REMOVED***
                        tzname = value
                    elif name == "COMMENT":
                        pass
                    else:
                        raise ValueError("unsupported property: "+name***REMOVED***
                else:
                    if name == "TZID":
                        if parms:
                            raise ValueError(
                                "unsupported TZID parm: "+parms[0***REMOVED******REMOVED***
                        tzid = value
                    elif name in ("TZURL", "LAST-MODIFIED", "COMMENT"***REMOVED***:
                        pass
                    else:
                        raise ValueError("unsupported property: "+name***REMOVED***
            elif name == "BEGIN" and value == "VTIMEZONE":
                tzid = None
                comps = [***REMOVED***
                invtz = True

    def __repr__(self***REMOVED***:
        return "%s(%s***REMOVED***" % (self.__class__.__name__, repr(self._s***REMOVED******REMOVED***

if sys.platform != "win32":
    TZFILES = ["/etc/localtime", "localtime"***REMOVED***
    TZPATHS = ["/usr/share/zoneinfo", "/usr/lib/zoneinfo", "/etc/zoneinfo"***REMOVED***
else:
    TZFILES = [***REMOVED***
    TZPATHS = [***REMOVED***


def gettz(name=None***REMOVED***:
    tz = None
    if not name:
        ***REMOVED***
            name = os.environ["TZ"***REMOVED***
        except KeyError:
            pass
    if name is None or name == ":":
        for filepath in TZFILES:
            if not os.path.isabs(filepath***REMOVED***:
                filename = filepath
                for path in TZPATHS:
                    filepath = os.path.join(path, filename***REMOVED***
                    if os.path.isfile(filepath***REMOVED***:
                        break
                else:
                    continue
            if os.path.isfile(filepath***REMOVED***:
                ***REMOVED***
                    tz = tzfile(filepath***REMOVED***
                    break
                except (IOError, OSError, ValueError***REMOVED***:
                    pass
        else:
            tz = tzlocal(***REMOVED***
    else:
        if name.startswith(":"***REMOVED***:
            name = name[:-1***REMOVED***
        if os.path.isabs(name***REMOVED***:
            if os.path.isfile(name***REMOVED***:
                tz = tzfile(name***REMOVED***
            else:
                tz = None
        else:
            for path in TZPATHS:
                filepath = os.path.join(path, name***REMOVED***
                if not os.path.isfile(filepath***REMOVED***:
                    filepath = filepath.replace(' ', '_'***REMOVED***
                    if not os.path.isfile(filepath***REMOVED***:
                        continue
                ***REMOVED***
                    tz = tzfile(filepath***REMOVED***
                    break
                except (IOError, OSError, ValueError***REMOVED***:
                    pass
            else:
                tz = None
                if tzwin is not None:
                    ***REMOVED***
                        tz = tzwin(name***REMOVED***
                    except WindowsError:
                        tz = None
                if not tz:
                    from dateutil.zoneinfo import gettz
                    tz = gettz(name***REMOVED***
                if not tz:
                    for c in name:
                        # name must have at least one offset to be a tzstr
                        if c in "0123456789":
                            ***REMOVED***
                                tz = tzstr(name***REMOVED***
                            except ValueError:
                                pass
                            break
                    else:
                        if name in ("GMT", "UTC"***REMOVED***:
                            tz = tzutc(***REMOVED***
                        elif name in time.tzname:
                            tz = tzlocal(***REMOVED***
    return tz

# vim:ts=4:sw=4:et
