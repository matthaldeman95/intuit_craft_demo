***REMOVED***
Helper functions for creating Form classes from Django models
and database field objects.
***REMOVED***

from __future__ import unicode_literals

from collections import OrderedDict
from itertools import chain

from django.core.exceptions import (
    NON_FIELD_ERRORS, FieldError, ImproperlyConfigured, ValidationError,
***REMOVED***
from django.forms.fields import ChoiceField, Field
from django.forms.forms import BaseForm, DeclarativeFieldsMetaclass
from django.forms.formsets import BaseFormSet, formset_factory
from django.forms.utils import ErrorList
from django.forms.widgets import (
    HiddenInput, MultipleHiddenInput, SelectMultiple,
***REMOVED***
from django.utils import six
from django.utils.encoding import force_text, smart_text
from django.utils.text import capfirst, get_text_list
from django.utils.translation import ugettext, ugettext_lazy as _

__all__ = (
    'ModelForm', 'BaseModelForm', 'model_to_dict', 'fields_for_model',
    'ModelChoiceField', 'ModelMultipleChoiceField', 'ALL_FIELDS',
    'BaseModelFormSet', 'modelformset_factory', 'BaseInlineFormSet',
    'inlineformset_factory', 'modelform_factory',
***REMOVED***

ALL_FIELDS = '__all__'


def construct_instance(form, instance, fields=None, exclude=None***REMOVED***:
    ***REMOVED***
    Constructs and returns a model instance from the bound ``form``'s
    ``cleaned_data``, but does not save the returned instance to the
    database.
    ***REMOVED***
    from django.db import models
    opts = instance._meta

    cleaned_data = form.cleaned_data
    file_field_list = [***REMOVED***
    for f in opts.fields:
        if not f.editable or isinstance(f, models.AutoField***REMOVED*** \
                or f.name not in cleaned_data:
            continue
        if fields is not None and f.name not in fields:
            continue
        if exclude and f.name in exclude:
            continue
        # Leave defaults for fields that aren't in POST data, except for
        # checkbox inputs because they don't appear in POST data if not checked.
        if (f.has_default(***REMOVED*** and
                form[f.name***REMOVED***.field.widget.value_omitted_from_data(form.data, form.files, form.add_prefix(f.name***REMOVED******REMOVED******REMOVED***:
            continue
        # Defer saving file-type fields until after the other fields, so a
        # callable upload_to can use the values from other fields.
        if isinstance(f, models.FileField***REMOVED***:
            file_field_list.append(f***REMOVED***
        else:
            f.save_form_data(instance, cleaned_data[f.name***REMOVED******REMOVED***

    for f in file_field_list:
        f.save_form_data(instance, cleaned_data[f.name***REMOVED******REMOVED***

    return instance


# ModelForms #################################################################

def model_to_dict(instance, fields=None, exclude=None***REMOVED***:
    ***REMOVED***
    Returns a dict containing the data in ``instance`` suitable for passing as
    a Form's ``initial`` keyword argument.

    ``fields`` is an optional list of field names. If provided, only the named
    fields will be included in the returned dict.

    ``exclude`` is an optional list of field names. If provided, the named
    fields will be excluded from the returned dict, even if they are listed in
    the ``fields`` argument.
    ***REMOVED***
    opts = instance._meta
    data = {***REMOVED***
    for f in chain(opts.concrete_fields, opts.private_fields, opts.many_to_many***REMOVED***:
        if not getattr(f, 'editable', False***REMOVED***:
            continue
        if fields and f.name not in fields:
            continue
        if exclude and f.name in exclude:
            continue
        data[f.name***REMOVED*** = f.value_from_object(instance***REMOVED***
    return data


def fields_for_model(model, fields=None, exclude=None, widgets=None,
                     formfield_callback=None, localized_fields=None,
                     labels=None, help_texts=None, error_messages=None,
                     field_classes=None***REMOVED***:
    ***REMOVED***
    Returns a ``OrderedDict`` containing form fields for the given model.

    ``fields`` is an optional list of field names. If provided, only the named
    fields will be included in the returned fields.

    ``exclude`` is an optional list of field names. If provided, the named
    fields will be excluded from the returned fields, even if they are listed
    in the ``fields`` argument.

    ``widgets`` is a dictionary of model field names mapped to a widget.

    ``formfield_callback`` is a callable that takes a model field and returns
    a form field.

    ``localized_fields`` is a list of names of fields which should be localized.

    ``labels`` is a dictionary of model field names mapped to a label.

    ``help_texts`` is a dictionary of model field names mapped to a help text.

    ``error_messages`` is a dictionary of model field names mapped to a
    dictionary of error messages.

    ``field_classes`` is a dictionary of model field names mapped to a form
    field class.
    ***REMOVED***
    field_list = [***REMOVED***
    ignored = [***REMOVED***
    opts = model._meta
    # Avoid circular import
    from django.db.models.fields import Field as ModelField
    sortable_private_fields = [f for f in opts.private_fields if isinstance(f, ModelField***REMOVED******REMOVED***
    for f in sorted(chain(opts.concrete_fields, sortable_private_fields, opts.many_to_many***REMOVED******REMOVED***:
        if not getattr(f, 'editable', False***REMOVED***:
            if (fields is not None and f.name in fields and
                    (exclude is None or f.name not in exclude***REMOVED******REMOVED***:
                raise FieldError(
                    "'%s' cannot be specified for %s model form as it is a non-editable field" % (
                        f.name, model.__name__***REMOVED***
                ***REMOVED***
            continue
        if fields is not None and f.name not in fields:
            continue
        if exclude and f.name in exclude:
            continue

        kwargs = {***REMOVED***
        if widgets and f.name in widgets:
            kwargs['widget'***REMOVED*** = widgets[f.name***REMOVED***
        if localized_fields == ALL_FIELDS or (localized_fields and f.name in localized_fields***REMOVED***:
            kwargs['localize'***REMOVED*** = True
        if labels and f.name in labels:
            kwargs['label'***REMOVED*** = labels[f.name***REMOVED***
        if help_texts and f.name in help_texts:
            kwargs['help_text'***REMOVED*** = help_texts[f.name***REMOVED***
        if error_messages and f.name in error_messages:
            kwargs['error_messages'***REMOVED*** = error_messages[f.name***REMOVED***
        if field_classes and f.name in field_classes:
            kwargs['form_class'***REMOVED*** = field_classes[f.name***REMOVED***

        if formfield_callback is None:
            formfield = f.formfield(**kwargs***REMOVED***
        elif not callable(formfield_callback***REMOVED***:
            raise TypeError('formfield_callback must be a function or callable'***REMOVED***
        else:
            formfield = formfield_callback(f, **kwargs***REMOVED***

        if formfield:
            field_list.append((f.name, formfield***REMOVED******REMOVED***
        else:
            ignored.append(f.name***REMOVED***
    field_dict = OrderedDict(field_list***REMOVED***
    if fields:
        field_dict = OrderedDict(
            [(f, field_dict.get(f***REMOVED******REMOVED*** for f in fields
                if ((not exclude***REMOVED*** or (exclude and f not in exclude***REMOVED******REMOVED*** and (f not in ignored***REMOVED******REMOVED***
        ***REMOVED***
    return field_dict


class ModelFormOptions(object***REMOVED***:
    def __init__(self, options=None***REMOVED***:
        self.model = getattr(options, 'model', None***REMOVED***
        self.fields = getattr(options, 'fields', None***REMOVED***
        self.exclude = getattr(options, 'exclude', None***REMOVED***
        self.widgets = getattr(options, 'widgets', None***REMOVED***
        self.localized_fields = getattr(options, 'localized_fields', None***REMOVED***
        self.labels = getattr(options, 'labels', None***REMOVED***
        self.help_texts = getattr(options, 'help_texts', None***REMOVED***
        self.error_messages = getattr(options, 'error_messages', None***REMOVED***
        self.field_classes = getattr(options, 'field_classes', None***REMOVED***


class ModelFormMetaclass(DeclarativeFieldsMetaclass***REMOVED***:
    def __new__(mcs, name, bases, attrs***REMOVED***:
        base_formfield_callback = None
        for b in bases:
            if hasattr(b, 'Meta'***REMOVED*** and hasattr(b.Meta, 'formfield_callback'***REMOVED***:
                base_formfield_callback = b.Meta.formfield_callback
                break

        formfield_callback = attrs.pop('formfield_callback', base_formfield_callback***REMOVED***

        new_class = super(ModelFormMetaclass, mcs***REMOVED***.__new__(mcs, name, bases, attrs***REMOVED***

        if bases == (BaseModelForm,***REMOVED***:
            return new_class

        opts = new_class._meta = ModelFormOptions(getattr(new_class, 'Meta', None***REMOVED******REMOVED***

        # We check if a string was passed to `fields` or `exclude`,
        # which is likely to be a mistake where the user typed ('foo'***REMOVED*** instead
        # of ('foo',***REMOVED***
        for opt in ['fields', 'exclude', 'localized_fields'***REMOVED***:
            value = getattr(opts, opt***REMOVED***
            if isinstance(value, six.string_types***REMOVED*** and value != ALL_FIELDS:
                msg = ("%(model***REMOVED***s.Meta.%(opt***REMOVED***s cannot be a string. "
                       "Did you mean to type: ('%(value***REMOVED***s',***REMOVED***?" % {
                           'model': new_class.__name__,
                           'opt': opt,
                           'value': value,
                   ***REMOVED******REMOVED***
                raise TypeError(msg***REMOVED***

        if opts.model:
            # If a model is defined, extract form fields from it.
            if opts.fields is None and opts.exclude is None:
                raise ImproperlyConfigured(
                    "Creating a ModelForm without either the 'fields' attribute "
                    "or the 'exclude' attribute is prohibited; form %s "
                    "needs updating." % name
                ***REMOVED***

            if opts.fields == ALL_FIELDS:
                # Sentinel for fields_for_model to indicate "get the list of
                # fields from the model"
                opts.fields = None

            fields = fields_for_model(opts.model, opts.fields, opts.exclude,
                                      opts.widgets, formfield_callback,
                                      opts.localized_fields, opts.labels,
                                      opts.help_texts, opts.error_messages,
                                      opts.field_classes***REMOVED***

            # make sure opts.fields doesn't specify an invalid field
            none_model_fields = [k for k, v in six.iteritems(fields***REMOVED*** if not v***REMOVED***
            missing_fields = (set(none_model_fields***REMOVED*** -
                              set(new_class.declared_fields.keys(***REMOVED******REMOVED******REMOVED***
            if missing_fields:
                message = 'Unknown field(s***REMOVED*** (%s***REMOVED*** specified for %s'
                message = message % (', '.join(missing_fields***REMOVED***,
                                     opts.model.__name__***REMOVED***
                raise FieldError(message***REMOVED***
            # Override default model fields with any custom declared ones
            # (plus, include all the other declared fields***REMOVED***.
            fields.update(new_class.declared_fields***REMOVED***
        else:
            fields = new_class.declared_fields

        new_class.base_fields = fields

        return new_class


class BaseModelForm(BaseForm***REMOVED***:
    def __init__(self, data=None, files=None, auto_id='id_%s', prefix=None,
                 initial=None, error_class=ErrorList, label_suffix=None,
                 empty_permitted=False, instance=None, use_required_attribute=None***REMOVED***:
        opts = self._meta
        if opts.model is None:
            raise ValueError('ModelForm has no model class specified.'***REMOVED***
        if instance is None:
            # if we didn't get an instance, instantiate a new one
            self.instance = opts.model(***REMOVED***
            object_data = {***REMOVED***
        else:
            self.instance = instance
            object_data = model_to_dict(instance, opts.fields, opts.exclude***REMOVED***
        # if initial was provided, it should override the values from instance
        if initial is not None:
            object_data.update(initial***REMOVED***
        # self._validate_unique will be set to True by BaseModelForm.clean(***REMOVED***.
        # It is False by default so overriding self.clean(***REMOVED*** and failing to call
        # super will stop validate_unique from being called.
        self._validate_unique = False
        super(BaseModelForm, self***REMOVED***.__init__(
            data, files, auto_id, prefix, object_data, error_class,
            label_suffix, empty_permitted, use_required_attribute=use_required_attribute,
        ***REMOVED***
        # Apply ``limit_choices_to`` to each field.
        for field_name in self.fields:
            formfield = self.fields[field_name***REMOVED***
            if hasattr(formfield, 'queryset'***REMOVED*** and hasattr(formfield, 'get_limit_choices_to'***REMOVED***:
                limit_choices_to = formfield.get_limit_choices_to(***REMOVED***
                if limit_choices_to is not None:
                    formfield.queryset = formfield.queryset.complex_filter(limit_choices_to***REMOVED***

    def _get_validation_exclusions(self***REMOVED***:
        ***REMOVED***
        For backwards-compatibility, several types of fields need to be
        excluded from model validation. See the following tickets for
        details: #12507, #12521, #12553
        ***REMOVED***
        exclude = [***REMOVED***
        # Build up a list of fields that should be excluded from model field
        # validation and unique checks.
        for f in self.instance._meta.fields:
            field = f.name
            # Exclude fields that aren't on the form. The developer may be
            # adding these values to the model after form validation.
            if field not in self.fields:
                exclude.append(f.name***REMOVED***

            # Don't perform model validation on fields that were defined
            # manually on the form and excluded via the ModelForm's Meta
            # class. See #12901.
            elif self._meta.fields and field not in self._meta.fields:
                exclude.append(f.name***REMOVED***
            elif self._meta.exclude and field in self._meta.exclude:
                exclude.append(f.name***REMOVED***

            # Exclude fields that failed form validation. There's no need for
            # the model fields to validate them as well.
            elif field in self._errors.keys(***REMOVED***:
                exclude.append(f.name***REMOVED***

            # Exclude empty fields that are not required by the form, if the
            # underlying model field is required. This keeps the model field
            # from raising a required error. Note: don't exclude the field from
            # validation if the model field allows blanks. If it does, the blank
            # value may be included in a unique check, so cannot be excluded
            # from validation.
            else:
                form_field = self.fields[field***REMOVED***
                field_value = self.cleaned_data.get(field***REMOVED***
                if not f.blank and not form_field.required and field_value in form_field.empty_values:
                    exclude.append(f.name***REMOVED***
        return exclude

    def clean(self***REMOVED***:
        self._validate_unique = True
        return self.cleaned_data

    def _update_errors(self, errors***REMOVED***:
        # Override any validation error messages defined at the model level
        # with those defined at the form level.
        opts = self._meta

        # Allow the model generated by construct_instance(***REMOVED*** to raise
        # ValidationError and have them handled in the same way as others.
        if hasattr(errors, 'error_dict'***REMOVED***:
            error_dict = errors.error_dict
        else:
            error_dict = {NON_FIELD_ERRORS: errors***REMOVED***

        for field, messages in error_dict.items(***REMOVED***:
            if (field == NON_FIELD_ERRORS and opts.error_messages and
                    NON_FIELD_ERRORS in opts.error_messages***REMOVED***:
                error_messages = opts.error_messages[NON_FIELD_ERRORS***REMOVED***
            elif field in self.fields:
                error_messages = self.fields[field***REMOVED***.error_messages
            else:
                continue

            for message in messages:
                if (isinstance(message, ValidationError***REMOVED*** and
                        message.code in error_messages***REMOVED***:
                    message.message = error_messages[message.code***REMOVED***

        self.add_error(None, errors***REMOVED***

    def _post_clean(self***REMOVED***:
        opts = self._meta

        exclude = self._get_validation_exclusions(***REMOVED***

        # Foreign Keys being used to represent inline relationships
        # are excluded from basic field value validation. This is for two
        # reasons: firstly, the value may not be supplied (#12507; the
        # case of providing new values to the admin***REMOVED***; secondly the
        # object being referred to may not yet fully exist (#12749***REMOVED***.
        # However, these fields *must* be included in uniqueness checks,
        # so this can't be part of _get_validation_exclusions(***REMOVED***.
        for name, field in self.fields.items(***REMOVED***:
            if isinstance(field, InlineForeignKeyField***REMOVED***:
                exclude.append(name***REMOVED***

        ***REMOVED***
            self.instance = construct_instance(self, self.instance, opts.fields, opts.exclude***REMOVED***
        except ValidationError as e:
            self._update_errors(e***REMOVED***

        ***REMOVED***
            self.instance.full_clean(exclude=exclude, validate_unique=False***REMOVED***
        except ValidationError as e:
            self._update_errors(e***REMOVED***

        # Validate uniqueness if needed.
        if self._validate_unique:
            self.validate_unique(***REMOVED***

    def validate_unique(self***REMOVED***:
        ***REMOVED***
        Calls the instance's validate_unique(***REMOVED*** method and updates the form's
        validation errors if any were raised.
        ***REMOVED***
        exclude = self._get_validation_exclusions(***REMOVED***
        ***REMOVED***
            self.instance.validate_unique(exclude=exclude***REMOVED***
        except ValidationError as e:
            self._update_errors(e***REMOVED***

    def _save_m2m(self***REMOVED***:
        ***REMOVED***
        Save the many-to-many fields and generic relations for this form.
        ***REMOVED***
        cleaned_data = self.cleaned_data
        exclude = self._meta.exclude
        fields = self._meta.fields
        opts = self.instance._meta
        # Note that for historical reasons we want to include also
        # private_fields here. (GenericRelation was previously a fake
        # m2m field***REMOVED***.
        for f in chain(opts.many_to_many, opts.private_fields***REMOVED***:
            if not hasattr(f, 'save_form_data'***REMOVED***:
                continue
            if fields and f.name not in fields:
                continue
            if exclude and f.name in exclude:
                continue
            if f.name in cleaned_data:
                f.save_form_data(self.instance, cleaned_data[f.name***REMOVED******REMOVED***

    def save(self, commit=True***REMOVED***:
        ***REMOVED***
        Save this form's self.instance object if commit=True. Otherwise, add
        a save_m2m(***REMOVED*** method to the form which can be called after the instance
        is saved manually at a later time. Return the model instance.
        ***REMOVED***
        if self.errors:
            raise ValueError(
                "The %s could not be %s because the data didn't validate." % (
                    self.instance._meta.object_name,
                    'created' if self.instance._state.adding else 'changed',
                ***REMOVED***
            ***REMOVED***
        if commit:
            # If committing, save the instance and the m2m data immediately.
            self.instance.save(***REMOVED***
            self._save_m2m(***REMOVED***
        else:
            # If not committing, add a method to the form to allow deferred
            # saving of m2m data.
            self.save_m2m = self._save_m2m
        return self.instance

    save.alters_data = True


class ModelForm(six.with_metaclass(ModelFormMetaclass, BaseModelForm***REMOVED******REMOVED***:
    pass


def modelform_factory(model, form=ModelForm, fields=None, exclude=None,
                      formfield_callback=None, widgets=None, localized_fields=None,
                      labels=None, help_texts=None, error_messages=None,
                      field_classes=None***REMOVED***:
    ***REMOVED***
    Returns a ModelForm containing form fields for the given model.

    ``fields`` is an optional list of field names. If provided, only the named
    fields will be included in the returned fields. If omitted or '__all__',
    all fields will be used.

    ``exclude`` is an optional list of field names. If provided, the named
    fields will be excluded from the returned fields, even if they are listed
    in the ``fields`` argument.

    ``widgets`` is a dictionary of model field names mapped to a widget.

    ``localized_fields`` is a list of names of fields which should be localized.

    ``formfield_callback`` is a callable that takes a model field and returns
    a form field.

    ``labels`` is a dictionary of model field names mapped to a label.

    ``help_texts`` is a dictionary of model field names mapped to a help text.

    ``error_messages`` is a dictionary of model field names mapped to a
    dictionary of error messages.

    ``field_classes`` is a dictionary of model field names mapped to a form
    field class.
    ***REMOVED***
    # Create the inner Meta class. FIXME: ideally, we should be able to
    # construct a ModelForm without creating and passing in a temporary
    # inner class.

    # Build up a list of attributes that the Meta object will have.
    attrs = {'model': model***REMOVED***
    if fields is not None:
        attrs['fields'***REMOVED*** = fields
    if exclude is not None:
        attrs['exclude'***REMOVED*** = exclude
    if widgets is not None:
        attrs['widgets'***REMOVED*** = widgets
    if localized_fields is not None:
        attrs['localized_fields'***REMOVED*** = localized_fields
    if labels is not None:
        attrs['labels'***REMOVED*** = labels
    if help_texts is not None:
        attrs['help_texts'***REMOVED*** = help_texts
    if error_messages is not None:
        attrs['error_messages'***REMOVED*** = error_messages
    if field_classes is not None:
        attrs['field_classes'***REMOVED*** = field_classes

    # If parent form class already has an inner Meta, the Meta we're
    # creating needs to inherit from the parent's inner meta.
    parent = (object,***REMOVED***
    if hasattr(form, 'Meta'***REMOVED***:
        parent = (form.Meta, object***REMOVED***
    Meta = type(str('Meta'***REMOVED***, parent, attrs***REMOVED***
    if formfield_callback:
        Meta.formfield_callback = staticmethod(formfield_callback***REMOVED***
    # Give this new form class a reasonable name.
    class_name = model.__name__ + str('Form'***REMOVED***

    # Class attributes for the new form class.
    form_class_attrs = {
        'Meta': Meta,
        'formfield_callback': formfield_callback
***REMOVED***

    if (getattr(Meta, 'fields', None***REMOVED*** is None and
            getattr(Meta, 'exclude', None***REMOVED*** is None***REMOVED***:
        raise ImproperlyConfigured(
            "Calling modelform_factory without defining 'fields' or "
            "'exclude' explicitly is prohibited."
        ***REMOVED***

    # Instantiate type(form***REMOVED*** in order to use the same metaclass as form.
    return type(form***REMOVED***(class_name, (form,***REMOVED***, form_class_attrs***REMOVED***


# ModelFormSets ##############################################################

class BaseModelFormSet(BaseFormSet***REMOVED***:
    ***REMOVED***
    A ``FormSet`` for editing a queryset and/or adding new objects to it.
    ***REMOVED***
    model = None

    # Set of fields that must be unique among forms of this set.
    unique_fields = set(***REMOVED***

    def __init__(self, data=None, files=None, auto_id='id_%s', prefix=None,
                 queryset=None, **kwargs***REMOVED***:
        self.queryset = queryset
        self.initial_extra = kwargs.pop('initial', None***REMOVED***
        defaults = {'data': data, 'files': files, 'auto_id': auto_id, 'prefix': prefix***REMOVED***
        defaults.update(kwargs***REMOVED***
        super(BaseModelFormSet, self***REMOVED***.__init__(**defaults***REMOVED***

    def initial_form_count(self***REMOVED***:
        ***REMOVED***Returns the number of forms that are required in this FormSet.***REMOVED***
        if not (self.data or self.files***REMOVED***:
            return len(self.get_queryset(***REMOVED******REMOVED***
        return super(BaseModelFormSet, self***REMOVED***.initial_form_count(***REMOVED***

    def _existing_object(self, pk***REMOVED***:
        if not hasattr(self, '_object_dict'***REMOVED***:
            self._object_dict = {o.pk: o for o in self.get_queryset(***REMOVED******REMOVED***
        return self._object_dict.get(pk***REMOVED***

    def _get_to_python(self, field***REMOVED***:
        ***REMOVED***
        If the field is a related field, fetch the concrete field's (that
        is, the ultimate pointed-to field's***REMOVED*** to_python.
        ***REMOVED***
        while field.remote_field is not None:
            field = field.remote_field.get_related_field(***REMOVED***
        return field.to_python

    def _construct_form(self, i, **kwargs***REMOVED***:
        if self.is_bound and i < self.initial_form_count(***REMOVED***:
            pk_key = "%s-%s" % (self.add_prefix(i***REMOVED***, self.model._meta.pk.name***REMOVED***
            pk = self.data[pk_key***REMOVED***
            pk_field = self.model._meta.pk
            to_python = self._get_to_python(pk_field***REMOVED***
            pk = to_python(pk***REMOVED***
            kwargs['instance'***REMOVED*** = self._existing_object(pk***REMOVED***
        if i < self.initial_form_count(***REMOVED*** and 'instance' not in kwargs:
            kwargs['instance'***REMOVED*** = self.get_queryset(***REMOVED***[i***REMOVED***
        if i >= self.initial_form_count(***REMOVED*** and self.initial_extra:
            # Set initial values for extra forms
            ***REMOVED***
                kwargs['initial'***REMOVED*** = self.initial_extra[i - self.initial_form_count(***REMOVED******REMOVED***
            except IndexError:
                pass
        return super(BaseModelFormSet, self***REMOVED***._construct_form(i, **kwargs***REMOVED***

    def get_queryset(self***REMOVED***:
        if not hasattr(self, '_queryset'***REMOVED***:
            if self.queryset is not None:
                qs = self.queryset
            else:
                qs = self.model._default_manager.get_queryset(***REMOVED***

            # If the queryset isn't already ordered we need to add an
            # artificial ordering here to make sure that all formsets
            # constructed from this queryset have the same form order.
            if not qs.ordered:
                qs = qs.order_by(self.model._meta.pk.name***REMOVED***

            # Removed queryset limiting here. As per discussion re: #13023
            # on django-dev, max_num should not prevent existing
            # related objects/inlines from being displayed.
            self._queryset = qs
        return self._queryset

    def save_new(self, form, commit=True***REMOVED***:
        ***REMOVED***Saves and returns a new model instance for the given form.***REMOVED***
        return form.save(commit=commit***REMOVED***

    def save_existing(self, form, instance, commit=True***REMOVED***:
        ***REMOVED***Saves and returns an existing model instance for the given form.***REMOVED***
        return form.save(commit=commit***REMOVED***

    def delete_existing(self, obj, commit=True***REMOVED***:
        ***REMOVED***Deletes an existing model instance.***REMOVED***
        if commit:
            obj.delete(***REMOVED***

    def save(self, commit=True***REMOVED***:
        ***REMOVED***Saves model instances for every form, adding and changing instances
        as necessary, and returns the list of instances.
        ***REMOVED***
        if not commit:
            self.saved_forms = [***REMOVED***

            def save_m2m(***REMOVED***:
                for form in self.saved_forms:
                    form.save_m2m(***REMOVED***
            self.save_m2m = save_m2m
        return self.save_existing_objects(commit***REMOVED*** + self.save_new_objects(commit***REMOVED***

    save.alters_data = True

    def clean(self***REMOVED***:
        self.validate_unique(***REMOVED***

    def validate_unique(self***REMOVED***:
        # Collect unique_checks and date_checks to run from all the forms.
        all_unique_checks = set(***REMOVED***
        all_date_checks = set(***REMOVED***
        forms_to_delete = self.deleted_forms
        valid_forms = [form for form in self.forms if form.is_valid(***REMOVED*** and form not in forms_to_delete***REMOVED***
        for form in valid_forms:
            exclude = form._get_validation_exclusions(***REMOVED***
            unique_checks, date_checks = form.instance._get_unique_checks(exclude=exclude***REMOVED***
            all_unique_checks = all_unique_checks.union(set(unique_checks***REMOVED******REMOVED***
            all_date_checks = all_date_checks.union(set(date_checks***REMOVED******REMOVED***

        errors = [***REMOVED***
        # Do each of the unique checks (unique and unique_together***REMOVED***
        for uclass, unique_check in all_unique_checks:
            seen_data = set(***REMOVED***
            for form in valid_forms:
                # Get the data for the set of fields that must be unique among the forms.
                row_data = (
                    field if field in self.unique_fields else form.cleaned_data[field***REMOVED***
                    for field in unique_check if field in form.cleaned_data
                ***REMOVED***
                # Reduce Model instances to their primary key values
                row_data = tuple(d._get_pk_val(***REMOVED*** if hasattr(d, '_get_pk_val'***REMOVED*** else d
                                 for d in row_data***REMOVED***
                if row_data and None not in row_data:
                    # if we've already seen it then we have a uniqueness failure
                    if row_data in seen_data:
                        # poke error messages into the right places and mark
                        # the form as invalid
                        errors.append(self.get_unique_error_message(unique_check***REMOVED******REMOVED***
                        form._errors[NON_FIELD_ERRORS***REMOVED*** = self.error_class([self.get_form_error(***REMOVED******REMOVED******REMOVED***
                        # remove the data from the cleaned_data dict since it was invalid
                        for field in unique_check:
                            if field in form.cleaned_data:
                                del form.cleaned_data[field***REMOVED***
                    # mark the data as seen
                    seen_data.add(row_data***REMOVED***
        # iterate over each of the date checks now
        for date_check in all_date_checks:
            seen_data = set(***REMOVED***
            uclass, lookup, field, unique_for = date_check
            for form in valid_forms:
                # see if we have data for both fields
                if (form.cleaned_data and form.cleaned_data[field***REMOVED*** is not None and
                        form.cleaned_data[unique_for***REMOVED*** is not None***REMOVED***:
                    # if it's a date lookup we need to get the data for all the fields
                    if lookup == 'date':
                        date = form.cleaned_data[unique_for***REMOVED***
                        date_data = (date.year, date.month, date.day***REMOVED***
                    # otherwise it's just the attribute on the date/datetime
                    # object
                    else:
                        date_data = (getattr(form.cleaned_data[unique_for***REMOVED***, lookup***REMOVED***,***REMOVED***
                    data = (form.cleaned_data[field***REMOVED***,***REMOVED*** + date_data
                    # if we've already seen it then we have a uniqueness failure
                    if data in seen_data:
                        # poke error messages into the right places and mark
                        # the form as invalid
                        errors.append(self.get_date_error_message(date_check***REMOVED******REMOVED***
                        form._errors[NON_FIELD_ERRORS***REMOVED*** = self.error_class([self.get_form_error(***REMOVED******REMOVED******REMOVED***
                        # remove the data from the cleaned_data dict since it was invalid
                        del form.cleaned_data[field***REMOVED***
                    # mark the data as seen
                    seen_data.add(data***REMOVED***

        if errors:
            raise ValidationError(errors***REMOVED***

    def get_unique_error_message(self, unique_check***REMOVED***:
        if len(unique_check***REMOVED*** == 1:
            return ugettext("Please correct the duplicate data for %(field***REMOVED***s."***REMOVED*** % {
                "field": unique_check[0***REMOVED***,
        ***REMOVED***
        else:
            return ugettext("Please correct the duplicate data for %(field***REMOVED***s, which must be unique."***REMOVED*** % {
                "field": get_text_list(unique_check, six.text_type(_("and"***REMOVED******REMOVED******REMOVED***,
        ***REMOVED***

    def get_date_error_message(self, date_check***REMOVED***:
        return ugettext(
            "Please correct the duplicate data for %(field_name***REMOVED***s "
            "which must be unique for the %(lookup***REMOVED***s in %(date_field***REMOVED***s."
        ***REMOVED*** % {
            'field_name': date_check[2***REMOVED***,
            'date_field': date_check[3***REMOVED***,
            'lookup': six.text_type(date_check[1***REMOVED******REMOVED***,
    ***REMOVED***

    def get_form_error(self***REMOVED***:
        return ugettext("Please correct the duplicate values below."***REMOVED***

    def save_existing_objects(self, commit=True***REMOVED***:
        self.changed_objects = [***REMOVED***
        self.deleted_objects = [***REMOVED***
        if not self.initial_forms:
            return [***REMOVED***

        saved_instances = [***REMOVED***
        forms_to_delete = self.deleted_forms
        for form in self.initial_forms:
            obj = form.instance
            if form in forms_to_delete:
                # If the pk is None, it means that the object can't be
                # deleted again. Possible reason for this is that the
                # object was already deleted from the DB. Refs #14877.
                if obj.pk is None:
                    continue
                self.deleted_objects.append(obj***REMOVED***
                self.delete_existing(obj, commit=commit***REMOVED***
            elif form.has_changed(***REMOVED***:
                self.changed_objects.append((obj, form.changed_data***REMOVED******REMOVED***
                saved_instances.append(self.save_existing(form, obj, commit=commit***REMOVED******REMOVED***
                if not commit:
                    self.saved_forms.append(form***REMOVED***
        return saved_instances

    def save_new_objects(self, commit=True***REMOVED***:
        self.new_objects = [***REMOVED***
        for form in self.extra_forms:
            if not form.has_changed(***REMOVED***:
                continue
            # If someone has marked an add form for deletion, don't save the
            # object.
            if self.can_delete and self._should_delete_form(form***REMOVED***:
                continue
            self.new_objects.append(self.save_new(form, commit=commit***REMOVED******REMOVED***
            if not commit:
                self.saved_forms.append(form***REMOVED***
        return self.new_objects

    def add_fields(self, form, index***REMOVED***:
        ***REMOVED***Add a hidden field for the object's primary key.***REMOVED***
        from django.db.models import AutoField, OneToOneField, ForeignKey
        self._pk_field = pk = self.model._meta.pk
        # If a pk isn't editable, then it won't be on the form, so we need to
        # add it here so we can tell which object is which when we get the
        # data back. Generally, pk.editable should be false, but for some
        # reason, auto_created pk fields and AutoField's editable attribute is
        # True, so check for that as well.

        def pk_is_not_editable(pk***REMOVED***:
            return (
                (not pk.editable***REMOVED*** or (pk.auto_created or isinstance(pk, AutoField***REMOVED******REMOVED*** or (
                    pk.remote_field and pk.remote_field.parent_link and
                    pk_is_not_editable(pk.remote_field.model._meta.pk***REMOVED***
                ***REMOVED***
            ***REMOVED***
        if pk_is_not_editable(pk***REMOVED*** or pk.name not in form.fields:
            if form.is_bound:
                # If we're adding the related instance, ignore its primary key
                # as it could be an auto-generated default which isn't actually
                # in the database.
                pk_value = None if form.instance._state.adding else form.instance.pk
            else:
                ***REMOVED***
                    if index is not None:
                        pk_value = self.get_queryset(***REMOVED***[index***REMOVED***.pk
                    else:
                        pk_value = None
                except IndexError:
                    pk_value = None
            if isinstance(pk, OneToOneField***REMOVED*** or isinstance(pk, ForeignKey***REMOVED***:
                qs = pk.remote_field.model._default_manager.get_queryset(***REMOVED***
            else:
                qs = self.model._default_manager.get_queryset(***REMOVED***
            qs = qs.using(form.instance._state.db***REMOVED***
            if form._meta.widgets:
                widget = form._meta.widgets.get(self._pk_field.name, HiddenInput***REMOVED***
            else:
                widget = HiddenInput
            form.fields[self._pk_field.name***REMOVED*** = ModelChoiceField(qs, initial=pk_value, required=False, widget=widget***REMOVED***
        super(BaseModelFormSet, self***REMOVED***.add_fields(form, index***REMOVED***


def modelformset_factory(model, form=ModelForm, formfield_callback=None,
                         formset=BaseModelFormSet, extra=1, can_delete=False,
                         can_order=False, max_num=None, fields=None, exclude=None,
                         widgets=None, validate_max=False, localized_fields=None,
                         labels=None, help_texts=None, error_messages=None,
                         min_num=None, validate_min=False, field_classes=None***REMOVED***:
    ***REMOVED***
    Returns a FormSet class for the given Django model class.
    ***REMOVED***
    meta = getattr(form, 'Meta', None***REMOVED***
    if (getattr(meta, 'fields', fields***REMOVED*** is None and
            getattr(meta, 'exclude', exclude***REMOVED*** is None***REMOVED***:
        raise ImproperlyConfigured(
            "Calling modelformset_factory without defining 'fields' or "
            "'exclude' explicitly is prohibited."
        ***REMOVED***

    form = modelform_factory(model, form=form, fields=fields, exclude=exclude,
                             formfield_callback=formfield_callback,
                             widgets=widgets, localized_fields=localized_fields,
                             labels=labels, help_texts=help_texts,
                             error_messages=error_messages, field_classes=field_classes***REMOVED***
    FormSet = formset_factory(form, formset, extra=extra, min_num=min_num, max_num=max_num,
                              can_order=can_order, can_delete=can_delete,
                              validate_min=validate_min, validate_max=validate_max***REMOVED***
    FormSet.model = model
    return FormSet


# InlineFormSets #############################################################

class BaseInlineFormSet(BaseModelFormSet***REMOVED***:
    ***REMOVED***A formset for child objects related to a parent.***REMOVED***
    def __init__(self, data=None, files=None, instance=None,
                 save_as_new=False, prefix=None, queryset=None, **kwargs***REMOVED***:
        if instance is None:
            self.instance = self.fk.remote_field.model(***REMOVED***
        else:
            self.instance = instance
        self.save_as_new = save_as_new
        if queryset is None:
            queryset = self.model._default_manager
        if self.instance.pk is not None:
            qs = queryset.filter(**{self.fk.name: self.instance***REMOVED******REMOVED***
        else:
            qs = queryset.none(***REMOVED***
        self.unique_fields = {self.fk.name***REMOVED***
        super(BaseInlineFormSet, self***REMOVED***.__init__(data, files, prefix=prefix,
                                                queryset=qs, **kwargs***REMOVED***

        # Add the generated field to form._meta.fields if it's defined to make
        # sure validation isn't skipped on that field.
        if self.form._meta.fields and self.fk.name not in self.form._meta.fields:
            if isinstance(self.form._meta.fields, tuple***REMOVED***:
                self.form._meta.fields = list(self.form._meta.fields***REMOVED***
            self.form._meta.fields.append(self.fk.name***REMOVED***

    def initial_form_count(self***REMOVED***:
        if self.save_as_new:
            return 0
        return super(BaseInlineFormSet, self***REMOVED***.initial_form_count(***REMOVED***

    def _construct_form(self, i, **kwargs***REMOVED***:
        form = super(BaseInlineFormSet, self***REMOVED***._construct_form(i, **kwargs***REMOVED***
        if self.save_as_new:
            # Remove the primary key from the form's data, we are only
            # creating new instances
            form.data[form.add_prefix(self._pk_field.name***REMOVED******REMOVED*** = None

            # Remove the foreign key from the form's data
            form.data[form.add_prefix(self.fk.name***REMOVED******REMOVED*** = None

        # Set the fk value here so that the form can do its validation.
        fk_value = self.instance.pk
        if self.fk.remote_field.field_name != self.fk.remote_field.model._meta.pk.name:
            fk_value = getattr(self.instance, self.fk.remote_field.field_name***REMOVED***
            fk_value = getattr(fk_value, 'pk', fk_value***REMOVED***
        setattr(form.instance, self.fk.get_attname(***REMOVED***, fk_value***REMOVED***
        return form

    @classmethod
    def get_default_prefix(cls***REMOVED***:
        return cls.fk.remote_field.get_accessor_name(model=cls.model***REMOVED***.replace('+', ''***REMOVED***

    def save_new(self, form, commit=True***REMOVED***:
        # Ensure the latest copy of the related instance is present on each
        # form (it may have been saved after the formset was originally
        # instantiated***REMOVED***.
        setattr(form.instance, self.fk.name, self.instance***REMOVED***
        # Use commit=False so we can assign the parent key afterwards, then
        # save the object.
        obj = form.save(commit=False***REMOVED***
        pk_value = getattr(self.instance, self.fk.remote_field.field_name***REMOVED***
        setattr(obj, self.fk.get_attname(***REMOVED***, getattr(pk_value, 'pk', pk_value***REMOVED******REMOVED***
        if commit:
            obj.save(***REMOVED***
        # form.save_m2m(***REMOVED*** can be called via the formset later on if commit=False
        if commit and hasattr(form, 'save_m2m'***REMOVED***:
            form.save_m2m(***REMOVED***
        return obj

    def add_fields(self, form, index***REMOVED***:
        super(BaseInlineFormSet, self***REMOVED***.add_fields(form, index***REMOVED***
        if self._pk_field == self.fk:
            name = self._pk_field.name
            kwargs = {'pk_field': True***REMOVED***
        else:
            # The foreign key field might not be on the form, so we poke at the
            # Model field to get the label, since we need that for error messages.
            name = self.fk.name
            kwargs = {
                'label': getattr(form.fields.get(name***REMOVED***, 'label', capfirst(self.fk.verbose_name***REMOVED******REMOVED***
        ***REMOVED***
            if self.fk.remote_field.field_name != self.fk.remote_field.model._meta.pk.name:
                kwargs['to_field'***REMOVED*** = self.fk.remote_field.field_name

        # If we're adding a new object, ignore a parent's auto-generated key
        # as it will be regenerated on the save request.
        if self.instance._state.adding:
            if kwargs.get('to_field'***REMOVED*** is not None:
                to_field = self.instance._meta.get_field(kwargs['to_field'***REMOVED******REMOVED***
            else:
                to_field = self.instance._meta.pk
            if to_field.has_default(***REMOVED***:
                setattr(self.instance, to_field.attname, None***REMOVED***

        form.fields[name***REMOVED*** = InlineForeignKeyField(self.instance, **kwargs***REMOVED***

    def get_unique_error_message(self, unique_check***REMOVED***:
        unique_check = [field for field in unique_check if field != self.fk.name***REMOVED***
        return super(BaseInlineFormSet, self***REMOVED***.get_unique_error_message(unique_check***REMOVED***


def _get_foreign_key(parent_model, model, fk_name=None, can_fail=False***REMOVED***:
    ***REMOVED***
    Finds and returns the ForeignKey from model to parent if there is one
    (returns None if can_fail is True and no such field exists***REMOVED***. If fk_name is
    provided, assume it is the name of the ForeignKey field. Unless can_fail is
    True, an exception is raised if there is no ForeignKey from model to
    parent_model.
    ***REMOVED***
    # avoid circular import
    from django.db.models import ForeignKey
    opts = model._meta
    if fk_name:
        fks_to_parent = [f for f in opts.fields if f.name == fk_name***REMOVED***
        if len(fks_to_parent***REMOVED*** == 1:
            fk = fks_to_parent[0***REMOVED***
            if not isinstance(fk, ForeignKey***REMOVED*** or \
                    (fk.remote_field.model != parent_model and
                     fk.remote_field.model not in parent_model._meta.get_parent_list(***REMOVED******REMOVED***:
                raise ValueError(
                    "fk_name '%s' is not a ForeignKey to '%s'." % (fk_name, parent_model._meta.label***REMOVED***
                ***REMOVED***
        elif len(fks_to_parent***REMOVED*** == 0:
            raise ValueError(
                "'%s' has no field named '%s'." % (model._meta.label, fk_name***REMOVED***
            ***REMOVED***
    else:
        # Try to discover what the ForeignKey from model to parent_model is
        fks_to_parent = [
            f for f in opts.fields
            if isinstance(f, ForeignKey***REMOVED*** and (
                f.remote_field.model == parent_model or
                f.remote_field.model in parent_model._meta.get_parent_list(***REMOVED***
            ***REMOVED***
        ***REMOVED***
        if len(fks_to_parent***REMOVED*** == 1:
            fk = fks_to_parent[0***REMOVED***
        elif len(fks_to_parent***REMOVED*** == 0:
            if can_fail:
                return
            raise ValueError(
                "'%s' has no ForeignKey to '%s'." % (
                    model._meta.label,
                    parent_model._meta.label,
                ***REMOVED***
            ***REMOVED***
        else:
            raise ValueError(
                "'%s' has more than one ForeignKey to '%s'." % (
                    model._meta.label,
                    parent_model._meta.label,
                ***REMOVED***
            ***REMOVED***
    return fk


def inlineformset_factory(parent_model, model, form=ModelForm,
                          formset=BaseInlineFormSet, fk_name=None,
                          fields=None, exclude=None, extra=3, can_order=False,
                          can_delete=True, max_num=None, formfield_callback=None,
                          widgets=None, validate_max=False, localized_fields=None,
                          labels=None, help_texts=None, error_messages=None,
                          min_num=None, validate_min=False, field_classes=None***REMOVED***:
    ***REMOVED***
    Returns an ``InlineFormSet`` for the given kwargs.

    You must provide ``fk_name`` if ``model`` has more than one ``ForeignKey``
    to ``parent_model``.
    ***REMOVED***
    fk = _get_foreign_key(parent_model, model, fk_name=fk_name***REMOVED***
    # enforce a max_num=1 when the foreign key to the parent model is unique.
    if fk.unique:
        max_num = 1
    kwargs = {
        'form': form,
        'formfield_callback': formfield_callback,
        'formset': formset,
        'extra': extra,
        'can_delete': can_delete,
        'can_order': can_order,
        'fields': fields,
        'exclude': exclude,
        'min_num': min_num,
        'max_num': max_num,
        'widgets': widgets,
        'validate_min': validate_min,
        'validate_max': validate_max,
        'localized_fields': localized_fields,
        'labels': labels,
        'help_texts': help_texts,
        'error_messages': error_messages,
        'field_classes': field_classes,
***REMOVED***
    FormSet = modelformset_factory(model, **kwargs***REMOVED***
    FormSet.fk = fk
    return FormSet


# Fields #####################################################################

class InlineForeignKeyField(Field***REMOVED***:
    ***REMOVED***
    A basic integer field that deals with validating the given value to a
    given parent instance in an inline.
    ***REMOVED***
    widget = HiddenInput
    default_error_messages = {
        'invalid_choice': _('The inline foreign key did not match the parent instance primary key.'***REMOVED***,
***REMOVED***

    def __init__(self, parent_instance, *args, **kwargs***REMOVED***:
        self.parent_instance = parent_instance
        self.pk_field = kwargs.pop("pk_field", False***REMOVED***
        self.to_field = kwargs.pop("to_field", None***REMOVED***
        if self.parent_instance is not None:
            if self.to_field:
                kwargs["initial"***REMOVED*** = getattr(self.parent_instance, self.to_field***REMOVED***
            else:
                kwargs["initial"***REMOVED*** = self.parent_instance.pk
        kwargs["required"***REMOVED*** = False
        super(InlineForeignKeyField, self***REMOVED***.__init__(*args, **kwargs***REMOVED***

    def clean(self, value***REMOVED***:
        if value in self.empty_values:
            if self.pk_field:
                return None
            # if there is no value act as we did before.
            return self.parent_instance
        # ensure the we compare the values as equal types.
        if self.to_field:
            orig = getattr(self.parent_instance, self.to_field***REMOVED***
        else:
            orig = self.parent_instance.pk
        if force_text(value***REMOVED*** != force_text(orig***REMOVED***:
            raise ValidationError(self.error_messages['invalid_choice'***REMOVED***, code='invalid_choice'***REMOVED***
        return self.parent_instance

    def has_changed(self, initial, data***REMOVED***:
        return False


class ModelChoiceIterator(object***REMOVED***:
    def __init__(self, field***REMOVED***:
        self.field = field
        self.queryset = field.queryset

    def __iter__(self***REMOVED***:
        if self.field.empty_label is not None:
            yield ("", self.field.empty_label***REMOVED***
        queryset = self.queryset.all(***REMOVED***
        # Can't use iterator(***REMOVED*** when queryset uses prefetch_related(***REMOVED***
        if not queryset._prefetch_related_lookups:
            queryset = queryset.iterator(***REMOVED***
        for obj in queryset:
            yield self.choice(obj***REMOVED***

    def __len__(self***REMOVED***:
        return (len(self.queryset***REMOVED*** + (1 if self.field.empty_label is not None else 0***REMOVED******REMOVED***

    def choice(self, obj***REMOVED***:
        return (self.field.prepare_value(obj***REMOVED***, self.field.label_from_instance(obj***REMOVED******REMOVED***


class ModelChoiceField(ChoiceField***REMOVED***:
    ***REMOVED***A ChoiceField whose choices are a model QuerySet.***REMOVED***
    # This class is a subclass of ChoiceField for purity, but it doesn't
    # actually use any of ChoiceField's implementation.
    default_error_messages = {
        'invalid_choice': _('Select a valid choice. That choice is not one of'
                            ' the available choices.'***REMOVED***,
***REMOVED***

    def __init__(self, queryset, empty_label="---------",
                 required=True, widget=None, label=None, initial=None,
                 help_text='', to_field_name=None, limit_choices_to=None,
                 *args, **kwargs***REMOVED***:
        if required and (initial is not None***REMOVED***:
            self.empty_label = None
        else:
            self.empty_label = empty_label

        # Call Field instead of ChoiceField __init__(***REMOVED*** because we don't need
        # ChoiceField.__init__(***REMOVED***.
        Field.__init__(self, required, widget, label, initial, help_text,
                       *args, **kwargs***REMOVED***
        self.queryset = queryset
        self.limit_choices_to = limit_choices_to   # limit the queryset later.
        self.to_field_name = to_field_name

    def get_limit_choices_to(self***REMOVED***:
        ***REMOVED***
        Returns ``limit_choices_to`` for this form field.

        If it is a callable, it will be invoked and the result will be
        returned.
        ***REMOVED***
        if callable(self.limit_choices_to***REMOVED***:
            return self.limit_choices_to(***REMOVED***
        return self.limit_choices_to

    def __deepcopy__(self, memo***REMOVED***:
        result = super(ChoiceField, self***REMOVED***.__deepcopy__(memo***REMOVED***
        # Need to force a new ModelChoiceIterator to be created, bug #11183
        result.queryset = result.queryset
        return result

    def _get_queryset(self***REMOVED***:
        return self._queryset

    def _set_queryset(self, queryset***REMOVED***:
        self._queryset = queryset
        self.widget.choices = self.choices

    queryset = property(_get_queryset, _set_queryset***REMOVED***

    # this method will be used to create object labels by the QuerySetIterator.
    # Override it to customize the label.
    def label_from_instance(self, obj***REMOVED***:
        ***REMOVED***
        This method is used to convert objects into strings; it's used to
        generate the labels for the choices presented by this object. Subclasses
        can override this method to customize the display of the choices.
        ***REMOVED***
        return smart_text(obj***REMOVED***

    def _get_choices(self***REMOVED***:
        # If self._choices is set, then somebody must have manually set
        # the property self.choices. In this case, just return self._choices.
        if hasattr(self, '_choices'***REMOVED***:
            return self._choices

        # Otherwise, execute the QuerySet in self.queryset to determine the
        # choices dynamically. Return a fresh ModelChoiceIterator that has not been
        # consumed. Note that we're instantiating a new ModelChoiceIterator *each*
        # time _get_choices(***REMOVED*** is called (and, thus, each time self.choices is
        # accessed***REMOVED*** so that we can ensure the QuerySet has not been consumed. This
        # construct might look complicated but it allows for lazy evaluation of
        # the queryset.
        return ModelChoiceIterator(self***REMOVED***

    choices = property(_get_choices, ChoiceField._set_choices***REMOVED***

    def prepare_value(self, value***REMOVED***:
        if hasattr(value, '_meta'***REMOVED***:
            if self.to_field_name:
                return value.serializable_value(self.to_field_name***REMOVED***
            else:
                return value.pk
        return super(ModelChoiceField, self***REMOVED***.prepare_value(value***REMOVED***

    def to_python(self, value***REMOVED***:
        if value in self.empty_values:
            return None
        ***REMOVED***
            key = self.to_field_name or 'pk'
            value = self.queryset.get(**{key: value***REMOVED******REMOVED***
        except (ValueError, TypeError, self.queryset.model.DoesNotExist***REMOVED***:
            raise ValidationError(self.error_messages['invalid_choice'***REMOVED***, code='invalid_choice'***REMOVED***
        return value

    def validate(self, value***REMOVED***:
        return Field.validate(self, value***REMOVED***

    def has_changed(self, initial, data***REMOVED***:
        initial_value = initial if initial is not None else ''
        data_value = data if data is not None else ''
        return force_text(self.prepare_value(initial_value***REMOVED******REMOVED*** != force_text(data_value***REMOVED***


class ModelMultipleChoiceField(ModelChoiceField***REMOVED***:
    ***REMOVED***A MultipleChoiceField whose choices are a model QuerySet.***REMOVED***
    widget = SelectMultiple
    hidden_widget = MultipleHiddenInput
    default_error_messages = {
        'list': _('Enter a list of values.'***REMOVED***,
        'invalid_choice': _('Select a valid choice. %(value***REMOVED***s is not one of the'
                            ' available choices.'***REMOVED***,
        'invalid_pk_value': _('"%(pk***REMOVED***s" is not a valid value for a primary key.'***REMOVED***
***REMOVED***

    def __init__(self, queryset, required=True, widget=None, label=None,
                 initial=None, help_text='', *args, **kwargs***REMOVED***:
        super(ModelMultipleChoiceField, self***REMOVED***.__init__(
            queryset, None, required, widget, label, initial, help_text,
            *args, **kwargs
        ***REMOVED***

    def to_python(self, value***REMOVED***:
        if not value:
            return [***REMOVED***
        return list(self._check_values(value***REMOVED******REMOVED***

    def clean(self, value***REMOVED***:
        value = self.prepare_value(value***REMOVED***
        if self.required and not value:
            raise ValidationError(self.error_messages['required'***REMOVED***, code='required'***REMOVED***
        elif not self.required and not value:
            return self.queryset.none(***REMOVED***
        if not isinstance(value, (list, tuple***REMOVED******REMOVED***:
            raise ValidationError(self.error_messages['list'***REMOVED***, code='list'***REMOVED***
        qs = self._check_values(value***REMOVED***
        # Since this overrides the inherited ModelChoiceField.clean
        # we run custom validators here
        self.run_validators(value***REMOVED***
        return qs

    def _check_values(self, value***REMOVED***:
        ***REMOVED***
        Given a list of possible PK values, returns a QuerySet of the
        corresponding objects. Raises a ValidationError if a given value is
        invalid (not a valid PK, not in the queryset, etc.***REMOVED***
        ***REMOVED***
        key = self.to_field_name or 'pk'
        # deduplicate given values to avoid creating many querysets or
        # requiring the database backend deduplicate efficiently.
        ***REMOVED***
            value = frozenset(value***REMOVED***
        except TypeError:
            # list of lists isn't hashable, for example
            raise ValidationError(
                self.error_messages['list'***REMOVED***,
                code='list',
            ***REMOVED***
        for pk in value:
            ***REMOVED***
                self.queryset.filter(**{key: pk***REMOVED******REMOVED***
            except (ValueError, TypeError***REMOVED***:
                raise ValidationError(
                    self.error_messages['invalid_pk_value'***REMOVED***,
                    code='invalid_pk_value',
                    params={'pk': pk***REMOVED***,
                ***REMOVED***
        qs = self.queryset.filter(**{'%s__in' % key: value***REMOVED******REMOVED***
        pks = set(force_text(getattr(o, key***REMOVED******REMOVED*** for o in qs***REMOVED***
        for val in value:
            if force_text(val***REMOVED*** not in pks:
                raise ValidationError(
                    self.error_messages['invalid_choice'***REMOVED***,
                    code='invalid_choice',
                    params={'value': val***REMOVED***,
                ***REMOVED***
        return qs

    def prepare_value(self, value***REMOVED***:
        if (hasattr(value, '__iter__'***REMOVED*** and
                not isinstance(value, six.text_type***REMOVED*** and
                not hasattr(value, '_meta'***REMOVED******REMOVED***:
            return [super(ModelMultipleChoiceField, self***REMOVED***.prepare_value(v***REMOVED*** for v in value***REMOVED***
        return super(ModelMultipleChoiceField, self***REMOVED***.prepare_value(value***REMOVED***

    def has_changed(self, initial, data***REMOVED***:
        if initial is None:
            initial = [***REMOVED***
        if data is None:
            data = [***REMOVED***
        if len(initial***REMOVED*** != len(data***REMOVED***:
            return True
        initial_set = set(force_text(value***REMOVED*** for value in self.prepare_value(initial***REMOVED******REMOVED***
        data_set = set(force_text(value***REMOVED*** for value in data***REMOVED***
        return data_set != initial_set


def modelform_defines_fields(form_class***REMOVED***:
    return (form_class is not None and (
            hasattr(form_class, '_meta'***REMOVED*** and
            (form_class._meta.fields is not None or
             form_class._meta.exclude is not None***REMOVED***
            ***REMOVED******REMOVED***
