from __future__ import unicode_literals

import json
import sys

from django.conf import settings
from django.core.exceptions import ValidationError  # backwards compatibility
from django.utils import six, timezone
from django.utils.encoding import force_text, python_2_unicode_compatible
from django.utils.html import escape, format_html, format_html_join, html_safe
from django.utils.translation import ugettext_lazy as _

***REMOVED***
    from collections import UserList
except ImportError:  # Python 2
    from UserList import UserList


def pretty_name(name***REMOVED***:
    ***REMOVED***Converts 'first_name' to 'First name'***REMOVED***
    if not name:
        return ''
    return name.replace('_', ' '***REMOVED***.capitalize(***REMOVED***


def flatatt(attrs***REMOVED***:
    ***REMOVED***
    Convert a dictionary of attributes to a single string.
    The returned string will contain a leading space followed by key="value",
    XML-style pairs. In the case of a boolean value, the key will appear
    without a value. It is assumed that the keys do not need to be
    XML-escaped. If the passed dictionary is empty, then return an empty
    string.

    The result is passed through 'mark_safe' (by way of 'format_html_join'***REMOVED***.
    ***REMOVED***
    key_value_attrs = [***REMOVED***
    boolean_attrs = [***REMOVED***
    for attr, value in attrs.items(***REMOVED***:
        if isinstance(value, bool***REMOVED***:
            if value:
                boolean_attrs.append((attr,***REMOVED******REMOVED***
        else:
            key_value_attrs.append((attr, value***REMOVED******REMOVED***

    return (
        format_html_join('', ' {***REMOVED***="{***REMOVED***"', sorted(key_value_attrs***REMOVED******REMOVED*** +
        format_html_join('', ' {***REMOVED***', sorted(boolean_attrs***REMOVED******REMOVED***
    ***REMOVED***


@html_safe
@python_2_unicode_compatible
class ErrorDict(dict***REMOVED***:
    ***REMOVED***
    A collection of errors that knows how to display itself in various formats.

    The dictionary keys are the field names, and the values are the errors.
    ***REMOVED***
    def as_data(self***REMOVED***:
        return {f: e.as_data(***REMOVED*** for f, e in self.items(***REMOVED******REMOVED***

    def as_json(self, escape_html=False***REMOVED***:
        return json.dumps({f: e.get_json_data(escape_html***REMOVED*** for f, e in self.items(***REMOVED******REMOVED******REMOVED***

    def as_ul(self***REMOVED***:
        if not self:
            return ''
        return format_html(
            '<ul class="errorlist">{***REMOVED***</ul>',
            format_html_join('', '<li>{***REMOVED***{***REMOVED***</li>', ((k, force_text(v***REMOVED******REMOVED*** for k, v in self.items(***REMOVED******REMOVED******REMOVED***
        ***REMOVED***

    def as_text(self***REMOVED***:
        output = [***REMOVED***
        for field, errors in self.items(***REMOVED***:
            output.append('* %s' % field***REMOVED***
            output.append('\n'.join('  * %s' % e for e in errors***REMOVED******REMOVED***
        return '\n'.join(output***REMOVED***

    def __str__(self***REMOVED***:
        return self.as_ul(***REMOVED***


@html_safe
@python_2_unicode_compatible
class ErrorList(UserList, list***REMOVED***:
    ***REMOVED***
    A collection of errors that knows how to display itself in various formats.
    ***REMOVED***
    def __init__(self, initlist=None, error_class=None***REMOVED***:
        super(ErrorList, self***REMOVED***.__init__(initlist***REMOVED***

        if error_class is None:
            self.error_class = 'errorlist'
        else:
            self.error_class = 'errorlist {***REMOVED***'.format(error_class***REMOVED***

    def as_data(self***REMOVED***:
        return ValidationError(self.data***REMOVED***.error_list

    def get_json_data(self, escape_html=False***REMOVED***:
        errors = [***REMOVED***
        for error in self.as_data(***REMOVED***:
            message = list(error***REMOVED***[0***REMOVED***
            errors.append({
                'message': escape(message***REMOVED*** if escape_html else message,
                'code': error.code or '',
        ***REMOVED******REMOVED***
        return errors

    def as_json(self, escape_html=False***REMOVED***:
        return json.dumps(self.get_json_data(escape_html***REMOVED******REMOVED***

    def as_ul(self***REMOVED***:
        if not self.data:
            return ''

        return format_html(
            '<ul class="{***REMOVED***">{***REMOVED***</ul>',
            self.error_class,
            format_html_join('', '<li>{***REMOVED***</li>', ((force_text(e***REMOVED***,***REMOVED*** for e in self***REMOVED******REMOVED***
        ***REMOVED***

    def as_text(self***REMOVED***:
        return '\n'.join('* %s' % e for e in self***REMOVED***

    def __str__(self***REMOVED***:
        return self.as_ul(***REMOVED***

    def __repr__(self***REMOVED***:
        return repr(list(self***REMOVED******REMOVED***

    def __contains__(self, item***REMOVED***:
        return item in list(self***REMOVED***

    def __eq__(self, other***REMOVED***:
        return list(self***REMOVED*** == other

    def __ne__(self, other***REMOVED***:
        return list(self***REMOVED*** != other

    def __getitem__(self, i***REMOVED***:
        error = self.data[i***REMOVED***
        if isinstance(error, ValidationError***REMOVED***:
            return list(error***REMOVED***[0***REMOVED***
        return force_text(error***REMOVED***

    def __reduce_ex__(self, *args, **kwargs***REMOVED***:
        # The `list` reduce function returns an iterator as the fourth element
        # that is normally used for repopulating. Since we only inherit from
        # `list` for `isinstance` backward compatibility (Refs #17413***REMOVED*** we
        # nullify this iterator as it would otherwise result in duplicate
        # entries. (Refs #23594***REMOVED***
        info = super(UserList, self***REMOVED***.__reduce_ex__(*args, **kwargs***REMOVED***
        return info[:3***REMOVED*** + (None, None***REMOVED***


# Utilities for time zone support in DateTimeField et al.

def from_current_timezone(value***REMOVED***:
    ***REMOVED***
    When time zone support is enabled, convert naive datetimes
    entered in the current time zone to aware datetimes.
    ***REMOVED***
    if settings.USE_TZ and value is not None and timezone.is_naive(value***REMOVED***:
        current_timezone = timezone.get_current_timezone(***REMOVED***
        ***REMOVED***
            return timezone.make_aware(value, current_timezone***REMOVED***
        except Exception:
            message = _(
                '%(datetime***REMOVED***s couldn\'t be interpreted '
                'in time zone %(current_timezone***REMOVED***s; it '
                'may be ambiguous or it may not exist.'
            ***REMOVED***
            params = {'datetime': value, 'current_timezone': current_timezone***REMOVED***
            six.reraise(ValidationError, ValidationError(
                message,
                code='ambiguous_timezone',
                params=params,
            ***REMOVED***, sys.exc_info(***REMOVED***[2***REMOVED******REMOVED***
    return value


def to_current_timezone(value***REMOVED***:
    ***REMOVED***
    When time zone support is enabled, convert aware datetimes
    to naive datetimes in the current time zone for display.
    ***REMOVED***
    if settings.USE_TZ and value is not None and timezone.is_aware(value***REMOVED***:
        current_timezone = timezone.get_current_timezone(***REMOVED***
        return timezone.make_naive(value, current_timezone***REMOVED***
    return value
