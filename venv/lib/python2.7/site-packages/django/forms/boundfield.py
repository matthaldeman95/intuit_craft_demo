from __future__ import unicode_literals

import datetime

from django.forms.utils import flatatt, pretty_name
from django.forms.widgets import Textarea, TextInput
from django.utils import six
from django.utils.encoding import (
    force_text, python_2_unicode_compatible, smart_text,
***REMOVED***
from django.utils.html import conditional_escape, format_html, html_safe
from django.utils.safestring import mark_safe
from django.utils.translation import ugettext_lazy as _

__all__ = ('BoundField',***REMOVED***


UNSET = object(***REMOVED***


@html_safe
@python_2_unicode_compatible
class BoundField(object***REMOVED***:
    "A Field plus data"
    def __init__(self, form, field, name***REMOVED***:
        self.form = form
        self.field = field
        self.name = name
        self.html_name = form.add_prefix(name***REMOVED***
        self.html_initial_name = form.add_initial_prefix(name***REMOVED***
        self.html_initial_id = form.add_initial_prefix(self.auto_id***REMOVED***
        if self.field.label is None:
            self.label = pretty_name(name***REMOVED***
        else:
            self.label = self.field.label
        self.help_text = field.help_text or ''
        self._initial_value = UNSET

    def __str__(self***REMOVED***:
        ***REMOVED***Renders this field as an HTML widget.***REMOVED***
        if self.field.show_hidden_initial:
            return self.as_widget(***REMOVED*** + self.as_hidden(only_initial=True***REMOVED***
        return self.as_widget(***REMOVED***

    def __iter__(self***REMOVED***:
        ***REMOVED***
        Yields rendered strings that comprise all widgets in this BoundField.

        This really is only useful for RadioSelect widgets, so that you can
        iterate over individual radio buttons in a template.
        ***REMOVED***
        id_ = self.field.widget.attrs.get('id'***REMOVED*** or self.auto_id
        attrs = {'id': id_***REMOVED*** if id_ else {***REMOVED***
        attrs = self.build_widget_attrs(attrs***REMOVED***
        for subwidget in self.field.widget.subwidgets(self.html_name, self.value(***REMOVED***, attrs***REMOVED***:
            yield subwidget

    def __len__(self***REMOVED***:
        return len(list(self.__iter__(***REMOVED******REMOVED******REMOVED***

    def __getitem__(self, idx***REMOVED***:
        # Prevent unnecessary reevaluation when accessing BoundField's attrs
        # from templates.
        if not isinstance(idx, six.integer_types + (slice,***REMOVED******REMOVED***:
            raise TypeError
        return list(self.__iter__(***REMOVED******REMOVED***[idx***REMOVED***

    @property
    def errors(self***REMOVED***:
        ***REMOVED***
        Returns an ErrorList for this field. Returns an empty ErrorList
        if there are none.
        ***REMOVED***
        return self.form.errors.get(self.name, self.form.error_class(***REMOVED******REMOVED***

    def as_widget(self, widget=None, attrs=None, only_initial=False***REMOVED***:
        ***REMOVED***
        Renders the field by rendering the passed widget, adding any HTML
        attributes passed as attrs.  If no widget is specified, then the
        field's default widget will be used.
        ***REMOVED***
        if not widget:
            widget = self.field.widget

        if self.field.localize:
            widget.is_localized = True

        attrs = attrs or {***REMOVED***
        attrs = self.build_widget_attrs(attrs, widget***REMOVED***
        auto_id = self.auto_id
        if auto_id and 'id' not in attrs and 'id' not in widget.attrs:
            if not only_initial:
                attrs['id'***REMOVED*** = auto_id
            else:
                attrs['id'***REMOVED*** = self.html_initial_id

        if not only_initial:
            name = self.html_name
        else:
            name = self.html_initial_name
        return force_text(widget.render(name, self.value(***REMOVED***, attrs=attrs***REMOVED******REMOVED***

    def as_text(self, attrs=None, **kwargs***REMOVED***:
        ***REMOVED***
        Returns a string of HTML for representing this as an <input type="text">.
        ***REMOVED***
        return self.as_widget(TextInput(***REMOVED***, attrs, **kwargs***REMOVED***

    def as_textarea(self, attrs=None, **kwargs***REMOVED***:
        "Returns a string of HTML for representing this as a <textarea>."
        return self.as_widget(Textarea(***REMOVED***, attrs, **kwargs***REMOVED***

    def as_hidden(self, attrs=None, **kwargs***REMOVED***:
        ***REMOVED***
        Returns a string of HTML for representing this as an <input type="hidden">.
        ***REMOVED***
        return self.as_widget(self.field.hidden_widget(***REMOVED***, attrs, **kwargs***REMOVED***

    @property
    def data(self***REMOVED***:
        ***REMOVED***
        Returns the data for this BoundField, or None if it wasn't given.
        ***REMOVED***
        return self.field.widget.value_from_datadict(self.form.data, self.form.files, self.html_name***REMOVED***

    def value(self***REMOVED***:
        ***REMOVED***
        Returns the value for this BoundField, using the initial value if
        the form is not bound or the data otherwise.
        ***REMOVED***
        if not self.form.is_bound:
            data = self.initial
        else:
            data = self.field.bound_data(
                self.data, self.form.initial.get(self.name, self.field.initial***REMOVED***
            ***REMOVED***
        return self.field.prepare_value(data***REMOVED***

    def label_tag(self, contents=None, attrs=None, label_suffix=None***REMOVED***:
        ***REMOVED***
        Wraps the given contents in a <label>, if the field has an ID attribute.
        contents should be 'mark_safe'd to avoid HTML escaping. If contents
        aren't given, uses the field's HTML-escaped label.

        If attrs are given, they're used as HTML attributes on the <label> tag.

        label_suffix allows overriding the form's label_suffix.
        ***REMOVED***
        contents = contents or self.label
        if label_suffix is None:
            label_suffix = (self.field.label_suffix if self.field.label_suffix is not None
                            else self.form.label_suffix***REMOVED***
        # Only add the suffix if the label does not end in punctuation.
        # Translators: If found as last label character, these punctuation
        # characters will prevent the default label_suffix to be appended to the label
        if label_suffix and contents and contents[-1***REMOVED*** not in _(':?.!'***REMOVED***:
            contents = format_html('{***REMOVED***{***REMOVED***', contents, label_suffix***REMOVED***
        widget = self.field.widget
        id_ = widget.attrs.get('id'***REMOVED*** or self.auto_id
        if id_:
            id_for_label = widget.id_for_label(id_***REMOVED***
            if id_for_label:
                attrs = dict(attrs or {***REMOVED***, **{'for': id_for_label***REMOVED******REMOVED***
            if self.field.required and hasattr(self.form, 'required_css_class'***REMOVED***:
                attrs = attrs or {***REMOVED***
                if 'class' in attrs:
                    attrs['class'***REMOVED*** += ' ' + self.form.required_css_class
                else:
                    attrs['class'***REMOVED*** = self.form.required_css_class
            attrs = flatatt(attrs***REMOVED*** if attrs else ''
            contents = format_html('<label{***REMOVED***>{***REMOVED***</label>', attrs, contents***REMOVED***
        else:
            contents = conditional_escape(contents***REMOVED***
        return mark_safe(contents***REMOVED***

    def css_classes(self, extra_classes=None***REMOVED***:
        ***REMOVED***
        Returns a string of space-separated CSS classes for this field.
        ***REMOVED***
        if hasattr(extra_classes, 'split'***REMOVED***:
            extra_classes = extra_classes.split(***REMOVED***
        extra_classes = set(extra_classes or [***REMOVED******REMOVED***
        if self.errors and hasattr(self.form, 'error_css_class'***REMOVED***:
            extra_classes.add(self.form.error_css_class***REMOVED***
        if self.field.required and hasattr(self.form, 'required_css_class'***REMOVED***:
            extra_classes.add(self.form.required_css_class***REMOVED***
        return ' '.join(extra_classes***REMOVED***

    @property
    def is_hidden(self***REMOVED***:
        "Returns True if this BoundField's widget is hidden."
        return self.field.widget.is_hidden

    @property
    def auto_id(self***REMOVED***:
        ***REMOVED***
        Calculates and returns the ID attribute for this BoundField, if the
        associated Form has specified auto_id. Returns an empty string otherwise.
        ***REMOVED***
        auto_id = self.form.auto_id
        if auto_id and '%s' in smart_text(auto_id***REMOVED***:
            return smart_text(auto_id***REMOVED*** % self.html_name
        elif auto_id:
            return self.html_name
        return ''

    @property
    def id_for_label(self***REMOVED***:
        ***REMOVED***
        Wrapper around the field widget's `id_for_label` method.
        Useful, for example, for focusing on this field regardless of whether
        it has a single widget or a MultiWidget.
        ***REMOVED***
        widget = self.field.widget
        id_ = widget.attrs.get('id'***REMOVED*** or self.auto_id
        return widget.id_for_label(id_***REMOVED***

    @property
    def initial(self***REMOVED***:
        data = self.form.initial.get(self.name, self.field.initial***REMOVED***
        if callable(data***REMOVED***:
            if self._initial_value is not UNSET:
                data = self._initial_value
            else:
                data = data(***REMOVED***
                # If this is an auto-generated default date, nix the
                # microseconds for standardized handling. See #22502.
                if (isinstance(data, (datetime.datetime, datetime.time***REMOVED******REMOVED*** and
                        not self.field.widget.supports_microseconds***REMOVED***:
                    data = data.replace(microsecond=0***REMOVED***
                self._initial_value = data
        return data

    def build_widget_attrs(self, attrs, widget=None***REMOVED***:
        if not widget:
            widget = self.field.widget
        attrs = dict(attrs***REMOVED***  # Copy attrs to avoid modifying the argument.
        if widget.use_required_attribute(self.initial***REMOVED*** and self.field.required and self.form.use_required_attribute:
            attrs['required'***REMOVED*** = True
        if self.field.disabled:
            attrs['disabled'***REMOVED*** = True
        return attrs
