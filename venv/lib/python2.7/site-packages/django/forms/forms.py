***REMOVED***
Form classes
***REMOVED***

from __future__ import unicode_literals

import copy
from collections import OrderedDict

from django.core.exceptions import NON_FIELD_ERRORS, ValidationError
# BoundField is imported for backwards compatibility in Django 1.9
from django.forms.boundfield import BoundField  # NOQA
from django.forms.fields import Field, FileField
# pretty_name is imported for backwards compatibility in Django 1.9
from django.forms.utils import ErrorDict, ErrorList, pretty_name  # NOQA
from django.forms.widgets import Media, MediaDefiningClass
from django.utils import six
from django.utils.encoding import force_text, python_2_unicode_compatible
from django.utils.functional import cached_property
from django.utils.html import conditional_escape, html_safe
from django.utils.safestring import mark_safe
from django.utils.translation import ugettext as _

__all__ = ('BaseForm', 'Form'***REMOVED***


class DeclarativeFieldsMetaclass(MediaDefiningClass***REMOVED***:
    ***REMOVED***
    Metaclass that collects Fields declared on the base classes.
    ***REMOVED***
    def __new__(mcs, name, bases, attrs***REMOVED***:
        # Collect fields from current class.
        current_fields = [***REMOVED***
        for key, value in list(attrs.items(***REMOVED******REMOVED***:
            if isinstance(value, Field***REMOVED***:
                current_fields.append((key, value***REMOVED******REMOVED***
                attrs.pop(key***REMOVED***
        current_fields.sort(key=lambda x: x[1***REMOVED***.creation_counter***REMOVED***
        attrs['declared_fields'***REMOVED*** = OrderedDict(current_fields***REMOVED***

        new_class = super(DeclarativeFieldsMetaclass, mcs***REMOVED***.__new__(mcs, name, bases, attrs***REMOVED***

        # Walk through the MRO.
        declared_fields = OrderedDict(***REMOVED***
        for base in reversed(new_class.__mro__***REMOVED***:
            # Collect fields from base class.
            if hasattr(base, 'declared_fields'***REMOVED***:
                declared_fields.update(base.declared_fields***REMOVED***

            # Field shadowing.
            for attr, value in base.__dict__.items(***REMOVED***:
                if value is None and attr in declared_fields:
                    declared_fields.pop(attr***REMOVED***

        new_class.base_fields = declared_fields
        new_class.declared_fields = declared_fields

        return new_class


@html_safe
@python_2_unicode_compatible
class BaseForm(object***REMOVED***:
    # This is the main implementation of all the Form logic. Note that this
    # class is different than Form. See the comments by the Form class for more
    # information. Any improvements to the form API should be made to *this*
    # class, not to the Form class.
    field_order = None
    prefix = None
    use_required_attribute = True

    def __init__(self, data=None, files=None, auto_id='id_%s', prefix=None,
                 initial=None, error_class=ErrorList, label_suffix=None,
                 empty_permitted=False, field_order=None, use_required_attribute=None***REMOVED***:
        self.is_bound = data is not None or files is not None
        self.data = data or {***REMOVED***
        self.files = files or {***REMOVED***
        self.auto_id = auto_id
        if prefix is not None:
            self.prefix = prefix
        self.initial = initial or {***REMOVED***
        self.error_class = error_class
        # Translators: This is the default suffix added to form field labels
        self.label_suffix = label_suffix if label_suffix is not None else _(':'***REMOVED***
        self.empty_permitted = empty_permitted
        self._errors = None  # Stores the errors after clean(***REMOVED*** has been called.

        # The base_fields class attribute is the *class-wide* definition of
        # fields. Because a particular *instance* of the class might want to
        # alter self.fields, we create self.fields here by copying base_fields.
        # Instances should always modify self.fields; they should not modify
        # self.base_fields.
        self.fields = copy.deepcopy(self.base_fields***REMOVED***
        self._bound_fields_cache = {***REMOVED***
        self.order_fields(self.field_order if field_order is None else field_order***REMOVED***

        if use_required_attribute is not None:
            self.use_required_attribute = use_required_attribute

    def order_fields(self, field_order***REMOVED***:
        ***REMOVED***
        Rearranges the fields according to field_order.

        field_order is a list of field names specifying the order. Fields not
        included in the list are appended in the default order for backward
        compatibility with subclasses not overriding field_order. If field_order
        is None, all fields are kept in the order defined in the class.
        Unknown fields in field_order are ignored to allow disabling fields in
        form subclasses without redefining ordering.
        ***REMOVED***
        if field_order is None:
            return
        fields = OrderedDict(***REMOVED***
        for key in field_order:
            ***REMOVED***
                fields[key***REMOVED*** = self.fields.pop(key***REMOVED***
            except KeyError:  # ignore unknown fields
                pass
        fields.update(self.fields***REMOVED***  # add remaining fields in original order
        self.fields = fields

    def __str__(self***REMOVED***:
        return self.as_table(***REMOVED***

    def __repr__(self***REMOVED***:
        if self._errors is None:
            is_valid = "Unknown"
        else:
            is_valid = self.is_bound and not bool(self._errors***REMOVED***
        return '<%(cls***REMOVED***s bound=%(bound***REMOVED***s, valid=%(valid***REMOVED***s, fields=(%(fields***REMOVED***s***REMOVED***>' % {
            'cls': self.__class__.__name__,
            'bound': self.is_bound,
            'valid': is_valid,
            'fields': ';'.join(self.fields***REMOVED***,
    ***REMOVED***

    def __iter__(self***REMOVED***:
        for name in self.fields:
            yield self[name***REMOVED***

    def __getitem__(self, name***REMOVED***:
        "Returns a BoundField with the given name."
        ***REMOVED***
            field = self.fields[name***REMOVED***
        except KeyError:
            raise KeyError(
                "Key '%s' not found in '%s'. Choices are: %s." % (
                    name,
                    self.__class__.__name__,
                    ', '.join(sorted(f for f in self.fields***REMOVED******REMOVED***,
                ***REMOVED***
            ***REMOVED***
        if name not in self._bound_fields_cache:
            self._bound_fields_cache[name***REMOVED*** = field.get_bound_field(self, name***REMOVED***
        return self._bound_fields_cache[name***REMOVED***

    @property
    def errors(self***REMOVED***:
        "Returns an ErrorDict for the data provided for the form"
        if self._errors is None:
            self.full_clean(***REMOVED***
        return self._errors

    def is_valid(self***REMOVED***:
        ***REMOVED***
        Returns True if the form has no errors. Otherwise, False. If errors are
        being ignored, returns False.
        ***REMOVED***
        return self.is_bound and not self.errors

    def add_prefix(self, field_name***REMOVED***:
        ***REMOVED***
        Returns the field name with a prefix appended, if this Form has a
        prefix set.

        Subclasses may wish to override.
        ***REMOVED***
        return '%s-%s' % (self.prefix, field_name***REMOVED*** if self.prefix else field_name

    def add_initial_prefix(self, field_name***REMOVED***:
        ***REMOVED***
        Add a 'initial' prefix for checking dynamic initial values
        ***REMOVED***
        return 'initial-%s' % self.add_prefix(field_name***REMOVED***

    def _html_output(self, normal_row, error_row, row_ender, help_text_html, errors_on_separate_row***REMOVED***:
        "Helper function for outputting HTML. Used by as_table(***REMOVED***, as_ul(***REMOVED***, as_p(***REMOVED***."
        top_errors = self.non_field_errors(***REMOVED***  # Errors that should be displayed above all fields.
        output, hidden_fields = [***REMOVED***, [***REMOVED***

        for name, field in self.fields.items(***REMOVED***:
            html_class_attr = ''
            bf = self[name***REMOVED***
            # Escape and cache in local variable.
            bf_errors = self.error_class([conditional_escape(error***REMOVED*** for error in bf.errors***REMOVED******REMOVED***
            if bf.is_hidden:
                if bf_errors:
                    top_errors.extend(
                        [_('(Hidden field %(name***REMOVED***s***REMOVED*** %(error***REMOVED***s'***REMOVED*** % {'name': name, 'error': force_text(e***REMOVED******REMOVED***
                         for e in bf_errors***REMOVED******REMOVED***
                hidden_fields.append(six.text_type(bf***REMOVED******REMOVED***
            else:
                # Create a 'class="..."' attribute if the row should have any
                # CSS classes applied.
                css_classes = bf.css_classes(***REMOVED***
                if css_classes:
                    html_class_attr = ' class="%s"' % css_classes

                if errors_on_separate_row and bf_errors:
                    output.append(error_row % force_text(bf_errors***REMOVED******REMOVED***

                if bf.label:
                    label = conditional_escape(force_text(bf.label***REMOVED******REMOVED***
                    label = bf.label_tag(label***REMOVED*** or ''
                else:
                    label = ''

                if field.help_text:
                    help_text = help_text_html % force_text(field.help_text***REMOVED***
                else:
                    help_text = ''

                output.append(normal_row % {
                    'errors': force_text(bf_errors***REMOVED***,
                    'label': force_text(label***REMOVED***,
                    'field': six.text_type(bf***REMOVED***,
                    'help_text': help_text,
                    'html_class_attr': html_class_attr,
                    'css_classes': css_classes,
                    'field_name': bf.html_name,
            ***REMOVED******REMOVED***

        if top_errors:
            output.insert(0, error_row % force_text(top_errors***REMOVED******REMOVED***

        if hidden_fields:  # Insert any hidden fields in the last row.
            str_hidden = ''.join(hidden_fields***REMOVED***
            if output:
                last_row = output[-1***REMOVED***
                # Chop off the trailing row_ender (e.g. '</td></tr>'***REMOVED*** and
                # insert the hidden fields.
                if not last_row.endswith(row_ender***REMOVED***:
                    # This can happen in the as_p(***REMOVED*** case (and possibly others
                    # that users write***REMOVED***: if there are only top errors, we may
                    # not be able to conscript the last row for our purposes,
                    # so insert a new, empty row.
                    last_row = (normal_row % {
                        'errors': '',
                        'label': '',
                        'field': '',
                        'help_text': '',
                        'html_class_attr': html_class_attr,
                        'css_classes': '',
                        'field_name': '',
                ***REMOVED******REMOVED***
                    output.append(last_row***REMOVED***
                output[-1***REMOVED*** = last_row[:-len(row_ender***REMOVED******REMOVED*** + str_hidden + row_ender
            else:
                # If there aren't any rows in the output, just append the
                # hidden fields.
                output.append(str_hidden***REMOVED***
        return mark_safe('\n'.join(output***REMOVED******REMOVED***

    def as_table(self***REMOVED***:
        "Returns this form rendered as HTML <tr>s -- excluding the <table></table>."
        return self._html_output(
            normal_row='<tr%(html_class_attr***REMOVED***s><th>%(label***REMOVED***s</th><td>%(errors***REMOVED***s%(field***REMOVED***s%(help_text***REMOVED***s</td></tr>',
            error_row='<tr><td colspan="2">%s</td></tr>',
            row_ender='</td></tr>',
            help_text_html='<br /><span class="helptext">%s</span>',
            errors_on_separate_row=False***REMOVED***

    def as_ul(self***REMOVED***:
        "Returns this form rendered as HTML <li>s -- excluding the <ul></ul>."
        return self._html_output(
            normal_row='<li%(html_class_attr***REMOVED***s>%(errors***REMOVED***s%(label***REMOVED***s %(field***REMOVED***s%(help_text***REMOVED***s</li>',
            error_row='<li>%s</li>',
            row_ender='</li>',
            help_text_html=' <span class="helptext">%s</span>',
            errors_on_separate_row=False***REMOVED***

    def as_p(self***REMOVED***:
        "Returns this form rendered as HTML <p>s."
        return self._html_output(
            normal_row='<p%(html_class_attr***REMOVED***s>%(label***REMOVED***s %(field***REMOVED***s%(help_text***REMOVED***s</p>',
            error_row='%s',
            row_ender='</p>',
            help_text_html=' <span class="helptext">%s</span>',
            errors_on_separate_row=True***REMOVED***

    def non_field_errors(self***REMOVED***:
        ***REMOVED***
        Returns an ErrorList of errors that aren't associated with a particular
        field -- i.e., from Form.clean(***REMOVED***. Returns an empty ErrorList if there
        are none.
        ***REMOVED***
        return self.errors.get(NON_FIELD_ERRORS, self.error_class(error_class='nonfield'***REMOVED******REMOVED***

    def add_error(self, field, error***REMOVED***:
        ***REMOVED***
        Update the content of `self._errors`.

        The `field` argument is the name of the field to which the errors
        should be added. If its value is None the errors will be treated as
        NON_FIELD_ERRORS.

        The `error` argument can be a single error, a list of errors, or a
        dictionary that maps field names to lists of errors. What we define as
        an "error" can be either a simple string or an instance of
        ValidationError with its message attribute set and what we define as
        list or dictionary can be an actual `list` or `dict` or an instance
        of ValidationError with its `error_list` or `error_dict` attribute set.

        If `error` is a dictionary, the `field` argument *must* be None and
        errors will be added to the fields that correspond to the keys of the
        dictionary.
        ***REMOVED***
        if not isinstance(error, ValidationError***REMOVED***:
            # Normalize to ValidationError and let its constructor
            # do the hard work of making sense of the input.
            error = ValidationError(error***REMOVED***

        if hasattr(error, 'error_dict'***REMOVED***:
            if field is not None:
                raise TypeError(
                    "The argument `field` must be `None` when the `error` "
                    "argument contains errors for multiple fields."
                ***REMOVED***
            else:
                error = error.error_dict
        else:
            error = {field or NON_FIELD_ERRORS: error.error_list***REMOVED***

        for field, error_list in error.items(***REMOVED***:
            if field not in self.errors:
                if field != NON_FIELD_ERRORS and field not in self.fields:
                    raise ValueError(
                        "'%s' has no field named '%s'." % (self.__class__.__name__, field***REMOVED******REMOVED***
                if field == NON_FIELD_ERRORS:
                    self._errors[field***REMOVED*** = self.error_class(error_class='nonfield'***REMOVED***
                else:
                    self._errors[field***REMOVED*** = self.error_class(***REMOVED***
            self._errors[field***REMOVED***.extend(error_list***REMOVED***
            if field in self.cleaned_data:
                del self.cleaned_data[field***REMOVED***

    def has_error(self, field, code=None***REMOVED***:
        if code is None:
            return field in self.errors
        if field in self.errors:
            for error in self.errors.as_data(***REMOVED***[field***REMOVED***:
                if error.code == code:
                    return True
        return False

    def full_clean(self***REMOVED***:
        ***REMOVED***
        Cleans all of self.data and populates self._errors and
        self.cleaned_data.
        ***REMOVED***
        self._errors = ErrorDict(***REMOVED***
        if not self.is_bound:  # Stop further processing.
            return
        self.cleaned_data = {***REMOVED***
        # If the form is permitted to be empty, and none of the form data has
        # changed from the initial data, short circuit any validation.
        if self.empty_permitted and not self.has_changed(***REMOVED***:
            return

        self._clean_fields(***REMOVED***
        self._clean_form(***REMOVED***
        self._post_clean(***REMOVED***

    def _clean_fields(self***REMOVED***:
        for name, field in self.fields.items(***REMOVED***:
            # value_from_datadict(***REMOVED*** gets the data from the data dictionaries.
            # Each widget type knows how to retrieve its own data, because some
            # widgets split data over several HTML fields.
            if field.disabled:
                value = self.initial.get(name, field.initial***REMOVED***
            else:
                value = field.widget.value_from_datadict(self.data, self.files, self.add_prefix(name***REMOVED******REMOVED***
            ***REMOVED***
                if isinstance(field, FileField***REMOVED***:
                    initial = self.initial.get(name, field.initial***REMOVED***
                    value = field.clean(value, initial***REMOVED***
                else:
                    value = field.clean(value***REMOVED***
                self.cleaned_data[name***REMOVED*** = value
                if hasattr(self, 'clean_%s' % name***REMOVED***:
                    value = getattr(self, 'clean_%s' % name***REMOVED***(***REMOVED***
                    self.cleaned_data[name***REMOVED*** = value
            except ValidationError as e:
                self.add_error(name, e***REMOVED***

    def _clean_form(self***REMOVED***:
        ***REMOVED***
            cleaned_data = self.clean(***REMOVED***
        except ValidationError as e:
            self.add_error(None, e***REMOVED***
        else:
            if cleaned_data is not None:
                self.cleaned_data = cleaned_data

    def _post_clean(self***REMOVED***:
        ***REMOVED***
        An internal hook for performing additional cleaning after form cleaning
        is complete. Used for model validation in model forms.
        ***REMOVED***
        pass

    def clean(self***REMOVED***:
        ***REMOVED***
        Hook for doing any extra form-wide cleaning after Field.clean(***REMOVED*** has been
        called on every field. Any ValidationError raised by this method will
        not be associated with a particular field; it will have a special-case
        association with the field named '__all__'.
        ***REMOVED***
        return self.cleaned_data

    def has_changed(self***REMOVED***:
        ***REMOVED***
        Returns True if data differs from initial.
        ***REMOVED***
        return bool(self.changed_data***REMOVED***

    @cached_property
    def changed_data(self***REMOVED***:
        data = [***REMOVED***
        for name, field in self.fields.items(***REMOVED***:
            prefixed_name = self.add_prefix(name***REMOVED***
            data_value = field.widget.value_from_datadict(self.data, self.files, prefixed_name***REMOVED***
            if not field.show_hidden_initial:
                initial_value = self.initial.get(name, field.initial***REMOVED***
                if callable(initial_value***REMOVED***:
                    initial_value = initial_value(***REMOVED***
            else:
                initial_prefixed_name = self.add_initial_prefix(name***REMOVED***
                hidden_widget = field.hidden_widget(***REMOVED***
                ***REMOVED***
                    initial_value = field.to_python(hidden_widget.value_from_datadict(
                        self.data, self.files, initial_prefixed_name***REMOVED******REMOVED***
                except ValidationError:
                    # Always assume data has changed if validation fails.
                    data.append(name***REMOVED***
                    continue
            if field.has_changed(initial_value, data_value***REMOVED***:
                data.append(name***REMOVED***
        return data

    @property
    def media(self***REMOVED***:
        ***REMOVED***
        Provide a description of all media required to render the widgets on this form
        ***REMOVED***
        media = Media(***REMOVED***
        for field in self.fields.values(***REMOVED***:
            media = media + field.widget.media
        return media

    def is_multipart(self***REMOVED***:
        ***REMOVED***
        Returns True if the form needs to be multipart-encoded, i.e. it has
        FileInput. Otherwise, False.
        ***REMOVED***
        for field in self.fields.values(***REMOVED***:
            if field.widget.needs_multipart_form:
                return True
        return False

    def hidden_fields(self***REMOVED***:
        ***REMOVED***
        Returns a list of all the BoundField objects that are hidden fields.
        Useful for manual form layout in templates.
        ***REMOVED***
        return [field for field in self if field.is_hidden***REMOVED***

    def visible_fields(self***REMOVED***:
        ***REMOVED***
        Returns a list of BoundField objects that aren't hidden fields.
        The opposite of the hidden_fields(***REMOVED*** method.
        ***REMOVED***
        return [field for field in self if not field.is_hidden***REMOVED***


class Form(six.with_metaclass(DeclarativeFieldsMetaclass, BaseForm***REMOVED******REMOVED***:
    "A collection of Fields, plus their associated data."
    # This is a separate class from BaseForm in order to abstract the way
    # self.fields is specified. This class (Form***REMOVED*** is the one that does the
    # fancy metaclass stuff purely for the semantic sugar -- it allows one
    # to define a form using declarative syntax.
    # BaseForm itself has no way of designating self.fields.
