from __future__ import unicode_literals

from threading import local

from django.utils import six
from django.utils.encoding import force_text, iri_to_uri
from django.utils.functional import lazy
from django.utils.six.moves.urllib.parse import urlsplit, urlunsplit
from django.utils.translation import override

from .exceptions import NoReverseMatch, Resolver404
from .resolvers import get_ns_resolver, get_resolver
from .utils import get_callable

# SCRIPT_NAME prefixes for each thread are stored here. If there's no entry for
# the current thread (which is the only one we ever access***REMOVED***, it is assumed to
# be empty.
_prefixes = local(***REMOVED***

# Overridden URLconfs for each thread are stored here.
_urlconfs = local(***REMOVED***


def resolve(path, urlconf=None***REMOVED***:
    if urlconf is None:
        urlconf = get_urlconf(***REMOVED***
    return get_resolver(urlconf***REMOVED***.resolve(path***REMOVED***


def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None***REMOVED***:
    if urlconf is None:
        urlconf = get_urlconf(***REMOVED***
    resolver = get_resolver(urlconf***REMOVED***
    args = args or [***REMOVED***
    kwargs = kwargs or {***REMOVED***

    prefix = get_script_prefix(***REMOVED***

    if not isinstance(viewname, six.string_types***REMOVED***:
        view = viewname
    else:
        parts = viewname.split(':'***REMOVED***
        parts.reverse(***REMOVED***
        view = parts[0***REMOVED***
        path = parts[1:***REMOVED***

        if current_app:
            current_path = current_app.split(':'***REMOVED***
            current_path.reverse(***REMOVED***
        else:
            current_path = None

        resolved_path = [***REMOVED***
        ns_pattern = ''
        while path:
            ns = path.pop(***REMOVED***
            current_ns = current_path.pop(***REMOVED*** if current_path else None
            # Lookup the name to see if it could be an app identifier.
            ***REMOVED***
                app_list = resolver.app_dict[ns***REMOVED***
                # Yes! Path part matches an app in the current Resolver.
                if current_ns and current_ns in app_list:
                    # If we are reversing for a particular app, use that
                    # namespace.
                    ns = current_ns
                elif ns not in app_list:
                    # The name isn't shared by one of the instances (i.e.,
                    # the default***REMOVED*** so pick the first instance as the default.
                    ns = app_list[0***REMOVED***
            except KeyError:
                pass

            if ns != current_ns:
                current_path = None

            ***REMOVED***
                extra, resolver = resolver.namespace_dict[ns***REMOVED***
                resolved_path.append(ns***REMOVED***
                ns_pattern = ns_pattern + extra
            except KeyError as key:
                if resolved_path:
                    raise NoReverseMatch(
                        "%s is not a registered namespace inside '%s'" %
                        (key, ':'.join(resolved_path***REMOVED******REMOVED***
                    ***REMOVED***
                else:
                    raise NoReverseMatch("%s is not a registered namespace" % key***REMOVED***
        if ns_pattern:
            resolver = get_ns_resolver(ns_pattern, resolver***REMOVED***

    return force_text(iri_to_uri(resolver._reverse_with_prefix(view, prefix, *args, **kwargs***REMOVED******REMOVED******REMOVED***

reverse_lazy = lazy(reverse, six.text_type***REMOVED***


def clear_url_caches(***REMOVED***:
    get_callable.cache_clear(***REMOVED***
    get_resolver.cache_clear(***REMOVED***
    get_ns_resolver.cache_clear(***REMOVED***


def set_script_prefix(prefix***REMOVED***:
    ***REMOVED***
    Set the script prefix for the current thread.
    ***REMOVED***
    if not prefix.endswith('/'***REMOVED***:
        prefix += '/'
    _prefixes.value = prefix


def get_script_prefix(***REMOVED***:
    ***REMOVED***
    Return the currently active script prefix. Useful for client code that
    wishes to construct their own URLs manually (although accessing the request
    instance is normally going to be a lot cleaner***REMOVED***.
    ***REMOVED***
    return getattr(_prefixes, "value", '/'***REMOVED***


def clear_script_prefix(***REMOVED***:
    ***REMOVED***
    Unset the script prefix for the current thread.
    ***REMOVED***
    ***REMOVED***
        del _prefixes.value
    except AttributeError:
        pass


def set_urlconf(urlconf_name***REMOVED***:
    ***REMOVED***
    Set the URLconf for the current thread (overriding the default one in
    settings***REMOVED***. If urlconf_name is None, revert back to the default.
    ***REMOVED***
    if urlconf_name:
        _urlconfs.value = urlconf_name
    else:
        if hasattr(_urlconfs, "value"***REMOVED***:
            del _urlconfs.value


def get_urlconf(default=None***REMOVED***:
    ***REMOVED***
    Return the root URLconf to use for the current thread if it has been
    changed from the default one.
    ***REMOVED***
    return getattr(_urlconfs, "value", default***REMOVED***


def is_valid_path(path, urlconf=None***REMOVED***:
    ***REMOVED***
    Return True if the given path resolves against the default URL resolver,
    False otherwise. This is a convenience method to make working with "is
    this a match?" cases easier, avoiding try...except blocks.
    ***REMOVED***
    ***REMOVED***
        resolve(path, urlconf***REMOVED***
        return True
    except Resolver404:
        return False


def translate_url(url, lang_code***REMOVED***:
    ***REMOVED***
    Given a URL (absolute or relative***REMOVED***, try to get its translated version in
    the `lang_code` language (either by i18n_patterns or by translated regex***REMOVED***.
    Return the original URL if no translated version is found.
    ***REMOVED***
    parsed = urlsplit(url***REMOVED***
    ***REMOVED***
        match = resolve(parsed.path***REMOVED***
    except Resolver404:
        pass
    else:
        to_be_reversed = "%s:%s" % (match.namespace, match.url_name***REMOVED*** if match.namespace else match.url_name
        with override(lang_code***REMOVED***:
            ***REMOVED***
                url = reverse(to_be_reversed, args=match.args, kwargs=match.kwargs***REMOVED***
            except NoReverseMatch:
                pass
            else:
                url = urlunsplit((parsed.scheme, parsed.netloc, url, parsed.query, parsed.fragment***REMOVED******REMOVED***
    return url
