***REMOVED***
This module converts requested URLs to callback view functions.

RegexURLResolver is the main class here. Its resolve(***REMOVED*** method takes a URL (as
a string***REMOVED*** and returns a ResolverMatch object which provides access to all
attributes of the resolved URL match.
***REMOVED***
from __future__ import unicode_literals

import functools
import re
import threading
from importlib import import_module

from django.conf import settings
from django.core.exceptions import ImproperlyConfigured
from django.utils import lru_cache, six
from django.utils.datastructures import MultiValueDict
from django.utils.encoding import force_str, force_text
from django.utils.functional import cached_property
from django.utils.http import RFC3986_SUBDELIMS, urlquote
from django.utils.regex_helper import normalize
from django.utils.translation import get_language

from .exceptions import NoReverseMatch, Resolver404
from .utils import get_callable


class ResolverMatch(object***REMOVED***:
    def __init__(self, func, args, kwargs, url_name=None, app_names=None, namespaces=None***REMOVED***:
        self.func = func
        self.args = args
        self.kwargs = kwargs
        self.url_name = url_name

        # If a URLRegexResolver doesn't have a namespace or app_name, it passes
        # in an empty value.
        self.app_names = [x for x in app_names if x***REMOVED*** if app_names else [***REMOVED***
        self.app_name = ':'.join(self.app_names***REMOVED***
        self.namespaces = [x for x in namespaces if x***REMOVED*** if namespaces else [***REMOVED***
        self.namespace = ':'.join(self.namespaces***REMOVED***

        if not hasattr(func, '__name__'***REMOVED***:
            # A class-based view
            self._func_path = '.'.join([func.__class__.__module__, func.__class__.__name__***REMOVED******REMOVED***
        else:
            # A function-based view
            self._func_path = '.'.join([func.__module__, func.__name__***REMOVED******REMOVED***

        view_path = url_name or self._func_path
        self.view_name = ':'.join(self.namespaces + [view_path***REMOVED******REMOVED***

    def __getitem__(self, index***REMOVED***:
        return (self.func, self.args, self.kwargs***REMOVED***[index***REMOVED***

    def __repr__(self***REMOVED***:
        return "ResolverMatch(func=%s, args=%s, kwargs=%s, url_name=%s, app_names=%s, namespaces=%s***REMOVED***" % (
            self._func_path, self.args, self.kwargs, self.url_name,
            self.app_names, self.namespaces,
        ***REMOVED***


@lru_cache.lru_cache(maxsize=None***REMOVED***
def get_resolver(urlconf=None***REMOVED***:
    if urlconf is None:
        from django.conf import settings
        urlconf = settings.ROOT_URLCONF
    return RegexURLResolver(r'^/', urlconf***REMOVED***


@lru_cache.lru_cache(maxsize=None***REMOVED***
def get_ns_resolver(ns_pattern, resolver***REMOVED***:
    # Build a namespaced resolver for the given parent URLconf pattern.
    # This makes it possible to have captured parameters in the parent
    # URLconf pattern.
    ns_resolver = RegexURLResolver(ns_pattern, resolver.url_patterns***REMOVED***
    return RegexURLResolver(r'^/', [ns_resolver***REMOVED******REMOVED***


class LocaleRegexProvider(object***REMOVED***:
    ***REMOVED***
    A mixin to provide a default regex property which can vary by active
    language.
    ***REMOVED***
    def __init__(self, regex***REMOVED***:
        # regex is either a string representing a regular expression, or a
        # translatable string (using ugettext_lazy***REMOVED*** representing a regular
        # expression.
        self._regex = regex
        self._regex_dict = {***REMOVED***

    @property
    def regex(self***REMOVED***:
        ***REMOVED***
        Return a compiled regular expression based on the activate language.
        ***REMOVED***
        language_code = get_language(***REMOVED***
        if language_code not in self._regex_dict:
            regex = self._regex if isinstance(self._regex, six.string_types***REMOVED*** else force_text(self._regex***REMOVED***
            ***REMOVED***
                compiled_regex = re.compile(regex, re.UNICODE***REMOVED***
            except re.error as e:
                raise ImproperlyConfigured(
                    '"%s" is not a valid regular expression: %s' %
                    (regex, six.text_type(e***REMOVED******REMOVED***
                ***REMOVED***
            self._regex_dict[language_code***REMOVED*** = compiled_regex
        return self._regex_dict[language_code***REMOVED***


class RegexURLPattern(LocaleRegexProvider***REMOVED***:
    def __init__(self, regex, callback, default_args=None, name=None***REMOVED***:
        LocaleRegexProvider.__init__(self, regex***REMOVED***
        self.callback = callback  # the view
        self.default_args = default_args or {***REMOVED***
        self.name = name

    def __repr__(self***REMOVED***:
        return force_str('<%s %s %s>' % (self.__class__.__name__, self.name, self.regex.pattern***REMOVED******REMOVED***

    def resolve(self, path***REMOVED***:
        match = self.regex.search(path***REMOVED***
        if match:
            # If there are any named groups, use those as kwargs, ignoring
            # non-named groups. Otherwise, pass all non-named arguments as
            # positional arguments.
            kwargs = match.groupdict(***REMOVED***
            args = (***REMOVED*** if kwargs else match.groups(***REMOVED***
            # In both cases, pass any extra_kwargs as **kwargs.
            kwargs.update(self.default_args***REMOVED***
            return ResolverMatch(self.callback, args, kwargs, self.name***REMOVED***

    @cached_property
    def lookup_str(self***REMOVED***:
        ***REMOVED***
        A string that identifies the view (e.g. 'path.to.view_function' or
        'path.to.ClassBasedView'***REMOVED***.
        ***REMOVED***
        callback = self.callback
        # Python 3.5 collapses nested partials, so can change "while" to "if"
        # when it's the minimum supported version.
        while isinstance(callback, functools.partial***REMOVED***:
            callback = callback.func
        if not hasattr(callback, '__name__'***REMOVED***:
            return callback.__module__ + "." + callback.__class__.__name__
        elif six.PY3:
            return callback.__module__ + "." + callback.__qualname__
        else:
            # PY2 does not support __qualname__
            return callback.__module__ + "." + callback.__name__


class RegexURLResolver(LocaleRegexProvider***REMOVED***:
    def __init__(self, regex, urlconf_name, default_kwargs=None, app_name=None, namespace=None***REMOVED***:
        LocaleRegexProvider.__init__(self, regex***REMOVED***
        # urlconf_name is the dotted Python path to the module defining
        # urlpatterns. It may also be an object with an urlpatterns attribute
        # or urlpatterns itself.
        self.urlconf_name = urlconf_name
        self.callback = None
        self.default_kwargs = default_kwargs or {***REMOVED***
        self.namespace = namespace
        self.app_name = app_name
        self._reverse_dict = {***REMOVED***
        self._namespace_dict = {***REMOVED***
        self._app_dict = {***REMOVED***
        # set of dotted paths to all functions and classes that are used in
        # urlpatterns
        self._callback_strs = set(***REMOVED***
        self._populated = False
        self._local = threading.local(***REMOVED***

    def __repr__(self***REMOVED***:
        if isinstance(self.urlconf_name, list***REMOVED*** and len(self.urlconf_name***REMOVED***:
            # Don't bother to output the whole list, it can be huge
            urlconf_repr = '<%s list>' % self.urlconf_name[0***REMOVED***.__class__.__name__
        else:
            urlconf_repr = repr(self.urlconf_name***REMOVED***
        return str('<%s %s (%s:%s***REMOVED*** %s>'***REMOVED*** % (
            self.__class__.__name__, urlconf_repr, self.app_name,
            self.namespace, self.regex.pattern,
        ***REMOVED***

    def _populate(self***REMOVED***:
        # Short-circuit if called recursively in this thread to prevent
        # infinite recursion. Concurrent threads may call this at the same
        # time and will need to continue, so set 'populating' on a
        # thread-local variable.
        if getattr(self._local, 'populating', False***REMOVED***:
            return
        self._local.populating = True
        lookups = MultiValueDict(***REMOVED***
        namespaces = {***REMOVED***
        apps = {***REMOVED***
        language_code = get_language(***REMOVED***
        for pattern in reversed(self.url_patterns***REMOVED***:
            if isinstance(pattern, RegexURLPattern***REMOVED***:
                self._callback_strs.add(pattern.lookup_str***REMOVED***
            p_pattern = pattern.regex.pattern
            if p_pattern.startswith('^'***REMOVED***:
                p_pattern = p_pattern[1:***REMOVED***
            if isinstance(pattern, RegexURLResolver***REMOVED***:
                if pattern.namespace:
                    namespaces[pattern.namespace***REMOVED*** = (p_pattern, pattern***REMOVED***
                    if pattern.app_name:
                        apps.setdefault(pattern.app_name, [***REMOVED******REMOVED***.append(pattern.namespace***REMOVED***
                else:
                    parent_pat = pattern.regex.pattern
                    for name in pattern.reverse_dict:
                        for matches, pat, defaults in pattern.reverse_dict.getlist(name***REMOVED***:
                            new_matches = normalize(parent_pat + pat***REMOVED***
                            lookups.appendlist(
                                name,
                                (
                                    new_matches,
                                    p_pattern + pat,
                                    dict(defaults, **pattern.default_kwargs***REMOVED***,
                                ***REMOVED***
                            ***REMOVED***
                    for namespace, (prefix, sub_pattern***REMOVED*** in pattern.namespace_dict.items(***REMOVED***:
                        namespaces[namespace***REMOVED*** = (p_pattern + prefix, sub_pattern***REMOVED***
                    for app_name, namespace_list in pattern.app_dict.items(***REMOVED***:
                        apps.setdefault(app_name, [***REMOVED******REMOVED***.extend(namespace_list***REMOVED***
                if not getattr(pattern._local, 'populating', False***REMOVED***:
                    pattern._populate(***REMOVED***
                self._callback_strs.update(pattern._callback_strs***REMOVED***
            else:
                bits = normalize(p_pattern***REMOVED***
                lookups.appendlist(pattern.callback, (bits, p_pattern, pattern.default_args***REMOVED******REMOVED***
                if pattern.name is not None:
                    lookups.appendlist(pattern.name, (bits, p_pattern, pattern.default_args***REMOVED******REMOVED***
        self._reverse_dict[language_code***REMOVED*** = lookups
        self._namespace_dict[language_code***REMOVED*** = namespaces
        self._app_dict[language_code***REMOVED*** = apps
        self._populated = True
        self._local.populating = False

    @property
    def reverse_dict(self***REMOVED***:
        language_code = get_language(***REMOVED***
        if language_code not in self._reverse_dict:
            self._populate(***REMOVED***
        return self._reverse_dict[language_code***REMOVED***

    @property
    def namespace_dict(self***REMOVED***:
        language_code = get_language(***REMOVED***
        if language_code not in self._namespace_dict:
            self._populate(***REMOVED***
        return self._namespace_dict[language_code***REMOVED***

    @property
    def app_dict(self***REMOVED***:
        language_code = get_language(***REMOVED***
        if language_code not in self._app_dict:
            self._populate(***REMOVED***
        return self._app_dict[language_code***REMOVED***

    def _is_callback(self, name***REMOVED***:
        if not self._populated:
            self._populate(***REMOVED***
        return name in self._callback_strs

    def resolve(self, path***REMOVED***:
        path = force_text(path***REMOVED***  # path may be a reverse_lazy object
        tried = [***REMOVED***
        match = self.regex.search(path***REMOVED***
        if match:
            new_path = path[match.end(***REMOVED***:***REMOVED***
            for pattern in self.url_patterns:
                ***REMOVED***
                    sub_match = pattern.resolve(new_path***REMOVED***
                except Resolver404 as e:
                    sub_tried = e.args[0***REMOVED***.get('tried'***REMOVED***
                    if sub_tried is not None:
                        tried.extend([pattern***REMOVED*** + t for t in sub_tried***REMOVED***
                    else:
                        tried.append([pattern***REMOVED******REMOVED***
                else:
                    if sub_match:
                        # Merge captured arguments in match with submatch
                        sub_match_dict = dict(match.groupdict(***REMOVED***, **self.default_kwargs***REMOVED***
                        sub_match_dict.update(sub_match.kwargs***REMOVED***

                        # If there are *any* named groups, ignore all non-named groups.
                        # Otherwise, pass all non-named arguments as positional arguments.
                        sub_match_args = sub_match.args
                        if not sub_match_dict:
                            sub_match_args = match.groups(***REMOVED*** + sub_match.args

                        return ResolverMatch(
                            sub_match.func,
                            sub_match_args,
                            sub_match_dict,
                            sub_match.url_name,
                            [self.app_name***REMOVED*** + sub_match.app_names,
                            [self.namespace***REMOVED*** + sub_match.namespaces,
                        ***REMOVED***
                    tried.append([pattern***REMOVED******REMOVED***
            raise Resolver404({'tried': tried, 'path': new_path***REMOVED******REMOVED***
        raise Resolver404({'path': path***REMOVED******REMOVED***

    @cached_property
    def urlconf_module(self***REMOVED***:
        if isinstance(self.urlconf_name, six.string_types***REMOVED***:
            return import_module(self.urlconf_name***REMOVED***
        else:
            return self.urlconf_name

    @cached_property
    def url_patterns(self***REMOVED***:
        # urlconf_module might be a valid set of patterns, so we default to it
        patterns = getattr(self.urlconf_module, "urlpatterns", self.urlconf_module***REMOVED***
        ***REMOVED***
            iter(patterns***REMOVED***
        except TypeError:
            msg = (
                "The included URLconf '{name***REMOVED***' does not appear to have any "
                "patterns in it. If you see valid patterns in the file then "
                "the issue is probably caused by a circular import."
            ***REMOVED***
            raise ImproperlyConfigured(msg.format(name=self.urlconf_name***REMOVED******REMOVED***
        return patterns

    def resolve_error_handler(self, view_type***REMOVED***:
        callback = getattr(self.urlconf_module, 'handler%s' % view_type, None***REMOVED***
        if not callback:
            # No handler specified in file; use lazy import, since
            # django.conf.urls imports this file.
            from django.conf import urls
            callback = getattr(urls, 'handler%s' % view_type***REMOVED***
        return get_callable(callback***REMOVED***, {***REMOVED***

    def reverse(self, lookup_view, *args, **kwargs***REMOVED***:
        return self._reverse_with_prefix(lookup_view, '', *args, **kwargs***REMOVED***

    def _reverse_with_prefix(self, lookup_view, _prefix, *args, **kwargs***REMOVED***:
        if args and kwargs:
            raise ValueError("Don't mix *args and **kwargs in call to reverse(***REMOVED***!"***REMOVED***
        text_args = [force_text(v***REMOVED*** for v in args***REMOVED***
        text_kwargs = {k: force_text(v***REMOVED*** for (k, v***REMOVED*** in kwargs.items(***REMOVED******REMOVED***

        if not self._populated:
            self._populate(***REMOVED***

        possibilities = self.reverse_dict.getlist(lookup_view***REMOVED***

        for possibility, pattern, defaults in possibilities:
            for result, params in possibility:
                if args:
                    if len(args***REMOVED*** != len(params***REMOVED***:
                        continue
                    candidate_subs = dict(zip(params, text_args***REMOVED******REMOVED***
                else:
                    if (set(kwargs.keys(***REMOVED******REMOVED*** | set(defaults.keys(***REMOVED******REMOVED*** != set(params***REMOVED*** |
                            set(defaults.keys(***REMOVED******REMOVED******REMOVED***:
                        continue
                    matches = True
                    for k, v in defaults.items(***REMOVED***:
                        if kwargs.get(k, v***REMOVED*** != v:
                            matches = False
                            break
                    if not matches:
                        continue
                    candidate_subs = text_kwargs
                # WSGI provides decoded URLs, without %xx escapes, and the URL
                # resolver operates on such URLs. First substitute arguments
                # without quoting to build a decoded URL and look for a match.
                # Then, if we have a match, redo the substitution with quoted
                # arguments in order to return a properly encoded URL.
                candidate_pat = _prefix.replace('%', '%%'***REMOVED*** + result
                if re.search('^%s%s' % (re.escape(_prefix***REMOVED***, pattern***REMOVED***, candidate_pat % candidate_subs, re.UNICODE***REMOVED***:
                    # safe characters from `pchar` definition of RFC 3986
                    url = urlquote(candidate_pat % candidate_subs, safe=RFC3986_SUBDELIMS + str('/~:@'***REMOVED******REMOVED***
                    # Don't allow construction of scheme relative urls.
                    if url.startswith('//'***REMOVED***:
                        url = '/%%2F%s' % url[2:***REMOVED***
                    return url
        # lookup_view can be URL name or callable, but callables are not
        # friendly in error messages.
        m = getattr(lookup_view, '__module__', None***REMOVED***
        n = getattr(lookup_view, '__name__', None***REMOVED***
        if m is not None and n is not None:
            lookup_view_s = "%s.%s" % (m, n***REMOVED***
        else:
            lookup_view_s = lookup_view

        patterns = [pattern for (possibility, pattern, defaults***REMOVED*** in possibilities***REMOVED***
        raise NoReverseMatch(
            "Reverse for '%s' with arguments '%s' and keyword "
            "arguments '%s' not found. %d pattern(s***REMOVED*** tried: %s" %
            (lookup_view_s, args, kwargs, len(patterns***REMOVED***, patterns***REMOVED***
        ***REMOVED***


class LocaleRegexURLResolver(RegexURLResolver***REMOVED***:
    ***REMOVED***
    A URL resolver that always matches the active language code as URL prefix.

    Rather than taking a regex argument, we just override the ``regex``
    function to always return the active language-code as regex.
    ***REMOVED***
    def __init__(
        self, urlconf_name, default_kwargs=None, app_name=None, namespace=None,
        prefix_default_language=True,
    ***REMOVED***:
        super(LocaleRegexURLResolver, self***REMOVED***.__init__(
            None, urlconf_name, default_kwargs, app_name, namespace,
        ***REMOVED***
        self.prefix_default_language = prefix_default_language

    @property
    def regex(self***REMOVED***:
        language_code = get_language(***REMOVED*** or settings.LANGUAGE_CODE
        if language_code not in self._regex_dict:
            if language_code == settings.LANGUAGE_CODE and not self.prefix_default_language:
                regex_string = ''
            else:
                regex_string = '^%s/' % language_code
            self._regex_dict[language_code***REMOVED*** = re.compile(regex_string, re.UNICODE***REMOVED***
        return self._regex_dict[language_code***REMOVED***
