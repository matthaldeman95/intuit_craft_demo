from __future__ import unicode_literals

import copy
import re
import sys
from io import BytesIO
from itertools import chain

from django.conf import settings
from django.core import signing
from django.core.exceptions import (
    DisallowedHost, ImproperlyConfigured, RequestDataTooBig,
***REMOVED***
from django.core.files import uploadhandler
from django.http.multipartparser import MultiPartParser, MultiPartParserError
from django.utils import six
from django.utils.datastructures import ImmutableList, MultiValueDict
from django.utils.encoding import (
    escape_uri_path, force_bytes, force_str, force_text, iri_to_uri,
***REMOVED***
from django.utils.http import is_same_domain, limited_parse_qsl
from django.utils.six.moves.urllib.parse import (
    quote, urlencode, urljoin, urlsplit,
***REMOVED***

RAISE_ERROR = object(***REMOVED***
host_validation_re = re.compile(r"^([a-z0-9.-***REMOVED***+|\[[a-f0-9***REMOVED****:[a-f0-9:***REMOVED***+\***REMOVED******REMOVED***(:\d+***REMOVED***?$"***REMOVED***


class UnreadablePostError(IOError***REMOVED***:
    pass


class RawPostDataException(Exception***REMOVED***:
    ***REMOVED***
    You cannot access raw_post_data from a request that has
    multipart/* POST data if it has been accessed via POST,
    FILES, etc..
    ***REMOVED***
    pass


class HttpRequest(object***REMOVED***:
    ***REMOVED***A basic HTTP request.***REMOVED***

    # The encoding used in GET/POST dicts. None means use default setting.
    _encoding = None
    _upload_handlers = [***REMOVED***

    def __init__(self***REMOVED***:
        # WARNING: The `WSGIRequest` subclass doesn't call `super`.
        # Any variable assignment made here should also happen in
        # `WSGIRequest.__init__(***REMOVED***`.

        self.GET = QueryDict(mutable=True***REMOVED***
        self.POST = QueryDict(mutable=True***REMOVED***
        self.COOKIES = {***REMOVED***
        self.META = {***REMOVED***
        self.FILES = MultiValueDict(***REMOVED***

        self.path = ''
        self.path_info = ''
        self.method = None
        self.resolver_match = None
        self._post_parse_error = False
        self.content_type = None
        self.content_params = None

    def __repr__(self***REMOVED***:
        if self.method is None or not self.get_full_path(***REMOVED***:
            return force_str('<%s>' % self.__class__.__name__***REMOVED***
        return force_str(
            '<%s: %s %r>' % (self.__class__.__name__, self.method, force_str(self.get_full_path(***REMOVED******REMOVED******REMOVED***
        ***REMOVED***

    def _get_raw_host(self***REMOVED***:
        ***REMOVED***
        Return the HTTP host using the environment or request headers. Skip
        allowed hosts protection, so may return an insecure host.
        ***REMOVED***
        # We try three options, in order of decreasing preference.
        if settings.USE_X_FORWARDED_HOST and (
                'HTTP_X_FORWARDED_HOST' in self.META***REMOVED***:
            host = self.META['HTTP_X_FORWARDED_HOST'***REMOVED***
        elif 'HTTP_HOST' in self.META:
            host = self.META['HTTP_HOST'***REMOVED***
        else:
            # Reconstruct the host using the algorithm from PEP 333.
            host = self.META['SERVER_NAME'***REMOVED***
            server_port = self.get_port(***REMOVED***
            if server_port != ('443' if self.is_secure(***REMOVED*** else '80'***REMOVED***:
                host = '%s:%s' % (host, server_port***REMOVED***
        return host

    def get_host(self***REMOVED***:
        ***REMOVED***Return the HTTP host using the environment or request headers.***REMOVED***
        host = self._get_raw_host(***REMOVED***

        # There is no hostname validation when DEBUG=True
        if settings.DEBUG:
            return host

        domain, port = split_domain_port(host***REMOVED***
        if domain and validate_host(domain, settings.ALLOWED_HOSTS***REMOVED***:
            return host
        else:
            msg = "Invalid HTTP_HOST header: %r." % host
            if domain:
                msg += " You may need to add %r to ALLOWED_HOSTS." % domain
            else:
                msg += " The domain name provided is not valid according to RFC 1034/1035."
            raise DisallowedHost(msg***REMOVED***

    def get_port(self***REMOVED***:
        ***REMOVED***Return the port number for the request as a string.***REMOVED***
        if settings.USE_X_FORWARDED_PORT and 'HTTP_X_FORWARDED_PORT' in self.META:
            port = self.META['HTTP_X_FORWARDED_PORT'***REMOVED***
        else:
            port = self.META['SERVER_PORT'***REMOVED***
        return str(port***REMOVED***

    def get_full_path(self, force_append_slash=False***REMOVED***:
        # RFC 3986 requires query string arguments to be in the ASCII range.
        # Rather than crash if this doesn't happen, we encode defensively.
        return '%s%s%s' % (
            escape_uri_path(self.path***REMOVED***,
            '/' if force_append_slash and not self.path.endswith('/'***REMOVED*** else '',
            ('?' + iri_to_uri(self.META.get('QUERY_STRING', ''***REMOVED******REMOVED******REMOVED*** if self.META.get('QUERY_STRING', ''***REMOVED*** else ''
        ***REMOVED***

    def get_signed_cookie(self, key, default=RAISE_ERROR, salt='', max_age=None***REMOVED***:
        ***REMOVED***
        Attempts to return a signed cookie. If the signature fails or the
        cookie has expired, raises an exception... unless you provide the
        default argument in which case that value will be returned instead.
        ***REMOVED***
        ***REMOVED***
            cookie_value = self.COOKIES[key***REMOVED***
        except KeyError:
            if default is not RAISE_ERROR:
                return default
            else:
                raise
        ***REMOVED***
            value = signing.get_cookie_signer(salt=key + salt***REMOVED***.unsign(
                cookie_value, max_age=max_age***REMOVED***
        except signing.BadSignature:
            if default is not RAISE_ERROR:
                return default
            else:
                raise
        return value

    def get_raw_uri(self***REMOVED***:
        ***REMOVED***
        Return an absolute URI from variables available in this request. Skip
        allowed hosts protection, so may return insecure URI.
        ***REMOVED***
        return '{scheme***REMOVED***://{host***REMOVED***{path***REMOVED***'.format(
            scheme=self.scheme,
            host=self._get_raw_host(***REMOVED***,
            path=self.get_full_path(***REMOVED***,
        ***REMOVED***

    def build_absolute_uri(self, location=None***REMOVED***:
        ***REMOVED***
        Builds an absolute URI from the location and the variables available in
        this request. If no ``location`` is specified, the absolute URI is
        built on ``request.get_full_path(***REMOVED***``. Anyway, if the location is
        absolute, it is simply converted to an RFC 3987 compliant URI and
        returned and if location is relative or is scheme-relative (i.e.,
        ``//example.com/``***REMOVED***, it is urljoined to a base URL constructed from the
        request variables.
        ***REMOVED***
        if location is None:
            # Make it an absolute url (but schemeless and domainless***REMOVED*** for the
            # edge case that the path starts with '//'.
            location = '//%s' % self.get_full_path(***REMOVED***
        bits = urlsplit(location***REMOVED***
        if not (bits.scheme and bits.netloc***REMOVED***:
            current_uri = '{scheme***REMOVED***://{host***REMOVED***{path***REMOVED***'.format(scheme=self.scheme,
                                                           host=self.get_host(***REMOVED***,
                                                           path=self.path***REMOVED***
            # Join the constructed URL with the provided location, which will
            # allow the provided ``location`` to apply query strings to the
            # base path as well as override the host, if it begins with //
            location = urljoin(current_uri, location***REMOVED***
        return iri_to_uri(location***REMOVED***

    def _get_scheme(self***REMOVED***:
        ***REMOVED***
        Hook for subclasses like WSGIRequest to implement. Returns 'http' by
        default.
        ***REMOVED***
        return 'http'

    @property
    def scheme(self***REMOVED***:
        if settings.SECURE_PROXY_SSL_HEADER:
            ***REMOVED***
                header, value = settings.SECURE_PROXY_SSL_HEADER
            except ValueError:
                raise ImproperlyConfigured(
                    'The SECURE_PROXY_SSL_HEADER setting must be a tuple containing two values.'
                ***REMOVED***
            if self.META.get(header***REMOVED*** == value:
                return 'https'
        return self._get_scheme(***REMOVED***

    def is_secure(self***REMOVED***:
        return self.scheme == 'https'

    def is_ajax(self***REMOVED***:
        return self.META.get('HTTP_X_REQUESTED_WITH'***REMOVED*** == 'XMLHttpRequest'

    @property
    def encoding(self***REMOVED***:
        return self._encoding

    @encoding.setter
    def encoding(self, val***REMOVED***:
        ***REMOVED***
        Sets the encoding used for GET/POST accesses. If the GET or POST
        dictionary has already been created, it is removed and recreated on the
        next access (so that it is decoded correctly***REMOVED***.
        ***REMOVED***
        self._encoding = val
        if hasattr(self, '_get'***REMOVED***:
            del self._get
        if hasattr(self, '_post'***REMOVED***:
            del self._post

    def _initialize_handlers(self***REMOVED***:
        self._upload_handlers = [uploadhandler.load_handler(handler, self***REMOVED***
                                 for handler in settings.FILE_UPLOAD_HANDLERS***REMOVED***

    @property
    def upload_handlers(self***REMOVED***:
        if not self._upload_handlers:
            # If there are no upload handlers defined, initialize them from settings.
            self._initialize_handlers(***REMOVED***
        return self._upload_handlers

    @upload_handlers.setter
    def upload_handlers(self, upload_handlers***REMOVED***:
        if hasattr(self, '_files'***REMOVED***:
            raise AttributeError("You cannot set the upload handlers after the upload has been processed."***REMOVED***
        self._upload_handlers = upload_handlers

    def parse_file_upload(self, META, post_data***REMOVED***:
        ***REMOVED***Returns a tuple of (POST QueryDict, FILES MultiValueDict***REMOVED***.***REMOVED***
        self.upload_handlers = ImmutableList(
            self.upload_handlers,
            warning="You cannot alter upload handlers after the upload has been processed."
        ***REMOVED***
        parser = MultiPartParser(META, post_data, self.upload_handlers, self.encoding***REMOVED***
        return parser.parse(***REMOVED***

    @property
    def body(self***REMOVED***:
        if not hasattr(self, '_body'***REMOVED***:
            if self._read_started:
                raise RawPostDataException("You cannot access body after reading from request's data stream"***REMOVED***

            # Limit the maximum request data size that will be handled in-memory.
            if (settings.DATA_UPLOAD_MAX_MEMORY_SIZE is not None and
                    int(self.META.get('CONTENT_LENGTH'***REMOVED*** or 0***REMOVED*** > settings.DATA_UPLOAD_MAX_MEMORY_SIZE***REMOVED***:
                raise RequestDataTooBig('Request body exceeded settings.DATA_UPLOAD_MAX_MEMORY_SIZE.'***REMOVED***

            ***REMOVED***
                self._body = self.read(***REMOVED***
            except IOError as e:
                six.reraise(UnreadablePostError, UnreadablePostError(*e.args***REMOVED***, sys.exc_info(***REMOVED***[2***REMOVED******REMOVED***
            self._stream = BytesIO(self._body***REMOVED***
        return self._body

    def _mark_post_parse_error(self***REMOVED***:
        self._post = QueryDict(***REMOVED***
        self._files = MultiValueDict(***REMOVED***
        self._post_parse_error = True

    def _load_post_and_files(self***REMOVED***:
        ***REMOVED***Populate self._post and self._files if the content-type is a form type***REMOVED***
        if self.method != 'POST':
            self._post, self._files = QueryDict(encoding=self._encoding***REMOVED***, MultiValueDict(***REMOVED***
            return
        if self._read_started and not hasattr(self, '_body'***REMOVED***:
            self._mark_post_parse_error(***REMOVED***
            return

        if self.content_type == 'multipart/form-data':
            if hasattr(self, '_body'***REMOVED***:
                # Use already read data
                data = BytesIO(self._body***REMOVED***
            else:
                data = self
            ***REMOVED***
                self._post, self._files = self.parse_file_upload(self.META, data***REMOVED***
            except MultiPartParserError:
                # An error occurred while parsing POST data. Since when
                # formatting the error the request handler might access
                # self.POST, set self._post and self._file to prevent
                # attempts to parse POST data again.
                # Mark that an error occurred. This allows self.__repr__ to
                # be explicit about it instead of simply representing an
                # empty POST
                self._mark_post_parse_error(***REMOVED***
                raise
        elif self.content_type == 'application/x-www-form-urlencoded':
            self._post, self._files = QueryDict(self.body, encoding=self._encoding***REMOVED***, MultiValueDict(***REMOVED***
        else:
            self._post, self._files = QueryDict(encoding=self._encoding***REMOVED***, MultiValueDict(***REMOVED***

    def close(self***REMOVED***:
        if hasattr(self, '_files'***REMOVED***:
            for f in chain.from_iterable(l[1***REMOVED*** for l in self._files.lists(***REMOVED******REMOVED***:
                f.close(***REMOVED***

    # File-like and iterator interface.
    #
    # Expects self._stream to be set to an appropriate source of bytes by
    # a corresponding request subclass (e.g. WSGIRequest***REMOVED***.
    # Also when request data has already been read by request.POST or
    # request.body, self._stream points to a BytesIO instance
    # containing that data.

    def read(self, *args, **kwargs***REMOVED***:
        self._read_started = True
        ***REMOVED***
            return self._stream.read(*args, **kwargs***REMOVED***
        except IOError as e:
            six.reraise(UnreadablePostError, UnreadablePostError(*e.args***REMOVED***, sys.exc_info(***REMOVED***[2***REMOVED******REMOVED***

    def readline(self, *args, **kwargs***REMOVED***:
        self._read_started = True
        ***REMOVED***
            return self._stream.readline(*args, **kwargs***REMOVED***
        except IOError as e:
            six.reraise(UnreadablePostError, UnreadablePostError(*e.args***REMOVED***, sys.exc_info(***REMOVED***[2***REMOVED******REMOVED***

    def xreadlines(self***REMOVED***:
        while True:
            buf = self.readline(***REMOVED***
            if not buf:
                break
            yield buf

    __iter__ = xreadlines

    def readlines(self***REMOVED***:
        return list(iter(self***REMOVED******REMOVED***


class QueryDict(MultiValueDict***REMOVED***:
    ***REMOVED***
    A specialized MultiValueDict which represents a query string.

    A QueryDict can be used to represent GET or POST data. It subclasses
    MultiValueDict since keys in such data can be repeated, for instance
    in the data from a form with a <select multiple> field.

    By default QueryDicts are immutable, though the copy(***REMOVED*** method
    will always return a mutable copy.

    Both keys and values set on this class are converted from the given encoding
    (DEFAULT_CHARSET by default***REMOVED*** to unicode.
    ***REMOVED***

    # These are both reset in __init__, but is specified here at the class
    # level so that unpickling will have valid values
    _mutable = True
    _encoding = None

    def __init__(self, query_string=None, mutable=False, encoding=None***REMOVED***:
        super(QueryDict, self***REMOVED***.__init__(***REMOVED***
        if not encoding:
            encoding = settings.DEFAULT_CHARSET
        self.encoding = encoding
        query_string = query_string or ''
        parse_qsl_kwargs = {
            'keep_blank_values': True,
            'fields_limit': settings.DATA_UPLOAD_MAX_NUMBER_FIELDS,
            'encoding': encoding,
    ***REMOVED***
        if six.PY3:
            if isinstance(query_string, bytes***REMOVED***:
                # query_string normally contains URL-encoded data, a subset of ASCII.
                ***REMOVED***
                    query_string = query_string.decode(encoding***REMOVED***
                except UnicodeDecodeError:
                    # ... but some user agents are misbehaving :-(
                    query_string = query_string.decode('iso-8859-1'***REMOVED***
            for key, value in limited_parse_qsl(query_string, **parse_qsl_kwargs***REMOVED***:
                self.appendlist(key, value***REMOVED***
        else:
            for key, value in limited_parse_qsl(query_string, **parse_qsl_kwargs***REMOVED***:
                ***REMOVED***
                    value = value.decode(encoding***REMOVED***
                except UnicodeDecodeError:
                    value = value.decode('iso-8859-1'***REMOVED***
                self.appendlist(force_text(key, encoding, errors='replace'***REMOVED***,
                                value***REMOVED***
        self._mutable = mutable

    @property
    def encoding(self***REMOVED***:
        if self._encoding is None:
            self._encoding = settings.DEFAULT_CHARSET
        return self._encoding

    @encoding.setter
    def encoding(self, value***REMOVED***:
        self._encoding = value

    def _assert_mutable(self***REMOVED***:
        if not self._mutable:
            raise AttributeError("This QueryDict instance is immutable"***REMOVED***

    def __setitem__(self, key, value***REMOVED***:
        self._assert_mutable(***REMOVED***
        key = bytes_to_text(key, self.encoding***REMOVED***
        value = bytes_to_text(value, self.encoding***REMOVED***
        super(QueryDict, self***REMOVED***.__setitem__(key, value***REMOVED***

    def __delitem__(self, key***REMOVED***:
        self._assert_mutable(***REMOVED***
        super(QueryDict, self***REMOVED***.__delitem__(key***REMOVED***

    def __copy__(self***REMOVED***:
        result = self.__class__('', mutable=True, encoding=self.encoding***REMOVED***
        for key, value in six.iterlists(self***REMOVED***:
            result.setlist(key, value***REMOVED***
        return result

    def __deepcopy__(self, memo***REMOVED***:
        result = self.__class__('', mutable=True, encoding=self.encoding***REMOVED***
        memo[id(self***REMOVED******REMOVED*** = result
        for key, value in six.iterlists(self***REMOVED***:
            result.setlist(copy.deepcopy(key, memo***REMOVED***, copy.deepcopy(value, memo***REMOVED******REMOVED***
        return result

    def setlist(self, key, list_***REMOVED***:
        self._assert_mutable(***REMOVED***
        key = bytes_to_text(key, self.encoding***REMOVED***
        list_ = [bytes_to_text(elt, self.encoding***REMOVED*** for elt in list_***REMOVED***
        super(QueryDict, self***REMOVED***.setlist(key, list_***REMOVED***

    def setlistdefault(self, key, default_list=None***REMOVED***:
        self._assert_mutable(***REMOVED***
        return super(QueryDict, self***REMOVED***.setlistdefault(key, default_list***REMOVED***

    def appendlist(self, key, value***REMOVED***:
        self._assert_mutable(***REMOVED***
        key = bytes_to_text(key, self.encoding***REMOVED***
        value = bytes_to_text(value, self.encoding***REMOVED***
        super(QueryDict, self***REMOVED***.appendlist(key, value***REMOVED***

    def pop(self, key, *args***REMOVED***:
        self._assert_mutable(***REMOVED***
        return super(QueryDict, self***REMOVED***.pop(key, *args***REMOVED***

    def popitem(self***REMOVED***:
        self._assert_mutable(***REMOVED***
        return super(QueryDict, self***REMOVED***.popitem(***REMOVED***

    def clear(self***REMOVED***:
        self._assert_mutable(***REMOVED***
        super(QueryDict, self***REMOVED***.clear(***REMOVED***

    def setdefault(self, key, default=None***REMOVED***:
        self._assert_mutable(***REMOVED***
        key = bytes_to_text(key, self.encoding***REMOVED***
        default = bytes_to_text(default, self.encoding***REMOVED***
        return super(QueryDict, self***REMOVED***.setdefault(key, default***REMOVED***

    def copy(self***REMOVED***:
        ***REMOVED***Returns a mutable copy of this object.***REMOVED***
        return self.__deepcopy__({***REMOVED******REMOVED***

    def urlencode(self, safe=None***REMOVED***:
        ***REMOVED***
        Returns an encoded string of all query string arguments.

        :arg safe: Used to specify characters which do not require quoting, for
            example::

                >>> q = QueryDict(mutable=True***REMOVED***
                >>> q['next'***REMOVED*** = '/a&b/'
                >>> q.urlencode(***REMOVED***
                'next=%2Fa%26b%2F'
                >>> q.urlencode(safe='/'***REMOVED***
                'next=/a%26b/'
        ***REMOVED***
        output = [***REMOVED***
        if safe:
            safe = force_bytes(safe, self.encoding***REMOVED***

            def encode(k, v***REMOVED***:
                return '%s=%s' % ((quote(k, safe***REMOVED***, quote(v, safe***REMOVED******REMOVED******REMOVED***
        else:
            def encode(k, v***REMOVED***:
                return urlencode({k: v***REMOVED******REMOVED***
        for k, list_ in self.lists(***REMOVED***:
            k = force_bytes(k, self.encoding***REMOVED***
            output.extend(encode(k, force_bytes(v, self.encoding***REMOVED******REMOVED***
                          for v in list_***REMOVED***
        return '&'.join(output***REMOVED***


# It's neither necessary nor appropriate to use
# django.utils.encoding.smart_text for parsing URLs and form inputs. Thus,
# this slightly more restricted function, used by QueryDict.
def bytes_to_text(s, encoding***REMOVED***:
    ***REMOVED***
    Converts basestring objects to unicode, using the given encoding. Illegally
    encoded input characters are replaced with Unicode "unknown" codepoint
    (\ufffd***REMOVED***.

    Returns any non-basestring objects without change.
    ***REMOVED***
    if isinstance(s, bytes***REMOVED***:
        return six.text_type(s, encoding, 'replace'***REMOVED***
    else:
        return s


def split_domain_port(host***REMOVED***:
    ***REMOVED***
    Return a (domain, port***REMOVED*** tuple from a given host.

    Returned domain is lower-cased. If the host is invalid, the domain will be
    empty.
    ***REMOVED***
    host = host.lower(***REMOVED***

    if not host_validation_re.match(host***REMOVED***:
        return '', ''

    if host[-1***REMOVED*** == '***REMOVED***':
        # It's an IPv6 address without a port.
        return host, ''
    bits = host.rsplit(':', 1***REMOVED***
    if len(bits***REMOVED*** == 2:
        return tuple(bits***REMOVED***
    return bits[0***REMOVED***, ''


def validate_host(host, allowed_hosts***REMOVED***:
    ***REMOVED***
    Validate the given host for this site.

    Check that the host looks valid and matches a host or host pattern in the
    given list of ``allowed_hosts``. Any pattern beginning with a period
    matches a domain and all its subdomains (e.g. ``.example.com`` matches
    ``example.com`` and any subdomain***REMOVED***, ``*`` matches anything, and anything
    else must match exactly.

    Note: This function assumes that the given host is lower-cased and has
    already had the port, if any, stripped off.

    Return ``True`` for a valid host, ``False`` otherwise.
    ***REMOVED***
    host = host[:-1***REMOVED*** if host.endswith('.'***REMOVED*** else host

    for pattern in allowed_hosts:
        if pattern == '*' or is_same_domain(host, pattern***REMOVED***:
            return True

    return False
