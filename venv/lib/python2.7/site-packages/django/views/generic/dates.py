from __future__ import unicode_literals

import datetime

from django.conf import settings
from django.core.exceptions import ImproperlyConfigured
from django.db import models
from django.http import Http404
from django.utils import timezone
from django.utils.encoding import force_str, force_text
from django.utils.functional import cached_property
from django.utils.translation import ugettext as _
from django.views.generic.base import View
from django.views.generic.detail import (
    BaseDetailView, SingleObjectTemplateResponseMixin,
***REMOVED***
from django.views.generic.list import (
    MultipleObjectMixin, MultipleObjectTemplateResponseMixin,
***REMOVED***


class YearMixin(object***REMOVED***:
    ***REMOVED***
    Mixin for views manipulating year-based data.
    ***REMOVED***
    year_format = '%Y'
    year = None

    def get_year_format(self***REMOVED***:
        ***REMOVED***
        Get a year format string in strptime syntax to be used to parse the
        year from url variables.
        ***REMOVED***
        return self.year_format

    def get_year(self***REMOVED***:
        ***REMOVED***
        Return the year for which this view should display data.
        ***REMOVED***
        year = self.year
        if year is None:
            ***REMOVED***
                year = self.kwargs['year'***REMOVED***
            except KeyError:
                ***REMOVED***
                    year = self.request.GET['year'***REMOVED***
                except KeyError:
                    raise Http404(_("No year specified"***REMOVED******REMOVED***
        return year

    def get_next_year(self, date***REMOVED***:
        ***REMOVED***
        Get the next valid year.
        ***REMOVED***
        return _get_next_prev(self, date, is_previous=False, period='year'***REMOVED***

    def get_previous_year(self, date***REMOVED***:
        ***REMOVED***
        Get the previous valid year.
        ***REMOVED***
        return _get_next_prev(self, date, is_previous=True, period='year'***REMOVED***

    def _get_next_year(self, date***REMOVED***:
        ***REMOVED***
        Return the start date of the next interval.

        The interval is defined by start date <= item date < next start date.
        ***REMOVED***
        return date.replace(year=date.year + 1, month=1, day=1***REMOVED***

    def _get_current_year(self, date***REMOVED***:
        ***REMOVED***
        Return the start date of the current interval.
        ***REMOVED***
        return date.replace(month=1, day=1***REMOVED***


class MonthMixin(object***REMOVED***:
    ***REMOVED***
    Mixin for views manipulating month-based data.
    ***REMOVED***
    month_format = '%b'
    month = None

    def get_month_format(self***REMOVED***:
        ***REMOVED***
        Get a month format string in strptime syntax to be used to parse the
        month from url variables.
        ***REMOVED***
        return self.month_format

    def get_month(self***REMOVED***:
        ***REMOVED***
        Return the month for which this view should display data.
        ***REMOVED***
        month = self.month
        if month is None:
            ***REMOVED***
                month = self.kwargs['month'***REMOVED***
            except KeyError:
                ***REMOVED***
                    month = self.request.GET['month'***REMOVED***
                except KeyError:
                    raise Http404(_("No month specified"***REMOVED******REMOVED***
        return month

    def get_next_month(self, date***REMOVED***:
        ***REMOVED***
        Get the next valid month.
        ***REMOVED***
        return _get_next_prev(self, date, is_previous=False, period='month'***REMOVED***

    def get_previous_month(self, date***REMOVED***:
        ***REMOVED***
        Get the previous valid month.
        ***REMOVED***
        return _get_next_prev(self, date, is_previous=True, period='month'***REMOVED***

    def _get_next_month(self, date***REMOVED***:
        ***REMOVED***
        Return the start date of the next interval.

        The interval is defined by start date <= item date < next start date.
        ***REMOVED***
        if date.month == 12:
            return date.replace(year=date.year + 1, month=1, day=1***REMOVED***
        else:
            return date.replace(month=date.month + 1, day=1***REMOVED***

    def _get_current_month(self, date***REMOVED***:
        ***REMOVED***
        Return the start date of the previous interval.
        ***REMOVED***
        return date.replace(day=1***REMOVED***


class DayMixin(object***REMOVED***:
    ***REMOVED***
    Mixin for views manipulating day-based data.
    ***REMOVED***
    day_format = '%d'
    day = None

    def get_day_format(self***REMOVED***:
        ***REMOVED***
        Get a day format string in strptime syntax to be used to parse the day
        from url variables.
        ***REMOVED***
        return self.day_format

    def get_day(self***REMOVED***:
        ***REMOVED***
        Return the day for which this view should display data.
        ***REMOVED***
        day = self.day
        if day is None:
            ***REMOVED***
                day = self.kwargs['day'***REMOVED***
            except KeyError:
                ***REMOVED***
                    day = self.request.GET['day'***REMOVED***
                except KeyError:
                    raise Http404(_("No day specified"***REMOVED******REMOVED***
        return day

    def get_next_day(self, date***REMOVED***:
        ***REMOVED***
        Get the next valid day.
        ***REMOVED***
        return _get_next_prev(self, date, is_previous=False, period='day'***REMOVED***

    def get_previous_day(self, date***REMOVED***:
        ***REMOVED***
        Get the previous valid day.
        ***REMOVED***
        return _get_next_prev(self, date, is_previous=True, period='day'***REMOVED***

    def _get_next_day(self, date***REMOVED***:
        ***REMOVED***
        Return the start date of the next interval.

        The interval is defined by start date <= item date < next start date.
        ***REMOVED***
        return date + datetime.timedelta(days=1***REMOVED***

    def _get_current_day(self, date***REMOVED***:
        ***REMOVED***
        Return the start date of the current interval.
        ***REMOVED***
        return date


class WeekMixin(object***REMOVED***:
    ***REMOVED***
    Mixin for views manipulating week-based data.
    ***REMOVED***
    week_format = '%U'
    week = None

    def get_week_format(self***REMOVED***:
        ***REMOVED***
        Get a week format string in strptime syntax to be used to parse the
        week from url variables.
        ***REMOVED***
        return self.week_format

    def get_week(self***REMOVED***:
        ***REMOVED***
        Return the week for which this view should display data
        ***REMOVED***
        week = self.week
        if week is None:
            ***REMOVED***
                week = self.kwargs['week'***REMOVED***
            except KeyError:
                ***REMOVED***
                    week = self.request.GET['week'***REMOVED***
                except KeyError:
                    raise Http404(_("No week specified"***REMOVED******REMOVED***
        return week

    def get_next_week(self, date***REMOVED***:
        ***REMOVED***
        Get the next valid week.
        ***REMOVED***
        return _get_next_prev(self, date, is_previous=False, period='week'***REMOVED***

    def get_previous_week(self, date***REMOVED***:
        ***REMOVED***
        Get the previous valid week.
        ***REMOVED***
        return _get_next_prev(self, date, is_previous=True, period='week'***REMOVED***

    def _get_next_week(self, date***REMOVED***:
        ***REMOVED***
        Return the start date of the next interval.

        The interval is defined by start date <= item date < next start date.
        ***REMOVED***
        return date + datetime.timedelta(days=7 - self._get_weekday(date***REMOVED******REMOVED***

    def _get_current_week(self, date***REMOVED***:
        ***REMOVED***
        Return the start date of the current interval.
        ***REMOVED***
        return date - datetime.timedelta(self._get_weekday(date***REMOVED******REMOVED***

    def _get_weekday(self, date***REMOVED***:
        ***REMOVED***
        Return the weekday for a given date.

        The first day according to the week format is 0 and the last day is 6.
        ***REMOVED***
        week_format = self.get_week_format(***REMOVED***
        if week_format == '%W':                 # week starts on Monday
            return date.weekday(***REMOVED***
        elif week_format == '%U':               # week starts on Sunday
            return (date.weekday(***REMOVED*** + 1***REMOVED*** % 7
        else:
            raise ValueError("unknown week format: %s" % week_format***REMOVED***


class DateMixin(object***REMOVED***:
    ***REMOVED***
    Mixin class for views manipulating date-based data.
    ***REMOVED***
    date_field = None
    allow_future = False

    def get_date_field(self***REMOVED***:
        ***REMOVED***
        Get the name of the date field to be used to filter by.
        ***REMOVED***
        if self.date_field is None:
            raise ImproperlyConfigured("%s.date_field is required." % self.__class__.__name__***REMOVED***
        return self.date_field

    def get_allow_future(self***REMOVED***:
        ***REMOVED***
        Returns `True` if the view should be allowed to display objects from
        the future.
        ***REMOVED***
        return self.allow_future

    # Note: the following three methods only work in subclasses that also
    # inherit SingleObjectMixin or MultipleObjectMixin.

    @cached_property
    def uses_datetime_field(self***REMOVED***:
        ***REMOVED***
        Return `True` if the date field is a `DateTimeField` and `False`
        if it's a `DateField`.
        ***REMOVED***
        model = self.get_queryset(***REMOVED***.model if self.model is None else self.model
        field = model._meta.get_field(self.get_date_field(***REMOVED******REMOVED***
        return isinstance(field, models.DateTimeField***REMOVED***

    def _make_date_lookup_arg(self, value***REMOVED***:
        ***REMOVED***
        Convert a date into a datetime when the date field is a DateTimeField.

        When time zone support is enabled, `date` is assumed to be in the
        current time zone, so that displayed items are consistent with the URL.
        ***REMOVED***
        if self.uses_datetime_field:
            value = datetime.datetime.combine(value, datetime.time.min***REMOVED***
            if settings.USE_TZ:
                value = timezone.make_aware(value, timezone.get_current_timezone(***REMOVED******REMOVED***
        return value

    def _make_single_date_lookup(self, date***REMOVED***:
        ***REMOVED***
        Get the lookup kwargs for filtering on a single date.

        If the date field is a DateTimeField, we can't just filter on
        date_field=date because that doesn't take the time into account.
        ***REMOVED***
        date_field = self.get_date_field(***REMOVED***
        if self.uses_datetime_field:
            since = self._make_date_lookup_arg(date***REMOVED***
            until = self._make_date_lookup_arg(date + datetime.timedelta(days=1***REMOVED******REMOVED***
            return {
                '%s__gte' % date_field: since,
                '%s__lt' % date_field: until,
        ***REMOVED***
        else:
            # Skip self._make_date_lookup_arg, it's a no-op in this branch.
            return {date_field: date***REMOVED***


class BaseDateListView(MultipleObjectMixin, DateMixin, View***REMOVED***:
    ***REMOVED***
    Abstract base class for date-based views displaying a list of objects.
    ***REMOVED***
    allow_empty = False
    date_list_period = 'year'

    def get(self, request, *args, **kwargs***REMOVED***:
        self.date_list, self.object_list, extra_context = self.get_dated_items(***REMOVED***
        context = self.get_context_data(object_list=self.object_list,
                                        date_list=self.date_list***REMOVED***
        context.update(extra_context***REMOVED***
        return self.render_to_response(context***REMOVED***

    def get_dated_items(self***REMOVED***:
        ***REMOVED***
        Obtain the list of dates and items.
        ***REMOVED***
        raise NotImplementedError('A DateView must provide an implementation of get_dated_items(***REMOVED***'***REMOVED***

    def get_ordering(self***REMOVED***:
        ***REMOVED***
        Returns the field or fields to use for ordering the queryset; uses the
        date field by default.
        ***REMOVED***
        return '-%s' % self.get_date_field(***REMOVED*** if self.ordering is None else self.ordering

    def get_dated_queryset(self, **lookup***REMOVED***:
        ***REMOVED***
        Get a queryset properly filtered according to `allow_future` and any
        extra lookup kwargs.
        ***REMOVED***
        qs = self.get_queryset(***REMOVED***.filter(**lookup***REMOVED***
        date_field = self.get_date_field(***REMOVED***
        allow_future = self.get_allow_future(***REMOVED***
        allow_empty = self.get_allow_empty(***REMOVED***
        paginate_by = self.get_paginate_by(qs***REMOVED***

        if not allow_future:
            now = timezone.now(***REMOVED*** if self.uses_datetime_field else timezone_today(***REMOVED***
            qs = qs.filter(**{'%s__lte' % date_field: now***REMOVED******REMOVED***

        if not allow_empty:
            # When pagination is enabled, it's better to do a cheap query
            # than to load the unpaginated queryset in memory.
            is_empty = len(qs***REMOVED*** == 0 if paginate_by is None else not qs.exists(***REMOVED***
            if is_empty:
                raise Http404(_("No %(verbose_name_plural***REMOVED***s available"***REMOVED*** % {
                    'verbose_name_plural': force_text(qs.model._meta.verbose_name_plural***REMOVED***
            ***REMOVED******REMOVED***

        return qs

    def get_date_list_period(self***REMOVED***:
        ***REMOVED***
        Get the aggregation period for the list of dates: 'year', 'month', or 'day'.
        ***REMOVED***
        return self.date_list_period

    def get_date_list(self, queryset, date_type=None, ordering='ASC'***REMOVED***:
        ***REMOVED***
        Get a date list by calling `queryset.dates/datetimes(***REMOVED***`, checking
        along the way for empty lists that aren't allowed.
        ***REMOVED***
        date_field = self.get_date_field(***REMOVED***
        allow_empty = self.get_allow_empty(***REMOVED***
        if date_type is None:
            date_type = self.get_date_list_period(***REMOVED***

        if self.uses_datetime_field:
            date_list = queryset.datetimes(date_field, date_type, ordering***REMOVED***
        else:
            date_list = queryset.dates(date_field, date_type, ordering***REMOVED***
        if date_list is not None and not date_list and not allow_empty:
            name = force_text(queryset.model._meta.verbose_name_plural***REMOVED***
            raise Http404(_("No %(verbose_name_plural***REMOVED***s available"***REMOVED*** %
                      ***REMOVED***'verbose_name_plural': name***REMOVED******REMOVED***

        return date_list


class BaseArchiveIndexView(BaseDateListView***REMOVED***:
    ***REMOVED***
    Base class for archives of date-based items.

    Requires a response mixin.
    ***REMOVED***
    context_object_name = 'latest'

    def get_dated_items(self***REMOVED***:
        ***REMOVED***
        Return (date_list, items, extra_context***REMOVED*** for this request.
        ***REMOVED***
        qs = self.get_dated_queryset(***REMOVED***
        date_list = self.get_date_list(qs, ordering='DESC'***REMOVED***

        if not date_list:
            qs = qs.none(***REMOVED***

        return (date_list, qs, {***REMOVED******REMOVED***


class ArchiveIndexView(MultipleObjectTemplateResponseMixin, BaseArchiveIndexView***REMOVED***:
    ***REMOVED***
    Top-level archive of date-based items.
    ***REMOVED***
    template_name_suffix = '_archive'


class BaseYearArchiveView(YearMixin, BaseDateListView***REMOVED***:
    ***REMOVED***
    List of objects published in a given year.
    ***REMOVED***
    date_list_period = 'month'
    make_object_list = False

    def get_dated_items(self***REMOVED***:
        ***REMOVED***
        Return (date_list, items, extra_context***REMOVED*** for this request.
        ***REMOVED***
        year = self.get_year(***REMOVED***

        date_field = self.get_date_field(***REMOVED***
        date = _date_from_string(year, self.get_year_format(***REMOVED******REMOVED***

        since = self._make_date_lookup_arg(date***REMOVED***
        until = self._make_date_lookup_arg(self._get_next_year(date***REMOVED******REMOVED***
        lookup_kwargs = {
            '%s__gte' % date_field: since,
            '%s__lt' % date_field: until,
    ***REMOVED***

        qs = self.get_dated_queryset(**lookup_kwargs***REMOVED***
        date_list = self.get_date_list(qs***REMOVED***

        if not self.get_make_object_list(***REMOVED***:
            # We need this to be a queryset since parent classes introspect it
            # to find information about the model.
            qs = qs.none(***REMOVED***

        return (date_list, qs, {
            'year': date,
            'next_year': self.get_next_year(date***REMOVED***,
            'previous_year': self.get_previous_year(date***REMOVED***,
    ***REMOVED******REMOVED***

    def get_make_object_list(self***REMOVED***:
        ***REMOVED***
        Return `True` if this view should contain the full list of objects in
        the given year.
        ***REMOVED***
        return self.make_object_list


class YearArchiveView(MultipleObjectTemplateResponseMixin, BaseYearArchiveView***REMOVED***:
    ***REMOVED***
    List of objects published in a given year.
    ***REMOVED***
    template_name_suffix = '_archive_year'


class BaseMonthArchiveView(YearMixin, MonthMixin, BaseDateListView***REMOVED***:
    ***REMOVED***
    List of objects published in a given month.
    ***REMOVED***
    date_list_period = 'day'

    def get_dated_items(self***REMOVED***:
        ***REMOVED***
        Return (date_list, items, extra_context***REMOVED*** for this request.
        ***REMOVED***
        year = self.get_year(***REMOVED***
        month = self.get_month(***REMOVED***

        date_field = self.get_date_field(***REMOVED***
        date = _date_from_string(year, self.get_year_format(***REMOVED***,
                                 month, self.get_month_format(***REMOVED******REMOVED***

        since = self._make_date_lookup_arg(date***REMOVED***
        until = self._make_date_lookup_arg(self._get_next_month(date***REMOVED******REMOVED***
        lookup_kwargs = {
            '%s__gte' % date_field: since,
            '%s__lt' % date_field: until,
    ***REMOVED***

        qs = self.get_dated_queryset(**lookup_kwargs***REMOVED***
        date_list = self.get_date_list(qs***REMOVED***

        return (date_list, qs, {
            'month': date,
            'next_month': self.get_next_month(date***REMOVED***,
            'previous_month': self.get_previous_month(date***REMOVED***,
    ***REMOVED******REMOVED***


class MonthArchiveView(MultipleObjectTemplateResponseMixin, BaseMonthArchiveView***REMOVED***:
    ***REMOVED***
    List of objects published in a given month.
    ***REMOVED***
    template_name_suffix = '_archive_month'


class BaseWeekArchiveView(YearMixin, WeekMixin, BaseDateListView***REMOVED***:
    ***REMOVED***
    List of objects published in a given week.
    ***REMOVED***

    def get_dated_items(self***REMOVED***:
        ***REMOVED***
        Return (date_list, items, extra_context***REMOVED*** for this request.
        ***REMOVED***
        year = self.get_year(***REMOVED***
        week = self.get_week(***REMOVED***

        date_field = self.get_date_field(***REMOVED***
        week_format = self.get_week_format(***REMOVED***
        week_start = {
            '%W': '1',
            '%U': '0',
    ***REMOVED***[week_format***REMOVED***
        date = _date_from_string(year, self.get_year_format(***REMOVED***,
                                 week_start, '%w',
                                 week, week_format***REMOVED***

        since = self._make_date_lookup_arg(date***REMOVED***
        until = self._make_date_lookup_arg(self._get_next_week(date***REMOVED******REMOVED***
        lookup_kwargs = {
            '%s__gte' % date_field: since,
            '%s__lt' % date_field: until,
    ***REMOVED***

        qs = self.get_dated_queryset(**lookup_kwargs***REMOVED***

        return (None, qs, {
            'week': date,
            'next_week': self.get_next_week(date***REMOVED***,
            'previous_week': self.get_previous_week(date***REMOVED***,
    ***REMOVED******REMOVED***


class WeekArchiveView(MultipleObjectTemplateResponseMixin, BaseWeekArchiveView***REMOVED***:
    ***REMOVED***
    List of objects published in a given week.
    ***REMOVED***
    template_name_suffix = '_archive_week'


class BaseDayArchiveView(YearMixin, MonthMixin, DayMixin, BaseDateListView***REMOVED***:
    ***REMOVED***
    List of objects published on a given day.
    ***REMOVED***
    def get_dated_items(self***REMOVED***:
        ***REMOVED***
        Return (date_list, items, extra_context***REMOVED*** for this request.
        ***REMOVED***
        year = self.get_year(***REMOVED***
        month = self.get_month(***REMOVED***
        day = self.get_day(***REMOVED***

        date = _date_from_string(year, self.get_year_format(***REMOVED***,
                                 month, self.get_month_format(***REMOVED***,
                                 day, self.get_day_format(***REMOVED******REMOVED***

        return self._get_dated_items(date***REMOVED***

    def _get_dated_items(self, date***REMOVED***:
        ***REMOVED***
        Do the actual heavy lifting of getting the dated items; this accepts a
        date object so that TodayArchiveView can be trivial.
        ***REMOVED***
        lookup_kwargs = self._make_single_date_lookup(date***REMOVED***
        qs = self.get_dated_queryset(**lookup_kwargs***REMOVED***

        return (None, qs, {
            'day': date,
            'previous_day': self.get_previous_day(date***REMOVED***,
            'next_day': self.get_next_day(date***REMOVED***,
            'previous_month': self.get_previous_month(date***REMOVED***,
            'next_month': self.get_next_month(date***REMOVED***
    ***REMOVED******REMOVED***


class DayArchiveView(MultipleObjectTemplateResponseMixin, BaseDayArchiveView***REMOVED***:
    ***REMOVED***
    List of objects published on a given day.
    ***REMOVED***
    template_name_suffix = "_archive_day"


class BaseTodayArchiveView(BaseDayArchiveView***REMOVED***:
    ***REMOVED***
    List of objects published today.
    ***REMOVED***

    def get_dated_items(self***REMOVED***:
        ***REMOVED***
        Return (date_list, items, extra_context***REMOVED*** for this request.
        ***REMOVED***
        return self._get_dated_items(datetime.date.today(***REMOVED******REMOVED***


class TodayArchiveView(MultipleObjectTemplateResponseMixin, BaseTodayArchiveView***REMOVED***:
    ***REMOVED***
    List of objects published today.
    ***REMOVED***
    template_name_suffix = "_archive_day"


class BaseDateDetailView(YearMixin, MonthMixin, DayMixin, DateMixin, BaseDetailView***REMOVED***:
    ***REMOVED***
    Detail view of a single object on a single date; this differs from the
    standard DetailView by accepting a year/month/day in the URL.
    ***REMOVED***
    def get_object(self, queryset=None***REMOVED***:
        ***REMOVED***
        Get the object this request displays.
        ***REMOVED***
        year = self.get_year(***REMOVED***
        month = self.get_month(***REMOVED***
        day = self.get_day(***REMOVED***
        date = _date_from_string(year, self.get_year_format(***REMOVED***,
                                 month, self.get_month_format(***REMOVED***,
                                 day, self.get_day_format(***REMOVED******REMOVED***

        # Use a custom queryset if provided
        qs = self.get_queryset(***REMOVED*** if queryset is None else queryset

        if not self.get_allow_future(***REMOVED*** and date > datetime.date.today(***REMOVED***:
            raise Http404(_(
                "Future %(verbose_name_plural***REMOVED***s not available because "
                "%(class_name***REMOVED***s.allow_future is False."
            ***REMOVED*** % {
                'verbose_name_plural': qs.model._meta.verbose_name_plural,
                'class_name': self.__class__.__name__,
        ***REMOVED******REMOVED***

        # Filter down a queryset from self.queryset using the date from the
        # URL. This'll get passed as the queryset to DetailView.get_object,
        # which'll handle the 404
        lookup_kwargs = self._make_single_date_lookup(date***REMOVED***
        qs = qs.filter(**lookup_kwargs***REMOVED***

        return super(BaseDetailView, self***REMOVED***.get_object(queryset=qs***REMOVED***


class DateDetailView(SingleObjectTemplateResponseMixin, BaseDateDetailView***REMOVED***:
    ***REMOVED***
    Detail view of a single object on a single date; this differs from the
    standard DetailView by accepting a year/month/day in the URL.
    ***REMOVED***
    template_name_suffix = '_detail'


def _date_from_string(year, year_format, month='', month_format='', day='', day_format='', delim='__'***REMOVED***:
    ***REMOVED***
    Helper: get a datetime.date object given a format string and a year,
    month, and day (only year is mandatory***REMOVED***. Raise a 404 for an invalid date.
    ***REMOVED***
    format = delim.join((year_format, month_format, day_format***REMOVED******REMOVED***
    datestr = delim.join((year, month, day***REMOVED******REMOVED***
    ***REMOVED***
        return datetime.datetime.strptime(force_str(datestr***REMOVED***, format***REMOVED***.date(***REMOVED***
    except ValueError:
        raise Http404(_("Invalid date string '%(datestr***REMOVED***s' given format '%(format***REMOVED***s'"***REMOVED*** % {
            'datestr': datestr,
            'format': format,
    ***REMOVED******REMOVED***


def _get_next_prev(generic_view, date, is_previous, period***REMOVED***:
    ***REMOVED***
    Helper: Get the next or the previous valid date. The idea is to allow
    links on month/day views to never be 404s by never providing a date
    that'll be invalid for the given view.

    This is a bit complicated since it handles different intervals of time,
    hence the coupling to generic_view.

    However in essence the logic comes down to:

        * If allow_empty and allow_future are both true, this is easy: just
          return the naive result (just the next/previous day/week/month,
          regardless of object existence.***REMOVED***

        * If allow_empty is true, allow_future is false, and the naive result
          isn't in the future, then return it; otherwise return None.

        * If allow_empty is false and allow_future is true, return the next
          date *that contains a valid object*, even if it's in the future. If
          there are no next objects, return None.

        * If allow_empty is false and allow_future is false, return the next
          date that contains a valid object. If that date is in the future, or
          if there are no next objects, return None.
    ***REMOVED***
    date_field = generic_view.get_date_field(***REMOVED***
    allow_empty = generic_view.get_allow_empty(***REMOVED***
    allow_future = generic_view.get_allow_future(***REMOVED***

    get_current = getattr(generic_view, '_get_current_%s' % period***REMOVED***
    get_next = getattr(generic_view, '_get_next_%s' % period***REMOVED***

    # Bounds of the current interval
    start, end = get_current(date***REMOVED***, get_next(date***REMOVED***

    # If allow_empty is True, the naive result will be valid
    if allow_empty:
        if is_previous:
            result = get_current(start - datetime.timedelta(days=1***REMOVED******REMOVED***
        else:
            result = end

        if allow_future or result <= timezone_today(***REMOVED***:
            return result
        else:
            return None

    # Otherwise, we'll need to go to the database to look for an object
    # whose date_field is at least (greater than/less than***REMOVED*** the given
    # naive result
    else:
        # Construct a lookup and an ordering depending on whether we're doing
        # a previous date or a next date lookup.
        if is_previous:
            lookup = {'%s__lt' % date_field: generic_view._make_date_lookup_arg(start***REMOVED******REMOVED***
            ordering = '-%s' % date_field
        else:
            lookup = {'%s__gte' % date_field: generic_view._make_date_lookup_arg(end***REMOVED******REMOVED***
            ordering = date_field

        # Filter out objects in the future if appropriate.
        if not allow_future:
            # Fortunately, to match the implementation of allow_future,
            # we need __lte, which doesn't conflict with __lt above.
            if generic_view.uses_datetime_field:
                now = timezone.now(***REMOVED***
            else:
                now = timezone_today(***REMOVED***
            lookup['%s__lte' % date_field***REMOVED*** = now

        qs = generic_view.get_queryset(***REMOVED***.filter(**lookup***REMOVED***.order_by(ordering***REMOVED***

        # Snag the first object from the queryset; if it doesn't exist that
        # means there's no next/previous link available.
        ***REMOVED***
            result = getattr(qs[0***REMOVED***, date_field***REMOVED***
        except IndexError:
            return None

        # Convert datetimes to dates in the current time zone.
        if generic_view.uses_datetime_field:
            if settings.USE_TZ:
                result = timezone.localtime(result***REMOVED***
            result = result.date(***REMOVED***

        # Return the first day of the period.
        return get_current(result***REMOVED***


def timezone_today(***REMOVED***:
    ***REMOVED***
    Return the current date in the current time zone.
    ***REMOVED***
    if settings.USE_TZ:
        return timezone.localtime(timezone.now(***REMOVED******REMOVED***.date(***REMOVED***
    else:
        return datetime.date.today(***REMOVED***
