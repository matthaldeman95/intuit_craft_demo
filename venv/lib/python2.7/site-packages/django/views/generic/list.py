from __future__ import unicode_literals

from django.core.exceptions import ImproperlyConfigured
from django.core.paginator import InvalidPage, Paginator
from django.db.models.query import QuerySet
from django.http import Http404
from django.utils import six
from django.utils.translation import ugettext as _
from django.views.generic.base import ContextMixin, TemplateResponseMixin, View


class MultipleObjectMixin(ContextMixin***REMOVED***:
    ***REMOVED***
    A mixin for views manipulating multiple objects.
    ***REMOVED***
    allow_empty = True
    queryset = None
    model = None
    paginate_by = None
    paginate_orphans = 0
    context_object_name = None
    paginator_class = Paginator
    page_kwarg = 'page'
    ordering = None

    def get_queryset(self***REMOVED***:
        ***REMOVED***
        Return the list of items for this view.

        The return value must be an iterable and may be an instance of
        `QuerySet` in which case `QuerySet` specific behavior will be enabled.
        ***REMOVED***
        if self.queryset is not None:
            queryset = self.queryset
            if isinstance(queryset, QuerySet***REMOVED***:
                queryset = queryset.all(***REMOVED***
        elif self.model is not None:
            queryset = self.model._default_manager.all(***REMOVED***
        else:
            raise ImproperlyConfigured(
                "%(cls***REMOVED***s is missing a QuerySet. Define "
                "%(cls***REMOVED***s.model, %(cls***REMOVED***s.queryset, or override "
                "%(cls***REMOVED***s.get_queryset(***REMOVED***." % {
                    'cls': self.__class__.__name__
            ***REMOVED***
            ***REMOVED***
        ordering = self.get_ordering(***REMOVED***
        if ordering:
            if isinstance(ordering, six.string_types***REMOVED***:
                ordering = (ordering,***REMOVED***
            queryset = queryset.order_by(*ordering***REMOVED***

        return queryset

    def get_ordering(self***REMOVED***:
        ***REMOVED***
        Return the field or fields to use for ordering the queryset.
        ***REMOVED***
        return self.ordering

    def paginate_queryset(self, queryset, page_size***REMOVED***:
        ***REMOVED***
        Paginate the queryset, if needed.
        ***REMOVED***
        paginator = self.get_paginator(
            queryset, page_size, orphans=self.get_paginate_orphans(***REMOVED***,
            allow_empty_first_page=self.get_allow_empty(***REMOVED******REMOVED***
        page_kwarg = self.page_kwarg
        page = self.kwargs.get(page_kwarg***REMOVED*** or self.request.GET.get(page_kwarg***REMOVED*** or 1
        ***REMOVED***
            page_number = int(page***REMOVED***
        except ValueError:
            if page == 'last':
                page_number = paginator.num_pages
            else:
                raise Http404(_("Page is not 'last', nor can it be converted to an int."***REMOVED******REMOVED***
        ***REMOVED***
            page = paginator.page(page_number***REMOVED***
            return (paginator, page, page.object_list, page.has_other_pages(***REMOVED******REMOVED***
        except InvalidPage as e:
            raise Http404(_('Invalid page (%(page_number***REMOVED***s***REMOVED***: %(message***REMOVED***s'***REMOVED*** % {
                'page_number': page_number,
                'message': str(e***REMOVED***
        ***REMOVED******REMOVED***

    def get_paginate_by(self, queryset***REMOVED***:
        ***REMOVED***
        Get the number of items to paginate by, or ``None`` for no pagination.
        ***REMOVED***
        return self.paginate_by

    def get_paginator(self, queryset, per_page, orphans=0,
                      allow_empty_first_page=True, **kwargs***REMOVED***:
        ***REMOVED***
        Return an instance of the paginator for this view.
        ***REMOVED***
        return self.paginator_class(
            queryset, per_page, orphans=orphans,
            allow_empty_first_page=allow_empty_first_page, **kwargs***REMOVED***

    def get_paginate_orphans(self***REMOVED***:
        ***REMOVED***
        Returns the maximum number of orphans extend the last page by when
        paginating.
        ***REMOVED***
        return self.paginate_orphans

    def get_allow_empty(self***REMOVED***:
        ***REMOVED***
        Returns ``True`` if the view should display empty lists, and ``False``
        if a 404 should be raised instead.
        ***REMOVED***
        return self.allow_empty

    def get_context_object_name(self, object_list***REMOVED***:
        ***REMOVED***
        Get the name of the item to be used in the context.
        ***REMOVED***
        if self.context_object_name:
            return self.context_object_name
        elif hasattr(object_list, 'model'***REMOVED***:
            return '%s_list' % object_list.model._meta.model_name
        else:
            return None

    def get_context_data(self, **kwargs***REMOVED***:
        ***REMOVED***
        Get the context for this view.
        ***REMOVED***
        queryset = kwargs.pop('object_list', self.object_list***REMOVED***
        page_size = self.get_paginate_by(queryset***REMOVED***
        context_object_name = self.get_context_object_name(queryset***REMOVED***
        if page_size:
            paginator, page, queryset, is_paginated = self.paginate_queryset(queryset, page_size***REMOVED***
            context = {
                'paginator': paginator,
                'page_obj': page,
                'is_paginated': is_paginated,
                'object_list': queryset
        ***REMOVED***
        else:
            context = {
                'paginator': None,
                'page_obj': None,
                'is_paginated': False,
                'object_list': queryset
        ***REMOVED***
        if context_object_name is not None:
            context[context_object_name***REMOVED*** = queryset
        context.update(kwargs***REMOVED***
        return super(MultipleObjectMixin, self***REMOVED***.get_context_data(**context***REMOVED***


class BaseListView(MultipleObjectMixin, View***REMOVED***:
    ***REMOVED***
    A base view for displaying a list of objects.
    ***REMOVED***
    def get(self, request, *args, **kwargs***REMOVED***:
        self.object_list = self.get_queryset(***REMOVED***
        allow_empty = self.get_allow_empty(***REMOVED***

        if not allow_empty:
            # When pagination is enabled and object_list is a queryset,
            # it's better to do a cheap query than to load the unpaginated
            # queryset in memory.
            if self.get_paginate_by(self.object_list***REMOVED*** is not None and hasattr(self.object_list, 'exists'***REMOVED***:
                is_empty = not self.object_list.exists(***REMOVED***
            else:
                is_empty = len(self.object_list***REMOVED*** == 0
            if is_empty:
                raise Http404(_("Empty list and '%(class_name***REMOVED***s.allow_empty' is False."***REMOVED*** % {
                    'class_name': self.__class__.__name__,
            ***REMOVED******REMOVED***
        context = self.get_context_data(***REMOVED***
        return self.render_to_response(context***REMOVED***


class MultipleObjectTemplateResponseMixin(TemplateResponseMixin***REMOVED***:
    ***REMOVED***
    Mixin for responding with a template and list of objects.
    ***REMOVED***
    template_name_suffix = '_list'

    def get_template_names(self***REMOVED***:
        ***REMOVED***
        Return a list of template names to be used for the request. Must return
        a list. May not be called if render_to_response is overridden.
        ***REMOVED***
        ***REMOVED***
            names = super(MultipleObjectTemplateResponseMixin, self***REMOVED***.get_template_names(***REMOVED***
        except ImproperlyConfigured:
            # If template_name isn't specified, it's not a problem --
            # we just start with an empty list.
            names = [***REMOVED***

        # If the list is a queryset, we'll invent a template name based on the
        # app and model name. This name gets put at the end of the template
        # name list so that user-supplied names override the automatically-
        # generated ones.
        if hasattr(self.object_list, 'model'***REMOVED***:
            opts = self.object_list.model._meta
            names.append("%s/%s%s.html" % (opts.app_label, opts.model_name, self.template_name_suffix***REMOVED******REMOVED***

        return names


class ListView(MultipleObjectTemplateResponseMixin, BaseListView***REMOVED***:
    ***REMOVED***
    Render some list of objects, set by `self.model` or `self.queryset`.
    `self.queryset` can actually be any iterable of items, not just a queryset.
    ***REMOVED***
