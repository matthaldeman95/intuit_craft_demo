from django import template
from django.apps import apps
from django.utils.encoding import iri_to_uri
from django.utils.six.moves.urllib.parse import urljoin

register = template.Library(***REMOVED***


class PrefixNode(template.Node***REMOVED***:

    def __repr__(self***REMOVED***:
        return "<PrefixNode for %r>" % self.name

    def __init__(self, varname=None, name=None***REMOVED***:
        if name is None:
            raise template.TemplateSyntaxError(
                "Prefix nodes must be given a name to return."***REMOVED***
        self.varname = varname
        self.name = name

    @classmethod
    def handle_token(cls, parser, token, name***REMOVED***:
        ***REMOVED***
        Class method to parse prefix node and return a Node.
        ***REMOVED***
        # token.split_contents(***REMOVED*** isn't useful here because tags using this method don't accept variable as arguments
        tokens = token.contents.split(***REMOVED***
        if len(tokens***REMOVED*** > 1 and tokens[1***REMOVED*** != 'as':
            raise template.TemplateSyntaxError(
                "First argument in '%s' must be 'as'" % tokens[0***REMOVED******REMOVED***
        if len(tokens***REMOVED*** > 1:
            varname = tokens[2***REMOVED***
        else:
            varname = None
        return cls(varname, name***REMOVED***

    @classmethod
    def handle_simple(cls, name***REMOVED***:
        ***REMOVED***
            from django.conf import settings
        except ImportError:
            prefix = ''
        else:
            prefix = iri_to_uri(getattr(settings, name, ''***REMOVED******REMOVED***
        return prefix

    def render(self, context***REMOVED***:
        prefix = self.handle_simple(self.name***REMOVED***
        if self.varname is None:
            return prefix
        context[self.varname***REMOVED*** = prefix
        return ''


@register.tag
def get_static_prefix(parser, token***REMOVED***:
    ***REMOVED***
    Populates a template variable with the static prefix,
    ``settings.STATIC_URL``.

    Usage::

    ***REMOVED***% get_static_prefix [as varname***REMOVED*** %***REMOVED***

    Examples::

    ***REMOVED***% get_static_prefix %***REMOVED***
    ***REMOVED***% get_static_prefix as static_prefix %***REMOVED***
    ***REMOVED***
    return PrefixNode.handle_token(parser, token, "STATIC_URL"***REMOVED***


@register.tag
def get_media_prefix(parser, token***REMOVED***:
    ***REMOVED***
    Populates a template variable with the media prefix,
    ``settings.MEDIA_URL``.

    Usage::

    ***REMOVED***% get_media_prefix [as varname***REMOVED*** %***REMOVED***

    Examples::

    ***REMOVED***% get_media_prefix %***REMOVED***
    ***REMOVED***% get_media_prefix as media_prefix %***REMOVED***
    ***REMOVED***
    return PrefixNode.handle_token(parser, token, "MEDIA_URL"***REMOVED***


class StaticNode(template.Node***REMOVED***:
    def __init__(self, varname=None, path=None***REMOVED***:
        if path is None:
            raise template.TemplateSyntaxError(
                "Static template nodes must be given a path to return."***REMOVED***
        self.path = path
        self.varname = varname

    def url(self, context***REMOVED***:
        path = self.path.resolve(context***REMOVED***
        return self.handle_simple(path***REMOVED***

    def render(self, context***REMOVED***:
        url = self.url(context***REMOVED***
        if self.varname is None:
            return url
        context[self.varname***REMOVED*** = url
        return ''

    @classmethod
    def handle_simple(cls, path***REMOVED***:
        if apps.is_installed('django.contrib.staticfiles'***REMOVED***:
            from django.contrib.staticfiles.storage import staticfiles_storage
            return staticfiles_storage.url(path***REMOVED***
        else:
            return urljoin(PrefixNode.handle_simple("STATIC_URL"***REMOVED***, path***REMOVED***

    @classmethod
    def handle_token(cls, parser, token***REMOVED***:
        ***REMOVED***
        Class method to parse prefix node and return a Node.
        ***REMOVED***
        bits = token.split_contents(***REMOVED***

        if len(bits***REMOVED*** < 2:
            raise template.TemplateSyntaxError(
                "'%s' takes at least one argument (path to file***REMOVED***" % bits[0***REMOVED******REMOVED***

        path = parser.compile_filter(bits[1***REMOVED******REMOVED***

        if len(bits***REMOVED*** >= 2 and bits[-2***REMOVED*** == 'as':
            varname = bits[3***REMOVED***
        else:
            varname = None

        return cls(varname, path***REMOVED***


@register.tag('static'***REMOVED***
def do_static(parser, token***REMOVED***:
    ***REMOVED***
    Joins the given path with the STATIC_URL setting.

    Usage::

    ***REMOVED***% static path [as varname***REMOVED*** %***REMOVED***

    Examples::

    ***REMOVED***% static "myapp/css/base.css" %***REMOVED***
    ***REMOVED***% static variable_with_path %***REMOVED***
    ***REMOVED***% static "myapp/css/base.css" as admin_base_css %***REMOVED***
    ***REMOVED***% static variable_with_path as varname %***REMOVED***
    ***REMOVED***
    return StaticNode.handle_token(parser, token***REMOVED***


def static(path***REMOVED***:
    ***REMOVED***
    Given a relative path to a static asset, return the absolute path to the
    asset.
    ***REMOVED***
    return StaticNode.handle_simple(path***REMOVED***
