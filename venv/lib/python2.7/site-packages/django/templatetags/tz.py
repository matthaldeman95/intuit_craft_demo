from datetime import datetime, tzinfo

from django.template import Library, Node, TemplateSyntaxError
from django.utils import six, timezone

***REMOVED***
    import pytz
except ImportError:
    pytz = None


register = Library(***REMOVED***


# HACK: datetime is an old-style class, create a new-style equivalent
# so we can define additional attributes.
class datetimeobject(datetime, object***REMOVED***:
    pass


# Template filters

@register.filter
def localtime(value***REMOVED***:
    ***REMOVED***
    Converts a datetime to local time in the active time zone.

    This only makes sense within a {% localtime off %***REMOVED*** block.
    ***REMOVED***
    return do_timezone(value, timezone.get_current_timezone(***REMOVED******REMOVED***


@register.filter
def utc(value***REMOVED***:
    ***REMOVED***
    Converts a datetime to UTC.
    ***REMOVED***
    return do_timezone(value, timezone.utc***REMOVED***


@register.filter('timezone'***REMOVED***
def do_timezone(value, arg***REMOVED***:
    ***REMOVED***
    Converts a datetime to local time in a given time zone.

    The argument must be an instance of a tzinfo subclass or a time zone name.
    If it is a time zone name, pytz is required.

    Naive datetimes are assumed to be in local time in the default time zone.
    ***REMOVED***
    if not isinstance(value, datetime***REMOVED***:
        return ''

    # Obtain a timezone-aware datetime
    ***REMOVED***
        if timezone.is_naive(value***REMOVED***:
            default_timezone = timezone.get_default_timezone(***REMOVED***
            value = timezone.make_aware(value, default_timezone***REMOVED***
    # Filters must never raise exceptions, and pytz' exceptions inherit
    # Exception directly, not a specific subclass. So catch everything.
    except Exception:
        return ''

    # Obtain a tzinfo instance
    if isinstance(arg, tzinfo***REMOVED***:
        tz = arg
    elif isinstance(arg, six.string_types***REMOVED*** and pytz is not None:
        ***REMOVED***
            tz = pytz.timezone(arg***REMOVED***
        except pytz.UnknownTimeZoneError:
            return ''
    else:
        return ''

    result = timezone.localtime(value, tz***REMOVED***

    # HACK: the convert_to_local_time flag will prevent
    #       automatic conversion of the value to local time.
    result = datetimeobject(result.year, result.month, result.day,
                            result.hour, result.minute, result.second,
                            result.microsecond, result.tzinfo***REMOVED***
    result.convert_to_local_time = False
    return result


# Template tags

class LocalTimeNode(Node***REMOVED***:
    ***REMOVED***
    Template node class used by ``localtime_tag``.
    ***REMOVED***
    def __init__(self, nodelist, use_tz***REMOVED***:
        self.nodelist = nodelist
        self.use_tz = use_tz

    def render(self, context***REMOVED***:
        old_setting = context.use_tz
        context.use_tz = self.use_tz
        output = self.nodelist.render(context***REMOVED***
        context.use_tz = old_setting
        return output


class TimezoneNode(Node***REMOVED***:
    ***REMOVED***
    Template node class used by ``timezone_tag``.
    ***REMOVED***
    def __init__(self, nodelist, tz***REMOVED***:
        self.nodelist = nodelist
        self.tz = tz

    def render(self, context***REMOVED***:
        with timezone.override(self.tz.resolve(context***REMOVED******REMOVED***:
            output = self.nodelist.render(context***REMOVED***
        return output


class GetCurrentTimezoneNode(Node***REMOVED***:
    ***REMOVED***
    Template node class used by ``get_current_timezone_tag``.
    ***REMOVED***
    def __init__(self, variable***REMOVED***:
        self.variable = variable

    def render(self, context***REMOVED***:
        context[self.variable***REMOVED*** = timezone.get_current_timezone_name(***REMOVED***
        return ''


@register.tag('localtime'***REMOVED***
def localtime_tag(parser, token***REMOVED***:
    ***REMOVED***
    Forces or prevents conversion of datetime objects to local time,
    regardless of the value of ``settings.USE_TZ``.

    Sample usage::

    ***REMOVED***% localtime off %***REMOVED***{{ value_in_utc ***REMOVED******REMOVED***{% endlocaltime %***REMOVED***
    ***REMOVED***
    bits = token.split_contents(***REMOVED***
    if len(bits***REMOVED*** == 1:
        use_tz = True
    elif len(bits***REMOVED*** > 2 or bits[1***REMOVED*** not in ('on', 'off'***REMOVED***:
        raise TemplateSyntaxError("%r argument should be 'on' or 'off'" %
                                  bits[0***REMOVED******REMOVED***
    else:
        use_tz = bits[1***REMOVED*** == 'on'
    nodelist = parser.parse(('endlocaltime',***REMOVED******REMOVED***
    parser.delete_first_token(***REMOVED***
    return LocalTimeNode(nodelist, use_tz***REMOVED***


@register.tag('timezone'***REMOVED***
def timezone_tag(parser, token***REMOVED***:
    ***REMOVED***
    Enables a given time zone just for this block.

    The ``timezone`` argument must be an instance of a ``tzinfo`` subclass, a
    time zone name, or ``None``. If is it a time zone name, pytz is required.
    If it is ``None``, the default time zone is used within the block.

    Sample usage::

    ***REMOVED***% timezone "Europe/Paris" %***REMOVED***
            It is {{ now ***REMOVED******REMOVED*** in Paris.
    ***REMOVED***% endtimezone %***REMOVED***
    ***REMOVED***
    bits = token.split_contents(***REMOVED***
    if len(bits***REMOVED*** != 2:
        raise TemplateSyntaxError("'%s' takes one argument (timezone***REMOVED***" %
                                  bits[0***REMOVED******REMOVED***
    tz = parser.compile_filter(bits[1***REMOVED******REMOVED***
    nodelist = parser.parse(('endtimezone',***REMOVED******REMOVED***
    parser.delete_first_token(***REMOVED***
    return TimezoneNode(nodelist, tz***REMOVED***


@register.tag("get_current_timezone"***REMOVED***
def get_current_timezone_tag(parser, token***REMOVED***:
    ***REMOVED***
    Stores the name of the current time zone in the context.

    Usage::

    ***REMOVED***% get_current_timezone as TIME_ZONE %***REMOVED***

    This will fetch the currently active time zone and put its name
    into the ``TIME_ZONE`` context variable.
    ***REMOVED***
    # token.split_contents(***REMOVED*** isn't useful here because this tag doesn't accept variable as arguments
    args = token.contents.split(***REMOVED***
    if len(args***REMOVED*** != 3 or args[1***REMOVED*** != 'as':
        raise TemplateSyntaxError("'get_current_timezone' requires "
                                  "'as variable' (got %r***REMOVED***" % args***REMOVED***
    return GetCurrentTimezoneNode(args[2***REMOVED******REMOVED***
