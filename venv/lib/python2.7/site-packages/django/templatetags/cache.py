from __future__ import unicode_literals

from django.core.cache import InvalidCacheBackendError, caches
from django.core.cache.utils import make_template_fragment_key
from django.template import (
    Library, Node, TemplateSyntaxError, VariableDoesNotExist,
***REMOVED***

register = Library(***REMOVED***


class CacheNode(Node***REMOVED***:
    def __init__(self, nodelist, expire_time_var, fragment_name, vary_on, cache_name***REMOVED***:
        self.nodelist = nodelist
        self.expire_time_var = expire_time_var
        self.fragment_name = fragment_name
        self.vary_on = vary_on
        self.cache_name = cache_name

    def render(self, context***REMOVED***:
        ***REMOVED***
            expire_time = self.expire_time_var.resolve(context***REMOVED***
        except VariableDoesNotExist:
            raise TemplateSyntaxError('"cache" tag got an unknown variable: %r' % self.expire_time_var.var***REMOVED***
        ***REMOVED***
            expire_time = int(expire_time***REMOVED***
        except (ValueError, TypeError***REMOVED***:
            raise TemplateSyntaxError('"cache" tag got a non-integer timeout value: %r' % expire_time***REMOVED***
        if self.cache_name:
            ***REMOVED***
                cache_name = self.cache_name.resolve(context***REMOVED***
            except VariableDoesNotExist:
                raise TemplateSyntaxError('"cache" tag got an unknown variable: %r' % self.cache_name.var***REMOVED***
            ***REMOVED***
                fragment_cache = caches[cache_name***REMOVED***
            except InvalidCacheBackendError:
                raise TemplateSyntaxError('Invalid cache name specified for cache tag: %r' % cache_name***REMOVED***
        else:
            ***REMOVED***
                fragment_cache = caches['template_fragments'***REMOVED***
            except InvalidCacheBackendError:
                fragment_cache = caches['default'***REMOVED***

        vary_on = [var.resolve(context***REMOVED*** for var in self.vary_on***REMOVED***
        cache_key = make_template_fragment_key(self.fragment_name, vary_on***REMOVED***
        value = fragment_cache.get(cache_key***REMOVED***
        if value is None:
            value = self.nodelist.render(context***REMOVED***
            fragment_cache.set(cache_key, value, expire_time***REMOVED***
        return value


@register.tag('cache'***REMOVED***
def do_cache(parser, token***REMOVED***:
    ***REMOVED***
    This will cache the contents of a template fragment for a given amount
    of time.

    Usage::

    ***REMOVED***% load cache %***REMOVED***
    ***REMOVED***% cache [expire_time***REMOVED*** [fragment_name***REMOVED*** %***REMOVED***
            .. some expensive processing ..
    ***REMOVED***% endcache %***REMOVED***

    This tag also supports varying by a list of arguments::

    ***REMOVED***% load cache %***REMOVED***
    ***REMOVED***% cache [expire_time***REMOVED*** [fragment_name***REMOVED*** [var1***REMOVED*** [var2***REMOVED*** .. %***REMOVED***
            .. some expensive processing ..
    ***REMOVED***% endcache %***REMOVED***

    Optionally the cache to use may be specified thus::

    ***REMOVED***% cache ....  using="cachename" %***REMOVED***

    Each unique set of arguments will result in a unique cache entry.
    ***REMOVED***
    nodelist = parser.parse(('endcache',***REMOVED******REMOVED***
    parser.delete_first_token(***REMOVED***
    tokens = token.split_contents(***REMOVED***
    if len(tokens***REMOVED*** < 3:
        raise TemplateSyntaxError("'%r' tag requires at least 2 arguments." % tokens[0***REMOVED******REMOVED***
    if len(tokens***REMOVED*** > 3 and tokens[-1***REMOVED***.startswith('using='***REMOVED***:
        cache_name = parser.compile_filter(tokens[-1***REMOVED***[len('using='***REMOVED***:***REMOVED******REMOVED***
        tokens = tokens[:-1***REMOVED***
    else:
        cache_name = None
    return CacheNode(
        nodelist, parser.compile_filter(tokens[1***REMOVED******REMOVED***,
        tokens[2***REMOVED***,  # fragment_name can't be a variable.
        [parser.compile_filter(t***REMOVED*** for t in tokens[3:***REMOVED******REMOVED***,
        cache_name,
    ***REMOVED***
