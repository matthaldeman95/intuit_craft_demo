***REMOVED***
This module collects helper functions and classes that "span" multiple levels
of MVC. In other words, these functions/classes introduce controlled coupling
for convenience's sake.
***REMOVED***
from django.http import (
    Http404, HttpResponse, HttpResponsePermanentRedirect, HttpResponseRedirect,
***REMOVED***
from django.template import loader
from django.urls import NoReverseMatch, reverse
from django.utils import six
from django.utils.encoding import force_text
from django.utils.functional import Promise


def render_to_response(template_name, context=None, content_type=None, status=None, using=None***REMOVED***:
    ***REMOVED***
    Returns a HttpResponse whose content is filled with the result of calling
    django.template.loader.render_to_string(***REMOVED*** with the passed arguments.
    ***REMOVED***
    content = loader.render_to_string(template_name, context, using=using***REMOVED***
    return HttpResponse(content, content_type, status***REMOVED***


def render(request, template_name, context=None, content_type=None, status=None, using=None***REMOVED***:
    ***REMOVED***
    Returns a HttpResponse whose content is filled with the result of calling
    django.template.loader.render_to_string(***REMOVED*** with the passed arguments.
    ***REMOVED***
    content = loader.render_to_string(template_name, context, request, using=using***REMOVED***
    return HttpResponse(content, content_type, status***REMOVED***


def redirect(to, *args, **kwargs***REMOVED***:
    ***REMOVED***
    Returns an HttpResponseRedirect to the appropriate URL for the arguments
    passed.

    The arguments could be:

        * A model: the model's `get_absolute_url(***REMOVED***` function will be called.

        * A view name, possibly with arguments: `urls.reverse(***REMOVED***` will be used
          to reverse-resolve the name.

        * A URL, which will be used as-is for the redirect location.

    By default issues a temporary redirect; pass permanent=True to issue a
    permanent redirect
    ***REMOVED***
    if kwargs.pop('permanent', False***REMOVED***:
        redirect_class = HttpResponsePermanentRedirect
    else:
        redirect_class = HttpResponseRedirect

    return redirect_class(resolve_url(to, *args, **kwargs***REMOVED******REMOVED***


def _get_queryset(klass***REMOVED***:
    ***REMOVED***
    Return a QuerySet or a Manager.
    Duck typing in action: any class with a `get(***REMOVED***` method (for
    get_object_or_404***REMOVED*** or a `filter(***REMOVED***` method (for get_list_or_404***REMOVED*** might do
    the job.
    ***REMOVED***
    # If it is a model class or anything else with ._default_manager
    if hasattr(klass, '_default_manager'***REMOVED***:
        return klass._default_manager.all(***REMOVED***
    return klass


def get_object_or_404(klass, *args, **kwargs***REMOVED***:
    ***REMOVED***
    Uses get(***REMOVED*** to return an object, or raises a Http404 exception if the object
    does not exist.

    klass may be a Model, Manager, or QuerySet object. All other passed
    arguments and keyword arguments are used in the get(***REMOVED*** query.

    Note: Like with get(***REMOVED***, an MultipleObjectsReturned will be raised if more than one
    object is found.
    ***REMOVED***
    queryset = _get_queryset(klass***REMOVED***
    ***REMOVED***
        return queryset.get(*args, **kwargs***REMOVED***
    except AttributeError:
        klass__name = klass.__name__ if isinstance(klass, type***REMOVED*** else klass.__class__.__name__
        raise ValueError(
            "First argument to get_object_or_404(***REMOVED*** must be a Model, Manager, "
            "or QuerySet, not '%s'." % klass__name
        ***REMOVED***
    except queryset.model.DoesNotExist:
        raise Http404('No %s matches the given query.' % queryset.model._meta.object_name***REMOVED***


def get_list_or_404(klass, *args, **kwargs***REMOVED***:
    ***REMOVED***
    Uses filter(***REMOVED*** to return a list of objects, or raise a Http404 exception if
    the list is empty.

    klass may be a Model, Manager, or QuerySet object. All other passed
    arguments and keyword arguments are used in the filter(***REMOVED*** query.
    ***REMOVED***
    queryset = _get_queryset(klass***REMOVED***
    ***REMOVED***
        obj_list = list(queryset.filter(*args, **kwargs***REMOVED******REMOVED***
    except AttributeError:
        klass__name = klass.__name__ if isinstance(klass, type***REMOVED*** else klass.__class__.__name__
        raise ValueError(
            "First argument to get_list_or_404(***REMOVED*** must be a Model, Manager, or "
            "QuerySet, not '%s'." % klass__name
        ***REMOVED***
    if not obj_list:
        raise Http404('No %s matches the given query.' % queryset.model._meta.object_name***REMOVED***
    return obj_list


def resolve_url(to, *args, **kwargs***REMOVED***:
    ***REMOVED***
    Return a URL appropriate for the arguments passed.

    The arguments could be:

        * A model: the model's `get_absolute_url(***REMOVED***` function will be called.

        * A view name, possibly with arguments: `urls.reverse(***REMOVED***` will be used
          to reverse-resolve the name.

        * A URL, which will be returned as-is.
    ***REMOVED***
    # If it's a model, use get_absolute_url(***REMOVED***
    if hasattr(to, 'get_absolute_url'***REMOVED***:
        return to.get_absolute_url(***REMOVED***

    if isinstance(to, Promise***REMOVED***:
        # Expand the lazy instance, as it can cause issues when it is passed
        # further to some Python functions like urlparse.
        to = force_text(to***REMOVED***

    if isinstance(to, six.string_types***REMOVED***:
        # Handle relative URLs
        if to.startswith(('./', '../'***REMOVED******REMOVED***:
            return to

    # Next try a reverse URL resolution.
    ***REMOVED***
        return reverse(to, args=args, kwargs=kwargs***REMOVED***
    except NoReverseMatch:
        # If this is a callable, re-raise.
        if callable(to***REMOVED***:
            raise
        # If this doesn't "feel" like a URL, re-raise.
        if '/' not in to and '.' not in to:
            raise

    # Finally, fall back and assume it's a URL
    return to
