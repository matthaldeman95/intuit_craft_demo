# -*- coding: utf-8 -*-
from __future__ import unicode_literals

from itertools import chain

from django.utils.itercompat import is_iterable


class Tags(object***REMOVED***:
    ***REMOVED***
    Built-in tags for internal checks.
    ***REMOVED***
    admin = 'admin'
    caches = 'caches'
    compatibility = 'compatibility'
    database = 'database'
    models = 'models'
    security = 'security'
    signals = 'signals'
    templates = 'templates'
    urls = 'urls'


class CheckRegistry(object***REMOVED***:

    def __init__(self***REMOVED***:
        self.registered_checks = [***REMOVED***
        self.deployment_checks = [***REMOVED***

    def register(self, check=None, *tags, **kwargs***REMOVED***:
        ***REMOVED***
        Can be used as a function or a decorator. Register given function
        `f` labeled with given `tags`. The function should receive **kwargs
        and return list of Errors and Warnings.

        Example::

            registry = CheckRegistry(***REMOVED***
            @registry.register('mytag', 'anothertag'***REMOVED***
            def my_check(apps, **kwargs***REMOVED***:
                # ... perform checks and collect `errors` ...
                return errors
            # or
            registry.register(my_check, 'mytag', 'anothertag'***REMOVED***
        ***REMOVED***
        kwargs.setdefault('deploy', False***REMOVED***

        def inner(check***REMOVED***:
            check.tags = tags
            if kwargs['deploy'***REMOVED***:
                if check not in self.deployment_checks:
                    self.deployment_checks.append(check***REMOVED***
            elif check not in self.registered_checks:
                self.registered_checks.append(check***REMOVED***
            return check

        if callable(check***REMOVED***:
            return inner(check***REMOVED***
        else:
            if check:
                tags += (check, ***REMOVED***
            return inner

    def run_checks(self, app_configs=None, tags=None, include_deployment_checks=False***REMOVED***:
        ***REMOVED***
        Run all registered checks and return list of Errors and Warnings.
        ***REMOVED***
        errors = [***REMOVED***
        checks = self.get_checks(include_deployment_checks***REMOVED***

        if tags is not None:
            checks = [check for check in checks
                      if hasattr(check, 'tags'***REMOVED*** and set(check.tags***REMOVED*** & set(tags***REMOVED******REMOVED***
        else:
            # By default, 'database'-tagged checks are not run as they do more
            # than mere static code analysis.
            checks = [check for check in checks
                      if not hasattr(check, 'tags'***REMOVED*** or Tags.database not in check.tags***REMOVED***

        for check in checks:
            new_errors = check(app_configs=app_configs***REMOVED***
            assert is_iterable(new_errors***REMOVED***, (
                "The function %r did not return a list. All functions registered "
                "with the checks registry must return a list." % check***REMOVED***
            errors.extend(new_errors***REMOVED***
        return errors

    def tag_exists(self, tag, include_deployment_checks=False***REMOVED***:
        return tag in self.tags_available(include_deployment_checks***REMOVED***

    def tags_available(self, deployment_checks=False***REMOVED***:
        return set(chain(*[check.tags for check in self.get_checks(deployment_checks***REMOVED*** if hasattr(check, 'tags'***REMOVED******REMOVED******REMOVED******REMOVED***

    def get_checks(self, include_deployment_checks=False***REMOVED***:
        checks = list(self.registered_checks***REMOVED***
        if include_deployment_checks:
            checks.extend(self.deployment_checks***REMOVED***
        return checks


registry = CheckRegistry(***REMOVED***
register = registry.register
run_checks = registry.run_checks
tag_exists = registry.tag_exists
