from __future__ import unicode_literals

import logging
import sys
import types
import warnings

from django.conf import settings
from django.core import signals
from django.core.exceptions import ImproperlyConfigured, MiddlewareNotUsed
from django.db import connections, transaction
from django.urls import get_resolver, get_urlconf, set_urlconf
from django.utils import six
from django.utils.deprecation import RemovedInDjango20Warning
from django.utils.module_loading import import_string

from .exception import (
    convert_exception_to_response, get_exception_response,
    handle_uncaught_exception,
***REMOVED***

logger = logging.getLogger('django.request'***REMOVED***


class BaseHandler(object***REMOVED***:

    def __init__(self***REMOVED***:
        self._request_middleware = None
        self._view_middleware = None
        self._template_response_middleware = None
        self._response_middleware = None
        self._exception_middleware = None
        self._middleware_chain = None

    def load_middleware(self***REMOVED***:
        ***REMOVED***
        Populate middleware lists from settings.MIDDLEWARE (or the deprecated
        MIDDLEWARE_CLASSES***REMOVED***.

        Must be called after the environment is fixed (see __call__ in subclasses***REMOVED***.
        ***REMOVED***
        self._request_middleware = [***REMOVED***
        self._view_middleware = [***REMOVED***
        self._template_response_middleware = [***REMOVED***
        self._response_middleware = [***REMOVED***
        self._exception_middleware = [***REMOVED***

        if settings.MIDDLEWARE is None:
            warnings.warn(
                "Old-style middleware using settings.MIDDLEWARE_CLASSES is "
                "deprecated. Update your middleware and use settings.MIDDLEWARE "
                "instead.", RemovedInDjango20Warning
            ***REMOVED***
            handler = convert_exception_to_response(self._legacy_get_response***REMOVED***
            for middleware_path in settings.MIDDLEWARE_CLASSES:
                mw_class = import_string(middleware_path***REMOVED***
                ***REMOVED***
                    mw_instance = mw_class(***REMOVED***
                except MiddlewareNotUsed as exc:
                    if settings.DEBUG:
                        if six.text_type(exc***REMOVED***:
                            logger.debug('MiddlewareNotUsed(%r***REMOVED***: %s', middleware_path, exc***REMOVED***
                        else:
                            logger.debug('MiddlewareNotUsed: %r', middleware_path***REMOVED***
                    continue

                if hasattr(mw_instance, 'process_request'***REMOVED***:
                    self._request_middleware.append(mw_instance.process_request***REMOVED***
                if hasattr(mw_instance, 'process_view'***REMOVED***:
                    self._view_middleware.append(mw_instance.process_view***REMOVED***
                if hasattr(mw_instance, 'process_template_response'***REMOVED***:
                    self._template_response_middleware.insert(0, mw_instance.process_template_response***REMOVED***
                if hasattr(mw_instance, 'process_response'***REMOVED***:
                    self._response_middleware.insert(0, mw_instance.process_response***REMOVED***
                if hasattr(mw_instance, 'process_exception'***REMOVED***:
                    self._exception_middleware.insert(0, mw_instance.process_exception***REMOVED***
        else:
            handler = convert_exception_to_response(self._get_response***REMOVED***
            for middleware_path in reversed(settings.MIDDLEWARE***REMOVED***:
                middleware = import_string(middleware_path***REMOVED***
                ***REMOVED***
                    mw_instance = middleware(handler***REMOVED***
                except MiddlewareNotUsed as exc:
                    if settings.DEBUG:
                        if six.text_type(exc***REMOVED***:
                            logger.debug('MiddlewareNotUsed(%r***REMOVED***: %s', middleware_path, exc***REMOVED***
                        else:
                            logger.debug('MiddlewareNotUsed: %r', middleware_path***REMOVED***
                    continue

                if mw_instance is None:
                    raise ImproperlyConfigured(
                        'Middleware factory %s returned None.' % middleware_path
                    ***REMOVED***

                if hasattr(mw_instance, 'process_view'***REMOVED***:
                    self._view_middleware.insert(0, mw_instance.process_view***REMOVED***
                if hasattr(mw_instance, 'process_template_response'***REMOVED***:
                    self._template_response_middleware.append(mw_instance.process_template_response***REMOVED***
                if hasattr(mw_instance, 'process_exception'***REMOVED***:
                    self._exception_middleware.append(mw_instance.process_exception***REMOVED***

                handler = convert_exception_to_response(mw_instance***REMOVED***

        # We only assign to this when initialization is complete as it is used
        # as a flag for initialization being complete.
        self._middleware_chain = handler

    def make_view_atomic(self, view***REMOVED***:
        non_atomic_requests = getattr(view, '_non_atomic_requests', set(***REMOVED******REMOVED***
        for db in connections.all(***REMOVED***:
            if db.settings_dict['ATOMIC_REQUESTS'***REMOVED*** and db.alias not in non_atomic_requests:
                view = transaction.atomic(using=db.alias***REMOVED***(view***REMOVED***
        return view

    def get_exception_response(self, request, resolver, status_code, exception***REMOVED***:
        return get_exception_response(request, resolver, status_code, exception, self.__class__***REMOVED***

    def get_response(self, request***REMOVED***:
        ***REMOVED***Return an HttpResponse object for the given HttpRequest.***REMOVED***
        # Setup default url resolver for this thread
        set_urlconf(settings.ROOT_URLCONF***REMOVED***

        response = self._middleware_chain(request***REMOVED***

        # This block is only needed for legacy MIDDLEWARE_CLASSES; if
        # MIDDLEWARE is used, self._response_middleware will be empty.
        ***REMOVED***
            # Apply response middleware, regardless of the response
            for middleware_method in self._response_middleware:
                response = middleware_method(request, response***REMOVED***
                # Complain if the response middleware returned None (a common error***REMOVED***.
                if response is None:
                    raise ValueError(
                        "%s.process_response didn't return an "
                        "HttpResponse object. It returned None instead."
                        % (middleware_method.__self__.__class__.__name__***REMOVED******REMOVED***
        except Exception:  # Any exception should be gathered and handled
            signals.got_request_exception.send(sender=self.__class__, request=request***REMOVED***
            response = self.handle_uncaught_exception(request, get_resolver(get_urlconf(***REMOVED******REMOVED***, sys.exc_info(***REMOVED******REMOVED***

        response._closable_objects.append(request***REMOVED***

        # If the exception handler returns a TemplateResponse that has not
        # been rendered, force it to be rendered.
        if not getattr(response, 'is_rendered', True***REMOVED*** and callable(getattr(response, 'render', None***REMOVED******REMOVED***:
            response = response.render(***REMOVED***

        if response.status_code == 404:
            logger.warning(
                'Not Found: %s', request.path,
                extra={'status_code': 404, 'request': request***REMOVED***,
            ***REMOVED***

        return response

    def _get_response(self, request***REMOVED***:
        ***REMOVED***
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        ***REMOVED***
        response = None

        if hasattr(request, 'urlconf'***REMOVED***:
            urlconf = request.urlconf
            set_urlconf(urlconf***REMOVED***
            resolver = get_resolver(urlconf***REMOVED***
        else:
            resolver = get_resolver(***REMOVED***

        resolver_match = resolver.resolve(request.path_info***REMOVED***
        callback, callback_args, callback_kwargs = resolver_match
        request.resolver_match = resolver_match

        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs***REMOVED***
            if response:
                break

        if response is None:
            wrapped_callback = self.make_view_atomic(callback***REMOVED***
            ***REMOVED***
                response = wrapped_callback(request, *callback_args, **callback_kwargs***REMOVED***
            except Exception as e:
                response = self.process_exception_by_middleware(e, request***REMOVED***

        # Complain if the view returned None (a common error***REMOVED***.
        if response is None:
            if isinstance(callback, types.FunctionType***REMOVED***:    # FBV
                view_name = callback.__name__
            else:                                           # CBV
                view_name = callback.__class__.__name__ + '.__call__'

            raise ValueError(
                "The view %s.%s didn't return an HttpResponse object. It "
                "returned None instead." % (callback.__module__, view_name***REMOVED***
            ***REMOVED***

        # If the response supports deferred rendering, apply template
        # response middleware and then render the response
        elif hasattr(response, 'render'***REMOVED*** and callable(response.render***REMOVED***:
            for middleware_method in self._template_response_middleware:
                response = middleware_method(request, response***REMOVED***
                # Complain if the template response middleware returned None (a common error***REMOVED***.
                if response is None:
                    raise ValueError(
                        "%s.process_template_response didn't return an "
                        "HttpResponse object. It returned None instead."
                        % (middleware_method.__self__.__class__.__name__***REMOVED***
                    ***REMOVED***

            ***REMOVED***
                response = response.render(***REMOVED***
            except Exception as e:
                response = self.process_exception_by_middleware(e, request***REMOVED***

        return response

    def process_exception_by_middleware(self, exception, request***REMOVED***:
        ***REMOVED***
        Pass the exception to the exception middleware. If no middleware
        return a response for this exception, raise it.
        ***REMOVED***
        for middleware_method in self._exception_middleware:
            response = middleware_method(request, exception***REMOVED***
            if response:
                return response
        raise

    def handle_uncaught_exception(self, request, resolver, exc_info***REMOVED***:
        ***REMOVED***Allow subclasses to override uncaught exception handling.***REMOVED***
        return handle_uncaught_exception(request, resolver, exc_info***REMOVED***

    def _legacy_get_response(self, request***REMOVED***:
        ***REMOVED***
        Apply process_request(***REMOVED*** middleware and call the main _get_response(***REMOVED***,
        if needed. Used only for legacy MIDDLEWARE_CLASSES.
        ***REMOVED***
        response = None
        # Apply request middleware
        for middleware_method in self._request_middleware:
            response = middleware_method(request***REMOVED***
            if response:
                break

        if response is None:
            response = self._get_response(request***REMOVED***
        return response
