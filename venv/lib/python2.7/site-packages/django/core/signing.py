***REMOVED***
Functions for creating and restoring url-safe signed JSON objects.

The format used looks like this:

>>> signing.dumps("hello"***REMOVED***
'ImhlbGxvIg:1QaUZC:YIye-ze3TTx7gtSv422nZA4sgmk'

There are two components here, separated by a ':'. The first component is a
URLsafe base64 encoded JSON of the object passed to dumps(***REMOVED***. The second
component is a base64 encoded hmac/SHA1 hash of "$first_component:$secret"

signing.loads(s***REMOVED*** checks the signature and returns the deserialized object.
If the signature fails, a BadSignature exception is raised.

>>> signing.loads("ImhlbGxvIg:1QaUZC:YIye-ze3TTx7gtSv422nZA4sgmk"***REMOVED***
u'hello'
>>> signing.loads("ImhlbGxvIg:1QaUZC:YIye-ze3TTx7gtSv422nZA4sgmk-modified"***REMOVED***
...
BadSignature: Signature failed: ImhlbGxvIg:1QaUZC:YIye-ze3TTx7gtSv422nZA4sgmk-modified

You can optionally compress the JSON prior to base64 encoding it to save
space, using the compress=True argument. This checks if compression actually
helps and only applies compression if the result is a shorter string:

>>> signing.dumps(range(1, 20***REMOVED***, compress=True***REMOVED***
'.eJwFwcERACAIwLCF-rCiILN47r-GyZVJsNgkxaFxoDgxcOHGxMKD_T7vhAml:1QaUaL:BA0thEZrp4FQVXIXuOvYJtLJSrQ'

The fact that the string is compressed is signalled by the prefixed '.' at the
start of the base64 JSON.

There are 65 url-safe characters: the 64 used by url-safe base64 and the ':'.
These functions make use of all of them.
***REMOVED***

from __future__ import unicode_literals

import base64
import datetime
import json
import re
import time
import zlib

from django.conf import settings
from django.utils import baseconv
from django.utils.crypto import constant_time_compare, salted_hmac
from django.utils.encoding import force_bytes, force_str, force_text
from django.utils.module_loading import import_string

_SEP_UNSAFE = re.compile(r'^[A-z0-9-_=***REMOVED****$'***REMOVED***


class BadSignature(Exception***REMOVED***:
    ***REMOVED***
    Signature does not match
    ***REMOVED***
    pass


class SignatureExpired(BadSignature***REMOVED***:
    ***REMOVED***
    Signature timestamp is older than required max_age
    ***REMOVED***
    pass


def b64_encode(s***REMOVED***:
    return base64.urlsafe_b64encode(s***REMOVED***.strip(b'='***REMOVED***


def b64_decode(s***REMOVED***:
    pad = b'=' * (-len(s***REMOVED*** % 4***REMOVED***
    return base64.urlsafe_b64decode(s + pad***REMOVED***


def base64_hmac(salt, value, key***REMOVED***:
    return b64_encode(salted_hmac(salt, value, key***REMOVED***.digest(***REMOVED******REMOVED***


def get_cookie_signer(salt='django.core.signing.get_cookie_signer'***REMOVED***:
    Signer = import_string(settings.SIGNING_BACKEND***REMOVED***
    key = force_bytes(settings.SECRET_KEY***REMOVED***
    return Signer(b'django.http.cookies' + key, salt=salt***REMOVED***


class JSONSerializer(object***REMOVED***:
    ***REMOVED***
    Simple wrapper around json to be used in signing.dumps and
    signing.loads.
    ***REMOVED***
    def dumps(self, obj***REMOVED***:
        return json.dumps(obj, separators=(',', ':'***REMOVED******REMOVED***.encode('latin-1'***REMOVED***

    def loads(self, data***REMOVED***:
        return json.loads(data.decode('latin-1'***REMOVED******REMOVED***


def dumps(obj, key=None, salt='django.core.signing', serializer=JSONSerializer, compress=False***REMOVED***:
    ***REMOVED***
    Returns URL-safe, sha1 signed base64 compressed JSON string. If key is
    None, settings.SECRET_KEY is used instead.

    If compress is True (not the default***REMOVED*** checks if compressing using zlib can
    save some space. Prepends a '.' to signify compression. This is included
    in the signature, to protect against zip bombs.

    Salt can be used to namespace the hash, so that a signed string is
    only valid for a given namespace. Leaving this at the default
    value or re-using a salt value across different parts of your
    application without good cause is a security risk.

    The serializer is expected to return a bytestring.
    ***REMOVED***
    data = serializer(***REMOVED***.dumps(obj***REMOVED***

    # Flag for if it's been compressed or not
    is_compressed = False

    if compress:
        # Avoid zlib dependency unless compress is being used
        compressed = zlib.compress(data***REMOVED***
        if len(compressed***REMOVED*** < (len(data***REMOVED*** - 1***REMOVED***:
            data = compressed
            is_compressed = True
    base64d = b64_encode(data***REMOVED***
    if is_compressed:
        base64d = b'.' + base64d
    return TimestampSigner(key, salt=salt***REMOVED***.sign(base64d***REMOVED***


def loads(s, key=None, salt='django.core.signing', serializer=JSONSerializer, max_age=None***REMOVED***:
    ***REMOVED***
    Reverse of dumps(***REMOVED***, raises BadSignature if signature fails.

    The serializer is expected to accept a bytestring.
    ***REMOVED***
    # TimestampSigner.unsign always returns unicode but base64 and zlib
    # compression operate on bytes.
    base64d = force_bytes(TimestampSigner(key, salt=salt***REMOVED***.unsign(s, max_age=max_age***REMOVED******REMOVED***
    decompress = False
    if base64d[:1***REMOVED*** == b'.':
        # It's compressed; uncompress it first
        base64d = base64d[1:***REMOVED***
        decompress = True
    data = b64_decode(base64d***REMOVED***
    if decompress:
        data = zlib.decompress(data***REMOVED***
    return serializer(***REMOVED***.loads(data***REMOVED***


class Signer(object***REMOVED***:

    def __init__(self, key=None, sep=':', salt=None***REMOVED***:
        # Use of native strings in all versions of Python
        self.key = key or settings.SECRET_KEY
        self.sep = force_str(sep***REMOVED***
        if _SEP_UNSAFE.match(self.sep***REMOVED***:
            raise ValueError(
                'Unsafe Signer separator: %r (cannot be empty or consist of '
                'only A-z0-9-_=***REMOVED***' % sep,
            ***REMOVED***
        self.salt = force_str(salt or '%s.%s' % (self.__class__.__module__, self.__class__.__name__***REMOVED******REMOVED***

    def signature(self, value***REMOVED***:
        signature = base64_hmac(self.salt + 'signer', value, self.key***REMOVED***
        # Convert the signature from bytes to str only on Python 3
        return force_str(signature***REMOVED***

    def sign(self, value***REMOVED***:
        value = force_str(value***REMOVED***
        return str('%s%s%s'***REMOVED*** % (value, self.sep, self.signature(value***REMOVED******REMOVED***

    def unsign(self, signed_value***REMOVED***:
        signed_value = force_str(signed_value***REMOVED***
        if self.sep not in signed_value:
            raise BadSignature('No "%s" found in value' % self.sep***REMOVED***
        value, sig = signed_value.rsplit(self.sep, 1***REMOVED***
        if constant_time_compare(sig, self.signature(value***REMOVED******REMOVED***:
            return force_text(value***REMOVED***
        raise BadSignature('Signature "%s" does not match' % sig***REMOVED***


class TimestampSigner(Signer***REMOVED***:

    def timestamp(self***REMOVED***:
        return baseconv.base62.encode(int(time.time(***REMOVED******REMOVED******REMOVED***

    def sign(self, value***REMOVED***:
        value = force_str(value***REMOVED***
        value = str('%s%s%s'***REMOVED*** % (value, self.sep, self.timestamp(***REMOVED******REMOVED***
        return super(TimestampSigner, self***REMOVED***.sign(value***REMOVED***

    def unsign(self, value, max_age=None***REMOVED***:
        ***REMOVED***
        Retrieve original value and check it wasn't signed more
        than max_age seconds ago.
        ***REMOVED***
        result = super(TimestampSigner, self***REMOVED***.unsign(value***REMOVED***
        value, timestamp = result.rsplit(self.sep, 1***REMOVED***
        timestamp = baseconv.base62.decode(timestamp***REMOVED***
        if max_age is not None:
            if isinstance(max_age, datetime.timedelta***REMOVED***:
                max_age = max_age.total_seconds(***REMOVED***
            # Check timestamp is not older than max_age
            age = time.time(***REMOVED*** - timestamp
            if age > max_age:
                raise SignatureExpired(
                    'Signature age %s > %s seconds' % (age, max_age***REMOVED******REMOVED***
        return value
