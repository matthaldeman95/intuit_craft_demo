import errno
***REMOVED***
import warnings
from datetime import datetime

from django.conf import settings
from django.core.exceptions import SuspiciousFileOperation
from django.core.files import File, locks
from django.core.files.move import file_move_safe
from django.core.signals import setting_changed
from django.utils import timezone
from django.utils._os import abspathu, safe_join
***REMOVED***
from django.utils.deconstruct import deconstructible
from django.utils.deprecation import RemovedInDjango20Warning
from django.utils.encoding import filepath_to_uri, force_text
from django.utils.functional import LazyObject, cached_property
from django.utils.module_loading import import_string
from django.utils.six.moves.urllib.parse import urljoin
from django.utils.text import get_valid_filename

__all__ = ('Storage', 'FileSystemStorage', 'DefaultStorage', 'default_storage'***REMOVED***


class Storage(object***REMOVED***:
    ***REMOVED***
    A base storage class, providing some default behaviors that all other
    storage systems can inherit or override, as necessary.
    ***REMOVED***

    # The following methods represent a public interface to private methods.
    # These shouldn't be overridden by subclasses unless absolutely necessary.

    def open(self, name, mode='rb'***REMOVED***:
        ***REMOVED***
        Retrieves the specified file from storage.
        ***REMOVED***
        return self._open(name, mode***REMOVED***

    def save(self, name, content, max_length=None***REMOVED***:
        ***REMOVED***
        Saves new content to the file specified by name. The content should be
        a proper File object or any python file-like object, ready to be read
        from the beginning.
        ***REMOVED***
        # Get the proper name for the file, as it will actually be saved.
        if name is None:
            name = content.name

        if not hasattr(content, 'chunks'***REMOVED***:
            content = File(content, name***REMOVED***

        name = self.get_available_name(name, max_length=max_length***REMOVED***
        return self._save(name, content***REMOVED***

    # These methods are part of the public API, with default implementations.

    def get_valid_name(self, name***REMOVED***:
        ***REMOVED***
        Returns a filename, based on the provided filename, that's suitable for
        use in the target storage system.
        ***REMOVED***
        return get_valid_filename(name***REMOVED***

    def get_available_name(self, name, max_length=None***REMOVED***:
        ***REMOVED***
        Returns a filename that's free on the target storage system, and
        available for new content to be written to.
        ***REMOVED***
        dir_name, file_name = os.path.split(name***REMOVED***
        file_root, file_ext = os.path.splitext(file_name***REMOVED***
        # If the filename already exists, add an underscore and a random 7
        # character alphanumeric string (before the file extension, if one
        # exists***REMOVED*** to the filename until the generated filename doesn't exist.
        # Truncate original name if required, so the new filename does not
        # exceed the max_length.
        while self.exists(name***REMOVED*** or (max_length and len(name***REMOVED*** > max_length***REMOVED***:
            # file_ext includes the dot.
            name = os.path.join(dir_name, "%s_%s%s" % (file_root, get_random_string(7***REMOVED***, file_ext***REMOVED******REMOVED***
            if max_length is None:
                continue
            # Truncate file_root if max_length exceeded.
            truncation = len(name***REMOVED*** - max_length
            if truncation > 0:
                file_root = file_root[:-truncation***REMOVED***
                # Entire file_root was truncated in attempt to find an available filename.
                if not file_root:
                    raise SuspiciousFileOperation(
                        'Storage can not find an available filename for "%s". '
                        'Please make sure that the corresponding file field '
                        'allows sufficient "max_length".' % name
                    ***REMOVED***
                name = os.path.join(dir_name, "%s_%s%s" % (file_root, get_random_string(7***REMOVED***, file_ext***REMOVED******REMOVED***
        return name

    def generate_filename(self, filename***REMOVED***:
        ***REMOVED***
        Validate the filename by calling get_valid_name(***REMOVED*** and return a filename
        to be passed to the save(***REMOVED*** method.
        ***REMOVED***
        # `filename` may include a path as returned by FileField.upload_to.
        dirname, filename = os.path.split(filename***REMOVED***
        return os.path.normpath(os.path.join(dirname, self.get_valid_name(filename***REMOVED******REMOVED******REMOVED***

    def path(self, name***REMOVED***:
        ***REMOVED***
        Returns a local filesystem path where the file can be retrieved using
        Python's built-in open(***REMOVED*** function. Storage systems that can't be
        accessed using open(***REMOVED*** should *not* implement this method.
        ***REMOVED***
        raise NotImplementedError("This backend doesn't support absolute paths."***REMOVED***

    # The following methods form the public API for storage systems, but with
    # no default implementations. Subclasses must implement *all* of these.

    def delete(self, name***REMOVED***:
        ***REMOVED***
        Deletes the specified file from the storage system.
        ***REMOVED***
        raise NotImplementedError('subclasses of Storage must provide a delete(***REMOVED*** method'***REMOVED***

    def exists(self, name***REMOVED***:
        ***REMOVED***
        Returns True if a file referenced by the given name already exists in the
        storage system, or False if the name is available for a new file.
        ***REMOVED***
        raise NotImplementedError('subclasses of Storage must provide an exists(***REMOVED*** method'***REMOVED***

    def listdir(self, path***REMOVED***:
        ***REMOVED***
        Lists the contents of the specified path, returning a 2-tuple of lists;
        the first item being directories, the second item being files.
        ***REMOVED***
        raise NotImplementedError('subclasses of Storage must provide a listdir(***REMOVED*** method'***REMOVED***

    def size(self, name***REMOVED***:
        ***REMOVED***
        Returns the total size, in bytes, of the file specified by name.
        ***REMOVED***
        raise NotImplementedError('subclasses of Storage must provide a size(***REMOVED*** method'***REMOVED***

    def url(self, name***REMOVED***:
        ***REMOVED***
        Returns an absolute URL where the file's contents can be accessed
        directly by a Web browser.
        ***REMOVED***
        raise NotImplementedError('subclasses of Storage must provide a url(***REMOVED*** method'***REMOVED***

    def accessed_time(self, name***REMOVED***:
        ***REMOVED***
        Returns the last accessed time (as datetime object***REMOVED*** of the file
        specified by name. Deprecated: use get_accessed_time(***REMOVED*** instead.
        ***REMOVED***
        warnings.warn(
            'Storage.accessed_time(***REMOVED*** is deprecated in favor of get_accessed_time(***REMOVED***.',
            RemovedInDjango20Warning,
            stacklevel=2,
        ***REMOVED***
        raise NotImplementedError('subclasses of Storage must provide an accessed_time(***REMOVED*** method'***REMOVED***

    def created_time(self, name***REMOVED***:
        ***REMOVED***
        Returns the creation time (as datetime object***REMOVED*** of the file
        specified by name. Deprecated: use get_created_time(***REMOVED*** instead.
        ***REMOVED***
        warnings.warn(
            'Storage.created_time(***REMOVED*** is deprecated in favor of get_created_time(***REMOVED***.',
            RemovedInDjango20Warning,
            stacklevel=2,
        ***REMOVED***
        raise NotImplementedError('subclasses of Storage must provide a created_time(***REMOVED*** method'***REMOVED***

    def modified_time(self, name***REMOVED***:
        ***REMOVED***
        Returns the last modified time (as datetime object***REMOVED*** of the file
        specified by name. Deprecated: use get_modified_time(***REMOVED*** instead.
        ***REMOVED***
        warnings.warn(
            'Storage.modified_time(***REMOVED*** is deprecated in favor of get_modified_time(***REMOVED***.',
            RemovedInDjango20Warning,
            stacklevel=2,
        ***REMOVED***
        raise NotImplementedError('subclasses of Storage must provide a modified_time(***REMOVED*** method'***REMOVED***

    def get_accessed_time(self, name***REMOVED***:
        ***REMOVED***
        Return the last accessed time (as a datetime***REMOVED*** of the file specified by
        name. The datetime will be timezone-aware if USE_TZ=True.
        ***REMOVED***
        # At the end of the deprecation:
        # raise NotImplementedError('subclasses of Storage must provide a get_accessed_time(***REMOVED*** method'***REMOVED***
        warnings.warn(
            'Storage.accessed_time(***REMOVED*** is deprecated. '
            'Storage backends should implement get_accessed_time(***REMOVED***.',
            RemovedInDjango20Warning,
            stacklevel=2,
        ***REMOVED***
        dt = self.accessed_time(name***REMOVED***
        return _possibly_make_aware(dt***REMOVED***

    def get_created_time(self, name***REMOVED***:
        ***REMOVED***
        Return the creation time (as a datetime***REMOVED*** of the file specified by name.
        The datetime will be timezone-aware if USE_TZ=True.
        ***REMOVED***
        # At the end of the deprecation:
        # raise NotImplementedError('subclasses of Storage must provide a get_created_time(***REMOVED*** method'***REMOVED***
        warnings.warn(
            'Storage.created_time(***REMOVED*** is deprecated. '
            'Storage backends should implement get_created_time(***REMOVED***.',
            RemovedInDjango20Warning,
            stacklevel=2,
        ***REMOVED***
        dt = self.created_time(name***REMOVED***
        return _possibly_make_aware(dt***REMOVED***

    def get_modified_time(self, name***REMOVED***:
        ***REMOVED***
        Return the last modified time (as a datetime***REMOVED*** of the file specified by
        name. The datetime will be timezone-aware if USE_TZ=True.
        ***REMOVED***
        # At the end of the deprecation:
        # raise NotImplementedError('subclasses of Storage must provide a get_modified_time(***REMOVED*** method'***REMOVED***
        warnings.warn(
            'Storage.modified_time(***REMOVED*** is deprecated. '
            'Storage backends should implement get_modified_time(***REMOVED***.',
            RemovedInDjango20Warning,
            stacklevel=2,
        ***REMOVED***
        dt = self.modified_time(name***REMOVED***
        return _possibly_make_aware(dt***REMOVED***


def _possibly_make_aware(dt***REMOVED***:
    ***REMOVED***
    Convert a datetime object in the local timezone to aware
    in UTC, if USE_TZ is True.
    ***REMOVED***
    # This function is only needed to help with the deprecations above and can
    # be removed in Django 2.0, RemovedInDjango20Warning.
    if settings.USE_TZ:
        tz = timezone.get_default_timezone(***REMOVED***
        return timezone.make_aware(dt, tz***REMOVED***.astimezone(timezone.utc***REMOVED***
    else:
        return dt


@deconstructible
class FileSystemStorage(Storage***REMOVED***:
    ***REMOVED***
    Standard filesystem storage
    ***REMOVED***

    def __init__(self, location=None, base_url=None, file_permissions_mode=None,
                 directory_permissions_mode=None***REMOVED***:
        self._location = location
        self._base_url = base_url
        self._file_permissions_mode = file_permissions_mode
        self._directory_permissions_mode = directory_permissions_mode
        setting_changed.connect(self._clear_cached_properties***REMOVED***

    def _clear_cached_properties(self, setting, **kwargs***REMOVED***:
        ***REMOVED***Reset setting based property values.***REMOVED***
        if setting == 'MEDIA_ROOT':
            self.__dict__.pop('base_location', None***REMOVED***
            self.__dict__.pop('location', None***REMOVED***
        elif setting == 'MEDIA_URL':
            self.__dict__.pop('base_url', None***REMOVED***
        elif setting == 'FILE_UPLOAD_PERMISSIONS':
            self.__dict__.pop('file_permissions_mode', None***REMOVED***
        elif setting == 'FILE_UPLOAD_DIRECTORY_PERMISSIONS':
            self.__dict__.pop('directory_permissions_mode', None***REMOVED***

    def _value_or_setting(self, value, setting***REMOVED***:
        return setting if value is None else value

    @cached_property
    def base_location(self***REMOVED***:
        return self._value_or_setting(self._location, settings.MEDIA_ROOT***REMOVED***

    @cached_property
    def location(self***REMOVED***:
        return abspathu(self.base_location***REMOVED***

    @cached_property
    def base_url(self***REMOVED***:
        if self._base_url is not None and not self._base_url.endswith('/'***REMOVED***:
            self._base_url += '/'
        return self._value_or_setting(self._base_url, settings.MEDIA_URL***REMOVED***

    @cached_property
    def file_permissions_mode(self***REMOVED***:
        return self._value_or_setting(self._file_permissions_mode, settings.FILE_UPLOAD_PERMISSIONS***REMOVED***

    @cached_property
    def directory_permissions_mode(self***REMOVED***:
        return self._value_or_setting(self._directory_permissions_mode, settings.FILE_UPLOAD_DIRECTORY_PERMISSIONS***REMOVED***

    def _open(self, name, mode='rb'***REMOVED***:
        return File(open(self.path(name***REMOVED***, mode***REMOVED******REMOVED***

    def _save(self, name, content***REMOVED***:
        full_path = self.path(name***REMOVED***

        # Create any intermediate directories that do not exist.
        # Note that there is a race between os.path.exists and os.makedirs:
        # if os.makedirs fails with EEXIST, the directory was created
        # concurrently, and we can continue normally. Refs #16082.
        directory = os.path.dirname(full_path***REMOVED***
        if not os.path.exists(directory***REMOVED***:
            ***REMOVED***
                if self.directory_permissions_mode is not None:
                    # os.makedirs applies the global umask, so we reset it,
                    # for consistency with file_permissions_mode behavior.
                    old_umask = os.umask(0***REMOVED***
                    ***REMOVED***
                        os.makedirs(directory, self.directory_permissions_mode***REMOVED***
                    finally:
                        os.umask(old_umask***REMOVED***
                else:
                    os.makedirs(directory***REMOVED***
            except OSError as e:
                if e.errno != errno.EEXIST:
                    raise
        if not os.path.isdir(directory***REMOVED***:
            raise IOError("%s exists and is not a directory." % directory***REMOVED***

        # There's a potential race condition between get_available_name and
        # saving the file; it's possible that two threads might return the
        # same name, at which point all sorts of fun happens. So we need to
        # try to create the file, but if it already exists we have to go back
        # to get_available_name(***REMOVED*** and try again.

        while True:
            ***REMOVED***
                # This file has a file path that we can move.
                if hasattr(content, 'temporary_file_path'***REMOVED***:
                    file_move_safe(content.temporary_file_path(***REMOVED***, full_path***REMOVED***

                # This is a normal uploadedfile that we can stream.
                else:
                    # This fun binary flag incantation makes os.open throw an
                    # OSError if the file already exists before we open it.
                    flags = (os.O_WRONLY | os.O_CREAT | os.O_EXCL |
                             getattr(os, 'O_BINARY', 0***REMOVED******REMOVED***
                    # The current umask value is masked out by os.open!
                    fd = os.open(full_path, flags, 0o666***REMOVED***
                    _file = None
                    ***REMOVED***
                        locks.lock(fd, locks.LOCK_EX***REMOVED***
                        for chunk in content.chunks(***REMOVED***:
                            if _file is None:
                                mode = 'wb' if isinstance(chunk, bytes***REMOVED*** else 'wt'
                                _file = os.fdopen(fd, mode***REMOVED***
                            _file.write(chunk***REMOVED***
                    finally:
                        locks.unlock(fd***REMOVED***
                        if _file is not None:
                            _file.close(***REMOVED***
                        else:
                            os.close(fd***REMOVED***
            except OSError as e:
                if e.errno == errno.EEXIST:
                    # Ooops, the file exists. We need a new file name.
                    name = self.get_available_name(name***REMOVED***
                    full_path = self.path(name***REMOVED***
                else:
                    raise
            else:
                # OK, the file save worked. Break out of the loop.
                break

        if self.file_permissions_mode is not None:
            os.chmod(full_path, self.file_permissions_mode***REMOVED***

        # Store filenames with forward slashes, even on Windows.
        return force_text(name.replace('\\', '/'***REMOVED******REMOVED***

    def delete(self, name***REMOVED***:
        assert name, "The name argument is not allowed to be empty."
        name = self.path(name***REMOVED***
        # If the file exists, delete it from the filesystem.
        # Note that there is a race between os.path.exists and os.remove:
        # if os.remove fails with ENOENT, the file was removed
        # concurrently, and we can continue normally.
        if os.path.exists(name***REMOVED***:
            ***REMOVED***
                os.remove(name***REMOVED***
            except OSError as e:
                if e.errno != errno.ENOENT:
                    raise

    def exists(self, name***REMOVED***:
        return os.path.exists(self.path(name***REMOVED******REMOVED***

    def listdir(self, path***REMOVED***:
        path = self.path(path***REMOVED***
        directories, files = [***REMOVED***, [***REMOVED***
        for entry in os.listdir(path***REMOVED***:
            if os.path.isdir(os.path.join(path, entry***REMOVED******REMOVED***:
                directories.append(entry***REMOVED***
            else:
                files.append(entry***REMOVED***
        return directories, files

    def path(self, name***REMOVED***:
        return safe_join(self.location, name***REMOVED***

    def size(self, name***REMOVED***:
        return os.path.getsize(self.path(name***REMOVED******REMOVED***

    def url(self, name***REMOVED***:
        if self.base_url is None:
            raise ValueError("This file is not accessible via a URL."***REMOVED***
        url = filepath_to_uri(name***REMOVED***
        if url is not None:
            url = url.lstrip('/'***REMOVED***
        return urljoin(self.base_url, url***REMOVED***

    def accessed_time(self, name***REMOVED***:
        warnings.warn(
            'FileSystemStorage.accessed_time(***REMOVED*** is deprecated in favor of '
            'get_accessed_time(***REMOVED***.',
            RemovedInDjango20Warning,
            stacklevel=2,
        ***REMOVED***
        return datetime.fromtimestamp(os.path.getatime(self.path(name***REMOVED******REMOVED******REMOVED***

    def created_time(self, name***REMOVED***:
        warnings.warn(
            'FileSystemStorage.created_time(***REMOVED*** is deprecated in favor of '
            'get_created_time(***REMOVED***.',
            RemovedInDjango20Warning,
            stacklevel=2,
        ***REMOVED***
        return datetime.fromtimestamp(os.path.getctime(self.path(name***REMOVED******REMOVED******REMOVED***

    def modified_time(self, name***REMOVED***:
        warnings.warn(
            'FileSystemStorage.modified_time(***REMOVED*** is deprecated in favor of '
            'get_modified_time(***REMOVED***.',
            RemovedInDjango20Warning,
            stacklevel=2,
        ***REMOVED***
        return datetime.fromtimestamp(os.path.getmtime(self.path(name***REMOVED******REMOVED******REMOVED***

    def _datetime_from_timestamp(self, ts***REMOVED***:
        ***REMOVED***
        If timezone support is enabled, make an aware datetime object in UTC;
        otherwise make a naive one in the local timezone.
        ***REMOVED***
        if settings.USE_TZ:
            # Safe to use .replace(***REMOVED*** because UTC doesn't have DST
            return datetime.utcfromtimestamp(ts***REMOVED***.replace(tzinfo=timezone.utc***REMOVED***
        else:
            return datetime.fromtimestamp(ts***REMOVED***

    def get_accessed_time(self, name***REMOVED***:
        return self._datetime_from_timestamp(os.path.getatime(self.path(name***REMOVED******REMOVED******REMOVED***

    def get_created_time(self, name***REMOVED***:
        return self._datetime_from_timestamp(os.path.getctime(self.path(name***REMOVED******REMOVED******REMOVED***

    def get_modified_time(self, name***REMOVED***:
        return self._datetime_from_timestamp(os.path.getmtime(self.path(name***REMOVED******REMOVED******REMOVED***


def get_storage_class(import_path=None***REMOVED***:
    return import_string(import_path or settings.DEFAULT_FILE_STORAGE***REMOVED***


class DefaultStorage(LazyObject***REMOVED***:
    def _setup(self***REMOVED***:
        self._wrapped = get_storage_class(***REMOVED***(***REMOVED***

default_storage = DefaultStorage(***REMOVED***
