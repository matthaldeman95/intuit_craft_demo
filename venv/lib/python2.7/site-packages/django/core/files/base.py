from __future__ import unicode_literals

***REMOVED***
from io import BytesIO, StringIO, UnsupportedOperation

from django.core.files.utils import FileProxyMixin
from django.utils import six
from django.utils.encoding import (
    force_bytes, force_str, python_2_unicode_compatible, smart_text,
***REMOVED***


@python_2_unicode_compatible
class File(FileProxyMixin***REMOVED***:
    DEFAULT_CHUNK_SIZE = 64 * 2 ** 10

    def __init__(self, file, name=None***REMOVED***:
        self.file = file
        if name is None:
            name = getattr(file, 'name', None***REMOVED***
        self.name = name
        if hasattr(file, 'mode'***REMOVED***:
            self.mode = file.mode

    def __str__(self***REMOVED***:
        return smart_text(self.name or ''***REMOVED***

    def __repr__(self***REMOVED***:
        return force_str("<%s: %s>" % (self.__class__.__name__, self or "None"***REMOVED******REMOVED***

    def __bool__(self***REMOVED***:
        return bool(self.name***REMOVED***

    def __nonzero__(self***REMOVED***:      # Python 2 compatibility
        return type(self***REMOVED***.__bool__(self***REMOVED***

    def __len__(self***REMOVED***:
        return self.size

    def _get_size_from_underlying_file(self***REMOVED***:
        if hasattr(self.file, 'size'***REMOVED***:
            return self.file.size
        if hasattr(self.file, 'name'***REMOVED***:
            ***REMOVED***
                return os.path.getsize(self.file.name***REMOVED***
            except (OSError, TypeError***REMOVED***:
                pass
        if hasattr(self.file, 'tell'***REMOVED*** and hasattr(self.file, 'seek'***REMOVED***:
            pos = self.file.tell(***REMOVED***
            self.file.seek(0, os.SEEK_END***REMOVED***
            size = self.file.tell(***REMOVED***
            self.file.seek(pos***REMOVED***
            return size
        raise AttributeError("Unable to determine the file's size."***REMOVED***

    def _get_size(self***REMOVED***:
        if hasattr(self, '_size'***REMOVED***:
            return self._size
        self._size = self._get_size_from_underlying_file(***REMOVED***
        return self._size

    def _set_size(self, size***REMOVED***:
        self._size = size

    size = property(_get_size, _set_size***REMOVED***

    def _get_closed(self***REMOVED***:
        return not self.file or self.file.closed
    closed = property(_get_closed***REMOVED***

    def chunks(self, chunk_size=None***REMOVED***:
        ***REMOVED***
        Read the file and yield chunks of ``chunk_size`` bytes (defaults to
        ``UploadedFile.DEFAULT_CHUNK_SIZE``***REMOVED***.
        ***REMOVED***
        if not chunk_size:
            chunk_size = self.DEFAULT_CHUNK_SIZE

        ***REMOVED***
            self.seek(0***REMOVED***
        except (AttributeError, UnsupportedOperation***REMOVED***:
            pass

        while True:
            data = self.read(chunk_size***REMOVED***
            if not data:
                break
            yield data

    def multiple_chunks(self, chunk_size=None***REMOVED***:
        ***REMOVED***
        Returns ``True`` if you can expect multiple chunks.

        NB: If a particular file representation is in memory, subclasses should
        always return ``False`` -- there's no good reason to read from memory in
        chunks.
        ***REMOVED***
        if not chunk_size:
            chunk_size = self.DEFAULT_CHUNK_SIZE
        return self.size > chunk_size

    def __iter__(self***REMOVED***:
        # Iterate over this file-like object by newlines
        buffer_ = None
        for chunk in self.chunks(***REMOVED***:
            for line in chunk.splitlines(True***REMOVED***:
                if buffer_:
                    if endswith_cr(buffer_***REMOVED*** and not equals_lf(line***REMOVED***:
                        # Line split after a \r newline; yield buffer_.
                        yield buffer_
                        # Continue with line.
                    else:
                        # Line either split without a newline (line
                        # continues after buffer_***REMOVED*** or with \r\n
                        # newline (line == b'\n'***REMOVED***.
                        line = buffer_ + line
                    # buffer_ handled, clear it.
                    buffer_ = None

                # If this is the end of a \n or \r\n line, yield.
                if endswith_lf(line***REMOVED***:
                    yield line
                else:
                    buffer_ = line

        if buffer_ is not None:
            yield buffer_

    def __enter__(self***REMOVED***:
        return self

    def __exit__(self, exc_type, exc_value, tb***REMOVED***:
        self.close(***REMOVED***

    def open(self, mode=None***REMOVED***:
        if not self.closed:
            self.seek(0***REMOVED***
        elif self.name and os.path.exists(self.name***REMOVED***:
            self.file = open(self.name, mode or self.mode***REMOVED***
        else:
            raise ValueError("The file cannot be reopened."***REMOVED***

    def close(self***REMOVED***:
        self.file.close(***REMOVED***


@python_2_unicode_compatible
class ContentFile(File***REMOVED***:
    ***REMOVED***
    A File-like object that takes just raw content, rather than an actual file.
    ***REMOVED***
    def __init__(self, content, name=None***REMOVED***:
        if six.PY3:
            stream_class = StringIO if isinstance(content, six.text_type***REMOVED*** else BytesIO
        else:
            stream_class = BytesIO
            content = force_bytes(content***REMOVED***
        super(ContentFile, self***REMOVED***.__init__(stream_class(content***REMOVED***, name=name***REMOVED***
        self.size = len(content***REMOVED***

    def __str__(self***REMOVED***:
        return 'Raw content'

    def __bool__(self***REMOVED***:
        return True

    def __nonzero__(self***REMOVED***:      # Python 2 compatibility
        return type(self***REMOVED***.__bool__(self***REMOVED***

    def open(self, mode=None***REMOVED***:
        self.seek(0***REMOVED***

    def close(self***REMOVED***:
        pass


def endswith_cr(line***REMOVED***:
    ***REMOVED***
    Return True if line (a text or byte string***REMOVED*** ends with '\r'.
    ***REMOVED***
    return line.endswith('\r' if isinstance(line, six.text_type***REMOVED*** else b'\r'***REMOVED***


def endswith_lf(line***REMOVED***:
    ***REMOVED***
    Return True if line (a text or byte string***REMOVED*** ends with '\n'.
    ***REMOVED***
    return line.endswith('\n' if isinstance(line, six.text_type***REMOVED*** else b'\n'***REMOVED***


def equals_lf(line***REMOVED***:
    ***REMOVED***
    Return True if line (a text or byte string***REMOVED*** equals '\n'.
    ***REMOVED***
    return line == ('\n' if isinstance(line, six.text_type***REMOVED*** else b'\n'***REMOVED***
