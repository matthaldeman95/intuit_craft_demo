import cgi
import errno
import mimetypes
***REMOVED***
import posixpath
import re
import shutil
import stat
import sys
import tempfile
from os import path

import django
from django.core.management.base import BaseCommand, CommandError
from django.core.management.utils import handle_extensions
from django.template import Context, Engine
from django.utils import archive, six
from django.utils.six.moves.urllib.request import urlretrieve
from django.utils.version import get_docs_version

_drive_re = re.compile('^([a-z***REMOVED******REMOVED***:', re.I***REMOVED***
_url_drive_re = re.compile('^([a-z***REMOVED******REMOVED***[:|***REMOVED***', re.I***REMOVED***


class TemplateCommand(BaseCommand***REMOVED***:
    ***REMOVED***
    Copies either a Django application layout template or a Django project
    layout template into the specified directory.

    :param style: A color style object (see django.core.management.color***REMOVED***.
    :param app_or_project: The string 'app' or 'project'.
    :param name: The name of the application or project.
    :param directory: The directory to which the template should be copied.
    :param options: The additional variables passed to project or app templates
    ***REMOVED***
    requires_system_checks = False
    # Can't import settings during this command, because they haven't
    # necessarily been created.
    can_import_settings = False
    # The supported URL schemes
    url_schemes = ['http', 'https', 'ftp'***REMOVED***
    # Can't perform any active locale changes during this command, because
    # setting might not be available at all.
    leave_locale_alone = True
    # Rewrite the following suffixes when determining the target filename.
    rewrite_template_suffixes = (
        # Allow shipping invalid .py files without byte-compilation.
        ('.py-tpl', '.py'***REMOVED***,
    ***REMOVED***

    def add_arguments(self, parser***REMOVED***:
        parser.add_argument('name', help='Name of the application or project.'***REMOVED***
        parser.add_argument('directory', nargs='?', help='Optional destination directory'***REMOVED***
        parser.add_argument('--template', help='The path or URL to load the template from.'***REMOVED***
        parser.add_argument(
            '--extension', '-e', dest='extensions',
            action='append', default=['py'***REMOVED***,
            help='The file extension(s***REMOVED*** to render (default: "py"***REMOVED***. '
                 'Separate multiple extensions with commas, or use '
                 '-e multiple times.'
        ***REMOVED***
        parser.add_argument(
            '--name', '-n', dest='files',
            action='append', default=[***REMOVED***,
            help='The file name(s***REMOVED*** to render. Separate multiple extensions '
                 'with commas, or use -n multiple times.'
        ***REMOVED***

    def handle(self, app_or_project, name, target=None, **options***REMOVED***:
        self.app_or_project = app_or_project
        self.paths_to_remove = [***REMOVED***
        self.verbosity = options['verbosity'***REMOVED***

        self.validate_name(name, app_or_project***REMOVED***

        # if some directory is given, make sure it's nicely expanded
        if target is None:
            top_dir = path.join(os.getcwd(***REMOVED***, name***REMOVED***
            ***REMOVED***
                os.makedirs(top_dir***REMOVED***
            except OSError as e:
                if e.errno == errno.EEXIST:
                    message = "'%s' already exists" % top_dir
                else:
                    message = e
                raise CommandError(message***REMOVED***
        else:
            top_dir = os.path.abspath(path.expanduser(target***REMOVED******REMOVED***
            if not os.path.exists(top_dir***REMOVED***:
                raise CommandError("Destination directory '%s' does not "
                                   "exist, please create it first." % top_dir***REMOVED***

        extensions = tuple(handle_extensions(options['extensions'***REMOVED******REMOVED******REMOVED***
        extra_files = [***REMOVED***
        for file in options['files'***REMOVED***:
            extra_files.extend(map(lambda x: x.strip(***REMOVED***, file.split(','***REMOVED******REMOVED******REMOVED***
        if self.verbosity >= 2:
            self.stdout.write("Rendering %s template files with "
                              "extensions: %s\n" %
                              (app_or_project, ', '.join(extensions***REMOVED******REMOVED******REMOVED***
            self.stdout.write("Rendering %s template files with "
                              "filenames: %s\n" %
                              (app_or_project, ', '.join(extra_files***REMOVED******REMOVED******REMOVED***

        base_name = '%s_name' % app_or_project
        base_subdir = '%s_template' % app_or_project
        base_directory = '%s_directory' % app_or_project
        camel_case_name = 'camel_case_%s_name' % app_or_project
        camel_case_value = ''.join(x for x in name.title(***REMOVED*** if x != '_'***REMOVED***

        context = Context(dict(options, **{
            base_name: name,
            base_directory: top_dir,
            camel_case_name: camel_case_value,
            'docs_version': get_docs_version(***REMOVED***,
            'django_version': django.__version__,
            'unicode_literals': '' if six.PY3 else 'from __future__ import unicode_literals\n\n',
    ***REMOVED******REMOVED***, autoescape=False***REMOVED***

        # Setup a stub settings environment for template rendering
        from django.conf import settings
        if not settings.configured:
            settings.configure(***REMOVED***

        template_dir = self.handle_template(options['template'***REMOVED***,
                                            base_subdir***REMOVED***
        prefix_length = len(template_dir***REMOVED*** + 1

        for root, dirs, files in os.walk(template_dir***REMOVED***:

            path_rest = root[prefix_length:***REMOVED***
            relative_dir = path_rest.replace(base_name, name***REMOVED***
            if relative_dir:
                target_dir = path.join(top_dir, relative_dir***REMOVED***
                if not path.exists(target_dir***REMOVED***:
                    os.mkdir(target_dir***REMOVED***

            for dirname in dirs[:***REMOVED***:
                if dirname.startswith('.'***REMOVED*** or dirname == '__pycache__':
                    dirs.remove(dirname***REMOVED***

            for filename in files:
                if filename.endswith(('.pyo', '.pyc', '.py.class'***REMOVED******REMOVED***:
                    # Ignore some files as they cause various breakages.
                    continue
                old_path = path.join(root, filename***REMOVED***
                new_path = path.join(top_dir, relative_dir,
                                     filename.replace(base_name, name***REMOVED******REMOVED***
                for old_suffix, new_suffix in self.rewrite_template_suffixes:
                    if new_path.endswith(old_suffix***REMOVED***:
                        new_path = new_path[:-len(old_suffix***REMOVED******REMOVED*** + new_suffix
                        break  # Only rewrite once

                if path.exists(new_path***REMOVED***:
                    raise CommandError("%s already exists, overlaying a "
                                       "project or app into an existing "
                                       "directory won't replace conflicting "
                                       "files" % new_path***REMOVED***

                # Only render the Python files, as we don't want to
                # accidentally render Django templates files
                with open(old_path, 'rb'***REMOVED*** as template_file:
                    content = template_file.read(***REMOVED***
                if new_path.endswith(extensions***REMOVED*** or filename in extra_files:
                    content = content.decode('utf-8'***REMOVED***
                    template = Engine(***REMOVED***.from_string(content***REMOVED***
                    content = template.render(context***REMOVED***
                    content = content.encode('utf-8'***REMOVED***
                with open(new_path, 'wb'***REMOVED*** as new_file:
                    new_file.write(content***REMOVED***

                if self.verbosity >= 2:
                    self.stdout.write("Creating %s\n" % new_path***REMOVED***
                ***REMOVED***
                    shutil.copymode(old_path, new_path***REMOVED***
                    self.make_writeable(new_path***REMOVED***
                except OSError:
                    self.stderr.write(
                        "Notice: Couldn't set permission bits on %s. You're "
                        "probably using an uncommon filesystem setup. No "
                        "problem." % new_path, self.style.NOTICE***REMOVED***

        if self.paths_to_remove:
            if self.verbosity >= 2:
                self.stdout.write("Cleaning up temporary files.\n"***REMOVED***
            for path_to_remove in self.paths_to_remove:
                if path.isfile(path_to_remove***REMOVED***:
                    os.remove(path_to_remove***REMOVED***
                else:
                    shutil.rmtree(path_to_remove***REMOVED***

    def handle_template(self, template, subdir***REMOVED***:
        ***REMOVED***
        Determines where the app or project templates are.
        Use django.__path__[0***REMOVED*** as the default because we don't
        know into which directory Django has been installed.
        ***REMOVED***
        if template is None:
            return path.join(django.__path__[0***REMOVED***, 'conf', subdir***REMOVED***
        else:
            if template.startswith('file://'***REMOVED***:
                template = template[7:***REMOVED***
            expanded_template = path.expanduser(template***REMOVED***
            expanded_template = path.normpath(expanded_template***REMOVED***
            if path.isdir(expanded_template***REMOVED***:
                return expanded_template
            if self.is_url(template***REMOVED***:
                # downloads the file and returns the path
                absolute_path = self.download(template***REMOVED***
            else:
                absolute_path = path.abspath(expanded_template***REMOVED***
            if path.exists(absolute_path***REMOVED***:
                return self.extract(absolute_path***REMOVED***

        raise CommandError("couldn't handle %s template %s." %
                           (self.app_or_project, template***REMOVED******REMOVED***

    def validate_name(self, name, app_or_project***REMOVED***:
        if name is None:
            raise CommandError("you must provide %s %s name" % (
                "an" if app_or_project == "app" else "a", app_or_project***REMOVED******REMOVED***
        # If it's not a valid directory name.
        if six.PY2:
            if not re.search(r'^[_a-zA-Z***REMOVED***\w*$', name***REMOVED***:
                # Provide a smart error message, depending on the error.
                if not re.search(r'^[_a-zA-Z***REMOVED***', name***REMOVED***:
                    message = 'make sure the name begins with a letter or underscore'
                else:
                    message = 'use only numbers, letters and underscores'
                raise CommandError("%r is not a valid %s name. Please %s." %
                                   (name, app_or_project, message***REMOVED******REMOVED***
        else:
            if not name.isidentifier(***REMOVED***:
                raise CommandError(
                    "%r is not a valid %s name. Please make sure the name is "
                    "a valid identifier." % (name, app_or_project***REMOVED***
                ***REMOVED***

    def download(self, url***REMOVED***:
        ***REMOVED***
        Downloads the given URL and returns the file name.
        ***REMOVED***
        def cleanup_url(url***REMOVED***:
            tmp = url.rstrip('/'***REMOVED***
            filename = tmp.split('/'***REMOVED***[-1***REMOVED***
            if url.endswith('/'***REMOVED***:
                display_url = tmp + '/'
            else:
                display_url = url
            return filename, display_url

        prefix = 'django_%s_template_' % self.app_or_project
        tempdir = tempfile.mkdtemp(prefix=prefix, suffix='_download'***REMOVED***
        self.paths_to_remove.append(tempdir***REMOVED***
        filename, display_url = cleanup_url(url***REMOVED***

        if self.verbosity >= 2:
            self.stdout.write("Downloading %s\n" % display_url***REMOVED***
        ***REMOVED***
            the_path, info = urlretrieve(url, path.join(tempdir, filename***REMOVED******REMOVED***
        except IOError as e:
            raise CommandError("couldn't download URL %s to %s: %s" %
                               (url, filename, e***REMOVED******REMOVED***

        used_name = the_path.split('/'***REMOVED***[-1***REMOVED***

        # Trying to get better name from response headers
        content_disposition = info.get('content-disposition'***REMOVED***
        if content_disposition:
            _, params = cgi.parse_header(content_disposition***REMOVED***
            guessed_filename = params.get('filename'***REMOVED*** or used_name
        else:
            guessed_filename = used_name

        # Falling back to content type guessing
        ext = self.splitext(guessed_filename***REMOVED***[1***REMOVED***
        content_type = info.get('content-type'***REMOVED***
        if not ext and content_type:
            ext = mimetypes.guess_extension(content_type***REMOVED***
            if ext:
                guessed_filename += ext

        # Move the temporary file to a filename that has better
        # chances of being recognized by the archive utils
        if used_name != guessed_filename:
            guessed_path = path.join(tempdir, guessed_filename***REMOVED***
            shutil.move(the_path, guessed_path***REMOVED***
            return guessed_path

        # Giving up
        return the_path

    def splitext(self, the_path***REMOVED***:
        ***REMOVED***
        Like os.path.splitext, but takes off .tar, too
        ***REMOVED***
        base, ext = posixpath.splitext(the_path***REMOVED***
        if base.lower(***REMOVED***.endswith('.tar'***REMOVED***:
            ext = base[-4:***REMOVED*** + ext
            base = base[:-4***REMOVED***
        return base, ext

    def extract(self, filename***REMOVED***:
        ***REMOVED***
        Extracts the given file to a temporarily and returns
        the path of the directory with the extracted content.
        ***REMOVED***
        prefix = 'django_%s_template_' % self.app_or_project
        tempdir = tempfile.mkdtemp(prefix=prefix, suffix='_extract'***REMOVED***
        self.paths_to_remove.append(tempdir***REMOVED***
        if self.verbosity >= 2:
            self.stdout.write("Extracting %s\n" % filename***REMOVED***
        ***REMOVED***
            archive.extract(filename, tempdir***REMOVED***
            return tempdir
        except (archive.ArchiveException, IOError***REMOVED*** as e:
            raise CommandError("couldn't extract file %s to %s: %s" %
                               (filename, tempdir, e***REMOVED******REMOVED***

    def is_url(self, template***REMOVED***:
        ***REMOVED***
        Returns True if the name looks like a URL
        ***REMOVED***
        if ':' not in template:
            return False
        scheme = template.split(':', 1***REMOVED***[0***REMOVED***.lower(***REMOVED***
        return scheme in self.url_schemes

    def make_writeable(self, filename***REMOVED***:
        ***REMOVED***
        Make sure that the file is writeable.
        Useful if our source is read-only.
        ***REMOVED***
        if sys.platform.startswith('java'***REMOVED***:
            # On Jython there is no os.access(***REMOVED***
            return
        if not os.access(filename, os.W_OK***REMOVED***:
            st = os.stat(filename***REMOVED***
            new_permissions = stat.S_IMODE(st.st_mode***REMOVED*** | stat.S_IWUSR
            os.chmod(filename, new_permissions***REMOVED***
