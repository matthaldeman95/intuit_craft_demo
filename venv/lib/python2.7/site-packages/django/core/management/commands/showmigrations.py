# -*- coding: utf-8 -*-
from __future__ import unicode_literals

from django.core.management.base import BaseCommand, CommandError
from django.db import DEFAULT_DB_ALIAS, connections
from django.db.migrations.loader import MigrationLoader


class Command(BaseCommand***REMOVED***:
    help = "Shows all available migrations for the current project"

    def add_arguments(self, parser***REMOVED***:
        parser.add_argument(
            'app_label', nargs='*',
            help='App labels of applications to limit the output to.',
        ***REMOVED***
        parser.add_argument(
            '--database', action='store', dest='database', default=DEFAULT_DB_ALIAS,
            help='Nominates a database to synchronize. Defaults to the "default" database.',
        ***REMOVED***

        formats = parser.add_mutually_exclusive_group(***REMOVED***
        formats.add_argument(
            '--list', '-l', action='store_const', dest='format', const='list',
            help='Shows a list of all migrations and which are applied.',
        ***REMOVED***
        formats.add_argument(
            '--plan', '-p', action='store_const', dest='format', const='plan',
            help=(
                'Shows all migrations in the order they will be applied. '
                'With a verbosity level of 2 or above all direct migration dependencies '
                'and reverse dependencies (run_before***REMOVED*** will be included.'
            ***REMOVED***
        ***REMOVED***

        parser.set_defaults(format='list'***REMOVED***

    def handle(self, *args, **options***REMOVED***:
        self.verbosity = options['verbosity'***REMOVED***

        # Get the database we're operating from
        db = options['database'***REMOVED***
        connection = connections[db***REMOVED***

        if options['format'***REMOVED*** == "plan":
            return self.show_plan(connection***REMOVED***
        else:
            return self.show_list(connection, options['app_label'***REMOVED******REMOVED***

    def show_list(self, connection, app_names=None***REMOVED***:
        ***REMOVED***
        Shows a list of all migrations on the system, or only those of
        some named apps.
        ***REMOVED***
        # Load migrations from disk/DB
        loader = MigrationLoader(connection, ignore_no_migrations=True***REMOVED***
        graph = loader.graph
        # If we were passed a list of apps, validate it
        if app_names:
            invalid_apps = [***REMOVED***
            for app_name in app_names:
                if app_name not in loader.migrated_apps:
                    invalid_apps.append(app_name***REMOVED***
            if invalid_apps:
                raise CommandError("No migrations present for: %s" % (", ".join(invalid_apps***REMOVED******REMOVED******REMOVED***
        # Otherwise, show all apps in alphabetic order
        else:
            app_names = sorted(loader.migrated_apps***REMOVED***
        # For each app, print its migrations in order from oldest (roots***REMOVED*** to
        # newest (leaves***REMOVED***.
        for app_name in app_names:
            self.stdout.write(app_name, self.style.MIGRATE_LABEL***REMOVED***
            shown = set(***REMOVED***
            for node in graph.leaf_nodes(app_name***REMOVED***:
                for plan_node in graph.forwards_plan(node***REMOVED***:
                    if plan_node not in shown and plan_node[0***REMOVED*** == app_name:
                        # Give it a nice title if it's a squashed one
                        title = plan_node[1***REMOVED***
                        if graph.nodes[plan_node***REMOVED***.replaces:
                            title += " (%s squashed migrations***REMOVED***" % len(graph.nodes[plan_node***REMOVED***.replaces***REMOVED***
                        # Mark it as applied/unapplied
                        if plan_node in loader.applied_migrations:
                            self.stdout.write(" [X***REMOVED*** %s" % title***REMOVED***
                        else:
                            self.stdout.write(" [ ***REMOVED*** %s" % title***REMOVED***
                        shown.add(plan_node***REMOVED***
            # If we didn't print anything, then a small message
            if not shown:
                self.stdout.write(" (no migrations***REMOVED***", self.style.ERROR***REMOVED***

    def show_plan(self, connection***REMOVED***:
        ***REMOVED***
        Shows all known migrations in the order they will be applied
        ***REMOVED***
        # Load migrations from disk/DB
        loader = MigrationLoader(connection***REMOVED***
        graph = loader.graph
        targets = graph.leaf_nodes(***REMOVED***
        plan = [***REMOVED***
        seen = set(***REMOVED***

        # Generate the plan
        for target in targets:
            for migration in graph.forwards_plan(target***REMOVED***:
                if migration not in seen:
                    node = graph.node_map[migration***REMOVED***
                    plan.append(node***REMOVED***
                    seen.add(migration***REMOVED***

        # Output
        def print_deps(node***REMOVED***:
            out = [***REMOVED***
            for parent in sorted(node.parents***REMOVED***:
                out.append("%s.%s" % parent.key***REMOVED***
            if out:
                return " ... (%s***REMOVED***" % ", ".join(out***REMOVED***
            return ""

        for node in plan:
            deps = ""
            if self.verbosity >= 2:
                deps = print_deps(node***REMOVED***
            if node.key in loader.applied_migrations:
                self.stdout.write("[X***REMOVED***  %s.%s%s" % (node.key[0***REMOVED***, node.key[1***REMOVED***, deps***REMOVED******REMOVED***
            else:
                self.stdout.write("[ ***REMOVED***  %s.%s%s" % (node.key[0***REMOVED***, node.key[1***REMOVED***, deps***REMOVED******REMOVED***
