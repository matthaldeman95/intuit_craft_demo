from __future__ import unicode_literals

import codecs
import glob
***REMOVED***

from django.core.management.base import BaseCommand, CommandError
from django.core.management.utils import find_command, popen_wrapper
from django.utils._os import npath, upath


def has_bom(fn***REMOVED***:
    with open(fn, 'rb'***REMOVED*** as f:
        sample = f.read(4***REMOVED***
    return sample.startswith((codecs.BOM_UTF8, codecs.BOM_UTF16_LE, codecs.BOM_UTF16_BE***REMOVED******REMOVED***


def is_writable(path***REMOVED***:
    # Known side effect: updating file access/modified time to current time if
    # it is writable.
    ***REMOVED***
        with open(path, 'a'***REMOVED***:
            os.utime(path, None***REMOVED***
    except (IOError, OSError***REMOVED***:
        return False
    return True


class Command(BaseCommand***REMOVED***:
    help = 'Compiles .po files to .mo files for use with builtin gettext support.'

    requires_system_checks = False
    leave_locale_alone = True

    program = 'msgfmt'
    program_options = ['--check-format'***REMOVED***

    def add_arguments(self, parser***REMOVED***:
        parser.add_argument(
            '--locale', '-l', dest='locale', action='append', default=[***REMOVED***,
            help='Locale(s***REMOVED*** to process (e.g. de_AT***REMOVED***. Default is to process all. '
                 'Can be used multiple times.',
        ***REMOVED***
        parser.add_argument(
            '--exclude', '-x', dest='exclude', action='append', default=[***REMOVED***,
            help='Locales to exclude. Default is none. Can be used multiple times.',
        ***REMOVED***
        parser.add_argument(
            '--use-fuzzy', '-f', dest='fuzzy', action='store_true', default=False,
            help='Use fuzzy translations.',
        ***REMOVED***

    def handle(self, **options***REMOVED***:
        locale = options['locale'***REMOVED***
        exclude = options['exclude'***REMOVED***
        self.verbosity = options['verbosity'***REMOVED***
        if options['fuzzy'***REMOVED***:
            self.program_options = self.program_options + ['-f'***REMOVED***

        if find_command(self.program***REMOVED*** is None:
            raise CommandError("Can't find %s. Make sure you have GNU gettext "
                               "tools 0.15 or newer installed." % self.program***REMOVED***

        basedirs = [os.path.join('conf', 'locale'***REMOVED***, 'locale'***REMOVED***
        if os.environ.get('DJANGO_SETTINGS_MODULE'***REMOVED***:
            from django.conf import settings
            basedirs.extend(upath(path***REMOVED*** for path in settings.LOCALE_PATHS***REMOVED***

        # Walk entire tree, looking for locale directories
        for dirpath, dirnames, filenames in os.walk('.', topdown=True***REMOVED***:
            for dirname in dirnames:
                if dirname == 'locale':
                    basedirs.append(os.path.join(dirpath, dirname***REMOVED******REMOVED***

        # Gather existing directories.
        basedirs = set(map(os.path.abspath, filter(os.path.isdir, basedirs***REMOVED******REMOVED******REMOVED***

        if not basedirs:
            raise CommandError("This script should be run from the Django Git "
                               "checkout or your project or app tree, or with "
                               "the settings module specified."***REMOVED***

        # Build locale list
        all_locales = [***REMOVED***
        for basedir in basedirs:
            locale_dirs = filter(os.path.isdir, glob.glob('%s/*' % basedir***REMOVED******REMOVED***
            all_locales.extend(map(os.path.basename, locale_dirs***REMOVED******REMOVED***

        # Account for excluded locales
        locales = locale or all_locales
        locales = set(locales***REMOVED*** - set(exclude***REMOVED***

        for basedir in basedirs:
            if locales:
                dirs = [os.path.join(basedir, l, 'LC_MESSAGES'***REMOVED*** for l in locales***REMOVED***
            else:
                dirs = [basedir***REMOVED***
            locations = [***REMOVED***
            for ldir in dirs:
                for dirpath, dirnames, filenames in os.walk(ldir***REMOVED***:
                    locations.extend((dirpath, f***REMOVED*** for f in filenames if f.endswith('.po'***REMOVED******REMOVED***
            if locations:
                self.compile_messages(locations***REMOVED***

    def compile_messages(self, locations***REMOVED***:
        ***REMOVED***
        Locations is a list of tuples: [(directory, file***REMOVED***, ...***REMOVED***
        ***REMOVED***
        for i, (dirpath, f***REMOVED*** in enumerate(locations***REMOVED***:
            if self.verbosity > 0:
                self.stdout.write('processing file %s in %s\n' % (f, dirpath***REMOVED******REMOVED***
            po_path = os.path.join(dirpath, f***REMOVED***
            if has_bom(po_path***REMOVED***:
                raise CommandError("The %s file has a BOM (Byte Order Mark***REMOVED***. "
                                   "Django only supports .po files encoded in "
                                   "UTF-8 and without any BOM." % po_path***REMOVED***
            base_path = os.path.splitext(po_path***REMOVED***[0***REMOVED***

            # Check writability on first location
            if i == 0 and not is_writable(npath(base_path + '.mo'***REMOVED******REMOVED***:
                self.stderr.write("The po files under %s are in a seemingly not writable location. "
                                  "mo files will not be updated/created." % dirpath***REMOVED***
                return

            args = [self.program***REMOVED*** + self.program_options + [
                '-o', npath(base_path + '.mo'***REMOVED***, npath(base_path + '.po'***REMOVED***
            ***REMOVED***
            output, errors, status = popen_wrapper(args***REMOVED***
            if status:
                if errors:
                    msg = "Execution of %s failed: %s" % (self.program, errors***REMOVED***
                else:
                    msg = "Execution of %s failed" % self.program
                raise CommandError(msg***REMOVED***
