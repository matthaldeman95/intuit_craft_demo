# -*- coding: utf-8 -*-
from __future__ import unicode_literals

import time
from collections import OrderedDict
from importlib import import_module

from django.apps import apps
from django.core.checks import Tags, run_checks
from django.core.management.base import BaseCommand, CommandError
from django.core.management.sql import (
    emit_post_migrate_signal, emit_pre_migrate_signal,
***REMOVED***
from django.db import DEFAULT_DB_ALIAS, connections, router, transaction
from django.db.migrations.autodetector import MigrationAutodetector
from django.db.migrations.executor import MigrationExecutor
from django.db.migrations.loader import AmbiguityError
from django.db.migrations.state import ModelState, ProjectState
from django.utils.module_loading import module_has_submodule


class Command(BaseCommand***REMOVED***:
    help = "Updates database schema. Manages both apps with migrations and those without."

    def add_arguments(self, parser***REMOVED***:
        parser.add_argument(
            'app_label', nargs='?',
            help='App label of an application to synchronize the state.',
        ***REMOVED***
        parser.add_argument(
            'migration_name', nargs='?',
            help='Database state will be brought to the state after that '
                 'migration. Use the name "zero" to unapply all migrations.',
        ***REMOVED***
        parser.add_argument(
            '--noinput', '--no-input',
            action='store_false', dest='interactive', default=True,
            help='Tells Django to NOT prompt the user for input of any kind.',
        ***REMOVED***
        parser.add_argument(
            '--database', action='store', dest='database',
            default=DEFAULT_DB_ALIAS,
            help='Nominates a database to synchronize. Defaults to the "default" database.',
        ***REMOVED***
        parser.add_argument(
            '--fake', action='store_true', dest='fake', default=False,
            help='Mark migrations as run without actually running them.',
        ***REMOVED***
        parser.add_argument(
            '--fake-initial', action='store_true', dest='fake_initial', default=False,
            help='Detect if tables already exist and fake-apply initial migrations if so. Make sure '
                 'that the current database schema matches your initial migration before using this '
                 'flag. Django will only check for an existing table name.',
        ***REMOVED***
        parser.add_argument(
            '--run-syncdb', action='store_true', dest='run_syncdb',
            help='Creates tables for apps without migrations.',
        ***REMOVED***

    def _run_checks(self, **kwargs***REMOVED***:
        issues = run_checks(tags=[Tags.database***REMOVED******REMOVED***
        issues.extend(super(Command, self***REMOVED***._run_checks(**kwargs***REMOVED******REMOVED***
        return issues

    def handle(self, *args, **options***REMOVED***:

        self.verbosity = options['verbosity'***REMOVED***
        self.interactive = options['interactive'***REMOVED***

        # Import the 'management' module within each installed app, to register
        # dispatcher events.
        for app_config in apps.get_app_configs(***REMOVED***:
            if module_has_submodule(app_config.module, "management"***REMOVED***:
                import_module('.management', app_config.name***REMOVED***

        # Get the database we're operating from
        db = options['database'***REMOVED***
        connection = connections[db***REMOVED***

        # Hook for backends needing any database preparation
        connection.prepare_database(***REMOVED***
        # Work out which apps have migrations and which do not
        executor = MigrationExecutor(connection, self.migration_progress_callback***REMOVED***

        # Raise an error if any migrations are applied before their dependencies.
        executor.loader.check_consistent_history(connection***REMOVED***

        # Before anything else, see if there's conflicting apps and drop out
        # hard if there are any
        conflicts = executor.loader.detect_conflicts(***REMOVED***
        if conflicts:
            name_str = "; ".join(
                "%s in %s" % (", ".join(names***REMOVED***, app***REMOVED***
                for app, names in conflicts.items(***REMOVED***
            ***REMOVED***
            raise CommandError(
                "Conflicting migrations detected; multiple leaf nodes in the "
                "migration graph: (%s***REMOVED***.\nTo fix them run "
                "'python manage.py makemigrations --merge'" % name_str
            ***REMOVED***

        # If they supplied command line arguments, work out what they mean.
        target_app_labels_only = True
        if options['app_label'***REMOVED*** and options['migration_name'***REMOVED***:
            app_label, migration_name = options['app_label'***REMOVED***, options['migration_name'***REMOVED***
            if app_label not in executor.loader.migrated_apps:
                raise CommandError(
                    "App '%s' does not have migrations." % app_label
                ***REMOVED***
            if migration_name == "zero":
                targets = [(app_label, None***REMOVED******REMOVED***
            else:
                ***REMOVED***
                    migration = executor.loader.get_migration_by_prefix(app_label, migration_name***REMOVED***
                except AmbiguityError:
                    raise CommandError(
                        "More than one migration matches '%s' in app '%s'. "
                        "Please be more specific." %
                        (migration_name, app_label***REMOVED***
                    ***REMOVED***
                except KeyError:
                    raise CommandError("Cannot find a migration matching '%s' from app '%s'." % (
                        migration_name, app_label***REMOVED******REMOVED***
                targets = [(app_label, migration.name***REMOVED******REMOVED***
            target_app_labels_only = False
        elif options['app_label'***REMOVED***:
            app_label = options['app_label'***REMOVED***
            if app_label not in executor.loader.migrated_apps:
                raise CommandError(
                    "App '%s' does not have migrations." % app_label
                ***REMOVED***
            targets = [key for key in executor.loader.graph.leaf_nodes(***REMOVED*** if key[0***REMOVED*** == app_label***REMOVED***
        else:
            targets = executor.loader.graph.leaf_nodes(***REMOVED***

        plan = executor.migration_plan(targets***REMOVED***
        run_syncdb = options['run_syncdb'***REMOVED*** and executor.loader.unmigrated_apps

        # Print some useful info
        if self.verbosity >= 1:
            self.stdout.write(self.style.MIGRATE_HEADING("Operations to perform:"***REMOVED******REMOVED***
            if run_syncdb:
                self.stdout.write(
                    self.style.MIGRATE_LABEL("  Synchronize unmigrated apps: "***REMOVED*** +
                    (", ".join(sorted(executor.loader.unmigrated_apps***REMOVED******REMOVED******REMOVED***
                ***REMOVED***
            if target_app_labels_only:
                self.stdout.write(
                    self.style.MIGRATE_LABEL("  Apply all migrations: "***REMOVED*** +
                    (", ".join(sorted(set(a for a, n in targets***REMOVED******REMOVED******REMOVED*** or "(none***REMOVED***"***REMOVED***
                ***REMOVED***
            else:
                if targets[0***REMOVED***[1***REMOVED*** is None:
                    self.stdout.write(self.style.MIGRATE_LABEL(
                        "  Unapply all migrations: "***REMOVED*** + "%s" % (targets[0***REMOVED***[0***REMOVED***, ***REMOVED***
                    ***REMOVED***
                else:
                    self.stdout.write(self.style.MIGRATE_LABEL(
                        "  Target specific migration: "***REMOVED*** + "%s, from %s"
                        % (targets[0***REMOVED***[1***REMOVED***, targets[0***REMOVED***[0***REMOVED******REMOVED***
                    ***REMOVED***

        pre_migrate_state = executor._create_project_state(with_applied_migrations=True***REMOVED***
        pre_migrate_apps = pre_migrate_state.apps
        emit_pre_migrate_signal(
            self.verbosity, self.interactive, connection.alias, apps=pre_migrate_apps, plan=plan,
        ***REMOVED***

        # Run the syncdb phase.
        if run_syncdb:
            if self.verbosity >= 1:
                self.stdout.write(self.style.MIGRATE_HEADING("Synchronizing apps without migrations:"***REMOVED******REMOVED***
            self.sync_apps(connection, executor.loader.unmigrated_apps***REMOVED***

        # Migrate!
        if self.verbosity >= 1:
            self.stdout.write(self.style.MIGRATE_HEADING("Running migrations:"***REMOVED******REMOVED***
        if not plan:
            if self.verbosity >= 1:
                self.stdout.write("  No migrations to apply."***REMOVED***
                # If there's changes that aren't in migrations yet, tell them how to fix it.
                autodetector = MigrationAutodetector(
                    executor.loader.project_state(***REMOVED***,
                    ProjectState.from_apps(apps***REMOVED***,
                ***REMOVED***
                changes = autodetector.changes(graph=executor.loader.graph***REMOVED***
                if changes:
                    self.stdout.write(self.style.NOTICE(
                        "  Your models have changes that are not yet reflected "
                        "in a migration, and so won't be applied."
                    ***REMOVED******REMOVED***
                    self.stdout.write(self.style.NOTICE(
                        "  Run 'manage.py makemigrations' to make new "
                        "migrations, and then re-run 'manage.py migrate' to "
                        "apply them."
                    ***REMOVED******REMOVED***
            fake = False
            fake_initial = False
        else:
            fake = options['fake'***REMOVED***
            fake_initial = options['fake_initial'***REMOVED***
        post_migrate_state = executor.migrate(
            targets, plan=plan, state=pre_migrate_state.clone(***REMOVED***, fake=fake,
            fake_initial=fake_initial,
        ***REMOVED***
        post_migrate_apps = post_migrate_state.apps

        # Re-render models of real apps to include relationships now that
        # we've got a final state. This wouldn't be necessary if real apps
        # models were rendered with relationships in the first place.
        with post_migrate_apps.bulk_update(***REMOVED***:
            model_keys = [***REMOVED***
            for model_state in post_migrate_apps.real_models:
                model_key = model_state.app_label, model_state.name_lower
                model_keys.append(model_key***REMOVED***
                post_migrate_apps.unregister_model(*model_key***REMOVED***
        post_migrate_apps.render_multiple([
            ModelState.from_model(apps.get_model(*model***REMOVED******REMOVED*** for model in model_keys
        ***REMOVED******REMOVED***

        # Send the post_migrate signal, so individual apps can do whatever they need
        # to do at this point.
        emit_post_migrate_signal(
            self.verbosity, self.interactive, connection.alias, apps=post_migrate_apps, plan=plan,
        ***REMOVED***

    def migration_progress_callback(self, action, migration=None, fake=False***REMOVED***:
        if self.verbosity >= 1:
            compute_time = self.verbosity > 1
            if action == "apply_start":
                if compute_time:
                    self.start = time.time(***REMOVED***
                self.stdout.write("  Applying %s..." % migration, ending=""***REMOVED***
                self.stdout.flush(***REMOVED***
            elif action == "apply_success":
                elapsed = " (%.3fs***REMOVED***" % (time.time(***REMOVED*** - self.start***REMOVED*** if compute_time else ""
                if fake:
                    self.stdout.write(self.style.SUCCESS(" FAKED" + elapsed***REMOVED******REMOVED***
                else:
                    self.stdout.write(self.style.SUCCESS(" OK" + elapsed***REMOVED******REMOVED***
            elif action == "unapply_start":
                if compute_time:
                    self.start = time.time(***REMOVED***
                self.stdout.write("  Unapplying %s..." % migration, ending=""***REMOVED***
                self.stdout.flush(***REMOVED***
            elif action == "unapply_success":
                elapsed = " (%.3fs***REMOVED***" % (time.time(***REMOVED*** - self.start***REMOVED*** if compute_time else ""
                if fake:
                    self.stdout.write(self.style.SUCCESS(" FAKED" + elapsed***REMOVED******REMOVED***
                else:
                    self.stdout.write(self.style.SUCCESS(" OK" + elapsed***REMOVED******REMOVED***
            elif action == "render_start":
                if compute_time:
                    self.start = time.time(***REMOVED***
                self.stdout.write("  Rendering model states...", ending=""***REMOVED***
                self.stdout.flush(***REMOVED***
            elif action == "render_success":
                elapsed = " (%.3fs***REMOVED***" % (time.time(***REMOVED*** - self.start***REMOVED*** if compute_time else ""
                self.stdout.write(self.style.SUCCESS(" DONE" + elapsed***REMOVED******REMOVED***

    def sync_apps(self, connection, app_labels***REMOVED***:
        "Runs the old syncdb-style operation on a list of app_labels."
        cursor = connection.cursor(***REMOVED***

        ***REMOVED***
            # Get a list of already installed *models* so that references work right.
            tables = connection.introspection.table_names(cursor***REMOVED***
            created_models = set(***REMOVED***

            # Build the manifest of apps and models that are to be synchronized
            all_models = [
                (app_config.label,
                    router.get_migratable_models(app_config, connection.alias, include_auto_created=False***REMOVED******REMOVED***
                for app_config in apps.get_app_configs(***REMOVED***
                if app_config.models_module is not None and app_config.label in app_labels
            ***REMOVED***

            def model_installed(model***REMOVED***:
                opts = model._meta
                converter = connection.introspection.table_name_converter
                # Note that if a model is unmanaged we short-circuit and never try to install it
                return not (
                    (converter(opts.db_table***REMOVED*** in tables***REMOVED*** or
                    (opts.auto_created and converter(opts.auto_created._meta.db_table***REMOVED*** in tables***REMOVED***
                ***REMOVED***

            manifest = OrderedDict(
                (app_name, list(filter(model_installed, model_list***REMOVED******REMOVED******REMOVED***
                for app_name, model_list in all_models
            ***REMOVED***

            # Create the tables for each model
            if self.verbosity >= 1:
                self.stdout.write("  Creating tables...\n"***REMOVED***
            with transaction.atomic(using=connection.alias, savepoint=connection.features.can_rollback_ddl***REMOVED***:
                deferred_sql = [***REMOVED***
                for app_name, model_list in manifest.items(***REMOVED***:
                    for model in model_list:
                        if not model._meta.can_migrate(connection***REMOVED***:
                            continue
                        if self.verbosity >= 3:
                            self.stdout.write(
                                "    Processing %s.%s model\n" % (app_name, model._meta.object_name***REMOVED***
                            ***REMOVED***
                        with connection.schema_editor(***REMOVED*** as editor:
                            if self.verbosity >= 1:
                                self.stdout.write("    Creating table %s\n" % model._meta.db_table***REMOVED***
                            editor.create_model(model***REMOVED***
                            deferred_sql.extend(editor.deferred_sql***REMOVED***
                            editor.deferred_sql = [***REMOVED***
                        created_models.add(model***REMOVED***

                if self.verbosity >= 1:
                    self.stdout.write("    Running deferred SQL...\n"***REMOVED***
                for statement in deferred_sql:
                    cursor.execute(statement***REMOVED***
        finally:
            cursor.close(***REMOVED***

        return created_models
