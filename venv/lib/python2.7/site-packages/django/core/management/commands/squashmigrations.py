from django.conf import settings
from django.core.management.base import BaseCommand, CommandError
from django.db import DEFAULT_DB_ALIAS, connections, migrations
from django.db.migrations.loader import AmbiguityError, MigrationLoader
from django.db.migrations.migration import SwappableTuple
from django.db.migrations.optimizer import MigrationOptimizer
from django.db.migrations.writer import MigrationWriter
from django.utils import six
from django.utils.version import get_docs_version


class Command(BaseCommand***REMOVED***:
    help = "Squashes an existing set of migrations (from first until specified***REMOVED*** into a single new one."

    def add_arguments(self, parser***REMOVED***:
        parser.add_argument(
            'app_label',
            help='App label of the application to squash migrations for.',
        ***REMOVED***
        parser.add_argument(
            'start_migration_name', default=None, nargs='?',
            help='Migrations will be squashed starting from and including this migration.',
        ***REMOVED***
        parser.add_argument(
            'migration_name',
            help='Migrations will be squashed until and including this migration.',
        ***REMOVED***
        parser.add_argument(
            '--no-optimize', action='store_true', dest='no_optimize', default=False,
            help='Do not try to optimize the squashed operations.',
        ***REMOVED***
        parser.add_argument(
            '--noinput', '--no-input', action='store_false', dest='interactive', default=True,
            help='Tells Django to NOT prompt the user for input of any kind.',
        ***REMOVED***

    def handle(self, **options***REMOVED***:

        self.verbosity = options['verbosity'***REMOVED***
        self.interactive = options['interactive'***REMOVED***
        app_label = options['app_label'***REMOVED***
        start_migration_name = options['start_migration_name'***REMOVED***
        migration_name = options['migration_name'***REMOVED***
        no_optimize = options['no_optimize'***REMOVED***

        # Load the current graph state, check the app and migration they asked for exists
        loader = MigrationLoader(connections[DEFAULT_DB_ALIAS***REMOVED******REMOVED***
        if app_label not in loader.migrated_apps:
            raise CommandError(
                "App '%s' does not have migrations (so squashmigrations on "
                "it makes no sense***REMOVED***" % app_label
            ***REMOVED***

        migration = self.find_migration(loader, app_label, migration_name***REMOVED***

        # Work out the list of predecessor migrations
        migrations_to_squash = [
            loader.get_migration(al, mn***REMOVED***
            for al, mn in loader.graph.forwards_plan((migration.app_label, migration.name***REMOVED******REMOVED***
            if al == migration.app_label
        ***REMOVED***

        if start_migration_name:
            start_migration = self.find_migration(loader, app_label, start_migration_name***REMOVED***
            start = loader.get_migration(start_migration.app_label, start_migration.name***REMOVED***
            ***REMOVED***
                start_index = migrations_to_squash.index(start***REMOVED***
                migrations_to_squash = migrations_to_squash[start_index:***REMOVED***
            except ValueError:
                raise CommandError(
                    "The migration '%s' cannot be found. Maybe it comes after "
                    "the migration '%s'?\n"
                    "Have a look at:\n"
                    "  python manage.py showmigrations %s\n"
                    "to debug this issue." % (start_migration, migration, app_label***REMOVED***
                ***REMOVED***

        # Tell them what we're doing and optionally ask if we should proceed
        if self.verbosity > 0 or self.interactive:
            self.stdout.write(self.style.MIGRATE_HEADING("Will squash the following migrations:"***REMOVED******REMOVED***
            for migration in migrations_to_squash:
                self.stdout.write(" - %s" % migration.name***REMOVED***

            if self.interactive:
                answer = None
                while not answer or answer not in "yn":
                    answer = six.moves.input("Do you wish to proceed? [yN***REMOVED*** "***REMOVED***
                    if not answer:
                        answer = "n"
                        break
                    else:
                        answer = answer[0***REMOVED***.lower(***REMOVED***
                if answer != "y":
                    return

        # Load the operations from all those migrations and concat together,
        # along with collecting external dependencies and detecting
        # double-squashing
        operations = [***REMOVED***
        dependencies = set(***REMOVED***
        # We need to take all dependencies from the first migration in the list
        # as it may be 0002 depending on 0001
        first_migration = True
        for smigration in migrations_to_squash:
            if smigration.replaces:
                raise CommandError(
                    "You cannot squash squashed migrations! Please transition "
                    "it to a normal migration first: "
                    "https://docs.djangoproject.com/en/%s/topics/migrations/#squashing-migrations" % get_docs_version(***REMOVED***
                ***REMOVED***
            operations.extend(smigration.operations***REMOVED***
            for dependency in smigration.dependencies:
                if isinstance(dependency, SwappableTuple***REMOVED***:
                    if settings.AUTH_USER_MODEL == dependency.setting:
                        dependencies.add(("__setting__", "AUTH_USER_MODEL"***REMOVED******REMOVED***
                    else:
                        dependencies.add(dependency***REMOVED***
                elif dependency[0***REMOVED*** != smigration.app_label or first_migration:
                    dependencies.add(dependency***REMOVED***
            first_migration = False

        if no_optimize:
            if self.verbosity > 0:
                self.stdout.write(self.style.MIGRATE_HEADING("(Skipping optimization.***REMOVED***"***REMOVED******REMOVED***
            new_operations = operations
        else:
            if self.verbosity > 0:
                self.stdout.write(self.style.MIGRATE_HEADING("Optimizing..."***REMOVED******REMOVED***

            optimizer = MigrationOptimizer(***REMOVED***
            new_operations = optimizer.optimize(operations, migration.app_label***REMOVED***

            if self.verbosity > 0:
                if len(new_operations***REMOVED*** == len(operations***REMOVED***:
                    self.stdout.write("  No optimizations possible."***REMOVED***
                else:
                    self.stdout.write(
                        "  Optimized from %s operations to %s operations." %
                        (len(operations***REMOVED***, len(new_operations***REMOVED******REMOVED***
                    ***REMOVED***

        # Work out the value of replaces (any squashed ones we're re-squashing***REMOVED***
        # need to feed their replaces into ours
        replaces = [***REMOVED***
        for migration in migrations_to_squash:
            if migration.replaces:
                replaces.extend(migration.replaces***REMOVED***
            else:
                replaces.append((migration.app_label, migration.name***REMOVED******REMOVED***

        # Make a new migration with those operations
        subclass = type("Migration", (migrations.Migration, ***REMOVED***, {
            "dependencies": dependencies,
            "operations": new_operations,
            "replaces": replaces,
    ***REMOVED******REMOVED***
        if start_migration_name:
            new_migration = subclass("%s_squashed_%s" % (start_migration.name, migration.name***REMOVED***, app_label***REMOVED***
        else:
            new_migration = subclass("0001_squashed_%s" % migration.name, app_label***REMOVED***
            new_migration.initial = True

        # Write out the new migration file
        writer = MigrationWriter(new_migration***REMOVED***
        with open(writer.path, "wb"***REMOVED*** as fh:
            fh.write(writer.as_string(***REMOVED******REMOVED***

        if self.verbosity > 0:
            self.stdout.write(self.style.MIGRATE_HEADING("Created new squashed migration %s" % writer.path***REMOVED******REMOVED***
            self.stdout.write("  You should commit this migration but leave the old ones in place;"***REMOVED***
            self.stdout.write("  the new migration will be used for new installs. Once you are sure"***REMOVED***
            self.stdout.write("  all instances of the codebase have applied the migrations you squashed,"***REMOVED***
            self.stdout.write("  you can delete them."***REMOVED***
            if writer.needs_manual_porting:
                self.stdout.write(self.style.MIGRATE_HEADING("Manual porting required"***REMOVED******REMOVED***
                self.stdout.write("  Your migrations contained functions that must be manually copied over,"***REMOVED***
                self.stdout.write("  as we could not safely copy their implementation."***REMOVED***
                self.stdout.write("  See the comment at the top of the squashed migration for details."***REMOVED***

    def find_migration(self, loader, app_label, name***REMOVED***:
        ***REMOVED***
            return loader.get_migration_by_prefix(app_label, name***REMOVED***
        except AmbiguityError:
            raise CommandError(
                "More than one migration matches '%s' in app '%s'. Please be "
                "more specific." % (name, app_label***REMOVED***
            ***REMOVED***
        except KeyError:
            raise CommandError(
                "Cannot find a migration matching '%s' from app '%s'." %
                (name, app_label***REMOVED***
            ***REMOVED***
