***REMOVED***
import sys
import warnings
from itertools import takewhile

from django.apps import apps
from django.conf import settings
from django.core.management.base import BaseCommand, CommandError
from django.db import DEFAULT_DB_ALIAS, connections, router
from django.db.migrations import Migration
from django.db.migrations.autodetector import MigrationAutodetector
from django.db.migrations.loader import MigrationLoader
from django.db.migrations.questioner import (
    InteractiveMigrationQuestioner, MigrationQuestioner,
    NonInteractiveMigrationQuestioner,
***REMOVED***
from django.db.migrations.state import ProjectState
from django.db.migrations.utils import get_migration_name_timestamp
from django.db.migrations.writer import MigrationWriter
from django.utils.deprecation import RemovedInDjango20Warning
from django.utils.six import iteritems
from django.utils.six.moves import zip


class Command(BaseCommand***REMOVED***:
    help = "Creates new migration(s***REMOVED*** for apps."

    def add_arguments(self, parser***REMOVED***:
        parser.add_argument(
            'args', metavar='app_label', nargs='*',
            help='Specify the app label(s***REMOVED*** to create migrations for.',
        ***REMOVED***
        parser.add_argument(
            '--dry-run', action='store_true', dest='dry_run', default=False,
            help="Just show what migrations would be made; don't actually write them.",
        ***REMOVED***
        parser.add_argument(
            '--merge', action='store_true', dest='merge', default=False,
            help="Enable fixing of migration conflicts.",
        ***REMOVED***
        parser.add_argument(
            '--empty', action='store_true', dest='empty', default=False,
            help="Create an empty migration.",
        ***REMOVED***
        parser.add_argument(
            '--noinput', '--no-input',
            action='store_false', dest='interactive', default=True,
            help='Tells Django to NOT prompt the user for input of any kind.',
        ***REMOVED***
        parser.add_argument(
            '-n', '--name', action='store', dest='name', default=None,
            help="Use this name for migration file(s***REMOVED***.",
        ***REMOVED***
        parser.add_argument(
            '-e', '--exit', action='store_true', dest='exit_code', default=False,
            help='Exit with error code 1 if no changes needing migrations are found. '
                 'Deprecated, use the --check option instead.',
        ***REMOVED***
        parser.add_argument(
            '--check', action='store_true', dest='check_changes',
            help='Exit with a non-zero status if model changes are missing migrations.',
        ***REMOVED***

    def handle(self, *app_labels, **options***REMOVED***:
        self.verbosity = options['verbosity'***REMOVED***
        self.interactive = options['interactive'***REMOVED***
        self.dry_run = options['dry_run'***REMOVED***
        self.merge = options['merge'***REMOVED***
        self.empty = options['empty'***REMOVED***
        self.migration_name = options['name'***REMOVED***
        self.exit_code = options['exit_code'***REMOVED***
        check_changes = options['check_changes'***REMOVED***

        if self.exit_code:
            warnings.warn(
                "The --exit option is deprecated in favor of the --check option.",
                RemovedInDjango20Warning
            ***REMOVED***

        # Make sure the app they asked for exists
        app_labels = set(app_labels***REMOVED***
        bad_app_labels = set(***REMOVED***
        for app_label in app_labels:
            ***REMOVED***
                apps.get_app_config(app_label***REMOVED***
            except LookupError:
                bad_app_labels.add(app_label***REMOVED***
        if bad_app_labels:
            for app_label in bad_app_labels:
                self.stderr.write("App '%s' could not be found. Is it in INSTALLED_APPS?" % app_label***REMOVED***
            sys.exit(2***REMOVED***

        # Load the current graph state. Pass in None for the connection so
        # the loader doesn't try to resolve replaced migrations from DB.
        loader = MigrationLoader(None, ignore_no_migrations=True***REMOVED***

        # Raise an error if any migrations are applied before their dependencies.
        consistency_check_labels = set(config.label for config in apps.get_app_configs(***REMOVED******REMOVED***
        # Non-default databases are only checked if database routers used.
        aliases_to_check = connections if settings.DATABASE_ROUTERS else [DEFAULT_DB_ALIAS***REMOVED***
        for alias in sorted(aliases_to_check***REMOVED***:
            connection = connections[alias***REMOVED***
            if (connection.settings_dict['ENGINE'***REMOVED*** != 'django.db.backends.dummy' and
                    # At least one app must be migrated to the database.
                    any(router.allow_migrate(connection.alias, label***REMOVED*** for label in consistency_check_labels***REMOVED******REMOVED***:
                loader.check_consistent_history(connection***REMOVED***

        # Before anything else, see if there's conflicting apps and drop out
        # hard if there are any and they don't want to merge
        conflicts = loader.detect_conflicts(***REMOVED***

        # If app_labels is specified, filter out conflicting migrations for unspecified apps
        if app_labels:
            conflicts = {
                app_label: conflict for app_label, conflict in iteritems(conflicts***REMOVED***
                if app_label in app_labels
        ***REMOVED***

        if conflicts and not self.merge:
            name_str = "; ".join(
                "%s in %s" % (", ".join(names***REMOVED***, app***REMOVED***
                for app, names in conflicts.items(***REMOVED***
            ***REMOVED***
            raise CommandError(
                "Conflicting migrations detected; multiple leaf nodes in the "
                "migration graph: (%s***REMOVED***.\nTo fix them run "
                "'python manage.py makemigrations --merge'" % name_str
            ***REMOVED***

        # If they want to merge and there's nothing to merge, then politely exit
        if self.merge and not conflicts:
            self.stdout.write("No conflicts detected to merge."***REMOVED***
            return

        # If they want to merge and there is something to merge, then
        # divert into the merge code
        if self.merge and conflicts:
            return self.handle_merge(loader, conflicts***REMOVED***

        if self.interactive:
            questioner = InteractiveMigrationQuestioner(specified_apps=app_labels, dry_run=self.dry_run***REMOVED***
        else:
            questioner = NonInteractiveMigrationQuestioner(specified_apps=app_labels, dry_run=self.dry_run***REMOVED***
        # Set up autodetector
        autodetector = MigrationAutodetector(
            loader.project_state(***REMOVED***,
            ProjectState.from_apps(apps***REMOVED***,
            questioner,
        ***REMOVED***

        # If they want to make an empty migration, make one for each app
        if self.empty:
            if not app_labels:
                raise CommandError("You must supply at least one app label when using --empty."***REMOVED***
            # Make a fake changes(***REMOVED*** result we can pass to arrange_for_graph
            changes = {
                app: [Migration("custom", app***REMOVED******REMOVED***
                for app in app_labels
        ***REMOVED***
            changes = autodetector.arrange_for_graph(
                changes=changes,
                graph=loader.graph,
                migration_name=self.migration_name,
            ***REMOVED***
            self.write_migration_files(changes***REMOVED***
            return

        # Detect changes
        changes = autodetector.changes(
            graph=loader.graph,
            trim_to_apps=app_labels or None,
            convert_apps=app_labels or None,
            migration_name=self.migration_name,
        ***REMOVED***

        if not changes:
            # No changes? Tell them.
            if self.verbosity >= 1:
                if len(app_labels***REMOVED*** == 1:
                    self.stdout.write("No changes detected in app '%s'" % app_labels.pop(***REMOVED******REMOVED***
                elif len(app_labels***REMOVED*** > 1:
                    self.stdout.write("No changes detected in apps '%s'" % ("', '".join(app_labels***REMOVED******REMOVED******REMOVED***
                else:
                    self.stdout.write("No changes detected"***REMOVED***

            if self.exit_code:
                sys.exit(1***REMOVED***
        else:
            self.write_migration_files(changes***REMOVED***
            if check_changes:
                sys.exit(1***REMOVED***

    def write_migration_files(self, changes***REMOVED***:
        ***REMOVED***
        Takes a changes dict and writes them out as migration files.
        ***REMOVED***
        directory_created = {***REMOVED***
        for app_label, app_migrations in changes.items(***REMOVED***:
            if self.verbosity >= 1:
                self.stdout.write(self.style.MIGRATE_HEADING("Migrations for '%s':" % app_label***REMOVED*** + "\n"***REMOVED***
            for migration in app_migrations:
                # Describe the migration
                writer = MigrationWriter(migration***REMOVED***
                if self.verbosity >= 1:
                    # Display a relative path if it's below the current working
                    # directory, or an absolute path otherwise.
                    migration_string = os.path.relpath(writer.path***REMOVED***
                    if migration_string.startswith('..'***REMOVED***:
                        migration_string = writer.path
                    self.stdout.write("  %s:\n" % (self.style.MIGRATE_LABEL(migration_string***REMOVED***,***REMOVED******REMOVED***
                    for operation in migration.operations:
                        self.stdout.write("    - %s\n" % operation.describe(***REMOVED******REMOVED***
                if not self.dry_run:
                    # Write the migrations file to the disk.
                    migrations_directory = os.path.dirname(writer.path***REMOVED***
                    if not directory_created.get(app_label***REMOVED***:
                        if not os.path.isdir(migrations_directory***REMOVED***:
                            os.mkdir(migrations_directory***REMOVED***
                        init_path = os.path.join(migrations_directory, "__init__.py"***REMOVED***
                        if not os.path.isfile(init_path***REMOVED***:
                            open(init_path, "w"***REMOVED***.close(***REMOVED***
                        # We just do this once per app
                        directory_created[app_label***REMOVED*** = True
                    migration_string = writer.as_string(***REMOVED***
                    with open(writer.path, "wb"***REMOVED*** as fh:
                        fh.write(migration_string***REMOVED***
                elif self.verbosity == 3:
                    # Alternatively, makemigrations --dry-run --verbosity 3
                    # will output the migrations to stdout rather than saving
                    # the file to the disk.
                    self.stdout.write(self.style.MIGRATE_HEADING(
                        "Full migrations file '%s':" % writer.filename***REMOVED*** + "\n"
                    ***REMOVED***
                    self.stdout.write("%s\n" % writer.as_string(***REMOVED******REMOVED***

    def handle_merge(self, loader, conflicts***REMOVED***:
        ***REMOVED***
        Handles merging together conflicted migrations interactively,
        if it's safe; otherwise, advises on how to fix it.
        ***REMOVED***
        if self.interactive:
            questioner = InteractiveMigrationQuestioner(***REMOVED***
        else:
            questioner = MigrationQuestioner(defaults={'ask_merge': True***REMOVED******REMOVED***

        for app_label, migration_names in conflicts.items(***REMOVED***:
            # Grab out the migrations in question, and work out their
            # common ancestor.
            merge_migrations = [***REMOVED***
            for migration_name in migration_names:
                migration = loader.get_migration(app_label, migration_name***REMOVED***
                migration.ancestry = [
                    mig for mig in loader.graph.forwards_plan((app_label, migration_name***REMOVED******REMOVED***
                    if mig[0***REMOVED*** == migration.app_label
                ***REMOVED***
                merge_migrations.append(migration***REMOVED***

            def all_items_equal(seq***REMOVED***:
                return all(item == seq[0***REMOVED*** for item in seq[1:***REMOVED******REMOVED***

            merge_migrations_generations = zip(*[m.ancestry for m in merge_migrations***REMOVED******REMOVED***
            common_ancestor_count = sum(1 for common_ancestor_generation
                                        in takewhile(all_items_equal, merge_migrations_generations***REMOVED******REMOVED***
            if not common_ancestor_count:
                raise ValueError("Could not find common ancestor of %s" % migration_names***REMOVED***
            # Now work out the operations along each divergent branch
            for migration in merge_migrations:
                migration.branch = migration.ancestry[common_ancestor_count:***REMOVED***
                migrations_ops = (loader.get_migration(node_app, node_name***REMOVED***.operations
                                  for node_app, node_name in migration.branch***REMOVED***
                migration.merged_operations = sum(migrations_ops, [***REMOVED******REMOVED***
            # In future, this could use some of the Optimizer code
            # (can_optimize_through***REMOVED*** to automatically see if they're
            # mergeable. For now, we always just prompt the user.
            if self.verbosity > 0:
                self.stdout.write(self.style.MIGRATE_HEADING("Merging %s" % app_label***REMOVED******REMOVED***
                for migration in merge_migrations:
                    self.stdout.write(self.style.MIGRATE_LABEL("  Branch %s" % migration.name***REMOVED******REMOVED***
                    for operation in migration.merged_operations:
                        self.stdout.write("    - %s\n" % operation.describe(***REMOVED******REMOVED***
            if questioner.ask_merge(app_label***REMOVED***:
                # If they still want to merge it, then write out an empty
                # file depending on the migrations needing merging.
                numbers = [
                    MigrationAutodetector.parse_number(migration.name***REMOVED***
                    for migration in merge_migrations
                ***REMOVED***
                ***REMOVED***
                    biggest_number = max(x for x in numbers if x is not None***REMOVED***
                except ValueError:
                    biggest_number = 1
                subclass = type("Migration", (Migration, ***REMOVED***, {
                    "dependencies": [(app_label, migration.name***REMOVED*** for migration in merge_migrations***REMOVED***,
            ***REMOVED******REMOVED***
                migration_name = "%04i_%s" % (
                    biggest_number + 1,
                    self.migration_name or ("merge_%s" % get_migration_name_timestamp(***REMOVED******REMOVED***
                ***REMOVED***
                new_migration = subclass(migration_name, app_label***REMOVED***
                writer = MigrationWriter(new_migration***REMOVED***

                if not self.dry_run:
                    # Write the merge migrations file to the disk
                    with open(writer.path, "wb"***REMOVED*** as fh:
                        fh.write(writer.as_string(***REMOVED******REMOVED***
                    if self.verbosity > 0:
                        self.stdout.write("\nCreated new merge migration %s" % writer.path***REMOVED***
                elif self.verbosity == 3:
                    # Alternatively, makemigrations --merge --dry-run --verbosity 3
                    # will output the merge migrations to stdout rather than saving
                    # the file to the disk.
                    self.stdout.write(self.style.MIGRATE_HEADING(
                        "Full merge migrations file '%s':" % writer.filename***REMOVED*** + "\n"
                    ***REMOVED***
                    self.stdout.write("%s\n" % writer.as_string(***REMOVED******REMOVED***
