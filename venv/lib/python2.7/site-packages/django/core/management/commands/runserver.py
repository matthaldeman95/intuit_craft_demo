from __future__ import unicode_literals

import errno
***REMOVED***
import re
import socket
import sys
from datetime import datetime

from django.conf import settings
from django.core.management.base import BaseCommand, CommandError
from django.core.servers.basehttp import get_internal_wsgi_application, run
from django.utils import autoreload, six
from django.utils.encoding import force_text, get_system_encoding


naiveip_re = re.compile(r***REMOVED***^(?:
(?P<addr>
    (?P<ipv4>\d{1,3***REMOVED***(?:\.\d{1,3***REMOVED******REMOVED***{3***REMOVED******REMOVED*** |         # IPv4 address
    (?P<ipv6>\[[a-fA-F0-9:***REMOVED***+\***REMOVED******REMOVED*** |               # IPv6 address
    (?P<fqdn>[a-zA-Z0-9-***REMOVED***+(?:\.[a-zA-Z0-9-***REMOVED***+***REMOVED*******REMOVED*** # FQDN
***REMOVED***:***REMOVED***?(?P<port>\d+***REMOVED***$***REMOVED***, re.X***REMOVED***


class Command(BaseCommand***REMOVED***:
    help = "Starts a lightweight Web server for development."

    # Validation is called explicitly each time the server is reloaded.
    requires_system_checks = False
    leave_locale_alone = True

    default_port = '8000'

    def add_arguments(self, parser***REMOVED***:
        parser.add_argument(
            'addrport', nargs='?',
            help='Optional port number, or ipaddr:port'
        ***REMOVED***
        parser.add_argument(
            '--ipv6', '-6', action='store_true', dest='use_ipv6', default=False,
            help='Tells Django to use an IPv6 address.',
        ***REMOVED***
        parser.add_argument(
            '--nothreading', action='store_false', dest='use_threading', default=True,
            help='Tells Django to NOT use threading.',
        ***REMOVED***
        parser.add_argument(
            '--noreload', action='store_false', dest='use_reloader', default=True,
            help='Tells Django to NOT use the auto-reloader.',
        ***REMOVED***

    def execute(self, *args, **options***REMOVED***:
        if options['no_color'***REMOVED***:
            # We rely on the environment because it's currently the only
            # way to reach WSGIRequestHandler. This seems an acceptable
            # compromise considering `runserver` runs indefinitely.
            os.environ[str("DJANGO_COLORS"***REMOVED******REMOVED*** = str("nocolor"***REMOVED***
        super(Command, self***REMOVED***.execute(*args, **options***REMOVED***

    def get_handler(self, *args, **options***REMOVED***:
        ***REMOVED***
        Returns the default WSGI handler for the runner.
        ***REMOVED***
        return get_internal_wsgi_application(***REMOVED***

    def handle(self, *args, **options***REMOVED***:
        from django.conf import settings

        if not settings.DEBUG and not settings.ALLOWED_HOSTS:
            raise CommandError('You must set settings.ALLOWED_HOSTS if DEBUG is False.'***REMOVED***

        self.use_ipv6 = options['use_ipv6'***REMOVED***
        if self.use_ipv6 and not socket.has_ipv6:
            raise CommandError('Your Python does not support IPv6.'***REMOVED***
        self._raw_ipv6 = False
        if not options['addrport'***REMOVED***:
            self.addr = ''
            self.port = self.default_port
        else:
            m = re.match(naiveip_re, options['addrport'***REMOVED******REMOVED***
            if m is None:
                raise CommandError('"%s" is not a valid port number '
                                   'or address:port pair.' % options['addrport'***REMOVED******REMOVED***
            self.addr, _ipv4, _ipv6, _fqdn, self.port = m.groups(***REMOVED***
            if not self.port.isdigit(***REMOVED***:
                raise CommandError("%r is not a valid port number." % self.port***REMOVED***
            if self.addr:
                if _ipv6:
                    self.addr = self.addr[1:-1***REMOVED***
                    self.use_ipv6 = True
                    self._raw_ipv6 = True
                elif self.use_ipv6 and not _fqdn:
                    raise CommandError('"%s" is not a valid IPv6 address.' % self.addr***REMOVED***
        if not self.addr:
            self.addr = '::1' if self.use_ipv6 else '127.0.0.1'
            self._raw_ipv6 = self.use_ipv6
        self.run(**options***REMOVED***

    def run(self, **options***REMOVED***:
        ***REMOVED***
        Runs the server, using the autoreloader if needed
        ***REMOVED***
        use_reloader = options['use_reloader'***REMOVED***

        if use_reloader:
            autoreload.main(self.inner_run, None, options***REMOVED***
        else:
            self.inner_run(None, **options***REMOVED***

    def inner_run(self, *args, **options***REMOVED***:
        # If an exception was silenced in ManagementUtility.execute in order
        # to be raised in the child process, raise it now.
        autoreload.raise_last_exception(***REMOVED***

        threading = options['use_threading'***REMOVED***
        # 'shutdown_message' is a stealth option.
        shutdown_message = options.get('shutdown_message', ''***REMOVED***
        quit_command = 'CTRL-BREAK' if sys.platform == 'win32' else 'CONTROL-C'

        self.stdout.write("Performing system checks...\n\n"***REMOVED***
        self.check(display_num_errors=True***REMOVED***
        # Need to check migrations here, so can't use the
        # requires_migrations_check attribute.
        self.check_migrations(***REMOVED***
        now = datetime.now(***REMOVED***.strftime('%B %d, %Y - %X'***REMOVED***
        if six.PY2:
            now = now.decode(get_system_encoding(***REMOVED******REMOVED***
        self.stdout.write(now***REMOVED***
        self.stdout.write((
            "Django version %(version***REMOVED***s, using settings %(settings***REMOVED***r\n"
            "Starting development server at http://%(addr***REMOVED***s:%(port***REMOVED***s/\n"
            "Quit the server with %(quit_command***REMOVED***s.\n"
        ***REMOVED*** % {
            "version": self.get_version(***REMOVED***,
            "settings": settings.SETTINGS_MODULE,
            "addr": '[%s***REMOVED***' % self.addr if self._raw_ipv6 else self.addr,
            "port": self.port,
            "quit_command": quit_command,
    ***REMOVED******REMOVED***

        ***REMOVED***
            handler = self.get_handler(*args, **options***REMOVED***
            run(self.addr, int(self.port***REMOVED***, handler,
                ipv6=self.use_ipv6, threading=threading***REMOVED***
        except socket.error as e:
            # Use helpful error messages instead of ugly tracebacks.
            ERRORS = {
                errno.EACCES: "You don't have permission to access that port.",
                errno.EADDRINUSE: "That port is already in use.",
                errno.EADDRNOTAVAIL: "That IP address can't be assigned to.",
        ***REMOVED***
            ***REMOVED***
                error_text = ERRORS[e.errno***REMOVED***
            except KeyError:
                error_text = force_text(e***REMOVED***
            self.stderr.write("Error: %s" % error_text***REMOVED***
            # Need to use an OS exit because sys.exit doesn't work in a thread
            os._exit(1***REMOVED***
        except KeyboardInterrupt:
            if shutdown_message:
                self.stdout.write(shutdown_message***REMOVED***
            sys.exit(0***REMOVED***

# Kept for backward compatibility
BaseRunserverCommand = Command
