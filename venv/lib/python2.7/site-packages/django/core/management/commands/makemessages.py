from __future__ import unicode_literals

import fnmatch
import glob
import io
***REMOVED***
import re
import sys
from functools import total_ordering
from itertools import dropwhile

import django
from django.conf import settings
from django.core.files.temp import NamedTemporaryFile
from django.core.management.base import BaseCommand, CommandError
from django.core.management.utils import (
    find_command, handle_extensions, popen_wrapper,
***REMOVED***
from django.utils._os import upath
from django.utils.encoding import DEFAULT_LOCALE_ENCODING, force_str
from django.utils.functional import cached_property
from django.utils.jslex import prepare_js_for_gettext
from django.utils.text import get_text_list

plural_forms_re = re.compile(r'^(?P<value>"Plural-Forms.+?\\n"***REMOVED***\s*$', re.MULTILINE | re.DOTALL***REMOVED***
STATUS_OK = 0
NO_LOCALE_DIR = object(***REMOVED***


def check_programs(*programs***REMOVED***:
    for program in programs:
        if find_command(program***REMOVED*** is None:
            raise CommandError(
                "Can't find %s. Make sure you have GNU gettext tools 0.15 or "
                "newer installed." % program
            ***REMOVED***


@total_ordering
class TranslatableFile(object***REMOVED***:
    def __init__(self, dirpath, file_name, locale_dir***REMOVED***:
        self.file = file_name
        self.dirpath = dirpath
        self.locale_dir = locale_dir

    def __repr__(self***REMOVED***:
        return "<TranslatableFile: %s>" % os.sep.join([self.dirpath, self.file***REMOVED******REMOVED***

    def __eq__(self, other***REMOVED***:
        return self.path == other.path

    def __lt__(self, other***REMOVED***:
        return self.path < other.path

    @property
    def path(self***REMOVED***:
        return os.path.join(self.dirpath, self.file***REMOVED***


class BuildFile(object***REMOVED***:
    ***REMOVED***
    Represents the state of a translatable file during the build process.
    ***REMOVED***
    def __init__(self, command, domain, translatable***REMOVED***:
        self.command = command
        self.domain = domain
        self.translatable = translatable

    @cached_property
    def is_templatized(self***REMOVED***:
        if self.domain == 'djangojs':
            return self.command.gettext_version < (0, 18, 3***REMOVED***
        elif self.domain == 'django':
            file_ext = os.path.splitext(self.translatable.file***REMOVED***[1***REMOVED***
            return file_ext != '.py'
        return False

    @cached_property
    def path(self***REMOVED***:
        return self.translatable.path

    @cached_property
    def work_path(self***REMOVED***:
        ***REMOVED***
        Path to a file which is being fed into GNU gettext pipeline. This may
        be either a translatable or its preprocessed version.
        ***REMOVED***
        if not self.is_templatized:
            return self.path
        extension = {
            'djangojs': 'c',
            'django': 'py',
    ***REMOVED***.get(self.domain***REMOVED***
        filename = '%s.%s' % (self.translatable.file, extension***REMOVED***
        return os.path.join(self.translatable.dirpath, filename***REMOVED***

    def preprocess(self***REMOVED***:
        ***REMOVED***
        Preprocess (if necessary***REMOVED*** a translatable file before passing it to
        xgettext GNU gettext utility.
        ***REMOVED***
        from django.utils.translation import templatize

        if not self.is_templatized:
            return

        with io.open(self.path, 'r', encoding=settings.FILE_CHARSET***REMOVED*** as fp:
            src_data = fp.read(***REMOVED***

        if self.domain == 'djangojs':
            content = prepare_js_for_gettext(src_data***REMOVED***
        elif self.domain == 'django':
            content = templatize(src_data, self.path[2:***REMOVED******REMOVED***

        with io.open(self.work_path, 'w', encoding='utf-8'***REMOVED*** as fp:
            fp.write(content***REMOVED***

    def postprocess_messages(self, msgs***REMOVED***:
        ***REMOVED***
        Postprocess messages generated by xgettext GNU gettext utility.

        Transform paths as if these messages were generated from original
        translatable files rather than from preprocessed versions.
        ***REMOVED***
        if not self.is_templatized:
            return msgs

        # Remove '.py' suffix
        if os.name == 'nt':
            # Preserve '.\' prefix on Windows to respect gettext behavior
            old_path = self.work_path
            new_path = self.path
        else:
            old_path = self.work_path[2:***REMOVED***
            new_path = self.path[2:***REMOVED***

        return re.sub(
            r'^(#: .****REMOVED***(' + re.escape(old_path***REMOVED*** + r'***REMOVED***',
            lambda match: match.group(***REMOVED***.replace(old_path, new_path***REMOVED***,
            msgs,
            flags=re.MULTILINE
        ***REMOVED***

    def cleanup(self***REMOVED***:
        ***REMOVED***
        Remove a preprocessed copy of a translatable file (if any***REMOVED***.
        ***REMOVED***
        if self.is_templatized:
            # This check is needed for the case of a symlinked file and its
            # source being processed inside a single group (locale dir***REMOVED***;
            # removing either of those two removes both.
            if os.path.exists(self.work_path***REMOVED***:
                os.unlink(self.work_path***REMOVED***


def normalize_eols(raw_contents***REMOVED***:
    ***REMOVED***
    Take a block of raw text that will be passed through str.splitlines(***REMOVED*** to
    get universal newlines treatment.

    Return the resulting block of text with normalized `\n` EOL sequences ready
    to be written to disk using current platform's native EOLs.
    ***REMOVED***
    lines_list = raw_contents.splitlines(***REMOVED***
    # Ensure last line has its EOL
    if lines_list and lines_list[-1***REMOVED***:
        lines_list.append(''***REMOVED***
    return '\n'.join(lines_list***REMOVED***


def write_pot_file(potfile, msgs***REMOVED***:
    ***REMOVED***
    Write the :param potfile: POT file with the :param msgs: contents,
    previously making sure its format is valid.
    ***REMOVED***
    pot_lines = msgs.splitlines(***REMOVED***
    if os.path.exists(potfile***REMOVED***:
        # Strip the header
        lines = dropwhile(len, pot_lines***REMOVED***
    else:
        lines = [***REMOVED***
        found, header_read = False, False
        for line in pot_lines:
            if not found and not header_read:
                found = True
                line = line.replace('charset=CHARSET', 'charset=UTF-8'***REMOVED***
            if not line and not found:
                header_read = True
            lines.append(line***REMOVED***
    msgs = '\n'.join(lines***REMOVED***
    with io.open(potfile, 'a', encoding='utf-8'***REMOVED*** as fp:
        fp.write(msgs***REMOVED***


class Command(BaseCommand***REMOVED***:
    help = (
        "Runs over the entire source tree of the current directory and "
        "pulls out all strings marked for translation. It creates (or updates***REMOVED*** a message "
        "file in the conf/locale (in the django tree***REMOVED*** or locale (for projects and "
        "applications***REMOVED*** directory.\n\nYou must run this command with one of either the "
        "--locale, --exclude, or --all options."
    ***REMOVED***

    translatable_file_class = TranslatableFile
    build_file_class = BuildFile

    requires_system_checks = False
    leave_locale_alone = True

    msgmerge_options = ['-q', '--previous'***REMOVED***
    msguniq_options = ['--to-code=utf-8'***REMOVED***
    msgattrib_options = ['--no-obsolete'***REMOVED***
    xgettext_options = ['--from-code=UTF-8', '--add-comments=Translators'***REMOVED***

    def add_arguments(self, parser***REMOVED***:
        parser.add_argument(
            '--locale', '-l', default=[***REMOVED***, dest='locale', action='append',
            help='Creates or updates the message files for the given locale(s***REMOVED*** (e.g. pt_BR***REMOVED***. '
                 'Can be used multiple times.',
        ***REMOVED***
        parser.add_argument(
            '--exclude', '-x', default=[***REMOVED***, dest='exclude', action='append',
            help='Locales to exclude. Default is none. Can be used multiple times.',
        ***REMOVED***
        parser.add_argument(
            '--domain', '-d', default='django', dest='domain',
            help='The domain of the message files (default: "django"***REMOVED***.',
        ***REMOVED***
        parser.add_argument(
            '--all', '-a', action='store_true', dest='all', default=False,
            help='Updates the message files for all existing locales.',
        ***REMOVED***
        parser.add_argument(
            '--extension', '-e', dest='extensions', action='append',
            help='The file extension(s***REMOVED*** to examine (default: "html,txt,py", or "js" '
                 'if the domain is "djangojs"***REMOVED***. Separate multiple extensions with '
                 'commas, or use -e multiple times.',
        ***REMOVED***
        parser.add_argument(
            '--symlinks', '-s', action='store_true', dest='symlinks', default=False,
            help='Follows symlinks to directories when examining source code '
                 'and templates for translation strings.',
        ***REMOVED***
        parser.add_argument(
            '--ignore', '-i', action='append', dest='ignore_patterns',
            default=[***REMOVED***, metavar='PATTERN',
            help='Ignore files or directories matching this glob-style pattern. '
                 'Use multiple times to ignore more.',
        ***REMOVED***
        parser.add_argument(
            '--no-default-ignore', action='store_false', dest='use_default_ignore_patterns',
            default=True, help="Don't ignore the common glob-style patterns 'CVS', '.*', '*~' and '*.pyc'.",
        ***REMOVED***
        parser.add_argument(
            '--no-wrap', action='store_true', dest='no_wrap',
            default=False, help="Don't break long message lines into several lines.",
        ***REMOVED***
        parser.add_argument(
            '--no-location', action='store_true', dest='no_location',
            default=False, help="Don't write '#: filename:line' lines.",
        ***REMOVED***
        parser.add_argument(
            '--no-obsolete', action='store_true', dest='no_obsolete',
            default=False, help="Remove obsolete message strings.",
        ***REMOVED***
        parser.add_argument(
            '--keep-pot', action='store_true', dest='keep_pot',
            default=False, help="Keep .pot file after making messages. Useful when debugging.",
        ***REMOVED***

    def handle(self, *args, **options***REMOVED***:
        locale = options['locale'***REMOVED***
        exclude = options['exclude'***REMOVED***
        self.domain = options['domain'***REMOVED***
        self.verbosity = options['verbosity'***REMOVED***
        process_all = options['all'***REMOVED***
        extensions = options['extensions'***REMOVED***
        self.symlinks = options['symlinks'***REMOVED***

        # Need to ensure that the i18n framework is enabled
        if settings.configured:
            settings.***REMOVED***
        else:
            settings.configure(USE_I18N=True***REMOVED***

        ignore_patterns = options['ignore_patterns'***REMOVED***
        if options['use_default_ignore_patterns'***REMOVED***:
            ignore_patterns += ['CVS', '.*', '*~', '*.pyc'***REMOVED***
        self.ignore_patterns = list(set(ignore_patterns***REMOVED******REMOVED***

        # Avoid messing with mutable class variables
        if options['no_wrap'***REMOVED***:
            self.msgmerge_options = self.msgmerge_options[:***REMOVED*** + ['--no-wrap'***REMOVED***
            self.msguniq_options = self.msguniq_options[:***REMOVED*** + ['--no-wrap'***REMOVED***
            self.msgattrib_options = self.msgattrib_options[:***REMOVED*** + ['--no-wrap'***REMOVED***
            self.xgettext_options = self.xgettext_options[:***REMOVED*** + ['--no-wrap'***REMOVED***
        if options['no_location'***REMOVED***:
            self.msgmerge_options = self.msgmerge_options[:***REMOVED*** + ['--no-location'***REMOVED***
            self.msguniq_options = self.msguniq_options[:***REMOVED*** + ['--no-location'***REMOVED***
            self.msgattrib_options = self.msgattrib_options[:***REMOVED*** + ['--no-location'***REMOVED***
            self.xgettext_options = self.xgettext_options[:***REMOVED*** + ['--no-location'***REMOVED***

        self.no_obsolete = options['no_obsolete'***REMOVED***
        self.keep_pot = options['keep_pot'***REMOVED***

        if self.domain not in ('django', 'djangojs'***REMOVED***:
            raise CommandError("currently makemessages only supports domains "
                               "'django' and 'djangojs'"***REMOVED***
        if self.domain == 'djangojs':
            exts = extensions if extensions else ['js'***REMOVED***
        else:
            exts = extensions if extensions else ['html', 'txt', 'py'***REMOVED***
        self.extensions = handle_extensions(exts***REMOVED***

        if (locale is None and not exclude and not process_all***REMOVED*** or self.domain is None:
            raise CommandError(
                "Type '%s help %s' for usage information."
                % (os.path.basename(sys.argv[0***REMOVED******REMOVED***, sys.argv[1***REMOVED******REMOVED***
            ***REMOVED***

        if self.verbosity > 1:
            self.stdout.write(
                'examining files with the extensions: %s\n'
                % get_text_list(list(self.extensions***REMOVED***, 'and'***REMOVED***
            ***REMOVED***

        self.invoked_for_django = False
        self.locale_paths = [***REMOVED***
        self.default_locale_path = None
        if os.path.isdir(os.path.join('conf', 'locale'***REMOVED******REMOVED***:
            self.locale_paths = [os.path.abspath(os.path.join('conf', 'locale'***REMOVED******REMOVED******REMOVED***
            self.default_locale_path = self.locale_paths[0***REMOVED***
            self.invoked_for_django = True
        else:
            self.locale_paths.extend(settings.LOCALE_PATHS***REMOVED***
            # Allow to run makemessages inside an app dir
            if os.path.isdir('locale'***REMOVED***:
                self.locale_paths.append(os.path.abspath('locale'***REMOVED******REMOVED***
            if self.locale_paths:
                self.default_locale_path = self.locale_paths[0***REMOVED***
                if not os.path.exists(self.default_locale_path***REMOVED***:
                    os.makedirs(self.default_locale_path***REMOVED***

        # Build locale list
        locale_dirs = filter(os.path.isdir, glob.glob('%s/*' % self.default_locale_path***REMOVED******REMOVED***
        all_locales = map(os.path.basename, locale_dirs***REMOVED***

        # Account for excluded locales
        if process_all:
            locales = all_locales
        else:
            locales = locale or all_locales
            locales = set(locales***REMOVED*** - set(exclude***REMOVED***

        if locales:
            check_programs('msguniq', 'msgmerge', 'msgattrib'***REMOVED***

        check_programs('xgettext'***REMOVED***

        ***REMOVED***
            potfiles = self.build_potfiles(***REMOVED***

            # Build po files for each selected locale
            for locale in locales:
                if self.verbosity > 0:
                    self.stdout.write("processing locale %s\n" % locale***REMOVED***
                for potfile in potfiles:
                    self.write_po_file(potfile, locale***REMOVED***
        finally:
            if not self.keep_pot:
                self.remove_potfiles(***REMOVED***

    @cached_property
    def gettext_version(self***REMOVED***:
        # Gettext tools will output system-encoded bytestrings instead of UTF-8,
        # when looking up the version. It's especially a problem on Windows.
        out, err, status = popen_wrapper(
            ['xgettext', '--version'***REMOVED***,
            stdout_encoding=DEFAULT_LOCALE_ENCODING,
        ***REMOVED***
        m = re.search(r'(\d+***REMOVED***\.(\d+***REMOVED***\.?(\d+***REMOVED***?', out***REMOVED***
        if m:
            return tuple(int(d***REMOVED*** for d in m.groups(***REMOVED*** if d is not None***REMOVED***
        else:
            raise CommandError("Unable to get gettext version. Is it installed?"***REMOVED***

    def build_potfiles(self***REMOVED***:
        ***REMOVED***
        Build pot files and apply msguniq to them.
        ***REMOVED***
        file_list = self.find_files("."***REMOVED***
        self.remove_potfiles(***REMOVED***
        self.process_files(file_list***REMOVED***
        potfiles = [***REMOVED***
        for path in self.locale_paths:
            potfile = os.path.join(path, '%s.pot' % str(self.domain***REMOVED******REMOVED***
            if not os.path.exists(potfile***REMOVED***:
                continue
            args = ['msguniq'***REMOVED*** + self.msguniq_options + [potfile***REMOVED***
            msgs, errors, status = popen_wrapper(args***REMOVED***
            if errors:
                if status != STATUS_OK:
                    raise CommandError(
                        "errors happened while running msguniq\n%s" % errors***REMOVED***
                elif self.verbosity > 0:
                    self.stdout.write(errors***REMOVED***
            msgs = normalize_eols(msgs***REMOVED***
            with io.open(potfile, 'w', encoding='utf-8'***REMOVED*** as fp:
                fp.write(msgs***REMOVED***
            potfiles.append(potfile***REMOVED***
        return potfiles

    def remove_potfiles(self***REMOVED***:
        for path in self.locale_paths:
            pot_path = os.path.join(path, '%s.pot' % str(self.domain***REMOVED******REMOVED***
            if os.path.exists(pot_path***REMOVED***:
                os.unlink(pot_path***REMOVED***

    def find_files(self, root***REMOVED***:
        ***REMOVED***
        Helper method to get all files in the given root. Also check that there
        is a matching locale dir for each file.
        ***REMOVED***

        def is_ignored(path, ignore_patterns***REMOVED***:
            ***REMOVED***
            Check if the given path should be ignored or not.
            ***REMOVED***
            filename = os.path.basename(path***REMOVED***

            def ignore(pattern***REMOVED***:
                return fnmatch.fnmatchcase(filename, pattern***REMOVED*** or fnmatch.fnmatchcase(path, pattern***REMOVED***

            return any(ignore(pattern***REMOVED*** for pattern in ignore_patterns***REMOVED***

        ignore_patterns = [os.path.normcase(p***REMOVED*** for p in self.ignore_patterns***REMOVED***
        dir_suffixes = {'%s*' % path_sep for path_sep in {'/', os.sep***REMOVED******REMOVED***
        norm_patterns = [***REMOVED***
        for p in ignore_patterns:
            for dir_suffix in dir_suffixes:
                if p.endswith(dir_suffix***REMOVED***:
                    norm_patterns.append(p[:-len(dir_suffix***REMOVED******REMOVED******REMOVED***
                    break
            else:
                norm_patterns.append(p***REMOVED***

        all_files = [***REMOVED***
        ignored_roots = [os.path.normpath(p***REMOVED*** for p in (settings.MEDIA_ROOT, settings.STATIC_ROOT***REMOVED*** if p***REMOVED***
        for dirpath, dirnames, filenames in os.walk(root, topdown=True, followlinks=self.symlinks***REMOVED***:
            for dirname in dirnames[:***REMOVED***:
                if (is_ignored(os.path.normpath(os.path.join(dirpath, dirname***REMOVED******REMOVED***, norm_patterns***REMOVED*** or
                        os.path.join(os.path.abspath(dirpath***REMOVED***, dirname***REMOVED*** in ignored_roots***REMOVED***:
                    dirnames.remove(dirname***REMOVED***
                    if self.verbosity > 1:
                        self.stdout.write('ignoring directory %s\n' % dirname***REMOVED***
                elif dirname == 'locale':
                    dirnames.remove(dirname***REMOVED***
                    self.locale_paths.insert(0, os.path.join(os.path.abspath(dirpath***REMOVED***, dirname***REMOVED******REMOVED***
            for filename in filenames:
                file_path = os.path.normpath(os.path.join(dirpath, filename***REMOVED******REMOVED***
                file_ext = os.path.splitext(filename***REMOVED***[1***REMOVED***
                if file_ext not in self.extensions or is_ignored(file_path, self.ignore_patterns***REMOVED***:
                    if self.verbosity > 1:
                        self.stdout.write('ignoring file %s in %s\n' % (filename, dirpath***REMOVED******REMOVED***
                else:
                    locale_dir = None
                    for path in self.locale_paths:
                        if os.path.abspath(dirpath***REMOVED***.startswith(os.path.dirname(path***REMOVED******REMOVED***:
                            locale_dir = path
                            break
                    if not locale_dir:
                        locale_dir = self.default_locale_path
                    if not locale_dir:
                        locale_dir = NO_LOCALE_DIR
                    all_files.append(self.translatable_file_class(dirpath, filename, locale_dir***REMOVED******REMOVED***
        return sorted(all_files***REMOVED***

    def process_files(self, file_list***REMOVED***:
        ***REMOVED***
        Group translatable files by locale directory and run pot file build
        process for each group.
        ***REMOVED***
        file_groups = {***REMOVED***
        for translatable in file_list:
            file_group = file_groups.setdefault(translatable.locale_dir, [***REMOVED******REMOVED***
            file_group.append(translatable***REMOVED***
        for locale_dir, files in file_groups.items(***REMOVED***:
            self.process_locale_dir(locale_dir, files***REMOVED***

    def process_locale_dir(self, locale_dir, files***REMOVED***:
        ***REMOVED***
        Extract translatable literals from the specified files, creating or
        updating the POT file for a given locale directory.

        Uses the xgettext GNU gettext utility.
        ***REMOVED***
        build_files = [***REMOVED***
        for translatable in files:
            if self.verbosity > 1:
                self.stdout.write('processing file %s in %s\n' % (
                    translatable.file, translatable.dirpath
                ***REMOVED******REMOVED***
            if self.domain not in ('djangojs', 'django'***REMOVED***:
                continue
            build_file = self.build_file_class(self, self.domain, translatable***REMOVED***
            ***REMOVED***
                build_file.preprocess(***REMOVED***
            except UnicodeDecodeError as e:
                self.stdout.write(
                    'UnicodeDecodeError: skipped file %s in %s (reason: %s***REMOVED***' % (
                        translatable.file, translatable.dirpath, e,
                    ***REMOVED***
                ***REMOVED***
                continue
            build_files.append(build_file***REMOVED***

        if self.domain == 'djangojs':
            is_templatized = build_file.is_templatized
            args = [
                'xgettext',
                '-d', self.domain,
                '--language=%s' % ('C' if is_templatized else 'JavaScript',***REMOVED***,
                '--keyword=gettext_noop',
                '--keyword=gettext_lazy',
                '--keyword=ngettext_lazy:1,2',
                '--keyword=pgettext:1c,2',
                '--keyword=npgettext:1c,2,3',
                '--output=-',
            ***REMOVED***
        elif self.domain == 'django':
            args = [
                'xgettext',
                '-d', self.domain,
                '--language=Python',
                '--keyword=gettext_noop',
                '--keyword=gettext_lazy',
                '--keyword=ngettext_lazy:1,2',
                '--keyword=ugettext_noop',
                '--keyword=ugettext_lazy',
                '--keyword=ungettext_lazy:1,2',
                '--keyword=pgettext:1c,2',
                '--keyword=npgettext:1c,2,3',
                '--keyword=pgettext_lazy:1c,2',
                '--keyword=npgettext_lazy:1c,2,3',
                '--output=-',
            ***REMOVED***
        else:
            return

        input_files = [bf.work_path for bf in build_files***REMOVED***
        with NamedTemporaryFile(mode='w+'***REMOVED*** as input_files_list:
            input_files_list.write(force_str('\n'.join(input_files***REMOVED***, encoding=DEFAULT_LOCALE_ENCODING***REMOVED******REMOVED***
            input_files_list.flush(***REMOVED***
            args.extend(['--files-from', input_files_list.name***REMOVED******REMOVED***
            args.extend(self.xgettext_options***REMOVED***
            msgs, errors, status = popen_wrapper(args***REMOVED***

        if errors:
            if status != STATUS_OK:
                for build_file in build_files:
                    build_file.cleanup(***REMOVED***
                raise CommandError(
                    'errors happened while running xgettext on %s\n%s' %
                    ('\n'.join(input_files***REMOVED***, errors***REMOVED***
                ***REMOVED***
            elif self.verbosity > 0:
                # Print warnings
                self.stdout.write(errors***REMOVED***

        if msgs:
            if locale_dir is NO_LOCALE_DIR:
                file_path = os.path.normpath(build_files[0***REMOVED***.path***REMOVED***
                raise CommandError(
                    'Unable to find a locale path to store translations for '
                    'file %s' % file_path
                ***REMOVED***
            for build_file in build_files:
                msgs = build_file.postprocess_messages(msgs***REMOVED***
            potfile = os.path.join(locale_dir, '%s.pot' % str(self.domain***REMOVED******REMOVED***
            write_pot_file(potfile, msgs***REMOVED***

        for build_file in build_files:
            build_file.cleanup(***REMOVED***

    def write_po_file(self, potfile, locale***REMOVED***:
        ***REMOVED***
        Creates or updates the PO file for self.domain and :param locale:.
        Uses contents of the existing :param potfile:.

        Uses msgmerge, and msgattrib GNU gettext utilities.
        ***REMOVED***
        basedir = os.path.join(os.path.dirname(potfile***REMOVED***, locale, 'LC_MESSAGES'***REMOVED***
        if not os.path.isdir(basedir***REMOVED***:
            os.makedirs(basedir***REMOVED***
        pofile = os.path.join(basedir, '%s.po' % str(self.domain***REMOVED******REMOVED***

        if os.path.exists(pofile***REMOVED***:
            args = ['msgmerge'***REMOVED*** + self.msgmerge_options + [pofile, potfile***REMOVED***
            msgs, errors, status = popen_wrapper(args***REMOVED***
            if errors:
                if status != STATUS_OK:
                    raise CommandError(
                        "errors happened while running msgmerge\n%s" % errors***REMOVED***
                elif self.verbosity > 0:
                    self.stdout.write(errors***REMOVED***
        else:
            with io.open(potfile, 'r', encoding='utf-8'***REMOVED*** as fp:
                msgs = fp.read(***REMOVED***
            if not self.invoked_for_django:
                msgs = self.copy_plural_forms(msgs, locale***REMOVED***
        msgs = normalize_eols(msgs***REMOVED***
        msgs = msgs.replace(
            "#. #-#-#-#-#  %s.pot (PACKAGE VERSION***REMOVED***  #-#-#-#-#\n" % self.domain, ""***REMOVED***
        with io.open(pofile, 'w', encoding='utf-8'***REMOVED*** as fp:
            fp.write(msgs***REMOVED***

        if self.no_obsolete:
            args = ['msgattrib'***REMOVED*** + self.msgattrib_options + ['-o', pofile, pofile***REMOVED***
            msgs, errors, status = popen_wrapper(args***REMOVED***
            if errors:
                if status != STATUS_OK:
                    raise CommandError(
                        "errors happened while running msgattrib\n%s" % errors***REMOVED***
                elif self.verbosity > 0:
                    self.stdout.write(errors***REMOVED***

    def copy_plural_forms(self, msgs, locale***REMOVED***:
        ***REMOVED***
        Copies plural forms header contents from a Django catalog of locale to
        the msgs string, inserting it at the right place. msgs should be the
        contents of a newly created .po file.
        ***REMOVED***
        django_dir = os.path.normpath(os.path.join(os.path.dirname(upath(django.__file__***REMOVED******REMOVED******REMOVED******REMOVED***
        if self.domain == 'djangojs':
            domains = ('djangojs', 'django'***REMOVED***
        else:
            domains = ('django',***REMOVED***
        for domain in domains:
            django_po = os.path.join(django_dir, 'conf', 'locale', locale, 'LC_MESSAGES', '%s.po' % domain***REMOVED***
            if os.path.exists(django_po***REMOVED***:
                with io.open(django_po, 'r', encoding='utf-8'***REMOVED*** as fp:
                    m = plural_forms_re.search(fp.read(***REMOVED******REMOVED***
                if m:
                    plural_form_line = force_str(m.group('value'***REMOVED******REMOVED***
                    if self.verbosity > 1:
                        self.stdout.write("copying plural forms: %s\n" % plural_form_line***REMOVED***
                    lines = [***REMOVED***
                    found = False
                    for line in msgs.splitlines(***REMOVED***:
                        if not found and (not line or plural_forms_re.search(line***REMOVED******REMOVED***:
                            line = plural_form_line
                            found = True
                        lines.append(line***REMOVED***
                    msgs = '\n'.join(lines***REMOVED***
                    break
        return msgs
