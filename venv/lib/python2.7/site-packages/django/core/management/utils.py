from __future__ import unicode_literals

***REMOVED***
import sys
from subprocess import PIPE, Popen

from django.utils import six
***REMOVED***
from django.utils.encoding import DEFAULT_LOCALE_ENCODING, force_text

from .base import CommandError


def popen_wrapper(args, os_err_exc_type=CommandError, stdout_encoding='utf-8'***REMOVED***:
    ***REMOVED***
    Friendly wrapper around Popen.

    Returns stdout output, stderr output and OS status code.
    ***REMOVED***
    ***REMOVED***
        p = Popen(args, shell=False, stdout=PIPE, stderr=PIPE, close_fds=os.name != 'nt'***REMOVED***
    except OSError as e:
        strerror = force_text(e.strerror, DEFAULT_LOCALE_ENCODING, strings_only=True***REMOVED***
        six.reraise(os_err_exc_type, os_err_exc_type('Error executing %s: %s' %
                    (args[0***REMOVED***, strerror***REMOVED******REMOVED***, sys.exc_info(***REMOVED***[2***REMOVED******REMOVED***
    output, errors = p.communicate(***REMOVED***
    return (
        force_text(output, stdout_encoding, strings_only=True, errors='strict'***REMOVED***,
        force_text(errors, DEFAULT_LOCALE_ENCODING, strings_only=True, errors='replace'***REMOVED***,
        p.returncode
    ***REMOVED***


def handle_extensions(extensions***REMOVED***:
    ***REMOVED***
    Organizes multiple extensions that are separated with commas or passed by
    using --extension/-e multiple times.

    For example: running 'django-admin makemessages -e js,txt -e xhtml -a'
    would result in an extension list: ['.js', '.txt', '.xhtml'***REMOVED***

    >>> handle_extensions(['.html', 'html,js,py,py,py,.py', 'py,.py'***REMOVED******REMOVED***
***REMOVED***'.html', '.js', '.py'***REMOVED***
    >>> handle_extensions(['.html, txt,.tpl'***REMOVED******REMOVED***
***REMOVED***'.html', '.tpl', '.txt'***REMOVED***
    ***REMOVED***
    ext_list = [***REMOVED***
    for ext in extensions:
        ext_list.extend(ext.replace(' ', ''***REMOVED***.split(','***REMOVED******REMOVED***
    for i, ext in enumerate(ext_list***REMOVED***:
        if not ext.startswith('.'***REMOVED***:
            ext_list[i***REMOVED*** = '.%s' % ext_list[i***REMOVED***
    return set(ext_list***REMOVED***


def find_command(cmd, path=None, pathext=None***REMOVED***:
    if path is None:
        path = os.environ.get('PATH', ''***REMOVED***.split(os.pathsep***REMOVED***
    if isinstance(path, six.string_types***REMOVED***:
        path = [path***REMOVED***
    # check if there are funny path extensions for executables, e.g. Windows
    if pathext is None:
        pathext = os.environ.get('PATHEXT', '.COM;.EXE;.BAT;.CMD'***REMOVED***.split(os.pathsep***REMOVED***
    # don't use extensions if the command ends with one of them
    for ext in pathext:
        if cmd.endswith(ext***REMOVED***:
            pathext = [''***REMOVED***
            break
    # check if we find the command on PATH
    for p in path:
        f = os.path.join(p, cmd***REMOVED***
        if os.path.isfile(f***REMOVED***:
            return f
        for ext in pathext:
            fext = f + ext
            if os.path.isfile(fext***REMOVED***:
                return fext
    return None


def get_random_secret_key(***REMOVED***:
    ***REMOVED***
    Return a 50 character random string usable as a SECRET_KEY setting value.
    ***REMOVED***
***REMOVED***
    return get_random_string(50, chars***REMOVED***
