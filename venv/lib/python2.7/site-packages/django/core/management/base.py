# -*- coding: utf-8 -*-
***REMOVED***
Base classes for writing management commands (named commands which can
be executed through ``django-admin`` or ``manage.py``***REMOVED***.
***REMOVED***
from __future__ import unicode_literals

***REMOVED***
import sys
from argparse import ArgumentParser

import django
from django.core import checks
from django.core.exceptions import ImproperlyConfigured
from django.core.management.color import color_style, no_style
from django.db import DEFAULT_DB_ALIAS, connections
from django.db.migrations.exceptions import MigrationSchemaMissing
from django.utils.encoding import force_str


class CommandError(Exception***REMOVED***:
    ***REMOVED***
    Exception class indicating a problem while executing a management
    command.

    If this exception is raised during the execution of a management
    command, it will be caught and turned into a nicely-printed error
    message to the appropriate output stream (i.e., stderr***REMOVED***; as a
    result, raising this exception (with a sensible description of the
    error***REMOVED*** is the preferred way to indicate that something has gone
    wrong in the execution of a command.
    ***REMOVED***
    pass


class SystemCheckError(CommandError***REMOVED***:
    ***REMOVED***
    The system check framework detected unrecoverable errors.
    ***REMOVED***
    pass


class CommandParser(ArgumentParser***REMOVED***:
    ***REMOVED***
    Customized ArgumentParser class to improve some error messages and prevent
    SystemExit in several occasions, as SystemExit is unacceptable when a
    command is called programmatically.
    ***REMOVED***
    def __init__(self, cmd, **kwargs***REMOVED***:
        self.cmd = cmd
        super(CommandParser, self***REMOVED***.__init__(**kwargs***REMOVED***

    def parse_args(self, args=None, namespace=None***REMOVED***:
        # Catch missing argument for a better error message
        if (hasattr(self.cmd, 'missing_args_message'***REMOVED*** and
                not (args or any(not arg.startswith('-'***REMOVED*** for arg in args***REMOVED******REMOVED******REMOVED***:
            self.error(self.cmd.missing_args_message***REMOVED***
        return super(CommandParser, self***REMOVED***.parse_args(args, namespace***REMOVED***

    def error(self, message***REMOVED***:
        if self.cmd._called_from_command_line:
            super(CommandParser, self***REMOVED***.error(message***REMOVED***
        else:
            raise CommandError("Error: %s" % message***REMOVED***


def handle_default_options(options***REMOVED***:
    ***REMOVED***
    Include any default options that all commands should accept here
    so that ManagementUtility can handle them before searching for
    user commands.
    ***REMOVED***
    if options.settings:
        os.environ['DJANGO_SETTINGS_MODULE'***REMOVED*** = options.settings
    if options.pythonpath:
        sys.path.insert(0, options.pythonpath***REMOVED***


class OutputWrapper(object***REMOVED***:
    ***REMOVED***
    Wrapper around stdout/stderr
    ***REMOVED***
    @property
    def style_func(self***REMOVED***:
        return self._style_func

    @style_func.setter
    def style_func(self, style_func***REMOVED***:
        if style_func and self.isatty(***REMOVED***:
            self._style_func = style_func
        else:
            self._style_func = lambda x: x

    def __init__(self, out, style_func=None, ending='\n'***REMOVED***:
        self._out = out
        self.style_func = None
        self.ending = ending

    def __getattr__(self, name***REMOVED***:
        return getattr(self._out, name***REMOVED***

    def isatty(self***REMOVED***:
        return hasattr(self._out, 'isatty'***REMOVED*** and self._out.isatty(***REMOVED***

    def write(self, msg, style_func=None, ending=None***REMOVED***:
        ending = self.ending if ending is None else ending
        if ending and not msg.endswith(ending***REMOVED***:
            msg += ending
        style_func = style_func or self.style_func
        self._out.write(force_str(style_func(msg***REMOVED******REMOVED******REMOVED***


class BaseCommand(object***REMOVED***:
    ***REMOVED***
    The base class from which all management commands ultimately
    derive.

    Use this class if you want access to all of the mechanisms which
    parse the command-line arguments and work out what code to call in
    response; if you don't need to change any of that behavior,
    consider using one of the subclasses defined in this file.

    If you are interested in overriding/customizing various aspects of
    the command-parsing and -execution behavior, the normal flow works
    as follows:

    1. ``django-admin`` or ``manage.py`` loads the command class
       and calls its ``run_from_argv(***REMOVED***`` method.

    2. The ``run_from_argv(***REMOVED***`` method calls ``create_parser(***REMOVED***`` to get
       an ``ArgumentParser`` for the arguments, parses them, performs
       any environment changes requested by options like
       ``pythonpath``, and then calls the ``execute(***REMOVED***`` method,
       passing the parsed arguments.

    3. The ``execute(***REMOVED***`` method attempts to carry out the command by
       calling the ``handle(***REMOVED***`` method with the parsed arguments; any
       output produced by ``handle(***REMOVED***`` will be printed to standard
       output and, if the command is intended to produce a block of
       SQL statements, will be wrapped in ``BEGIN`` and ``COMMIT``.

    4. If ``handle(***REMOVED***`` or ``execute(***REMOVED***`` raised any exception (e.g.
       ``CommandError``***REMOVED***, ``run_from_argv(***REMOVED***`` will  instead print an error
       message to ``stderr``.

    Thus, the ``handle(***REMOVED***`` method is typically the starting point for
    subclasses; many built-in commands and command types either place
    all of their logic in ``handle(***REMOVED***``, or perform some additional
    parsing work in ``handle(***REMOVED***`` and then delegate from it to more
    specialized methods as needed.

    Several attributes affect behavior at various steps along the way:

    ``can_import_settings``
        A boolean indicating whether the command needs to be able to
        import Django settings; if ``True``, ``execute(***REMOVED***`` will verify
        that this is possible before proceeding. Default value is
        ``True``.

    ``help``
        A short description of the command, which will be printed in
        help messages.

    ``output_transaction``
        A boolean indicating whether the command outputs SQL
        statements; if ``True``, the output will automatically be
        wrapped with ``BEGIN;`` and ``COMMIT;``. Default value is
        ``False``.

    ``requires_migrations_checks``
        A boolean; if ``True``, the command prints a warning if the set of
        migrations on disk don't match the migrations in the database.

    ``requires_system_checks``
        A boolean; if ``True``, entire Django project will be checked for errors
        prior to executing the command. Default value is ``True``.
        To validate an individual application's models
        rather than all applications' models, call
        ``self.check(app_configs***REMOVED***`` from ``handle(***REMOVED***``, where ``app_configs``
        is the list of application's configuration provided by the
        app registry.

    ``leave_locale_alone``
        A boolean indicating whether the locale set in settings should be
        preserved during the execution of the command instead of translations
        being deactivated.

        Default value is ``False``.

        Make sure you know what you are doing if you decide to change the value
        of this option in your custom command if it creates database content
        that is locale-sensitive and such content shouldn't contain any
        translations (like it happens e.g. with django.contrib.auth
        permissions***REMOVED*** as activating any locale might cause unintended effects.

        This option can't be False when the can_import_settings option is set
        to False too because attempting to deactivate translations needs access
        to settings. This condition will generate a CommandError.
    ***REMOVED***
    # Metadata about this command.
    help = ''

    # Configuration shortcuts that alter various logic.
    _called_from_command_line = False
    can_import_settings = True
    output_transaction = False  # Whether to wrap the output in a "BEGIN; COMMIT;"
    leave_locale_alone = False
    requires_migrations_checks = False
    requires_system_checks = True

    def __init__(self, stdout=None, stderr=None, no_color=False***REMOVED***:
        self.stdout = OutputWrapper(stdout or sys.stdout***REMOVED***
        self.stderr = OutputWrapper(stderr or sys.stderr***REMOVED***
        if no_color:
            self.style = no_style(***REMOVED***
        else:
            self.style = color_style(***REMOVED***
            self.stderr.style_func = self.style.ERROR

    def get_version(self***REMOVED***:
        ***REMOVED***
        Return the Django version, which should be correct for all built-in
        Django commands. User-supplied commands can override this method to
        return their own version.
        ***REMOVED***
        return django.get_version(***REMOVED***

    def create_parser(self, prog_name, subcommand***REMOVED***:
        ***REMOVED***
        Create and return the ``ArgumentParser`` which will be used to
        parse the arguments to this command.
        ***REMOVED***
        parser = CommandParser(
            self, prog="%s %s" % (os.path.basename(prog_name***REMOVED***, subcommand***REMOVED***,
            description=self.help or None,
        ***REMOVED***
        parser.add_argument('--version', action='version', version=self.get_version(***REMOVED******REMOVED***
        parser.add_argument(
            '-v', '--verbosity', action='store', dest='verbosity', default=1,
            type=int, choices=[0, 1, 2, 3***REMOVED***,
            help='Verbosity level; 0=minimal output, 1=normal output, 2=verbose output, 3=very verbose output',
        ***REMOVED***
        parser.add_argument(
            '--settings',
            help=(
                'The Python path to a settings module, e.g. '
                '"myproject.settings.main". If this isn\'t provided, the '
                'DJANGO_SETTINGS_MODULE environment variable will be used.'
            ***REMOVED***,
        ***REMOVED***
        parser.add_argument(
            '--pythonpath',
            help='A directory to add to the Python path, e.g. "/home/djangoprojects/myproject".',
        ***REMOVED***
        parser.add_argument('--traceback', action='store_true', help='Raise on CommandError exceptions'***REMOVED***
        parser.add_argument(
            '--no-color', action='store_true', dest='no_color', default=False,
            help="Don't colorize the command output.",
        ***REMOVED***
        self.add_arguments(parser***REMOVED***
        return parser

    def add_arguments(self, parser***REMOVED***:
        ***REMOVED***
        Entry point for subclassed commands to add custom arguments.
        ***REMOVED***
        pass

    def print_help(self, prog_name, subcommand***REMOVED***:
        ***REMOVED***
        Print the help message for this command, derived from
        ``self.usage(***REMOVED***``.
        ***REMOVED***
        parser = self.create_parser(prog_name, subcommand***REMOVED***
        parser.print_help(***REMOVED***

    def run_from_argv(self, argv***REMOVED***:
        ***REMOVED***
        Set up any environment changes requested (e.g., Python path
        and Django settings***REMOVED***, then run this command. If the
        command raises a ``CommandError``, intercept it and print it sensibly
        to stderr. If the ``--traceback`` option is present or the raised
        ``Exception`` is not ``CommandError``, raise it.
        ***REMOVED***
        self._called_from_command_line = True
        parser = self.create_parser(argv[0***REMOVED***, argv[1***REMOVED******REMOVED***

        options = parser.parse_args(argv[2:***REMOVED******REMOVED***
        cmd_options = vars(options***REMOVED***
        # Move positional args out of options to mimic legacy optparse
        args = cmd_options.pop('args', (***REMOVED******REMOVED***
        handle_default_options(options***REMOVED***
        ***REMOVED***
            self.execute(*args, **cmd_options***REMOVED***
        except Exception as e:
            if options.traceback or not isinstance(e, CommandError***REMOVED***:
                raise

            # SystemCheckError takes care of its own formatting.
            if isinstance(e, SystemCheckError***REMOVED***:
                self.stderr.write(str(e***REMOVED***, lambda x: x***REMOVED***
            else:
                self.stderr.write('%s: %s' % (e.__class__.__name__, e***REMOVED******REMOVED***
            sys.exit(1***REMOVED***
        finally:
            connections.close_all(***REMOVED***

    def execute(self, *args, **options***REMOVED***:
        ***REMOVED***
        Try to execute this command, performing system checks if needed (as
        controlled by the ``requires_system_checks`` attribute, except if
        force-skipped***REMOVED***.
        ***REMOVED***
        if options['no_color'***REMOVED***:
            self.style = no_style(***REMOVED***
            self.stderr.style_func = None
        if options.get('stdout'***REMOVED***:
            self.stdout = OutputWrapper(options['stdout'***REMOVED******REMOVED***
        if options.get('stderr'***REMOVED***:
            self.stderr = OutputWrapper(options['stderr'***REMOVED***, self.stderr.style_func***REMOVED***

        saved_locale = None
        if not self.leave_locale_alone:
            # Only mess with locales if we can assume we have a working
            # settings file, because django.utils.translation requires settings
            # (The final saying about whether the i18n machinery is active will be
            # found in the value of the USE_I18N setting***REMOVED***
            if not self.can_import_settings:
                raise CommandError("Incompatible values of 'leave_locale_alone' "
                                   "(%s***REMOVED*** and 'can_import_settings' (%s***REMOVED*** command "
                                   "options." % (self.leave_locale_alone,
                                                 self.can_import_settings***REMOVED******REMOVED***
            # Deactivate translations, because django-admin creates database
            # content like permissions, and those shouldn't contain any
            # translations.
            from django.utils import translation
            saved_locale = translation.get_language(***REMOVED***
            translation.deactivate_all(***REMOVED***

        ***REMOVED***
            if self.requires_system_checks and not options.get('skip_checks'***REMOVED***:
                self.check(***REMOVED***
            if self.requires_migrations_checks:
                self.check_migrations(***REMOVED***
            output = self.handle(*args, **options***REMOVED***
            if output:
                if self.output_transaction:
                    connection = connections[options.get('database', DEFAULT_DB_ALIAS***REMOVED******REMOVED***
                    output = '%s\n%s\n%s' % (
                        self.style.SQL_KEYWORD(connection.ops.start_transaction_sql(***REMOVED******REMOVED***,
                        output,
                        self.style.SQL_KEYWORD(connection.ops.end_transaction_sql(***REMOVED******REMOVED***,
                    ***REMOVED***
                self.stdout.write(output***REMOVED***
        finally:
            if saved_locale is not None:
                translation.activate(saved_locale***REMOVED***
        return output

    def _run_checks(self, **kwargs***REMOVED***:
        return checks.run_checks(**kwargs***REMOVED***

    def check(self, app_configs=None, tags=None, display_num_errors=False,
              include_deployment_checks=False, fail_level=checks.ERROR***REMOVED***:
        ***REMOVED***
        Uses the system check framework to validate entire Django project.
        Raises CommandError for any serious message (error or critical errors***REMOVED***.
        If there are only light messages (like warnings***REMOVED***, they are printed to
        stderr and no exception is raised.
        ***REMOVED***
        all_issues = self._run_checks(
            app_configs=app_configs,
            tags=tags,
            include_deployment_checks=include_deployment_checks,
        ***REMOVED***

        header, body, footer = "", "", ""
        visible_issue_count = 0  # excludes silenced warnings

        if all_issues:
            debugs = [e for e in all_issues if e.level < checks.INFO and not e.is_silenced(***REMOVED******REMOVED***
            infos = [e for e in all_issues if checks.INFO <= e.level < checks.WARNING and not e.is_silenced(***REMOVED******REMOVED***
            warnings = [e for e in all_issues if checks.WARNING <= e.level < checks.ERROR and not e.is_silenced(***REMOVED******REMOVED***
            errors = [e for e in all_issues if checks.ERROR <= e.level < checks.CRITICAL and not e.is_silenced(***REMOVED******REMOVED***
            criticals = [e for e in all_issues if checks.CRITICAL <= e.level and not e.is_silenced(***REMOVED******REMOVED***
            sorted_issues = [
                (criticals, 'CRITICALS'***REMOVED***,
                (errors, 'ERRORS'***REMOVED***,
                (warnings, 'WARNINGS'***REMOVED***,
                (infos, 'INFOS'***REMOVED***,
                (debugs, 'DEBUGS'***REMOVED***,
            ***REMOVED***

            for issues, group_name in sorted_issues:
                if issues:
                    visible_issue_count += len(issues***REMOVED***
                    formatted = (
                        self.style.ERROR(force_str(e***REMOVED******REMOVED***
                        if e.is_serious(***REMOVED***
                        else self.style.WARNING(force_str(e***REMOVED******REMOVED***
                        for e in issues***REMOVED***
                    formatted = "\n".join(sorted(formatted***REMOVED******REMOVED***
                    body += '\n%s:\n%s\n' % (group_name, formatted***REMOVED***

        if visible_issue_count:
            header = "System check identified some issues:\n"

        if display_num_errors:
            if visible_issue_count:
                footer += '\n'
            footer += "System check identified %s (%s silenced***REMOVED***." % (
                "no issues" if visible_issue_count == 0 else
                "1 issue" if visible_issue_count == 1 else
                "%s issues" % visible_issue_count,
                len(all_issues***REMOVED*** - visible_issue_count,
            ***REMOVED***

        if any(e.is_serious(fail_level***REMOVED*** and not e.is_silenced(***REMOVED*** for e in all_issues***REMOVED***:
            msg = self.style.ERROR("SystemCheckError: %s" % header***REMOVED*** + body + footer
            raise SystemCheckError(msg***REMOVED***
        else:
            msg = header + body + footer

        if msg:
            if visible_issue_count:
                self.stderr.write(msg, lambda x: x***REMOVED***
            else:
                self.stdout.write(msg***REMOVED***

    def check_migrations(self***REMOVED***:
        ***REMOVED***
        Print a warning if the set of migrations on disk don't match the
        migrations in the database.
        ***REMOVED***
        from django.db.migrations.executor import MigrationExecutor
        ***REMOVED***
            executor = MigrationExecutor(connections[DEFAULT_DB_ALIAS***REMOVED******REMOVED***
        except ImproperlyConfigured:
            # No databases are configured (or the dummy one***REMOVED***
            return
        except MigrationSchemaMissing:
            self.stdout.write(self.style.NOTICE(
                "\nNot checking migrations as it is not possible to access/create the django_migrations table."
            ***REMOVED******REMOVED***
            return

        plan = executor.migration_plan(executor.loader.graph.leaf_nodes(***REMOVED******REMOVED***
        if plan:
            apps_waiting_migration = sorted(set(migration.app_label for migration, backwards in plan***REMOVED******REMOVED***
            self.stdout.write(
                self.style.NOTICE(
                    "\nYou have %(unpplied_migration_count***REMOVED***s unapplied migration(s***REMOVED***. "
                    "Your project may not work properly until you apply the "
                    "migrations for app(s***REMOVED***: %(apps_waiting_migration***REMOVED***s." % {
                        "unpplied_migration_count": len(plan***REMOVED***,
                        "apps_waiting_migration": ", ".join(apps_waiting_migration***REMOVED***,
                ***REMOVED***
                ***REMOVED***
            ***REMOVED***
            self.stdout.write(self.style.NOTICE("Run 'python manage.py migrate' to apply them.\n"***REMOVED******REMOVED***

    def handle(self, *args, **options***REMOVED***:
        ***REMOVED***
        The actual logic of the command. Subclasses must implement
        this method.
        ***REMOVED***
        raise NotImplementedError('subclasses of BaseCommand must provide a handle(***REMOVED*** method'***REMOVED***


class AppCommand(BaseCommand***REMOVED***:
    ***REMOVED***
    A management command which takes one or more installed application labels
    as arguments, and does something with each of them.

    Rather than implementing ``handle(***REMOVED***``, subclasses must implement
    ``handle_app_config(***REMOVED***``, which will be called once for each application.
    ***REMOVED***
    missing_args_message = "Enter at least one application label."

    def add_arguments(self, parser***REMOVED***:
        parser.add_argument('args', metavar='app_label', nargs='+', help='One or more application label.'***REMOVED***

    def handle(self, *app_labels, **options***REMOVED***:
        from django.apps import apps
        ***REMOVED***
            app_configs = [apps.get_app_config(app_label***REMOVED*** for app_label in app_labels***REMOVED***
        except (LookupError, ImportError***REMOVED*** as e:
            raise CommandError("%s. Are you sure your INSTALLED_APPS setting is correct?" % e***REMOVED***
        output = [***REMOVED***
        for app_config in app_configs:
            app_output = self.handle_app_config(app_config, **options***REMOVED***
            if app_output:
                output.append(app_output***REMOVED***
        return '\n'.join(output***REMOVED***

    def handle_app_config(self, app_config, **options***REMOVED***:
        ***REMOVED***
        Perform the command's actions for app_config, an AppConfig instance
        corresponding to an application label given on the command line.
        ***REMOVED***
        raise NotImplementedError(
            "Subclasses of AppCommand must provide"
            "a handle_app_config(***REMOVED*** method."***REMOVED***


class LabelCommand(BaseCommand***REMOVED***:
    ***REMOVED***
    A management command which takes one or more arbitrary arguments
    (labels***REMOVED*** on the command line, and does something with each of
    them.

    Rather than implementing ``handle(***REMOVED***``, subclasses must implement
    ``handle_label(***REMOVED***``, which will be called once for each label.

    If the arguments should be names of installed applications, use
    ``AppCommand`` instead.
    ***REMOVED***
    label = 'label'
    missing_args_message = "Enter at least one %s." % label

    def add_arguments(self, parser***REMOVED***:
        parser.add_argument('args', metavar=self.label, nargs='+'***REMOVED***

    def handle(self, *labels, **options***REMOVED***:
        output = [***REMOVED***
        for label in labels:
            label_output = self.handle_label(label, **options***REMOVED***
            if label_output:
                output.append(label_output***REMOVED***
        return '\n'.join(output***REMOVED***

    def handle_label(self, label, **options***REMOVED***:
        ***REMOVED***
        Perform the command's actions for ``label``, which will be the
        string as given on the command line.
        ***REMOVED***
        raise NotImplementedError('subclasses of LabelCommand must provide a handle_label(***REMOVED*** method'***REMOVED***
