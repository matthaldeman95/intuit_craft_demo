from __future__ import unicode_literals

***REMOVED***
import pkgutil
import sys
from collections import OrderedDict, defaultdict
from importlib import import_module

import django
from django.apps import apps
from django.conf import settings
from django.core.exceptions import ImproperlyConfigured
from django.core.management.base import (
    BaseCommand, CommandError, CommandParser, handle_default_options,
***REMOVED***
from django.core.management.color import color_style
from django.utils import autoreload, lru_cache, six
from django.utils._os import npath, upath
from django.utils.encoding import force_text


def find_commands(management_dir***REMOVED***:
    ***REMOVED***
    Given a path to a management directory, returns a list of all the command
    names that are available.

    Returns an empty list if no commands are defined.
    ***REMOVED***
    command_dir = os.path.join(management_dir, 'commands'***REMOVED***
    return [name for _, name, is_pkg in pkgutil.iter_modules([npath(command_dir***REMOVED******REMOVED******REMOVED***
            if not is_pkg and not name.startswith('_'***REMOVED******REMOVED***


def load_command_class(app_name, name***REMOVED***:
    ***REMOVED***
    Given a command name and an application name, returns the Command
    class instance. All errors raised by the import process
    (ImportError, AttributeError***REMOVED*** are allowed to propagate.
    ***REMOVED***
    module = import_module('%s.management.commands.%s' % (app_name, name***REMOVED******REMOVED***
    return module.Command(***REMOVED***


@lru_cache.lru_cache(maxsize=None***REMOVED***
def get_commands(***REMOVED***:
    ***REMOVED***
    Returns a dictionary mapping command names to their callback applications.

    This works by looking for a management.commands package in django.core, and
    in each installed application -- if a commands package exists, all commands
    in that package are registered.

    Core commands are always included. If a settings module has been
    specified, user-defined commands will also be included.

    The dictionary is in the format {command_name: app_name***REMOVED***. Key-value
    pairs from this dictionary can then be used in calls to
    load_command_class(app_name, command_name***REMOVED***

    If a specific version of a command must be loaded (e.g., with the
    startapp command***REMOVED***, the instantiated module can be placed in the
    dictionary in place of the application name.

    The dictionary is cached on the first call and reused on subsequent
    calls.
    ***REMOVED***
    commands = {name: 'django.core' for name in find_commands(upath(__path__[0***REMOVED******REMOVED******REMOVED******REMOVED***

    if not settings.configured:
        return commands

    for app_config in reversed(list(apps.get_app_configs(***REMOVED******REMOVED******REMOVED***:
        path = os.path.join(app_config.path, 'management'***REMOVED***
        commands.update({name: app_config.name for name in find_commands(path***REMOVED******REMOVED******REMOVED***

    return commands


def call_command(command_name, *args, **options***REMOVED***:
    ***REMOVED***
    Calls the given command, with the given options and args/kwargs.

    This is the primary API you should use for calling specific commands.

    `name` may be a string or a command object. Using a string is preferred
    unless the command object is required for further processing or testing.

    Some examples:
        call_command('migrate'***REMOVED***
        call_command('shell', plain=True***REMOVED***
        call_command('sqlmigrate', 'myapp'***REMOVED***

        from django.core.management.commands import flush
        cmd = flush.Command(***REMOVED***
        call_command(cmd, verbosity=0, interactive=False***REMOVED***
        # Do something with cmd ...
    ***REMOVED***
    if isinstance(command_name, BaseCommand***REMOVED***:
        # Command object passed in.
        command = command_name
        command_name = command.__class__.__module__.split('.'***REMOVED***[-1***REMOVED***
    else:
        # Load the command object by name.
        ***REMOVED***
            app_name = get_commands(***REMOVED***[command_name***REMOVED***
        except KeyError:
            raise CommandError("Unknown command: %r" % command_name***REMOVED***

        if isinstance(app_name, BaseCommand***REMOVED***:
            # If the command is already loaded, use it directly.
            command = app_name
        else:
            command = load_command_class(app_name, command_name***REMOVED***

    # Simulate argument parsing to get the option defaults (see #10080 for details***REMOVED***.
    parser = command.create_parser('', command_name***REMOVED***
    # Use the `dest` option name from the parser option
    opt_mapping = {
        sorted(s_opt.option_strings***REMOVED***[0***REMOVED***.lstrip('-'***REMOVED***.replace('-', '_'***REMOVED***: s_opt.dest
        for s_opt in parser._actions if s_opt.option_strings
***REMOVED***
    arg_options = {opt_mapping.get(key, key***REMOVED***: value for key, value in options.items(***REMOVED******REMOVED***
    defaults = parser.parse_args(args=[force_text(a***REMOVED*** for a in args***REMOVED******REMOVED***
    defaults = dict(defaults._get_kwargs(***REMOVED***, **arg_options***REMOVED***
    # Move positional args out of options to mimic legacy optparse
    args = defaults.pop('args', (***REMOVED******REMOVED***
    if 'skip_checks' not in options:
        defaults['skip_checks'***REMOVED*** = True

    return command.execute(*args, **defaults***REMOVED***


class ManagementUtility(object***REMOVED***:
    ***REMOVED***
    Encapsulates the logic of the django-admin and manage.py utilities.

    A ManagementUtility has a number of commands, which can be manipulated
    by editing the self.commands dictionary.
    ***REMOVED***
    def __init__(self, argv=None***REMOVED***:
        self.argv = argv or sys.argv[:***REMOVED***
        self.prog_name = os.path.basename(self.argv[0***REMOVED******REMOVED***
        self.settings_exception = None

    def main_help_text(self, commands_only=False***REMOVED***:
        ***REMOVED***
        Returns the script's main help text, as a string.
        ***REMOVED***
        if commands_only:
            usage = sorted(get_commands(***REMOVED***.keys(***REMOVED******REMOVED***
        else:
            usage = [
                "",
                "Type '%s help <subcommand>' for help on a specific subcommand." % self.prog_name,
                "",
                "Available subcommands:",
            ***REMOVED***
            commands_dict = defaultdict(lambda: [***REMOVED******REMOVED***
            for name, app in six.iteritems(get_commands(***REMOVED******REMOVED***:
                if app == 'django.core':
                    app = 'django'
                else:
                    app = app.rpartition('.'***REMOVED***[-1***REMOVED***
                commands_dict[app***REMOVED***.append(name***REMOVED***
            style = color_style(***REMOVED***
            for app in sorted(commands_dict.keys(***REMOVED******REMOVED***:
                usage.append(""***REMOVED***
                usage.append(style.NOTICE("[%s***REMOVED***" % app***REMOVED******REMOVED***
                for name in sorted(commands_dict[app***REMOVED******REMOVED***:
                    usage.append("    %s" % name***REMOVED***
            # Output an extra note if settings are not properly configured
            if self.settings_exception is not None:
                usage.append(style.NOTICE(
                    "Note that only Django core commands are listed "
                    "as settings are not properly configured (error: %s***REMOVED***."
                    % self.settings_exception***REMOVED******REMOVED***

        return '\n'.join(usage***REMOVED***

    def fetch_command(self, subcommand***REMOVED***:
        ***REMOVED***
        Tries to fetch the given subcommand, printing a message with the
        appropriate command called from the command line (usually
        "django-admin" or "manage.py"***REMOVED*** if it can't be found.
        ***REMOVED***
        # Get commands outside of try block to prevent swallowing exceptions
        commands = get_commands(***REMOVED***
        ***REMOVED***
            app_name = commands[subcommand***REMOVED***
        except KeyError:
            if os.environ.get('DJANGO_SETTINGS_MODULE'***REMOVED***:
                # If `subcommand` is missing due to misconfigured settings, the
                # following line will retrigger an ImproperlyConfigured exception
                # (get_commands(***REMOVED*** swallows the original one***REMOVED*** so the user is
                # informed about it.
                settings.INSTALLED_APPS
            else:
                sys.stderr.write("No Django settings specified.\n"***REMOVED***
            sys.stderr.write(
                "Unknown command: %r\nType '%s help' for usage.\n"
                % (subcommand, self.prog_name***REMOVED***
            ***REMOVED***
            sys.exit(1***REMOVED***
        if isinstance(app_name, BaseCommand***REMOVED***:
            # If the command is already loaded, use it directly.
            klass = app_name
        else:
            klass = load_command_class(app_name, subcommand***REMOVED***
        return klass

    def autocomplete(self***REMOVED***:
        ***REMOVED***
        Output completion suggestions for BASH.

        The output of this function is passed to BASH's `COMREPLY` variable and
        treated as completion suggestions. `COMREPLY` expects a space
        separated string as the result.

        The `COMP_WORDS` and `COMP_CWORD` BASH environment variables are used
        to get information about the cli input. Please refer to the BASH
        man-page for more information about this variables.

        Subcommand options are saved as pairs. A pair consists of
        the long option string (e.g. '--exclude'***REMOVED*** and a boolean
        value indicating if the option requires arguments. When printing to
        stdout, an equal sign is appended to options which require arguments.

        Note: If debugging this function, it is recommended to write the debug
        output in a separate file. Otherwise the debug output will be treated
        and formatted as potential completion suggestions.
        ***REMOVED***
        # Don't complete if user hasn't sourced bash_completion file.
        if 'DJANGO_AUTO_COMPLETE' not in os.environ:
            return

        cwords = os.environ['COMP_WORDS'***REMOVED***.split(***REMOVED***[1:***REMOVED***
        cword = int(os.environ['COMP_CWORD'***REMOVED******REMOVED***

        ***REMOVED***
            curr = cwords[cword - 1***REMOVED***
        except IndexError:
            curr = ''

        subcommands = list(get_commands(***REMOVED******REMOVED*** + ['help'***REMOVED***
        options = [('--help', False***REMOVED******REMOVED***

        # subcommand
        if cword == 1:
            print(' '.join(sorted(filter(lambda x: x.startswith(curr***REMOVED***, subcommands***REMOVED******REMOVED******REMOVED******REMOVED***
        # subcommand options
        # special case: the 'help' subcommand has no options
        elif cwords[0***REMOVED*** in subcommands and cwords[0***REMOVED*** != 'help':
            subcommand_cls = self.fetch_command(cwords[0***REMOVED******REMOVED***
            # special case: add the names of installed apps to options
            if cwords[0***REMOVED*** in ('dumpdata', 'sqlmigrate', 'sqlsequencereset', 'test'***REMOVED***:
                ***REMOVED***
                    app_configs = apps.get_app_configs(***REMOVED***
                    # Get the last part of the dotted path as the app name.
                    options.extend((app_config.label, 0***REMOVED*** for app_config in app_configs***REMOVED***
                except ImportError:
                    # Fail silently if DJANGO_SETTINGS_MODULE isn't set. The
                    # user will find out once they execute the command.
                    pass
            parser = subcommand_cls.create_parser('', cwords[0***REMOVED******REMOVED***
            options.extend(
                (sorted(s_opt.option_strings***REMOVED***[0***REMOVED***, s_opt.nargs != 0***REMOVED***
                for s_opt in parser._actions if s_opt.option_strings
            ***REMOVED***
            # filter out previously specified options from available options
            prev_opts = [x.split('='***REMOVED***[0***REMOVED*** for x in cwords[1:cword - 1***REMOVED******REMOVED***
            options = [opt for opt in options if opt[0***REMOVED*** not in prev_opts***REMOVED***

            # filter options by current input
            options = sorted((k, v***REMOVED*** for k, v in options if k.startswith(curr***REMOVED******REMOVED***
            for option in options:
                opt_label = option[0***REMOVED***
                # append '=' to options which require args
                if option[1***REMOVED***:
                    opt_label += '='
                print(opt_label***REMOVED***
        # Exit code of the bash completion function is never passed back to
        # the user, so it's safe to always exit with 0.
        # For more details see #25420.
        sys.exit(0***REMOVED***

    def execute(self***REMOVED***:
        ***REMOVED***
        Given the command-line arguments, this figures out which subcommand is
        being run, creates a parser appropriate to that command, and runs it.
        ***REMOVED***
        ***REMOVED***
            subcommand = self.argv[1***REMOVED***
        except IndexError:
            subcommand = 'help'  # Display help if no arguments were given.

        # Preprocess options to extract --settings and --pythonpath.
        # These options could affect the commands that are available, so they
        # must be processed early.
        parser = CommandParser(None, usage="%(prog***REMOVED***s subcommand [options***REMOVED*** [args***REMOVED***", add_help=False***REMOVED***
        parser.add_argument('--settings'***REMOVED***
        parser.add_argument('--pythonpath'***REMOVED***
        parser.add_argument('args', nargs='*'***REMOVED***  # catch-all
        ***REMOVED***
            options, args = parser.parse_known_args(self.argv[2:***REMOVED******REMOVED***
            handle_default_options(options***REMOVED***
        except CommandError:
            pass  # Ignore any option errors at this point.

        no_settings_commands = [
            'help', 'version', '--help', '--version', '-h',
            'compilemessages', 'makemessages',
            'startapp', 'startproject',
        ***REMOVED***

        ***REMOVED***
            settings.INSTALLED_APPS
        except ImproperlyConfigured as exc:
            self.settings_exception = exc
            # A handful of built-in management commands work without settings.
            # Load the default settings -- where INSTALLED_APPS is empty.
            if subcommand in no_settings_commands:
                settings.configure(***REMOVED***

        if settings.configured:
            # Start the auto-reloading dev server even if the code is broken.
            # The hardcoded condition is a code smell but we can't rely on a
            # flag on the command class because we haven't located it yet.
            if subcommand == 'runserver' and '--noreload' not in self.argv:
                ***REMOVED***
                    autoreload.check_errors(django.setup***REMOVED***(***REMOVED***
                except Exception:
                    # The exception will be raised later in the child process
                    # started by the autoreloader. Pretend it didn't happen by
                    # loading an empty list of applications.
                    apps.all_models = defaultdict(OrderedDict***REMOVED***
                    apps.app_configs = OrderedDict(***REMOVED***
                    apps.apps_ready = apps.models_ready = apps.ready = True

            # In all other cases, django.setup(***REMOVED*** is required to succeed.
            else:
                django.setup(***REMOVED***

        self.autocomplete(***REMOVED***

        if subcommand == 'help':
            if '--commands' in args:
                sys.stdout.write(self.main_help_text(commands_only=True***REMOVED*** + '\n'***REMOVED***
            elif len(options.args***REMOVED*** < 1:
                sys.stdout.write(self.main_help_text(***REMOVED*** + '\n'***REMOVED***
            else:
                self.fetch_command(options.args[0***REMOVED******REMOVED***.print_help(self.prog_name, options.args[0***REMOVED******REMOVED***
        # Special-cases: We want 'django-admin --version' and
        # 'django-admin --help' to work, for backwards compatibility.
        elif subcommand == 'version' or self.argv[1:***REMOVED*** == ['--version'***REMOVED***:
            sys.stdout.write(django.get_version(***REMOVED*** + '\n'***REMOVED***
        elif self.argv[1:***REMOVED*** in (['--help'***REMOVED***, ['-h'***REMOVED******REMOVED***:
            sys.stdout.write(self.main_help_text(***REMOVED*** + '\n'***REMOVED***
        else:
            self.fetch_command(subcommand***REMOVED***.run_from_argv(self.argv***REMOVED***


def execute_from_command_line(argv=None***REMOVED***:
    ***REMOVED***
    A simple method that runs a ManagementUtility.
    ***REMOVED***
    utility = ManagementUtility(argv***REMOVED***
    utility.execute(***REMOVED***
