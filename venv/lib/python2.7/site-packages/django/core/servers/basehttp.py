***REMOVED***
HTTP server that implements the Python WSGI protocol (PEP 333, rev 1.21***REMOVED***.

Based on wsgiref.simple_server which is part of the standard library since 2.5.

This is a simple server for use in testing or debugging Django apps. It hasn't
been reviewed for security issues. DON'T USE IT FOR PRODUCTION USE!
***REMOVED***

from __future__ import unicode_literals

import logging
import socket
import sys
from wsgiref import simple_server

from django.core.exceptions import ImproperlyConfigured
from django.core.handlers.wsgi import ISO_8859_1, UTF_8
from django.core.wsgi import get_wsgi_application
from django.utils import six
from django.utils.encoding import uri_to_iri
from django.utils.module_loading import import_string
from django.utils.six.moves import socketserver

__all__ = ('WSGIServer', 'WSGIRequestHandler'***REMOVED***

logger = logging.getLogger('django.server'***REMOVED***


def get_internal_wsgi_application(***REMOVED***:
    ***REMOVED***
    Loads and returns the WSGI application as configured by the user in
    ``settings.WSGI_APPLICATION``. With the default ``startproject`` layout,
    this will be the ``application`` object in ``projectname/wsgi.py``.

    This function, and the ``WSGI_APPLICATION`` setting itself, are only useful
    for Django's internal server (runserver***REMOVED***; external WSGI servers should just
    be configured to point to the correct application object directly.

    If settings.WSGI_APPLICATION is not set (is ``None``***REMOVED***, we just return
    whatever ``django.core.wsgi.get_wsgi_application`` returns.
    ***REMOVED***
    from django.conf import settings
    app_path = getattr(settings, 'WSGI_APPLICATION'***REMOVED***
    if app_path is None:
        return get_wsgi_application(***REMOVED***

    ***REMOVED***
        return import_string(app_path***REMOVED***
    except ImportError as e:
        msg = (
            "WSGI application '%(app_path***REMOVED***s' could not be loaded; "
            "Error importing module: '%(exception***REMOVED***s'" % ({
                'app_path': app_path,
                'exception': e,
        ***REMOVED******REMOVED***
        ***REMOVED***
        six.reraise(ImproperlyConfigured, ImproperlyConfigured(msg***REMOVED***,
                    sys.exc_info(***REMOVED***[2***REMOVED******REMOVED***


def is_broken_pipe_error(***REMOVED***:
    exc_type, exc_value = sys.exc_info(***REMOVED***[:2***REMOVED***
    return issubclass(exc_type, socket.error***REMOVED*** and exc_value.args[0***REMOVED*** == 32


class WSGIServer(simple_server.WSGIServer, object***REMOVED***:
    ***REMOVED***BaseHTTPServer that implements the Python WSGI protocol***REMOVED***

    request_queue_size = 10

    def __init__(self, *args, **kwargs***REMOVED***:
        if kwargs.pop('ipv6', False***REMOVED***:
            self.address_family = socket.AF_INET6
        self.allow_reuse_address = kwargs.pop('allow_reuse_address', True***REMOVED***
        super(WSGIServer, self***REMOVED***.__init__(*args, **kwargs***REMOVED***

    def server_bind(self***REMOVED***:
        ***REMOVED***Override server_bind to store the server name.***REMOVED***
        super(WSGIServer, self***REMOVED***.server_bind(***REMOVED***
        self.setup_environ(***REMOVED***

    def handle_error(self, request, client_address***REMOVED***:
        if is_broken_pipe_error(***REMOVED***:
            logger.info("- Broken pipe from %s\n", client_address***REMOVED***
        else:
            super(WSGIServer, self***REMOVED***.handle_error(request, client_address***REMOVED***


# Inheriting from object required on Python 2.
class ServerHandler(simple_server.ServerHandler, object***REMOVED***:
    def handle_error(self***REMOVED***:
        # Ignore broken pipe errors, otherwise pass on
        if not is_broken_pipe_error(***REMOVED***:
            super(ServerHandler, self***REMOVED***.handle_error(***REMOVED***


class WSGIRequestHandler(simple_server.WSGIRequestHandler, object***REMOVED***:
    def address_string(self***REMOVED***:
        # Short-circuit parent method to not call socket.getfqdn
        return self.client_address[0***REMOVED***

    def log_message(self, format, *args***REMOVED***:
        extra = {
            'request': self.request,
            'server_time': self.log_date_time_string(***REMOVED***,
    ***REMOVED***
        if args[1***REMOVED***[0***REMOVED*** == '4':
            # 0x16 = Handshake, 0x03 = SSL 3.0 or TLS 1.x
            if args[0***REMOVED***.startswith(str('\x16\x03'***REMOVED******REMOVED***:
                extra['status_code'***REMOVED*** = 500
                logger.error(
                    "You're accessing the development server over HTTPS, but "
                    "it only supports HTTP.\n", extra=extra,
                ***REMOVED***
                return

        if args[1***REMOVED***.isdigit(***REMOVED*** and len(args[1***REMOVED******REMOVED*** == 3:
            status_code = int(args[1***REMOVED******REMOVED***
            extra['status_code'***REMOVED*** = status_code

            if status_code >= 500:
                level = logger.error
            elif status_code >= 400:
                level = logger.warning
            else:
                level = logger.info
        else:
            level = logger.info

        level(format, *args, extra=extra***REMOVED***

    def get_environ(self***REMOVED***:
        # Strip all headers with underscores in the name before constructing
        # the WSGI environ. This prevents header-spoofing based on ambiguity
        # between underscores and dashes both normalized to underscores in WSGI
        # env vars. Nginx and Apache 2.4+ both do this as well.
        for k, v in self.headers.items(***REMOVED***:
            if '_' in k:
                del self.headers[k***REMOVED***

        env = super(WSGIRequestHandler, self***REMOVED***.get_environ(***REMOVED***

        path = self.path
        if '?' in path:
            path = path.partition('?'***REMOVED***[0***REMOVED***

        path = uri_to_iri(path***REMOVED***.encode(UTF_8***REMOVED***
        # Under Python 3, non-ASCII values in the WSGI environ are arbitrarily
        # decoded with ISO-8859-1. We replicate this behavior here.
        # Refs comment in `get_bytes_from_wsgi(***REMOVED***`.
        env['PATH_INFO'***REMOVED*** = path.decode(ISO_8859_1***REMOVED*** if six.PY3 else path

        return env

    def handle(self***REMOVED***:
        ***REMOVED***Copy of WSGIRequestHandler, but with different ServerHandler***REMOVED***

        self.raw_requestline = self.rfile.readline(65537***REMOVED***
        if len(self.raw_requestline***REMOVED*** > 65536:
            self.requestline = ''
            self.request_version = ''
            self.command = ''
            self.send_error(414***REMOVED***
            return

        if not self.parse_request(***REMOVED***:  # An error code has been sent, just exit
            return

        handler = ServerHandler(
            self.rfile, self.wfile, self.get_stderr(***REMOVED***, self.get_environ(***REMOVED***
        ***REMOVED***
        handler.request_handler = self      # backpointer for logging
        handler.run(self.server.get_app(***REMOVED******REMOVED***


def run(addr, port, wsgi_handler, ipv6=False, threading=False***REMOVED***:
    server_address = (addr, port***REMOVED***
    if threading:
        httpd_cls = type(str('WSGIServer'***REMOVED***, (socketserver.ThreadingMixIn, WSGIServer***REMOVED***, {***REMOVED******REMOVED***
    else:
        httpd_cls = WSGIServer
    httpd = httpd_cls(server_address, WSGIRequestHandler, ipv6=ipv6***REMOVED***
    if threading:
        # ThreadingMixIn.daemon_threads indicates how threads will behave on an
        # abrupt shutdown; like quitting the server by the user or restarting
        # by the auto-reloader. True means the server will not wait for thread
        # termination before it quits. This will make auto-reloader faster
        # and will prevent the need to kill the server manually if a thread
        # isn't terminating correctly.
        httpd.daemon_threads = True
    httpd.set_app(wsgi_handler***REMOVED***
    httpd.serve_forever(***REMOVED***
