import collections
from math import ceil

from django.utils import six
from django.utils.functional import cached_property


class InvalidPage(Exception***REMOVED***:
    pass


class PageNotAnInteger(InvalidPage***REMOVED***:
    pass


class EmptyPage(InvalidPage***REMOVED***:
    pass


class Paginator(object***REMOVED***:

    def __init__(self, object_list, per_page, orphans=0,
                 allow_empty_first_page=True***REMOVED***:
        self.object_list = object_list
        self.per_page = int(per_page***REMOVED***
        self.orphans = int(orphans***REMOVED***
        self.allow_empty_first_page = allow_empty_first_page

    def validate_number(self, number***REMOVED***:
        ***REMOVED***
        Validates the given 1-based page number.
        ***REMOVED***
        ***REMOVED***
            number = int(number***REMOVED***
        except (TypeError, ValueError***REMOVED***:
            raise PageNotAnInteger('That page number is not an integer'***REMOVED***
        if number < 1:
            raise EmptyPage('That page number is less than 1'***REMOVED***
        if number > self.num_pages:
            if number == 1 and self.allow_empty_first_page:
                pass
            else:
                raise EmptyPage('That page contains no results'***REMOVED***
        return number

    def page(self, number***REMOVED***:
        ***REMOVED***
        Returns a Page object for the given 1-based page number.
        ***REMOVED***
        number = self.validate_number(number***REMOVED***
        bottom = (number - 1***REMOVED*** * self.per_page
        top = bottom + self.per_page
        if top + self.orphans >= self.count:
            top = self.count
        return self._get_page(self.object_list[bottom:top***REMOVED***, number, self***REMOVED***

    def _get_page(self, *args, **kwargs***REMOVED***:
        ***REMOVED***
        Returns an instance of a single page.

        This hook can be used by subclasses to use an alternative to the
        standard :cls:`Page` object.
        ***REMOVED***
        return Page(*args, **kwargs***REMOVED***

    @cached_property
    def count(self***REMOVED***:
        ***REMOVED***
        Returns the total number of objects, across all pages.
        ***REMOVED***
        ***REMOVED***
            return self.object_list.count(***REMOVED***
        except (AttributeError, TypeError***REMOVED***:
            # AttributeError if object_list has no count(***REMOVED*** method.
            # TypeError if object_list.count(***REMOVED*** requires arguments
            # (i.e. is of type list***REMOVED***.
            return len(self.object_list***REMOVED***

    @cached_property
    def num_pages(self***REMOVED***:
        ***REMOVED***
        Returns the total number of pages.
        ***REMOVED***
        if self.count == 0 and not self.allow_empty_first_page:
            return 0
        hits = max(1, self.count - self.orphans***REMOVED***
        return int(ceil(hits / float(self.per_page***REMOVED******REMOVED******REMOVED***

    @property
    def page_range(self***REMOVED***:
        ***REMOVED***
        Returns a 1-based range of pages for iterating through within
        a template for loop.
        ***REMOVED***
        return six.moves.range(1, self.num_pages + 1***REMOVED***


QuerySetPaginator = Paginator   # For backwards-compatibility.


class Page(collections.Sequence***REMOVED***:

    def __init__(self, object_list, number, paginator***REMOVED***:
        self.object_list = object_list
        self.number = number
        self.paginator = paginator

    def __repr__(self***REMOVED***:
        return '<Page %s of %s>' % (self.number, self.paginator.num_pages***REMOVED***

    def __len__(self***REMOVED***:
        return len(self.object_list***REMOVED***

    def __getitem__(self, index***REMOVED***:
        if not isinstance(index, (slice,***REMOVED*** + six.integer_types***REMOVED***:
            raise TypeError
        # The object_list is converted to a list so that if it was a QuerySet
        # it won't be a database hit per __getitem__.
        if not isinstance(self.object_list, list***REMOVED***:
            self.object_list = list(self.object_list***REMOVED***
        return self.object_list[index***REMOVED***

    def has_next(self***REMOVED***:
        return self.number < self.paginator.num_pages

    def has_previous(self***REMOVED***:
        return self.number > 1

    def has_other_pages(self***REMOVED***:
        return self.has_previous(***REMOVED*** or self.has_next(***REMOVED***

    def next_page_number(self***REMOVED***:
        return self.paginator.validate_number(self.number + 1***REMOVED***

    def previous_page_number(self***REMOVED***:
        return self.paginator.validate_number(self.number - 1***REMOVED***

    def start_index(self***REMOVED***:
        ***REMOVED***
        Returns the 1-based index of the first object on this page,
        relative to total objects in the paginator.
        ***REMOVED***
        # Special case, return zero if no items.
        if self.paginator.count == 0:
            return 0
        return (self.paginator.per_page * (self.number - 1***REMOVED******REMOVED*** + 1

    def end_index(self***REMOVED***:
        ***REMOVED***
        Returns the 1-based index of the last object on this page,
        relative to total objects found (hits***REMOVED***.
        ***REMOVED***
        # Special case for the last page because there can be orphans.
        if self.number == self.paginator.num_pages:
            return self.paginator.count
        return self.number * self.paginator.per_page
