from __future__ import unicode_literals

import re

from django.core.exceptions import ValidationError
from django.utils import six
from django.utils.deconstruct import deconstructible
from django.utils.encoding import force_text
from django.utils.functional import SimpleLazyObject
from django.utils.ipv6 import is_valid_ipv6_address
from django.utils.six.moves.urllib.parse import urlsplit, urlunsplit
from django.utils.translation import ugettext_lazy as _, ungettext_lazy

# These values, if given to validate(***REMOVED***, will trigger the self.required check.
EMPTY_VALUES = (None, '', [***REMOVED***, (***REMOVED***, {***REMOVED******REMOVED***


def _lazy_re_compile(regex, flags=0***REMOVED***:
    ***REMOVED***Lazily compile a regex with flags.***REMOVED***
    def _compile(***REMOVED***:
        # Compile the regex if it was not passed pre-compiled.
        if isinstance(regex, six.string_types***REMOVED***:
            return re.compile(regex, flags***REMOVED***
        else:
            assert not flags, "flags must be empty if regex is passed pre-compiled"
            return regex
    return SimpleLazyObject(_compile***REMOVED***


@deconstructible
class RegexValidator(object***REMOVED***:
    regex = ''
    message = _('Enter a valid value.'***REMOVED***
    code = 'invalid'
    inverse_match = False
    flags = 0

    def __init__(self, regex=None, message=None, code=None, inverse_match=None, flags=None***REMOVED***:
        if regex is not None:
            self.regex = regex
        if message is not None:
            self.message = message
        if code is not None:
            self.code = code
        if inverse_match is not None:
            self.inverse_match = inverse_match
        if flags is not None:
            self.flags = flags
        if self.flags and not isinstance(self.regex, six.string_types***REMOVED***:
            raise TypeError("If the flags are set, regex must be a regular expression string."***REMOVED***

        self.regex = _lazy_re_compile(self.regex, self.flags***REMOVED***

    def __call__(self, value***REMOVED***:
        ***REMOVED***
        Validates that the input matches the regular expression
        if inverse_match is False, otherwise raises ValidationError.
        ***REMOVED***
        if not (self.inverse_match is not bool(self.regex.search(
                force_text(value***REMOVED******REMOVED******REMOVED******REMOVED***:
            raise ValidationError(self.message, code=self.code***REMOVED***

    def __eq__(self, other***REMOVED***:
        return (
            isinstance(other, RegexValidator***REMOVED*** and
            self.regex.pattern == other.regex.pattern and
            self.regex.flags == other.regex.flags and
            (self.message == other.message***REMOVED*** and
            (self.code == other.code***REMOVED*** and
            (self.inverse_match == other.inverse_match***REMOVED***
        ***REMOVED***

    def __ne__(self, other***REMOVED***:
        return not (self == other***REMOVED***


@deconstructible
class URLValidator(RegexValidator***REMOVED***:
    ul = '\u00a1-\uffff'  # unicode letters range (must be a unicode string, not a raw string***REMOVED***

    # IP patterns
    ipv4_re = r'(?:25[0-5***REMOVED***|2[0-4***REMOVED***\d|[0-1***REMOVED***?\d?\d***REMOVED***(?:\.(?:25[0-5***REMOVED***|2[0-4***REMOVED***\d|[0-1***REMOVED***?\d?\d***REMOVED******REMOVED***{3***REMOVED***'
    ipv6_re = r'\[[0-9a-f:\.***REMOVED***+\***REMOVED***'  # (simple regex, validated later***REMOVED***

    # Host patterns
    hostname_re = r'[a-z' + ul + r'0-9***REMOVED***(?:[a-z' + ul + r'0-9-***REMOVED***{0,61***REMOVED***[a-z' + ul + r'0-9***REMOVED******REMOVED***?'
    # Max length for domain name labels is 63 characters per RFC 1034 sec. 3.1
    domain_re = r'(?:\.(?!-***REMOVED***[a-z' + ul + r'0-9-***REMOVED***{1,63***REMOVED***(?<!-***REMOVED******REMOVED****'
    tld_re = (
        '\.'                                # dot
        '(?!-***REMOVED***'                             # can't start with a dash
        '(?:[a-z' + ul + '-***REMOVED***{2,63***REMOVED***'         # domain label
        '|xn--[a-z0-9***REMOVED***{1,59***REMOVED******REMOVED***'              # or punycode label
        '(?<!-***REMOVED***'                            # can't end with a dash
        '\.?'                               # may have a trailing dot
    ***REMOVED***
    host_re = '(' + hostname_re + domain_re + tld_re + '|localhost***REMOVED***'

    regex = _lazy_re_compile(
        r'^(?:[a-z0-9\.\-\+***REMOVED*******REMOVED***://'  # scheme is validated separately
        r'(?:\S+(?::\S****REMOVED***?@***REMOVED***?'  # user:pass authentication
        r'(?:' + ipv4_re + '|' + ipv6_re + '|' + host_re + '***REMOVED***'
        r'(?::\d{2,5***REMOVED******REMOVED***?'  # port
        r'(?:[/?#***REMOVED***[^\s***REMOVED*******REMOVED***?'  # resource path
        r'\Z', re.IGNORECASE***REMOVED***
    message = _('Enter a valid URL.'***REMOVED***
    schemes = ['http', 'https', 'ftp', 'ftps'***REMOVED***

    def __init__(self, schemes=None, **kwargs***REMOVED***:
        super(URLValidator, self***REMOVED***.__init__(**kwargs***REMOVED***
        if schemes is not None:
            self.schemes = schemes

    def __call__(self, value***REMOVED***:
        value = force_text(value***REMOVED***
        # Check first if the scheme is valid
        scheme = value.split('://'***REMOVED***[0***REMOVED***.lower(***REMOVED***
        if scheme not in self.schemes:
            raise ValidationError(self.message, code=self.code***REMOVED***

        # Then check full URL
        ***REMOVED***
            super(URLValidator, self***REMOVED***.__call__(value***REMOVED***
        except ValidationError as e:
            # Trivial case failed. Try for possible IDN domain
            if value:
                ***REMOVED***
                    scheme, netloc, path, query, fragment = urlsplit(value***REMOVED***
                except ValueError:  # for example, "Invalid IPv6 URL"
                    raise ValidationError(self.message, code=self.code***REMOVED***
                ***REMOVED***
                    netloc = netloc.encode('idna'***REMOVED***.decode('ascii'***REMOVED***  # IDN -> ACE
                except UnicodeError:  # invalid domain part
                    raise e
                url = urlunsplit((scheme, netloc, path, query, fragment***REMOVED******REMOVED***
                super(URLValidator, self***REMOVED***.__call__(url***REMOVED***
            else:
                raise
        else:
            # Now verify IPv6 in the netloc part
            host_match = re.search(r'^\[(.+***REMOVED***\***REMOVED***(?::\d{2,5***REMOVED******REMOVED***?$', urlsplit(value***REMOVED***.netloc***REMOVED***
            if host_match:
                potential_ip = host_match.groups(***REMOVED***[0***REMOVED***
                ***REMOVED***
                    validate_ipv6_address(potential_ip***REMOVED***
                except ValidationError:
                    raise ValidationError(self.message, code=self.code***REMOVED***
            url = value

        # The maximum length of a full host name is 253 characters per RFC 1034
        # section 3.1. It's defined to be 255 bytes or less, but this includes
        # one byte for the length of the name and one byte for the trailing dot
        # that's used to indicate absolute names in DNS.
        if len(urlsplit(value***REMOVED***.netloc***REMOVED*** > 253:
            raise ValidationError(self.message, code=self.code***REMOVED***

integer_validator = RegexValidator(
    _lazy_re_compile('^-?\d+\Z'***REMOVED***,
    message=_('Enter a valid integer.'***REMOVED***,
    code='invalid',
***REMOVED***


def validate_integer(value***REMOVED***:
    return integer_validator(value***REMOVED***


@deconstructible
class EmailValidator(object***REMOVED***:
    message = _('Enter a valid email address.'***REMOVED***
    code = 'invalid'
    user_regex = _lazy_re_compile(
        r"(^[-!#$%&'*+/=?^_`{***REMOVED***|~0-9A-Z***REMOVED***+(\.[-!#$%&'*+/=?^_`{***REMOVED***|~0-9A-Z***REMOVED***+***REMOVED****\Z"  # dot-atom
        r'|^"([\001-\010\013\014\016-\037!#-\[\***REMOVED***-\177***REMOVED***|\\[\001-\011\013\014\016-\177***REMOVED******REMOVED****"\Z***REMOVED***',  # quoted-string
        re.IGNORECASE***REMOVED***
    domain_regex = _lazy_re_compile(
        # max length for domain name labels is 63 characters per RFC 1034
        r'((?:[A-Z0-9***REMOVED***(?:[A-Z0-9-***REMOVED***{0,61***REMOVED***[A-Z0-9***REMOVED******REMOVED***?\.***REMOVED***+***REMOVED***(?:[A-Z0-9-***REMOVED***{2,63***REMOVED***(?<!-***REMOVED******REMOVED***\Z',
        re.IGNORECASE***REMOVED***
    literal_regex = _lazy_re_compile(
        # literal form, ipv4 or ipv6 address (SMTP 4.1.3***REMOVED***
        r'\[([A-f0-9:\.***REMOVED***+***REMOVED***\***REMOVED***\Z',
        re.IGNORECASE***REMOVED***
    domain_whitelist = ['localhost'***REMOVED***

    def __init__(self, message=None, code=None, whitelist=None***REMOVED***:
        if message is not None:
            self.message = message
        if code is not None:
            self.code = code
        if whitelist is not None:
            self.domain_whitelist = whitelist

    def __call__(self, value***REMOVED***:
        value = force_text(value***REMOVED***

        if not value or '@' not in value:
            raise ValidationError(self.message, code=self.code***REMOVED***

        user_part, domain_part = value.rsplit('@', 1***REMOVED***

        if not self.user_regex.match(user_part***REMOVED***:
            raise ValidationError(self.message, code=self.code***REMOVED***

        if (domain_part not in self.domain_whitelist and
                not self.validate_domain_part(domain_part***REMOVED******REMOVED***:
            # Try for possible IDN domain-part
            ***REMOVED***
                domain_part = domain_part.encode('idna'***REMOVED***.decode('ascii'***REMOVED***
                if self.validate_domain_part(domain_part***REMOVED***:
                    return
            except UnicodeError:
                pass
            raise ValidationError(self.message, code=self.code***REMOVED***

    def validate_domain_part(self, domain_part***REMOVED***:
        if self.domain_regex.match(domain_part***REMOVED***:
            return True

        literal_match = self.literal_regex.match(domain_part***REMOVED***
        if literal_match:
            ip_address = literal_match.group(1***REMOVED***
            ***REMOVED***
                validate_ipv46_address(ip_address***REMOVED***
                return True
            except ValidationError:
                pass
        return False

    def __eq__(self, other***REMOVED***:
        return (
            isinstance(other, EmailValidator***REMOVED*** and
            (self.domain_whitelist == other.domain_whitelist***REMOVED*** and
            (self.message == other.message***REMOVED*** and
            (self.code == other.code***REMOVED***
        ***REMOVED***

validate_email = EmailValidator(***REMOVED***

slug_re = _lazy_re_compile(r'^[-a-zA-Z0-9_***REMOVED***+\Z'***REMOVED***
validate_slug = RegexValidator(
    slug_re,
    _("Enter a valid 'slug' consisting of letters, numbers, underscores or hyphens."***REMOVED***,
    'invalid'
***REMOVED***

slug_unicode_re = _lazy_re_compile(r'^[-\w***REMOVED***+\Z', re.U***REMOVED***
validate_unicode_slug = RegexValidator(
    slug_unicode_re,
    _("Enter a valid 'slug' consisting of Unicode letters, numbers, underscores, or hyphens."***REMOVED***,
    'invalid'
***REMOVED***

ipv4_re = _lazy_re_compile(r'^(25[0-5***REMOVED***|2[0-4***REMOVED***\d|[0-1***REMOVED***?\d?\d***REMOVED***(\.(25[0-5***REMOVED***|2[0-4***REMOVED***\d|[0-1***REMOVED***?\d?\d***REMOVED******REMOVED***{3***REMOVED***\Z'***REMOVED***
validate_ipv4_address = RegexValidator(ipv4_re, _('Enter a valid IPv4 address.'***REMOVED***, 'invalid'***REMOVED***


def validate_ipv6_address(value***REMOVED***:
    if not is_valid_ipv6_address(value***REMOVED***:
        raise ValidationError(_('Enter a valid IPv6 address.'***REMOVED***, code='invalid'***REMOVED***


def validate_ipv46_address(value***REMOVED***:
    ***REMOVED***
        validate_ipv4_address(value***REMOVED***
    except ValidationError:
        ***REMOVED***
            validate_ipv6_address(value***REMOVED***
        except ValidationError:
            raise ValidationError(_('Enter a valid IPv4 or IPv6 address.'***REMOVED***, code='invalid'***REMOVED***

ip_address_validator_map = {
    'both': ([validate_ipv46_address***REMOVED***, _('Enter a valid IPv4 or IPv6 address.'***REMOVED******REMOVED***,
    'ipv4': ([validate_ipv4_address***REMOVED***, _('Enter a valid IPv4 address.'***REMOVED******REMOVED***,
    'ipv6': ([validate_ipv6_address***REMOVED***, _('Enter a valid IPv6 address.'***REMOVED******REMOVED***,
***REMOVED***


def ip_address_validators(protocol, unpack_ipv4***REMOVED***:
    ***REMOVED***
    Depending on the given parameters returns the appropriate validators for
    the GenericIPAddressField.

    This code is here, because it is exactly the same for the model and the form field.
    ***REMOVED***
    if protocol != 'both' and unpack_ipv4:
        raise ValueError(
            "You can only use `unpack_ipv4` if `protocol` is set to 'both'"***REMOVED***
    ***REMOVED***
        return ip_address_validator_map[protocol.lower(***REMOVED******REMOVED***
    except KeyError:
        raise ValueError("The protocol '%s' is unknown. Supported: %s"
                         % (protocol, list(ip_address_validator_map***REMOVED******REMOVED******REMOVED***


def int_list_validator(sep=',', message=None, code='invalid', allow_negative=False***REMOVED***:
    regexp = _lazy_re_compile('^%(neg***REMOVED***s\d+(?:%(sep***REMOVED***s%(neg***REMOVED***s\d+***REMOVED****\Z' % {
        'neg': '(-***REMOVED***?' if allow_negative else '',
        'sep': re.escape(sep***REMOVED***,
***REMOVED******REMOVED***
    return RegexValidator(regexp, message=message, code=code***REMOVED***


validate_comma_separated_integer_list = int_list_validator(
    message=_('Enter only digits separated by commas.'***REMOVED***,
***REMOVED***


@deconstructible
class BaseValidator(object***REMOVED***:
    message = _('Ensure this value is %(limit_value***REMOVED***s (it is %(show_value***REMOVED***s***REMOVED***.'***REMOVED***
    code = 'limit_value'

    def __init__(self, limit_value, message=None***REMOVED***:
        self.limit_value = limit_value
        if message:
            self.message = message

    def __call__(self, value***REMOVED***:
        cleaned = self.clean(value***REMOVED***
        params = {'limit_value': self.limit_value, 'show_value': cleaned, 'value': value***REMOVED***
        if self.compare(cleaned, self.limit_value***REMOVED***:
            raise ValidationError(self.message, code=self.code, params=params***REMOVED***

    def __eq__(self, other***REMOVED***:
        return (
            isinstance(other, self.__class__***REMOVED*** and
            self.limit_value == other.limit_value and
            self.message == other.message and
            self.code == other.code
        ***REMOVED***

    def compare(self, a, b***REMOVED***:
        return a is not b

    def clean(self, x***REMOVED***:
        return x


@deconstructible
class MaxValueValidator(BaseValidator***REMOVED***:
    message = _('Ensure this value is less than or equal to %(limit_value***REMOVED***s.'***REMOVED***
    code = 'max_value'

    def compare(self, a, b***REMOVED***:
        return a > b


@deconstructible
class MinValueValidator(BaseValidator***REMOVED***:
    message = _('Ensure this value is greater than or equal to %(limit_value***REMOVED***s.'***REMOVED***
    code = 'min_value'

    def compare(self, a, b***REMOVED***:
        return a < b


@deconstructible
class MinLengthValidator(BaseValidator***REMOVED***:
    message = ungettext_lazy(
        'Ensure this value has at least %(limit_value***REMOVED***d character (it has %(show_value***REMOVED***d***REMOVED***.',
        'Ensure this value has at least %(limit_value***REMOVED***d characters (it has %(show_value***REMOVED***d***REMOVED***.',
        'limit_value'***REMOVED***
    code = 'min_length'

    def compare(self, a, b***REMOVED***:
        return a < b

    def clean(self, x***REMOVED***:
        return len(x***REMOVED***


@deconstructible
class MaxLengthValidator(BaseValidator***REMOVED***:
    message = ungettext_lazy(
        'Ensure this value has at most %(limit_value***REMOVED***d character (it has %(show_value***REMOVED***d***REMOVED***.',
        'Ensure this value has at most %(limit_value***REMOVED***d characters (it has %(show_value***REMOVED***d***REMOVED***.',
        'limit_value'***REMOVED***
    code = 'max_length'

    def compare(self, a, b***REMOVED***:
        return a > b

    def clean(self, x***REMOVED***:
        return len(x***REMOVED***


@deconstructible
class DecimalValidator(object***REMOVED***:
    ***REMOVED***
    Validate that the input does not exceed the maximum number of digits
    expected, otherwise raise ValidationError.
    ***REMOVED***
    messages = {
        'max_digits': ungettext_lazy(
            'Ensure that there are no more than %(max***REMOVED***s digit in total.',
            'Ensure that there are no more than %(max***REMOVED***s digits in total.',
            'max'
        ***REMOVED***,
        'max_decimal_places': ungettext_lazy(
            'Ensure that there are no more than %(max***REMOVED***s decimal place.',
            'Ensure that there are no more than %(max***REMOVED***s decimal places.',
            'max'
        ***REMOVED***,
        'max_whole_digits': ungettext_lazy(
            'Ensure that there are no more than %(max***REMOVED***s digit before the decimal point.',
            'Ensure that there are no more than %(max***REMOVED***s digits before the decimal point.',
            'max'
        ***REMOVED***,
***REMOVED***

    def __init__(self, max_digits, decimal_places***REMOVED***:
        self.max_digits = max_digits
        self.decimal_places = decimal_places

    def __call__(self, value***REMOVED***:
        digit_tuple, exponent = value.as_tuple(***REMOVED***[1:***REMOVED***
        decimals = abs(exponent***REMOVED***
        # digit_tuple doesn't include any leading zeros.
        digits = len(digit_tuple***REMOVED***
        if decimals > digits:
            # We have leading zeros up to or past the decimal point. Count
            # everything past the decimal point as a digit. We do not count
            # 0 before the decimal point as a digit since that would mean
            # we would not allow max_digits = decimal_places.
            digits = decimals
        whole_digits = digits - decimals

        if self.max_digits is not None and digits > self.max_digits:
            raise ValidationError(
                self.messages['max_digits'***REMOVED***,
                code='max_digits',
                params={'max': self.max_digits***REMOVED***,
            ***REMOVED***
        if self.decimal_places is not None and decimals > self.decimal_places:
            raise ValidationError(
                self.messages['max_decimal_places'***REMOVED***,
                code='max_decimal_places',
                params={'max': self.decimal_places***REMOVED***,
            ***REMOVED***
        if (self.max_digits is not None and self.decimal_places is not None and
                whole_digits > (self.max_digits - self.decimal_places***REMOVED******REMOVED***:
            raise ValidationError(
                self.messages['max_whole_digits'***REMOVED***,
                code='max_whole_digits',
                params={'max': (self.max_digits - self.decimal_places***REMOVED******REMOVED***,
            ***REMOVED***

    def __eq__(self, other***REMOVED***:
        return (
            isinstance(other, self.__class__***REMOVED*** and
            self.max_digits == other.max_digits and
            self.decimal_places == other.decimal_places
        ***REMOVED***
