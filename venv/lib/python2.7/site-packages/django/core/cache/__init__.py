***REMOVED***
Caching framework.

This package defines set of cache backends that all conform to a simple API.
In a nutshell, a cache is a set of values -- which can be any object that
may be pickled -- identified by string keys.  For the complete API, see
the abstract BaseCache class in django.core.cache.backends.base.

Client code should use the `cache` variable defined here to access the default
cache backend and look up non-default cache backends in the `caches` dict-like
object.

See docs/topics/cache.txt for information on the public API.
***REMOVED***
from threading import local

from django.conf import settings
from django.core import signals
from django.core.cache.backends.base import (
    BaseCache, CacheKeyWarning, InvalidCacheBackendError,
***REMOVED***
from django.utils.module_loading import import_string

__all__ = [
    'cache', 'DEFAULT_CACHE_ALIAS', 'InvalidCacheBackendError',
    'CacheKeyWarning', 'BaseCache',
***REMOVED***

DEFAULT_CACHE_ALIAS = 'default'


def _create_cache(backend, **kwargs***REMOVED***:
    ***REMOVED***
        # Try to get the CACHES entry for the given backend name first
        ***REMOVED***
            conf = settings.CACHES[backend***REMOVED***
        except KeyError:
            ***REMOVED***
                # Trying to import the given backend, in case it's a dotted path
                import_string(backend***REMOVED***
            except ImportError as e:
                raise InvalidCacheBackendError("Could not find backend '%s': %s" % (
                    backend, e***REMOVED******REMOVED***
            location = kwargs.pop('LOCATION', ''***REMOVED***
            params = kwargs
        else:
            params = conf.copy(***REMOVED***
            params.update(kwargs***REMOVED***
            backend = params.pop('BACKEND'***REMOVED***
            location = params.pop('LOCATION', ''***REMOVED***
        backend_cls = import_string(backend***REMOVED***
    except ImportError as e:
        raise InvalidCacheBackendError(
            "Could not find backend '%s': %s" % (backend, e***REMOVED******REMOVED***
    return backend_cls(location, params***REMOVED***


class CacheHandler(object***REMOVED***:
    ***REMOVED***
    A Cache Handler to manage access to Cache instances.

    Ensures only one instance of each alias exists per thread.
    ***REMOVED***
    def __init__(self***REMOVED***:
        self._caches = local(***REMOVED***

    def __getitem__(self, alias***REMOVED***:
        ***REMOVED***
            return self._caches.caches[alias***REMOVED***
        except AttributeError:
            self._caches.caches = {***REMOVED***
        except KeyError:
            pass

        if alias not in settings.CACHES:
            raise InvalidCacheBackendError(
                "Could not find config for '%s' in settings.CACHES" % alias
            ***REMOVED***

        cache = _create_cache(alias***REMOVED***
        self._caches.caches[alias***REMOVED*** = cache
        return cache

    def all(self***REMOVED***:
        return getattr(self._caches, 'caches', {***REMOVED******REMOVED***.values(***REMOVED***

caches = CacheHandler(***REMOVED***


class DefaultCacheProxy(object***REMOVED***:
    ***REMOVED***
    Proxy access to the default Cache object's attributes.

    This allows the legacy `cache` object to be thread-safe using the new
    ``caches`` API.
    ***REMOVED***
    def __getattr__(self, name***REMOVED***:
        return getattr(caches[DEFAULT_CACHE_ALIAS***REMOVED***, name***REMOVED***

    def __setattr__(self, name, value***REMOVED***:
        return setattr(caches[DEFAULT_CACHE_ALIAS***REMOVED***, name, value***REMOVED***

    def __delattr__(self, name***REMOVED***:
        return delattr(caches[DEFAULT_CACHE_ALIAS***REMOVED***, name***REMOVED***

    def __contains__(self, key***REMOVED***:
        return key in caches[DEFAULT_CACHE_ALIAS***REMOVED***

    def __eq__(self, other***REMOVED***:
        return caches[DEFAULT_CACHE_ALIAS***REMOVED*** == other

    def __ne__(self, other***REMOVED***:
        return caches[DEFAULT_CACHE_ALIAS***REMOVED*** != other

cache = DefaultCacheProxy(***REMOVED***


def close_caches(**kwargs***REMOVED***:
    # Some caches -- python-memcached in particular -- need to do a cleanup at the
    # end of a request cycle. If not implemented in a particular backend
    # cache.close is a no-op
    for cache in caches.all(***REMOVED***:
        cache.close(***REMOVED***
signals.request_finished.connect(close_caches***REMOVED***
