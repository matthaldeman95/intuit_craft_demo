"Thread-safe in-memory cache backend."

import time
from contextlib import contextmanager

from django.core.cache.backends.base import DEFAULT_TIMEOUT, BaseCache
from django.utils.synch import RWLock

***REMOVED***
    from django.utils.six.moves import cPickle as pickle
except ImportError:
    import pickle


# Global in-memory store of cache data. Keyed by name, to provide
# multiple named local memory caches.
_caches = {***REMOVED***
_expire_info = {***REMOVED***
_locks = {***REMOVED***


@contextmanager
def dummy(***REMOVED***:
    ***REMOVED***A context manager that does nothing special.***REMOVED***
    yield


class LocMemCache(BaseCache***REMOVED***:
    def __init__(self, name, params***REMOVED***:
        BaseCache.__init__(self, params***REMOVED***
        self._cache = _caches.setdefault(name, {***REMOVED******REMOVED***
        self._expire_info = _expire_info.setdefault(name, {***REMOVED******REMOVED***
        self._lock = _locks.setdefault(name, RWLock(***REMOVED******REMOVED***

    def add(self, key, value, timeout=DEFAULT_TIMEOUT, version=None***REMOVED***:
        key = self.make_key(key, version=version***REMOVED***
        self.validate_key(key***REMOVED***
        pickled = pickle.dumps(value, pickle.HIGHEST_PROTOCOL***REMOVED***
        with self._lock.writer(***REMOVED***:
            if self._has_expired(key***REMOVED***:
                self._set(key, pickled, timeout***REMOVED***
                return True
            return False

    def get(self, key, default=None, version=None, acquire_lock=True***REMOVED***:
        key = self.make_key(key, version=version***REMOVED***
        self.validate_key(key***REMOVED***
        pickled = None
        with (self._lock.reader(***REMOVED*** if acquire_lock else dummy(***REMOVED******REMOVED***:
            if not self._has_expired(key***REMOVED***:
                pickled = self._cache[key***REMOVED***
        if pickled is not None:
            ***REMOVED***
                return pickle.loads(pickled***REMOVED***
            except pickle.PickleError:
                return default

        with (self._lock.writer(***REMOVED*** if acquire_lock else dummy(***REMOVED******REMOVED***:
            ***REMOVED***
                del self._cache[key***REMOVED***
                del self._expire_info[key***REMOVED***
            except KeyError:
                pass
            return default

    def _set(self, key, value, timeout=DEFAULT_TIMEOUT***REMOVED***:
        if len(self._cache***REMOVED*** >= self._max_entries:
            self._cull(***REMOVED***
        self._cache[key***REMOVED*** = value
        self._expire_info[key***REMOVED*** = self.get_backend_timeout(timeout***REMOVED***

    def set(self, key, value, timeout=DEFAULT_TIMEOUT, version=None***REMOVED***:
        key = self.make_key(key, version=version***REMOVED***
        self.validate_key(key***REMOVED***
        pickled = pickle.dumps(value, pickle.HIGHEST_PROTOCOL***REMOVED***
        with self._lock.writer(***REMOVED***:
            self._set(key, pickled, timeout***REMOVED***

    def incr(self, key, delta=1, version=None***REMOVED***:
        with self._lock.writer(***REMOVED***:
            value = self.get(key, version=version, acquire_lock=False***REMOVED***
            if value is None:
                raise ValueError("Key '%s' not found" % key***REMOVED***
            new_value = value + delta
            key = self.make_key(key, version=version***REMOVED***
            pickled = pickle.dumps(new_value, pickle.HIGHEST_PROTOCOL***REMOVED***
            self._cache[key***REMOVED*** = pickled
        return new_value

    def has_key(self, key, version=None***REMOVED***:
        key = self.make_key(key, version=version***REMOVED***
        self.validate_key(key***REMOVED***
        with self._lock.reader(***REMOVED***:
            if not self._has_expired(key***REMOVED***:
                return True

        with self._lock.writer(***REMOVED***:
            ***REMOVED***
                del self._cache[key***REMOVED***
                del self._expire_info[key***REMOVED***
            except KeyError:
                pass
            return False

    def _has_expired(self, key***REMOVED***:
        exp = self._expire_info.get(key, -1***REMOVED***
        if exp is None or exp > time.time(***REMOVED***:
            return False
        return True

    def _cull(self***REMOVED***:
        if self._cull_frequency == 0:
            self.clear(***REMOVED***
        else:
            doomed = [k for (i, k***REMOVED*** in enumerate(self._cache***REMOVED*** if i % self._cull_frequency == 0***REMOVED***
            for k in doomed:
                self._delete(k***REMOVED***

    def _delete(self, key***REMOVED***:
        ***REMOVED***
            del self._cache[key***REMOVED***
        except KeyError:
            pass
        ***REMOVED***
            del self._expire_info[key***REMOVED***
        except KeyError:
            pass

    def delete(self, key, version=None***REMOVED***:
        key = self.make_key(key, version=version***REMOVED***
        self.validate_key(key***REMOVED***
        with self._lock.writer(***REMOVED***:
            self._delete(key***REMOVED***

    def clear(self***REMOVED***:
        self._cache.clear(***REMOVED***
        self._expire_info.clear(***REMOVED***
