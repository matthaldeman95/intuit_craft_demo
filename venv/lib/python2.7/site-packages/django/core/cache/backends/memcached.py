"Memcached cache backend"

import pickle
import time

from django.core.cache.backends.base import DEFAULT_TIMEOUT, BaseCache
from django.utils import six
from django.utils.encoding import force_str
from django.utils.functional import cached_property


class BaseMemcachedCache(BaseCache***REMOVED***:
    def __init__(self, server, params, library, value_not_found_exception***REMOVED***:
        super(BaseMemcachedCache, self***REMOVED***.__init__(params***REMOVED***
        if isinstance(server, six.string_types***REMOVED***:
            self._servers = server.split(';'***REMOVED***
        else:
            self._servers = server

        # The exception type to catch from the underlying library for a key
        # that was not found. This is a ValueError for python-memcache,
        # pylibmc.NotFound for pylibmc, and cmemcache will return None without
        # raising an exception.
        self.LibraryValueNotFoundException = value_not_found_exception

        self._lib = library
        self._options = params.get('OPTIONS'***REMOVED***

    @property
    def _cache(self***REMOVED***:
        ***REMOVED***
        Implements transparent thread-safe access to a memcached client.
        ***REMOVED***
        if getattr(self, '_client', None***REMOVED*** is None:
            self._client = self._lib.Client(self._servers***REMOVED***

        return self._client

    def get_backend_timeout(self, timeout=DEFAULT_TIMEOUT***REMOVED***:
        ***REMOVED***
        Memcached deals with long (> 30 days***REMOVED*** timeouts in a special
        way. Call this function to obtain a safe value for your timeout.
        ***REMOVED***
        if timeout == DEFAULT_TIMEOUT:
            timeout = self.default_timeout

        if timeout is None:
            # Using 0 in memcache sets a non-expiring timeout.
            return 0
        elif int(timeout***REMOVED*** == 0:
            # Other cache backends treat 0 as set-and-expire. To achieve this
            # in memcache backends, a negative timeout must be passed.
            timeout = -1

        if timeout > 2592000:  # 60*60*24*30, 30 days
            # See https://github.com/memcached/memcached/wiki/Programming#expiration
            # "Expiration times can be set from 0, meaning "never expire", to
            # 30 days. Any time higher than 30 days is interpreted as a Unix
            # timestamp date. If you want to expire an object on January 1st of
            # next year, this is how you do that."
            #
            # This means that we have to switch to absolute timestamps.
            timeout += int(time.time(***REMOVED******REMOVED***
        return int(timeout***REMOVED***

    def make_key(self, key, version=None***REMOVED***:
        # Python 2 memcache requires the key to be a byte string.
        return force_str(super(BaseMemcachedCache, self***REMOVED***.make_key(key, version***REMOVED******REMOVED***

    def add(self, key, value, timeout=DEFAULT_TIMEOUT, version=None***REMOVED***:
        key = self.make_key(key, version=version***REMOVED***
        return self._cache.add(key, value, self.get_backend_timeout(timeout***REMOVED******REMOVED***

    def get(self, key, default=None, version=None***REMOVED***:
        key = self.make_key(key, version=version***REMOVED***
        val = self._cache.get(key***REMOVED***
        if val is None:
            return default
        return val

    def set(self, key, value, timeout=DEFAULT_TIMEOUT, version=None***REMOVED***:
        key = self.make_key(key, version=version***REMOVED***
        if not self._cache.set(key, value, self.get_backend_timeout(timeout***REMOVED******REMOVED***:
            # make sure the key doesn't keep its old value in case of failure to set (memcached's 1MB limit***REMOVED***
            self._cache.delete(key***REMOVED***

    def delete(self, key, version=None***REMOVED***:
        key = self.make_key(key, version=version***REMOVED***
        self._cache.delete(key***REMOVED***

    def get_many(self, keys, version=None***REMOVED***:
        new_keys = [self.make_key(x, version=version***REMOVED*** for x in keys***REMOVED***
        ret = self._cache.get_multi(new_keys***REMOVED***
        if ret:
            _ = {***REMOVED***
            m = dict(zip(new_keys, keys***REMOVED******REMOVED***
            for k, v in ret.items(***REMOVED***:
                _[m[k***REMOVED******REMOVED*** = v
            ret = _
        return ret

    def close(self, **kwargs***REMOVED***:
        self._cache.disconnect_all(***REMOVED***

    def incr(self, key, delta=1, version=None***REMOVED***:
        key = self.make_key(key, version=version***REMOVED***
        # memcached doesn't support a negative delta
        if delta < 0:
            return self._cache.decr(key, -delta***REMOVED***
        ***REMOVED***
            val = self._cache.incr(key, delta***REMOVED***

        # python-memcache responds to incr on non-existent keys by
        # raising a ValueError, pylibmc by raising a pylibmc.NotFound
        # and Cmemcache returns None. In all cases,
        # we should raise a ValueError though.
        except self.LibraryValueNotFoundException:
            val = None
        if val is None:
            raise ValueError("Key '%s' not found" % key***REMOVED***
        return val

    def decr(self, key, delta=1, version=None***REMOVED***:
        key = self.make_key(key, version=version***REMOVED***
        # memcached doesn't support a negative delta
        if delta < 0:
            return self._cache.incr(key, -delta***REMOVED***
        ***REMOVED***
            val = self._cache.decr(key, delta***REMOVED***

        # python-memcache responds to incr on non-existent keys by
        # raising a ValueError, pylibmc by raising a pylibmc.NotFound
        # and Cmemcache returns None. In all cases,
        # we should raise a ValueError though.
        except self.LibraryValueNotFoundException:
            val = None
        if val is None:
            raise ValueError("Key '%s' not found" % key***REMOVED***
        return val

    def set_many(self, data, timeout=DEFAULT_TIMEOUT, version=None***REMOVED***:
        safe_data = {***REMOVED***
        for key, value in data.items(***REMOVED***:
            key = self.make_key(key, version=version***REMOVED***
            safe_data[key***REMOVED*** = value
        self._cache.set_multi(safe_data, self.get_backend_timeout(timeout***REMOVED******REMOVED***

    def delete_many(self, keys, version=None***REMOVED***:
        self._cache.delete_multi(self.make_key(key, version=version***REMOVED*** for key in keys***REMOVED***

    def clear(self***REMOVED***:
        self._cache.flush_all(***REMOVED***


class MemcachedCache(BaseMemcachedCache***REMOVED***:
    "An implementation of a cache binding using python-memcached"
    def __init__(self, server, params***REMOVED***:
        import memcache
        super(MemcachedCache, self***REMOVED***.__init__(server, params,
                                             library=memcache,
                                             value_not_found_exception=ValueError***REMOVED***

    @property
    def _cache(self***REMOVED***:
        if getattr(self, '_client', None***REMOVED*** is None:
            self._client = self._lib.Client(self._servers, pickleProtocol=pickle.HIGHEST_PROTOCOL***REMOVED***
        return self._client


class PyLibMCCache(BaseMemcachedCache***REMOVED***:
    "An implementation of a cache binding using pylibmc"
    def __init__(self, server, params***REMOVED***:
        import pylibmc
        super(PyLibMCCache, self***REMOVED***.__init__(server, params,
                                           library=pylibmc,
                                           value_not_found_exception=pylibmc.NotFound***REMOVED***

    @cached_property
    def _cache(self***REMOVED***:
        client = self._lib.Client(self._servers***REMOVED***
        if self._options:
            client.behaviors = self._options

        return client
