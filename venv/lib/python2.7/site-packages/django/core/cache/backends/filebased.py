"File-based cache backend"
import errno
import glob
import hashlib
import io
***REMOVED***
import random
import tempfile
import time
import zlib

from django.core.cache.backends.base import DEFAULT_TIMEOUT, BaseCache
from django.core.files.move import file_move_safe
from django.utils.encoding import force_bytes

***REMOVED***
    from django.utils.six.moves import cPickle as pickle
except ImportError:
    import pickle


class FileBasedCache(BaseCache***REMOVED***:
    cache_suffix = '.djcache'

    def __init__(self, dir, params***REMOVED***:
        super(FileBasedCache, self***REMOVED***.__init__(params***REMOVED***
        self._dir = os.path.abspath(dir***REMOVED***
        self._createdir(***REMOVED***

    def add(self, key, value, timeout=DEFAULT_TIMEOUT, version=None***REMOVED***:
        if self.has_key(key, version***REMOVED***:
            return False
        self.set(key, value, timeout, version***REMOVED***
        return True

    def get(self, key, default=None, version=None***REMOVED***:
        fname = self._key_to_file(key, version***REMOVED***
        if os.path.exists(fname***REMOVED***:
            ***REMOVED***
                with io.open(fname, 'rb'***REMOVED*** as f:
                    if not self._is_expired(f***REMOVED***:
                        return pickle.loads(zlib.decompress(f.read(***REMOVED******REMOVED******REMOVED***
            except IOError as e:
                if e.errno == errno.ENOENT:
                    pass  # Cache file was removed after the exists check
        return default

    def set(self, key, value, timeout=DEFAULT_TIMEOUT, version=None***REMOVED***:
        self._createdir(***REMOVED***  # Cache dir can be deleted at any time.
        fname = self._key_to_file(key, version***REMOVED***
        self._cull(***REMOVED***  # make some room if necessary
        fd, tmp_path = tempfile.mkstemp(dir=self._dir***REMOVED***
        renamed = False
        ***REMOVED***
            with io.open(fd, 'wb'***REMOVED*** as f:
                expiry = self.get_backend_timeout(timeout***REMOVED***
                f.write(pickle.dumps(expiry, pickle.HIGHEST_PROTOCOL***REMOVED******REMOVED***
                f.write(zlib.compress(pickle.dumps(value, pickle.HIGHEST_PROTOCOL***REMOVED******REMOVED******REMOVED***
            file_move_safe(tmp_path, fname, allow_overwrite=True***REMOVED***
            renamed = True
        finally:
            if not renamed:
                os.remove(tmp_path***REMOVED***

    def delete(self, key, version=None***REMOVED***:
        self._delete(self._key_to_file(key, version***REMOVED******REMOVED***

    def _delete(self, fname***REMOVED***:
        if not fname.startswith(self._dir***REMOVED*** or not os.path.exists(fname***REMOVED***:
            return
        ***REMOVED***
            os.remove(fname***REMOVED***
        except OSError as e:
            # ENOENT can happen if the cache file is removed (by another
            # process***REMOVED*** after the os.path.exists check.
            if e.errno != errno.ENOENT:
                raise

    def has_key(self, key, version=None***REMOVED***:
        fname = self._key_to_file(key, version***REMOVED***
        if os.path.exists(fname***REMOVED***:
            with io.open(fname, 'rb'***REMOVED*** as f:
                return not self._is_expired(f***REMOVED***
        return False

    def _cull(self***REMOVED***:
        ***REMOVED***
        Removes random cache entries if max_entries is reached at a ratio
        of num_entries / cull_frequency. A value of 0 for CULL_FREQUENCY means
        that the entire cache will be purged.
        ***REMOVED***
        filelist = self._list_cache_files(***REMOVED***
        num_entries = len(filelist***REMOVED***
        if num_entries < self._max_entries:
            return  # return early if no culling is required
        if self._cull_frequency == 0:
            return self.clear(***REMOVED***  # Clear the cache when CULL_FREQUENCY = 0
        # Delete a random selection of entries
        filelist = random.sample(filelist,
                                 int(num_entries / self._cull_frequency***REMOVED******REMOVED***
        for fname in filelist:
            self._delete(fname***REMOVED***

    def _createdir(self***REMOVED***:
        if not os.path.exists(self._dir***REMOVED***:
            ***REMOVED***
                os.makedirs(self._dir, 0o700***REMOVED***
            except OSError as e:
                if e.errno != errno.EEXIST:
                    raise EnvironmentError(
                        "Cache directory '%s' does not exist "
                        "and could not be created'" % self._dir***REMOVED***

    def _key_to_file(self, key, version=None***REMOVED***:
        ***REMOVED***
        Convert a key into a cache file path. Basically this is the
        root cache path joined with the md5sum of the key and a suffix.
        ***REMOVED***
        key = self.make_key(key, version=version***REMOVED***
        self.validate_key(key***REMOVED***
        return os.path.join(self._dir, ''.join(
            [hashlib.md5(force_bytes(key***REMOVED******REMOVED***.hexdigest(***REMOVED***, self.cache_suffix***REMOVED******REMOVED******REMOVED***

    def clear(self***REMOVED***:
        ***REMOVED***
        Remove all the cache files.
        ***REMOVED***
        if not os.path.exists(self._dir***REMOVED***:
            return
        for fname in self._list_cache_files(***REMOVED***:
            self._delete(fname***REMOVED***

    def _is_expired(self, f***REMOVED***:
        ***REMOVED***
        Takes an open cache file and determines if it has expired,
        deletes the file if it is has passed its expiry time.
        ***REMOVED***
        exp = pickle.load(f***REMOVED***
        if exp is not None and exp < time.time(***REMOVED***:
            f.close(***REMOVED***  # On Windows a file has to be closed before deleting
            self._delete(f.name***REMOVED***
            return True
        return False

    def _list_cache_files(self***REMOVED***:
        ***REMOVED***
        Get a list of paths to all the cache files. These are all the files
        in the root cache dir that end on the cache_suffix.
        ***REMOVED***
        if not os.path.exists(self._dir***REMOVED***:
            return [***REMOVED***
        filelist = [os.path.join(self._dir, fname***REMOVED*** for fname
                    in glob.glob1(self._dir, '*%s' % self.cache_suffix***REMOVED******REMOVED***
        return filelist
