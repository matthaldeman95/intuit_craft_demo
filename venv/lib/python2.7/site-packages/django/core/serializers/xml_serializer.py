***REMOVED***
XML serializer.
***REMOVED***

from __future__ import unicode_literals

from collections import OrderedDict
from xml.dom import pulldom
from xml.sax import handler
from xml.sax.expatreader import ExpatParser as _ExpatParser

from django.apps import apps
from django.conf import settings
from django.core.serializers import base
from django.db import DEFAULT_DB_ALIAS, models
from django.utils.encoding import smart_text
from django.utils.xmlutils import (
    SimplerXMLGenerator, UnserializableContentError,
***REMOVED***


class Serializer(base.Serializer***REMOVED***:
    ***REMOVED***
    Serializes a QuerySet to XML.
    ***REMOVED***

    def indent(self, level***REMOVED***:
        if self.options.get('indent'***REMOVED*** is not None:
            self.xml.ignorableWhitespace('\n' + ' ' * self.options.get('indent'***REMOVED*** * level***REMOVED***

    def start_serialization(self***REMOVED***:
        ***REMOVED***
        Start serialization -- open the XML document and the root element.
        ***REMOVED***
        self.xml = SimplerXMLGenerator(self.stream, self.options.get("encoding", settings.DEFAULT_CHARSET***REMOVED******REMOVED***
        self.xml.startDocument(***REMOVED***
        self.xml.startElement("django-objects", {"version": "1.0"***REMOVED******REMOVED***

    def end_serialization(self***REMOVED***:
        ***REMOVED***
        End serialization -- end the document.
        ***REMOVED***
        self.indent(0***REMOVED***
        self.xml.endElement("django-objects"***REMOVED***
        self.xml.endDocument(***REMOVED***

    def start_object(self, obj***REMOVED***:
        ***REMOVED***
        Called as each object is handled.
        ***REMOVED***
        if not hasattr(obj, "_meta"***REMOVED***:
            raise base.SerializationError("Non-model object (%s***REMOVED*** encountered during serialization" % type(obj***REMOVED******REMOVED***

        self.indent(1***REMOVED***
        attrs = OrderedDict([("model", smart_text(obj._meta***REMOVED******REMOVED******REMOVED******REMOVED***
        if not self.use_natural_primary_keys or not hasattr(obj, 'natural_key'***REMOVED***:
            obj_pk = obj._get_pk_val(***REMOVED***
            if obj_pk is not None:
                attrs['pk'***REMOVED*** = smart_text(obj_pk***REMOVED***

        self.xml.startElement("object", attrs***REMOVED***

    def end_object(self, obj***REMOVED***:
        ***REMOVED***
        Called after handling all fields for an object.
        ***REMOVED***
        self.indent(1***REMOVED***
        self.xml.endElement("object"***REMOVED***

    def handle_field(self, obj, field***REMOVED***:
        ***REMOVED***
        Called to handle each field on an object (except for ForeignKeys and
        ManyToManyFields***REMOVED***
        ***REMOVED***
        self.indent(2***REMOVED***
        self.xml.startElement("field", OrderedDict([
            ("name", field.name***REMOVED***,
            ("type", field.get_internal_type(***REMOVED******REMOVED***,
        ***REMOVED******REMOVED******REMOVED***

        # Get a "string version" of the object's data.
        if getattr(obj, field.name***REMOVED*** is not None:
            ***REMOVED***
                self.xml.characters(field.value_to_string(obj***REMOVED******REMOVED***
            except UnserializableContentError:
                raise ValueError("%s.%s (pk:%s***REMOVED*** contains unserializable characters" % (
                    obj.__class__.__name__, field.name, obj._get_pk_val(***REMOVED******REMOVED******REMOVED***
        else:
            self.xml.addQuickElement("None"***REMOVED***

        self.xml.endElement("field"***REMOVED***

    def handle_fk_field(self, obj, field***REMOVED***:
        ***REMOVED***
        Called to handle a ForeignKey (we need to treat them slightly
        differently from regular fields***REMOVED***.
        ***REMOVED***
        self._start_relational_field(field***REMOVED***
        related_att = getattr(obj, field.get_attname(***REMOVED******REMOVED***
        if related_att is not None:
            if self.use_natural_foreign_keys and hasattr(field.remote_field.model, 'natural_key'***REMOVED***:
                related = getattr(obj, field.name***REMOVED***
                # If related object has a natural key, use it
                related = related.natural_key(***REMOVED***
                # Iterable natural keys are rolled out as subelements
                for key_value in related:
                    self.xml.startElement("natural", {***REMOVED******REMOVED***
                    self.xml.characters(smart_text(key_value***REMOVED******REMOVED***
                    self.xml.endElement("natural"***REMOVED***
            else:
                self.xml.characters(smart_text(related_att***REMOVED******REMOVED***
        else:
            self.xml.addQuickElement("None"***REMOVED***
        self.xml.endElement("field"***REMOVED***

    def handle_m2m_field(self, obj, field***REMOVED***:
        ***REMOVED***
        Called to handle a ManyToManyField. Related objects are only
        serialized as references to the object's PK (i.e. the related *data*
        is not dumped, just the relation***REMOVED***.
        ***REMOVED***
        if field.remote_field.through._meta.auto_created:
            self._start_relational_field(field***REMOVED***
            if self.use_natural_foreign_keys and hasattr(field.remote_field.model, 'natural_key'***REMOVED***:
                # If the objects in the m2m have a natural key, use it
                def handle_m2m(value***REMOVED***:
                    natural = value.natural_key(***REMOVED***
                    # Iterable natural keys are rolled out as subelements
                    self.xml.startElement("object", {***REMOVED******REMOVED***
                    for key_value in natural:
                        self.xml.startElement("natural", {***REMOVED******REMOVED***
                        self.xml.characters(smart_text(key_value***REMOVED******REMOVED***
                        self.xml.endElement("natural"***REMOVED***
                    self.xml.endElement("object"***REMOVED***
            else:
                def handle_m2m(value***REMOVED***:
                    self.xml.addQuickElement("object", attrs={
                        'pk': smart_text(value._get_pk_val(***REMOVED******REMOVED***
                ***REMOVED******REMOVED***
            for relobj in getattr(obj, field.name***REMOVED***.iterator(***REMOVED***:
                handle_m2m(relobj***REMOVED***

            self.xml.endElement("field"***REMOVED***

    def _start_relational_field(self, field***REMOVED***:
        ***REMOVED***
        Helper to output the <field> element for relational fields
        ***REMOVED***
        self.indent(2***REMOVED***
        self.xml.startElement("field", OrderedDict([
            ("name", field.name***REMOVED***,
            ("rel", field.remote_field.__class__.__name__***REMOVED***,
            ("to", smart_text(field.remote_field.model._meta***REMOVED******REMOVED***,
        ***REMOVED******REMOVED******REMOVED***


class Deserializer(base.Deserializer***REMOVED***:
    ***REMOVED***
    Deserialize XML.
    ***REMOVED***

    def __init__(self, stream_or_string, **options***REMOVED***:
        super(Deserializer, self***REMOVED***.__init__(stream_or_string, **options***REMOVED***
        self.event_stream = pulldom.parse(self.stream, self._make_parser(***REMOVED******REMOVED***
        self.db = options.pop('using', DEFAULT_DB_ALIAS***REMOVED***
        self.ignore = options.pop('ignorenonexistent', False***REMOVED***

    def _make_parser(self***REMOVED***:
        ***REMOVED***Create a hardened XML parser (no custom/external entities***REMOVED***.***REMOVED***
        return DefusedExpatParser(***REMOVED***

    def __next__(self***REMOVED***:
        for event, node in self.event_stream:
            if event == "START_ELEMENT" and node.nodeName == "object":
                self.event_stream.expandNode(node***REMOVED***
                return self._handle_object(node***REMOVED***
        raise StopIteration

    def _handle_object(self, node***REMOVED***:
        ***REMOVED***
        Convert an <object> node to a DeserializedObject.
        ***REMOVED***
        # Look up the model using the model loading mechanism. If this fails,
        # bail.
        Model = self._get_model_from_node(node, "model"***REMOVED***

        # Start building a data dictionary from the object.
        data = {***REMOVED***
        if node.hasAttribute('pk'***REMOVED***:
            data[Model._meta.pk.attname***REMOVED*** = Model._meta.pk.to_python(
                node.getAttribute('pk'***REMOVED******REMOVED***

        # Also start building a dict of m2m data (this is saved as
        # {m2m_accessor_attribute : [list_of_related_objects***REMOVED******REMOVED******REMOVED***
        m2m_data = {***REMOVED***

        field_names = {f.name for f in Model._meta.get_fields(***REMOVED******REMOVED***
        # Deserialize each field.
        for field_node in node.getElementsByTagName("field"***REMOVED***:
            # If the field is missing the name attribute, bail (are you
            # sensing a pattern here?***REMOVED***
            field_name = field_node.getAttribute("name"***REMOVED***
            if not field_name:
                raise base.DeserializationError("<field> node is missing the 'name' attribute"***REMOVED***

            # Get the field from the Model. This will raise a
            # FieldDoesNotExist if, well, the field doesn't exist, which will
            # be propagated correctly unless ignorenonexistent=True is used.
            if self.ignore and field_name not in field_names:
                continue
            field = Model._meta.get_field(field_name***REMOVED***

            # As is usually the case, relation fields get the special treatment.
            if field.remote_field and isinstance(field.remote_field, models.ManyToManyRel***REMOVED***:
                m2m_data[field.name***REMOVED*** = self._handle_m2m_field_node(field_node, field***REMOVED***
            elif field.remote_field and isinstance(field.remote_field, models.ManyToOneRel***REMOVED***:
                data[field.attname***REMOVED*** = self._handle_fk_field_node(field_node, field***REMOVED***
            else:
                if field_node.getElementsByTagName('None'***REMOVED***:
                    value = None
                else:
                    value = field.to_python(getInnerText(field_node***REMOVED***.strip(***REMOVED******REMOVED***
                data[field.name***REMOVED*** = value

        obj = base.build_instance(Model, data, self.db***REMOVED***

        # Return a DeserializedObject so that the m2m data has a place to live.
        return base.DeserializedObject(obj, m2m_data***REMOVED***

    def _handle_fk_field_node(self, node, field***REMOVED***:
        ***REMOVED***
        Handle a <field> node for a ForeignKey
        ***REMOVED***
        # Check if there is a child node named 'None', returning None if so.
        if node.getElementsByTagName('None'***REMOVED***:
            return None
        else:
            model = field.remote_field.model
            if hasattr(model._default_manager, 'get_by_natural_key'***REMOVED***:
                keys = node.getElementsByTagName('natural'***REMOVED***
                if keys:
                    # If there are 'natural' subelements, it must be a natural key
                    field_value = [getInnerText(k***REMOVED***.strip(***REMOVED*** for k in keys***REMOVED***
                    obj = model._default_manager.db_manager(self.db***REMOVED***.get_by_natural_key(*field_value***REMOVED***
                    obj_pk = getattr(obj, field.remote_field.field_name***REMOVED***
                    # If this is a natural foreign key to an object that
                    # has a FK/O2O as the foreign key, use the FK value
                    if field.remote_field.model._meta.pk.remote_field:
                        obj_pk = obj_pk.pk
                else:
                    # Otherwise, treat like a normal PK
                    field_value = getInnerText(node***REMOVED***.strip(***REMOVED***
                    obj_pk = model._meta.get_field(field.remote_field.field_name***REMOVED***.to_python(field_value***REMOVED***
                return obj_pk
            else:
                field_value = getInnerText(node***REMOVED***.strip(***REMOVED***
                return model._meta.get_field(field.remote_field.field_name***REMOVED***.to_python(field_value***REMOVED***

    def _handle_m2m_field_node(self, node, field***REMOVED***:
        ***REMOVED***
        Handle a <field> node for a ManyToManyField.
        ***REMOVED***
        model = field.remote_field.model
        default_manager = model._default_manager
        if hasattr(default_manager, 'get_by_natural_key'***REMOVED***:
            def m2m_convert(n***REMOVED***:
                keys = n.getElementsByTagName('natural'***REMOVED***
                if keys:
                    # If there are 'natural' subelements, it must be a natural key
                    field_value = [getInnerText(k***REMOVED***.strip(***REMOVED*** for k in keys***REMOVED***
                    obj_pk = default_manager.db_manager(self.db***REMOVED***.get_by_natural_key(*field_value***REMOVED***.pk
                else:
                    # Otherwise, treat like a normal PK value.
                    obj_pk = model._meta.pk.to_python(n.getAttribute('pk'***REMOVED******REMOVED***
                return obj_pk
        else:
            def m2m_convert(n***REMOVED***:
                return model._meta.pk.to_python(n.getAttribute('pk'***REMOVED******REMOVED***
        return [m2m_convert(c***REMOVED*** for c in node.getElementsByTagName("object"***REMOVED******REMOVED***

    def _get_model_from_node(self, node, attr***REMOVED***:
        ***REMOVED***
        Helper to look up a model from a <object model=...> or a <field
        rel=... to=...> node.
        ***REMOVED***
        model_identifier = node.getAttribute(attr***REMOVED***
        if not model_identifier:
            raise base.DeserializationError(
                "<%s> node is missing the required '%s' attribute"
                % (node.nodeName, attr***REMOVED******REMOVED***
        ***REMOVED***
            return apps.get_model(model_identifier***REMOVED***
        except (LookupError, TypeError***REMOVED***:
            raise base.DeserializationError(
                "<%s> node has invalid model identifier: '%s'"
                % (node.nodeName, model_identifier***REMOVED******REMOVED***


def getInnerText(node***REMOVED***:
    ***REMOVED***
    Get all the inner text of a DOM node (recursively***REMOVED***.
    ***REMOVED***
    # inspired by http://mail.python.org/pipermail/xml-sig/2005-March/011022.html
    inner_text = [***REMOVED***
    for child in node.childNodes:
        if child.nodeType == child.TEXT_NODE or child.nodeType == child.CDATA_SECTION_NODE:
            inner_text.append(child.data***REMOVED***
        elif child.nodeType == child.ELEMENT_NODE:
            inner_text.extend(getInnerText(child***REMOVED******REMOVED***
        else:
            pass
    return "".join(inner_text***REMOVED***


# Below code based on Christian Heimes' defusedxml


class DefusedExpatParser(_ExpatParser***REMOVED***:
    ***REMOVED***
    An expat parser hardened against XML bomb attacks.

    Forbids DTDs, external entity references
    ***REMOVED***
    def __init__(self, *args, **kwargs***REMOVED***:
        _ExpatParser.__init__(self, *args, **kwargs***REMOVED***
        self.setFeature(handler.feature_external_ges, False***REMOVED***
        self.setFeature(handler.feature_external_pes, False***REMOVED***

    def start_doctype_decl(self, name, sysid, pubid, has_internal_subset***REMOVED***:
        raise DTDForbidden(name, sysid, pubid***REMOVED***

    def entity_decl(self, name, is_parameter_entity, value, base,
                    sysid, pubid, notation_name***REMOVED***:
        raise EntitiesForbidden(name, value, base, sysid, pubid, notation_name***REMOVED***

    def unparsed_entity_decl(self, name, base, sysid, pubid, notation_name***REMOVED***:
        # expat 1.2
        raise EntitiesForbidden(name, None, base, sysid, pubid, notation_name***REMOVED***

    def external_entity_ref_handler(self, context, base, sysid, pubid***REMOVED***:
        raise ExternalReferenceForbidden(context, base, sysid, pubid***REMOVED***

    def reset(self***REMOVED***:
        _ExpatParser.reset(self***REMOVED***
        parser = self._parser
        parser.StartDoctypeDeclHandler = self.start_doctype_decl
        parser.EntityDeclHandler = self.entity_decl
        parser.UnparsedEntityDeclHandler = self.unparsed_entity_decl
        parser.ExternalEntityRefHandler = self.external_entity_ref_handler


class DefusedXmlException(ValueError***REMOVED***:
    ***REMOVED***Base exception.***REMOVED***
    def __repr__(self***REMOVED***:
        return str(self***REMOVED***


class DTDForbidden(DefusedXmlException***REMOVED***:
    ***REMOVED***Document type definition is forbidden.***REMOVED***
    def __init__(self, name, sysid, pubid***REMOVED***:
        super(DTDForbidden, self***REMOVED***.__init__(***REMOVED***
        self.name = name
        self.sysid = sysid
        self.pubid = pubid

    def __str__(self***REMOVED***:
        tpl = "DTDForbidden(name='{***REMOVED***', system_id={!r***REMOVED***, public_id={!r***REMOVED******REMOVED***"
        return tpl.format(self.name, self.sysid, self.pubid***REMOVED***


class EntitiesForbidden(DefusedXmlException***REMOVED***:
    ***REMOVED***Entity definition is forbidden.***REMOVED***
    def __init__(self, name, value, base, sysid, pubid, notation_name***REMOVED***:
        super(EntitiesForbidden, self***REMOVED***.__init__(***REMOVED***
        self.name = name
        self.value = value
        self.base = base
        self.sysid = sysid
        self.pubid = pubid
        self.notation_name = notation_name

    def __str__(self***REMOVED***:
        tpl = "EntitiesForbidden(name='{***REMOVED***', system_id={!r***REMOVED***, public_id={!r***REMOVED******REMOVED***"
        return tpl.format(self.name, self.sysid, self.pubid***REMOVED***


class ExternalReferenceForbidden(DefusedXmlException***REMOVED***:
    ***REMOVED***Resolving an external reference is forbidden.***REMOVED***
    def __init__(self, context, base, sysid, pubid***REMOVED***:
        super(ExternalReferenceForbidden, self***REMOVED***.__init__(***REMOVED***
        self.context = context
        self.base = base
        self.sysid = sysid
        self.pubid = pubid

    def __str__(self***REMOVED***:
        tpl = "ExternalReferenceForbidden(system_id='{***REMOVED***', public_id={***REMOVED******REMOVED***"
        return tpl.format(self.sysid, self.pubid***REMOVED***
