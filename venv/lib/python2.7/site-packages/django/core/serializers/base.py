***REMOVED***
Module for abstract serializer/unserializer base classes.
***REMOVED***
from django.db import models
from django.utils import six


class SerializerDoesNotExist(KeyError***REMOVED***:
    ***REMOVED***The requested serializer was not found.***REMOVED***
    pass


class SerializationError(Exception***REMOVED***:
    ***REMOVED***Something bad happened during serialization.***REMOVED***
    pass


class DeserializationError(Exception***REMOVED***:
    ***REMOVED***Something bad happened during deserialization.***REMOVED***

    @classmethod
    def WithData(cls, original_exc, model, fk, field_value***REMOVED***:
        ***REMOVED***
        Factory method for creating a deserialization error which has a more
        explanatory message.
        ***REMOVED***
        return cls("%s: (%s:pk=%s***REMOVED*** field_value was '%s'" % (original_exc, model, fk, field_value***REMOVED******REMOVED***


class ProgressBar(object***REMOVED***:
    progress_width = 75

    def __init__(self, output, total_count***REMOVED***:
        self.output = output
        self.total_count = total_count
        self.prev_done = 0

    def update(self, count***REMOVED***:
        if not self.output:
            return
        perc = count * 100 // self.total_count
        done = perc * self.progress_width // 100
        if self.prev_done >= done:
            return
        self.prev_done = done
        cr = '' if self.total_count == 1 else '\r'
        self.output.write(cr + '[' + '.' * done + ' ' * (self.progress_width - done***REMOVED*** + '***REMOVED***'***REMOVED***
        if done == self.progress_width:
            self.output.write('\n'***REMOVED***
        self.output.flush(***REMOVED***


class Serializer(object***REMOVED***:
    ***REMOVED***
    Abstract serializer base class.
    ***REMOVED***

    # Indicates if the implemented serializer is only available for
    # internal Django use.
    internal_use_only = False
    progress_class = ProgressBar

    def serialize(self, queryset, **options***REMOVED***:
        ***REMOVED***
        Serialize a queryset.
        ***REMOVED***
        self.options = options

        self.stream = options.pop("stream", six.StringIO(***REMOVED******REMOVED***
        self.selected_fields = options.pop("fields", None***REMOVED***
        self.use_natural_foreign_keys = options.pop('use_natural_foreign_keys', False***REMOVED***
        self.use_natural_primary_keys = options.pop('use_natural_primary_keys', False***REMOVED***
        progress_bar = self.progress_class(
            options.pop('progress_output', None***REMOVED***, options.pop('object_count', 0***REMOVED***
        ***REMOVED***

        self.start_serialization(***REMOVED***
        self.first = True
        for count, obj in enumerate(queryset, start=1***REMOVED***:
            self.start_object(obj***REMOVED***
            # Use the concrete parent class' _meta instead of the object's _meta
            # This is to avoid local_fields problems for proxy models. Refs #17717.
            concrete_model = obj._meta.concrete_model
            for field in concrete_model._meta.local_fields:
                if field.serialize:
                    if field.remote_field is None:
                        if self.selected_fields is None or field.attname in self.selected_fields:
                            self.handle_field(obj, field***REMOVED***
                    else:
                        if self.selected_fields is None or field.attname[:-3***REMOVED*** in self.selected_fields:
                            self.handle_fk_field(obj, field***REMOVED***
            for field in concrete_model._meta.many_to_many:
                if field.serialize:
                    if self.selected_fields is None or field.attname in self.selected_fields:
                        self.handle_m2m_field(obj, field***REMOVED***
            self.end_object(obj***REMOVED***
            progress_bar.update(count***REMOVED***
            if self.first:
                self.first = False
        self.end_serialization(***REMOVED***
        return self.getvalue(***REMOVED***

    def start_serialization(self***REMOVED***:
        ***REMOVED***
        Called when serializing of the queryset starts.
        ***REMOVED***
        raise NotImplementedError('subclasses of Serializer must provide a start_serialization(***REMOVED*** method'***REMOVED***

    def end_serialization(self***REMOVED***:
        ***REMOVED***
        Called when serializing of the queryset ends.
        ***REMOVED***
        pass

    def start_object(self, obj***REMOVED***:
        ***REMOVED***
        Called when serializing of an object starts.
        ***REMOVED***
        raise NotImplementedError('subclasses of Serializer must provide a start_object(***REMOVED*** method'***REMOVED***

    def end_object(self, obj***REMOVED***:
        ***REMOVED***
        Called when serializing of an object ends.
        ***REMOVED***
        pass

    def handle_field(self, obj, field***REMOVED***:
        ***REMOVED***
        Called to handle each individual (non-relational***REMOVED*** field on an object.
        ***REMOVED***
        raise NotImplementedError('subclasses of Serializer must provide an handle_field(***REMOVED*** method'***REMOVED***

    def handle_fk_field(self, obj, field***REMOVED***:
        ***REMOVED***
        Called to handle a ForeignKey field.
        ***REMOVED***
        raise NotImplementedError('subclasses of Serializer must provide an handle_fk_field(***REMOVED*** method'***REMOVED***

    def handle_m2m_field(self, obj, field***REMOVED***:
        ***REMOVED***
        Called to handle a ManyToManyField.
        ***REMOVED***
        raise NotImplementedError('subclasses of Serializer must provide an handle_m2m_field(***REMOVED*** method'***REMOVED***

    def getvalue(self***REMOVED***:
        ***REMOVED***
        Return the fully serialized queryset (or None if the output stream is
        not seekable***REMOVED***.
        ***REMOVED***
        if callable(getattr(self.stream, 'getvalue', None***REMOVED******REMOVED***:
            return self.stream.getvalue(***REMOVED***


class Deserializer(six.Iterator***REMOVED***:
    ***REMOVED***
    Abstract base deserializer class.
    ***REMOVED***

    def __init__(self, stream_or_string, **options***REMOVED***:
        ***REMOVED***
        Init this serializer given a stream or a string
        ***REMOVED***
        self.options = options
        if isinstance(stream_or_string, six.string_types***REMOVED***:
            self.stream = six.StringIO(stream_or_string***REMOVED***
        else:
            self.stream = stream_or_string

    def __iter__(self***REMOVED***:
        return self

    def __next__(self***REMOVED***:
        ***REMOVED***Iteration iterface -- return the next item in the stream***REMOVED***
        raise NotImplementedError('subclasses of Deserializer must provide a __next__(***REMOVED*** method'***REMOVED***


class DeserializedObject(object***REMOVED***:
    ***REMOVED***
    A deserialized model.

    Basically a container for holding the pre-saved deserialized data along
    with the many-to-many data saved with the object.

    Call ``save(***REMOVED***`` to save the object (with the many-to-many data***REMOVED*** to the
    database; call ``save(save_m2m=False***REMOVED***`` to save just the object fields
    (and not touch the many-to-many stuff.***REMOVED***
    ***REMOVED***

    def __init__(self, obj, m2m_data=None***REMOVED***:
        self.object = obj
        self.m2m_data = m2m_data

    def __repr__(self***REMOVED***:
        return "<DeserializedObject: %s(pk=%s***REMOVED***>" % (
            self.object._meta.label, self.object.pk***REMOVED***

    def save(self, save_m2m=True, using=None, **kwargs***REMOVED***:
        # Call save on the Model baseclass directly. This bypasses any
        # model-defined save. The save is also forced to be raw.
        # raw=True is passed to any pre/post_save signals.
        models.Model.save_base(self.object, using=using, raw=True, **kwargs***REMOVED***
        if self.m2m_data and save_m2m:
            for accessor_name, object_list in self.m2m_data.items(***REMOVED***:
                getattr(self.object, accessor_name***REMOVED***.set(object_list***REMOVED***

        # prevent a second (possibly accidental***REMOVED*** call to save(***REMOVED*** from saving
        # the m2m data twice.
        self.m2m_data = None


def build_instance(Model, data, db***REMOVED***:
    ***REMOVED***
    Build a model instance.

    If the model instance doesn't have a primary key and the model supports
    natural keys, try to retrieve it from the database.
    ***REMOVED***
    obj = Model(**data***REMOVED***
    if (obj.pk is None and hasattr(Model, 'natural_key'***REMOVED*** and
            hasattr(Model._default_manager, 'get_by_natural_key'***REMOVED******REMOVED***:
        natural_key = obj.natural_key(***REMOVED***
        ***REMOVED***
            obj.pk = Model._default_manager.db_manager(db***REMOVED***.get_by_natural_key(*natural_key***REMOVED***.pk
        except Model.DoesNotExist:
            pass
    return obj
