***REMOVED***
A Python "serializer". Doesn't do much serializing per se -- just converts to
and from basic Python data types (lists, dicts, strings, etc.***REMOVED***. Useful as a basis for
other serializers.
***REMOVED***
from __future__ import unicode_literals

from collections import OrderedDict

from django.apps import apps
from django.conf import settings
from django.core.serializers import base
from django.db import DEFAULT_DB_ALIAS, models
from django.utils import six
from django.utils.encoding import force_text, is_protected_type


class Serializer(base.Serializer***REMOVED***:
    ***REMOVED***
    Serializes a QuerySet to basic Python objects.
    ***REMOVED***

    internal_use_only = True

    def start_serialization(self***REMOVED***:
        self._current = None
        self.objects = [***REMOVED***

    def end_serialization(self***REMOVED***:
        pass

    def start_object(self, obj***REMOVED***:
        self._current = OrderedDict(***REMOVED***

    def end_object(self, obj***REMOVED***:
        self.objects.append(self.get_dump_object(obj***REMOVED******REMOVED***
        self._current = None

    def get_dump_object(self, obj***REMOVED***:
        data = OrderedDict([('model', force_text(obj._meta***REMOVED******REMOVED******REMOVED******REMOVED***
        if not self.use_natural_primary_keys or not hasattr(obj, 'natural_key'***REMOVED***:
            data["pk"***REMOVED*** = force_text(obj._get_pk_val(***REMOVED***, strings_only=True***REMOVED***
        data['fields'***REMOVED*** = self._current
        return data

    def handle_field(self, obj, field***REMOVED***:
        value = field.value_from_object(obj***REMOVED***
        # Protected types (i.e., primitives like None, numbers, dates,
        # and Decimals***REMOVED*** are passed through as is. All other values are
        # converted to string first.
        if is_protected_type(value***REMOVED***:
            self._current[field.name***REMOVED*** = value
        else:
            self._current[field.name***REMOVED*** = field.value_to_string(obj***REMOVED***

    def handle_fk_field(self, obj, field***REMOVED***:
        if self.use_natural_foreign_keys and hasattr(field.remote_field.model, 'natural_key'***REMOVED***:
            related = getattr(obj, field.name***REMOVED***
            if related:
                value = related.natural_key(***REMOVED***
            else:
                value = None
        else:
            value = getattr(obj, field.get_attname(***REMOVED******REMOVED***
            if not is_protected_type(value***REMOVED***:
                value = field.value_to_string(obj***REMOVED***
        self._current[field.name***REMOVED*** = value

    def handle_m2m_field(self, obj, field***REMOVED***:
        if field.remote_field.through._meta.auto_created:
            if self.use_natural_foreign_keys and hasattr(field.remote_field.model, 'natural_key'***REMOVED***:
                def m2m_value(value***REMOVED***:
                    return value.natural_key(***REMOVED***
            else:
                def m2m_value(value***REMOVED***:
                    return force_text(value._get_pk_val(***REMOVED***, strings_only=True***REMOVED***
            self._current[field.name***REMOVED*** = [
                m2m_value(related***REMOVED*** for related in getattr(obj, field.name***REMOVED***.iterator(***REMOVED***
            ***REMOVED***

    def getvalue(self***REMOVED***:
        return self.objects


def Deserializer(object_list, **options***REMOVED***:
    ***REMOVED***
    Deserialize simple Python objects back into Django ORM instances.

    It's expected that you pass the Python objects themselves (instead of a
    stream or a string***REMOVED*** to the constructor
    ***REMOVED***
    db = options.pop('using', DEFAULT_DB_ALIAS***REMOVED***
    ignore = options.pop('ignorenonexistent', False***REMOVED***
    field_names_cache = {***REMOVED***  # Model: <list of field_names>

    for d in object_list:
        # Look up the model and starting build a dict of data for it.
        ***REMOVED***
            Model = _get_model(d["model"***REMOVED******REMOVED***
        except base.DeserializationError:
            if ignore:
                continue
            else:
                raise
        data = {***REMOVED***
        if 'pk' in d:
            ***REMOVED***
                data[Model._meta.pk.attname***REMOVED*** = Model._meta.pk.to_python(d.get('pk'***REMOVED******REMOVED***
            except Exception as e:
                raise base.DeserializationError.WithData(e, d['model'***REMOVED***, d.get('pk'***REMOVED***, None***REMOVED***
        m2m_data = {***REMOVED***

        if Model not in field_names_cache:
            field_names_cache[Model***REMOVED*** = {f.name for f in Model._meta.get_fields(***REMOVED******REMOVED***
        field_names = field_names_cache[Model***REMOVED***

        # Handle each field
        for (field_name, field_value***REMOVED*** in six.iteritems(d["fields"***REMOVED******REMOVED***:

            if ignore and field_name not in field_names:
                # skip fields no longer on model
                continue

            if isinstance(field_value, str***REMOVED***:
                field_value = force_text(
                    field_value, options.get("encoding", settings.DEFAULT_CHARSET***REMOVED***, strings_only=True
                ***REMOVED***

            field = Model._meta.get_field(field_name***REMOVED***

            # Handle M2M relations
            if field.remote_field and isinstance(field.remote_field, models.ManyToManyRel***REMOVED***:
                model = field.remote_field.model
                if hasattr(model._default_manager, 'get_by_natural_key'***REMOVED***:
                    def m2m_convert(value***REMOVED***:
                        if hasattr(value, '__iter__'***REMOVED*** and not isinstance(value, six.text_type***REMOVED***:
                            return model._default_manager.db_manager(db***REMOVED***.get_by_natural_key(*value***REMOVED***.pk
                        else:
                            return force_text(model._meta.pk.to_python(value***REMOVED***, strings_only=True***REMOVED***
                else:
                    def m2m_convert(v***REMOVED***:
                        return force_text(model._meta.pk.to_python(v***REMOVED***, strings_only=True***REMOVED***

                ***REMOVED***
                    m2m_data[field.name***REMOVED*** = [***REMOVED***
                    for pk in field_value:
                        m2m_data[field.name***REMOVED***.append(m2m_convert(pk***REMOVED******REMOVED***
                except Exception as e:
                    raise base.DeserializationError.WithData(e, d['model'***REMOVED***, d.get('pk'***REMOVED***, pk***REMOVED***

            # Handle FK fields
            elif field.remote_field and isinstance(field.remote_field, models.ManyToOneRel***REMOVED***:
                model = field.remote_field.model
                if field_value is not None:
                    ***REMOVED***
                        default_manager = model._default_manager
                        field_name = field.remote_field.field_name
                        if hasattr(default_manager, 'get_by_natural_key'***REMOVED***:
                            if hasattr(field_value, '__iter__'***REMOVED*** and not isinstance(field_value, six.text_type***REMOVED***:
                                obj = default_manager.db_manager(db***REMOVED***.get_by_natural_key(*field_value***REMOVED***
                                value = getattr(obj, field.remote_field.field_name***REMOVED***
                                # If this is a natural foreign key to an object that
                                # has a FK/O2O as the foreign key, use the FK value
                                if model._meta.pk.remote_field:
                                    value = value.pk
                            else:
                                value = model._meta.get_field(field_name***REMOVED***.to_python(field_value***REMOVED***
                            data[field.attname***REMOVED*** = value
                        else:
                            data[field.attname***REMOVED*** = model._meta.get_field(field_name***REMOVED***.to_python(field_value***REMOVED***
                    except Exception as e:
                        raise base.DeserializationError.WithData(e, d['model'***REMOVED***, d.get('pk'***REMOVED***, field_value***REMOVED***
                else:
                    data[field.attname***REMOVED*** = None

            # Handle all other fields
            else:
                ***REMOVED***
                    data[field.name***REMOVED*** = field.to_python(field_value***REMOVED***
                except Exception as e:
                    raise base.DeserializationError.WithData(e, d['model'***REMOVED***, d.get('pk'***REMOVED***, field_value***REMOVED***

        obj = base.build_instance(Model, data, db***REMOVED***
        yield base.DeserializedObject(obj, m2m_data***REMOVED***


def _get_model(model_identifier***REMOVED***:
    ***REMOVED***
    Helper to look up a model from an "app_label.model_name" string.
    ***REMOVED***
    ***REMOVED***
        return apps.get_model(model_identifier***REMOVED***
    except (LookupError, TypeError***REMOVED***:
        raise base.DeserializationError("Invalid model identifier: '%s'" % model_identifier***REMOVED***
