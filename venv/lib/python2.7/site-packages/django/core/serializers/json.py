***REMOVED***
Serialize data to/from JSON
***REMOVED***

# Avoid shadowing the standard library json module
from __future__ import absolute_import, unicode_literals

import datetime
import decimal
import json
import sys
import uuid

from django.core.serializers.base import DeserializationError
from django.core.serializers.python import (
    Deserializer as PythonDeserializer, Serializer as PythonSerializer,
***REMOVED***
from django.utils import six
from django.utils.functional import Promise
from django.utils.timezone import is_aware


class Serializer(PythonSerializer***REMOVED***:
    ***REMOVED***
    Convert a queryset to JSON.
    ***REMOVED***
    internal_use_only = False

    def _init_options(self***REMOVED***:
        if json.__version__.split('.'***REMOVED*** >= ['2', '1', '3'***REMOVED***:
            # Use JS strings to represent Python Decimal instances (ticket #16850***REMOVED***
            self.options.update({'use_decimal': False***REMOVED******REMOVED***
        self._current = None
        self.json_kwargs = self.options.copy(***REMOVED***
        self.json_kwargs.pop('stream', None***REMOVED***
        self.json_kwargs.pop('fields', None***REMOVED***
        if self.options.get('indent'***REMOVED***:
            # Prevent trailing spaces
            self.json_kwargs['separators'***REMOVED*** = (',', ': '***REMOVED***

    def start_serialization(self***REMOVED***:
        self._init_options(***REMOVED***
        self.stream.write("["***REMOVED***

    def end_serialization(self***REMOVED***:
        if self.options.get("indent"***REMOVED***:
            self.stream.write("\n"***REMOVED***
        self.stream.write("***REMOVED***"***REMOVED***
        if self.options.get("indent"***REMOVED***:
            self.stream.write("\n"***REMOVED***

    def end_object(self, obj***REMOVED***:
        # self._current has the field data
        indent = self.options.get("indent"***REMOVED***
        if not self.first:
            self.stream.write(","***REMOVED***
            if not indent:
                self.stream.write(" "***REMOVED***
        if indent:
            self.stream.write("\n"***REMOVED***
        json.dump(self.get_dump_object(obj***REMOVED***, self.stream,
                  cls=DjangoJSONEncoder, **self.json_kwargs***REMOVED***
        self._current = None

    def getvalue(self***REMOVED***:
        # Grand-parent super
        return super(PythonSerializer, self***REMOVED***.getvalue(***REMOVED***


def Deserializer(stream_or_string, **options***REMOVED***:
    ***REMOVED***
    Deserialize a stream or string of JSON data.
    ***REMOVED***
    if not isinstance(stream_or_string, (bytes, six.string_types***REMOVED******REMOVED***:
        stream_or_string = stream_or_string.read(***REMOVED***
    if isinstance(stream_or_string, bytes***REMOVED***:
        stream_or_string = stream_or_string.decode('utf-8'***REMOVED***
    ***REMOVED***
        objects = json.loads(stream_or_string***REMOVED***
        for obj in PythonDeserializer(objects, **options***REMOVED***:
            yield obj
    except GeneratorExit:
        raise
    except Exception as e:
        # Map to deserializer error
        six.reraise(DeserializationError, DeserializationError(e***REMOVED***, sys.exc_info(***REMOVED***[2***REMOVED******REMOVED***


class DjangoJSONEncoder(json.JSONEncoder***REMOVED***:
    ***REMOVED***
    JSONEncoder subclass that knows how to encode date/time, decimal types and UUIDs.
    ***REMOVED***
    def default(self, o***REMOVED***:
        # See "Date Time String Format" in the ECMA-262 specification.
        if isinstance(o, datetime.datetime***REMOVED***:
            r = o.isoformat(***REMOVED***
            if o.microsecond:
                r = r[:23***REMOVED*** + r[26:***REMOVED***
            if r.endswith('+00:00'***REMOVED***:
                r = r[:-6***REMOVED*** + 'Z'
            return r
        elif isinstance(o, datetime.date***REMOVED***:
            return o.isoformat(***REMOVED***
        elif isinstance(o, datetime.time***REMOVED***:
            if is_aware(o***REMOVED***:
                raise ValueError("JSON can't represent timezone-aware times."***REMOVED***
            r = o.isoformat(***REMOVED***
            if o.microsecond:
                r = r[:12***REMOVED***
            return r
        elif isinstance(o, decimal.Decimal***REMOVED***:
            return str(o***REMOVED***
        elif isinstance(o, uuid.UUID***REMOVED***:
            return str(o***REMOVED***
        elif isinstance(o, Promise***REMOVED***:
            return six.text_type(o***REMOVED***
        else:
            return super(DjangoJSONEncoder, self***REMOVED***.default(o***REMOVED***

# Older, deprecated class name (for backwards compatibility purposes***REMOVED***.
DateTimeAwareJSONEncoder = DjangoJSONEncoder
