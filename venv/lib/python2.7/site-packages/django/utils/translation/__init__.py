***REMOVED***
Internationalization support.
***REMOVED***
from __future__ import unicode_literals

import re

from django.utils import six
from django.utils.decorators import ContextDecorator
from django.utils.encoding import force_text
from django.utils.functional import lazy

__all__ = [
    'activate', 'deactivate', 'override', 'deactivate_all',
    'get_language', 'get_language_from_request',
    'get_language_info', 'get_language_bidi',
    'check_for_language', 'to_locale', 'templatize', 'string_concat',
    'gettext', 'gettext_lazy', 'gettext_noop',
    'ugettext', 'ugettext_lazy', 'ugettext_noop',
    'ngettext', 'ngettext_lazy',
    'ungettext', 'ungettext_lazy',
    'pgettext', 'pgettext_lazy',
    'npgettext', 'npgettext_lazy',
    'LANGUAGE_SESSION_KEY',
***REMOVED***

LANGUAGE_SESSION_KEY = '_language'


class TranslatorCommentWarning(SyntaxWarning***REMOVED***:
    pass


# Here be dragons, so a short explanation of the logic won't hurt:
# We are trying to solve two problems: (1***REMOVED*** access settings, in particular
# settings.USE_I18N, as late as possible, so that modules can be imported
# without having to first configure Django, and (2***REMOVED*** if some other code creates
# a reference to one of these functions, don't break that reference when we
# replace the functions with their real counterparts (once we do access the
# settings***REMOVED***.

class Trans(object***REMOVED***:
    ***REMOVED***
    The purpose of this class is to store the actual translation function upon
    receiving the first call to that function. After this is done, changes to
    USE_I18N will have no effect to which function is served upon request. If
    your tests rely on changing USE_I18N, you can delete all the functions
    from _trans.__dict__.

    Note that storing the function with setattr will have a noticeable
    performance effect, as access to the function goes the normal path,
    instead of using __getattr__.
    ***REMOVED***

    def __getattr__(self, real_name***REMOVED***:
        from django.conf import settings
        if settings.USE_I18N:
            from django.utils.translation import trans_real as trans
        else:
            from django.utils.translation import trans_null as trans
        setattr(self, real_name, getattr(trans, real_name***REMOVED******REMOVED***
        return getattr(trans, real_name***REMOVED***

_trans = Trans(***REMOVED***

# The Trans class is no more needed, so remove it from the namespace.
del Trans


def gettext_noop(message***REMOVED***:
    return _trans.gettext_noop(message***REMOVED***

ugettext_noop = gettext_noop


def gettext(message***REMOVED***:
    return _trans.gettext(message***REMOVED***


def ngettext(singular, plural, number***REMOVED***:
    return _trans.ngettext(singular, plural, number***REMOVED***


def ugettext(message***REMOVED***:
    return _trans.ugettext(message***REMOVED***


def ungettext(singular, plural, number***REMOVED***:
    return _trans.ungettext(singular, plural, number***REMOVED***


def pgettext(context, message***REMOVED***:
    return _trans.pgettext(context, message***REMOVED***


def npgettext(context, singular, plural, number***REMOVED***:
    return _trans.npgettext(context, singular, plural, number***REMOVED***

gettext_lazy = lazy(gettext, str***REMOVED***
ugettext_lazy = lazy(ugettext, six.text_type***REMOVED***
pgettext_lazy = lazy(pgettext, six.text_type***REMOVED***


def lazy_number(func, resultclass, number=None, **kwargs***REMOVED***:
    if isinstance(number, six.integer_types***REMOVED***:
        kwargs['number'***REMOVED*** = number
        proxy = lazy(func, resultclass***REMOVED***(**kwargs***REMOVED***
    else:
        original_kwargs = kwargs.copy(***REMOVED***

        class NumberAwareString(resultclass***REMOVED***:
            def __bool__(self***REMOVED***:
                return bool(kwargs['singular'***REMOVED******REMOVED***

            def __nonzero__(self***REMOVED***:  # Python 2 compatibility
                return type(self***REMOVED***.__bool__(self***REMOVED***

            def __mod__(self, rhs***REMOVED***:
                if isinstance(rhs, dict***REMOVED*** and number:
                    ***REMOVED***
                        number_value = rhs[number***REMOVED***
                    except KeyError:
                        raise KeyError(
                            "Your dictionary lacks key '%s\'. Please provide "
                            "it, because it is required to determine whether "
                            "string is singular or plural." % number
                        ***REMOVED***
                else:
                    number_value = rhs
                kwargs['number'***REMOVED*** = number_value
                translated = func(**kwargs***REMOVED***
                ***REMOVED***
                    translated = translated % rhs
                except TypeError:
                    # String doesn't contain a placeholder for the number
                    pass
                return translated

        proxy = lazy(lambda **kwargs: NumberAwareString(***REMOVED***, NumberAwareString***REMOVED***(**kwargs***REMOVED***
        proxy.__reduce__ = lambda: (_lazy_number_unpickle, (func, resultclass, number, original_kwargs***REMOVED******REMOVED***
    return proxy


def _lazy_number_unpickle(func, resultclass, number, kwargs***REMOVED***:
    return lazy_number(func, resultclass, number=number, **kwargs***REMOVED***


def ngettext_lazy(singular, plural, number=None***REMOVED***:
    return lazy_number(ngettext, str, singular=singular, plural=plural, number=number***REMOVED***


def ungettext_lazy(singular, plural, number=None***REMOVED***:
    return lazy_number(ungettext, six.text_type, singular=singular, plural=plural, number=number***REMOVED***


def npgettext_lazy(context, singular, plural, number=None***REMOVED***:
    return lazy_number(npgettext, six.text_type, context=context, singular=singular, plural=plural, number=number***REMOVED***


def activate(language***REMOVED***:
    return _trans.activate(language***REMOVED***


def deactivate(***REMOVED***:
    return _trans.deactivate(***REMOVED***


class override(ContextDecorator***REMOVED***:
    def __init__(self, language, deactivate=False***REMOVED***:
        self.language = language
        self.deactivate = deactivate

    def __enter__(self***REMOVED***:
        self.old_language = get_language(***REMOVED***
        if self.language is not None:
            activate(self.language***REMOVED***
        else:
            deactivate_all(***REMOVED***

    def __exit__(self, exc_type, exc_value, traceback***REMOVED***:
        if self.old_language is None:
            deactivate_all(***REMOVED***
        elif self.deactivate:
            deactivate(***REMOVED***
        else:
            activate(self.old_language***REMOVED***


def get_language(***REMOVED***:
    return _trans.get_language(***REMOVED***


def get_language_bidi(***REMOVED***:
    return _trans.get_language_bidi(***REMOVED***


def check_for_language(lang_code***REMOVED***:
    return _trans.check_for_language(lang_code***REMOVED***


def to_locale(language***REMOVED***:
    return _trans.to_locale(language***REMOVED***


def get_language_from_request(request, check_path=False***REMOVED***:
    return _trans.get_language_from_request(request, check_path***REMOVED***


def get_language_from_path(path***REMOVED***:
    return _trans.get_language_from_path(path***REMOVED***


def templatize(src, origin=None***REMOVED***:
    return _trans.templatize(src, origin***REMOVED***


def deactivate_all(***REMOVED***:
    return _trans.deactivate_all(***REMOVED***


def _string_concat(*strings***REMOVED***:
    ***REMOVED***
    Lazy variant of string concatenation, needed for translations that are
    constructed from multiple parts.
    ***REMOVED***
    return ''.join(force_text(s***REMOVED*** for s in strings***REMOVED***
string_concat = lazy(_string_concat, six.text_type***REMOVED***


def get_language_info(lang_code***REMOVED***:
    from django.conf.locale import LANG_INFO
    ***REMOVED***
        lang_info = LANG_INFO[lang_code***REMOVED***
        if 'fallback' in lang_info and 'name' not in lang_info:
            info = get_language_info(lang_info['fallback'***REMOVED***[0***REMOVED******REMOVED***
        else:
            info = lang_info
    except KeyError:
        if '-' not in lang_code:
            raise KeyError("Unknown language code %s." % lang_code***REMOVED***
        generic_lang_code = lang_code.split('-'***REMOVED***[0***REMOVED***
        ***REMOVED***
            info = LANG_INFO[generic_lang_code***REMOVED***
        except KeyError:
            raise KeyError("Unknown language code %s and %s." % (lang_code, generic_lang_code***REMOVED******REMOVED***

    if info:
        info['name_translated'***REMOVED*** = ugettext_lazy(info['name'***REMOVED******REMOVED***
    return info

trim_whitespace_re = re.compile('\s*\n\s*'***REMOVED***


def trim_whitespace(s***REMOVED***:
    return trim_whitespace_re.sub(' ', s.strip(***REMOVED******REMOVED***
