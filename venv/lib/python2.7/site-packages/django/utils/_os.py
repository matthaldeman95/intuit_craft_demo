from __future__ import unicode_literals

***REMOVED***
import sys
import tempfile
from os.path import abspath, dirname, isabs, join, normcase, normpath, sep

from django.core.exceptions import SuspiciousFileOperation
from django.utils import six
from django.utils.encoding import force_text

if six.PY2:
    fs_encoding = sys.getfilesystemencoding(***REMOVED*** or sys.getdefaultencoding(***REMOVED***


# Under Python 2, define our own abspath function that can handle joining
# unicode paths to a current working directory that has non-ASCII characters
# in it.  This isn't necessary on Windows since the Windows version of abspath
# handles this correctly. It also handles drive letters differently than the
# pure Python implementation, so it's best not to replace it.
if six.PY3 or os.name == 'nt':
    abspathu = abspath
else:
    def abspathu(path***REMOVED***:
        ***REMOVED***
        Version of os.path.abspath that uses the unicode representation
        of the current working directory, thus avoiding a UnicodeDecodeError
        in join when the cwd has non-ASCII characters.
        ***REMOVED***
        if not isabs(path***REMOVED***:
            path = join(os.getcwdu(***REMOVED***, path***REMOVED***
        return normpath(path***REMOVED***


def upath(path***REMOVED***:
    ***REMOVED***
    Always return a unicode path.
    ***REMOVED***
    if six.PY2 and not isinstance(path, six.text_type***REMOVED***:
        return path.decode(fs_encoding***REMOVED***
    return path


def npath(path***REMOVED***:
    ***REMOVED***
    Always return a native path, that is unicode on Python 3 and bytestring on
    Python 2.
    ***REMOVED***
    if six.PY2 and not isinstance(path, bytes***REMOVED***:
        return path.encode(fs_encoding***REMOVED***
    return path


def safe_join(base, *paths***REMOVED***:
    ***REMOVED***
    Joins one or more path components to the base path component intelligently.
    Returns a normalized, absolute version of the final path.

    The final path must be located inside of the base path component (otherwise
    a ValueError is raised***REMOVED***.
    ***REMOVED***
    base = force_text(base***REMOVED***
    paths = [force_text(p***REMOVED*** for p in paths***REMOVED***
    final_path = abspathu(join(base, *paths***REMOVED******REMOVED***
    base_path = abspathu(base***REMOVED***
    # Ensure final_path starts with base_path (using normcase to ensure we
    # don't false-negative on case insensitive operating systems like Windows***REMOVED***,
    # further, one of the following conditions must be true:
    #  a***REMOVED*** The next character is the path separator (to prevent conditions like
    #     safe_join("/dir", "/../d"***REMOVED******REMOVED***
    #  b***REMOVED*** The final path must be the same as the base path.
    #  c***REMOVED*** The base path must be the most root path (meaning either "/" or "C:\\"***REMOVED***
    if (not normcase(final_path***REMOVED***.startswith(normcase(base_path + sep***REMOVED******REMOVED*** and
            normcase(final_path***REMOVED*** != normcase(base_path***REMOVED*** and
            dirname(normcase(base_path***REMOVED******REMOVED*** != normcase(base_path***REMOVED******REMOVED***:
        raise SuspiciousFileOperation(
            'The joined path ({***REMOVED******REMOVED*** is located outside of the base path '
            'component ({***REMOVED******REMOVED***'.format(final_path, base_path***REMOVED******REMOVED***
    return final_path


def symlinks_supported(***REMOVED***:
    ***REMOVED***
    A function to check if creating symlinks are supported in the
    host platform and/or if they are allowed to be created (e.g.
    on Windows it requires admin permissions***REMOVED***.
    ***REMOVED***
    tmpdir = tempfile.mkdtemp(***REMOVED***
    original_path = os.path.join(tmpdir, 'original'***REMOVED***
    symlink_path = os.path.join(tmpdir, 'symlink'***REMOVED***
    os.makedirs(original_path***REMOVED***
    ***REMOVED***
        os.symlink(original_path, symlink_path***REMOVED***
        supported = True
    except (OSError, NotImplementedError, AttributeError***REMOVED***:
        supported = False
    else:
        os.remove(symlink_path***REMOVED***
    finally:
        os.rmdir(original_path***REMOVED***
        os.rmdir(tmpdir***REMOVED***
        return supported
