***REMOVED***
A class for storing a tree graph. Primarily used for filter constructs in the
ORM.
***REMOVED***

import copy

from django.utils.encoding import force_str, force_text


class Node(object***REMOVED***:
    ***REMOVED***
    A single internal node in the tree graph. A Node should be viewed as a
    connection (the root***REMOVED*** with the children being either leaf nodes or other
    Node instances.
    ***REMOVED***
    # Standard connector type. Clients usually won't use this at all and
    # subclasses will usually override the value.
    default = 'DEFAULT'

    def __init__(self, children=None, connector=None, negated=False***REMOVED***:
        ***REMOVED***
        Constructs a new Node. If no connector is given, the default will be
        used.
        ***REMOVED***
        self.children = children[:***REMOVED*** if children else [***REMOVED***
        self.connector = connector or self.default
        self.negated = negated

    # We need this because of django.db.models.query_utils.Q. Q. __init__(***REMOVED*** is
    # problematic, but it is a natural Node subclass in all other respects.
    @classmethod
    def _new_instance(cls, children=None, connector=None, negated=False***REMOVED***:
        ***REMOVED***
        This is called to create a new instance of this class when we need new
        Nodes (or subclasses***REMOVED*** in the internal code in this class. Normally, it
        just shadows __init__(***REMOVED***. However, subclasses with an __init__ signature
        that is not an extension of Node.__init__ might need to implement this
        method to allow a Node to create a new instance of them (if they have
        any extra setting up to do***REMOVED***.
        ***REMOVED***
        obj = Node(children, connector, negated***REMOVED***
        obj.__class__ = cls
        return obj

    def __str__(self***REMOVED***:
        template = '(NOT (%s: %s***REMOVED******REMOVED***' if self.negated else '(%s: %s***REMOVED***'
        return force_str(template % (self.connector, ', '.join(force_text(c***REMOVED*** for c in self.children***REMOVED******REMOVED******REMOVED***

    def __repr__(self***REMOVED***:
        return str("<%s: %s>"***REMOVED*** % (self.__class__.__name__, self***REMOVED***

    def __deepcopy__(self, memodict***REMOVED***:
        ***REMOVED***
        Utility method used by copy.deepcopy(***REMOVED***.
        ***REMOVED***
        obj = Node(connector=self.connector, negated=self.negated***REMOVED***
        obj.__class__ = self.__class__
        obj.children = copy.deepcopy(self.children, memodict***REMOVED***
        return obj

    def __len__(self***REMOVED***:
        ***REMOVED***
        The size of a node if the number of children it has.
        ***REMOVED***
        return len(self.children***REMOVED***

    def __bool__(self***REMOVED***:
        ***REMOVED***
        For truth value testing.
        ***REMOVED***
        return bool(self.children***REMOVED***

    def __nonzero__(self***REMOVED***:      # Python 2 compatibility
        return type(self***REMOVED***.__bool__(self***REMOVED***

    def __contains__(self, other***REMOVED***:
        ***REMOVED***
        Returns True is 'other' is a direct child of this instance.
        ***REMOVED***
        return other in self.children

    def add(self, data, conn_type, squash=True***REMOVED***:
        ***REMOVED***
        Combines this tree and the data represented by data using the
        connector conn_type. The combine is done by squashing the node other
        away if possible.

        This tree (self***REMOVED*** will never be pushed to a child node of the
        combined tree, nor will the connector or negated properties change.

        The function returns a node which can be used in place of data
        regardless if the node other got squashed or not.

        If `squash` is False the data is prepared and added as a child to
        this tree without further logic.
        ***REMOVED***
        if data in self.children:
            return data
        if not squash:
            self.children.append(data***REMOVED***
            return data
        if self.connector == conn_type:
            # We can reuse self.children to append or squash the node other.
            if (isinstance(data, Node***REMOVED*** and not data.negated and
                    (data.connector == conn_type or len(data***REMOVED*** == 1***REMOVED******REMOVED***:
                # We can squash the other node's children directly into this
                # node. We are just doing (AB***REMOVED***(CD***REMOVED*** == (ABCD***REMOVED*** here, with the
                # addition that if the length of the other node is 1 the
                # connector doesn't matter. However, for the len(self***REMOVED*** == 1
                # case we don't want to do the squashing, as it would alter
                # self.connector.
                self.children.extend(data.children***REMOVED***
                return self
            else:
                # We could use perhaps additional logic here to see if some
                # children could be used for pushdown here.
                self.children.append(data***REMOVED***
                return data
        else:
            obj = self._new_instance(self.children, self.connector,
                                     self.negated***REMOVED***
            self.connector = conn_type
            self.children = [obj, data***REMOVED***
            return data

    def negate(self***REMOVED***:
        ***REMOVED***
        Negate the sense of the root connector.
        ***REMOVED***
        self.negated = not self.negated
