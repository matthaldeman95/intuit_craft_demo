# This code was mostly based on ipaddr-py
# Copyright 2007 Google Inc. https://github.com/google/ipaddr-py
# Licensed under the Apache License, Version 2.0 (the "License"***REMOVED***.
import re

from django.core.exceptions import ValidationError
from django.utils.six.moves import range
from django.utils.translation import ugettext_lazy as _


def clean_ipv6_address(ip_str, unpack_ipv4=False,
                       error_message=_("This is not a valid IPv6 address."***REMOVED******REMOVED***:
    ***REMOVED***
    Cleans an IPv6 address string.

    Validity is checked by calling is_valid_ipv6_address(***REMOVED*** - if an
    invalid address is passed, ValidationError is raised.

    Replaces the longest continuous zero-sequence with "::" and
    removes leading zeroes and makes sure all hextets are lowercase.

    Args:
        ip_str: A valid IPv6 address.
        unpack_ipv4: if an IPv4-mapped address is found,
        return the plain IPv4 address (default=False***REMOVED***.
        error_message: An error message used in the ValidationError.

    Returns:
        A compressed IPv6 address, or the same value
    ***REMOVED***
    best_doublecolon_start = -1
    best_doublecolon_len = 0
    doublecolon_start = -1
    doublecolon_len = 0

    if not is_valid_ipv6_address(ip_str***REMOVED***:
        raise ValidationError(error_message, code='invalid'***REMOVED***

    # This algorithm can only handle fully exploded
    # IP strings
    ip_str = _explode_shorthand_ip_string(ip_str***REMOVED***

    ip_str = _sanitize_ipv4_mapping(ip_str***REMOVED***

    # If needed, unpack the IPv4 and return straight away
    # - no need in running the rest of the algorithm
    if unpack_ipv4:
        ipv4_unpacked = _unpack_ipv4(ip_str***REMOVED***

        if ipv4_unpacked:
            return ipv4_unpacked

    hextets = ip_str.split(":"***REMOVED***

    for index in range(len(hextets***REMOVED******REMOVED***:
        # Remove leading zeroes
        if '.' not in hextets[index***REMOVED***:
            hextets[index***REMOVED*** = hextets[index***REMOVED***.lstrip('0'***REMOVED***
        if not hextets[index***REMOVED***:
            hextets[index***REMOVED*** = '0'

        # Determine best hextet to compress
        if hextets[index***REMOVED*** == '0':
            doublecolon_len += 1
            if doublecolon_start == -1:
                # Start of a sequence of zeros.
                doublecolon_start = index
            if doublecolon_len > best_doublecolon_len:
                # This is the longest sequence of zeros so far.
                best_doublecolon_len = doublecolon_len
                best_doublecolon_start = doublecolon_start
        else:
            doublecolon_len = 0
            doublecolon_start = -1

    # Compress the most suitable hextet
    if best_doublecolon_len > 1:
        best_doublecolon_end = (best_doublecolon_start +
                                best_doublecolon_len***REMOVED***
        # For zeros at the end of the address.
        if best_doublecolon_end == len(hextets***REMOVED***:
            hextets += [''***REMOVED***
        hextets[best_doublecolon_start:best_doublecolon_end***REMOVED*** = [''***REMOVED***
        # For zeros at the beginning of the address.
        if best_doublecolon_start == 0:
            hextets = [''***REMOVED*** + hextets

    result = ":".join(hextets***REMOVED***

    return result.lower(***REMOVED***


def _sanitize_ipv4_mapping(ip_str***REMOVED***:
    ***REMOVED***
    Sanitize IPv4 mapping in an expanded IPv6 address.

    This converts ::ffff:0a0a:0a0a to ::ffff:10.10.10.10.
    If there is nothing to sanitize, returns an unchanged
    string.

    Args:
        ip_str: A string, the expanded IPv6 address.

    Returns:
        The sanitized output string, if applicable.
    ***REMOVED***
    if not ip_str.lower(***REMOVED***.startswith('0000:0000:0000:0000:0000:ffff:'***REMOVED***:
        # not an ipv4 mapping
        return ip_str

    hextets = ip_str.split(':'***REMOVED***

    if '.' in hextets[-1***REMOVED***:
        # already sanitized
        return ip_str

    ipv4_address = "%d.%d.%d.%d" % (
        int(hextets[6***REMOVED***[0:2***REMOVED***, 16***REMOVED***,
        int(hextets[6***REMOVED***[2:4***REMOVED***, 16***REMOVED***,
        int(hextets[7***REMOVED***[0:2***REMOVED***, 16***REMOVED***,
        int(hextets[7***REMOVED***[2:4***REMOVED***, 16***REMOVED***,
    ***REMOVED***

    result = ':'.join(hextets[0:6***REMOVED******REMOVED***
    result += ':' + ipv4_address

    return result


def _unpack_ipv4(ip_str***REMOVED***:
    ***REMOVED***
    Unpack an IPv4 address that was mapped in a compressed IPv6 address.

    This converts 0000:0000:0000:0000:0000:ffff:10.10.10.10 to 10.10.10.10.
    If there is nothing to sanitize, returns None.

    Args:
        ip_str: A string, the expanded IPv6 address.

    Returns:
        The unpacked IPv4 address, or None if there was nothing to unpack.
    ***REMOVED***
    if not ip_str.lower(***REMOVED***.startswith('0000:0000:0000:0000:0000:ffff:'***REMOVED***:
        return None

    return ip_str.rsplit(':', 1***REMOVED***[1***REMOVED***


def is_valid_ipv6_address(ip_str***REMOVED***:
    ***REMOVED***
    Ensure we have a valid IPv6 address.

    Args:
        ip_str: A string, the IPv6 address.

    Returns:
        A boolean, True if this is a valid IPv6 address.
    ***REMOVED***
    from django.core.validators import validate_ipv4_address

    symbols_re = re.compile(r'^[0-9a-fA-F:.***REMOVED***+$'***REMOVED***
    if not symbols_re.match(ip_str***REMOVED***:
        return False

    # We need to have at least one ':'.
    if ':' not in ip_str:
        return False

    # We can only have one '::' shortener.
    if ip_str.count('::'***REMOVED*** > 1:
        return False

    # '::' should be encompassed by start, digits or end.
    if ':::' in ip_str:
        return False

    # A single colon can neither start nor end an address.
    if ((ip_str.startswith(':'***REMOVED*** and not ip_str.startswith('::'***REMOVED******REMOVED*** or
            (ip_str.endswith(':'***REMOVED*** and not ip_str.endswith('::'***REMOVED******REMOVED******REMOVED***:
        return False

    # We can never have more than 7 ':' (1::2:3:4:5:6:7:8 is invalid***REMOVED***
    if ip_str.count(':'***REMOVED*** > 7:
        return False

    # If we have no concatenation, we need to have 8 fields with 7 ':'.
    if '::' not in ip_str and ip_str.count(':'***REMOVED*** != 7:
        # We might have an IPv4 mapped address.
        if ip_str.count('.'***REMOVED*** != 3:
            return False

    ip_str = _explode_shorthand_ip_string(ip_str***REMOVED***

    # Now that we have that all squared away, let's check that each of the
    # hextets are between 0x0 and 0xFFFF.
    for hextet in ip_str.split(':'***REMOVED***:
        if hextet.count('.'***REMOVED*** == 3:
            # If we have an IPv4 mapped address, the IPv4 portion has to
            # be at the end of the IPv6 portion.
            if not ip_str.split(':'***REMOVED***[-1***REMOVED*** == hextet:
                return False
            ***REMOVED***
                validate_ipv4_address(hextet***REMOVED***
            except ValidationError:
                return False
        else:
            ***REMOVED***
                # a value error here means that we got a bad hextet,
                # something like 0xzzzz
                if int(hextet, 16***REMOVED*** < 0x0 or int(hextet, 16***REMOVED*** > 0xFFFF:
                    return False
            except ValueError:
                return False
    return True


def _explode_shorthand_ip_string(ip_str***REMOVED***:
    ***REMOVED***
    Expand a shortened IPv6 address.

    Args:
        ip_str: A string, the IPv6 address.

    Returns:
        A string, the expanded IPv6 address.
    ***REMOVED***
    if not _is_shorthand_ip(ip_str***REMOVED***:
        # We've already got a longhand ip_str.
        return ip_str

    new_ip = [***REMOVED***
    hextet = ip_str.split('::'***REMOVED***

    # If there is a ::, we need to expand it with zeroes
    # to get to 8 hextets - unless there is a dot in the last hextet,
    # meaning we're doing v4-mapping
    if '.' in ip_str.split(':'***REMOVED***[-1***REMOVED***:
        fill_to = 7
    else:
        fill_to = 8

    if len(hextet***REMOVED*** > 1:
        sep = len(hextet[0***REMOVED***.split(':'***REMOVED******REMOVED*** + len(hextet[1***REMOVED***.split(':'***REMOVED******REMOVED***
        new_ip = hextet[0***REMOVED***.split(':'***REMOVED***

        for __ in range(fill_to - sep***REMOVED***:
            new_ip.append('0000'***REMOVED***
        new_ip += hextet[1***REMOVED***.split(':'***REMOVED***

    else:
        new_ip = ip_str.split(':'***REMOVED***

    # Now need to make sure every hextet is 4 lower case characters.
    # If a hextet is < 4 characters, we've got missing leading 0's.
    ret_ip = [***REMOVED***
    for hextet in new_ip:
        ret_ip.append(('0' * (4 - len(hextet***REMOVED******REMOVED*** + hextet***REMOVED***.lower(***REMOVED******REMOVED***
    return ':'.join(ret_ip***REMOVED***


def _is_shorthand_ip(ip_str***REMOVED***:
    ***REMOVED***Determine if the address is shortened.

    Args:
        ip_str: A string, the IPv6 address.

    Returns:
        A boolean, True if the address is shortened.
    ***REMOVED***
    if ip_str.count('::'***REMOVED*** == 1:
        return True
    if any(len(x***REMOVED*** < 4 for x in ip_str.split(':'***REMOVED******REMOVED***:
        return True
    return False
