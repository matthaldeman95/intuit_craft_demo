***REMOVED***
Synchronization primitives:

    - reader-writer lock (preference to writers***REMOVED***

(Contributed to Django by eugene@lazutkin.com***REMOVED***
***REMOVED***

import contextlib
import threading


class RWLock(object***REMOVED***:
    ***REMOVED***
    Classic implementation of reader-writer lock with preference to writers.

    Readers can access a resource simultaneously.
    Writers get an exclusive access.

    API is self-descriptive:
        reader_enters(***REMOVED***
        reader_leaves(***REMOVED***
        writer_enters(***REMOVED***
        writer_leaves(***REMOVED***
    ***REMOVED***
    def __init__(self***REMOVED***:
        self.mutex = threading.RLock(***REMOVED***
        self.can_read = threading.Semaphore(0***REMOVED***
        self.can_write = threading.Semaphore(0***REMOVED***
        self.active_readers = 0
        self.active_writers = 0
        self.waiting_readers = 0
        self.waiting_writers = 0

    def reader_enters(self***REMOVED***:
        with self.mutex:
            if self.active_writers == 0 and self.waiting_writers == 0:
                self.active_readers += 1
                self.can_read.release(***REMOVED***
            else:
                self.waiting_readers += 1
        self.can_read.acquire(***REMOVED***

    def reader_leaves(self***REMOVED***:
        with self.mutex:
            self.active_readers -= 1
            if self.active_readers == 0 and self.waiting_writers != 0:
                self.active_writers += 1
                self.waiting_writers -= 1
                self.can_write.release(***REMOVED***

    @contextlib.contextmanager
    def reader(self***REMOVED***:
        self.reader_enters(***REMOVED***
        ***REMOVED***
            yield
        finally:
            self.reader_leaves(***REMOVED***

    def writer_enters(self***REMOVED***:
        with self.mutex:
            if self.active_writers == 0 and self.waiting_writers == 0 and self.active_readers == 0:
                self.active_writers += 1
                self.can_write.release(***REMOVED***
            else:
                self.waiting_writers += 1
        self.can_write.acquire(***REMOVED***

    def writer_leaves(self***REMOVED***:
        with self.mutex:
            self.active_writers -= 1
            if self.waiting_writers != 0:
                self.active_writers += 1
                self.waiting_writers -= 1
                self.can_write.release(***REMOVED***
            elif self.waiting_readers != 0:
                t = self.waiting_readers
                self.waiting_readers = 0
                self.active_readers += t
                while t > 0:
                    self.can_read.release(***REMOVED***
                    t -= 1

    @contextlib.contextmanager
    def writer(self***REMOVED***:
        self.writer_enters(***REMOVED***
        ***REMOVED***
            yield
        finally:
            self.writer_leaves(***REMOVED***
