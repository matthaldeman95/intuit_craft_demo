"Functions that help with dynamically creating decorators for views."

***REMOVED***
    from contextlib import ContextDecorator
except ImportError:
    ContextDecorator = None

from functools import WRAPPER_ASSIGNMENTS, update_wrapper, wraps

from django.utils import six


class classonlymethod(classmethod***REMOVED***:
    def __get__(self, instance, cls=None***REMOVED***:
        if instance is not None:
            raise AttributeError("This method is available only on the class, not on instances."***REMOVED***
        return super(classonlymethod, self***REMOVED***.__get__(instance, cls***REMOVED***


def method_decorator(decorator, name=''***REMOVED***:
    ***REMOVED***
    Converts a function decorator into a method decorator
    ***REMOVED***
    # 'obj' can be a class or a function. If 'obj' is a function at the time it
    # is passed to _dec,  it will eventually be a method of the class it is
    # defined on. If 'obj' is a class, the 'name' is required to be the name
    # of the method that will be decorated.
    def _dec(obj***REMOVED***:
        is_class = isinstance(obj, type***REMOVED***
        if is_class:
            if name and hasattr(obj, name***REMOVED***:
                func = getattr(obj, name***REMOVED***
                if not callable(func***REMOVED***:
                    raise TypeError(
                        "Cannot decorate '{0***REMOVED***' as it isn't a callable "
                        "attribute of {1***REMOVED*** ({2***REMOVED******REMOVED***".format(name, obj, func***REMOVED***
                    ***REMOVED***
            else:
                raise ValueError(
                    "The keyword argument `name` must be the name of a method "
                    "of the decorated class: {0***REMOVED***. Got '{1***REMOVED***' instead".format(
                        obj, name,
                    ***REMOVED***
                ***REMOVED***
        else:
            func = obj

        def decorate(function***REMOVED***:
            ***REMOVED***
            Apply a list/tuple of decorators if decorator is one. Decorator
            functions are applied so that the call order is the same as the
            order in which they appear in the iterable.
            ***REMOVED***
            if hasattr(decorator, '__iter__'***REMOVED***:
                for dec in decorator[::-1***REMOVED***:
                    function = dec(function***REMOVED***
                return function
            return decorator(function***REMOVED***

        def _wrapper(self, *args, **kwargs***REMOVED***:
            @decorate
            def bound_func(*args2, **kwargs2***REMOVED***:
                return func.__get__(self, type(self***REMOVED******REMOVED***(*args2, **kwargs2***REMOVED***
            # bound_func has the signature that 'decorator' expects i.e.  no
            # 'self' argument, but it is a closure over self so it can call
            # 'func' correctly.
            return bound_func(*args, **kwargs***REMOVED***
        # In case 'decorator' adds attributes to the function it decorates, we
        # want to copy those. We don't have access to bound_func in this scope,
        # but we can cheat by using it on a dummy function.

        @decorate
        def dummy(*args, **kwargs***REMOVED***:
            pass
        update_wrapper(_wrapper, dummy***REMOVED***
        # Need to preserve any existing attributes of 'func', including the name.
        update_wrapper(_wrapper, func***REMOVED***

        if is_class:
            setattr(obj, name, _wrapper***REMOVED***
            return obj

        return _wrapper
    # Don't worry about making _dec look similar to a list/tuple as it's rather
    # meaningless.
    if not hasattr(decorator, '__iter__'***REMOVED***:
        update_wrapper(_dec, decorator, assigned=available_attrs(decorator***REMOVED******REMOVED***
    # Change the name to aid debugging.
    if hasattr(decorator, '__name__'***REMOVED***:
        _dec.__name__ = 'method_decorator(%s***REMOVED***' % decorator.__name__
    else:
        _dec.__name__ = 'method_decorator(%s***REMOVED***' % decorator.__class__.__name__
    return _dec


def decorator_from_middleware_with_args(middleware_class***REMOVED***:
    ***REMOVED***
    Like decorator_from_middleware, but returns a function
    that accepts the arguments to be passed to the middleware_class.
    Use like::

         cache_page = decorator_from_middleware_with_args(CacheMiddleware***REMOVED***
         # ...

         @cache_page(3600***REMOVED***
         def my_view(request***REMOVED***:
             # ...
    ***REMOVED***
    return make_middleware_decorator(middleware_class***REMOVED***


def decorator_from_middleware(middleware_class***REMOVED***:
    ***REMOVED***
    Given a middleware class (not an instance***REMOVED***, returns a view decorator. This
    lets you use middleware functionality on a per-view basis. The middleware
    is created with no params passed.
    ***REMOVED***
    return make_middleware_decorator(middleware_class***REMOVED***(***REMOVED***


def available_attrs(fn***REMOVED***:
    ***REMOVED***
    Return the list of functools-wrappable attributes on a callable.
    This is required as a workaround for http://bugs.python.org/issue3445
    under Python 2.
    ***REMOVED***
    if six.PY3:
        return WRAPPER_ASSIGNMENTS
    else:
        return tuple(a for a in WRAPPER_ASSIGNMENTS if hasattr(fn, a***REMOVED******REMOVED***


def make_middleware_decorator(middleware_class***REMOVED***:
    def _make_decorator(*m_args, **m_kwargs***REMOVED***:
        middleware = middleware_class(*m_args, **m_kwargs***REMOVED***

        def _decorator(view_func***REMOVED***:
            @wraps(view_func, assigned=available_attrs(view_func***REMOVED******REMOVED***
            def _wrapped_view(request, *args, **kwargs***REMOVED***:
                if hasattr(middleware, 'process_request'***REMOVED***:
                    result = middleware.process_request(request***REMOVED***
                    if result is not None:
                        return result
                if hasattr(middleware, 'process_view'***REMOVED***:
                    result = middleware.process_view(request, view_func, args, kwargs***REMOVED***
                    if result is not None:
                        return result
                ***REMOVED***
                    response = view_func(request, *args, **kwargs***REMOVED***
                except Exception as e:
                    if hasattr(middleware, 'process_exception'***REMOVED***:
                        result = middleware.process_exception(request, e***REMOVED***
                        if result is not None:
                            return result
                    raise
                if hasattr(response, 'render'***REMOVED*** and callable(response.render***REMOVED***:
                    if hasattr(middleware, 'process_template_response'***REMOVED***:
                        response = middleware.process_template_response(request, response***REMOVED***
                    # Defer running of process_response until after the template
                    # has been rendered:
                    if hasattr(middleware, 'process_response'***REMOVED***:
                        def callback(response***REMOVED***:
                            return middleware.process_response(request, response***REMOVED***
                        response.add_post_render_callback(callback***REMOVED***
                else:
                    if hasattr(middleware, 'process_response'***REMOVED***:
                        return middleware.process_response(request, response***REMOVED***
                return response
            return _wrapped_view
        return _decorator
    return _make_decorator


if ContextDecorator is None:
    # ContextDecorator was introduced in Python 3.2
    # See https://docs.python.org/3/library/contextlib.html#contextlib.ContextDecorator
    class ContextDecorator(object***REMOVED***:
        ***REMOVED***
        A base class that enables a context manager to also be used as a decorator.
        ***REMOVED***
        def __call__(self, func***REMOVED***:
            @wraps(func, assigned=available_attrs(func***REMOVED******REMOVED***
            def inner(*args, **kwargs***REMOVED***:
                with self:
                    return func(*args, **kwargs***REMOVED***
            return inner


class classproperty(object***REMOVED***:
    def __init__(self, method=None***REMOVED***:
        self.fget = method

    def __get__(self, instance, cls=None***REMOVED***:
        return self.fget(cls***REMOVED***

    def getter(self, method***REMOVED***:
        self.fget = method
        return self
