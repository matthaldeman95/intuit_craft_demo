from __future__ import absolute_import

import inspect
import warnings


class RemovedInDjango20Warning(PendingDeprecationWarning***REMOVED***:
    pass


class RemovedInNextVersionWarning(DeprecationWarning***REMOVED***:
    pass


class warn_about_renamed_method(object***REMOVED***:
    def __init__(self, class_name, old_method_name, new_method_name, deprecation_warning***REMOVED***:
        self.class_name = class_name
        self.old_method_name = old_method_name
        self.new_method_name = new_method_name
        self.deprecation_warning = deprecation_warning

    def __call__(self, f***REMOVED***:
        def wrapped(*args, **kwargs***REMOVED***:
            warnings.warn(
                "`%s.%s` is deprecated, use `%s` instead." %
                (self.class_name, self.old_method_name, self.new_method_name***REMOVED***,
                self.deprecation_warning, 2***REMOVED***
            return f(*args, **kwargs***REMOVED***
        return wrapped


class RenameMethodsBase(type***REMOVED***:
    ***REMOVED***
    Handles the deprecation paths when renaming a method.

    It does the following:
        1***REMOVED*** Define the new method if missing and complain about it.
        2***REMOVED*** Define the old method if missing.
        3***REMOVED*** Complain whenever an old method is called.

    See #15363 for more details.
    ***REMOVED***

    renamed_methods = (***REMOVED***

    def __new__(cls, name, bases, attrs***REMOVED***:
        new_class = super(RenameMethodsBase, cls***REMOVED***.__new__(cls, name, bases, attrs***REMOVED***

        for base in inspect.getmro(new_class***REMOVED***:
            class_name = base.__name__
            for renamed_method in cls.renamed_methods:
                old_method_name = renamed_method[0***REMOVED***
                old_method = base.__dict__.get(old_method_name***REMOVED***
                new_method_name = renamed_method[1***REMOVED***
                new_method = base.__dict__.get(new_method_name***REMOVED***
                deprecation_warning = renamed_method[2***REMOVED***
                wrapper = warn_about_renamed_method(class_name, *renamed_method***REMOVED***

                # Define the new method if missing and complain about it
                if not new_method and old_method:
                    warnings.warn(
                        "`%s.%s` method should be renamed `%s`." %
                        (class_name, old_method_name, new_method_name***REMOVED***,
                        deprecation_warning, 2***REMOVED***
                    setattr(base, new_method_name, old_method***REMOVED***
                    setattr(base, old_method_name, wrapper(old_method***REMOVED******REMOVED***

                # Define the old method as a wrapped call to the new method.
                if not old_method and new_method:
                    setattr(base, old_method_name, wrapper(new_method***REMOVED******REMOVED***

        return new_class


class DeprecationInstanceCheck(type***REMOVED***:
    def __instancecheck__(self, instance***REMOVED***:
        warnings.warn(
            "`%s` is deprecated, use `%s` instead." % (self.__name__, self.alternative***REMOVED***,
            self.deprecation_warning, 2
        ***REMOVED***
        return super(DeprecationInstanceCheck, self***REMOVED***.__instancecheck__(instance***REMOVED***


class CallableBool:
    ***REMOVED***
    An boolean-like object that is also callable for backwards compatibility.
    ***REMOVED***
    do_not_call_in_templates = True

    def __init__(self, value***REMOVED***:
        self.value = value

    def __bool__(self***REMOVED***:
        return self.value

    def __call__(self***REMOVED***:
        warnings.warn(
            "Using user.is_authenticated(***REMOVED*** and user.is_anonymous(***REMOVED*** as a method "
            "is deprecated. Remove the parentheses to use it as an attribute.",
            RemovedInDjango20Warning, stacklevel=2
        ***REMOVED***
        return self.value

    def __nonzero__(self***REMOVED***:  # Python 2 compatibility
        return self.value

    def __repr__(self***REMOVED***:
        return 'CallableBool(%r***REMOVED***' % self.value

    def __eq__(self, other***REMOVED***:
        return self.value == other

    def __ne__(self, other***REMOVED***:
        return self.value != other

    def __or__(self, other***REMOVED***:
        return bool(self.value or other***REMOVED***

CallableFalse = CallableBool(False***REMOVED***
CallableTrue = CallableBool(True***REMOVED***


class MiddlewareMixin(object***REMOVED***:
    def __init__(self, get_response=None***REMOVED***:
        self.get_response = get_response
        super(MiddlewareMixin, self***REMOVED***.__init__(***REMOVED***

    def __call__(self, request***REMOVED***:
        response = None
        if hasattr(self, 'process_request'***REMOVED***:
            response = self.process_request(request***REMOVED***
        if not response:
            response = self.get_response(request***REMOVED***
        if hasattr(self, 'process_response'***REMOVED***:
            response = self.process_response(request, response***REMOVED***
        return response
