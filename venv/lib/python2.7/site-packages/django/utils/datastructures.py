import copy
from collections import OrderedDict

from django.utils import six


class OrderedSet(object***REMOVED***:
    ***REMOVED***
    A set which keeps the ordering of the inserted items.
    Currently backs onto OrderedDict.
    ***REMOVED***

    def __init__(self, iterable=None***REMOVED***:
        self.dict = OrderedDict(((x, None***REMOVED*** for x in iterable***REMOVED*** if iterable else [***REMOVED******REMOVED***

    def add(self, item***REMOVED***:
        self.dict[item***REMOVED*** = None

    def remove(self, item***REMOVED***:
        del self.dict[item***REMOVED***

    def discard(self, item***REMOVED***:
        ***REMOVED***
            self.remove(item***REMOVED***
        except KeyError:
            pass

    def __iter__(self***REMOVED***:
        return iter(self.dict.keys(***REMOVED******REMOVED***

    def __contains__(self, item***REMOVED***:
        return item in self.dict

    def __bool__(self***REMOVED***:
        return bool(self.dict***REMOVED***

    def __nonzero__(self***REMOVED***:      # Python 2 compatibility
        return type(self***REMOVED***.__bool__(self***REMOVED***

    def __len__(self***REMOVED***:
        return len(self.dict***REMOVED***


class MultiValueDictKeyError(KeyError***REMOVED***:
    pass


class MultiValueDict(dict***REMOVED***:
    ***REMOVED***
    A subclass of dictionary customized to handle multiple values for the
    same key.

    >>> d = MultiValueDict({'name': ['Adrian', 'Simon'***REMOVED***, 'position': ['Developer'***REMOVED******REMOVED******REMOVED***
    >>> d['name'***REMOVED***
    'Simon'
    >>> d.getlist('name'***REMOVED***
    ['Adrian', 'Simon'***REMOVED***
    >>> d.getlist('doesnotexist'***REMOVED***
    [***REMOVED***
    >>> d.getlist('doesnotexist', ['Adrian', 'Simon'***REMOVED******REMOVED***
    ['Adrian', 'Simon'***REMOVED***
    >>> d.get('lastname', 'nonexistent'***REMOVED***
    'nonexistent'
    >>> d.setlist('lastname', ['Holovaty', 'Willison'***REMOVED******REMOVED***

    This class exists to solve the irritating problem raised by cgi.parse_qs,
    which returns a list for every key, even though most Web forms submit
    single name-value pairs.
    ***REMOVED***
    def __init__(self, key_to_list_mapping=(***REMOVED******REMOVED***:
        super(MultiValueDict, self***REMOVED***.__init__(key_to_list_mapping***REMOVED***

    def __repr__(self***REMOVED***:
        return "<%s: %s>" % (self.__class__.__name__,
                             super(MultiValueDict, self***REMOVED***.__repr__(***REMOVED******REMOVED***

    def __getitem__(self, key***REMOVED***:
        ***REMOVED***
        Returns the last data value for this key, or [***REMOVED*** if it's an empty list;
        raises KeyError if not found.
        ***REMOVED***
        ***REMOVED***
            list_ = super(MultiValueDict, self***REMOVED***.__getitem__(key***REMOVED***
        except KeyError:
            raise MultiValueDictKeyError(repr(key***REMOVED******REMOVED***
        ***REMOVED***
            return list_[-1***REMOVED***
        except IndexError:
            return [***REMOVED***

    def __setitem__(self, key, value***REMOVED***:
        super(MultiValueDict, self***REMOVED***.__setitem__(key, [value***REMOVED******REMOVED***

    def __copy__(self***REMOVED***:
        return self.__class__([
            (k, v[:***REMOVED******REMOVED***
            for k, v in self.lists(***REMOVED***
        ***REMOVED******REMOVED***

    def __deepcopy__(self, memo=None***REMOVED***:
        if memo is None:
            memo = {***REMOVED***
        result = self.__class__(***REMOVED***
        memo[id(self***REMOVED******REMOVED*** = result
        for key, value in dict.items(self***REMOVED***:
            dict.__setitem__(result, copy.deepcopy(key, memo***REMOVED***,
                             copy.deepcopy(value, memo***REMOVED******REMOVED***
        return result

    def __getstate__(self***REMOVED***:
        obj_dict = self.__dict__.copy(***REMOVED***
        obj_dict['_data'***REMOVED*** = {k: self.getlist(k***REMOVED*** for k in self***REMOVED***
        return obj_dict

    def __setstate__(self, obj_dict***REMOVED***:
        data = obj_dict.pop('_data', {***REMOVED******REMOVED***
        for k, v in data.items(***REMOVED***:
            self.setlist(k, v***REMOVED***
        self.__dict__.update(obj_dict***REMOVED***

    def get(self, key, default=None***REMOVED***:
        ***REMOVED***
        Returns the last data value for the passed key. If key doesn't exist
        or value is an empty list, then default is returned.
        ***REMOVED***
        ***REMOVED***
            val = self[key***REMOVED***
        except KeyError:
            return default
        if val == [***REMOVED***:
            return default
        return val

    def getlist(self, key, default=None***REMOVED***:
        ***REMOVED***
        Returns the list of values for the passed key. If key doesn't exist,
        then a default value is returned.
        ***REMOVED***
        ***REMOVED***
            return super(MultiValueDict, self***REMOVED***.__getitem__(key***REMOVED***
        except KeyError:
            if default is None:
                return [***REMOVED***
            return default

    def setlist(self, key, list_***REMOVED***:
        super(MultiValueDict, self***REMOVED***.__setitem__(key, list_***REMOVED***

    def setdefault(self, key, default=None***REMOVED***:
        if key not in self:
            self[key***REMOVED*** = default
            # Do not return default here because __setitem__(***REMOVED*** may store
            # another value -- QueryDict.__setitem__(***REMOVED*** does. Look it up.
        return self[key***REMOVED***

    def setlistdefault(self, key, default_list=None***REMOVED***:
        if key not in self:
            if default_list is None:
                default_list = [***REMOVED***
            self.setlist(key, default_list***REMOVED***
            # Do not return default_list here because setlist(***REMOVED*** may store
            # another value -- QueryDict.setlist(***REMOVED*** does. Look it up.
        return self.getlist(key***REMOVED***

    def appendlist(self, key, value***REMOVED***:
        ***REMOVED***Appends an item to the internal list associated with key.***REMOVED***
        self.setlistdefault(key***REMOVED***.append(value***REMOVED***

    def _iteritems(self***REMOVED***:
        ***REMOVED***
        Yields (key, value***REMOVED*** pairs, where value is the last item in the list
        associated with the key.
        ***REMOVED***
        for key in self:
            yield key, self[key***REMOVED***

    def _iterlists(self***REMOVED***:
        ***REMOVED***Yields (key, list***REMOVED*** pairs.***REMOVED***
        return six.iteritems(super(MultiValueDict, self***REMOVED******REMOVED***

    def _itervalues(self***REMOVED***:
        ***REMOVED***Yield the last value on every key list.***REMOVED***
        for key in self:
            yield self[key***REMOVED***

    if six.PY3:
        items = _iteritems
        lists = _iterlists
        values = _itervalues
    else:
        iteritems = _iteritems
        iterlists = _iterlists
        itervalues = _itervalues

        def items(self***REMOVED***:
            return list(self.iteritems(***REMOVED******REMOVED***

        def lists(self***REMOVED***:
            return list(self.iterlists(***REMOVED******REMOVED***

        def values(self***REMOVED***:
            return list(self.itervalues(***REMOVED******REMOVED***

    def copy(self***REMOVED***:
        ***REMOVED***Returns a shallow copy of this object.***REMOVED***
        return copy.copy(self***REMOVED***

    def update(self, *args, **kwargs***REMOVED***:
        ***REMOVED***
        update(***REMOVED*** extends rather than replaces existing key lists.
        Also accepts keyword args.
        ***REMOVED***
        if len(args***REMOVED*** > 1:
            raise TypeError("update expected at most 1 arguments, got %d" % len(args***REMOVED******REMOVED***
        if args:
            other_dict = args[0***REMOVED***
            if isinstance(other_dict, MultiValueDict***REMOVED***:
                for key, value_list in other_dict.lists(***REMOVED***:
                    self.setlistdefault(key***REMOVED***.extend(value_list***REMOVED***
            else:
                ***REMOVED***
                    for key, value in other_dict.items(***REMOVED***:
                        self.setlistdefault(key***REMOVED***.append(value***REMOVED***
                except TypeError:
                    raise ValueError("MultiValueDict.update(***REMOVED*** takes either a MultiValueDict or dictionary"***REMOVED***
        for key, value in six.iteritems(kwargs***REMOVED***:
            self.setlistdefault(key***REMOVED***.append(value***REMOVED***

    def dict(self***REMOVED***:
        ***REMOVED***
        Returns current object as a dict with singular values.
        ***REMOVED***
        return {key: self[key***REMOVED*** for key in self***REMOVED***


class ImmutableList(tuple***REMOVED***:
    ***REMOVED***
    A tuple-like object that raises useful errors when it is asked to mutate.

    Example::

        >>> a = ImmutableList(range(5***REMOVED***, warning="You cannot mutate this."***REMOVED***
        >>> a[3***REMOVED*** = '4'
        Traceback (most recent call last***REMOVED***:
            ...
        AttributeError: You cannot mutate this.
    ***REMOVED***

    def __new__(cls, *args, **kwargs***REMOVED***:
        if 'warning' in kwargs:
            warning = kwargs['warning'***REMOVED***
            del kwargs['warning'***REMOVED***
        else:
            warning = 'ImmutableList object is immutable.'
        self = tuple.__new__(cls, *args, **kwargs***REMOVED***
        self.warning = warning
        return self

    def complain(self, *wargs, **kwargs***REMOVED***:
        if isinstance(self.warning, Exception***REMOVED***:
            raise self.warning
        else:
            raise AttributeError(self.warning***REMOVED***

    # All list mutation functions complain.
    __delitem__ = complain
    __delslice__ = complain
    __iadd__ = complain
    __imul__ = complain
    __setitem__ = complain
    __setslice__ = complain
    append = complain
    extend = complain
    insert = complain
    pop = complain
    remove = complain
    sort = complain
    reverse = complain


class DictWrapper(dict***REMOVED***:
    ***REMOVED***
    Wraps accesses to a dictionary so that certain values (those starting with
    the specified prefix***REMOVED*** are passed through a function before being returned.
    The prefix is removed before looking up the real value.

    Used by the SQL construction code to ensure that values are correctly
    quoted before being used.
    ***REMOVED***
    def __init__(self, data, func, prefix***REMOVED***:
        super(DictWrapper, self***REMOVED***.__init__(data***REMOVED***
        self.func = func
        self.prefix = prefix

    def __getitem__(self, key***REMOVED***:
        ***REMOVED***
        Retrieves the real value after stripping the prefix string (if
        present***REMOVED***. If the prefix is present, pass the value through self.func
        before returning, otherwise return the raw value.
        ***REMOVED***
        if key.startswith(self.prefix***REMOVED***:
            use_func = True
            key = key[len(self.prefix***REMOVED***:***REMOVED***
        else:
            use_func = False
        value = super(DictWrapper, self***REMOVED***.__getitem__(key***REMOVED***
        if use_func:
            return self.func(value***REMOVED***
        return value
