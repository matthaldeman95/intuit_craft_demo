# -*- encoding: utf-8 -*-
from __future__ import unicode_literals

import codecs
import datetime
import locale
from decimal import Decimal

from django.utils import six
from django.utils.functional import Promise
from django.utils.six.moves.urllib.parse import quote, unquote

if six.PY3:
    from urllib.parse import unquote_to_bytes


class DjangoUnicodeDecodeError(UnicodeDecodeError***REMOVED***:
    def __init__(self, obj, *args***REMOVED***:
        self.obj = obj
        UnicodeDecodeError.__init__(self, *args***REMOVED***

    def __str__(self***REMOVED***:
        original = UnicodeDecodeError.__str__(self***REMOVED***
        return '%s. You passed in %r (%s***REMOVED***' % (original, self.obj, type(self.obj***REMOVED******REMOVED***


# For backwards compatibility. (originally in Django, then added to six 1.9***REMOVED***
python_2_unicode_compatible = six.python_2_unicode_compatible


def smart_text(s, encoding='utf-8', strings_only=False, errors='strict'***REMOVED***:
    ***REMOVED***
    Returns a text object representing 's' -- unicode on Python 2 and str on
    Python 3. Treats bytestrings using the 'encoding' codec.

    If strings_only is True, don't convert (some***REMOVED*** non-string-like objects.
    ***REMOVED***
    if isinstance(s, Promise***REMOVED***:
        # The input is the result of a gettext_lazy(***REMOVED*** call.
        return s
    return force_text(s, encoding, strings_only, errors***REMOVED***


_PROTECTED_TYPES = six.integer_types + (
    type(None***REMOVED***, float, Decimal, datetime.datetime, datetime.date, datetime.time
***REMOVED***


def is_protected_type(obj***REMOVED***:
    ***REMOVED***Determine if the object instance is of a protected type.

    Objects of protected types are preserved as-is when passed to
    force_text(strings_only=True***REMOVED***.
    ***REMOVED***
    return isinstance(obj, _PROTECTED_TYPES***REMOVED***


def force_text(s, encoding='utf-8', strings_only=False, errors='strict'***REMOVED***:
    ***REMOVED***
    Similar to smart_text, except that lazy instances are resolved to
    strings, rather than kept as lazy objects.

    If strings_only is True, don't convert (some***REMOVED*** non-string-like objects.
    ***REMOVED***
    # Handle the common case first for performance reasons.
    if issubclass(type(s***REMOVED***, six.text_type***REMOVED***:
        return s
    if strings_only and is_protected_type(s***REMOVED***:
        return s
    ***REMOVED***
        if not issubclass(type(s***REMOVED***, six.string_types***REMOVED***:
            if six.PY3:
                if isinstance(s, bytes***REMOVED***:
                    s = six.text_type(s, encoding, errors***REMOVED***
                else:
                    s = six.text_type(s***REMOVED***
            elif hasattr(s, '__unicode__'***REMOVED***:
                s = six.text_type(s***REMOVED***
            else:
                s = six.text_type(bytes(s***REMOVED***, encoding, errors***REMOVED***
        else:
            # Note: We use .decode(***REMOVED*** here, instead of six.text_type(s, encoding,
            # errors***REMOVED***, so that if s is a SafeBytes, it ends up being a
            # SafeText at the end.
            s = s.decode(encoding, errors***REMOVED***
    except UnicodeDecodeError as e:
        if not isinstance(s, Exception***REMOVED***:
            raise DjangoUnicodeDecodeError(s, *e.args***REMOVED***
        else:
            # If we get to here, the caller has passed in an Exception
            # subclass populated with non-ASCII bytestring data without a
            # working unicode method. Try to handle this without raising a
            # further exception by individually forcing the exception args
            # to unicode.
            s = ' '.join(force_text(arg, encoding, strings_only, errors***REMOVED***
                         for arg in s***REMOVED***
    return s


def smart_bytes(s, encoding='utf-8', strings_only=False, errors='strict'***REMOVED***:
    ***REMOVED***
    Returns a bytestring version of 's', encoded as specified in 'encoding'.

    If strings_only is True, don't convert (some***REMOVED*** non-string-like objects.
    ***REMOVED***
    if isinstance(s, Promise***REMOVED***:
        # The input is the result of a gettext_lazy(***REMOVED*** call.
        return s
    return force_bytes(s, encoding, strings_only, errors***REMOVED***


def force_bytes(s, encoding='utf-8', strings_only=False, errors='strict'***REMOVED***:
    ***REMOVED***
    Similar to smart_bytes, except that lazy instances are resolved to
    strings, rather than kept as lazy objects.

    If strings_only is True, don't convert (some***REMOVED*** non-string-like objects.
    ***REMOVED***
    # Handle the common case first for performance reasons.
    if isinstance(s, bytes***REMOVED***:
        if encoding == 'utf-8':
            return s
        else:
            return s.decode('utf-8', errors***REMOVED***.encode(encoding, errors***REMOVED***
    if strings_only and is_protected_type(s***REMOVED***:
        return s
    if isinstance(s, six.memoryview***REMOVED***:
        return bytes(s***REMOVED***
    if isinstance(s, Promise***REMOVED***:
        return six.text_type(s***REMOVED***.encode(encoding, errors***REMOVED***
    if not isinstance(s, six.string_types***REMOVED***:
        ***REMOVED***
            if six.PY3:
                return six.text_type(s***REMOVED***.encode(encoding***REMOVED***
            else:
                return bytes(s***REMOVED***
        except UnicodeEncodeError:
            if isinstance(s, Exception***REMOVED***:
                # An Exception subclass containing non-ASCII data that doesn't
                # know how to print itself properly. We shouldn't raise a
                # further exception.
                return b' '.join(force_bytes(arg, encoding, strings_only, errors***REMOVED***
                                 for arg in s***REMOVED***
            return six.text_type(s***REMOVED***.encode(encoding, errors***REMOVED***
    else:
        return s.encode(encoding, errors***REMOVED***

if six.PY3:
    smart_str = smart_text
    force_str = force_text
else:
    smart_str = smart_bytes
    force_str = force_bytes
    # backwards compatibility for Python 2
    smart_unicode = smart_text
    force_unicode = force_text

smart_str.__doc__ = ***REMOVED***
Apply smart_text in Python 3 and smart_bytes in Python 2.

This is suitable for writing to sys.stdout (for instance***REMOVED***.
***REMOVED***

force_str.__doc__ = ***REMOVED***
Apply force_text in Python 3 and force_bytes in Python 2.
***REMOVED***


def iri_to_uri(iri***REMOVED***:
    ***REMOVED***
    Convert an Internationalized Resource Identifier (IRI***REMOVED*** portion to a URI
    portion that is suitable for inclusion in a URL.

    This is the algorithm from section 3.1 of RFC 3987.  However, since we are
    assuming input is either UTF-8 or unicode already, we can simplify things a
    little from the full method.

    Takes an IRI in UTF-8 bytes (e.g. '/I \xe2\x99\xa5 Django/'***REMOVED*** or unicode
    (e.g. '/I â™¥ Django/'***REMOVED*** and returns ASCII bytes containing the encoded result
    (e.g. '/I%20%E2%99%A5%20Django/'***REMOVED***.
    ***REMOVED***
    # The list of safe characters here is constructed from the "reserved" and
    # "unreserved" characters specified in sections 2.2 and 2.3 of RFC 3986:
    #     reserved    = gen-delims / sub-delims
    #     gen-delims  = ":" / "/" / "?" / "#" / "[" / "***REMOVED***" / "@"
    #     sub-delims  = "!" / "$" / "&" / "'" / "(" / "***REMOVED***"
    #                   / "*" / "+" / "," / ";" / "="
    #     unreserved  = ALPHA / DIGIT / "-" / "." / "_" / "~"
    # Of the unreserved characters, urllib.quote already considers all but
    # the ~ safe.
    # The % character is also added to the list of safe characters here, as the
    # end of section 3.1 of RFC 3987 specifically mentions that % must not be
    # converted.
    if iri is None:
        return iri
    return quote(force_bytes(iri***REMOVED***, safe=b"/#%[***REMOVED***=:;$&(***REMOVED***+,!?*@'~"***REMOVED***


def uri_to_iri(uri***REMOVED***:
    ***REMOVED***
    Converts a Uniform Resource Identifier(URI***REMOVED*** into an Internationalized
    Resource Identifier(IRI***REMOVED***.

    This is the algorithm from section 3.2 of RFC 3987.

    Takes an URI in ASCII bytes (e.g. '/I%20%E2%99%A5%20Django/'***REMOVED*** and returns
    unicode containing the encoded result (e.g. '/I \xe2\x99\xa5 Django/'***REMOVED***.
    ***REMOVED***
    if uri is None:
        return uri
    uri = force_bytes(uri***REMOVED***
    iri = unquote_to_bytes(uri***REMOVED*** if six.PY3 else unquote(uri***REMOVED***
    return repercent_broken_unicode(iri***REMOVED***.decode('utf-8'***REMOVED***


def escape_uri_path(path***REMOVED***:
    ***REMOVED***
    Escape the unsafe characters from the path portion of a Uniform Resource
    Identifier (URI***REMOVED***.
    ***REMOVED***
    # These are the "reserved" and "unreserved" characters specified in
    # sections 2.2 and 2.3 of RFC 2396:
    #   reserved    = ";" | "/" | "?" | ":" | "@" | "&" | "=" | "+" | "$" | ","
    #   unreserved  = alphanum | mark
    #   mark        = "-" | "_" | "." | "!" | "~" | "*" | "'" | "(" | "***REMOVED***"
    # The list of safe characters here is constructed subtracting ";", "=",
    # and "?" according to section 3.3 of RFC 2396.
    # The reason for not subtracting and escaping "/" is that we are escaping
    # the entire path, not a path segment.
    return quote(force_bytes(path***REMOVED***, safe=b"/:@&+$,-_.!~*'(***REMOVED***"***REMOVED***


def repercent_broken_unicode(path***REMOVED***:
    ***REMOVED***
    As per section 3.2 of RFC 3987, step three of converting a URI into an IRI,
    we need to re-percent-encode any octet produced that is not part of a
    strictly legal UTF-8 octet sequence.
    ***REMOVED***
    ***REMOVED***
        path.decode('utf-8'***REMOVED***
    except UnicodeDecodeError as e:
        repercent = quote(path[e.start:e.end***REMOVED***, safe=b"/#%[***REMOVED***=:;$&(***REMOVED***+,!?*@'~"***REMOVED***
        path = repercent_broken_unicode(
            path[:e.start***REMOVED*** + force_bytes(repercent***REMOVED*** + path[e.end:***REMOVED******REMOVED***
    return path


def filepath_to_uri(path***REMOVED***:
    ***REMOVED***Convert a file system path to a URI portion that is suitable for
    inclusion in a URL.

    We are assuming input is either UTF-8 or unicode already.

    This method will encode certain chars that would normally be recognized as
    special chars for URIs.  Note that this method does not encode the '
    character, as it is a valid character within URIs.  See
    encodeURIComponent(***REMOVED*** JavaScript function for more details.

    Returns an ASCII string containing the encoded result.
    ***REMOVED***
    if path is None:
        return path
    # I know about `os.sep` and `os.altsep` but I want to leave
    # some flexibility for hardcoding separators.
    return quote(force_bytes(path***REMOVED***.replace(b"\\", b"/"***REMOVED***, safe=b"/~!*(***REMOVED***'"***REMOVED***


def get_system_encoding(***REMOVED***:
    ***REMOVED***
    The encoding of the default system locale but falls back to the given
    fallback encoding if the encoding is unsupported by python or could
    not be determined.  See tickets #10335 and #5846
    ***REMOVED***
    ***REMOVED***
        encoding = locale.getdefaultlocale(***REMOVED***[1***REMOVED*** or 'ascii'
        codecs.lookup(encoding***REMOVED***
    except Exception:
        encoding = 'ascii'
    return encoding

DEFAULT_LOCALE_ENCODING = get_system_encoding(***REMOVED***
