import datetime
import decimal
import unicodedata
from importlib import import_module

from django.conf import settings
from django.utils import dateformat, datetime_safe, numberformat, six
from django.utils.encoding import force_str
from django.utils.functional import lazy
from django.utils.safestring import mark_safe
from django.utils.translation import (
    check_for_language, get_language, to_locale,
***REMOVED***

# format_cache is a mapping from (format_type, lang***REMOVED*** to the format string.
# By using the cache, it is possible to avoid running get_format_modules
# repeatedly.
_format_cache = {***REMOVED***
_format_modules_cache = {***REMOVED***

ISO_INPUT_FORMATS = {
    'DATE_INPUT_FORMATS': ['%Y-%m-%d'***REMOVED***,
    'TIME_INPUT_FORMATS': ['%H:%M:%S', '%H:%M:%S.%f', '%H:%M'***REMOVED***,
    'DATETIME_INPUT_FORMATS': [
        '%Y-%m-%d %H:%M:%S',
        '%Y-%m-%d %H:%M:%S.%f',
        '%Y-%m-%d %H:%M',
        '%Y-%m-%d'
    ***REMOVED***,
***REMOVED***


FORMAT_SETTINGS = frozenset([
    'DECIMAL_SEPARATOR',
    'THOUSAND_SEPARATOR',
    'NUMBER_GROUPING',
    'FIRST_DAY_OF_WEEK',
    'MONTH_DAY_FORMAT',
    'TIME_FORMAT',
    'DATE_FORMAT',
    'DATETIME_FORMAT',
    'SHORT_DATE_FORMAT',
    'SHORT_DATETIME_FORMAT',
    'YEAR_MONTH_FORMAT',
    'DATE_INPUT_FORMATS',
    'TIME_INPUT_FORMATS',
    'DATETIME_INPUT_FORMATS',
***REMOVED******REMOVED***


def reset_format_cache(***REMOVED***:
    ***REMOVED***Clear any cached formats.

    This method is provided primarily for testing purposes,
    so that the effects of cached formats can be removed.
    ***REMOVED***
    global _format_cache, _format_modules_cache
    _format_cache = {***REMOVED***
    _format_modules_cache = {***REMOVED***


def iter_format_modules(lang, format_module_path=None***REMOVED***:
    ***REMOVED***
    Does the heavy lifting of finding format modules.
    ***REMOVED***
    if not check_for_language(lang***REMOVED***:
        return

    if format_module_path is None:
        format_module_path = settings.FORMAT_MODULE_PATH

    format_locations = [***REMOVED***
    if format_module_path:
        if isinstance(format_module_path, six.string_types***REMOVED***:
            format_module_path = [format_module_path***REMOVED***
        for path in format_module_path:
            format_locations.append(path + '.%s'***REMOVED***
    format_locations.append('django.conf.locale.%s'***REMOVED***
    locale = to_locale(lang***REMOVED***
    locales = [locale***REMOVED***
    if '_' in locale:
        locales.append(locale.split('_'***REMOVED***[0***REMOVED******REMOVED***
    for location in format_locations:
        for loc in locales:
            ***REMOVED***
                yield import_module('%s.formats' % (location % loc***REMOVED******REMOVED***
            except ImportError:
                pass


def get_format_modules(lang=None, reverse=False***REMOVED***:
    ***REMOVED***
    Returns a list of the format modules found
    ***REMOVED***
    if lang is None:
        lang = get_language(***REMOVED***
    if lang not in _format_modules_cache:
        _format_modules_cache[lang***REMOVED*** = list(iter_format_modules(lang, settings.FORMAT_MODULE_PATH***REMOVED******REMOVED***
    modules = _format_modules_cache[lang***REMOVED***
    if reverse:
        return list(reversed(modules***REMOVED******REMOVED***
    return modules


def get_format(format_type, lang=None, use_l10n=None***REMOVED***:
    ***REMOVED***
    For a specific format type, returns the format for the current
    language (locale***REMOVED***, defaults to the format in the settings.
    format_type is the name of the format, e.g. 'DATE_FORMAT'

    If use_l10n is provided and is not None, that will force the value to
    be localized (or not***REMOVED***, overriding the value of settings.USE_L10N.
    ***REMOVED***
    format_type = force_str(format_type***REMOVED***
    if use_l10n or (use_l10n is None and settings.USE_L10N***REMOVED***:
        if lang is None:
            lang = get_language(***REMOVED***
        cache_key = (format_type, lang***REMOVED***
        ***REMOVED***
            cached = _format_cache[cache_key***REMOVED***
            if cached is not None:
                return cached
        except KeyError:
            for module in get_format_modules(lang***REMOVED***:
                ***REMOVED***
                    val = getattr(module, format_type***REMOVED***
                    for iso_input in ISO_INPUT_FORMATS.get(format_type, (***REMOVED******REMOVED***:
                        if iso_input not in val:
                            if isinstance(val, tuple***REMOVED***:
                                val = list(val***REMOVED***
                            val.append(iso_input***REMOVED***
                    _format_cache[cache_key***REMOVED*** = val
                    return val
                except AttributeError:
                    pass
            _format_cache[cache_key***REMOVED*** = None
    if format_type not in FORMAT_SETTINGS:
        return format_type
    # Return the general setting by default
    return getattr(settings, format_type***REMOVED***

get_format_lazy = lazy(get_format, six.text_type, list, tuple***REMOVED***


def date_format(value, format=None, use_l10n=None***REMOVED***:
    ***REMOVED***
    Formats a datetime.date or datetime.datetime object using a
    localizable format

    If use_l10n is provided and is not None, that will force the value to
    be localized (or not***REMOVED***, overriding the value of settings.USE_L10N.
    ***REMOVED***
    return dateformat.format(value, get_format(format or 'DATE_FORMAT', use_l10n=use_l10n***REMOVED******REMOVED***


def time_format(value, format=None, use_l10n=None***REMOVED***:
    ***REMOVED***
    Formats a datetime.time object using a localizable format

    If use_l10n is provided and is not None, that will force the value to
    be localized (or not***REMOVED***, overriding the value of settings.USE_L10N.
    ***REMOVED***
    return dateformat.time_format(value, get_format(format or 'TIME_FORMAT', use_l10n=use_l10n***REMOVED******REMOVED***


def number_format(value, decimal_pos=None, use_l10n=None, force_grouping=False***REMOVED***:
    ***REMOVED***
    Formats a numeric value using localization settings

    If use_l10n is provided and is not None, that will force the value to
    be localized (or not***REMOVED***, overriding the value of settings.USE_L10N.
    ***REMOVED***
    if use_l10n or (use_l10n is None and settings.USE_L10N***REMOVED***:
        lang = get_language(***REMOVED***
    else:
        lang = None
    return numberformat.format(
        value,
        get_format('DECIMAL_SEPARATOR', lang, use_l10n=use_l10n***REMOVED***,
        decimal_pos,
        get_format('NUMBER_GROUPING', lang, use_l10n=use_l10n***REMOVED***,
        get_format('THOUSAND_SEPARATOR', lang, use_l10n=use_l10n***REMOVED***,
        force_grouping=force_grouping
    ***REMOVED***


def localize(value, use_l10n=None***REMOVED***:
    ***REMOVED***
    Checks if value is a localizable type (date, number...***REMOVED*** and returns it
    formatted as a string using current locale format.

    If use_l10n is provided and is not None, that will force the value to
    be localized (or not***REMOVED***, overriding the value of settings.USE_L10N.
    ***REMOVED***
    if isinstance(value, six.string_types***REMOVED***:  # Handle strings first for performance reasons.
        return value
    elif isinstance(value, bool***REMOVED***:  # Make sure booleans don't get treated as numbers
        return mark_safe(six.text_type(value***REMOVED******REMOVED***
    elif isinstance(value, (decimal.Decimal, float***REMOVED*** + six.integer_types***REMOVED***:
        return number_format(value, use_l10n=use_l10n***REMOVED***
    elif isinstance(value, datetime.datetime***REMOVED***:
        return date_format(value, 'DATETIME_FORMAT', use_l10n=use_l10n***REMOVED***
    elif isinstance(value, datetime.date***REMOVED***:
        return date_format(value, use_l10n=use_l10n***REMOVED***
    elif isinstance(value, datetime.time***REMOVED***:
        return time_format(value, 'TIME_FORMAT', use_l10n=use_l10n***REMOVED***
    return value


def localize_input(value, default=None***REMOVED***:
    ***REMOVED***
    Checks if an input value is a localizable type and returns it
    formatted with the appropriate formatting string of the current locale.
    ***REMOVED***
    if isinstance(value, six.string_types***REMOVED***:  # Handle strings first for performance reasons.
        return value
    elif isinstance(value, bool***REMOVED***:  # Don't treat booleans as numbers.
        return six.text_type(value***REMOVED***
    elif isinstance(value, (decimal.Decimal, float***REMOVED*** + six.integer_types***REMOVED***:
        return number_format(value***REMOVED***
    elif isinstance(value, datetime.datetime***REMOVED***:
        value = datetime_safe.new_datetime(value***REMOVED***
        format = force_str(default or get_format('DATETIME_INPUT_FORMATS'***REMOVED***[0***REMOVED******REMOVED***
        return value.strftime(format***REMOVED***
    elif isinstance(value, datetime.date***REMOVED***:
        value = datetime_safe.new_date(value***REMOVED***
        format = force_str(default or get_format('DATE_INPUT_FORMATS'***REMOVED***[0***REMOVED******REMOVED***
        return value.strftime(format***REMOVED***
    elif isinstance(value, datetime.time***REMOVED***:
        format = force_str(default or get_format('TIME_INPUT_FORMATS'***REMOVED***[0***REMOVED******REMOVED***
        return value.strftime(format***REMOVED***
    return value


def sanitize_separators(value***REMOVED***:
    ***REMOVED***
    Sanitizes a value according to the current decimal and
    thousand separator setting. Used with form field input.
    ***REMOVED***
    if settings.USE_L10N and isinstance(value, six.string_types***REMOVED***:
        parts = [***REMOVED***
        decimal_separator = get_format('DECIMAL_SEPARATOR'***REMOVED***
        if decimal_separator in value:
            value, decimals = value.split(decimal_separator, 1***REMOVED***
            parts.append(decimals***REMOVED***
        if settings.USE_THOUSAND_SEPARATOR:
            thousand_sep = get_format('THOUSAND_SEPARATOR'***REMOVED***
            if thousand_sep == '.' and value.count('.'***REMOVED*** == 1 and len(value.split('.'***REMOVED***[-1***REMOVED******REMOVED*** != 3:
                # Special case where we suspect a dot meant decimal separator (see #22171***REMOVED***
                pass
            else:
                for replacement in {
                        thousand_sep, unicodedata.normalize('NFKD', thousand_sep***REMOVED******REMOVED***:
                    value = value.replace(replacement, ''***REMOVED***
        parts.append(value***REMOVED***
        value = '.'.join(reversed(parts***REMOVED******REMOVED***
    return value
