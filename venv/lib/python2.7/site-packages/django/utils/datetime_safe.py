# Python's datetime strftime doesn't handle dates before 1900.
# These classes override date and datetime to support the formatting of a date
# through its full "proleptic Gregorian" date range.
#
# Based on code submitted to comp.lang.python by Andrew Dalke
#
# >>> datetime_safe.date(1850, 8, 2***REMOVED***.strftime("%Y/%m/%d was a %A"***REMOVED***
# '1850/08/02 was a Friday'

import re
import time as ttime
from datetime import (
    date as real_date, datetime as real_datetime, time as real_time,
***REMOVED***


class date(real_date***REMOVED***:
    def strftime(self, fmt***REMOVED***:
        return strftime(self, fmt***REMOVED***


class datetime(real_datetime***REMOVED***:
    def strftime(self, fmt***REMOVED***:
        return strftime(self, fmt***REMOVED***

    @classmethod
    def combine(cls, date, time***REMOVED***:
        return cls(date.year, date.month, date.day,
                   time.hour, time.minute, time.second,
                   time.microsecond, time.tzinfo***REMOVED***

    def date(self***REMOVED***:
        return date(self.year, self.month, self.day***REMOVED***


class time(real_time***REMOVED***:
    pass


def new_date(d***REMOVED***:
    "Generate a safe date from a datetime.date object."
    return date(d.year, d.month, d.day***REMOVED***


def new_datetime(d***REMOVED***:
    ***REMOVED***
    Generate a safe datetime from a datetime.date or datetime.datetime object.
    ***REMOVED***
    kw = [d.year, d.month, d.day***REMOVED***
    if isinstance(d, real_datetime***REMOVED***:
        kw.extend([d.hour, d.minute, d.second, d.microsecond, d.tzinfo***REMOVED******REMOVED***
    return datetime(*kw***REMOVED***

# This library does not support strftime's "%s" or "%y" format strings.
# Allowed if there's an even number of "%"s because they are escaped.
_illegal_formatting = re.compile(r"((^|[^%***REMOVED******REMOVED***(%%***REMOVED****%[sy***REMOVED******REMOVED***"***REMOVED***


def _findall(text, substr***REMOVED***:
    # Also finds overlaps
    sites = [***REMOVED***
    i = 0
    while 1:
        j = text.find(substr, i***REMOVED***
        if j == -1:
            break
        sites.append(j***REMOVED***
        i = j + 1
    return sites


def strftime(dt, fmt***REMOVED***:
    if dt.year >= 1900:
        return super(type(dt***REMOVED***, dt***REMOVED***.strftime(fmt***REMOVED***
    illegal_formatting = _illegal_formatting.search(fmt***REMOVED***
    if illegal_formatting:
        raise TypeError("strftime of dates before 1900 does not handle" + illegal_formatting.group(0***REMOVED******REMOVED***

    year = dt.year
    # For every non-leap year century, advance by
    # 6 years to get into the 28-year repeat cycle
    delta = 2000 - year
    off = 6 * (delta // 100 + delta // 400***REMOVED***
    year = year + off

    # Move to around the year 2000
    year = year + ((2000 - year***REMOVED*** // 28***REMOVED*** * 28
    timetuple = dt.timetuple(***REMOVED***
    s1 = ttime.strftime(fmt, (year,***REMOVED*** + timetuple[1:***REMOVED******REMOVED***
    sites1 = _findall(s1, str(year***REMOVED******REMOVED***

    s2 = ttime.strftime(fmt, (year + 28,***REMOVED*** + timetuple[1:***REMOVED******REMOVED***
    sites2 = _findall(s2, str(year + 28***REMOVED******REMOVED***

    sites = [***REMOVED***
    for site in sites1:
        if site in sites2:
            sites.append(site***REMOVED***

    s = s1
    syear = "%04d" % (dt.year,***REMOVED***
    for site in sites:
        s = s[:site***REMOVED*** + syear + s[site + 4:***REMOVED***
    return s
