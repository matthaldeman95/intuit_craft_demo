import copy
***REMOVED***
import sys
from importlib import import_module

from django.utils import six


def import_string(dotted_path***REMOVED***:
    ***REMOVED***
    Import a dotted module path and return the attribute/class designated by the
    last name in the path. Raise ImportError if the import failed.
    ***REMOVED***
    ***REMOVED***
        module_path, class_name = dotted_path.rsplit('.', 1***REMOVED***
    except ValueError:
        msg = "%s doesn't look like a module path" % dotted_path
        six.reraise(ImportError, ImportError(msg***REMOVED***, sys.exc_info(***REMOVED***[2***REMOVED******REMOVED***

    module = import_module(module_path***REMOVED***

    ***REMOVED***
        return getattr(module, class_name***REMOVED***
    except AttributeError:
        msg = 'Module "%s" does not define a "%s" attribute/class' % (
            module_path, class_name***REMOVED***
        six.reraise(ImportError, ImportError(msg***REMOVED***, sys.exc_info(***REMOVED***[2***REMOVED******REMOVED***


def autodiscover_modules(*args, **kwargs***REMOVED***:
    ***REMOVED***
    Auto-discover INSTALLED_APPS modules and fail silently when
    not present. This forces an import on them to register any admin bits they
    may want.

    You may provide a register_to keyword parameter as a way to access a
    registry. This register_to object must have a _registry instance variable
    to access it.
    ***REMOVED***
    from django.apps import apps

    register_to = kwargs.get('register_to'***REMOVED***
    for app_config in apps.get_app_configs(***REMOVED***:
        for module_to_search in args:
            # Attempt to import the app's module.
            ***REMOVED***
                if register_to:
                    before_import_registry = copy.copy(register_to._registry***REMOVED***

                import_module('%s.%s' % (app_config.name, module_to_search***REMOVED******REMOVED***
            except Exception:
                # Reset the registry to the state before the last import
                # as this import will have to reoccur on the next request and
                # this could raise NotRegistered and AlreadyRegistered
                # exceptions (see #8245***REMOVED***.
                if register_to:
                    register_to._registry = before_import_registry

                # Decide whether to bubble up this error. If the app just
                # doesn't have the module in question, we can ignore the error
                # attempting to import it, otherwise we want it to bubble up.
                if module_has_submodule(app_config.module, module_to_search***REMOVED***:
                    raise


if six.PY3:
    from importlib.util import find_spec as importlib_find

    def module_has_submodule(package, module_name***REMOVED***:
        ***REMOVED***See if 'module' is in 'package'.***REMOVED***
        ***REMOVED***
            package_name = package.__name__
            package_path = package.__path__
        except AttributeError:
            # package isn't a package.
            return False

        full_module_name = package_name + '.' + module_name
        return importlib_find(full_module_name, package_path***REMOVED*** is not None

else:
    import imp

    def module_has_submodule(package, module_name***REMOVED***:
        ***REMOVED***See if 'module' is in 'package'.***REMOVED***
        name = ".".join([package.__name__, module_name***REMOVED******REMOVED***
        ***REMOVED***
            # None indicates a cached miss; see mark_miss(***REMOVED*** in Python/import.c.
            return sys.modules[name***REMOVED*** is not None
        except KeyError:
            pass
        ***REMOVED***
            package_path = package.__path__   # No __path__, then not a package.
        except AttributeError:
            # Since the remainder of this function assumes that we're dealing with
            # a package (module with a __path__***REMOVED***, so if it's not, then bail here.
            return False
        for finder in sys.meta_path:
            if finder.find_module(name, package_path***REMOVED***:
                return True
        for entry in package_path:
            ***REMOVED***
                # Try the cached finder.
                finder = sys.path_importer_cache[entry***REMOVED***
                if finder is None:
                    # Implicit import machinery should be used.
                    ***REMOVED***
                        file_, _, _ = imp.find_module(module_name, [entry***REMOVED******REMOVED***
                        if file_:
                            file_.close(***REMOVED***
                        return True
                    except ImportError:
                        continue
                # Else see if the finder knows of a loader.
                elif finder.find_module(name***REMOVED***:
                    return True
                else:
                    continue
            except KeyError:
                # No cached finder, so try and make one.
                for hook in sys.path_hooks:
                    ***REMOVED***
                        finder = hook(entry***REMOVED***
                        # XXX Could cache in sys.path_importer_cache
                        if finder.find_module(name***REMOVED***:
                            return True
                        else:
                            # Once a finder is found, stop the search.
                            break
                    except ImportError:
                        # Continue the search for a finder.
                        continue
                else:
                    # No finder found.
                    # Try the implicit import machinery if searching a directory.
                    if os.path.isdir(entry***REMOVED***:
                        ***REMOVED***
                            file_, _, _ = imp.find_module(module_name, [entry***REMOVED******REMOVED***
                            if file_:
                                file_.close(***REMOVED***
                            return True
                        except ImportError:
                            pass
                    # XXX Could insert None or NullImporter
        else:
            # Exhausted the search, so the module cannot be found.
            return False


def module_dir(module***REMOVED***:
    ***REMOVED***
    Find the name of the directory that contains a module, if possible.

    Raise ValueError otherwise, e.g. for namespace packages that are split
    over several directories.
    ***REMOVED***
    # Convert to list because _NamespacePath does not support indexing on 3.3.
    paths = list(getattr(module, '__path__', [***REMOVED******REMOVED******REMOVED***
    if len(paths***REMOVED*** == 1:
        return paths[0***REMOVED***
    else:
        filename = getattr(module, '__file__', None***REMOVED***
        if filename is not None:
            return os.path.dirname(filename***REMOVED***
    raise ValueError("Cannot determine directory containing %s" % module***REMOVED***
