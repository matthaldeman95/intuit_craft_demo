***REMOVED***
import socket

import geoip2.database

from django.conf import settings
from django.core.validators import ipv4_re
from django.utils import six
from django.utils.ipv6 import is_valid_ipv6_address

from .resources import City, Country

# Creating the settings dictionary with any settings, if needed.
GEOIP_SETTINGS = {
    'GEOIP_PATH': getattr(settings, 'GEOIP_PATH', None***REMOVED***,
    'GEOIP_CITY': getattr(settings, 'GEOIP_CITY', 'GeoLite2-City.mmdb'***REMOVED***,
    'GEOIP_COUNTRY': getattr(settings, 'GEOIP_COUNTRY', 'GeoLite2-Country.mmdb'***REMOVED***,
***REMOVED***


class GeoIP2Exception(Exception***REMOVED***:
    pass


class GeoIP2(object***REMOVED***:
    # The flags for GeoIP memory caching.
    # Try MODE_MMAP_EXT, MODE_MMAP, MODE_FILE in that order.
    MODE_AUTO = 0
    # Use the C extension with memory map.
    MODE_MMAP_EXT = 1
    # Read from memory map. Pure Python.
    MODE_MMAP = 2
    # Read database as standard file. Pure Python.
    MODE_FILE = 4
    # Load database into memory. Pure Python.
    MODE_MEMORY = 8
    cache_options = {opt: None for opt in (0, 1, 2, 4, 8***REMOVED******REMOVED***

    # Paths to the city & country binary databases.
    _city_file = ''
    _country_file = ''

    # Initially, pointers to GeoIP file references are NULL.
    _city = None
    _country = None

    def __init__(self, path=None, cache=0, country=None, city=None***REMOVED***:
        ***REMOVED***
        Initialize the GeoIP object. No parameters are required to use default
        settings. Keyword arguments may be passed in to customize the locations
        of the GeoIP datasets.

        * path: Base directory to where GeoIP data is located or the full path
            to where the city or country data files (*.mmdb***REMOVED*** are located.
            Assumes that both the city and country data sets are located in
            this directory; overrides the GEOIP_PATH setting.

        * cache: The cache settings when opening up the GeoIP datasets. May be
            an integer in (0, 1, 2, 4, 8***REMOVED*** corresponding to the MODE_AUTO,
            MODE_MMAP_EXT, MODE_MMAP, MODE_FILE, and MODE_MEMORY,
            `GeoIPOptions` C API settings,  respectively. Defaults to 0,
            meaning MODE_AUTO.

        * coun***REMOVED*** The name of the GeoIP country data file. Defaults to
            'GeoLite2-Country.mmdb'; overrides the GEOIP_COUNTRY setting.

        * city: The name of the GeoIP city data file. Defaults to
            'GeoLite2-City.mmdb'; overrides the GEOIP_CITY setting.
        ***REMOVED***
        # Checking the given cache option.
        if cache in self.cache_options:
            self._cache = cache
        else:
            raise GeoIP2Exception('Invalid GeoIP caching option: %s' % cache***REMOVED***

        # Getting the GeoIP data path.
        if not path:
            path = GEOIP_SETTINGS['GEOIP_PATH'***REMOVED***
            if not path:
                raise GeoIP2Exception('GeoIP path must be provided via parameter or the GEOIP_PATH setting.'***REMOVED***
        if not isinstance(path, six.string_types***REMOVED***:
            raise TypeError('Invalid path type: %s' % type(path***REMOVED***.__name__***REMOVED***

        if os.path.isdir(path***REMOVED***:
            # Constructing the GeoIP database filenames using the settings
            # dictionary. If the database files for the GeoLite country
            # and/or city datasets exist, then try to open them.
            country_db = os.path.join(path, country or GEOIP_SETTINGS['GEOIP_COUNTRY'***REMOVED******REMOVED***
            if os.path.isfile(country_db***REMOVED***:
                self._country = geoip2.database.Reader(country_db, mode=cache***REMOVED***
                self._country_file = country_db

            city_db = os.path.join(path, city or GEOIP_SETTINGS['GEOIP_CITY'***REMOVED******REMOVED***
            if os.path.isfile(city_db***REMOVED***:
                self._city = geoip2.database.Reader(city_db, mode=cache***REMOVED***
                self._city_file = city_db
        elif os.path.isfile(path***REMOVED***:
            # Otherwise, some detective work will be needed to figure out
            # whether the given database path is for the GeoIP country or city
            # databases.
            reader = geoip2.database.Reader(path, mode=cache***REMOVED***
            db_type = reader.metadata(***REMOVED***.database_type

            if db_type.endswith('City'***REMOVED***:
                # GeoLite City database detected.
                self._city = reader
                self._city_file = path
            elif db_type.endswith('Country'***REMOVED***:
                # GeoIP Country database detected.
                self._country = reader
                self._country_file = path
            else:
                raise GeoIP2Exception('Unable to recognize database edition: %s' % db_type***REMOVED***
        else:
            raise GeoIP2Exception('GeoIP path must be a valid file or directory.'***REMOVED***

    @property
    def _reader(self***REMOVED***:
        if self._coun***REMOVED***
            return self._country
        else:
            return self._city

    @property
    def _country_or_city(self***REMOVED***:
        if self._coun***REMOVED***
            return self._country.country
        else:
            return self._city.city

    def __del__(self***REMOVED***:
        # Cleanup any GeoIP file handles lying around.
        if self._reader:
            self._reader.close(***REMOVED***

    def __repr__(self***REMOVED***:
        meta = self._reader.metadata(***REMOVED***
        version = '[v%s.%s***REMOVED***' % (meta.binary_format_major_version, meta.binary_format_minor_version***REMOVED***
        return '<%(cls***REMOVED***s %(version***REMOVED***s _country_file="%(country***REMOVED***s", _city_file="%(city***REMOVED***s">' % {
            'cls': self.__class__.__name__,
            'version': version,
            'country': self._country_file,
            'city': self._city_file,
    ***REMOVED***

    def _check_query(self, query, country=False, city=False, city_or_country=False***REMOVED***:
        "Helper routine for checking the query and database availability."
        # Making sure a string was passed in for the query.
        if not isinstance(query, six.string_types***REMOVED***:
            raise TypeError('GeoIP query must be a string, not type %s' % type(query***REMOVED***.__name__***REMOVED***

        # Extra checks for the existence of country and city databases.
        if city_or_country and not (self._country or self._city***REMOVED***:
            raise GeoIP2Exception('Invalid GeoIP country and city data files.'***REMOVED***
        elif country and not self._coun***REMOVED***
            raise GeoIP2Exception('Invalid GeoIP country data file: %s' % self._country_file***REMOVED***
        elif city and not self._city:
            raise GeoIP2Exception('Invalid GeoIP city data file: %s' % self._city_file***REMOVED***

        # Return the query string back to the caller. GeoIP2 only takes IP addresses.
        if not (ipv4_re.match(query***REMOVED*** or is_valid_ipv6_address(query***REMOVED******REMOVED***:
            query = socket.gethostbyname(query***REMOVED***

        return query

    def city(self, query***REMOVED***:
        ***REMOVED***
        Return a dictionary of city information for the given IP address or
        Fully Qualified Domain Name (FQDN***REMOVED***. Some information in the dictionary
        may be undefined (None***REMOVED***.
        ***REMOVED***
        enc_query = self._check_query(query, city=True***REMOVED***
        return City(self._city.city(enc_query***REMOVED******REMOVED***

    def country_code(self, query***REMOVED***:
        "Return the country code for the given IP Address or FQDN."
        enc_query = self._check_query(query, city_or_country=True***REMOVED***
        return self.country(enc_query***REMOVED***['country_code'***REMOVED***

    def country_name(self, query***REMOVED***:
        "Return the country name for the given IP Address or FQDN."
        enc_query = self._check_query(query, city_or_country=True***REMOVED***
        return self.country(enc_query***REMOVED***['country_name'***REMOVED***

    def country(self, query***REMOVED***:
        ***REMOVED***
        Return a dictionary with the country code and name when given an
        IP address or a Fully Qualified Domain Name (FQDN***REMOVED***. For example, both
        '24.124.1.80' and 'djangoproject.com' are valid parameters.
        ***REMOVED***
        # Returning the country code and name
        enc_query = self._check_query(query, city_or_country=True***REMOVED***
        return Country(self._country_or_city(enc_query***REMOVED******REMOVED***

    # #### Coordinate retrieval routines ####
    def coords(self, query, ordering=('longitude', 'latitude'***REMOVED******REMOVED***:
        cdict = self.city(query***REMOVED***
        if cdict is None:
            return None
        else:
            return tuple(cdict[o***REMOVED*** for o in ordering***REMOVED***

    def lon_lat(self, query***REMOVED***:
        "Return a tuple of the (longitude, latitude***REMOVED*** for the given query."
        return self.coords(query***REMOVED***

    def lat_lon(self, query***REMOVED***:
        "Return a tuple of the (latitude, longitude***REMOVED*** for the given query."
        return self.coords(query, ('latitude', 'longitude'***REMOVED******REMOVED***

    def geos(self, query***REMOVED***:
        "Return a GEOS Point object for the given query."
        ll = self.lon_lat(query***REMOVED***
        if ll:
            from django.contrib.gis.geos import Point
            return Point(ll, srid=4326***REMOVED***
        else:
            return None

    # #### GeoIP Database Information Routines ####
    @property
    def info(self***REMOVED***:
        "Return information about the GeoIP library and databases in use."
        meta = self._reader.metadata(***REMOVED***
        return 'GeoIP Library:\n\t%s.%s\n' % (meta.binary_format_major_version, meta.binary_format_minor_version***REMOVED***

    @classmethod
    def open(cls, full_path, cache***REMOVED***:
        return GeoIP2(full_path, cache***REMOVED***
