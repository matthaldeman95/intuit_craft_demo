from ctypes import byref, c_uint

from django.contrib.gis.geos import prototypes as capi
from django.contrib.gis.geos.geometry import GEOSGeometry
from django.contrib.gis.geos.libgeos import GEOM_PTR, get_pointer_arr
from django.contrib.gis.geos.linestring import LinearRing
from django.utils import six
from django.utils.six.moves import range


class Polygon(GEOSGeometry***REMOVED***:
    _minlength = 1

    def __init__(self, *args, **kwargs***REMOVED***:
        ***REMOVED***
        Initializes on an exterior ring and a sequence of holes (both
        instances may be either LinearRing instances, or a tuple/list
        that may be constructed into a LinearRing***REMOVED***.

        Examples of initialization, where shell, hole1, and hole2 are
        valid LinearRing geometries:
        >>> from django.contrib.gis.geos import LinearRing, Polygon
        >>> shell = hole1 = hole2 = LinearRing(***REMOVED***
        >>> poly = Polygon(shell, hole1, hole2***REMOVED***
        >>> poly = Polygon(shell, (hole1, hole2***REMOVED******REMOVED***

        >>> # Example where a tuple parameters are used:
        >>> poly = Polygon(((0, 0***REMOVED***, (0, 10***REMOVED***, (10, 10***REMOVED***, (0, 10***REMOVED***, (0, 0***REMOVED******REMOVED***,
        ...                ((4, 4***REMOVED***, (4, 6***REMOVED***, (6, 6***REMOVED***, (6, 4***REMOVED***, (4, 4***REMOVED******REMOVED******REMOVED***
        ***REMOVED***
        if not args:
            super(Polygon, self***REMOVED***.__init__(self._create_polygon(0, None***REMOVED***, **kwargs***REMOVED***
            return

        # Getting the ext_ring and init_holes parameters from the argument list
        ext_ring = args[0***REMOVED***
        init_holes = args[1:***REMOVED***
        n_holes = len(init_holes***REMOVED***

        # If initialized as Polygon(shell, (LinearRing, LinearRing***REMOVED******REMOVED*** [for backward-compatibility***REMOVED***
        if n_holes == 1 and isinstance(init_holes[0***REMOVED***, (tuple, list***REMOVED******REMOVED***:
            if len(init_holes[0***REMOVED******REMOVED*** == 0:
                init_holes = (***REMOVED***
                n_holes = 0
            elif isinstance(init_holes[0***REMOVED***[0***REMOVED***, LinearRing***REMOVED***:
                init_holes = init_holes[0***REMOVED***
                n_holes = len(init_holes***REMOVED***

        polygon = self._create_polygon(n_holes + 1, (ext_ring,***REMOVED*** + init_holes***REMOVED***
        super(Polygon, self***REMOVED***.__init__(polygon, **kwargs***REMOVED***

    def __iter__(self***REMOVED***:
        "Iterates over each ring in the polygon."
        for i in range(len(self***REMOVED******REMOVED***:
            yield self[i***REMOVED***

    def __len__(self***REMOVED***:
        "Returns the number of rings in this Polygon."
        return self.num_interior_rings + 1

    @classmethod
    def from_bbox(cls, bbox***REMOVED***:
        "Constructs a Polygon from a bounding box (4-tuple***REMOVED***."
        x0, y0, x1, y1 = bbox
        for z in bbox:
            if not isinstance(z, six.integer_types + (float,***REMOVED******REMOVED***:
                return GEOSGeometry('POLYGON((%s %s, %s %s, %s %s, %s %s, %s %s***REMOVED******REMOVED***' %
                                    (x0, y0, x0, y1, x1, y1, x1, y0, x0, y0***REMOVED******REMOVED***
        return Polygon(((x0, y0***REMOVED***, (x0, y1***REMOVED***, (x1, y1***REMOVED***, (x1, y0***REMOVED***, (x0, y0***REMOVED******REMOVED******REMOVED***

    # ### These routines are needed for list-like operation w/ListMixin ###
    def _create_polygon(self, length, items***REMOVED***:
        # Instantiate LinearRing objects if necessary, but don't clone them yet
        # _construct_ring will throw a TypeError if a parameter isn't a valid ring
        # If we cloned the pointers here, we wouldn't be able to clean up
        # in case of error.
        if not length:
            return capi.create_empty_polygon(***REMOVED***

        rings = [***REMOVED***
        for r in items:
            if isinstance(r, GEOM_PTR***REMOVED***:
                rings.append(r***REMOVED***
            else:
                rings.append(self._construct_ring(r***REMOVED******REMOVED***

        shell = self._clone(rings.pop(0***REMOVED******REMOVED***

        n_holes = length - 1
        if n_holes:
            holes = get_pointer_arr(n_holes***REMOVED***
            for i, r in enumerate(rings***REMOVED***:
                holes[i***REMOVED*** = self._clone(r***REMOVED***
                holes_param = byref(holes***REMOVED***
        else:
            holes_param = None

        return capi.create_polygon(shell, holes_param, c_uint(n_holes***REMOVED******REMOVED***

    def _clone(self, g***REMOVED***:
        if isinstance(g, GEOM_PTR***REMOVED***:
            return capi.geom_clone(g***REMOVED***
        else:
            return capi.geom_clone(g.ptr***REMOVED***

    def _construct_ring(self, param, msg=(
            'Parameter must be a sequence of LinearRings or objects that can initialize to LinearRings'***REMOVED******REMOVED***:
        "Helper routine for trying to construct a ring from the given parameter."
        if isinstance(param, LinearRing***REMOVED***:
            return param
        ***REMOVED***
            ring = LinearRing(param***REMOVED***
            return ring
        except TypeError:
            raise TypeError(msg***REMOVED***

    def _set_list(self, length, items***REMOVED***:
        # Getting the current pointer, replacing with the newly constructed
        # geometry, and destroying the old geometry.
        prev_ptr = self.ptr
        srid = self.srid
        self.ptr = self._create_polygon(length, items***REMOVED***
        if srid:
            self.srid = srid
        capi.destroy_geom(prev_ptr***REMOVED***

    def _get_single_internal(self, index***REMOVED***:
        ***REMOVED***
        Returns the ring at the specified index.  The first index, 0, will
        always return the exterior ring.  Indices > 0 will return the
        interior ring at the given index (e.g., poly[1***REMOVED*** and poly[2***REMOVED*** would
        return the first and second interior ring, respectively***REMOVED***.

        CAREFUL: Internal/External are not the same as Interior/Exterior!
        _get_single_internal returns a pointer from the existing geometries for use
        internally by the object's methods.  _get_single_external returns a clone
        of the same geometry for use by external code.
        ***REMOVED***
        if index == 0:
            return capi.get_extring(self.ptr***REMOVED***
        else:
            # Getting the interior ring, have to subtract 1 from the index.
            return capi.get_intring(self.ptr, index - 1***REMOVED***

    def _get_single_external(self, index***REMOVED***:
        return GEOSGeometry(capi.geom_clone(self._get_single_internal(index***REMOVED******REMOVED***, srid=self.srid***REMOVED***

    _set_single = GEOSGeometry._set_single_rebuild
    _assign_extended_slice = GEOSGeometry._assign_extended_slice_rebuild

    # #### Polygon Properties ####
    @property
    def num_interior_rings(self***REMOVED***:
        "Returns the number of interior rings."
        # Getting the number of rings
        return capi.get_nrings(self.ptr***REMOVED***

    def _get_ext_ring(self***REMOVED***:
        "Gets the exterior ring of the Polygon."
        return self[0***REMOVED***

    def _set_ext_ring(self, ring***REMOVED***:
        "Sets the exterior ring of the Polygon."
        self[0***REMOVED*** = ring

    # Properties for the exterior ring/shell.
    exterior_ring = property(_get_ext_ring, _set_ext_ring***REMOVED***
    shell = exterior_ring

    @property
    def tuple(self***REMOVED***:
        "Gets the tuple for each ring in this Polygon."
        return tuple(self[i***REMOVED***.tuple for i in range(len(self***REMOVED******REMOVED******REMOVED***
    coords = tuple

    @property
    def kml(self***REMOVED***:
        "Returns the KML representation of this Polygon."
        inner_kml = ''.join(
            "<innerBoundaryIs>%s</innerBoundaryIs>" % self[i + 1***REMOVED***.kml
            for i in range(self.num_interior_rings***REMOVED***
        ***REMOVED***
        return "<Polygon><outerBoundaryIs>%s</outerBoundaryIs>%s</Polygon>" % (self[0***REMOVED***.kml, inner_kml***REMOVED***
