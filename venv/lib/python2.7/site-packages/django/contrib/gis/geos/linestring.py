from django.contrib.gis.geos import prototypes as capi
from django.contrib.gis.geos.coordseq import GEOSCoordSeq
from django.contrib.gis.geos.error import GEOSException
from django.contrib.gis.geos.geometry import GEOSGeometry, LinearGeometryMixin
from django.contrib.gis.geos.point import Point
from django.contrib.gis.shortcuts import numpy
from django.utils.six.moves import range


class LineString(LinearGeometryMixin, GEOSGeometry***REMOVED***:
    _init_func = capi.create_linestring
    _minlength = 2
    has_cs = True

    def __init__(self, *args, **kwargs***REMOVED***:
        ***REMOVED***
        Initializes on the given sequence -- may take lists, tuples, NumPy arrays
        of X,Y pairs, or Point objects.  If Point objects are used, ownership is
        _not_ transferred to the LineString object.

        Examples:
         ls = LineString((1, 1***REMOVED***, (2, 2***REMOVED******REMOVED***
         ls = LineString([(1, 1***REMOVED***, (2, 2***REMOVED******REMOVED******REMOVED***
         ls = LineString(array([(1, 1***REMOVED***, (2, 2***REMOVED******REMOVED******REMOVED******REMOVED***
         ls = LineString(Point(1, 1***REMOVED***, Point(2, 2***REMOVED******REMOVED***
        ***REMOVED***
        # If only one argument provided, set the coords array appropriately
        if len(args***REMOVED*** == 1:
            coords = args[0***REMOVED***
        else:
            coords = args

        if not (isinstance(coords, (tuple, list***REMOVED******REMOVED*** or numpy and isinstance(coords, numpy.ndarray***REMOVED******REMOVED***:
            raise TypeError('Invalid initialization input for LineStrings.'***REMOVED***

        # If SRID was passed in with the keyword arguments
        srid = kwargs.get('srid'***REMOVED***

        ncoords = len(coords***REMOVED***
        if not ncoords:
            super(LineString, self***REMOVED***.__init__(self._init_func(None***REMOVED***, srid=srid***REMOVED***
            return

        if ncoords < self._minlength:
            raise ValueError(
                '%s requires at least %d points, got %s.' % (
                    self.__class__.__name__,
                    self._minlength,
                    ncoords,
                ***REMOVED***
            ***REMOVED***

        if isinstance(coords, (tuple, list***REMOVED******REMOVED***:
            # Getting the number of coords and the number of dimensions -- which
            #  must stay the same, e.g., no LineString((1, 2***REMOVED***, (1, 2, 3***REMOVED******REMOVED***.
            ndim = None
            # Incrementing through each of the coordinates and verifying
            for coord in coords:
                if not isinstance(coord, (tuple, list, Point***REMOVED******REMOVED***:
                    raise TypeError('Each coordinate should be a sequence (list or tuple***REMOVED***'***REMOVED***

                if ndim is None:
                    ndim = len(coord***REMOVED***
                    self._checkdim(ndim***REMOVED***
                elif len(coord***REMOVED*** != ndim:
                    raise TypeError('Dimension mismatch.'***REMOVED***
            numpy_coords = False
        else:
            shape = coords.shape  # Using numpy's shape.
            if len(shape***REMOVED*** != 2:
                raise TypeError('Too many dimensions.'***REMOVED***
            self._checkdim(shape[1***REMOVED******REMOVED***
            ndim = shape[1***REMOVED***
            numpy_coords = True

        # Creating a coordinate sequence object because it is easier to
        # set the points using GEOSCoordSeq.__setitem__(***REMOVED***.
        cs = GEOSCoordSeq(capi.create_cs(ncoords, ndim***REMOVED***, z=bool(ndim == 3***REMOVED******REMOVED***

        for i in range(ncoords***REMOVED***:
            if numpy_coords:
                cs[i***REMOVED*** = coords[i, :***REMOVED***
            elif isinstance(coords[i***REMOVED***, Point***REMOVED***:
                cs[i***REMOVED*** = coords[i***REMOVED***.tuple
            else:
                cs[i***REMOVED*** = coords[i***REMOVED***

        # Calling the base geometry initialization with the returned pointer
        #  from the function.
        super(LineString, self***REMOVED***.__init__(self._init_func(cs.ptr***REMOVED***, srid=srid***REMOVED***

    def __iter__(self***REMOVED***:
        "Allows iteration over this LineString."
        for i in range(len(self***REMOVED******REMOVED***:
            yield self[i***REMOVED***

    def __len__(self***REMOVED***:
        "Returns the number of points in this LineString."
        return len(self._cs***REMOVED***

    def _get_single_external(self, index***REMOVED***:
        return self._cs[index***REMOVED***

    _get_single_internal = _get_single_external

    def _set_list(self, length, items***REMOVED***:
        ndim = self._cs.dims
        hasz = self._cs.hasz  # I don't understand why these are different

        # create a new coordinate sequence and populate accordingly
        cs = GEOSCoordSeq(capi.create_cs(length, ndim***REMOVED***, z=hasz***REMOVED***
        for i, c in enumerate(items***REMOVED***:
            cs[i***REMOVED*** = c

        ptr = self._init_func(cs.ptr***REMOVED***
        if ptr:
            capi.destroy_geom(self.ptr***REMOVED***
            self.ptr = ptr
            self._post_init(self.srid***REMOVED***
        else:
            # can this happen?
            raise GEOSException('Geometry resulting from slice deletion was invalid.'***REMOVED***

    def _set_single(self, index, value***REMOVED***:
        self._checkindex(index***REMOVED***
        self._cs[index***REMOVED*** = value

    def _checkdim(self, dim***REMOVED***:
        if dim not in (2, 3***REMOVED***:
            raise TypeError('Dimension mismatch.'***REMOVED***

    # #### Sequence Properties ####
    @property
    def tuple(self***REMOVED***:
        "Returns a tuple version of the geometry from the coordinate sequence."
        return self._cs.tuple
    coords = tuple

    def _listarr(self, func***REMOVED***:
        ***REMOVED***
        Internal routine that returns a sequence (list***REMOVED*** corresponding with
        the given function.  Will return a numpy array if possible.
        ***REMOVED***
        lst = [func(i***REMOVED*** for i in range(len(self***REMOVED******REMOVED******REMOVED***
        if numpy:
            return numpy.array(lst***REMOVED***  # ARRRR!
        else:
            return lst

    @property
    def array(self***REMOVED***:
        "Returns a numpy array for the LineString."
        return self._listarr(self._cs.__getitem__***REMOVED***

    @property
    def x(self***REMOVED***:
        "Returns a list or numpy array of the X variable."
        return self._listarr(self._cs.getX***REMOVED***

    @property
    def y(self***REMOVED***:
        "Returns a list or numpy array of the Y variable."
        return self._listarr(self._cs.getY***REMOVED***

    @property
    def z(self***REMOVED***:
        "Returns a list or numpy array of the Z variable."
        if not self.hasz:
            return None
        else:
            return self._listarr(self._cs.getZ***REMOVED***


# LinearRings are LineStrings used within Polygons.
class LinearRing(LineString***REMOVED***:
    _minlength = 4
    _init_func = capi.create_linearring
