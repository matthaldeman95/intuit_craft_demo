***REMOVED***
 This module houses the GEOSCoordSeq object, which is used internally
 by GEOSGeometry to house the actual coordinates of the Point,
 LineString, and LinearRing geometries.
***REMOVED***
from ctypes import byref, c_double, c_uint

from django.contrib.gis.geos import prototypes as capi
from django.contrib.gis.geos.base import GEOSBase
from django.contrib.gis.geos.error import GEOSException
from django.contrib.gis.geos.libgeos import CS_PTR
from django.contrib.gis.shortcuts import numpy
from django.utils.six.moves import range


class GEOSCoordSeq(GEOSBase***REMOVED***:
    "The internal representation of a list of coordinates inside a Geometry."

    ptr_type = CS_PTR

    def __init__(self, ptr, z=False***REMOVED***:
        "Initializes from a GEOS pointer."
        if not isinstance(ptr, CS_PTR***REMOVED***:
            raise TypeError('Coordinate sequence should initialize with a CS_PTR.'***REMOVED***
        self._ptr = ptr
        self._z = z

    def __iter__(self***REMOVED***:
        "Iterates over each point in the coordinate sequence."
        for i in range(self.size***REMOVED***:
            yield self[i***REMOVED***

    def __len__(self***REMOVED***:
        "Returns the number of points in the coordinate sequence."
        return int(self.size***REMOVED***

    def __str__(self***REMOVED***:
        "Returns the string representation of the coordinate sequence."
        return str(self.tuple***REMOVED***

    def __getitem__(self, index***REMOVED***:
        "Returns the coordinate sequence value at the given index."
        coords = [self.getX(index***REMOVED***, self.getY(index***REMOVED******REMOVED***
        if self.dims == 3 and self._z:
            coords.append(self.getZ(index***REMOVED******REMOVED***
        return tuple(coords***REMOVED***

    def __setitem__(self, index, value***REMOVED***:
        "Sets the coordinate sequence value at the given index."
        # Checking the input value
        if isinstance(value, (list, tuple***REMOVED******REMOVED***:
            pass
        elif numpy and isinstance(value, numpy.ndarray***REMOVED***:
            pass
        else:
            raise TypeError('Must set coordinate with a sequence (list, tuple, or numpy array***REMOVED***.'***REMOVED***
        # Checking the dims of the input
        if self.dims == 3 and self._z:
            n_args = 3
            set_3d = True
        else:
            n_args = 2
            set_3d = False
        if len(value***REMOVED*** != n_args:
            raise TypeError('Dimension of value does not match.'***REMOVED***
        # Setting the X, Y, Z
        self.setX(index, value[0***REMOVED******REMOVED***
        self.setY(index, value[1***REMOVED******REMOVED***
        if set_3d:
            self.setZ(index, value[2***REMOVED******REMOVED***

    # #### Internal Routines ####
    def _checkindex(self, index***REMOVED***:
        "Checks the given index."
        sz = self.size
        if (sz < 1***REMOVED*** or (index < 0***REMOVED*** or (index >= sz***REMOVED***:
            raise IndexError('invalid GEOS Geometry index: %s' % str(index***REMOVED******REMOVED***

    def _checkdim(self, dim***REMOVED***:
        "Checks the given dimension."
        if dim < 0 or dim > 2:
            raise GEOSException('invalid ordinate dimension "%d"' % dim***REMOVED***

    # #### Ordinate getting and setting routines ####
    def getOrdinate(self, dimension, index***REMOVED***:
        "Returns the value for the given dimension and index."
        self._checkindex(index***REMOVED***
        self._checkdim(dimension***REMOVED***
        return capi.cs_getordinate(self.ptr, index, dimension, byref(c_double(***REMOVED******REMOVED******REMOVED***

    def setOrdinate(self, dimension, index, value***REMOVED***:
        "Sets the value for the given dimension and index."
        self._checkindex(index***REMOVED***
        self._checkdim(dimension***REMOVED***
        capi.cs_setordinate(self.ptr, index, dimension, value***REMOVED***

    def getX(self, index***REMOVED***:
        "Get the X value at the index."
        return self.getOrdinate(0, index***REMOVED***

    def setX(self, index, value***REMOVED***:
        "Set X with the value at the given index."
        self.setOrdinate(0, index, value***REMOVED***

    def getY(self, index***REMOVED***:
        "Get the Y value at the given index."
        return self.getOrdinate(1, index***REMOVED***

    def setY(self, index, value***REMOVED***:
        "Set Y with the value at the given index."
        self.setOrdinate(1, index, value***REMOVED***

    def getZ(self, index***REMOVED***:
        "Get Z with the value at the given index."
        return self.getOrdinate(2, index***REMOVED***

    def setZ(self, index, value***REMOVED***:
        "Set Z with the value at the given index."
        self.setOrdinate(2, index, value***REMOVED***

    # ### Dimensions ###
    @property
    def size(self***REMOVED***:
        "Returns the size of this coordinate sequence."
        return capi.cs_getsize(self.ptr, byref(c_uint(***REMOVED******REMOVED******REMOVED***

    @property
    def dims(self***REMOVED***:
        "Returns the dimensions of this coordinate sequence."
        return capi.cs_getdims(self.ptr, byref(c_uint(***REMOVED******REMOVED******REMOVED***

    @property
    def hasz(self***REMOVED***:
        ***REMOVED***
        Returns whether this coordinate sequence is 3D.  This property value is
        inherited from the parent Geometry.
        ***REMOVED***
        return self._z

    # ### Other Methods ###
    def clone(self***REMOVED***:
        "Clones this coordinate sequence."
        return GEOSCoordSeq(capi.cs_clone(self.ptr***REMOVED***, self.hasz***REMOVED***

    @property
    def kml(self***REMOVED***:
        "Returns the KML representation for the coordinates."
        # Getting the substitution string depending on whether the coordinates have
        #  a Z dimension.
        if self.hasz:
            substr = '%s,%s,%s '
        else:
            substr = '%s,%s,0 '
        return '<coordinates>%s</coordinates>' % \
            ''.join(substr % self[i***REMOVED*** for i in range(len(self***REMOVED******REMOVED******REMOVED***.strip(***REMOVED***

    @property
    def tuple(self***REMOVED***:
        "Returns a tuple version of this coordinate sequence."
        n = self.size
        if n == 1:
            return self[0***REMOVED***
        else:
            return tuple(self[i***REMOVED*** for i in range(n***REMOVED******REMOVED***
