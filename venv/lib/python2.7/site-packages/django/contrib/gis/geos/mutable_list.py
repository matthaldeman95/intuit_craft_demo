# Copyright (c***REMOVED*** 2008-2009 Aryeh Leib Taurog, all rights reserved.
# Released under the New BSD license.
***REMOVED***
This module contains a base type which provides list-style mutations
without specific data storage methods.

See also http://static.aryehleib.com/oldsite/MutableLists.html

Author: Aryeh Leib Taurog.
***REMOVED***
from functools import total_ordering

from django.utils import six
from django.utils.six.moves import range


@total_ordering
class ListMixin(object***REMOVED***:
    ***REMOVED***
    A base class which provides complete list interface.
    Derived classes must call ListMixin's __init__(***REMOVED*** function
    and implement the following:

    function _get_single_external(self, i***REMOVED***:
        Return single item with index i for general use.
        The index i will always satisfy 0 <= i < len(self***REMOVED***.

    function _get_single_internal(self, i***REMOVED***:
        Same as above, but for use within the class [Optional***REMOVED***
        Note that if _get_single_internal and _get_single_internal return
        different types of objects, _set_list must distinguish
        between the two and handle each appropriately.

    function _set_list(self, length, items***REMOVED***:
        Recreate the entire object.

        NOTE: items may be a generator which calls _get_single_internal.
        Therefore, it is necessary to cache the values in a temporary:
            temp = list(items***REMOVED***
        before clobbering the original storage.

    function _set_single(self, i, value***REMOVED***:
        Set the single item at index i to value [Optional***REMOVED***
        If left undefined, all mutations will result in rebuilding
        the object using _set_list.

    function __len__(self***REMOVED***:
        Return the length

    int _minlength:
        The minimum legal length [Optional***REMOVED***

    int _maxlength:
        The maximum legal length [Optional***REMOVED***

    type or tuple _allowed:
        A type or tuple of allowed item types [Optional***REMOVED***
    ***REMOVED***

    _minlength = 0
    _maxlength = None

    # ### Python initialization and special list interface methods ###

    def __init__(self, *args, **kwargs***REMOVED***:
        if not hasattr(self, '_get_single_internal'***REMOVED***:
            self._get_single_internal = self._get_single_external

        if not hasattr(self, '_set_single'***REMOVED***:
            self._set_single = self._set_single_rebuild
            self._assign_extended_slice = self._assign_extended_slice_rebuild

        super(ListMixin, self***REMOVED***.__init__(*args, **kwargs***REMOVED***

    def __getitem__(self, index***REMOVED***:
        "Get the item(s***REMOVED*** at the specified index/slice."
        if isinstance(index, slice***REMOVED***:
            return [self._get_single_external(i***REMOVED*** for i in range(*index.indices(len(self***REMOVED******REMOVED******REMOVED******REMOVED***
        else:
            index = self._checkindex(index***REMOVED***
            return self._get_single_external(index***REMOVED***

    def __delitem__(self, index***REMOVED***:
        "Delete the item(s***REMOVED*** at the specified index/slice."
        if not isinstance(index, six.integer_types + (slice,***REMOVED******REMOVED***:
            raise TypeError("%s is not a legal index" % index***REMOVED***

        # calculate new length and dimensions
        origLen = len(self***REMOVED***
        if isinstance(index, six.integer_types***REMOVED***:
            index = self._checkindex(index***REMOVED***
            indexRange = [index***REMOVED***
        else:
            indexRange = range(*index.indices(origLen***REMOVED******REMOVED***

        newLen = origLen - len(indexRange***REMOVED***
        newItems = (self._get_single_internal(i***REMOVED***
                    for i in range(origLen***REMOVED***
                    if i not in indexRange***REMOVED***

        self._rebuild(newLen, newItems***REMOVED***

    def __setitem__(self, index, val***REMOVED***:
        "Set the item(s***REMOVED*** at the specified index/slice."
        if isinstance(index, slice***REMOVED***:
            self._set_slice(index, val***REMOVED***
        else:
            index = self._checkindex(index***REMOVED***
            self._check_allowed((val,***REMOVED******REMOVED***
            self._set_single(index, val***REMOVED***

    # ### Special methods for arithmetic operations ###
    def __add__(self, other***REMOVED***:
        'add another list-like object'
        return self.__class__(list(self***REMOVED*** + list(other***REMOVED******REMOVED***

    def __radd__(self, other***REMOVED***:
        'add to another list-like object'
        return other.__class__(list(other***REMOVED*** + list(self***REMOVED******REMOVED***

    def __iadd__(self, other***REMOVED***:
        'add another list-like object to self'
        self.extend(list(other***REMOVED******REMOVED***
        return self

    def __mul__(self, n***REMOVED***:
        'multiply'
        return self.__class__(list(self***REMOVED*** * n***REMOVED***

    def __rmul__(self, n***REMOVED***:
        'multiply'
        return self.__class__(list(self***REMOVED*** * n***REMOVED***

    def __imul__(self, n***REMOVED***:
        'multiply'
        if n <= 0:
            del self[:***REMOVED***
        else:
            cache = list(self***REMOVED***
            for i in range(n - 1***REMOVED***:
                self.extend(cache***REMOVED***
        return self

    def __eq__(self, other***REMOVED***:
        olen = len(other***REMOVED***
        for i in range(olen***REMOVED***:
            ***REMOVED***
                c = self[i***REMOVED*** == other[i***REMOVED***
            except IndexError:
                # self must be shorter
                return False
            if not c:
                return False
        return len(self***REMOVED*** == olen

    def __lt__(self, other***REMOVED***:
        olen = len(other***REMOVED***
        for i in range(olen***REMOVED***:
            ***REMOVED***
                c = self[i***REMOVED*** < other[i***REMOVED***
            except IndexError:
                # self must be shorter
                return True
            if c:
                return c
            elif other[i***REMOVED*** < self[i***REMOVED***:
                return False
        return len(self***REMOVED*** < olen

    # ### Public list interface Methods ###
    # ## Non-mutating ##
    def count(self, val***REMOVED***:
        "Standard list count method"
        count = 0
        for i in self:
            if val == i:
                count += 1
        return count

    def index(self, val***REMOVED***:
        "Standard list index method"
        for i in range(0, len(self***REMOVED******REMOVED***:
            if self[i***REMOVED*** == val:
                return i
        raise ValueError('%s not found in object' % str(val***REMOVED******REMOVED***

    # ## Mutating ##
    def append(self, val***REMOVED***:
        "Standard list append method"
        self[len(self***REMOVED***:***REMOVED*** = [val***REMOVED***

    def extend(self, vals***REMOVED***:
        "Standard list extend method"
        self[len(self***REMOVED***:***REMOVED*** = vals

    def insert(self, index, val***REMOVED***:
        "Standard list insert method"
        if not isinstance(index, six.integer_types***REMOVED***:
            raise TypeError("%s is not a legal index" % index***REMOVED***
        self[index:index***REMOVED*** = [val***REMOVED***

    def pop(self, index=-1***REMOVED***:
        "Standard list pop method"
        result = self[index***REMOVED***
        del self[index***REMOVED***
        return result

    def remove(self, val***REMOVED***:
        "Standard list remove method"
        del self[self.index(val***REMOVED******REMOVED***

    def reverse(self***REMOVED***:
        "Standard list reverse method"
        self[:***REMOVED*** = self[-1::-1***REMOVED***

    def sort(self, cmp=None, key=None, reverse=False***REMOVED***:
        "Standard list sort method"
        if key:
            temp = [(key(v***REMOVED***, v***REMOVED*** for v in self***REMOVED***
            temp.sort(key=lambda x: x[0***REMOVED***, reverse=reverse***REMOVED***
            self[:***REMOVED*** = [v[1***REMOVED*** for v in temp***REMOVED***
        else:
            temp = list(self***REMOVED***
            if cmp is not None:
                temp.sort(cmp=cmp, reverse=reverse***REMOVED***
            else:
                temp.sort(reverse=reverse***REMOVED***
            self[:***REMOVED*** = temp

    # ### Private routines ###
    def _rebuild(self, newLen, newItems***REMOVED***:
        if newLen and newLen < self._minlength:
            raise ValueError('Must have at least %d items' % self._minlength***REMOVED***
        if self._maxlength is not None and newLen > self._maxlength:
            raise ValueError('Cannot have more than %d items' % self._maxlength***REMOVED***

        self._set_list(newLen, newItems***REMOVED***

    def _set_single_rebuild(self, index, value***REMOVED***:
        self._set_slice(slice(index, index + 1, 1***REMOVED***, [value***REMOVED******REMOVED***

    def _checkindex(self, index, correct=True***REMOVED***:
        length = len(self***REMOVED***
        if 0 <= index < length:
            return index
        if correct and -length <= index < 0:
            return index + length
        raise IndexError('invalid index: %s' % str(index***REMOVED******REMOVED***

    def _check_allowed(self, items***REMOVED***:
        if hasattr(self, '_allowed'***REMOVED***:
            if False in [isinstance(val, self._allowed***REMOVED*** for val in items***REMOVED***:
                raise TypeError('Invalid type encountered in the arguments.'***REMOVED***

    def _set_slice(self, index, values***REMOVED***:
        "Assign values to a slice of the object"
        ***REMOVED***
            iter(values***REMOVED***
        except TypeError:
            raise TypeError('can only assign an iterable to a slice'***REMOVED***

        self._check_allowed(values***REMOVED***

        origLen = len(self***REMOVED***
        valueList = list(values***REMOVED***
        start, stop, step = index.indices(origLen***REMOVED***

        # CAREFUL: index.step and step are not the same!
        # step will never be None
        if index.step is None:
            self._assign_simple_slice(start, stop, valueList***REMOVED***
        else:
            self._assign_extended_slice(start, stop, step, valueList***REMOVED***

    def _assign_extended_slice_rebuild(self, start, stop, step, valueList***REMOVED***:
        'Assign an extended slice by rebuilding entire list'
        indexList = range(start, stop, step***REMOVED***
        # extended slice, only allow assigning slice of same size
        if len(valueList***REMOVED*** != len(indexList***REMOVED***:
            raise ValueError('attempt to assign sequence of size %d '
                             'to extended slice of size %d'
                             % (len(valueList***REMOVED***, len(indexList***REMOVED******REMOVED******REMOVED***

        # we're not changing the length of the sequence
        newLen = len(self***REMOVED***
        newVals = dict(zip(indexList, valueList***REMOVED******REMOVED***

        def newItems(***REMOVED***:
            for i in range(newLen***REMOVED***:
                if i in newVals:
                    yield newVals[i***REMOVED***
                else:
                    yield self._get_single_internal(i***REMOVED***

        self._rebuild(newLen, newItems(***REMOVED******REMOVED***

    def _assign_extended_slice(self, start, stop, step, valueList***REMOVED***:
        'Assign an extended slice by re-assigning individual items'
        indexList = range(start, stop, step***REMOVED***
        # extended slice, only allow assigning slice of same size
        if len(valueList***REMOVED*** != len(indexList***REMOVED***:
            raise ValueError('attempt to assign sequence of size %d '
                             'to extended slice of size %d'
                             % (len(valueList***REMOVED***, len(indexList***REMOVED******REMOVED******REMOVED***

        for i, val in zip(indexList, valueList***REMOVED***:
            self._set_single(i, val***REMOVED***

    def _assign_simple_slice(self, start, stop, valueList***REMOVED***:
        'Assign a simple slice; Can assign slice of any length'
        origLen = len(self***REMOVED***
        stop = max(start, stop***REMOVED***
        newLen = origLen - stop + start + len(valueList***REMOVED***

        def newItems(***REMOVED***:
            for i in range(origLen + 1***REMOVED***:
                if i == start:
                    for val in valueList:
                        yield val

                if i < origLen:
                    if i < start or i >= stop:
                        yield self._get_single_internal(i***REMOVED***

        self._rebuild(newLen, newItems(***REMOVED******REMOVED***
