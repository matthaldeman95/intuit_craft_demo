import logging

from django.contrib.gis.db.models.fields import GeometryField
from django.db.backends.mysql.schema import DatabaseSchemaEditor
from django.db.utils import OperationalError

logger = logging.getLogger('django.contrib.gis'***REMOVED***


class MySQLGISSchemaEditor(DatabaseSchemaEditor***REMOVED***:
    sql_add_spatial_index = 'CREATE SPATIAL INDEX %(index***REMOVED***s ON %(table***REMOVED***s(%(column***REMOVED***s***REMOVED***'
    sql_drop_spatial_index = 'DROP INDEX %(index***REMOVED***s ON %(table***REMOVED***s'

    def __init__(self, *args, **kwargs***REMOVED***:
        super(MySQLGISSchemaEditor, self***REMOVED***.__init__(*args, **kwargs***REMOVED***
        self.geometry_sql = [***REMOVED***

    def skip_default(self, field***REMOVED***:
        return (
            super(MySQLGISSchemaEditor, self***REMOVED***.skip_default(field***REMOVED*** or
            # Geometry fields are stored as BLOB/TEXT and can't have defaults.
            isinstance(field, GeometryField***REMOVED***
        ***REMOVED***

    def column_sql(self, model, field, include_default=False***REMOVED***:
        column_sql = super(MySQLGISSchemaEditor, self***REMOVED***.column_sql(model, field, include_default***REMOVED***
        # MySQL doesn't support spatial indexes on NULL columns
        if isinstance(field, GeometryField***REMOVED*** and field.spatial_index and not field.null:
            qn = self.connection.ops.quote_name
            db_table = model._meta.db_table
            self.geometry_sql.append(
                self.sql_add_spatial_index % {
                    'index': qn(self._create_spatial_index_name(model, field***REMOVED******REMOVED***,
                    'table': qn(db_table***REMOVED***,
                    'column': qn(field.column***REMOVED***,
            ***REMOVED***
            ***REMOVED***
        return column_sql

    def create_model(self, model***REMOVED***:
        super(MySQLGISSchemaEditor, self***REMOVED***.create_model(model***REMOVED***
        self.create_spatial_indexes(***REMOVED***

    def add_field(self, model, field***REMOVED***:
        super(MySQLGISSchemaEditor, self***REMOVED***.add_field(model, field***REMOVED***
        self.create_spatial_indexes(***REMOVED***

    def remove_field(self, model, field***REMOVED***:
        if isinstance(field, GeometryField***REMOVED*** and field.spatial_index:
            qn = self.connection.ops.quote_name
            sql = self.sql_drop_spatial_index % {
                'index': qn(self._create_spatial_index_name(model, field***REMOVED******REMOVED***,
                'table': qn(model._meta.db_table***REMOVED***,
        ***REMOVED***
            ***REMOVED***
                self.execute(sql***REMOVED***
            except OperationalError:
                logger.error(
                    "Couldn't remove spatial index: %s (may be expected "
                    "if your storage engine doesn't support them***REMOVED***.", sql
                ***REMOVED***

        super(MySQLGISSchemaEditor, self***REMOVED***.remove_field(model, field***REMOVED***

    def _create_spatial_index_name(self, model, field***REMOVED***:
        return '%s_%s_id' % (model._meta.db_table, field.column***REMOVED***

    def create_spatial_indexes(self***REMOVED***:
        for sql in self.geometry_sql:
            ***REMOVED***
                self.execute(sql***REMOVED***
            except OperationalError:
                logger.error(
                    "Cannot create SPATIAL INDEX %s. Only MyISAM and (as of "
                    "MySQL 5.7.5***REMOVED*** InnoDB support them.", sql
                ***REMOVED***
        self.geometry_sql = [***REMOVED***
