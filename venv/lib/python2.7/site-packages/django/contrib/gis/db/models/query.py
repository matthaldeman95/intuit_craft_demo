import warnings

from django.contrib.gis.db.models.fields import (
    GeometryField, LineStringField, PointField, get_srid_info,
***REMOVED***
from django.contrib.gis.db.models.lookups import GISLookup
from django.contrib.gis.db.models.sql import (
    AreaField, DistanceField, GeomField, GMLField,
***REMOVED***
from django.contrib.gis.geometry.backend import Geometry
from django.contrib.gis.measure import Area, Distance
from django.db import connections
from django.db.models.constants import LOOKUP_SEP
from django.db.models.expressions import RawSQL
from django.db.models.fields import Field
from django.db.models.query import QuerySet
from django.utils import six
from django.utils.deprecation import RemovedInDjango20Warning


class GeoQuerySet(QuerySet***REMOVED***:
    "The Geographic QuerySet."

    # ### GeoQuerySet Methods ###
    def area(self, tolerance=0.05, **kwargs***REMOVED***:
        ***REMOVED***
        Returns the area of the geographic field in an `area` attribute on
        each element of this GeoQuerySet.
        ***REMOVED***
        # Performing setup here rather than in `_spatial_attribute` so that
        # we can get the units for `AreaField`.
        procedure_args, geo_field = self._spatial_setup(
            'area', field_name=kwargs.get('field_name'***REMOVED******REMOVED***
        s = {'procedure_args': procedure_args,
             'geo_field': geo_field,
             'setup': False,
         ***REMOVED***
        connection = connections[self.db***REMOVED***
        backend = connection.ops
        if backend.oracle:
            s['procedure_fmt'***REMOVED*** = '%(geo_col***REMOVED***s,%(tolerance***REMOVED***s'
            s['procedure_args'***REMOVED***['tolerance'***REMOVED*** = tolerance
            s['select_field'***REMOVED*** = AreaField('sq_m'***REMOVED***  # Oracle returns area in units of meters.
        elif backend.postgis or backend.spatialite:
            if backend.geography:
                # Geography fields support area calculation, returns square meters.
                s['select_field'***REMOVED*** = AreaField('sq_m'***REMOVED***
            elif not geo_field.geodetic(connection***REMOVED***:
                # Getting the area units of the geographic field.
                s['select_field'***REMOVED*** = AreaField(Area.unit_attname(geo_field.units_name(connection***REMOVED******REMOVED******REMOVED***
            else:
                # TODO: Do we want to support raw number areas for geodetic fields?
                raise Exception('Area on geodetic coordinate systems not supported.'***REMOVED***
        return self._spatial_attribute('area', s, **kwargs***REMOVED***

    def centroid(self, **kwargs***REMOVED***:
        ***REMOVED***
        Returns the centroid of the geographic field in a `centroid`
        attribute on each element of this GeoQuerySet.
        ***REMOVED***
        return self._geom_attribute('centroid', **kwargs***REMOVED***

    def difference(self, geom, **kwargs***REMOVED***:
        ***REMOVED***
        Returns the spatial difference of the geographic field in a `difference`
        attribute on each element of this GeoQuerySet.
        ***REMOVED***
        return self._geomset_attribute('difference', geom, **kwargs***REMOVED***

    def distance(self, geom, **kwargs***REMOVED***:
        ***REMOVED***
        Returns the distance from the given geographic field name to the
        given geometry in a `distance` attribute on each element of the
        GeoQuerySet.

        Keyword Arguments:
         `spheroid`  => If the geometry field is geodetic and PostGIS is
                        the spatial database, then the more accurate
                        spheroid calculation will be used instead of the
                        quicker sphere calculation.

         `tolerance` => Used only for Oracle. The tolerance is
                        in meters -- a default of 5 centimeters (0.05***REMOVED***
                        is used.
        ***REMOVED***
        return self._distance_attribute('distance', geom, **kwargs***REMOVED***

    def envelope(self, **kwargs***REMOVED***:
        ***REMOVED***
        Returns a Geometry representing the bounding box of the
        Geometry field in an `envelope` attribute on each element of
        the GeoQuerySet.
        ***REMOVED***
        return self._geom_attribute('envelope', **kwargs***REMOVED***

    def force_rhr(self, **kwargs***REMOVED***:
        ***REMOVED***
        Returns a modified version of the Polygon/MultiPolygon in which
        all of the vertices follow the Right-Hand-Rule.  By default,
        this is attached as the `force_rhr` attribute on each element
        of the GeoQuerySet.
        ***REMOVED***
        return self._geom_attribute('force_rhr', **kwargs***REMOVED***

    def geojson(self, precision=8, crs=False, bbox=False, **kwargs***REMOVED***:
        ***REMOVED***
        Returns a GeoJSON representation of the geometry field in a `geojson`
        attribute on each element of the GeoQuerySet.

        The `crs` and `bbox` keywords may be set to True if the user wants
        the coordinate reference system and the bounding box to be included
        in the GeoJSON representation of the geometry.
        ***REMOVED***
        backend = connections[self.db***REMOVED***.ops
        if not backend.geojson:
            raise NotImplementedError('Only PostGIS and SpatiaLite support GeoJSON serialization.'***REMOVED***

        if not isinstance(precision, six.integer_types***REMOVED***:
            raise TypeError('Precision keyword must be set with an integer.'***REMOVED***

        options = 0
        if crs and bbox:
            options = 3
        elif bbox:
            options = 1
        elif crs:
            options = 2
        s = {'desc': 'GeoJSON',
             'procedure_args': {'precision': precision, 'options': options***REMOVED***,
             'procedure_fmt': '%(geo_col***REMOVED***s,%(precision***REMOVED***s,%(options***REMOVED***s',
         ***REMOVED***
        return self._spatial_attribute('geojson', s, **kwargs***REMOVED***

    def geohash(self, precision=20, **kwargs***REMOVED***:
        ***REMOVED***
        Returns a GeoHash representation of the given field in a `geohash`
        attribute on each element of the GeoQuerySet.

        The `precision` keyword may be used to custom the number of
        _characters_ used in the output GeoHash, the default is 20.
        ***REMOVED***
        s = {'desc': 'GeoHash',
             'procedure_args': {'precision': precision***REMOVED***,
             'procedure_fmt': '%(geo_col***REMOVED***s,%(precision***REMOVED***s',
         ***REMOVED***
        return self._spatial_attribute('geohash', s, **kwargs***REMOVED***

    def gml(self, precision=8, version=2, **kwargs***REMOVED***:
        ***REMOVED***
        Returns GML representation of the given field in a `gml` attribute
        on each element of the GeoQuerySet.
        ***REMOVED***
        backend = connections[self.db***REMOVED***.ops
        s = {'desc': 'GML', 'procedure_args': {'precision': precision***REMOVED******REMOVED***
        if backend.postgis:
            s['procedure_fmt'***REMOVED*** = '%(version***REMOVED***s,%(geo_col***REMOVED***s,%(precision***REMOVED***s'
            s['procedure_args'***REMOVED*** = {'precision': precision, 'version': version***REMOVED***
        if backend.oracle:
            s['select_field'***REMOVED*** = GMLField(***REMOVED***

        return self._spatial_attribute('gml', s, **kwargs***REMOVED***

    def intersection(self, geom, **kwargs***REMOVED***:
        ***REMOVED***
        Returns the spatial intersection of the Geometry field in
        an `intersection` attribute on each element of this
        GeoQuerySet.
        ***REMOVED***
        return self._geomset_attribute('intersection', geom, **kwargs***REMOVED***

    def kml(self, **kwargs***REMOVED***:
        ***REMOVED***
        Returns KML representation of the geometry field in a `kml`
        attribute on each element of this GeoQuerySet.
        ***REMOVED***
        s = {'desc': 'KML',
             'procedure_fmt': '%(geo_col***REMOVED***s,%(precision***REMOVED***s',
             'procedure_args': {'precision': kwargs.pop('precision', 8***REMOVED******REMOVED***,
         ***REMOVED***
        return self._spatial_attribute('kml', s, **kwargs***REMOVED***

    def length(self, **kwargs***REMOVED***:
        ***REMOVED***
        Returns the length of the geometry field as a `Distance` object
        stored in a `length` attribute on each element of this GeoQuerySet.
        ***REMOVED***
        return self._distance_attribute('length', None, **kwargs***REMOVED***

    def mem_size(self, **kwargs***REMOVED***:
        ***REMOVED***
        Returns the memory size (number of bytes***REMOVED*** that the geometry field takes
        in a `mem_size` attribute  on each element of this GeoQuerySet.
        ***REMOVED***
        return self._spatial_attribute('mem_size', {***REMOVED***, **kwargs***REMOVED***

    def num_geom(self, **kwargs***REMOVED***:
        ***REMOVED***
        Returns the number of geometries if the field is a
        GeometryCollection or Multi* Field in a `num_geom`
        attribute on each element of this GeoQuerySet; otherwise
        the sets with None.
        ***REMOVED***
        return self._spatial_attribute('num_geom', {***REMOVED***, **kwargs***REMOVED***

    def num_points(self, **kwargs***REMOVED***:
        ***REMOVED***
        Returns the number of points in the first linestring in the
        Geometry field in a `num_points` attribute on each element of
        this GeoQuerySet; otherwise sets with None.
        ***REMOVED***
        return self._spatial_attribute('num_points', {***REMOVED***, **kwargs***REMOVED***

    def perimeter(self, **kwargs***REMOVED***:
        ***REMOVED***
        Returns the perimeter of the geometry field as a `Distance` object
        stored in a `perimeter` attribute on each element of this GeoQuerySet.
        ***REMOVED***
        return self._distance_attribute('perimeter', None, **kwargs***REMOVED***

    def point_on_surface(self, **kwargs***REMOVED***:
        ***REMOVED***
        Returns a Point geometry guaranteed to lie on the surface of the
        Geometry field in a `point_on_surface` attribute on each element
        of this GeoQuerySet; otherwise sets with None.
        ***REMOVED***
        return self._geom_attribute('point_on_surface', **kwargs***REMOVED***

    def reverse_geom(self, **kwargs***REMOVED***:
        ***REMOVED***
        Reverses the coordinate order of the geometry, and attaches as a
        `reverse` attribute on each element of this GeoQuerySet.
        ***REMOVED***
        s = {'select_field': GeomField(***REMOVED******REMOVED***
        kwargs.setdefault('model_att', 'reverse_geom'***REMOVED***
        if connections[self.db***REMOVED***.ops.oracle:
            s['geo_field_type'***REMOVED*** = LineStringField
        return self._spatial_attribute('reverse', s, **kwargs***REMOVED***

    def scale(self, x, y, z=0.0, **kwargs***REMOVED***:
        ***REMOVED***
        Scales the geometry to a new size by multiplying the ordinates
        with the given x,y,z scale factors.
        ***REMOVED***
        if connections[self.db***REMOVED***.ops.spatialite:
            if z != 0.0:
                raise NotImplementedError('SpatiaLite does not support 3D scaling.'***REMOVED***
            s = {'procedure_fmt': '%(geo_col***REMOVED***s,%(x***REMOVED***s,%(y***REMOVED***s',
                 'procedure_args': {'x': x, 'y': y***REMOVED***,
                 'select_field': GeomField(***REMOVED***,
             ***REMOVED***
        else:
            s = {'procedure_fmt': '%(geo_col***REMOVED***s,%(x***REMOVED***s,%(y***REMOVED***s,%(z***REMOVED***s',
                 'procedure_args': {'x': x, 'y': y, 'z': z***REMOVED***,
                 'select_field': GeomField(***REMOVED***,
             ***REMOVED***
        return self._spatial_attribute('scale', s, **kwargs***REMOVED***

    def snap_to_grid(self, *args, **kwargs***REMOVED***:
        ***REMOVED***
        Snap all points of the input geometry to the grid.  How the
        geometry is snapped to the grid depends on how many arguments
        were given:
          - 1 argument : A single size to snap both the X and Y grids to.
          - 2 arguments: X and Y sizes to snap the grid to.
          - 4 arguments: X, Y sizes and the X, Y origins.
        ***REMOVED***
        if False in [isinstance(arg, (float,***REMOVED*** + six.integer_types***REMOVED*** for arg in args***REMOVED***:
            raise TypeError('Size argument(s***REMOVED*** for the grid must be a float or integer values.'***REMOVED***

        nargs = len(args***REMOVED***
        if nargs == 1:
            size = args[0***REMOVED***
            procedure_fmt = '%(geo_col***REMOVED***s,%(size***REMOVED***s'
            procedure_args = {'size': size***REMOVED***
        elif nargs == 2:
            xsize, ysize = args
            procedure_fmt = '%(geo_col***REMOVED***s,%(xsize***REMOVED***s,%(ysize***REMOVED***s'
            procedure_args = {'xsize': xsize, 'ysize': ysize***REMOVED***
        elif nargs == 4:
            xsize, ysize, xorigin, yorigin = args
            procedure_fmt = '%(geo_col***REMOVED***s,%(xorigin***REMOVED***s,%(yorigin***REMOVED***s,%(xsize***REMOVED***s,%(ysize***REMOVED***s'
            procedure_args = {'xsize': xsize, 'ysize': ysize,
                              'xorigin': xorigin, 'yorigin': yorigin***REMOVED***
        else:
            raise ValueError('Must provide 1, 2, or 4 arguments to `snap_to_grid`.'***REMOVED***

        s = {'procedure_fmt': procedure_fmt,
             'procedure_args': procedure_args,
             'select_field': GeomField(***REMOVED***,
         ***REMOVED***

        return self._spatial_attribute('snap_to_grid', s, **kwargs***REMOVED***

    def svg(self, relative=False, precision=8, **kwargs***REMOVED***:
        ***REMOVED***
        Returns SVG representation of the geographic field in a `svg`
        attribute on each element of this GeoQuerySet.

        Keyword Arguments:
         `relative`  => If set to True, this will evaluate the path in
                        terms of relative moves (rather than absolute***REMOVED***.

         `precision` => May be used to set the maximum number of decimal
                        digits used in output (defaults to 8***REMOVED***.
        ***REMOVED***
        relative = int(bool(relative***REMOVED******REMOVED***
        if not isinstance(precision, six.integer_types***REMOVED***:
            raise TypeError('SVG precision keyword argument must be an integer.'***REMOVED***
        s = {
            'desc': 'SVG',
            'procedure_fmt': '%(geo_col***REMOVED***s,%(rel***REMOVED***s,%(precision***REMOVED***s',
            'procedure_args': {
                'rel': relative,
                'precision': precision,
        ***REMOVED***
    ***REMOVED***
        return self._spatial_attribute('svg', s, **kwargs***REMOVED***

    def sym_difference(self, geom, **kwargs***REMOVED***:
        ***REMOVED***
        Returns the symmetric difference of the geographic field in a
        `sym_difference` attribute on each element of this GeoQuerySet.
        ***REMOVED***
        return self._geomset_attribute('sym_difference', geom, **kwargs***REMOVED***

    def translate(self, x, y, z=0.0, **kwargs***REMOVED***:
        ***REMOVED***
        Translates the geometry to a new location using the given numeric
        parameters as offsets.
        ***REMOVED***
        if connections[self.db***REMOVED***.ops.spatialite:
            if z != 0.0:
                raise NotImplementedError('SpatiaLite does not support 3D translation.'***REMOVED***
            s = {'procedure_fmt': '%(geo_col***REMOVED***s,%(x***REMOVED***s,%(y***REMOVED***s',
                 'procedure_args': {'x': x, 'y': y***REMOVED***,
                 'select_field': GeomField(***REMOVED***,
             ***REMOVED***
        else:
            s = {'procedure_fmt': '%(geo_col***REMOVED***s,%(x***REMOVED***s,%(y***REMOVED***s,%(z***REMOVED***s',
                 'procedure_args': {'x': x, 'y': y, 'z': z***REMOVED***,
                 'select_field': GeomField(***REMOVED***,
             ***REMOVED***
        return self._spatial_attribute('translate', s, **kwargs***REMOVED***

    def transform(self, srid=4326, **kwargs***REMOVED***:
        ***REMOVED***
        Transforms the given geometry field to the given SRID.  If no SRID is
        provided, the transformation will default to using 4326 (WGS84***REMOVED***.
        ***REMOVED***
        if not isinstance(srid, six.integer_types***REMOVED***:
            raise TypeError('An integer SRID must be provided.'***REMOVED***
        field_name = kwargs.get('field_name'***REMOVED***
        self._spatial_setup('transform', field_name=field_name***REMOVED***
        self.query.add_context('transformed_srid', srid***REMOVED***
        return self._clone(***REMOVED***

    def union(self, geom, **kwargs***REMOVED***:
        ***REMOVED***
        Returns the union of the geographic field with the given
        Geometry in a `union` attribute on each element of this GeoQuerySet.
        ***REMOVED***
        return self._geomset_attribute('union', geom, **kwargs***REMOVED***

    # ### Private API -- Abstracted DRY routines. ###
    def _spatial_setup(self, att, desc=None, field_name=None, geo_field_type=None***REMOVED***:
        ***REMOVED***
        Performs set up for executing the spatial function.
        ***REMOVED***
        # Does the spatial backend support this?
        connection = connections[self.db***REMOVED***
        func = getattr(connection.ops, att, False***REMOVED***
        if desc is None:
            desc = att
        if not func:
            raise NotImplementedError('%s stored procedure not available on '
                                      'the %s backend.' %
                                      (desc, connection.ops.name***REMOVED******REMOVED***

        # Initializing the procedure arguments.
        procedure_args = {'function': func***REMOVED***

        # Is there a geographic field in the model to perform this
        # operation on?
        geo_field = self._geo_field(field_name***REMOVED***
        if not geo_field:
            raise TypeError('%s output only available on GeometryFields.' % func***REMOVED***

        # If the `geo_field_type` keyword was used, then enforce that
        # type limitation.
        if geo_field_type is not None and not isinstance(geo_field, geo_field_type***REMOVED***:
            raise TypeError('"%s" stored procedures may only be called on %ss.' % (func, geo_field_type.__name__***REMOVED******REMOVED***

        # Setting the procedure args.
        procedure_args['geo_col'***REMOVED*** = self._geocol_select(geo_field, field_name***REMOVED***

        return procedure_args, geo_field

    def _spatial_attribute(self, att, settings, field_name=None, model_att=None***REMOVED***:
        ***REMOVED***
        DRY routine for calling a spatial stored procedure on a geometry column
        and attaching its output as an attribute of the model.

        Arguments:
         att:
          The name of the spatial attribute that holds the spatial
          SQL function to call.

         settings:
          Dictionary of internal settings to customize for the spatial procedure.

        Public Keyword Arguments:

         field_name:
          The name of the geographic field to call the spatial
          function on.  May also be a lookup to a geometry field
          as part of a foreign key relation.

         model_att:
          The name of the model attribute to attach the output of
          the spatial function to.
        ***REMOVED***
        warnings.warn(
            "The %s GeoQuerySet method is deprecated. See GeoDjango Functions "
            "documentation to find the expression-based replacement." % att,
            RemovedInDjango20Warning, stacklevel=2
        ***REMOVED***
        # Default settings.
        settings.setdefault('desc', None***REMOVED***
        settings.setdefault('geom_args', (***REMOVED******REMOVED***
        settings.setdefault('geom_field', None***REMOVED***
        settings.setdefault('procedure_args', {***REMOVED******REMOVED***
        settings.setdefault('procedure_fmt', '%(geo_col***REMOVED***s'***REMOVED***
        settings.setdefault('select_params', [***REMOVED******REMOVED***

        connection = connections[self.db***REMOVED***

        # Performing setup for the spatial column, unless told not to.
        if settings.get('setup', True***REMOVED***:
            default_args, geo_field = self._spatial_setup(
                att, desc=settings['desc'***REMOVED***, field_name=field_name,
                geo_field_type=settings.get('geo_field_type'***REMOVED******REMOVED***
            for k, v in six.iteritems(default_args***REMOVED***:
                settings['procedure_args'***REMOVED***.setdefault(k, v***REMOVED***
        else:
            geo_field = settings['geo_field'***REMOVED***

        # The attribute to attach to the model.
        if not isinstance(model_att, six.string_types***REMOVED***:
            model_att = att

        # Special handling for any argument that is a geometry.
        for name in settings['geom_args'***REMOVED***:
            # Using the field's get_placeholder(***REMOVED*** routine to get any needed
            # transformation SQL.
            geom = geo_field.get_prep_value(settings['procedure_args'***REMOVED***[name***REMOVED******REMOVED***
            params = geo_field._get_db_prep_lookup('contains', geom, connection=connection***REMOVED***
            geom_placeholder = geo_field.get_placeholder(geom, None, connection***REMOVED***

            # Replacing the procedure format with that of any needed
            # transformation SQL.
            old_fmt = '%%(%s***REMOVED***s' % name
            new_fmt = geom_placeholder % '%%s'
            settings['procedure_fmt'***REMOVED*** = settings['procedure_fmt'***REMOVED***.replace(old_fmt, new_fmt***REMOVED***
            settings['select_params'***REMOVED***.extend(params***REMOVED***

        # Getting the format for the stored procedure.
        fmt = '%%(function***REMOVED***s(%s***REMOVED***' % settings['procedure_fmt'***REMOVED***

        # If the result of this function needs to be converted.
        if settings.get('select_field'***REMOVED***:
            select_field = settings['select_field'***REMOVED***
            if connection.ops.oracle:
                select_field.empty_strings_allowed = False
        else:
            select_field = Field(***REMOVED***

        # Finally, setting the extra selection attribute with
        # the format string expanded with the stored procedure
        # arguments.
        self.query.add_annotation(
            RawSQL(fmt % settings['procedure_args'***REMOVED***, settings['select_params'***REMOVED***, select_field***REMOVED***,
            model_att***REMOVED***
        return self

    def _distance_attribute(self, func, geom=None, tolerance=0.05, spheroid=False, **kwargs***REMOVED***:
        ***REMOVED***
        DRY routine for GeoQuerySet distance attribute routines.
        ***REMOVED***
        # Setting up the distance procedure arguments.
        procedure_args, geo_field = self._spatial_setup(func, field_name=kwargs.get('field_name'***REMOVED******REMOVED***

        # If geodetic defaulting distance attribute to meters (Oracle and
        # PostGIS spherical distances return meters***REMOVED***.  Otherwise, use the
        # units of the geometry field.
        connection = connections[self.db***REMOVED***
        geodetic = geo_field.geodetic(connection***REMOVED***
        geography = geo_field.geography

        if geodetic:
            dist_att = 'm'
        else:
            dist_att = Distance.unit_attname(geo_field.units_name(connection***REMOVED******REMOVED***

        # Shortcut booleans for what distance function we're using and
        # whether the geometry field is 3D.
        distance = func == 'distance'
        length = func == 'length'
        perimeter = func == 'perimeter'
        if not (distance or length or perimeter***REMOVED***:
            raise ValueError('Unknown distance function: %s' % func***REMOVED***
        geom_3d = geo_field.dim == 3

        # The field's _get_db_prep_lookup(***REMOVED*** is used to get any
        # extra distance parameters.  Here we set up the
        # parameters that will be passed in to field's function.
        lookup_params = [geom or 'POINT (0 0***REMOVED***', 0***REMOVED***

        # Getting the spatial backend operations.
        backend = connection.ops

        # If the spheroid calculation is desired, either by the `spheroid`
        # keyword or when calculating the length of geodetic field, make
        # sure the 'spheroid' distance setting string is passed in so we
        # get the correct spatial stored procedure.
        if spheroid or (backend.postgis and geodetic and
                        (not geography***REMOVED*** and length***REMOVED***:
            lookup_params.append('spheroid'***REMOVED***
        lookup_params = geo_field.get_prep_value(lookup_params***REMOVED***
        params = geo_field._get_db_prep_lookup('distance_lte', lookup_params, connection=connection***REMOVED***

        # The `geom_args` flag is set to true if a geometry parameter was
        # passed in.
        geom_args = bool(geom***REMOVED***

        if backend.oracle:
            if distance:
                procedure_fmt = '%(geo_col***REMOVED***s,%(geom***REMOVED***s,%(tolerance***REMOVED***s'
            elif length or perimeter:
                procedure_fmt = '%(geo_col***REMOVED***s,%(tolerance***REMOVED***s'
            procedure_args['tolerance'***REMOVED*** = tolerance
        else:
            # Getting whether this field is in units of degrees since the field may have
            # been transformed via the `transform` GeoQuerySet method.
            srid = self.query.get_context('transformed_srid'***REMOVED***
            if srid:
                u, unit_name, s = get_srid_info(srid, connection***REMOVED***
                geodetic = unit_name.lower(***REMOVED*** in geo_field.geodetic_units

            if geodetic and not connection.features.supports_distance_geodetic:
                raise ValueError(
                    'This database does not support linear distance '
                    'calculations on geodetic coordinate systems.'
                ***REMOVED***

            if distance:
                if srid:
                    # Setting the `geom_args` flag to false because we want to handle
                    # transformation SQL here, rather than the way done by default
                    # (which will transform to the original SRID of the field rather
                    #  than to what was transformed to***REMOVED***.
                    geom_args = False
                    procedure_fmt = '%s(%%(geo_col***REMOVED***s, %s***REMOVED***' % (backend.transform, srid***REMOVED***
                    if geom.srid is None or geom.srid == srid:
                        # If the geom parameter srid is None, it is assumed the coordinates
                        # are in the transformed units.  A placeholder is used for the
                        # geometry parameter.  `GeomFromText` constructor is also needed
                        # to wrap geom placeholder for SpatiaLite.
                        if backend.spatialite:
                            procedure_fmt += ', %s(%%%%s, %s***REMOVED***' % (backend.from_text, srid***REMOVED***
                        else:
                            procedure_fmt += ', %%s'
                    else:
                        # We need to transform the geom to the srid specified in `transform(***REMOVED***`,
                        # so wrapping the geometry placeholder in transformation SQL.
                        # SpatiaLite also needs geometry placeholder wrapped in `GeomFromText`
                        # constructor.
                        if backend.spatialite:
                            procedure_fmt += (', %s(%s(%%%%s, %s***REMOVED***, %s***REMOVED***' % (
                                backend.transform, backend.from_text,
                                geom.srid, srid***REMOVED******REMOVED***
                        else:
                            procedure_fmt += ', %s(%%%%s, %s***REMOVED***' % (backend.transform, srid***REMOVED***
                else:
                    # `transform(***REMOVED***` was not used on this GeoQuerySet.
                    procedure_fmt = '%(geo_col***REMOVED***s,%(geom***REMOVED***s'

                if not geography and geodetic:
                    # Spherical distance calculation is needed (because the geographic
                    # field is geodetic***REMOVED***. However, the PostGIS ST_distance_sphere/spheroid(***REMOVED***
                    # procedures may only do queries from point columns to point geometries
                    # some error checking is required.
                    if not backend.geography:
                        if not isinstance(geo_field, PointField***REMOVED***:
                            raise ValueError('Spherical distance calculation only supported on PointFields.'***REMOVED***
                        if not str(Geometry(six.memoryview(params[0***REMOVED***.ewkb***REMOVED******REMOVED***.geom_type***REMOVED*** == 'Point':
                            raise ValueError(
                                'Spherical distance calculation only supported with '
                                'Point Geometry parameters'
                            ***REMOVED***
                    # The `function` procedure argument needs to be set differently for
                    # geodetic distance calculations.
                    if spheroid:
                        # Call to distance_spheroid(***REMOVED*** requires spheroid param as well.
                        procedure_fmt += ",'%(spheroid***REMOVED***s'"
                        procedure_args.update({'function': backend.distance_spheroid, 'spheroid': params[1***REMOVED******REMOVED******REMOVED***
                    else:
                        procedure_args.update({'function': backend.distance_sphere***REMOVED******REMOVED***
            elif length or perimeter:
                procedure_fmt = '%(geo_col***REMOVED***s'
                if not geography and geodetic and length:
                    # There's no `length_sphere`, and `length_spheroid` also
                    # works on 3D geometries.
                    procedure_fmt += ",'%(spheroid***REMOVED***s'"
                    procedure_args.update({'function': backend.length_spheroid, 'spheroid': params[1***REMOVED******REMOVED******REMOVED***
                elif geom_3d and connection.features.supports_3d_functions:
                    # Use 3D variants of perimeter and length routines on supported backends.
                    if perimeter:
                        procedure_args.update({'function': backend.perimeter3d***REMOVED******REMOVED***
                    elif length:
                        procedure_args.update({'function': backend.length3d***REMOVED******REMOVED***

        # Setting up the settings for `_spatial_attribute`.
        s = {'select_field': DistanceField(dist_att***REMOVED***,
             'setup': False,
             'geo_field': geo_field,
             'procedure_args': procedure_args,
             'procedure_fmt': procedure_fmt,
         ***REMOVED***
        if geom_args:
            s['geom_args'***REMOVED*** = ('geom',***REMOVED***
            s['procedure_args'***REMOVED***['geom'***REMOVED*** = geom
        elif geom:
            # The geometry is passed in as a parameter because we handled
            # transformation conditions in this routine.
            s['select_params'***REMOVED*** = [backend.Adapter(geom***REMOVED******REMOVED***
        return self._spatial_attribute(func, s, **kwargs***REMOVED***

    def _geom_attribute(self, func, tolerance=0.05, **kwargs***REMOVED***:
        ***REMOVED***
        DRY routine for setting up a GeoQuerySet method that attaches a
        Geometry attribute (e.g., `centroid`, `point_on_surface`***REMOVED***.
        ***REMOVED***
        s = {'select_field': GeomField(***REMOVED******REMOVED***
        if connections[self.db***REMOVED***.ops.oracle:
            s['procedure_fmt'***REMOVED*** = '%(geo_col***REMOVED***s,%(tolerance***REMOVED***s'
            s['procedure_args'***REMOVED*** = {'tolerance': tolerance***REMOVED***
        return self._spatial_attribute(func, s, **kwargs***REMOVED***

    def _geomset_attribute(self, func, geom, tolerance=0.05, **kwargs***REMOVED***:
        ***REMOVED***
        DRY routine for setting up a GeoQuerySet method that attaches a
        Geometry attribute and takes a Geoemtry parameter.  This is used
        for geometry set-like operations (e.g., intersection, difference,
        union, sym_difference***REMOVED***.
        ***REMOVED***
        s = {
            'geom_args': ('geom',***REMOVED***,
            'select_field': GeomField(***REMOVED***,
            'procedure_fmt': '%(geo_col***REMOVED***s,%(geom***REMOVED***s',
            'procedure_args': {'geom': geom***REMOVED***,
    ***REMOVED***
        if connections[self.db***REMOVED***.ops.oracle:
            s['procedure_fmt'***REMOVED*** += ',%(tolerance***REMOVED***s'
            s['procedure_args'***REMOVED***['tolerance'***REMOVED*** = tolerance
        return self._spatial_attribute(func, s, **kwargs***REMOVED***

    def _geocol_select(self, geo_field, field_name***REMOVED***:
        ***REMOVED***
        Helper routine for constructing the SQL to select the geographic
        column.  Takes into account if the geographic field is in a
        ForeignKey relation to the current model.
        ***REMOVED***
        compiler = self.query.get_compiler(self.db***REMOVED***
        opts = self.model._meta
        if geo_field not in opts.fields:
            # Is this operation going to be on a related geographic field?
            # If so, it'll have to be added to the select related information
            # (e.g., if 'location__point' was given as the field name, then
            # chop the non-relational field and add select_related('location'***REMOVED******REMOVED***.
            # Note: the operation really is defined as "must add select related!"
            self.query.add_select_related([field_name.rsplit(LOOKUP_SEP, 1***REMOVED***[0***REMOVED******REMOVED******REMOVED***
            # Call pre_sql_setup(***REMOVED*** so that compiler.select gets populated.
            compiler.pre_sql_setup(***REMOVED***
            for col, _, _ in compiler.select:
                if col.output_field == geo_field:
                    return col.as_sql(compiler, compiler.connection***REMOVED***[0***REMOVED***
            raise ValueError("%r not in compiler's related_select_cols" % geo_field***REMOVED***
        elif geo_field not in opts.local_fields:
            # This geographic field is inherited from another model, so we have to
            # use the db table for the _parent_ model instead.
            parent_model = geo_field.model._meta.concrete_model
            return self._field_column(compiler, geo_field, parent_model._meta.db_table***REMOVED***
        else:
            return self._field_column(compiler, geo_field***REMOVED***

    # Private API utilities, subject to change.
    def _geo_field(self, field_name=None***REMOVED***:
        ***REMOVED***
        Returns the first Geometry field encountered or the one specified via
        the `field_name` keyword. The `field_name` may be a string specifying
        the geometry field on this GeoQuerySet's model, or a lookup string
        to a geometry field via a ForeignKey relation.
        ***REMOVED***
        if field_name is None:
            # Incrementing until the first geographic field is found.
            for field in self.model._meta.fields:
                if isinstance(field, GeometryField***REMOVED***:
                    return field
            return False
        else:
            # Otherwise, check by the given field name -- which may be
            # a lookup to a _related_ geographic field.
            return GISLookup._check_geo_field(self.model._meta, field_name***REMOVED***

    def _field_column(self, compiler, field, table_alias=None, column=None***REMOVED***:
        ***REMOVED***
        Helper function that returns the database column for the given field.
        The table and column are returned (quoted***REMOVED*** in the proper format, e.g.,
        `"geoapp_city"."point"`.  If `table_alias` is not specified, the
        database table associated with the model of this `GeoQuerySet` will be
        used.  If `column` is specified, it will be used instead of the value
        in `field.column`.
        ***REMOVED***
        if table_alias is None:
            table_alias = compiler.query.get_meta(***REMOVED***.db_table
        return "%s.%s" % (compiler.quote_name_unless_alias(table_alias***REMOVED***,
                          compiler.connection.ops.quote_name(column or field.column***REMOVED******REMOVED***
