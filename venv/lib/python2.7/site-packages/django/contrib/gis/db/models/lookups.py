from __future__ import unicode_literals

import re

from django.core.exceptions import FieldDoesNotExist
from django.db.models.constants import LOOKUP_SEP
from django.db.models.expressions import Col, Expression
from django.db.models.lookups import BuiltinLookup, Lookup, Transform
from django.utils import six

gis_lookups = {***REMOVED***


class RasterBandTransform(Transform***REMOVED***:
    def as_sql(self, compiler, connection***REMOVED***:
        return compiler.compile(self.lhs***REMOVED***


class GISLookup(Lookup***REMOVED***:
    sql_template = None
    transform_func = None
    distance = False
    band_rhs = None
    band_lhs = None

    def __init__(self, *args, **kwargs***REMOVED***:
        super(GISLookup, self***REMOVED***.__init__(*args, **kwargs***REMOVED***
        self.template_params = {***REMOVED***

    @classmethod
    def _check_geo_field(cls, opts, lookup***REMOVED***:
        ***REMOVED***
        Utility for checking the given lookup with the given model options.
        The lookup is a string either specifying the geographic field, e.g.
        'point, 'the_geom', or a related lookup on a geographic field like
        'address__point'.

        If a BaseSpatialField exists according to the given lookup on the model
        options, it will be returned. Otherwise return None.
        ***REMOVED***
        from django.contrib.gis.db.models.fields import BaseSpatialField
        # This takes into account the situation where the lookup is a
        # lookup to a related geographic field, e.g., 'address__point'.
        field_list = lookup.split(LOOKUP_SEP***REMOVED***

        # Reversing so list operates like a queue of related lookups,
        # and popping the top lookup.
        field_list.reverse(***REMOVED***
        fld_name = field_list.pop(***REMOVED***

        ***REMOVED***
            geo_fld = opts.get_field(fld_name***REMOVED***
            # If the field list is still around, then it means that the
            # lookup was for a geometry field across a relationship --
            # thus we keep on getting the related model options and the
            # model field associated with the next field in the list
            # until there's no more left.
            while len(field_list***REMOVED***:
                opts = geo_fld.remote_field.model._meta
                geo_fld = opts.get_field(field_list.pop(***REMOVED******REMOVED***
        except (FieldDoesNotExist, AttributeError***REMOVED***:
            return False

        # Finally, make sure we got a Geographic field and return.
        if isinstance(geo_fld, BaseSpatialField***REMOVED***:
            return geo_fld
        else:
            return False

    def process_band_indices(self, only_lhs=False***REMOVED***:
        ***REMOVED***
        Extract the lhs band index from the band transform class and the rhs
        band index from the input tuple.
        ***REMOVED***
        # PostGIS band indices are 1-based, so the band index needs to be
        # increased to be consistent with the GDALRaster band indices.
        if only_lhs:
            self.band_rhs = 1
            self.band_lhs = self.lhs.band_index + 1
            return

        if isinstance(self.lhs, RasterBandTransform***REMOVED***:
            self.band_lhs = self.lhs.band_index + 1
        else:
            self.band_lhs = 1

        self.band_rhs = self.rhs[1***REMOVED***
        if len(self.rhs***REMOVED*** == 1:
            self.rhs = self.rhs[0***REMOVED***
        else:
            self.rhs = (self.rhs[0***REMOVED***, ***REMOVED*** + self.rhs[2:***REMOVED***

    def get_db_prep_lookup(self, value, connection***REMOVED***:
        # get_db_prep_lookup is called by process_rhs from super class
        if isinstance(value, (tuple, list***REMOVED******REMOVED***:
            # First param is assumed to be the geometric object
            params = [connection.ops.Adapter(value[0***REMOVED******REMOVED******REMOVED*** + list(value***REMOVED***[1:***REMOVED***
        else:
            params = [connection.ops.Adapter(value***REMOVED******REMOVED***
        return ('%s', params***REMOVED***

    def process_rhs(self, compiler, connection***REMOVED***:
        if hasattr(self.rhs, '_as_sql'***REMOVED***:
            # If rhs is some QuerySet, don't touch it
            return super(GISLookup, self***REMOVED***.process_rhs(compiler, connection***REMOVED***

        geom = self.rhs
        if isinstance(self.rhs, Col***REMOVED***:
            # Make sure the F Expression destination field exists, and
            # set an `srid` attribute with the same as that of the
            # destination.
            geo_fld = self.rhs.output_field
            if not hasattr(geo_fld, 'srid'***REMOVED***:
                raise ValueError('No geographic field found in expression.'***REMOVED***
            self.rhs.srid = geo_fld.srid
        elif isinstance(self.rhs, Expression***REMOVED***:
            raise ValueError('Complex expressions not supported for spatial fields.'***REMOVED***
        elif isinstance(self.rhs, (list, tuple***REMOVED******REMOVED***:
            geom = self.rhs[0***REMOVED***
            # Check if a band index was passed in the query argument.
            if ((len(self.rhs***REMOVED*** == 2 and not self.lookup_name == 'relate'***REMOVED*** or
                    (len(self.rhs***REMOVED*** == 3 and self.lookup_name == 'relate'***REMOVED******REMOVED***:
                self.process_band_indices(***REMOVED***
            elif len(self.rhs***REMOVED*** > 2:
                raise ValueError('Tuple too long for lookup %s.' % self.lookup_name***REMOVED***
        elif isinstance(self.lhs, RasterBandTransform***REMOVED***:
            self.process_band_indices(only_lhs=True***REMOVED***

        rhs, rhs_params = super(GISLookup, self***REMOVED***.process_rhs(compiler, connection***REMOVED***
        rhs = connection.ops.get_geom_placeholder(self.lhs.output_field, geom, compiler***REMOVED***
        return rhs, rhs_params

    def get_rhs_op(self, connection, rhs***REMOVED***:
        # Unlike BuiltinLookup, the GIS get_rhs_op(***REMOVED*** implementation should return
        # an object (SpatialOperator***REMOVED*** with an as_sql(***REMOVED*** method to allow for more
        # complex computations (where the lhs part can be mixed in***REMOVED***.
        return connection.ops.gis_operators[self.lookup_name***REMOVED***

    def as_sql(self, compiler, connection***REMOVED***:
        lhs_sql, sql_params = self.process_lhs(compiler, connection***REMOVED***
        rhs_sql, rhs_params = self.process_rhs(compiler, connection***REMOVED***
        sql_params.extend(rhs_params***REMOVED***

        template_params = {'lhs': lhs_sql, 'rhs': rhs_sql, 'value': '%s'***REMOVED***
        template_params.update(self.template_params***REMOVED***
        rhs_op = self.get_rhs_op(connection, rhs_sql***REMOVED***
        return rhs_op.as_sql(connection, self, template_params, sql_params***REMOVED***


# ------------------
# Geometry operators
# ------------------

class OverlapsLeftLookup(GISLookup***REMOVED***:
    ***REMOVED***
    The overlaps_left operator returns true if A's bounding box overlaps or is to the
    left of B's bounding box.
    ***REMOVED***
    lookup_name = 'overlaps_left'
gis_lookups['overlaps_left'***REMOVED*** = OverlapsLeftLookup


class OverlapsRightLookup(GISLookup***REMOVED***:
    ***REMOVED***
    The 'overlaps_right' operator returns true if A's bounding box overlaps or is to the
    right of B's bounding box.
    ***REMOVED***
    lookup_name = 'overlaps_right'
gis_lookups['overlaps_right'***REMOVED*** = OverlapsRightLookup


class OverlapsBelowLookup(GISLookup***REMOVED***:
    ***REMOVED***
    The 'overlaps_below' operator returns true if A's bounding box overlaps or is below
    B's bounding box.
    ***REMOVED***
    lookup_name = 'overlaps_below'
gis_lookups['overlaps_below'***REMOVED*** = OverlapsBelowLookup


class OverlapsAboveLookup(GISLookup***REMOVED***:
    ***REMOVED***
    The 'overlaps_above' operator returns true if A's bounding box overlaps or is above
    B's bounding box.
    ***REMOVED***
    lookup_name = 'overlaps_above'
gis_lookups['overlaps_above'***REMOVED*** = OverlapsAboveLookup


class LeftLookup(GISLookup***REMOVED***:
    ***REMOVED***
    The 'left' operator returns true if A's bounding box is strictly to the left
    of B's bounding box.
    ***REMOVED***
    lookup_name = 'left'
gis_lookups['left'***REMOVED*** = LeftLookup


class RightLookup(GISLookup***REMOVED***:
    ***REMOVED***
    The 'right' operator returns true if A's bounding box is strictly to the right
    of B's bounding box.
    ***REMOVED***
    lookup_name = 'right'
gis_lookups['right'***REMOVED*** = RightLookup


class StrictlyBelowLookup(GISLookup***REMOVED***:
    ***REMOVED***
    The 'strictly_below' operator returns true if A's bounding box is strictly below B's
    bounding box.
    ***REMOVED***
    lookup_name = 'strictly_below'
gis_lookups['strictly_below'***REMOVED*** = StrictlyBelowLookup


class StrictlyAboveLookup(GISLookup***REMOVED***:
    ***REMOVED***
    The 'strictly_above' operator returns true if A's bounding box is strictly above B's
    bounding box.
    ***REMOVED***
    lookup_name = 'strictly_above'
gis_lookups['strictly_above'***REMOVED*** = StrictlyAboveLookup


class SameAsLookup(GISLookup***REMOVED***:
    ***REMOVED***
    The "~=" operator is the "same as" operator. It tests actual geometric
    equality of two features. So if A and B are the same feature,
    vertex-by-vertex, the operator returns true.
    ***REMOVED***
    lookup_name = 'same_as'
gis_lookups['same_as'***REMOVED*** = SameAsLookup


class ExactLookup(SameAsLookup***REMOVED***:
    # Alias of same_as
    lookup_name = 'exact'
gis_lookups['exact'***REMOVED*** = ExactLookup


class BBContainsLookup(GISLookup***REMOVED***:
    ***REMOVED***
    The 'bbcontains' operator returns true if A's bounding box completely contains
    by B's bounding box.
    ***REMOVED***
    lookup_name = 'bbcontains'
gis_lookups['bbcontains'***REMOVED*** = BBContainsLookup


class BBOverlapsLookup(GISLookup***REMOVED***:
    ***REMOVED***
    The 'bboverlaps' operator returns true if A's bounding box overlaps B's bounding box.
    ***REMOVED***
    lookup_name = 'bboverlaps'
gis_lookups['bboverlaps'***REMOVED*** = BBOverlapsLookup


class ContainedLookup(GISLookup***REMOVED***:
    ***REMOVED***
    The 'contained' operator returns true if A's bounding box is completely contained
    by B's bounding box.
    ***REMOVED***
    lookup_name = 'contained'
gis_lookups['contained'***REMOVED*** = ContainedLookup


# ------------------
# Geometry functions
# ------------------

class ContainsLookup(GISLookup***REMOVED***:
    lookup_name = 'contains'
gis_lookups['contains'***REMOVED*** = ContainsLookup


class ContainsProperlyLookup(GISLookup***REMOVED***:
    lookup_name = 'contains_properly'
gis_lookups['contains_properly'***REMOVED*** = ContainsProperlyLookup


class CoveredByLookup(GISLookup***REMOVED***:
    lookup_name = 'coveredby'
gis_lookups['coveredby'***REMOVED*** = CoveredByLookup


class CoversLookup(GISLookup***REMOVED***:
    lookup_name = 'covers'
gis_lookups['covers'***REMOVED*** = CoversLookup


class CrossesLookup(GISLookup***REMOVED***:
    lookup_name = 'crosses'
gis_lookups['crosses'***REMOVED*** = CrossesLookup


class DisjointLookup(GISLookup***REMOVED***:
    lookup_name = 'disjoint'
gis_lookups['disjoint'***REMOVED*** = DisjointLookup


class EqualsLookup(GISLookup***REMOVED***:
    lookup_name = 'equals'
gis_lookups['equals'***REMOVED*** = EqualsLookup


class IntersectsLookup(GISLookup***REMOVED***:
    lookup_name = 'intersects'
gis_lookups['intersects'***REMOVED*** = IntersectsLookup


class IsValidLookup(BuiltinLookup***REMOVED***:
    lookup_name = 'isvalid'

    def as_sql(self, compiler, connection***REMOVED***:
        if self.lhs.field.geom_type == 'RASTER':
            raise ValueError('The isvalid lookup is only available on geometry fields.'***REMOVED***
        gis_op = connection.ops.gis_operators[self.lookup_name***REMOVED***
        sql, params = self.process_lhs(compiler, connection***REMOVED***
        sql = '%(func***REMOVED***s(%(lhs***REMOVED***s***REMOVED***' % {'func': gis_op.func, 'lhs': sql***REMOVED***
        if not self.rhs:
            sql = 'NOT ' + sql
        return sql, params
gis_lookups['isvalid'***REMOVED*** = IsValidLookup


class OverlapsLookup(GISLookup***REMOVED***:
    lookup_name = 'overlaps'
gis_lookups['overlaps'***REMOVED*** = OverlapsLookup


class RelateLookup(GISLookup***REMOVED***:
    lookup_name = 'relate'
    sql_template = '%(func***REMOVED***s(%(lhs***REMOVED***s, %(rhs***REMOVED***s, %%s***REMOVED***'
    pattern_regex = re.compile(r'^[012TF\****REMOVED***{9***REMOVED***$'***REMOVED***

    def get_db_prep_lookup(self, value, connection***REMOVED***:
        if len(value***REMOVED*** != 2:
            raise ValueError('relate must be passed a two-tuple'***REMOVED***
        # Check the pattern argument
        backend_op = connection.ops.gis_operators[self.lookup_name***REMOVED***
        if hasattr(backend_op, 'check_relate_argument'***REMOVED***:
            backend_op.check_relate_argument(value[1***REMOVED******REMOVED***
        else:
            pattern = value[1***REMOVED***
            if not isinstance(pattern, six.string_types***REMOVED*** or not self.pattern_regex.match(pattern***REMOVED***:
                raise ValueError('Invalid intersection matrix pattern "%s".' % pattern***REMOVED***
        return super(RelateLookup, self***REMOVED***.get_db_prep_lookup(value, connection***REMOVED***
gis_lookups['relate'***REMOVED*** = RelateLookup


class TouchesLookup(GISLookup***REMOVED***:
    lookup_name = 'touches'
gis_lookups['touches'***REMOVED*** = TouchesLookup


class WithinLookup(GISLookup***REMOVED***:
    lookup_name = 'within'
gis_lookups['within'***REMOVED*** = WithinLookup


class DistanceLookupBase(GISLookup***REMOVED***:
    distance = True
    sql_template = '%(func***REMOVED***s(%(lhs***REMOVED***s, %(rhs***REMOVED***s***REMOVED*** %(op***REMOVED***s %(value***REMOVED***s'

    def process_rhs(self, compiler, connection***REMOVED***:
        if not isinstance(self.rhs, (tuple, list***REMOVED******REMOVED*** or not 2 <= len(self.rhs***REMOVED*** <= 4:
            raise ValueError("2, 3, or 4-element tuple required for '%s' lookup." % self.lookup_name***REMOVED***
        elif len(self.rhs***REMOVED*** == 4 and not self.rhs[3***REMOVED*** == 'spheroid':
            raise ValueError("For 4-element tuples the last argument must be the 'speroid' directive."***REMOVED***

        # Check if the second parameter is a band index.
        if len(self.rhs***REMOVED*** > 2 and not self.rhs[2***REMOVED*** == 'spheroid':
            self.process_band_indices(***REMOVED***

        params = [connection.ops.Adapter(self.rhs[0***REMOVED******REMOVED******REMOVED***

        # Getting the distance parameter in the units of the field.
        dist_param = self.rhs[1***REMOVED***
        if hasattr(dist_param, 'resolve_expression'***REMOVED***:
            dist_param = dist_param.resolve_expression(compiler.query***REMOVED***
            sql, expr_params = compiler.compile(dist_param***REMOVED***
            self.template_params['value'***REMOVED*** = sql
            params.extend(expr_params***REMOVED***
        else:
            params += connection.ops.get_distance(
                self.lhs.output_field, (dist_param,***REMOVED*** + self.rhs[2:***REMOVED***,
                self.lookup_name, handle_spheroid=False
            ***REMOVED***
        rhs = connection.ops.get_geom_placeholder(self.lhs.output_field, params[0***REMOVED***, compiler***REMOVED***
        return (rhs, params***REMOVED***


class DWithinLookup(DistanceLookupBase***REMOVED***:
    lookup_name = 'dwithin'
    sql_template = '%(func***REMOVED***s(%(lhs***REMOVED***s, %(rhs***REMOVED***s, %%s***REMOVED***'
gis_lookups['dwithin'***REMOVED*** = DWithinLookup


class DistanceGTLookup(DistanceLookupBase***REMOVED***:
    lookup_name = 'distance_gt'
gis_lookups['distance_gt'***REMOVED*** = DistanceGTLookup


class DistanceGTELookup(DistanceLookupBase***REMOVED***:
    lookup_name = 'distance_gte'
gis_lookups['distance_gte'***REMOVED*** = DistanceGTELookup


class DistanceLTLookup(DistanceLookupBase***REMOVED***:
    lookup_name = 'distance_lt'
gis_lookups['distance_lt'***REMOVED*** = DistanceLTLookup


class DistanceLTELookup(DistanceLookupBase***REMOVED***:
    lookup_name = 'distance_lte'
gis_lookups['distance_lte'***REMOVED*** = DistanceLTELookup
