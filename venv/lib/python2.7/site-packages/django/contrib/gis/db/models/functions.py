from decimal import Decimal

from django.contrib.gis.db.models.fields import GeometryField
from django.contrib.gis.db.models.sql import AreaField
from django.contrib.gis.measure import (
    Area as AreaMeasure, Distance as DistanceMeasure,
***REMOVED***
from django.core.exceptions import FieldError
from django.db.models import BooleanField, FloatField, IntegerField, TextField
from django.db.models.expressions import Func, Value
from django.utils import six

NUMERIC_TYPES = six.integer_types + (float, Decimal***REMOVED***


class GeoFunc(Func***REMOVED***:
    function = None
    output_field_class = None
    geom_param_pos = 0

    def __init__(self, *expressions, **extra***REMOVED***:
        if 'output_field' not in extra and self.output_field_class:
            extra['output_field'***REMOVED*** = self.output_field_class(***REMOVED***
        super(GeoFunc, self***REMOVED***.__init__(*expressions, **extra***REMOVED***

    @property
    def name(self***REMOVED***:
        return self.__class__.__name__

    @property
    def srid(self***REMOVED***:
        expr = self.source_expressions[self.geom_param_pos***REMOVED***
        if hasattr(expr, 'srid'***REMOVED***:
            return expr.srid
        ***REMOVED***
            return expr.field.srid
        except (AttributeError, FieldError***REMOVED***:
            return None

    def as_sql(self, compiler, connection***REMOVED***:
        if self.function is None:
            self.function = connection.ops.spatial_function_name(self.name***REMOVED***
        return super(GeoFunc, self***REMOVED***.as_sql(compiler, connection***REMOVED***

    def resolve_expression(self, *args, **kwargs***REMOVED***:
        res = super(GeoFunc, self***REMOVED***.resolve_expression(*args, **kwargs***REMOVED***
        base_srid = res.srid
        if not base_srid:
            raise TypeError("Geometry functions can only operate on geometric content."***REMOVED***

        for pos, expr in enumerate(res.source_expressions[1:***REMOVED***, start=1***REMOVED***:
            if isinstance(expr, GeomValue***REMOVED*** and expr.srid != base_srid:
                # Automatic SRID conversion so objects are comparable
                res.source_expressions[pos***REMOVED*** = Transform(expr, base_srid***REMOVED***.resolve_expression(*args, **kwargs***REMOVED***
        return res

    def _handle_param(self, value, param_name='', check_types=None***REMOVED***:
        if not hasattr(value, 'resolve_expression'***REMOVED***:
            if check_types and not isinstance(value, check_types***REMOVED***:
                raise TypeError(
                    "The %s parameter has the wrong type: should be %s." % (
                        param_name, str(check_types***REMOVED******REMOVED***
                ***REMOVED***
        return value


class GeomValue(Value***REMOVED***:
    geography = False

    @property
    def srid(self***REMOVED***:
        return self.value.srid

    def as_sql(self, compiler, connection***REMOVED***:
        return '%s(%%s, %s***REMOVED***' % (connection.ops.from_text, self.srid***REMOVED***, [connection.ops.Adapter(self.value***REMOVED******REMOVED***

    def as_mysql(self, compiler, connection***REMOVED***:
        return '%s(%%s***REMOVED***' % (connection.ops.from_text***REMOVED***, [connection.ops.Adapter(self.value***REMOVED******REMOVED***

    def as_postgresql(self, compiler, connection***REMOVED***:
        if self.geography:
            self.value = connection.ops.Adapter(self.value, geography=self.geography***REMOVED***
        else:
            self.value = connection.ops.Adapter(self.value***REMOVED***
        return super(GeomValue, self***REMOVED***.as_sql(compiler, connection***REMOVED***


class GeoFuncWithGeoParam(GeoFunc***REMOVED***:
    def __init__(self, expression, geom, *expressions, **extra***REMOVED***:
        if not hasattr(geom, 'srid'***REMOVED*** or not geom.srid:
            raise ValueError("Please provide a geometry attribute with a defined SRID."***REMOVED***
        super(GeoFuncWithGeoParam, self***REMOVED***.__init__(expression, GeomValue(geom***REMOVED***, *expressions, **extra***REMOVED***


class SQLiteDecimalToFloatMixin(object***REMOVED***:
    ***REMOVED***
    By default, Decimal values are converted to str by the SQLite backend, which
    is not acceptable by the GIS functions expecting numeric values.
    ***REMOVED***
    def as_sqlite(self, compiler, connection***REMOVED***:
        for expr in self.get_source_expressions(***REMOVED***:
            if hasattr(expr, 'value'***REMOVED*** and isinstance(expr.value, Decimal***REMOVED***:
                expr.value = float(expr.value***REMOVED***
        return super(SQLiteDecimalToFloatMixin, self***REMOVED***.as_sql(compiler, connection***REMOVED***


class OracleToleranceMixin(object***REMOVED***:
    tolerance = 0.05

    def as_oracle(self, compiler, connection***REMOVED***:
        tol = self.extra.get('tolerance', self.tolerance***REMOVED***
        self.template = "%%(function***REMOVED***s(%%(expressions***REMOVED***s, %s***REMOVED***" % tol
        return super(OracleToleranceMixin, self***REMOVED***.as_sql(compiler, connection***REMOVED***


class Area(OracleToleranceMixin, GeoFunc***REMOVED***:
    output_field_class = AreaField
    arity = 1

    def as_sql(self, compiler, connection***REMOVED***:
        if connection.ops.geography:
            self.output_field.area_att = 'sq_m'
        else:
            # Getting the area units of the geographic field.
            source_fields = self.get_source_fields(***REMOVED***
            if len(source_fields***REMOVED***:
                source_field = source_fields[0***REMOVED***
                if source_field.geodetic(connection***REMOVED***:
                    # TODO: Do we want to support raw number areas for geodetic fields?
                    raise NotImplementedError('Area on geodetic coordinate systems not supported.'***REMOVED***
                units_name = source_field.units_name(connection***REMOVED***
                if units_name:
                    self.output_field.area_att = AreaMeasure.unit_attname(units_name***REMOVED***
        return super(Area, self***REMOVED***.as_sql(compiler, connection***REMOVED***

    def as_oracle(self, compiler, connection***REMOVED***:
        self.output_field = AreaField('sq_m'***REMOVED***  # Oracle returns area in units of meters.
        return super(Area, self***REMOVED***.as_oracle(compiler, connection***REMOVED***


class AsGeoJSON(GeoFunc***REMOVED***:
    output_field_class = TextField

    def __init__(self, expression, bbox=False, crs=False, precision=8, **extra***REMOVED***:
        expressions = [expression***REMOVED***
        if precision is not None:
            expressions.append(self._handle_param(precision, 'precision', six.integer_types***REMOVED******REMOVED***
        options = 0
        if crs and bbox:
            options = 3
        elif bbox:
            options = 1
        elif crs:
            options = 2
        if options:
            expressions.append(options***REMOVED***
        super(AsGeoJSON, self***REMOVED***.__init__(*expressions, **extra***REMOVED***


class AsGML(GeoFunc***REMOVED***:
    geom_param_pos = 1
    output_field_class = TextField

    def __init__(self, expression, version=2, precision=8, **extra***REMOVED***:
        expressions = [version, expression***REMOVED***
        if precision is not None:
            expressions.append(self._handle_param(precision, 'precision', six.integer_types***REMOVED******REMOVED***
        super(AsGML, self***REMOVED***.__init__(*expressions, **extra***REMOVED***


class AsKML(AsGML***REMOVED***:
    def as_sqlite(self, compiler, connection***REMOVED***:
        # No version parameter
        self.source_expressions.pop(0***REMOVED***
        return super(AsKML, self***REMOVED***.as_sql(compiler, connection***REMOVED***


class AsSVG(GeoFunc***REMOVED***:
    output_field_class = TextField

    def __init__(self, expression, relative=False, precision=8, **extra***REMOVED***:
        relative = relative if hasattr(relative, 'resolve_expression'***REMOVED*** else int(relative***REMOVED***
        expressions = [
            expression,
            relative,
            self._handle_param(precision, 'precision', six.integer_types***REMOVED***,
        ***REMOVED***
        super(AsSVG, self***REMOVED***.__init__(*expressions, **extra***REMOVED***


class BoundingCircle(GeoFunc***REMOVED***:
    def __init__(self, expression, num_seg=48, **extra***REMOVED***:
        super(BoundingCircle, self***REMOVED***.__init__(*[expression, num_seg***REMOVED***, **extra***REMOVED***


class Centroid(OracleToleranceMixin, GeoFunc***REMOVED***:
    arity = 1


class Difference(OracleToleranceMixin, GeoFuncWithGeoParam***REMOVED***:
    arity = 2


class DistanceResultMixin(object***REMOVED***:
    def source_is_geography(self***REMOVED***:
        return self.get_source_fields(***REMOVED***[0***REMOVED***.geography and self.srid == 4326

    def convert_value(self, value, expression, connection, context***REMOVED***:
        if value is None:
            return None
        geo_field = GeometryField(srid=self.srid***REMOVED***  # Fake field to get SRID info
        if geo_field.geodetic(connection***REMOVED***:
            dist_att = 'm'
        else:
            units = geo_field.units_name(connection***REMOVED***
            if units:
                dist_att = DistanceMeasure.unit_attname(units***REMOVED***
            else:
                dist_att = None
        if dist_att:
            return DistanceMeasure(**{dist_att: value***REMOVED******REMOVED***
        return value


class Distance(DistanceResultMixin, OracleToleranceMixin, GeoFuncWithGeoParam***REMOVED***:
    output_field_class = FloatField
    spheroid = None

    def __init__(self, expr1, expr2, spheroid=None, **extra***REMOVED***:
        expressions = [expr1, expr2***REMOVED***
        if spheroid is not None:
            self.spheroid = spheroid
            expressions += (self._handle_param(spheroid, 'spheroid', bool***REMOVED***,***REMOVED***
        super(Distance, self***REMOVED***.__init__(*expressions, **extra***REMOVED***

    def as_postgresql(self, compiler, connection***REMOVED***:
        geo_field = GeometryField(srid=self.srid***REMOVED***  # Fake field to get SRID info
        if self.source_is_geography(***REMOVED***:
            # Set parameters as geography if base field is geography
            for pos, expr in enumerate(
                    self.source_expressions[self.geom_param_pos + 1:***REMOVED***, start=self.geom_param_pos + 1***REMOVED***:
                if isinstance(expr, GeomValue***REMOVED***:
                    expr.geography = True
        elif geo_field.geodetic(connection***REMOVED***:
            # Geometry fields with geodetic (lon/lat***REMOVED*** coordinates need special distance functions
            if self.spheroid:
                self.function = 'ST_Distance_Spheroid'  # More accurate, resource intensive
                # Replace boolean param by the real spheroid of the base field
                self.source_expressions[2***REMOVED*** = Value(geo_field._spheroid***REMOVED***
            else:
                self.function = 'ST_Distance_Sphere'
        return super(Distance, self***REMOVED***.as_sql(compiler, connection***REMOVED***

    def as_oracle(self, compiler, connection***REMOVED***:
        if self.spheroid:
            self.source_expressions.pop(2***REMOVED***
        return super(Distance, self***REMOVED***.as_oracle(compiler, connection***REMOVED***


class Envelope(GeoFunc***REMOVED***:
    arity = 1


class ForceRHR(GeoFunc***REMOVED***:
    arity = 1


class GeoHash(GeoFunc***REMOVED***:
    output_field_class = TextField

    def __init__(self, expression, precision=None, **extra***REMOVED***:
        expressions = [expression***REMOVED***
        if precision is not None:
            expressions.append(self._handle_param(precision, 'precision', six.integer_types***REMOVED******REMOVED***
        super(GeoHash, self***REMOVED***.__init__(*expressions, **extra***REMOVED***


class Intersection(OracleToleranceMixin, GeoFuncWithGeoParam***REMOVED***:
    arity = 2


class IsValid(GeoFunc***REMOVED***:
    output_field_class = BooleanField


class Length(DistanceResultMixin, OracleToleranceMixin, GeoFunc***REMOVED***:
    output_field_class = FloatField

    def __init__(self, expr1, spheroid=True, **extra***REMOVED***:
        self.spheroid = spheroid
        super(Length, self***REMOVED***.__init__(expr1, **extra***REMOVED***

    def as_sql(self, compiler, connection***REMOVED***:
        geo_field = GeometryField(srid=self.srid***REMOVED***  # Fake field to get SRID info
        if geo_field.geodetic(connection***REMOVED*** and not connection.features.supports_length_geodetic:
            raise NotImplementedError("This backend doesn't support Length on geodetic fields"***REMOVED***
        return super(Length, self***REMOVED***.as_sql(compiler, connection***REMOVED***

    def as_postgresql(self, compiler, connection***REMOVED***:
        geo_field = GeometryField(srid=self.srid***REMOVED***  # Fake field to get SRID info
        if self.source_is_geography(***REMOVED***:
            self.source_expressions.append(Value(self.spheroid***REMOVED******REMOVED***
        elif geo_field.geodetic(connection***REMOVED***:
            # Geometry fields with geodetic (lon/lat***REMOVED*** coordinates need length_spheroid
            self.function = 'ST_Length_Spheroid'
            self.source_expressions.append(Value(geo_field._spheroid***REMOVED******REMOVED***
        else:
            dim = min(f.dim for f in self.get_source_fields(***REMOVED*** if f***REMOVED***
            if dim > 2:
                self.function = connection.ops.length3d
        return super(Length, self***REMOVED***.as_sql(compiler, connection***REMOVED***

    def as_sqlite(self, compiler, connection***REMOVED***:
        geo_field = GeometryField(srid=self.srid***REMOVED***
        if geo_field.geodetic(connection***REMOVED***:
            if self.spheroid:
                self.function = 'GeodesicLength'
            else:
                self.function = 'GreatCircleLength'
        return super(Length, self***REMOVED***.as_sql(compiler, connection***REMOVED***


class MakeValid(GeoFunc***REMOVED***:
    pass


class MemSize(GeoFunc***REMOVED***:
    output_field_class = IntegerField
    arity = 1


class NumGeometries(GeoFunc***REMOVED***:
    output_field_class = IntegerField
    arity = 1


class NumPoints(GeoFunc***REMOVED***:
    output_field_class = IntegerField
    arity = 1

    def as_sqlite(self, compiler, connection***REMOVED***:
        if self.source_expressions[self.geom_param_pos***REMOVED***.output_field.geom_type != 'LINESTRING':
            raise TypeError("SpatiaLite NumPoints can only operate on LineString content"***REMOVED***
        return super(NumPoints, self***REMOVED***.as_sql(compiler, connection***REMOVED***


class Perimeter(DistanceResultMixin, OracleToleranceMixin, GeoFunc***REMOVED***:
    output_field_class = FloatField
    arity = 1

    def as_postgresql(self, compiler, connection***REMOVED***:
        geo_field = GeometryField(srid=self.srid***REMOVED***  # Fake field to get SRID info
        if geo_field.geodetic(connection***REMOVED*** and not self.source_is_geography(***REMOVED***:
            raise NotImplementedError("ST_Perimeter cannot use a non-projected non-geography field."***REMOVED***
        dim = min(f.dim for f in self.get_source_fields(***REMOVED******REMOVED***
        if dim > 2:
            self.function = connection.ops.perimeter3d
        return super(Perimeter, self***REMOVED***.as_sql(compiler, connection***REMOVED***

    def as_sqlite(self, compiler, connection***REMOVED***:
        geo_field = GeometryField(srid=self.srid***REMOVED***  # Fake field to get SRID info
        if geo_field.geodetic(connection***REMOVED***:
            raise NotImplementedError("Perimeter cannot use a non-projected field."***REMOVED***
        return super(Perimeter, self***REMOVED***.as_sql(compiler, connection***REMOVED***


class PointOnSurface(OracleToleranceMixin, GeoFunc***REMOVED***:
    arity = 1


class Reverse(GeoFunc***REMOVED***:
    arity = 1


class Scale(SQLiteDecimalToFloatMixin, GeoFunc***REMOVED***:
    def __init__(self, expression, x, y, z=0.0, **extra***REMOVED***:
        expressions = [
            expression,
            self._handle_param(x, 'x', NUMERIC_TYPES***REMOVED***,
            self._handle_param(y, 'y', NUMERIC_TYPES***REMOVED***,
        ***REMOVED***
        if z != 0.0:
            expressions.append(self._handle_param(z, 'z', NUMERIC_TYPES***REMOVED******REMOVED***
        super(Scale, self***REMOVED***.__init__(*expressions, **extra***REMOVED***


class SnapToGrid(SQLiteDecimalToFloatMixin, GeoFunc***REMOVED***:
    def __init__(self, expression, *args, **extra***REMOVED***:
        nargs = len(args***REMOVED***
        expressions = [expression***REMOVED***
        if nargs in (1, 2***REMOVED***:
            expressions.extend(
                [self._handle_param(arg, '', NUMERIC_TYPES***REMOVED*** for arg in args***REMOVED***
            ***REMOVED***
        elif nargs == 4:
            # Reverse origin and size param ordering
            expressions.extend(
                [self._handle_param(arg, '', NUMERIC_TYPES***REMOVED*** for arg in args[2:***REMOVED******REMOVED***
            ***REMOVED***
            expressions.extend(
                [self._handle_param(arg, '', NUMERIC_TYPES***REMOVED*** for arg in args[0:2***REMOVED******REMOVED***
            ***REMOVED***
        else:
            raise ValueError('Must provide 1, 2, or 4 arguments to `SnapToGrid`.'***REMOVED***
        super(SnapToGrid, self***REMOVED***.__init__(*expressions, **extra***REMOVED***


class SymDifference(OracleToleranceMixin, GeoFuncWithGeoParam***REMOVED***:
    arity = 2


class Transform(GeoFunc***REMOVED***:
    def __init__(self, expression, srid, **extra***REMOVED***:
        expressions = [
            expression,
            self._handle_param(srid, 'srid', six.integer_types***REMOVED***,
        ***REMOVED***
        super(Transform, self***REMOVED***.__init__(*expressions, **extra***REMOVED***

    @property
    def srid(self***REMOVED***:
        # Make srid the resulting srid of the transformation
        return self.source_expressions[self.geom_param_pos + 1***REMOVED***.value

    def convert_value(self, value, expression, connection, context***REMOVED***:
        value = super(Transform, self***REMOVED***.convert_value(value, expression, connection, context***REMOVED***
        if not connection.ops.postgis and not value.srid:
            # Some backends do not set the srid on the returning geometry
            value.srid = self.srid
        return value


class Translate(Scale***REMOVED***:
    def as_sqlite(self, compiler, connection***REMOVED***:
        func_name = connection.ops.spatial_function_name(self.name***REMOVED***
        if func_name == 'ST_Translate' and len(self.source_expressions***REMOVED*** < 4:
            # Always provide the z parameter for ST_Translate (Spatialite >= 3.1***REMOVED***
            self.source_expressions.append(Value(0***REMOVED******REMOVED***
        elif func_name == 'ShiftCoords' and len(self.source_expressions***REMOVED*** > 3:
            raise ValueError("This version of Spatialite doesn't support 3D"***REMOVED***
        return super(Translate, self***REMOVED***.as_sqlite(compiler, connection***REMOVED***


class Union(OracleToleranceMixin, GeoFuncWithGeoParam***REMOVED***:
    arity = 2
