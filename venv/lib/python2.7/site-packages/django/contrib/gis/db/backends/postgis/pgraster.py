import binascii
import struct

from django.forms import ValidationError

from .const import (
    GDAL_TO_POSTGIS, GDAL_TO_STRUCT, POSTGIS_HEADER_STRUCTURE, POSTGIS_TO_GDAL,
    STRUCT_SIZE,
***REMOVED***


def pack(structure, data***REMOVED***:
    ***REMOVED***
    Pack data into hex string with little endian format.
    ***REMOVED***
    return binascii.hexlify(struct.pack('<' + structure, *data***REMOVED******REMOVED***.upper(***REMOVED***


def unpack(structure, data***REMOVED***:
    ***REMOVED***
    Unpack little endian hexlified binary string into a list.
    ***REMOVED***
    return struct.unpack('<' + structure, binascii.unhexlify(data***REMOVED******REMOVED***


def chunk(data, index***REMOVED***:
    ***REMOVED***
    Split a string into two parts at the input index.
    ***REMOVED***
    return data[:index***REMOVED***, data[index:***REMOVED***


def get_pgraster_srid(data***REMOVED***:
    ***REMOVED***
    Extract the SRID from a PostGIS raster string.
    ***REMOVED***
    if data is None:
        return
    # The positional arguments here extract the hex-encoded srid from the
    # header of the PostGIS raster string. This can be understood through
    # the POSTGIS_HEADER_STRUCTURE constant definition in the const module.
    return unpack('i', data[106:114***REMOVED******REMOVED***[0***REMOVED***


def from_pgraster(data***REMOVED***:
    ***REMOVED***
    Convert a PostGIS HEX String into a dictionary.
    ***REMOVED***
    if data is None:
        return

    # Split raster header from data
    header, data = chunk(data, 122***REMOVED***
    header = unpack(POSTGIS_HEADER_STRUCTURE, header***REMOVED***

    # Parse band data
    bands = [***REMOVED***
    pixeltypes = [***REMOVED***
    while data:
        # Get pixel type for this band
        pixeltype, data = chunk(data, 2***REMOVED***
        pixeltype = unpack('B', pixeltype***REMOVED***[0***REMOVED***

        # Subtract nodata byte from band nodata value if it exists
        has_nodata = pixeltype >= 64
        if has_nodata:
            pixeltype -= 64

        # Convert datatype from PostGIS to GDAL & get pack type and size
        pixeltype = POSTGIS_TO_GDAL[pixeltype***REMOVED***
        pack_type = GDAL_TO_STRUCT[pixeltype***REMOVED***
        pack_size = 2 * STRUCT_SIZE[pack_type***REMOVED***

        # Parse band nodata value. The nodata value is part of the
        # PGRaster string even if the nodata flag is True, so it always
        # has to be chunked off the data string.
        nodata, data = chunk(data, pack_size***REMOVED***
        nodata = unpack(pack_type, nodata***REMOVED***[0***REMOVED***

        # Chunk and unpack band data (pack size times nr of pixels***REMOVED***
        band, data = chunk(data, pack_size * header[10***REMOVED*** * header[11***REMOVED******REMOVED***
        band_result = {'data': binascii.unhexlify(band***REMOVED******REMOVED***

        # If the nodata flag is True, set the nodata value.
        if has_nodata:
            band_result['nodata_value'***REMOVED*** = nodata

        # Append band data to band list
        bands.append(band_result***REMOVED***

        # Store pixeltype of this band in pixeltypes array
        pixeltypes.append(pixeltype***REMOVED***

    # Check that all bands have the same pixeltype.
    # This is required by GDAL. PostGIS rasters could have different pixeltypes
    # for bands of the same raster.
    if len(set(pixeltypes***REMOVED******REMOVED*** != 1:
        raise ValidationError("Band pixeltypes are not all equal."***REMOVED***

    return {
        'srid': int(header[9***REMOVED******REMOVED***,
        'width': header[10***REMOVED***, 'height': header[11***REMOVED***,
        'datatype': pixeltypes[0***REMOVED***,
        'origin': (header[5***REMOVED***, header[6***REMOVED******REMOVED***,
        'scale': (header[3***REMOVED***, header[4***REMOVED******REMOVED***,
        'skew': (header[7***REMOVED***, header[8***REMOVED******REMOVED***,
        'bands': bands,
***REMOVED***


def to_pgraster(rast***REMOVED***:
    ***REMOVED***
    Convert a GDALRaster into PostGIS Raster format.
    ***REMOVED***
    # Return if the raster is null
    if rast is None or rast == '':
        return

    # Prepare the raster header data as a tuple. The first two numbers are
    # the endianness and the PostGIS Raster Version, both are fixed by
    # PostGIS at the moment.
    rasterheader = (
        1, 0, len(rast.bands***REMOVED***, rast.scale.x, rast.scale.y,
        rast.origin.x, rast.origin.y, rast.skew.x, rast.skew.y,
        rast.srs.srid, rast.width, rast.height,
    ***REMOVED***

    # Hexlify raster header
    result = pack(POSTGIS_HEADER_STRUCTURE, rasterheader***REMOVED***

    for band in rast.bands:
        # The PostGIS raster band header has exactly two elements, a 8BUI byte
        # and the nodata value.
        #
        # The 8BUI stores both the PostGIS pixel data type and a nodata flag.
        # It is composed as the datatype integer plus 64 as a flag for existing
        # nodata values:
        # 8BUI_VALUE = PG_PIXEL_TYPE (0-11***REMOVED*** + FLAG (0 or 64***REMOVED***
        #
        # For example, if the byte value is 71, then the datatype is
        # 71-64 = 7 (32BSI***REMOVED*** and the nodata value is True.
        structure = 'B' + GDAL_TO_STRUCT[band.datatype(***REMOVED******REMOVED***

        # Get band pixel type in PostGIS notation
        pixeltype = GDAL_TO_POSTGIS[band.datatype(***REMOVED******REMOVED***

        # Set the nodata flag
        if band.nodata_value is not None:
            pixeltype += 64

        # Pack band header
        bandheader = pack(structure, (pixeltype, band.nodata_value or 0***REMOVED******REMOVED***

        # Hexlify band data
        band_data_hex = binascii.hexlify(band.data(as_memoryview=True***REMOVED******REMOVED***.upper(***REMOVED***

        # Add packed header and band data to result
        result += bandheader + band_data_hex

    # Cast raster to string before passing it to the DB
    return result.decode(***REMOVED***
