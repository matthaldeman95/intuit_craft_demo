***REMOVED***
 The GDAL/OGR library uses an Envelope structure to hold the bounding
 box information for a geometry.  The envelope (bounding box***REMOVED*** contains
 two pairs of coordinates, one for the lower left coordinate and one
 for the upper right coordinate:

                           +----------o Upper right; (max_x, max_y***REMOVED***
                           |          |
                           |          |
                           |          |
 Lower left (min_x, min_y***REMOVED*** o----------+
***REMOVED***
from ctypes import Structure, c_double

from django.contrib.gis.gdal.error import GDALException


# The OGR definition of an Envelope is a C structure containing four doubles.
#  See the 'ogr_core.h' source file for more information:
#   http://www.gdal.org/ogr__core_8h_source.html
class OGREnvelope(Structure***REMOVED***:
    "Represents the OGREnvelope C Structure."
    _fields_ = [("MinX", c_double***REMOVED***,
                ("MaxX", c_double***REMOVED***,
                ("MinY", c_double***REMOVED***,
                ("MaxY", c_double***REMOVED***,
                ***REMOVED***


class Envelope(object***REMOVED***:
    ***REMOVED***
    The Envelope object is a C structure that contains the minimum and
    maximum X, Y coordinates for a rectangle bounding box.  The naming
    of the variables is compatible with the OGR Envelope structure.
    ***REMOVED***

    def __init__(self, *args***REMOVED***:
        ***REMOVED***
        The initialization function may take an OGREnvelope structure, 4-element
        tuple or list, or 4 individual arguments.
        ***REMOVED***

        if len(args***REMOVED*** == 1:
            if isinstance(args[0***REMOVED***, OGREnvelope***REMOVED***:
                # OGREnvelope (a ctypes Structure***REMOVED*** was passed in.
                self._envelope = args[0***REMOVED***
            elif isinstance(args[0***REMOVED***, (tuple, list***REMOVED******REMOVED***:
                # A tuple was passed in.
                if len(args[0***REMOVED******REMOVED*** != 4:
                    raise GDALException('Incorrect number of tuple elements (%d***REMOVED***.' % len(args[0***REMOVED******REMOVED******REMOVED***
                else:
                    self._from_sequence(args[0***REMOVED******REMOVED***
            else:
                raise TypeError('Incorrect type of argument: %s' % str(type(args[0***REMOVED******REMOVED******REMOVED******REMOVED***
        elif len(args***REMOVED*** == 4:
            # Individual parameters passed in.
            #  Thanks to ww for the help
            self._from_sequence([float(a***REMOVED*** for a in args***REMOVED******REMOVED***
        else:
            raise GDALException('Incorrect number (%d***REMOVED*** of arguments.' % len(args***REMOVED******REMOVED***

        # Checking the x,y coordinates
        if self.min_x > self.max_x:
            raise GDALException('Envelope minimum X > maximum X.'***REMOVED***
        if self.min_y > self.max_y:
            raise GDALException('Envelope minimum Y > maximum Y.'***REMOVED***

    def __eq__(self, other***REMOVED***:
        ***REMOVED***
        Returns True if the envelopes are equivalent; can compare against
        other Envelopes and 4-tuples.
        ***REMOVED***
        if isinstance(other, Envelope***REMOVED***:
            return (self.min_x == other.min_x***REMOVED*** and (self.min_y == other.min_y***REMOVED*** and \
                   (self.max_x == other.max_x***REMOVED*** and (self.max_y == other.max_y***REMOVED***
        elif isinstance(other, tuple***REMOVED*** and len(other***REMOVED*** == 4:
            return (self.min_x == other[0***REMOVED******REMOVED*** and (self.min_y == other[1***REMOVED******REMOVED*** and \
                   (self.max_x == other[2***REMOVED******REMOVED*** and (self.max_y == other[3***REMOVED******REMOVED***
        else:
            raise GDALException('Equivalence testing only works with other Envelopes.'***REMOVED***

    def __str__(self***REMOVED***:
        "Returns a string representation of the tuple."
        return str(self.tuple***REMOVED***

    def _from_sequence(self, seq***REMOVED***:
        "Initializes the C OGR Envelope structure from the given sequence."
        self._envelope = OGREnvelope(***REMOVED***
        self._envelope.MinX = seq[0***REMOVED***
        self._envelope.MinY = seq[1***REMOVED***
        self._envelope.MaxX = seq[2***REMOVED***
        self._envelope.MaxY = seq[3***REMOVED***

    def expand_to_include(self, *args***REMOVED***:
        ***REMOVED***
        Modifies the envelope to expand to include the boundaries of
        the passed-in 2-tuple (a point***REMOVED***, 4-tuple (an extent***REMOVED*** or
        envelope.
        ***REMOVED***
        # We provide a number of different signatures for this method,
        # and the logic here is all about converting them into a
        # 4-tuple single parameter which does the actual work of
        # expanding the envelope.
        if len(args***REMOVED*** == 1:
            if isinstance(args[0***REMOVED***, Envelope***REMOVED***:
                return self.expand_to_include(args[0***REMOVED***.tuple***REMOVED***
            elif hasattr(args[0***REMOVED***, 'x'***REMOVED*** and hasattr(args[0***REMOVED***, 'y'***REMOVED***:
                return self.expand_to_include(args[0***REMOVED***.x, args[0***REMOVED***.y, args[0***REMOVED***.x, args[0***REMOVED***.y***REMOVED***
            elif isinstance(args[0***REMOVED***, (tuple, list***REMOVED******REMOVED***:
                # A tuple was passed in.
                if len(args[0***REMOVED******REMOVED*** == 2:
                    return self.expand_to_include((args[0***REMOVED***[0***REMOVED***, args[0***REMOVED***[1***REMOVED***, args[0***REMOVED***[0***REMOVED***, args[0***REMOVED***[1***REMOVED******REMOVED******REMOVED***
                elif len(args[0***REMOVED******REMOVED*** == 4:
                    (minx, miny, maxx, maxy***REMOVED*** = args[0***REMOVED***
                    if minx < self._envelope.MinX:
                        self._envelope.MinX = minx
                    if miny < self._envelope.MinY:
                        self._envelope.MinY = miny
                    if maxx > self._envelope.MaxX:
                        self._envelope.MaxX = maxx
                    if maxy > self._envelope.MaxY:
                        self._envelope.MaxY = maxy
                else:
                    raise GDALException('Incorrect number of tuple elements (%d***REMOVED***.' % len(args[0***REMOVED******REMOVED******REMOVED***
            else:
                raise TypeError('Incorrect type of argument: %s' % str(type(args[0***REMOVED******REMOVED******REMOVED******REMOVED***
        elif len(args***REMOVED*** == 2:
            # An x and an y parameter were passed in
                return self.expand_to_include((args[0***REMOVED***, args[1***REMOVED***, args[0***REMOVED***, args[1***REMOVED******REMOVED******REMOVED***
        elif len(args***REMOVED*** == 4:
            # Individual parameters passed in.
            return self.expand_to_include(args***REMOVED***
        else:
            raise GDALException('Incorrect number (%d***REMOVED*** of arguments.' % len(args[0***REMOVED******REMOVED******REMOVED***

    @property
    def min_x(self***REMOVED***:
        "Returns the value of the minimum X coordinate."
        return self._envelope.MinX

    @property
    def min_y(self***REMOVED***:
        "Returns the value of the minimum Y coordinate."
        return self._envelope.MinY

    @property
    def max_x(self***REMOVED***:
        "Returns the value of the maximum X coordinate."
        return self._envelope.MaxX

    @property
    def max_y(self***REMOVED***:
        "Returns the value of the maximum Y coordinate."
        return self._envelope.MaxY

    @property
    def ur(self***REMOVED***:
        "Returns the upper-right coordinate."
        return (self.max_x, self.max_y***REMOVED***

    @property
    def ll(self***REMOVED***:
        "Returns the lower-left coordinate."
        return (self.min_x, self.min_y***REMOVED***

    @property
    def tuple(self***REMOVED***:
        "Returns a tuple representing the envelope."
        return (self.min_x, self.min_y, self.max_x, self.max_y***REMOVED***

    @property
    def wkt(self***REMOVED***:
        "Returns WKT representing a Polygon for this envelope."
        # TODO: Fix significant figures.
        return 'POLYGON((%s %s,%s %s,%s %s,%s %s,%s %s***REMOVED******REMOVED***' % \
               (self.min_x, self.min_y, self.min_x, self.max_y,
                self.max_x, self.max_y, self.max_x, self.min_y,
                self.min_x, self.min_y***REMOVED***
