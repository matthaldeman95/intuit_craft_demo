from ctypes import byref, c_double, c_int, c_void_p

from django.contrib.gis.gdal.base import GDALBase
from django.contrib.gis.gdal.error import GDALException
from django.contrib.gis.gdal.prototypes import raster as capi
from django.contrib.gis.shortcuts import numpy
from django.utils import six
from django.utils.encoding import force_text
from django.utils.six.moves import range

from .const import GDAL_INTEGER_TYPES, GDAL_PIXEL_TYPES, GDAL_TO_CTYPES


class GDALBand(GDALBase***REMOVED***:
    ***REMOVED***
    Wraps a GDAL raster band, needs to be obtained from a GDALRaster object.
    ***REMOVED***
    def __init__(self, source, index***REMOVED***:
        self.source = source
        self._ptr = capi.get_ds_raster_band(source._ptr, index***REMOVED***

    def _flush(self***REMOVED***:
        ***REMOVED***
        Call the flush method on the Band's parent raster and force a refresh
        of the statistics attribute when requested the next time.
        ***REMOVED***
        self.source._flush(***REMOVED***
        self._stats_refresh = True

    @property
    def description(self***REMOVED***:
        ***REMOVED***
        Returns the description string of the band.
        ***REMOVED***
        return force_text(capi.get_band_description(self._ptr***REMOVED******REMOVED***

    @property
    def width(self***REMOVED***:
        ***REMOVED***
        Width (X axis***REMOVED*** in pixels of the band.
        ***REMOVED***
        return capi.get_band_xsize(self._ptr***REMOVED***

    @property
    def height(self***REMOVED***:
        ***REMOVED***
        Height (Y axis***REMOVED*** in pixels of the band.
        ***REMOVED***
        return capi.get_band_ysize(self._ptr***REMOVED***

    @property
    def pixel_count(self***REMOVED***:
        ***REMOVED***
        Returns the total number of pixels in this band.
        ***REMOVED***
        return self.width * self.height

    _stats_refresh = False

    def statistics(self, refresh=False, approximate=False***REMOVED***:
        ***REMOVED***
        Compute statistics on the pixel values of this band.

        The return value is a tuple with the following structure:
        (minimum, maximum, mean, standard deviation***REMOVED***.

        If approximate=True, the statistics may be computed based on overviews
        or a subset of image tiles.

        If refresh=True, the statistics will be computed from the data directly,
        and the cache will be updated where applicable.

        For empty bands (where all pixel values are nodata***REMOVED***, all statistics
        values are returned as None.

        For raster formats using Persistent Auxiliary Metadata (PAM***REMOVED*** services,
        the statistics might be cached in an auxiliary file.
        ***REMOVED***
        # Prepare array with arguments for capi function
        smin, smax, smean, sstd = c_double(***REMOVED***, c_double(***REMOVED***, c_double(***REMOVED***, c_double(***REMOVED***
        stats_args = [
            self._ptr, c_int(approximate***REMOVED***, byref(smin***REMOVED***, byref(smax***REMOVED***,
            byref(smean***REMOVED***, byref(sstd***REMOVED***, c_void_p(***REMOVED***, c_void_p(***REMOVED***,
        ***REMOVED***

        if refresh or self._stats_refresh:
            func = capi.compute_band_statistics
        else:
            # Add additional argument to force computation if there is no
            # existing PAM file to take the values from.
            force = True
            stats_args.insert(2, c_int(force***REMOVED******REMOVED***
            func = capi.get_band_statistics

        # Computation of statistics fails for empty bands.
        ***REMOVED***
            func(*stats_args***REMOVED***
            result = smin.value, smax.value, smean.value, sstd.value
        except GDALException:
            result = (None, None, None, None***REMOVED***

        self._stats_refresh = False

        return result

    @property
    def min(self***REMOVED***:
        ***REMOVED***
        Return the minimum pixel value for this band.
        ***REMOVED***
        return self.statistics(***REMOVED***[0***REMOVED***

    @property
    def max(self***REMOVED***:
        ***REMOVED***
        Return the maximum pixel value for this band.
        ***REMOVED***
        return self.statistics(***REMOVED***[1***REMOVED***

    @property
    def mean(self***REMOVED***:
        ***REMOVED***
        Return the mean of all pixel values of this band.
        ***REMOVED***
        return self.statistics(***REMOVED***[2***REMOVED***

    @property
    def std(self***REMOVED***:
        ***REMOVED***
        Return the standard deviation of all pixel values of this band.
        ***REMOVED***
        return self.statistics(***REMOVED***[3***REMOVED***

    @property
    def nodata_value(self***REMOVED***:
        ***REMOVED***
        Returns the nodata value for this band, or None if it isn't set.
        ***REMOVED***
        # Get value and nodata exists flag
        nodata_exists = c_int(***REMOVED***
        value = capi.get_band_nodata_value(self._ptr, nodata_exists***REMOVED***
        if not nodata_exists:
            value = None
        # If the pixeltype is an integer, convert to int
        elif self.datatype(***REMOVED*** in GDAL_INTEGER_TYPES:
            value = int(value***REMOVED***
        return value

    @nodata_value.setter
    def nodata_value(self, value***REMOVED***:
        ***REMOVED***
        Sets the nodata value for this band.
        ***REMOVED***
        if value is None:
            if not capi.delete_band_nodata_value:
                raise ValueError('GDAL >= 2.1 required to delete nodata values.'***REMOVED***
            capi.delete_band_nodata_value(self._ptr***REMOVED***
        elif not isinstance(value, (int, float***REMOVED******REMOVED***:
            raise ValueError('Nodata value must be numeric or None.'***REMOVED***
        else:
            capi.set_band_nodata_value(self._ptr, value***REMOVED***
        self._flush(***REMOVED***

    def datatype(self, as_string=False***REMOVED***:
        ***REMOVED***
        Returns the GDAL Pixel Datatype for this band.
        ***REMOVED***
        dtype = capi.get_band_datatype(self._ptr***REMOVED***
        if as_string:
            dtype = GDAL_PIXEL_TYPES[dtype***REMOVED***
        return dtype

    def data(self, data=None, offset=None, size=None, shape=None, as_memoryview=False***REMOVED***:
        ***REMOVED***
        Reads or writes pixel values for this band. Blocks of data can
        be accessed by specifying the width, height and offset of the
        desired block. The same specification can be used to update
        parts of a raster by providing an array of values.

        Allowed input data types are bytes, memoryview, list, tuple, and array.
        ***REMOVED***
        if not offset:
            offset = (0, 0***REMOVED***

        if not size:
            size = (self.width - offset[0***REMOVED***, self.height - offset[1***REMOVED******REMOVED***

        if not shape:
            shape = size

        if any(x <= 0 for x in size***REMOVED***:
            raise ValueError('Offset too big for this raster.'***REMOVED***

        if size[0***REMOVED*** > self.width or size[1***REMOVED*** > self.height:
            raise ValueError('Size is larger than raster.'***REMOVED***

        # Create ctypes type array generator
        ctypes_array = GDAL_TO_CTYPES[self.datatype(***REMOVED******REMOVED*** * (shape[0***REMOVED*** * shape[1***REMOVED******REMOVED***

        if data is None:
            # Set read mode
            access_flag = 0
            # Prepare empty ctypes array
            data_array = ctypes_array(***REMOVED***
        else:
            # Set write mode
            access_flag = 1

            # Instantiate ctypes array holding the input data
            if isinstance(data, (bytes, six.memoryview***REMOVED******REMOVED*** or (numpy and isinstance(data, numpy.ndarray***REMOVED******REMOVED***:
                data_array = ctypes_array.from_buffer_copy(data***REMOVED***
            else:
                data_array = ctypes_array(*data***REMOVED***

        # Access band
        capi.band_io(self._ptr, access_flag, offset[0***REMOVED***, offset[1***REMOVED***,
                     size[0***REMOVED***, size[1***REMOVED***, byref(data_array***REMOVED***, shape[0***REMOVED***,
                     shape[1***REMOVED***, self.datatype(***REMOVED***, 0, 0***REMOVED***

        # Return data as numpy array if possible, otherwise as list
        if data is None:
            if as_memoryview:
                return memoryview(data_array***REMOVED***
            elif numpy:
                # reshape(***REMOVED*** needs a reshape parameter with the height first.
                return numpy.frombuffer(
                    data_array, dtype=numpy.dtype(data_array***REMOVED***
                ***REMOVED***.reshape(tuple(reversed(size***REMOVED******REMOVED******REMOVED***
            else:
                return list(data_array***REMOVED***
        else:
            self._flush(***REMOVED***


class BandList(list***REMOVED***:
    def __init__(self, source***REMOVED***:
        self.source = source
        list.__init__(self***REMOVED***

    def __iter__(self***REMOVED***:
        for idx in range(1, len(self***REMOVED*** + 1***REMOVED***:
            yield GDALBand(self.source, idx***REMOVED***

    def __len__(self***REMOVED***:
        return capi.get_ds_raster_count(self.source._ptr***REMOVED***

    def __getitem__(self, index***REMOVED***:
        ***REMOVED***
            return GDALBand(self.source, index + 1***REMOVED***
        except GDALException:
            raise GDALException('Unable to get band index %d' % index***REMOVED***
