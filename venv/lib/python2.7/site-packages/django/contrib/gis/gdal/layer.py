from ctypes import byref, c_double

from django.contrib.gis.gdal.base import GDALBase
from django.contrib.gis.gdal.envelope import Envelope, OGREnvelope
from django.contrib.gis.gdal.error import (
    GDALException, OGRIndexError, SRSException,
***REMOVED***
from django.contrib.gis.gdal.feature import Feature
from django.contrib.gis.gdal.field import OGRFieldTypes
from django.contrib.gis.gdal.geometries import OGRGeometry
from django.contrib.gis.gdal.geomtype import OGRGeomType
from django.contrib.gis.gdal.prototypes import (
    ds as capi, geom as geom_api, srs as srs_api,
***REMOVED***
from django.contrib.gis.gdal.srs import SpatialReference
from django.utils import six
from django.utils.encoding import force_bytes, force_text
from django.utils.six.moves import range


# For more information, see the OGR C API source code:
#  http://www.gdal.org/ogr__api_8h.html
#
# The OGR_L_* routines are relevant here.
class Layer(GDALBase***REMOVED***:
    "A class that wraps an OGR Layer, needs to be instantiated from a DataSource object."

    def __init__(self, layer_ptr, ds***REMOVED***:
        ***REMOVED***
        Initializes on an OGR C pointer to the Layer and the `DataSource` object
        that owns this layer.  The `DataSource` object is required so that a
        reference to it is kept with this Layer.  This prevents garbage
        collection of the `DataSource` while this Layer is still active.
        ***REMOVED***
        if not layer_ptr:
            raise GDALException('Cannot create Layer, invalid pointer given'***REMOVED***
        self.ptr = layer_ptr
        self._ds = ds
        self._ldefn = capi.get_layer_defn(self._ptr***REMOVED***
        # Does the Layer support random reading?
        self._random_read = self.test_capability(b'RandomRead'***REMOVED***

    def __getitem__(self, index***REMOVED***:
        "Gets the Feature at the specified index."
        if isinstance(index, six.integer_types***REMOVED***:
            # An integer index was given -- we cannot do a check based on the
            # number of features because the beginning and ending feature IDs
            # are not guaranteed to be 0 and len(layer***REMOVED***-1, respectively.
            if index < 0:
                raise OGRIndexError('Negative indices are not allowed on OGR Layers.'***REMOVED***
            return self._make_feature(index***REMOVED***
        elif isinstance(index, slice***REMOVED***:
            # A slice was given
            start, stop, stride = index.indices(self.num_feat***REMOVED***
            return [self._make_feature(fid***REMOVED*** for fid in range(start, stop, stride***REMOVED******REMOVED***
        else:
            raise TypeError('Integers and slices may only be used when indexing OGR Layers.'***REMOVED***

    def __iter__(self***REMOVED***:
        "Iterates over each Feature in the Layer."
        # ResetReading(***REMOVED*** must be called before iteration is to begin.
        capi.reset_reading(self._ptr***REMOVED***
        for i in range(self.num_feat***REMOVED***:
            yield Feature(capi.get_next_feature(self._ptr***REMOVED***, self***REMOVED***

    def __len__(self***REMOVED***:
        "The length is the number of features."
        return self.num_feat

    def __str__(self***REMOVED***:
        "The string name of the layer."
        return self.name

    def _make_feature(self, feat_id***REMOVED***:
        ***REMOVED***
        Helper routine for __getitem__ that constructs a Feature from the given
        Feature ID.  If the OGR Layer does not support random-access reading,
        then each feature of the layer will be incremented through until the
        a Feature is found matching the given feature ID.
        ***REMOVED***
        if self._random_read:
            # If the Layer supports random reading, return.
            ***REMOVED***
                return Feature(capi.get_feature(self.ptr, feat_id***REMOVED***, self***REMOVED***
            except GDALException:
                pass
        else:
            # Random access isn't supported, have to increment through
            # each feature until the given feature ID is encountered.
            for feat in self:
                if feat.fid == feat_id:
                    return feat
        # Should have returned a Feature, raise an OGRIndexError.
        raise OGRIndexError('Invalid feature id: %s.' % feat_id***REMOVED***

    # #### Layer properties ####
    @property
    def extent(self***REMOVED***:
        "Returns the extent (an Envelope***REMOVED*** of this layer."
        env = OGREnvelope(***REMOVED***
        capi.get_extent(self.ptr, byref(env***REMOVED***, 1***REMOVED***
        return Envelope(env***REMOVED***

    @property
    def name(self***REMOVED***:
        "Returns the name of this layer in the Data Source."
        name = capi.get_fd_name(self._ldefn***REMOVED***
        return force_text(name, self._ds.encoding, strings_only=True***REMOVED***

    @property
    def num_feat(self, force=1***REMOVED***:
        "Returns the number of features in the Layer."
        return capi.get_feature_count(self.ptr, force***REMOVED***

    @property
    def num_fields(self***REMOVED***:
        "Returns the number of fields in the Layer."
        return capi.get_field_count(self._ldefn***REMOVED***

    @property
    def geom_type(self***REMOVED***:
        "Returns the geometry type (OGRGeomType***REMOVED*** of the Layer."
        return OGRGeomType(capi.get_fd_geom_type(self._ldefn***REMOVED******REMOVED***

    @property
    def srs(self***REMOVED***:
        "Returns the Spatial Reference used in this Layer."
        ***REMOVED***
            ptr = capi.get_layer_srs(self.ptr***REMOVED***
            return SpatialReference(srs_api.clone_srs(ptr***REMOVED******REMOVED***
        except SRSException:
            return None

    @property
    def fields(self***REMOVED***:
        ***REMOVED***
        Returns a list of string names corresponding to each of the Fields
        available in this Layer.
        ***REMOVED***
        return [force_text(capi.get_field_name(capi.get_field_defn(self._ldefn, i***REMOVED******REMOVED***,
                           self._ds.encoding, strings_only=True***REMOVED***
                for i in range(self.num_fields***REMOVED******REMOVED***

    @property
    def field_types(self***REMOVED***:
        ***REMOVED***
        Returns a list of the types of fields in this Layer.  For example,
        the list [OFTInteger, OFTReal, OFTString***REMOVED*** would be returned for
        an OGR layer that had an integer, a floating-point, and string
        fields.
        ***REMOVED***
        return [OGRFieldTypes[capi.get_field_type(capi.get_field_defn(self._ldefn, i***REMOVED******REMOVED******REMOVED***
                for i in range(self.num_fields***REMOVED******REMOVED***

    @property
    def field_widths(self***REMOVED***:
        "Returns a list of the maximum field widths for the features."
        return [capi.get_field_width(capi.get_field_defn(self._ldefn, i***REMOVED******REMOVED***
                for i in range(self.num_fields***REMOVED******REMOVED***

    @property
    def field_precisions(self***REMOVED***:
        "Returns the field precisions for the features."
        return [capi.get_field_precision(capi.get_field_defn(self._ldefn, i***REMOVED******REMOVED***
                for i in range(self.num_fields***REMOVED******REMOVED***

    def _get_spatial_filter(self***REMOVED***:
        ***REMOVED***
            return OGRGeometry(geom_api.clone_geom(capi.get_spatial_filter(self.ptr***REMOVED******REMOVED******REMOVED***
        except GDALException:
            return None

    def _set_spatial_filter(self, filter***REMOVED***:
        if isinstance(filter, OGRGeometry***REMOVED***:
            capi.set_spatial_filter(self.ptr, filter.ptr***REMOVED***
        elif isinstance(filter, (tuple, list***REMOVED******REMOVED***:
            if not len(filter***REMOVED*** == 4:
                raise ValueError('Spatial filter list/tuple must have 4 elements.'***REMOVED***
            # Map c_double onto params -- if a bad type is passed in it
            # will be caught here.
            xmin, ymin, xmax, ymax = map(c_double, filter***REMOVED***
            capi.set_spatial_filter_rect(self.ptr, xmin, ymin, xmax, ymax***REMOVED***
        elif filter is None:
            capi.set_spatial_filter(self.ptr, None***REMOVED***
        else:
            raise TypeError('Spatial filter must be either an OGRGeometry instance, a 4-tuple, or None.'***REMOVED***

    spatial_filter = property(_get_spatial_filter, _set_spatial_filter***REMOVED***

    # #### Layer Methods ####
    def get_fields(self, field_name***REMOVED***:
        ***REMOVED***
        Returns a list containing the given field name for every Feature
        in the Layer.
        ***REMOVED***
        if field_name not in self.fields:
            raise GDALException('invalid field name: %s' % field_name***REMOVED***
        return [feat.get(field_name***REMOVED*** for feat in self***REMOVED***

    def get_geoms(self, geos=False***REMOVED***:
        ***REMOVED***
        Returns a list containing the OGRGeometry for every Feature in
        the Layer.
        ***REMOVED***
        if geos:
            from django.contrib.gis.geos import GEOSGeometry
            return [GEOSGeometry(feat.geom.wkb***REMOVED*** for feat in self***REMOVED***
        else:
            return [feat.geom for feat in self***REMOVED***

    def test_capability(self, capability***REMOVED***:
        ***REMOVED***
        Returns a bool indicating whether the this Layer supports the given
        capability (a string***REMOVED***.  Valid capability strings include:
          'RandomRead', 'SequentialWrite', 'RandomWrite', 'FastSpatialFilter',
          'FastFeatureCount', 'FastGetExtent', 'CreateField', 'Transactions',
          'DeleteFeature', and 'FastSetNextByIndex'.
        ***REMOVED***
        return bool(capi.test_capability(self.ptr, force_bytes(capability***REMOVED******REMOVED******REMOVED***
