***REMOVED***
 The OGRGeometry is a wrapper for using the OGR Geometry class
 (see http://www.gdal.org/classOGRGeometry.html***REMOVED***.  OGRGeometry
 may be instantiated when reading geometries from OGR Data Sources
 (e.g. SHP files***REMOVED***, or when given OGC WKT (a string***REMOVED***.

 While the 'full' API is not present yet, the API is "pythonic" unlike
 the traditional and "next-generation" OGR Python bindings.  One major
 advantage OGR Geometries have over their GEOS counterparts is support
 for spatial reference systems and their transformation.

 Example:
  >>> from django.contrib.gis.gdal import OGRGeometry, OGRGeomType, SpatialReference
  >>> wkt1, wkt2 = 'POINT(-90 30***REMOVED***', 'POLYGON((0 0, 5 0, 5 5, 0 5***REMOVED***'
  >>> pnt = OGRGeometry(wkt1***REMOVED***
  >>> print(pnt***REMOVED***
  POINT (-90 30***REMOVED***
  >>> mpnt = OGRGeometry(OGRGeomType('MultiPoint'***REMOVED***, SpatialReference('WGS84'***REMOVED******REMOVED***
  >>> mpnt.add(wkt1***REMOVED***
  >>> mpnt.add(wkt1***REMOVED***
  >>> print(mpnt***REMOVED***
  MULTIPOINT (-90 30,-90 30***REMOVED***
  >>> print(mpnt.srs.name***REMOVED***
  WGS 84
  >>> print(mpnt.srs.proj***REMOVED***
  +proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs
  >>> mpnt.transform(SpatialReference('NAD27'***REMOVED******REMOVED***
  >>> print(mpnt.proj***REMOVED***
  +proj=longlat +ellps=clrk66 +datum=NAD27 +no_defs
  >>> print(mpnt***REMOVED***
  MULTIPOINT (-89.999930378602485 29.999797886557641,-89.999930378602485 29.999797886557641***REMOVED***

  The OGRGeomType class is to make it easy to specify an OGR geometry type:
  >>> from django.contrib.gis.gdal import OGRGeomType
  >>> gt1 = OGRGeomType(3***REMOVED*** # Using an integer for the type
  >>> gt2 = OGRGeomType('Polygon'***REMOVED*** # Using a string
  >>> gt3 = OGRGeomType('POLYGON'***REMOVED*** # It's case-insensitive
  >>> print(gt1 == 3, gt1 == 'Polygon'***REMOVED*** # Equivalence works w/non-OGRGeomType objects
  True True
***REMOVED***
import sys
from binascii import a2b_hex, b2a_hex
from ctypes import byref, c_char_p, c_double, c_ubyte, c_void_p, string_at

from django.contrib.gis.gdal.base import GDALBase
from django.contrib.gis.gdal.envelope import Envelope, OGREnvelope
from django.contrib.gis.gdal.error import (
    GDALException, OGRIndexError, SRSException,
***REMOVED***
from django.contrib.gis.gdal.geomtype import OGRGeomType
from django.contrib.gis.gdal.prototypes import geom as capi, srs as srs_api
from django.contrib.gis.gdal.srs import CoordTransform, SpatialReference
from django.contrib.gis.geometry.regex import hex_regex, json_regex, wkt_regex
from django.utils import six
from django.utils.six.moves import range


# For more information, see the OGR C API source code:
#  http://www.gdal.org/ogr__api_8h.html
#
# The OGR_G_* routines are relevant here.
class OGRGeometry(GDALBase***REMOVED***:
    "Generally encapsulates an OGR geometry."

    def __init__(self, geom_input, srs=None***REMOVED***:
        "Initializes Geometry on either WKT or an OGR pointer as input."

        str_instance = isinstance(geom_input, six.string_types***REMOVED***

        # If HEX, unpack input to a binary buffer.
        if str_instance and hex_regex.match(geom_input***REMOVED***:
            geom_input = six.memoryview(a2b_hex(geom_input.upper(***REMOVED***.encode(***REMOVED******REMOVED******REMOVED***
            str_instance = False

        # Constructing the geometry,
        if str_instance:
            wkt_m = wkt_regex.match(geom_input***REMOVED***
            json_m = json_regex.match(geom_input***REMOVED***
            if wkt_m:
                if wkt_m.group('srid'***REMOVED***:
                    # If there's EWKT, set the SRS w/value of the SRID.
                    srs = int(wkt_m.group('srid'***REMOVED******REMOVED***
                if wkt_m.group('type'***REMOVED***.upper(***REMOVED*** == 'LINEARRING':
                    # OGR_G_CreateFromWkt doesn't work with LINEARRING WKT.
                    #  See http://trac.osgeo.org/gdal/ticket/1992.
                    g = capi.create_geom(OGRGeomType(wkt_m.group('type'***REMOVED******REMOVED***.num***REMOVED***
                    capi.import_wkt(g, byref(c_char_p(wkt_m.group('wkt'***REMOVED***.encode(***REMOVED******REMOVED******REMOVED******REMOVED***
                else:
                    g = capi.from_wkt(byref(c_char_p(wkt_m.group('wkt'***REMOVED***.encode(***REMOVED******REMOVED******REMOVED***, None, byref(c_void_p(***REMOVED******REMOVED******REMOVED***
            elif json_m:
                g = capi.from_json(geom_input.encode(***REMOVED******REMOVED***
            else:
                # Seeing if the input is a valid short-hand string
                # (e.g., 'Point', 'POLYGON'***REMOVED***.
                OGRGeomType(geom_input***REMOVED***
                g = capi.create_geom(OGRGeomType(geom_input***REMOVED***.num***REMOVED***
        elif isinstance(geom_input, six.memoryview***REMOVED***:
            # WKB was passed in
            g = capi.from_wkb(bytes(geom_input***REMOVED***, None, byref(c_void_p(***REMOVED******REMOVED***, len(geom_input***REMOVED******REMOVED***
        elif isinstance(geom_input, OGRGeomType***REMOVED***:
            # OGRGeomType was passed in, an empty geometry will be created.
            g = capi.create_geom(geom_input.num***REMOVED***
        elif isinstance(geom_input, self.ptr_type***REMOVED***:
            # OGR pointer (c_void_p***REMOVED*** was the input.
            g = geom_input
        else:
            raise GDALException('Invalid input type for OGR Geometry construction: %s' % type(geom_input***REMOVED******REMOVED***

        # Now checking the Geometry pointer before finishing initialization
        # by setting the pointer for the object.
        if not g:
            raise GDALException('Cannot create OGR Geometry from input: %s' % str(geom_input***REMOVED******REMOVED***
        self.ptr = g

        # Assigning the SpatialReference object to the geometry, if valid.
        if srs:
            self.srs = srs

        # Setting the class depending upon the OGR Geometry Type
        self.__class__ = GEO_CLASSES[self.geom_type.num***REMOVED***

    def __del__(self***REMOVED***:
        "Deletes this Geometry."
        ***REMOVED***
            capi.destroy_geom(self._ptr***REMOVED***
        except (AttributeError, TypeError***REMOVED***:
            pass  # Some part might already have been garbage collected

    # Pickle routines
    def __getstate__(self***REMOVED***:
        srs = self.srs
        if srs:
            srs = srs.wkt
        else:
            srs = None
        return bytes(self.wkb***REMOVED***, srs

    def __setstate__(self, state***REMOVED***:
        wkb, srs = state
        ptr = capi.from_wkb(wkb, None, byref(c_void_p(***REMOVED******REMOVED***, len(wkb***REMOVED******REMOVED***
        if not ptr:
            raise GDALException('Invalid OGRGeometry loaded from pickled state.'***REMOVED***
        self.ptr = ptr
        self.srs = srs

    @classmethod
    def from_bbox(cls, bbox***REMOVED***:
        "Constructs a Polygon from a bounding box (4-tuple***REMOVED***."
        x0, y0, x1, y1 = bbox
        return OGRGeometry('POLYGON((%s %s, %s %s, %s %s, %s %s, %s %s***REMOVED******REMOVED***' % (
            x0, y0, x0, y1, x1, y1, x1, y0, x0, y0***REMOVED******REMOVED***

    # ### Geometry set-like operations ###
    # g = g1 | g2
    def __or__(self, other***REMOVED***:
        "Returns the union of the two geometries."
        return self.union(other***REMOVED***

    # g = g1 & g2
    def __and__(self, other***REMOVED***:
        "Returns the intersection of this Geometry and the other."
        return self.intersection(other***REMOVED***

    # g = g1 - g2
    def __sub__(self, other***REMOVED***:
        "Return the difference this Geometry and the other."
        return self.difference(other***REMOVED***

    # g = g1 ^ g2
    def __xor__(self, other***REMOVED***:
        "Return the symmetric difference of this Geometry and the other."
        return self.sym_difference(other***REMOVED***

    def __eq__(self, other***REMOVED***:
        "Is this Geometry equal to the other?"
        if isinstance(other, OGRGeometry***REMOVED***:
            return self.equals(other***REMOVED***
        else:
            return False

    def __ne__(self, other***REMOVED***:
        "Tests for inequality."
        return not (self == other***REMOVED***

    def __str__(self***REMOVED***:
        "WKT is used for the string representation."
        return self.wkt

    # #### Geometry Properties ####
    @property
    def dimension(self***REMOVED***:
        "Returns 0 for points, 1 for lines, and 2 for surfaces."
        return capi.get_dims(self.ptr***REMOVED***

    def _get_coord_dim(self***REMOVED***:
        "Returns the coordinate dimension of the Geometry."
        return capi.get_coord_dim(self.ptr***REMOVED***

    def _set_coord_dim(self, dim***REMOVED***:
        "Sets the coordinate dimension of this Geometry."
        if dim not in (2, 3***REMOVED***:
            raise ValueError('Geometry dimension must be either 2 or 3'***REMOVED***
        capi.set_coord_dim(self.ptr, dim***REMOVED***

    coord_dim = property(_get_coord_dim, _set_coord_dim***REMOVED***

    @property
    def geom_count(self***REMOVED***:
        "The number of elements in this Geometry."
        return capi.get_geom_count(self.ptr***REMOVED***

    @property
    def point_count(self***REMOVED***:
        "Returns the number of Points in this Geometry."
        return capi.get_point_count(self.ptr***REMOVED***

    @property
    def num_points(self***REMOVED***:
        "Alias for `point_count` (same name method in GEOS API.***REMOVED***"
        return self.point_count

    @property
    def num_coords(self***REMOVED***:
        "Alais for `point_count`."
        return self.point_count

    @property
    def geom_type(self***REMOVED***:
        "Returns the Type for this Geometry."
        return OGRGeomType(capi.get_geom_type(self.ptr***REMOVED******REMOVED***

    @property
    def geom_name(self***REMOVED***:
        "Returns the Name of this Geometry."
        return capi.get_geom_name(self.ptr***REMOVED***

    @property
    def area(self***REMOVED***:
        "Returns the area for a LinearRing, Polygon, or MultiPolygon; 0 otherwise."
        return capi.get_area(self.ptr***REMOVED***

    @property
    def envelope(self***REMOVED***:
        "Returns the envelope for this Geometry."
        # TODO: Fix Envelope(***REMOVED*** for Point geometries.
        return Envelope(capi.get_envelope(self.ptr, byref(OGREnvelope(***REMOVED******REMOVED******REMOVED******REMOVED***

    @property
    def extent(self***REMOVED***:
        "Returns the envelope as a 4-tuple, instead of as an Envelope object."
        return self.envelope.tuple

    # #### SpatialReference-related Properties ####

    # The SRS property
    def _get_srs(self***REMOVED***:
        "Returns the Spatial Reference for this Geometry."
        ***REMOVED***
            srs_ptr = capi.get_geom_srs(self.ptr***REMOVED***
            return SpatialReference(srs_api.clone_srs(srs_ptr***REMOVED******REMOVED***
        except SRSException:
            return None

    def _set_srs(self, srs***REMOVED***:
        "Sets the SpatialReference for this geometry."
        # Do not have to clone the `SpatialReference` object pointer because
        # when it is assigned to this `OGRGeometry` it's internal OGR
        # reference count is incremented, and will likewise be released
        # (decremented***REMOVED*** when this geometry's destructor is called.
        if isinstance(srs, SpatialReference***REMOVED***:
            srs_ptr = srs.ptr
        elif isinstance(srs, six.integer_types + six.string_types***REMOVED***:
            sr = SpatialReference(srs***REMOVED***
            srs_ptr = sr.ptr
        elif srs is None:
            srs_ptr = None
        else:
            raise TypeError('Cannot assign spatial reference with object of type: %s' % type(srs***REMOVED******REMOVED***
        capi.assign_srs(self.ptr, srs_ptr***REMOVED***

    srs = property(_get_srs, _set_srs***REMOVED***

    # The SRID property
    def _get_srid(self***REMOVED***:
        srs = self.srs
        if srs:
            return srs.srid
        return None

    def _set_srid(self, srid***REMOVED***:
        if isinstance(srid, six.integer_types***REMOVED*** or srid is None:
            self.srs = srid
        else:
            raise TypeError('SRID must be set with an integer.'***REMOVED***

    srid = property(_get_srid, _set_srid***REMOVED***

    # #### Output Methods ####
    @property
    def geos(self***REMOVED***:
        "Returns a GEOSGeometry object from this OGRGeometry."
        from django.contrib.gis.geos import GEOSGeometry
        return GEOSGeometry(self.wkb, self.srid***REMOVED***

    @property
    def gml(self***REMOVED***:
        "Returns the GML representation of the Geometry."
        return capi.to_gml(self.ptr***REMOVED***

    @property
    def hex(self***REMOVED***:
        "Returns the hexadecimal representation of the WKB (a string***REMOVED***."
        return b2a_hex(self.wkb***REMOVED***.upper(***REMOVED***

    @property
    def json(self***REMOVED***:
        ***REMOVED***
        Returns the GeoJSON representation of this Geometry.
        ***REMOVED***
        return capi.to_json(self.ptr***REMOVED***
    geojson = json

    @property
    def kml(self***REMOVED***:
        "Returns the KML representation of the Geometry."
        return capi.to_kml(self.ptr, None***REMOVED***

    @property
    def wkb_size(self***REMOVED***:
        "Returns the size of the WKB buffer."
        return capi.get_wkbsize(self.ptr***REMOVED***

    @property
    def wkb(self***REMOVED***:
        "Returns the WKB representation of the Geometry."
        if sys.byteorder == 'little':
            byteorder = 1  # wkbNDR (from ogr_core.h***REMOVED***
        else:
            byteorder = 0  # wkbXDR
        sz = self.wkb_size
        # Creating the unsigned character buffer, and passing it in by reference.
        buf = (c_ubyte * sz***REMOVED***(***REMOVED***
        capi.to_wkb(self.ptr, byteorder, byref(buf***REMOVED******REMOVED***
        # Returning a buffer of the string at the pointer.
        return six.memoryview(string_at(buf, sz***REMOVED******REMOVED***

    @property
    def wkt(self***REMOVED***:
        "Returns the WKT representation of the Geometry."
        return capi.to_wkt(self.ptr, byref(c_char_p(***REMOVED******REMOVED******REMOVED***

    @property
    def ewkt(self***REMOVED***:
        "Returns the EWKT representation of the Geometry."
        srs = self.srs
        if srs and srs.srid:
            return 'SRID=%s;%s' % (srs.srid, self.wkt***REMOVED***
        else:
            return self.wkt

    # #### Geometry Methods ####
    def clone(self***REMOVED***:
        "Clones this OGR Geometry."
        return OGRGeometry(capi.clone_geom(self.ptr***REMOVED***, self.srs***REMOVED***

    def close_rings(self***REMOVED***:
        ***REMOVED***
        If there are any rings within this geometry that have not been
        closed, this routine will do so by adding the starting point at the
        end.
        ***REMOVED***
        # Closing the open rings.
        capi.geom_close_rings(self.ptr***REMOVED***

    def transform(self, coord_trans, clone=False***REMOVED***:
        ***REMOVED***
        Transforms this geometry to a different spatial reference system.
        May take a CoordTransform object, a SpatialReference object, string
        WKT or PROJ.4, and/or an integer SRID.  By default nothing is returned
        and the geometry is transformed in-place.  However, if the `clone`
        keyword is set, then a transformed clone of this geometry will be
        returned.
        ***REMOVED***
        if clone:
            klone = self.clone(***REMOVED***
            klone.transform(coord_trans***REMOVED***
            return klone

        # Depending on the input type, use the appropriate OGR routine
        # to perform the transformation.
        if isinstance(coord_trans, CoordTransform***REMOVED***:
            capi.geom_transform(self.ptr, coord_trans.ptr***REMOVED***
        elif isinstance(coord_trans, SpatialReference***REMOVED***:
            capi.geom_transform_to(self.ptr, coord_trans.ptr***REMOVED***
        elif isinstance(coord_trans, six.integer_types + six.string_types***REMOVED***:
            sr = SpatialReference(coord_trans***REMOVED***
            capi.geom_transform_to(self.ptr, sr.ptr***REMOVED***
        else:
            raise TypeError('Transform only accepts CoordTransform, '
                            'SpatialReference, string, and integer objects.'***REMOVED***

    # #### Topology Methods ####
    def _topology(self, func, other***REMOVED***:
        ***REMOVED***A generalized function for topology operations, takes a GDAL function and
        the other geometry to perform the operation on.***REMOVED***
        if not isinstance(other, OGRGeometry***REMOVED***:
            raise TypeError('Must use another OGRGeometry object for topology operations!'***REMOVED***

        # Returning the output of the given function with the other geometry's
        # pointer.
        return func(self.ptr, other.ptr***REMOVED***

    def intersects(self, other***REMOVED***:
        "Returns True if this geometry intersects with the other."
        return self._topology(capi.ogr_intersects, other***REMOVED***

    def equals(self, other***REMOVED***:
        "Returns True if this geometry is equivalent to the other."
        return self._topology(capi.ogr_equals, other***REMOVED***

    def disjoint(self, other***REMOVED***:
        "Returns True if this geometry and the other are spatially disjoint."
        return self._topology(capi.ogr_disjoint, other***REMOVED***

    def touches(self, other***REMOVED***:
        "Returns True if this geometry touches the other."
        return self._topology(capi.ogr_touches, other***REMOVED***

    def crosses(self, other***REMOVED***:
        "Returns True if this geometry crosses the other."
        return self._topology(capi.ogr_crosses, other***REMOVED***

    def within(self, other***REMOVED***:
        "Returns True if this geometry is within the other."
        return self._topology(capi.ogr_within, other***REMOVED***

    def contains(self, other***REMOVED***:
        "Returns True if this geometry contains the other."
        return self._topology(capi.ogr_contains, other***REMOVED***

    def overlaps(self, other***REMOVED***:
        "Returns True if this geometry overlaps the other."
        return self._topology(capi.ogr_overlaps, other***REMOVED***

    # #### Geometry-generation Methods ####
    def _geomgen(self, gen_func, other=None***REMOVED***:
        "A helper routine for the OGR routines that generate geometries."
        if isinstance(other, OGRGeometry***REMOVED***:
            return OGRGeometry(gen_func(self.ptr, other.ptr***REMOVED***, self.srs***REMOVED***
        else:
            return OGRGeometry(gen_func(self.ptr***REMOVED***, self.srs***REMOVED***

    @property
    def boundary(self***REMOVED***:
        "Returns the boundary of this geometry."
        return self._geomgen(capi.get_boundary***REMOVED***

    @property
    def convex_hull(self***REMOVED***:
        ***REMOVED***
        Returns the smallest convex Polygon that contains all the points in
        this Geometry.
        ***REMOVED***
        return self._geomgen(capi.geom_convex_hull***REMOVED***

    def difference(self, other***REMOVED***:
        ***REMOVED***
        Returns a new geometry consisting of the region which is the difference
        of this geometry and the other.
        ***REMOVED***
        return self._geomgen(capi.geom_diff, other***REMOVED***

    def intersection(self, other***REMOVED***:
        ***REMOVED***
        Returns a new geometry consisting of the region of intersection of this
        geometry and the other.
        ***REMOVED***
        return self._geomgen(capi.geom_intersection, other***REMOVED***

    def sym_difference(self, other***REMOVED***:
        ***REMOVED***
        Returns a new geometry which is the symmetric difference of this
        geometry and the other.
        ***REMOVED***
        return self._geomgen(capi.geom_sym_diff, other***REMOVED***

    def union(self, other***REMOVED***:
        ***REMOVED***
        Returns a new geometry consisting of the region which is the union of
        this geometry and the other.
        ***REMOVED***
        return self._geomgen(capi.geom_union, other***REMOVED***


# The subclasses for OGR Geometry.
class Point(OGRGeometry***REMOVED***:

    @property
    def x(self***REMOVED***:
        "Returns the X coordinate for this Point."
        return capi.getx(self.ptr, 0***REMOVED***

    @property
    def y(self***REMOVED***:
        "Returns the Y coordinate for this Point."
        return capi.gety(self.ptr, 0***REMOVED***

    @property
    def z(self***REMOVED***:
        "Returns the Z coordinate for this Point."
        if self.coord_dim == 3:
            return capi.getz(self.ptr, 0***REMOVED***

    @property
    def tuple(self***REMOVED***:
        "Returns the tuple of this point."
        if self.coord_dim == 2:
            return (self.x, self.y***REMOVED***
        elif self.coord_dim == 3:
            return (self.x, self.y, self.z***REMOVED***
    coords = tuple


class LineString(OGRGeometry***REMOVED***:

    def __getitem__(self, index***REMOVED***:
        "Returns the Point at the given index."
        if index >= 0 and index < self.point_count:
            x, y, z = c_double(***REMOVED***, c_double(***REMOVED***, c_double(***REMOVED***
            capi.get_point(self.ptr, index, byref(x***REMOVED***, byref(y***REMOVED***, byref(z***REMOVED******REMOVED***
            dim = self.coord_dim
            if dim == 1:
                return (x.value,***REMOVED***
            elif dim == 2:
                return (x.value, y.value***REMOVED***
            elif dim == 3:
                return (x.value, y.value, z.value***REMOVED***
        else:
            raise OGRIndexError('index out of range: %s' % str(index***REMOVED******REMOVED***

    def __iter__(self***REMOVED***:
        "Iterates over each point in the LineString."
        for i in range(self.point_count***REMOVED***:
            yield self[i***REMOVED***

    def __len__(self***REMOVED***:
        "The length returns the number of points in the LineString."
        return self.point_count

    @property
    def tuple(self***REMOVED***:
        "Returns the tuple representation of this LineString."
        return tuple(self[i***REMOVED*** for i in range(len(self***REMOVED******REMOVED******REMOVED***
    coords = tuple

    def _listarr(self, func***REMOVED***:
        ***REMOVED***
        Internal routine that returns a sequence (list***REMOVED*** corresponding with
        the given function.
        ***REMOVED***
        return [func(self.ptr, i***REMOVED*** for i in range(len(self***REMOVED******REMOVED******REMOVED***

    @property
    def x(self***REMOVED***:
        "Returns the X coordinates in a list."
        return self._listarr(capi.getx***REMOVED***

    @property
    def y(self***REMOVED***:
        "Returns the Y coordinates in a list."
        return self._listarr(capi.gety***REMOVED***

    @property
    def z(self***REMOVED***:
        "Returns the Z coordinates in a list."
        if self.coord_dim == 3:
            return self._listarr(capi.getz***REMOVED***


# LinearRings are used in Polygons.
class LinearRing(LineString***REMOVED***:
    pass


class Polygon(OGRGeometry***REMOVED***:

    def __len__(self***REMOVED***:
        "The number of interior rings in this Polygon."
        return self.geom_count

    def __iter__(self***REMOVED***:
        "Iterates through each ring in the Polygon."
        for i in range(self.geom_count***REMOVED***:
            yield self[i***REMOVED***

    def __getitem__(self, index***REMOVED***:
        "Gets the ring at the specified index."
        if index < 0 or index >= self.geom_count:
            raise OGRIndexError('index out of range: %s' % index***REMOVED***
        else:
            return OGRGeometry(capi.clone_geom(capi.get_geom_ref(self.ptr, index***REMOVED******REMOVED***, self.srs***REMOVED***

    # Polygon Properties
    @property
    def shell(self***REMOVED***:
        "Returns the shell of this Polygon."
        return self[0***REMOVED***  # First ring is the shell
    exterior_ring = shell

    @property
    def tuple(self***REMOVED***:
        "Returns a tuple of LinearRing coordinate tuples."
        return tuple(self[i***REMOVED***.tuple for i in range(self.geom_count***REMOVED******REMOVED***
    coords = tuple

    @property
    def point_count(self***REMOVED***:
        "The number of Points in this Polygon."
        # Summing up the number of points in each ring of the Polygon.
        return sum(self[i***REMOVED***.point_count for i in range(self.geom_count***REMOVED******REMOVED***

    @property
    def centroid(self***REMOVED***:
        "Returns the centroid (a Point***REMOVED*** of this Polygon."
        # The centroid is a Point, create a geometry for this.
        p = OGRGeometry(OGRGeomType('Point'***REMOVED******REMOVED***
        capi.get_centroid(self.ptr, p.ptr***REMOVED***
        return p


# Geometry Collection base class.
class GeometryCollection(OGRGeometry***REMOVED***:
    "The Geometry Collection class."

    def __getitem__(self, index***REMOVED***:
        "Gets the Geometry at the specified index."
        if index < 0 or index >= self.geom_count:
            raise OGRIndexError('index out of range: %s' % index***REMOVED***
        else:
            return OGRGeometry(capi.clone_geom(capi.get_geom_ref(self.ptr, index***REMOVED******REMOVED***, self.srs***REMOVED***

    def __iter__(self***REMOVED***:
        "Iterates over each Geometry."
        for i in range(self.geom_count***REMOVED***:
            yield self[i***REMOVED***

    def __len__(self***REMOVED***:
        "The number of geometries in this Geometry Collection."
        return self.geom_count

    def add(self, geom***REMOVED***:
        "Add the geometry to this Geometry Collection."
        if isinstance(geom, OGRGeometry***REMOVED***:
            if isinstance(geom, self.__class__***REMOVED***:
                for g in geom:
                    capi.add_geom(self.ptr, g.ptr***REMOVED***
            else:
                capi.add_geom(self.ptr, geom.ptr***REMOVED***
        elif isinstance(geom, six.string_types***REMOVED***:
            tmp = OGRGeometry(geom***REMOVED***
            capi.add_geom(self.ptr, tmp.ptr***REMOVED***
        else:
            raise GDALException('Must add an OGRGeometry.'***REMOVED***

    @property
    def point_count(self***REMOVED***:
        "The number of Points in this Geometry Collection."
        # Summing up the number of points in each geometry in this collection
        return sum(self[i***REMOVED***.point_count for i in range(self.geom_count***REMOVED******REMOVED***

    @property
    def tuple(self***REMOVED***:
        "Returns a tuple representation of this Geometry Collection."
        return tuple(self[i***REMOVED***.tuple for i in range(self.geom_count***REMOVED******REMOVED***
    coords = tuple


# Multiple Geometry types.
class MultiPoint(GeometryCollection***REMOVED***:
    pass


class MultiLineString(GeometryCollection***REMOVED***:
    pass


class MultiPolygon(GeometryCollection***REMOVED***:
    pass

# Class mapping dictionary (using the OGRwkbGeometryType as the key***REMOVED***
GEO_CLASSES = {1: Point,
               2: LineString,
               3: Polygon,
               4: MultiPoint,
               5: MultiLineString,
               6: MultiPolygon,
               7: GeometryCollection,
               101: LinearRing,
               1 + OGRGeomType.wkb25bit: Point,
               2 + OGRGeomType.wkb25bit: LineString,
               3 + OGRGeomType.wkb25bit: Polygon,
               4 + OGRGeomType.wkb25bit: MultiPoint,
               5 + OGRGeomType.wkb25bit: MultiLineString,
               6 + OGRGeomType.wkb25bit: MultiPolygon,
               7 + OGRGeomType.wkb25bit: GeometryCollection,
           ***REMOVED***
