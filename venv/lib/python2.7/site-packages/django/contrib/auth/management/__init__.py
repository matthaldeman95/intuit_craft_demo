***REMOVED***
Creates permissions for all installed apps that need permissions.
***REMOVED***
from __future__ import unicode_literals

import getpass
import unicodedata

from django.apps import apps as global_apps
from django.contrib.auth import get_permission_codename
from django.core import exceptions
from django.db import DEFAULT_DB_ALIAS, router
from django.utils import six
from django.utils.encoding import DEFAULT_LOCALE_ENCODING


def _get_all_permissions(opts***REMOVED***:
    ***REMOVED***
    Returns (codename, name***REMOVED*** for all permissions in the given opts.
    ***REMOVED***
    builtin = _get_builtin_permissions(opts***REMOVED***
    custom = list(opts.permissions***REMOVED***
    return builtin + custom


def _get_builtin_permissions(opts***REMOVED***:
    ***REMOVED***
    Returns (codename, name***REMOVED*** for all autogenerated permissions.
    By default, this is ('add', 'change', 'delete'***REMOVED***
    ***REMOVED***
    perms = [***REMOVED***
    for action in opts.default_permissions:
        perms.append((
            get_permission_codename(action, opts***REMOVED***,
            'Can %s %s' % (action, opts.verbose_name_raw***REMOVED***
        ***REMOVED******REMOVED***
    return perms


def create_permissions(app_config, verbosity=2, interactive=True, using=DEFAULT_DB_ALIAS, apps=global_apps, **kwargs***REMOVED***:
    if not app_config.models_module:
        return

    app_label = app_config.label
    ***REMOVED***
        app_config = apps.get_app_config(app_label***REMOVED***
        ContentType = apps.get_model('contenttypes', 'ContentType'***REMOVED***
        Permission = apps.get_model('auth', 'Permission'***REMOVED***
    except LookupError:
        return

    if not router.allow_migrate_model(using, Permission***REMOVED***:
        return

    # This will hold the permissions we're looking for as
    # (content_type, (codename, name***REMOVED******REMOVED***
    searched_perms = list(***REMOVED***
    # The codenames and ctypes that should exist.
    ctypes = set(***REMOVED***
    for klass in app_config.get_models(***REMOVED***:
        # Force looking up the content types in the current database
        # before creating foreign keys to them.
        ctype = ContentType.objects.db_manager(using***REMOVED***.get_for_model(klass***REMOVED***

        ctypes.add(ctype***REMOVED***
        for perm in _get_all_permissions(klass._meta***REMOVED***:
            searched_perms.append((ctype, perm***REMOVED******REMOVED***

    # Find all the Permissions that have a content_type for a model we're
    # looking for.  We don't need to check for codenames since we already have
    # a list of the ones we're going to create.
    all_perms = set(Permission.objects.using(using***REMOVED***.filter(
        content_type__in=ctypes,
    ***REMOVED***.values_list(
        "content_type", "codename"
    ***REMOVED******REMOVED***

    perms = [
        Permission(codename=codename, name=name, content_type=ct***REMOVED***
        for ct, (codename, name***REMOVED*** in searched_perms
        if (ct.pk, codename***REMOVED*** not in all_perms
    ***REMOVED***
    Permission.objects.using(using***REMOVED***.bulk_create(perms***REMOVED***
    if verbosity >= 2:
        for perm in perms:
            print("Adding permission '%s'" % perm***REMOVED***


def get_system_username(***REMOVED***:
    ***REMOVED***
    Try to determine the current system user's username.

    :returns: The username as a unicode string, or an empty string if the
        username could not be determined.
    ***REMOVED***
    ***REMOVED***
        result = getpass.getuser(***REMOVED***
    except (ImportError, KeyError***REMOVED***:
        # KeyError will be raised by os.getpwuid(***REMOVED*** (called by getuser(***REMOVED******REMOVED***
        # if there is no corresponding entry in the /etc/passwd file
        # (a very restricted chroot environment, for example***REMOVED***.
        return ''
    if six.PY2:
        ***REMOVED***
            result = result.decode(DEFAULT_LOCALE_ENCODING***REMOVED***
        except UnicodeDecodeError:
            # UnicodeDecodeError - preventive treatment for non-latin Windows.
            return ''
    return result


def get_default_username(check_db=True***REMOVED***:
    ***REMOVED***
    Try to determine the current system user's username to use as a default.

    :param check_db: If ``True``, requires that the username does not match an
        existing ``auth.User`` (otherwise returns an empty string***REMOVED***.
    :returns: The username, or an empty string if no username can be
        determined.
    ***REMOVED***
    # This file is used in apps.py, it should not trigger models import.
    from django.contrib.auth import models as auth_app

    # If the User model has been swapped out, we can't make any assumptions
    # about the default user name.
    if auth_app.User._meta.swapped:
        return ''

    default_username = get_system_username(***REMOVED***
    ***REMOVED***
        default_username = (
            unicodedata.normalize('NFKD', default_username***REMOVED***
            .encode('ascii', 'ignore'***REMOVED***.decode('ascii'***REMOVED***
            .replace(' ', ''***REMOVED***.lower(***REMOVED***
        ***REMOVED***
    except UnicodeDecodeError:
        return ''

    # Run the username validator
    ***REMOVED***
        auth_app.User._meta.get_field('username'***REMOVED***.run_validators(default_username***REMOVED***
    except exceptions.ValidationError:
        return ''

    # Don't return the default username if it is already taken.
    if check_db and default_username:
        ***REMOVED***
            auth_app.User._default_manager.get(username=default_username***REMOVED***
        except auth_app.User.DoesNotExist:
            pass
        else:
            return ''
    return default_username
