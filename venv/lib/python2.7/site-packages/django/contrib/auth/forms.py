from __future__ import unicode_literals

import unicodedata

from django import forms
from django.contrib.auth import (
    authenticate, get_user_model, password_validation,
***REMOVED***
from django.contrib.auth.hashers import (
    UNUSABLE_PASSWORD_PREFIX, identify_hasher,
***REMOVED***
from django.contrib.auth.models import User
from django.contrib.auth.tokens import default_token_generator
from django.contrib.sites.shortcuts import get_current_site
from django.core.mail import EmailMultiAlternatives
from django.forms.utils import flatatt
from django.template import loader
from django.utils.encoding import force_bytes
from django.utils.html import format_html, format_html_join
from django.utils.http import urlsafe_base64_encode
from django.utils.safestring import mark_safe
from django.utils.text import capfirst
from django.utils.translation import ugettext, ugettext_lazy as _


class ReadOnlyPasswordHashWidget(forms.Widget***REMOVED***:
    def render(self, name, value, attrs***REMOVED***:
        encoded = value
        final_attrs = self.build_attrs(attrs***REMOVED***

        if not encoded or encoded.startswith(UNUSABLE_PASSWORD_PREFIX***REMOVED***:
            summary = mark_safe("<strong>%s</strong>" % ugettext("No password set."***REMOVED******REMOVED***
        else:
            ***REMOVED***
                hasher = identify_hasher(encoded***REMOVED***
            except ValueError:
                summary = mark_safe("<strong>%s</strong>" % ugettext(
                    "Invalid password format or unknown hashing algorithm."
                ***REMOVED******REMOVED***
            else:
                summary = format_html_join(
                    '', '<strong>{***REMOVED***</strong>: {***REMOVED*** ',
                    ((ugettext(key***REMOVED***, value***REMOVED*** for key, value in hasher.safe_summary(encoded***REMOVED***.items(***REMOVED******REMOVED***
                ***REMOVED***

        return format_html("<div{***REMOVED***>{***REMOVED***</div>", flatatt(final_attrs***REMOVED***, summary***REMOVED***


class ReadOnlyPasswordHashField(forms.Field***REMOVED***:
    widget = ReadOnlyPasswordHashWidget

    def __init__(self, *args, **kwargs***REMOVED***:
        kwargs.setdefault("required", False***REMOVED***
        super(ReadOnlyPasswordHashField, self***REMOVED***.__init__(*args, **kwargs***REMOVED***

    def bound_data(self, data, initial***REMOVED***:
        # Always return initial because the widget doesn't
        # render an input field.
        return initial

    def has_changed(self, initial, data***REMOVED***:
        return False


class UsernameField(forms.CharField***REMOVED***:
    def to_python(self, value***REMOVED***:
        return unicodedata.normalize('NFKC', super(UsernameField, self***REMOVED***.to_python(value***REMOVED******REMOVED***


class UserCreationForm(forms.ModelForm***REMOVED***:
    ***REMOVED***
    A form that creates a user, with no privileges, from the given username and
    password.
    ***REMOVED***
    error_messages = {
        'password_mismatch': _("The two password fields didn't match."***REMOVED***,
***REMOVED***
    password1 = forms.CharField(
        label=_("Password"***REMOVED***,
        strip=False,
        widget=forms.PasswordInput,
    ***REMOVED***
    password2 = forms.CharField(
        label=_("Password confirmation"***REMOVED***,
        widget=forms.PasswordInput,
        strip=False,
        help_text=_("Enter the same password as before, for verification."***REMOVED***,
    ***REMOVED***

    class Meta:
        model = User
        fields = ("username",***REMOVED***
        field_classes = {'username': UsernameField***REMOVED***

    def __init__(self, *args, **kwargs***REMOVED***:
        super(UserCreationForm, self***REMOVED***.__init__(*args, **kwargs***REMOVED***
        if self._meta.model.USERNAME_FIELD in self.fields:
            self.fields[self._meta.model.USERNAME_FIELD***REMOVED***.widget.attrs.update({'autofocus': ''***REMOVED******REMOVED***

    def clean_password2(self***REMOVED***:
        password1 = self.cleaned_data.get("password1"***REMOVED***
        password2 = self.cleaned_data.get("password2"***REMOVED***
        if password1 and password2 and password1 != password2:
            raise forms.ValidationError(
                self.error_messages['password_mismatch'***REMOVED***,
                code='password_mismatch',
            ***REMOVED***
        self.instance.username = self.cleaned_data.get('username'***REMOVED***
        password_validation.validate_password(self.cleaned_data.get('password2'***REMOVED***, self.instance***REMOVED***
        return password2

    def save(self, commit=True***REMOVED***:
        user = super(UserCreationForm, self***REMOVED***.save(commit=False***REMOVED***
        user.set_password(self.cleaned_data["password1"***REMOVED******REMOVED***
        if commit:
            user.save(***REMOVED***
        return user


class UserChangeForm(forms.ModelForm***REMOVED***:
    password = ReadOnlyPasswordHashField(
        label=_("Password"***REMOVED***,
        help_text=_(
            "Raw passwords are not stored, so there is no way to see this "
            "user's password, but you can change the password using "
            "<a href=\"../password/\">this form</a>."
        ***REMOVED***,
    ***REMOVED***

    class Meta:
        model = User
        fields = '__all__'
        field_classes = {'username': UsernameField***REMOVED***

    def __init__(self, *args, **kwargs***REMOVED***:
        super(UserChangeForm, self***REMOVED***.__init__(*args, **kwargs***REMOVED***
        f = self.fields.get('user_permissions'***REMOVED***
        if f is not None:
            f.queryset = f.queryset.select_related('content_type'***REMOVED***

    def clean_password(self***REMOVED***:
        # Regardless of what the user provides, return the initial value.
        # This is done here, rather than on the field, because the
        # field does not have access to the initial value
        return self.initial["password"***REMOVED***


class AuthenticationForm(forms.Form***REMOVED***:
    ***REMOVED***
    Base class for authenticating users. Extend this to get a form that accepts
    username/password logins.
    ***REMOVED***
    username = UsernameField(
        max_length=254,
        widget=forms.TextInput(attrs={'autofocus': ''***REMOVED******REMOVED***,
    ***REMOVED***
    password = forms.CharField(
        label=_("Password"***REMOVED***,
        strip=False,
        widget=forms.PasswordInput,
    ***REMOVED***

    error_messages = {
        'invalid_login': _(
            "Please enter a correct %(username***REMOVED***s and password. Note that both "
            "fields may be case-sensitive."
        ***REMOVED***,
        'inactive': _("This account is inactive."***REMOVED***,
***REMOVED***

    def __init__(self, request=None, *args, **kwargs***REMOVED***:
        ***REMOVED***
        The 'request' parameter is set for custom auth use by subclasses.
        The form data comes in via the standard 'data' kwarg.
        ***REMOVED***
        self.request = request
        self.user_cache = None
        super(AuthenticationForm, self***REMOVED***.__init__(*args, **kwargs***REMOVED***

        # Set the label for the "username" field.
        UserModel = get_user_model(***REMOVED***
        self.username_field = UserModel._meta.get_field(UserModel.USERNAME_FIELD***REMOVED***
        if self.fields['username'***REMOVED***.label is None:
            self.fields['username'***REMOVED***.label = capfirst(self.username_field.verbose_name***REMOVED***

    def clean(self***REMOVED***:
        username = self.cleaned_data.get('username'***REMOVED***
        password = self.cleaned_data.get('password'***REMOVED***

        if username and password:
            self.user_cache = authenticate(username=username, password=password***REMOVED***
            if self.user_cache is None:
                raise forms.ValidationError(
                    self.error_messages['invalid_login'***REMOVED***,
                    code='invalid_login',
                    params={'username': self.username_field.verbose_name***REMOVED***,
                ***REMOVED***
            else:
                self.confirm_login_allowed(self.user_cache***REMOVED***

        return self.cleaned_data

    def confirm_login_allowed(self, user***REMOVED***:
        ***REMOVED***
        Controls whether the given User may log in. This is a policy setting,
        independent of end-user authentication. This default behavior is to
        allow login by active users, and reject login by inactive users.

        If the given user cannot log in, this method should raise a
        ``forms.ValidationError``.

        If the given user may log in, this method should return None.
        ***REMOVED***
        if not user.is_active:
            raise forms.ValidationError(
                self.error_messages['inactive'***REMOVED***,
                code='inactive',
            ***REMOVED***

    def get_user_id(self***REMOVED***:
        if self.user_cache:
            return self.user_cache.id
        return None

    def get_user(self***REMOVED***:
        return self.user_cache


class PasswordResetForm(forms.Form***REMOVED***:
    email = forms.EmailField(label=_("Email"***REMOVED***, max_length=254***REMOVED***

    def send_mail(self, subject_template_name, email_template_name,
                  context, from_email, to_email, html_email_template_name=None***REMOVED***:
        ***REMOVED***
        Sends a django.core.mail.EmailMultiAlternatives to `to_email`.
        ***REMOVED***
        subject = loader.render_to_string(subject_template_name, context***REMOVED***
        # Email subject *must not* contain newlines
        subject = ''.join(subject.splitlines(***REMOVED******REMOVED***
        body = loader.render_to_string(email_template_name, context***REMOVED***

        email_message = EmailMultiAlternatives(subject, body, from_email, [to_email***REMOVED******REMOVED***
        if html_email_template_name is not None:
            html_email = loader.render_to_string(html_email_template_name, context***REMOVED***
            email_message.attach_alternative(html_email, 'text/html'***REMOVED***

        email_message.send(***REMOVED***

    def get_users(self, email***REMOVED***:
        ***REMOVED***Given an email, return matching user(s***REMOVED*** who should receive a reset.

        This allows subclasses to more easily customize the default policies
        that prevent inactive users and users with unusable passwords from
        resetting their password.
        ***REMOVED***
        active_users = get_user_model(***REMOVED***._default_manager.filter(
            email__iexact=email, is_active=True***REMOVED***
        return (u for u in active_users if u.has_usable_password(***REMOVED******REMOVED***

    def save(self, domain_override=None,
             subject_template_name='registration/password_reset_subject.txt',
             email_template_name='registration/password_reset_email.html',
             use_https=False, token_generator=default_token_generator,
             from_email=None, request=None, html_email_template_name=None,
             extra_email_context=None***REMOVED***:
        ***REMOVED***
        Generates a one-use only link for resetting password and sends to the
        user.
        ***REMOVED***
        email = self.cleaned_data["email"***REMOVED***
        for user in self.get_users(email***REMOVED***:
            if not domain_override:
                current_site = get_current_site(request***REMOVED***
                site_name = current_site.name
                domain = current_site.domain
            else:
                site_name = domain = domain_override
            context = {
                'email': user.email,
                'domain': domain,
                'site_name': site_name,
                'uid': urlsafe_base64_encode(force_bytes(user.pk***REMOVED******REMOVED***,
                'user': user,
                'token': token_generator.make_token(user***REMOVED***,
                'protocol': 'https' if use_https else 'http',
        ***REMOVED***
            if extra_email_context is not None:
                context.update(extra_email_context***REMOVED***
            self.send_mail(
                subject_template_name, email_template_name, context, from_email,
                user.email, html_email_template_name=html_email_template_name,
            ***REMOVED***


class SetPasswordForm(forms.Form***REMOVED***:
    ***REMOVED***
    A form that lets a user change set their password without entering the old
    password
    ***REMOVED***
    error_messages = {
        'password_mismatch': _("The two password fields didn't match."***REMOVED***,
***REMOVED***
    new_password1 = forms.CharField(
        label=_("New password"***REMOVED***,
        widget=forms.PasswordInput,
        strip=False,
        help_text=password_validation.password_validators_help_text_html(***REMOVED***,
    ***REMOVED***
    new_password2 = forms.CharField(
        label=_("New password confirmation"***REMOVED***,
        strip=False,
        widget=forms.PasswordInput,
    ***REMOVED***

    def __init__(self, user, *args, **kwargs***REMOVED***:
        self.user = user
        super(SetPasswordForm, self***REMOVED***.__init__(*args, **kwargs***REMOVED***

    def clean_new_password2(self***REMOVED***:
        password1 = self.cleaned_data.get('new_password1'***REMOVED***
        password2 = self.cleaned_data.get('new_password2'***REMOVED***
        if password1 and password2:
            if password1 != password2:
                raise forms.ValidationError(
                    self.error_messages['password_mismatch'***REMOVED***,
                    code='password_mismatch',
                ***REMOVED***
        password_validation.validate_password(password2, self.user***REMOVED***
        return password2

    def save(self, commit=True***REMOVED***:
        password = self.cleaned_data["new_password1"***REMOVED***
        self.user.set_password(password***REMOVED***
        if commit:
            self.user.save(***REMOVED***
        return self.user


class PasswordChangeForm(SetPasswordForm***REMOVED***:
    ***REMOVED***
    A form that lets a user change their password by entering their old
    password.
    ***REMOVED***
    error_messages = dict(SetPasswordForm.error_messages, **{
        'password_incorrect': _("Your old password was entered incorrectly. Please enter it again."***REMOVED***,
***REMOVED******REMOVED***
    old_password = forms.CharField(
        label=_("Old password"***REMOVED***,
        strip=False,
        widget=forms.PasswordInput(attrs={'autofocus': ''***REMOVED******REMOVED***,
    ***REMOVED***

    field_order = ['old_password', 'new_password1', 'new_password2'***REMOVED***

    def clean_old_password(self***REMOVED***:
        ***REMOVED***
        Validates that the old_password field is correct.
        ***REMOVED***
        old_password = self.cleaned_data["old_password"***REMOVED***
        if not self.user.check_password(old_password***REMOVED***:
            raise forms.ValidationError(
                self.error_messages['password_incorrect'***REMOVED***,
                code='password_incorrect',
            ***REMOVED***
        return old_password


class AdminPasswordChangeForm(forms.Form***REMOVED***:
    ***REMOVED***
    A form used to change the password of a user in the admin interface.
    ***REMOVED***
    error_messages = {
        'password_mismatch': _("The two password fields didn't match."***REMOVED***,
***REMOVED***
    required_css_class = 'required'
    password1 = forms.CharField(
        label=_("Password"***REMOVED***,
        widget=forms.PasswordInput(attrs={'autofocus': ''***REMOVED******REMOVED***,
        strip=False,
        help_text=password_validation.password_validators_help_text_html(***REMOVED***,
    ***REMOVED***
    password2 = forms.CharField(
        label=_("Password (again***REMOVED***"***REMOVED***,
        widget=forms.PasswordInput,
        strip=False,
        help_text=_("Enter the same password as before, for verification."***REMOVED***,
    ***REMOVED***

    def __init__(self, user, *args, **kwargs***REMOVED***:
        self.user = user
        super(AdminPasswordChangeForm, self***REMOVED***.__init__(*args, **kwargs***REMOVED***

    def clean_password2(self***REMOVED***:
        password1 = self.cleaned_data.get('password1'***REMOVED***
        password2 = self.cleaned_data.get('password2'***REMOVED***
        if password1 and password2:
            if password1 != password2:
                raise forms.ValidationError(
                    self.error_messages['password_mismatch'***REMOVED***,
                    code='password_mismatch',
                ***REMOVED***
        password_validation.validate_password(password2, self.user***REMOVED***
        return password2

    def save(self, commit=True***REMOVED***:
        ***REMOVED***
        Saves the new password.
        ***REMOVED***
        password = self.cleaned_data["password1"***REMOVED***
        self.user.set_password(password***REMOVED***
        if commit:
            self.user.save(***REMOVED***
        return self.user

    def _get_changed_data(self***REMOVED***:
        data = super(AdminPasswordChangeForm, self***REMOVED***.changed_data
        for name in self.fields.keys(***REMOVED***:
            if name not in data:
                return [***REMOVED***
        return ['password'***REMOVED***
    changed_data = property(_get_changed_data***REMOVED***
