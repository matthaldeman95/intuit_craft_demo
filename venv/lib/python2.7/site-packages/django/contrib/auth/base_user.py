***REMOVED***
This module allows importing AbstractBaseUser even when django.contrib.auth is
not in INSTALLED_APPS.
***REMOVED***
from __future__ import unicode_literals

import unicodedata

from django.contrib.auth import password_validation
from django.contrib.auth.hashers import (
    check_password, is_password_usable, make_password,
***REMOVED***
from django.db import models
***REMOVED***, salted_hmac
from django.utils.deprecation import CallableFalse, CallableTrue
from django.utils.encoding import force_text, python_2_unicode_compatible
from django.utils.translation import ugettext_lazy as _


class BaseUserManager(models.Manager***REMOVED***:

    @classmethod
    def normalize_email(cls, email***REMOVED***:
        ***REMOVED***
        Normalize the email address by lowercasing the domain part of it.
        ***REMOVED***
        email = email or ''
        ***REMOVED***
            email_name, domain_part = email.strip(***REMOVED***.rsplit('@', 1***REMOVED***
        except ValueError:
            pass
        else:
            email = '@'.join([email_name, domain_part.lower(***REMOVED******REMOVED******REMOVED***
        return email

    def make_random_password(self, length=10,
                             allowed_chars='abcdefghjkmnpqrstuvwxyz'
                                           'ABCDEFGHJKLMNPQRSTUVWXYZ'
                                           '23456789'***REMOVED***:
        ***REMOVED***
        Generate a random password with the given length and given
        allowed_chars. The default value of allowed_chars does not have "I" or
        "O" or letters and digits that look similar -- just to avoid confusion.
        ***REMOVED***
        return get_random_string(length, allowed_chars***REMOVED***

    def get_by_natural_key(self, username***REMOVED***:
        return self.get(**{self.model.USERNAME_FIELD: username***REMOVED******REMOVED***


@python_2_unicode_compatible
class AbstractBaseUser(models.Model***REMOVED***:
    password = models.CharField(_('password'***REMOVED***, max_length=128***REMOVED***
    last_login = models.DateTimeField(_('last login'***REMOVED***, blank=True, null=True***REMOVED***

    is_active = True

    REQUIRED_FIELDS = [***REMOVED***

    class Meta:
        abstract = True

    def get_username(self***REMOVED***:
        "Return the identifying username for this User"
        return getattr(self, self.USERNAME_FIELD***REMOVED***

    def __init__(self, *args, **kwargs***REMOVED***:
        super(AbstractBaseUser, self***REMOVED***.__init__(*args, **kwargs***REMOVED***
        # Stores the raw password if set_password(***REMOVED*** is called so that it can
        # be passed to password_changed(***REMOVED*** after the model is saved.
        self._password = None

    def __str__(self***REMOVED***:
        return self.get_username(***REMOVED***

    def clean(self***REMOVED***:
        setattr(self, self.USERNAME_FIELD, self.normalize_username(self.get_username(***REMOVED******REMOVED******REMOVED***

    def save(self, *args, **kwargs***REMOVED***:
        super(AbstractBaseUser, self***REMOVED***.save(*args, **kwargs***REMOVED***
        if self._password is not None:
            password_validation.password_changed(self._password, self***REMOVED***
            self._password = None

    def natural_key(self***REMOVED***:
        return (self.get_username(***REMOVED***,***REMOVED***

    @property
    def is_anonymous(self***REMOVED***:
        ***REMOVED***
        Always return False. This is a way of comparing User objects to
        anonymous users.
        ***REMOVED***
        return CallableFalse

    @property
    def is_authenticated(self***REMOVED***:
        ***REMOVED***
        Always return True. This is a way to tell if the user has been
        authenticated in templates.
        ***REMOVED***
        return CallableTrue

    def set_password(self, raw_password***REMOVED***:
        self.password = make_password(raw_password***REMOVED***
        self._password = raw_password

    def check_password(self, raw_password***REMOVED***:
        ***REMOVED***
        Return a boolean of whether the raw_password was correct. Handles
        hashing formats behind the scenes.
        ***REMOVED***
        def setter(raw_password***REMOVED***:
            self.set_password(raw_password***REMOVED***
            # Password hash upgrades shouldn't be considered password changes.
            self._password = None
            self.save(update_fields=["password"***REMOVED******REMOVED***
        return check_password(raw_password, self.password, setter***REMOVED***

    def set_unusable_password(self***REMOVED***:
        # Set a value that will never be a valid hash
        self.password = make_password(None***REMOVED***

    def has_usable_password(self***REMOVED***:
        return is_password_usable(self.password***REMOVED***

    def get_full_name(self***REMOVED***:
        raise NotImplementedError('subclasses of AbstractBaseUser must provide a get_full_name(***REMOVED*** method'***REMOVED***

    def get_short_name(self***REMOVED***:
        raise NotImplementedError('subclasses of AbstractBaseUser must provide a get_short_name(***REMOVED*** method.'***REMOVED***

    def get_session_auth_hash(self***REMOVED***:
        ***REMOVED***
        Return an HMAC of the password field.
        ***REMOVED***
        key_salt = "django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash"
        return salted_hmac(key_salt, self.password***REMOVED***.hexdigest(***REMOVED***

    @classmethod
    def normalize_username(cls, username***REMOVED***:
        return unicodedata.normalize('NFKC', force_text(username***REMOVED******REMOVED***
