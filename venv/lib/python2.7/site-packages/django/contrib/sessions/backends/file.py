import datetime
import errno
import logging
***REMOVED***
import shutil
import tempfile

from django.conf import settings
from django.contrib.sessions.backends.base import (
    VALID_KEY_CHARS, CreateError, SessionBase, UpdateError,
***REMOVED***
from django.contrib.sessions.exceptions import InvalidSessionKey
from django.core.exceptions import ImproperlyConfigured, SuspiciousOperation
from django.utils import timezone
from django.utils.encoding import force_text


class SessionStore(SessionBase***REMOVED***:
    ***REMOVED***
    Implements a file based session store.
    ***REMOVED***
    def __init__(self, session_key=None***REMOVED***:
        self.storage_path = type(self***REMOVED***._get_storage_path(***REMOVED***
        self.file_prefix = settings.SESSION_COOKIE_NAME
        super(SessionStore, self***REMOVED***.__init__(session_key***REMOVED***

    @classmethod
    def _get_storage_path(cls***REMOVED***:
        ***REMOVED***
            return cls._storage_path
        except AttributeError:
            storage_path = getattr(settings, "SESSION_FILE_PATH", None***REMOVED***
            if not storage_path:
                storage_path = tempfile.gettempdir(***REMOVED***

            # Make sure the storage path is valid.
            if not os.path.isdir(storage_path***REMOVED***:
                raise ImproperlyConfigured(
                    "The session storage path %r doesn't exist. Please set your"
                    " SESSION_FILE_PATH setting to an existing directory in which"
                    " Django can store session data." % storage_path***REMOVED***

            cls._storage_path = storage_path
            return storage_path

    def _key_to_file(self, session_key=None***REMOVED***:
        ***REMOVED***
        Get the file associated with this session key.
        ***REMOVED***
        if session_key is None:
            session_key = self._get_or_create_session_key(***REMOVED***

        # Make sure we're not vulnerable to directory traversal. Session keys
        # should always be md5s, so they should never contain directory
        # components.
        if not set(session_key***REMOVED***.issubset(set(VALID_KEY_CHARS***REMOVED******REMOVED***:
            raise InvalidSessionKey(
                "Invalid characters in session key"***REMOVED***

        return os.path.join(self.storage_path, self.file_prefix + session_key***REMOVED***

    def _last_modification(self***REMOVED***:
        ***REMOVED***
        Return the modification time of the file storing the session's content.
        ***REMOVED***
        modification = os.stat(self._key_to_file(***REMOVED******REMOVED***.st_mtime
        if settings.USE_TZ:
            modification = datetime.datetime.utcfromtimestamp(modification***REMOVED***
            modification = modification.replace(tzinfo=timezone.utc***REMOVED***
        else:
            modification = datetime.datetime.fromtimestamp(modification***REMOVED***
        return modification

    def _expiry_date(self, session_data***REMOVED***:
        ***REMOVED***
        Return the expiry time of the file storing the session's content.
        ***REMOVED***
        expiry = session_data.get('_session_expiry'***REMOVED***
        if not expiry:
            expiry = self._last_modification(***REMOVED*** + datetime.timedelta(seconds=settings.SESSION_COOKIE_AGE***REMOVED***
        return expiry

    def load(self***REMOVED***:
        session_data = {***REMOVED***
        ***REMOVED***
            with open(self._key_to_file(***REMOVED***, "rb"***REMOVED*** as session_file:
                file_data = session_file.read(***REMOVED***
            # Don't fail if there is no data in the session file.
            # We may have opened the empty placeholder file.
            if file_data:
                ***REMOVED***
                    session_data = self.decode(file_data***REMOVED***
                except (EOFError, SuspiciousOperation***REMOVED*** as e:
                    if isinstance(e, SuspiciousOperation***REMOVED***:
                        logger = logging.getLogger('django.security.%s' % e.__class__.__name__***REMOVED***
                        logger.warning(force_text(e***REMOVED******REMOVED***
                    self.create(***REMOVED***

                # Remove expired sessions.
                expiry_age = self.get_expiry_age(expiry=self._expiry_date(session_data***REMOVED******REMOVED***
                if expiry_age <= 0:
                    session_data = {***REMOVED***
                    self.delete(***REMOVED***
                    self.create(***REMOVED***
        except (IOError, SuspiciousOperation***REMOVED***:
            self._session_key = None
        return session_data

    def create(self***REMOVED***:
        while True:
            self._session_key = self._get_new_session_key(***REMOVED***
            ***REMOVED***
                self.save(must_create=True***REMOVED***
            except CreateError:
                continue
            self.modified = True
            return

    def save(self, must_create=False***REMOVED***:
        if self.session_key is None:
            return self.create(***REMOVED***
        # Get the session data now, before we start messing
        # with the file it is stored within.
        session_data = self._get_session(no_load=must_create***REMOVED***

        session_file_name = self._key_to_file(***REMOVED***

        ***REMOVED***
            # Make sure the file exists.  If it does not already exist, an
            # empty placeholder file is created.
            flags = os.O_WRONLY | getattr(os, 'O_BINARY', 0***REMOVED***
            if must_create:
                flags |= os.O_EXCL | os.O_CREAT
            fd = os.open(session_file_name, flags***REMOVED***
            os.close(fd***REMOVED***

        except OSError as e:
            if must_create and e.errno == errno.EEXIST:
                raise CreateError
            if not must_create and e.errno == errno.ENOENT:
                raise UpdateError
            raise

        # Write the session file without interfering with other threads
        # or processes.  By writing to an atomically generated temporary
        # file and then using the atomic os.rename(***REMOVED*** to make the complete
        # file visible, we avoid having to lock the session file, while
        # still maintaining its integrity.
        #
        # Note: Locking the session file was explored, but rejected in part
        # because in order to be atomic and cross-platform, it required a
        # long-lived lock file for each session, doubling the number of
        # files in the session storage directory at any given time.  This
        # rename solution is cleaner and avoids any additional overhead
        # when reading the session data, which is the more common case
        # unless SESSION_SAVE_EVERY_REQUEST = True.
        #
        # See ticket #8616.
        dir, prefix = os.path.split(session_file_name***REMOVED***

        ***REMOVED***
            output_file_fd, output_file_name = tempfile.mkstemp(dir=dir, prefix=prefix + '_out_'***REMOVED***
            renamed = False
            ***REMOVED***
                ***REMOVED***
                    os.write(output_file_fd, self.encode(session_data***REMOVED***.encode(***REMOVED******REMOVED***
                finally:
                    os.close(output_file_fd***REMOVED***

                # This will atomically rename the file (os.rename***REMOVED*** if the OS
                # supports it. Otherwise this will result in a shutil.copy2
                # and os.unlink (for example on Windows***REMOVED***. See #9084.
                shutil.move(output_file_name, session_file_name***REMOVED***
                renamed = True
            finally:
                if not renamed:
                    os.unlink(output_file_name***REMOVED***

        except (OSError, IOError, EOFError***REMOVED***:
            pass

    def exists(self, session_key***REMOVED***:
        return os.path.exists(self._key_to_file(session_key***REMOVED******REMOVED***

    def delete(self, session_key=None***REMOVED***:
        if session_key is None:
            if self.session_key is None:
                return
            session_key = self.session_key
        ***REMOVED***
            os.unlink(self._key_to_file(session_key***REMOVED******REMOVED***
        except OSError:
            pass

    def clean(self***REMOVED***:
        pass

    @classmethod
    def clear_expired(cls***REMOVED***:
        storage_path = cls._get_storage_path(***REMOVED***
        file_prefix = settings.SESSION_COOKIE_NAME

        for session_file in os.listdir(storage_path***REMOVED***:
            if not session_file.startswith(file_prefix***REMOVED***:
                continue
            session_key = session_file[len(file_prefix***REMOVED***:***REMOVED***
            session = cls(session_key***REMOVED***
            # When an expired session is loaded, its file is removed, and a
            # new file is immediately created. Prevent this by disabling
            # the create(***REMOVED*** method.
            session.create = lambda: None
            session.load(***REMOVED***
