import logging

from django.contrib.sessions.backends.base import (
    CreateError, SessionBase, UpdateError,
***REMOVED***
from django.core.exceptions import SuspiciousOperation
from django.db import DatabaseError, IntegrityError, router, transaction
from django.utils import timezone
from django.utils.encoding import force_text
from django.utils.functional import cached_property


class SessionStore(SessionBase***REMOVED***:
    ***REMOVED***
    Implements database session store.
    ***REMOVED***
    def __init__(self, session_key=None***REMOVED***:
        super(SessionStore, self***REMOVED***.__init__(session_key***REMOVED***

    @classmethod
    def get_model_class(cls***REMOVED***:
        # Avoids a circular import and allows importing SessionStore when
        # django.contrib.sessions is not in INSTALLED_APPS.
        from django.contrib.sessions.models import Session
        return Session

    @cached_property
    def model(self***REMOVED***:
        return self.get_model_class(***REMOVED***

    def load(self***REMOVED***:
        ***REMOVED***
            s = self.model.objects.get(
                session_key=self.session_key,
                expire_date__gt=timezone.now(***REMOVED***
            ***REMOVED***
            return self.decode(s.session_data***REMOVED***
        except (self.model.DoesNotExist, SuspiciousOperation***REMOVED*** as e:
            if isinstance(e, SuspiciousOperation***REMOVED***:
                logger = logging.getLogger('django.security.%s' % e.__class__.__name__***REMOVED***
                logger.warning(force_text(e***REMOVED******REMOVED***
            self._session_key = None
            return {***REMOVED***

    def exists(self, session_key***REMOVED***:
        return self.model.objects.filter(session_key=session_key***REMOVED***.exists(***REMOVED***

    def create(self***REMOVED***:
        while True:
            self._session_key = self._get_new_session_key(***REMOVED***
            ***REMOVED***
                # Save immediately to ensure we have a unique entry in the
                # database.
                self.save(must_create=True***REMOVED***
            except CreateError:
                # Key wasn't unique. Try again.
                continue
            self.modified = True
            return

    def create_model_instance(self, data***REMOVED***:
        ***REMOVED***
        Return a new instance of the session model object, which represents the
        current session state. Intended to be used for saving the session data
        to the database.
        ***REMOVED***
        return self.model(
            session_key=self._get_or_create_session_key(***REMOVED***,
            session_data=self.encode(data***REMOVED***,
            expire_date=self.get_expiry_date(***REMOVED***,
        ***REMOVED***

    def save(self, must_create=False***REMOVED***:
        ***REMOVED***
        Saves the current session data to the database. If 'must_create' is
        True, a database error will be raised if the saving operation doesn't
        create a *new* entry (as opposed to possibly updating an existing
        entry***REMOVED***.
        ***REMOVED***
        if self.session_key is None:
            return self.create(***REMOVED***
        data = self._get_session(no_load=must_create***REMOVED***
        obj = self.create_model_instance(data***REMOVED***
        using = router.db_for_write(self.model, instance=obj***REMOVED***
        ***REMOVED***
            with transaction.atomic(using=using***REMOVED***:
                obj.save(force_insert=must_create, force_update=not must_create, using=using***REMOVED***
        except IntegrityError:
            if must_create:
                raise CreateError
            raise
        except DatabaseError:
            if not must_create:
                raise UpdateError
            raise

    def delete(self, session_key=None***REMOVED***:
        if session_key is None:
            if self.session_key is None:
                return
            session_key = self.session_key
        ***REMOVED***
            self.model.objects.get(session_key=session_key***REMOVED***.delete(***REMOVED***
        except self.model.DoesNotExist:
            pass

    @classmethod
    def clear_expired(cls***REMOVED***:
        cls.get_model_class(***REMOVED***.objects.filter(expire_date__lt=timezone.now(***REMOVED******REMOVED***.delete(***REMOVED***
