***REMOVED***
This module allows importing AbstractBaseSession even
when django.contrib.sessions is not in INSTALLED_APPS.
***REMOVED***
from __future__ import unicode_literals

from django.db import models
from django.utils.encoding import python_2_unicode_compatible
from django.utils.translation import ugettext_lazy as _


class BaseSessionManager(models.Manager***REMOVED***:
    def encode(self, session_dict***REMOVED***:
        ***REMOVED***
        Return the given session dictionary serialized and encoded as a string.
        ***REMOVED***
        session_store_class = self.model.get_session_store_class(***REMOVED***
        return session_store_class(***REMOVED***.encode(session_dict***REMOVED***

    def save(self, session_key, session_dict, expire_date***REMOVED***:
        s = self.model(session_key, self.encode(session_dict***REMOVED***, expire_date***REMOVED***
        if session_dict:
            s.save(***REMOVED***
        else:
            s.delete(***REMOVED***  # Clear sessions with no data.
        return s


@python_2_unicode_compatible
class AbstractBaseSession(models.Model***REMOVED***:
    session_key = models.CharField(_('session key'***REMOVED***, max_length=40, primary_key=True***REMOVED***
    session_data = models.TextField(_('session data'***REMOVED******REMOVED***
    expire_date = models.DateTimeField(_('expire date'***REMOVED***, db_index=True***REMOVED***

    objects = BaseSessionManager(***REMOVED***

    class Meta:
        abstract = True
        verbose_name = _('session'***REMOVED***
        verbose_name_plural = _('sessions'***REMOVED***

    def __str__(self***REMOVED***:
        return self.session_key

    @classmethod
    def get_session_store_class(cls***REMOVED***:
        raise NotImplementedError

    def get_decoded(self***REMOVED***:
        session_store_class = self.get_session_store_class(***REMOVED***
        return session_store_class(***REMOVED***.decode(self.session_data***REMOVED***
