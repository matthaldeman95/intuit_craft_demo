import json

from django.conf import settings
from django.contrib.messages.storage.base import BaseStorage, Message
from django.http import SimpleCookie
from django.utils import six
from django.utils.crypto import constant_time_compare, salted_hmac
from django.utils.safestring import SafeData, mark_safe


class MessageEncoder(json.JSONEncoder***REMOVED***:
    ***REMOVED***
    Compactly serializes instances of the ``Message`` class as JSON.
    ***REMOVED***
    message_key = '__json_message'

    def default(self, obj***REMOVED***:
        if isinstance(obj, Message***REMOVED***:
            # Using 0/1 here instead of False/True to produce more compact json
            is_safedata = 1 if isinstance(obj.message, SafeData***REMOVED*** else 0
            message = [self.message_key, is_safedata, obj.level, obj.message***REMOVED***
            if obj.extra_tags:
                message.append(obj.extra_tags***REMOVED***
            return message
        return super(MessageEncoder, self***REMOVED***.default(obj***REMOVED***


class MessageDecoder(json.JSONDecoder***REMOVED***:
    ***REMOVED***
    Decodes JSON that includes serialized ``Message`` instances.
    ***REMOVED***

    def process_messages(self, obj***REMOVED***:
        if isinstance(obj, list***REMOVED*** and obj:
            if obj[0***REMOVED*** == MessageEncoder.message_key:
                if len(obj***REMOVED*** == 3:
                    # Compatibility with previously-encoded messages
                    return Message(*obj[1:***REMOVED******REMOVED***
                if obj[1***REMOVED***:
                    obj[3***REMOVED*** = mark_safe(obj[3***REMOVED******REMOVED***
                return Message(*obj[2:***REMOVED******REMOVED***
            return [self.process_messages(item***REMOVED*** for item in obj***REMOVED***
        if isinstance(obj, dict***REMOVED***:
            return {key: self.process_messages(value***REMOVED***
                    for key, value in six.iteritems(obj***REMOVED******REMOVED***
        return obj

    def decode(self, s, **kwargs***REMOVED***:
        decoded = super(MessageDecoder, self***REMOVED***.decode(s, **kwargs***REMOVED***
        return self.process_messages(decoded***REMOVED***


class CookieStorage(BaseStorage***REMOVED***:
    ***REMOVED***
    Stores messages in a cookie.
    ***REMOVED***
    cookie_name = 'messages'
    # uwsgi's default configuration enforces a maximum size of 4kb for all the
    # HTTP headers. In order to leave some room for other cookies and headers,
    # restrict the session cookie to 1/2 of 4kb. See #18781.
    max_cookie_size = 2048
    not_finished = '__messagesnotfinished__'

    def _get(self, *args, **kwargs***REMOVED***:
        ***REMOVED***
        Retrieves a list of messages from the messages cookie.  If the
        not_finished sentinel value is found at the end of the message list,
        remove it and return a result indicating that not all messages were
        retrieved by this storage.
        ***REMOVED***
        data = self.request.COOKIES.get(self.cookie_name***REMOVED***
        messages = self._decode(data***REMOVED***
        all_retrieved = not (messages and messages[-1***REMOVED*** == self.not_finished***REMOVED***
        if messages and not all_retrieved:
            # remove the sentinel value
            messages.pop(***REMOVED***
        return messages, all_retrieved

    def _update_cookie(self, encoded_data, response***REMOVED***:
        ***REMOVED***
        Either sets the cookie with the encoded data if there is any data to
        store, or deletes the cookie.
        ***REMOVED***
        if encoded_data:
            response.set_cookie(
                self.cookie_name, encoded_data,
                domain=settings.SESSION_COOKIE_DOMAIN,
                secure=settings.SESSION_COOKIE_SECURE or None,
                httponly=settings.SESSION_COOKIE_HTTPONLY or None,
            ***REMOVED***
        else:
            response.delete_cookie(self.cookie_name, domain=settings.SESSION_COOKIE_DOMAIN***REMOVED***

    def _store(self, messages, response, remove_oldest=True, *args, **kwargs***REMOVED***:
        ***REMOVED***
        Stores the messages to a cookie, returning a list of any messages which
        could not be stored.

        If the encoded data is larger than ``max_cookie_size``, removes
        messages until the data fits (these are the messages which are
        returned***REMOVED***, and add the not_finished sentinel value to indicate as much.
        ***REMOVED***
        unstored_messages = [***REMOVED***
        encoded_data = self._encode(messages***REMOVED***
        if self.max_cookie_size:
            # data is going to be stored eventually by SimpleCookie, which
            # adds its own overhead, which we must account for.
            cookie = SimpleCookie(***REMOVED***  # create outside the loop

            def stored_length(val***REMOVED***:
                return len(cookie.value_encode(val***REMOVED***[1***REMOVED******REMOVED***

            while encoded_data and stored_length(encoded_data***REMOVED*** > self.max_cookie_size:
                if remove_oldest:
                    unstored_messages.append(messages.pop(0***REMOVED******REMOVED***
                else:
                    unstored_messages.insert(0, messages.pop(***REMOVED******REMOVED***
                encoded_data = self._encode(messages + [self.not_finished***REMOVED***,
                                            encode_empty=unstored_messages***REMOVED***
        self._update_cookie(encoded_data, response***REMOVED***
        return unstored_messages

    def _hash(self, value***REMOVED***:
        ***REMOVED***
        Creates an HMAC/SHA1 hash based on the value and the project setting's
        SECRET_KEY, modified to make it unique for the present purpose.
        ***REMOVED***
        key_salt = 'django.contrib.messages'
        return salted_hmac(key_salt, value***REMOVED***.hexdigest(***REMOVED***

    def _encode(self, messages, encode_empty=False***REMOVED***:
        ***REMOVED***
        Returns an encoded version of the messages list which can be stored as
        plain text.

        Since the data will be retrieved from the client-side, the encoded data
        also contains a hash to ensure that the data was not tampered with.
        ***REMOVED***
        if messages or encode_empty:
            encoder = MessageEncoder(separators=(',', ':'***REMOVED******REMOVED***
            value = encoder.encode(messages***REMOVED***
            return '%s$%s' % (self._hash(value***REMOVED***, value***REMOVED***

    def _decode(self, data***REMOVED***:
        ***REMOVED***
        Safely decodes an encoded text stream back into a list of messages.

        If the encoded text stream contained an invalid hash or was in an
        invalid format, ``None`` is returned.
        ***REMOVED***
        if not data:
            return None
        bits = data.split('$', 1***REMOVED***
        if len(bits***REMOVED*** == 2:
            hash, value = bits
            if constant_time_compare(hash, self._hash(value***REMOVED******REMOVED***:
                ***REMOVED***
                    # If we get here (and the JSON decode works***REMOVED***, everything is
                    # good. In any other case, drop back and return None.
                    return json.loads(value, cls=MessageDecoder***REMOVED***
                except ValueError:
                    pass
        # Mark the data as used (so it gets removed***REMOVED*** since something was wrong
        # with the data.
        self.used = True
        return None
