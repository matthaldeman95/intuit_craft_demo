from __future__ import unicode_literals

from django.conf import settings
from django.contrib.messages import constants, utils
from django.utils.encoding import force_text, python_2_unicode_compatible

LEVEL_TAGS = utils.get_level_tags(***REMOVED***


@python_2_unicode_compatible
class Message(object***REMOVED***:
    ***REMOVED***
    Represents an actual message that can be stored in any of the supported
    storage classes (typically session- or cookie-based***REMOVED*** and rendered in a view
    or template.
    ***REMOVED***

    def __init__(self, level, message, extra_tags=None***REMOVED***:
        self.level = int(level***REMOVED***
        self.message = message
        self.extra_tags = extra_tags

    def _prepare(self***REMOVED***:
        ***REMOVED***
        Prepares the message for serialization by forcing the ``message``
        and ``extra_tags`` to unicode in case they are lazy translations.

        Known "safe" types (None, int, etc.***REMOVED*** are not converted (see Django's
        ``force_text`` implementation for details***REMOVED***.
        ***REMOVED***
        self.message = force_text(self.message, strings_only=True***REMOVED***
        self.extra_tags = force_text(self.extra_tags, strings_only=True***REMOVED***

    def __eq__(self, other***REMOVED***:
        return isinstance(other, Message***REMOVED*** and self.level == other.level and \
            self.message == other.message

    def __str__(self***REMOVED***:
        return force_text(self.message***REMOVED***

    def _get_tags(self***REMOVED***:
        extra_tags = force_text(self.extra_tags, strings_only=True***REMOVED***
        if extra_tags and self.level_tag:
            return ' '.join([extra_tags, self.level_tag***REMOVED******REMOVED***
        elif extra_tags:
            return extra_tags
        elif self.level_tag:
            return self.level_tag
        return ''
    tags = property(_get_tags***REMOVED***

    @property
    def level_tag(self***REMOVED***:
        return force_text(LEVEL_TAGS.get(self.level, ''***REMOVED***, strings_only=True***REMOVED***


class BaseStorage(object***REMOVED***:
    ***REMOVED***
    This is the base backend for temporary message storage.

    This is not a complete class; to be a usable storage backend, it must be
    subclassed and the two methods ``_get`` and ``_store`` overridden.
    ***REMOVED***

    def __init__(self, request, *args, **kwargs***REMOVED***:
        self.request = request
        self._queued_messages = [***REMOVED***
        self.used = False
        self.added_new = False
        super(BaseStorage, self***REMOVED***.__init__(*args, **kwargs***REMOVED***

    def __len__(self***REMOVED***:
        return len(self._loaded_messages***REMOVED*** + len(self._queued_messages***REMOVED***

    def __iter__(self***REMOVED***:
        self.used = True
        if self._queued_messages:
            self._loaded_messages.extend(self._queued_messages***REMOVED***
            self._queued_messages = [***REMOVED***
        return iter(self._loaded_messages***REMOVED***

    def __contains__(self, item***REMOVED***:
        return item in self._loaded_messages or item in self._queued_messages

    @property
    def _loaded_messages(self***REMOVED***:
        ***REMOVED***
        Returns a list of loaded messages, retrieving them first if they have
        not been loaded yet.
        ***REMOVED***
        if not hasattr(self, '_loaded_data'***REMOVED***:
            messages, all_retrieved = self._get(***REMOVED***
            self._loaded_data = messages or [***REMOVED***
        return self._loaded_data

    def _get(self, *args, **kwargs***REMOVED***:
        ***REMOVED***
        Retrieves a list of stored messages. Returns a tuple of the messages
        and a flag indicating whether or not all the messages originally
        intended to be stored in this storage were, in fact, stored and
        retrieved; e.g., ``(messages, all_retrieved***REMOVED***``.

        **This method must be implemented by a subclass.**

        If it is possible to tell if the backend was not used (as opposed to
        just containing no messages***REMOVED*** then ``None`` should be returned in
        place of ``messages``.
        ***REMOVED***
        raise NotImplementedError('subclasses of BaseStorage must provide a _get(***REMOVED*** method'***REMOVED***

    def _store(self, messages, response, *args, **kwargs***REMOVED***:
        ***REMOVED***
        Stores a list of messages, returning a list of any messages which could
        not be stored.

        One type of object must be able to be stored, ``Message``.

        **This method must be implemented by a subclass.**
        ***REMOVED***
        raise NotImplementedError('subclasses of BaseStorage must provide a _store(***REMOVED*** method'***REMOVED***

    def _prepare_messages(self, messages***REMOVED***:
        ***REMOVED***
        Prepares a list of messages for storage.
        ***REMOVED***
        for message in messages:
            message._prepare(***REMOVED***

    def update(self, response***REMOVED***:
        ***REMOVED***
        Stores all unread messages.

        If the backend has yet to be iterated, previously stored messages will
        be stored again. Otherwise, only messages added after the last
        iteration will be stored.
        ***REMOVED***
        self._prepare_messages(self._queued_messages***REMOVED***
        if self.used:
            return self._store(self._queued_messages, response***REMOVED***
        elif self.added_new:
            messages = self._loaded_messages + self._queued_messages
            return self._store(messages, response***REMOVED***

    def add(self, level, message, extra_tags=''***REMOVED***:
        ***REMOVED***
        Queues a message to be stored.

        The message is only queued if it contained something and its level is
        not less than the recording level (``self.level``***REMOVED***.
        ***REMOVED***
        if not message:
            return
        # Check that the message level is not less than the recording level.
        level = int(level***REMOVED***
        if level < self.level:
            return
        # Add the message.
        self.added_new = True
        message = Message(level, message, extra_tags=extra_tags***REMOVED***
        self._queued_messages.append(message***REMOVED***

    def _get_level(self***REMOVED***:
        ***REMOVED***
        Returns the minimum recorded level.

        The default level is the ``MESSAGE_LEVEL`` setting. If this is
        not found, the ``INFO`` level is used.
        ***REMOVED***
        if not hasattr(self, '_level'***REMOVED***:
            self._level = getattr(settings, 'MESSAGE_LEVEL', constants.INFO***REMOVED***
        return self._level

    def _set_level(self, value=None***REMOVED***:
        ***REMOVED***
        Sets a custom minimum recorded level.

        If set to ``None``, the default level will be used (see the
        ``_get_level`` method***REMOVED***.
        ***REMOVED***
        if value is None and hasattr(self, '_level'***REMOVED***:
            del self._level
        else:
            self._level = int(value***REMOVED***

    level = property(_get_level, _set_level, _set_level***REMOVED***
