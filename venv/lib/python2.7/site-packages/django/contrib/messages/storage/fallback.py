from django.contrib.messages.storage.base import BaseStorage
from django.contrib.messages.storage.cookie import CookieStorage
from django.contrib.messages.storage.session import SessionStorage


class FallbackStorage(BaseStorage***REMOVED***:
    ***REMOVED***
    Tries to store all messages in the first backend, storing any unstored
    messages in each subsequent backend backend.
    ***REMOVED***
    storage_classes = (CookieStorage, SessionStorage***REMOVED***

    def __init__(self, *args, **kwargs***REMOVED***:
        super(FallbackStorage, self***REMOVED***.__init__(*args, **kwargs***REMOVED***
        self.storages = [storage_class(*args, **kwargs***REMOVED***
                         for storage_class in self.storage_classes***REMOVED***
        self._used_storages = set(***REMOVED***

    def _get(self, *args, **kwargs***REMOVED***:
        ***REMOVED***
        Gets a single list of messages from all storage backends.
        ***REMOVED***
        all_messages = [***REMOVED***
        for storage in self.storages:
            messages, all_retrieved = storage._get(***REMOVED***
            # If the backend hasn't been used, no more retrieval is necessary.
            if messages is None:
                break
            if messages:
                self._used_storages.add(storage***REMOVED***
            all_messages.extend(messages***REMOVED***
            # If this storage class contained all the messages, no further
            # retrieval is necessary
            if all_retrieved:
                break
        return all_messages, all_retrieved

    def _store(self, messages, response, *args, **kwargs***REMOVED***:
        ***REMOVED***
        Stores the messages, returning any unstored messages after trying all
        backends.

        For each storage backend, any messages not stored are passed on to the
        next backend.
        ***REMOVED***
        for storage in self.storages:
            if messages:
                messages = storage._store(messages, response,
                                          remove_oldest=False***REMOVED***
            # Even if there are no more messages, continue iterating to ensure
            # storages which contained messages are flushed.
            elif storage in self._used_storages:
                storage._store([***REMOVED***, response***REMOVED***
                self._used_storages.remove(storage***REMOVED***
        return messages
