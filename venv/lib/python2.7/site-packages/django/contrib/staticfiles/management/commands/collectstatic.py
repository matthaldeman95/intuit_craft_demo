from __future__ import unicode_literals

***REMOVED***
from collections import OrderedDict

from django.apps import apps
from django.contrib.staticfiles.finders import get_finders
from django.contrib.staticfiles.storage import staticfiles_storage
from django.core.files.storage import FileSystemStorage
from django.core.management.base import BaseCommand, CommandError
from django.core.management.color import no_style
from django.utils.encoding import smart_text
from django.utils.functional import cached_property
from django.utils.six.moves import input


class Command(BaseCommand***REMOVED***:
    ***REMOVED***
    Command that allows to copy or symlink static files from different
    locations to the settings.STATIC_ROOT.
    ***REMOVED***
    help = "Collect static files in a single location."
    requires_system_checks = False

    def __init__(self, *args, **kwargs***REMOVED***:
        super(Command, self***REMOVED***.__init__(*args, **kwargs***REMOVED***
        self.copied_files = [***REMOVED***
        self.symlinked_files = [***REMOVED***
        self.unmodified_files = [***REMOVED***
        self.post_processed_files = [***REMOVED***
        self.storage = staticfiles_storage
        self.style = no_style(***REMOVED***

    @cached_property
    def local(self***REMOVED***:
        ***REMOVED***
            self.storage.path(''***REMOVED***
        except NotImplementedError:
            return False
        return True

    def add_arguments(self, parser***REMOVED***:
        parser.add_argument(
            '--noinput', '--no-input',
            action='store_false', dest='interactive', default=True,
            help="Do NOT prompt the user for input of any kind.",
        ***REMOVED***
        parser.add_argument(
            '--no-post-process',
            action='store_false', dest='post_process', default=True,
            help="Do NOT post process collected files.",
        ***REMOVED***
        parser.add_argument(
            '-i', '--ignore', action='append', default=[***REMOVED***,
            dest='ignore_patterns', metavar='PATTERN',
            help="Ignore files or directories matching this glob-style "
                 "pattern. Use multiple times to ignore more.",
        ***REMOVED***
        parser.add_argument(
            '-n', '--dry-run',
            action='store_true', dest='dry_run', default=False,
            help="Do everything except modify the filesystem.",
        ***REMOVED***
        parser.add_argument(
            '-c', '--clear',
            action='store_true', dest='clear', default=False,
            help="Clear the existing files using the storage "
                 "before trying to copy or link the original file.",
        ***REMOVED***
        parser.add_argument(
            '-l', '--link',
            action='store_true', dest='link', default=False,
            help="Create a symbolic link to each file instead of copying.",
        ***REMOVED***
        parser.add_argument(
            '--no-default-ignore', action='store_false',
            dest='use_default_ignore_patterns', default=True,
            help="Don't ignore the common private glob-style patterns (defaults to 'CVS', '.*' and '*~'***REMOVED***.",
        ***REMOVED***

    def set_options(self, **options***REMOVED***:
        ***REMOVED***
        Set instance variables based on an options dict
        ***REMOVED***
        self.interactive = options['interactive'***REMOVED***
        self.verbosity = options['verbosity'***REMOVED***
        self.symlink = options['link'***REMOVED***
        self.clear = options['clear'***REMOVED***
        self.dry_run = options['dry_run'***REMOVED***
        ignore_patterns = options['ignore_patterns'***REMOVED***
        if options['use_default_ignore_patterns'***REMOVED***:
            ignore_patterns += apps.get_app_config('staticfiles'***REMOVED***.ignore_patterns
        self.ignore_patterns = list(set(ignore_patterns***REMOVED******REMOVED***
        self.post_process = options['post_process'***REMOVED***

    def collect(self***REMOVED***:
        ***REMOVED***
        Perform the bulk of the work of collectstatic.

        Split off from handle(***REMOVED*** to facilitate testing.
        ***REMOVED***
        if self.symlink and not self.local:
            raise CommandError("Can't symlink to a remote destination."***REMOVED***

        if self.clear:
            self.clear_dir(''***REMOVED***

        if self.symlink:
            handler = self.link_file
        else:
            handler = self.copy_file

        found_files = OrderedDict(***REMOVED***
        for finder in get_finders(***REMOVED***:
            for path, storage in finder.list(self.ignore_patterns***REMOVED***:
                # Prefix the relative path if the source storage contains it
                if getattr(storage, 'prefix', None***REMOVED***:
                    prefixed_path = os.path.join(storage.prefix, path***REMOVED***
                else:
                    prefixed_path = path

                if prefixed_path not in found_files:
                    found_files[prefixed_path***REMOVED*** = (storage, path***REMOVED***
                    handler(path, prefixed_path, storage***REMOVED***
                else:
                    self.log(
                        "Found another file with the destination path '%s'. It "
                        "will be ignored since only the first encountered file "
                        "is collected. If this is not what you want, make sure "
                        "every static file has a unique path." % prefixed_path,
                        level=1,
                    ***REMOVED***

        # Here we check if the storage backend has a post_process
        # method and pass it the list of modified files.
        if self.post_process and hasattr(self.storage, 'post_process'***REMOVED***:
            processor = self.storage.post_process(found_files,
                                                  dry_run=self.dry_run***REMOVED***
            for original_path, processed_path, processed in processor:
                if isinstance(processed, Exception***REMOVED***:
                    self.stderr.write("Post-processing '%s' failed!" % original_path***REMOVED***
                    # Add a blank line before the traceback, otherwise it's
                    # too easy to miss the relevant part of the error message.
                    self.stderr.write(""***REMOVED***
                    raise processed
                if processed:
                    self.log("Post-processed '%s' as '%s'" %
                             (original_path, processed_path***REMOVED***, level=1***REMOVED***
                    self.post_processed_files.append(original_path***REMOVED***
                else:
                    self.log("Skipped post-processing '%s'" % original_path***REMOVED***

        return {
            'modified': self.copied_files + self.symlinked_files,
            'unmodified': self.unmodified_files,
            'post_processed': self.post_processed_files,
    ***REMOVED***

    def handle(self, **options***REMOVED***:
        self.set_options(**options***REMOVED***

        message = ['\n'***REMOVED***
        if self.dry_run:
            message.append(
                'You have activated the --dry-run option so no files will be modified.\n\n'
            ***REMOVED***

        message.append(
            'You have requested to collect static files at the destination\n'
            'location as specified in your settings'
        ***REMOVED***

        if self.is_local_storage(***REMOVED*** and self.storage.location:
            destination_path = self.storage.location
            message.append(':\n\n    %s\n\n' % destination_path***REMOVED***
        else:
            destination_path = None
            message.append('.\n\n'***REMOVED***

        if self.clear:
            message.append('This will DELETE ALL FILES in this location!\n'***REMOVED***
        else:
            message.append('This will overwrite existing files!\n'***REMOVED***

        message.append(
            'Are you sure you want to do this?\n\n'
            "Type 'yes' to continue, or 'no' to cancel: "
        ***REMOVED***

        if self.interactive and input(''.join(message***REMOVED******REMOVED*** != 'yes':
            raise CommandError("Collecting static files cancelled."***REMOVED***

        collected = self.collect(***REMOVED***
        modified_count = len(collected['modified'***REMOVED******REMOVED***
        unmodified_count = len(collected['unmodified'***REMOVED******REMOVED***
        post_processed_count = len(collected['post_processed'***REMOVED******REMOVED***

        if self.verbosity >= 1:
            template = ("\n%(modified_count***REMOVED***s %(identifier***REMOVED***s %(action***REMOVED***s"
                        "%(destination***REMOVED***s%(unmodified***REMOVED***s%(post_processed***REMOVED***s.\n"***REMOVED***
            summary = template % {
                'modified_count': modified_count,
                'identifier': 'static file' + ('' if modified_count == 1 else 's'***REMOVED***,
                'action': 'symlinked' if self.symlink else 'copied',
                'destination': (" to '%s'" % destination_path if destination_path else ''***REMOVED***,
                'unmodified': (', %s unmodified' % unmodified_count if collected['unmodified'***REMOVED*** else ''***REMOVED***,
                'post_processed': (collected['post_processed'***REMOVED*** and
                                   ', %s post-processed'
                                   % post_processed_count or ''***REMOVED***,
        ***REMOVED***
            return summary

    def log(self, msg, level=2***REMOVED***:
        ***REMOVED***
        Small log helper
        ***REMOVED***
        if self.verbosity >= level:
            self.stdout.write(msg***REMOVED***

    def is_local_storage(self***REMOVED***:
        return isinstance(self.storage, FileSystemStorage***REMOVED***

    def clear_dir(self, path***REMOVED***:
        ***REMOVED***
        Deletes the given relative path using the destination storage backend.
        ***REMOVED***
        if not self.storage.exists(path***REMOVED***:
            return

        dirs, files = self.storage.listdir(path***REMOVED***
        for f in files:
            fpath = os.path.join(path, f***REMOVED***
            if self.dry_run:
                self.log("Pretending to delete '%s'" %
                         smart_text(fpath***REMOVED***, level=1***REMOVED***
            else:
                self.log("Deleting '%s'" % smart_text(fpath***REMOVED***, level=1***REMOVED***
                ***REMOVED***
                    full_path = self.storage.path(fpath***REMOVED***
                except NotImplementedError:
                    self.storage.delete(fpath***REMOVED***
                else:
                    if not os.path.exists(full_path***REMOVED*** and os.path.lexists(full_path***REMOVED***:
                        # Delete broken symlinks
                        os.unlink(full_path***REMOVED***
                    else:
                        self.storage.delete(fpath***REMOVED***
        for d in dirs:
            self.clear_dir(os.path.join(path, d***REMOVED******REMOVED***

    def delete_file(self, path, prefixed_path, source_storage***REMOVED***:
        ***REMOVED***
        Checks if the target file should be deleted if it already exists
        ***REMOVED***
        if self.storage.exists(prefixed_path***REMOVED***:
            ***REMOVED***
                # When was the target file modified last time?
                target_last_modified = self.storage.get_modified_time(prefixed_path***REMOVED***
            except (OSError, NotImplementedError, AttributeError***REMOVED***:
                # The storage doesn't support get_modified_time(***REMOVED*** or failed
                pass
            else:
                ***REMOVED***
                    # When was the source file modified last time?
                    source_last_modified = source_storage.get_modified_time(path***REMOVED***
                except (OSError, NotImplementedError, AttributeError***REMOVED***:
                    pass
                else:
                    # The full path of the target file
                    if self.local:
                        full_path = self.storage.path(prefixed_path***REMOVED***
                    else:
                        full_path = None
                    # Skip the file if the source file is younger
                    # Avoid sub-second precision (see #14665, #19540***REMOVED***
                    if (target_last_modified.replace(microsecond=0***REMOVED*** >= source_last_modified.replace(microsecond=0***REMOVED*** and
                            full_path and not (self.symlink ^ os.path.islink(full_path***REMOVED******REMOVED******REMOVED***:
                        if prefixed_path not in self.unmodified_files:
                            self.unmodified_files.append(prefixed_path***REMOVED***
                        self.log("Skipping '%s' (not modified***REMOVED***" % path***REMOVED***
                        return False
            # Then delete the existing file if really needed
            if self.dry_run:
                self.log("Pretending to delete '%s'" % path***REMOVED***
            else:
                self.log("Deleting '%s'" % path***REMOVED***
                self.storage.delete(prefixed_path***REMOVED***
        return True

    def link_file(self, path, prefixed_path, source_storage***REMOVED***:
        ***REMOVED***
        Attempt to link ``path``
        ***REMOVED***
        # Skip this file if it was already copied earlier
        if prefixed_path in self.symlinked_files:
            return self.log("Skipping '%s' (already linked earlier***REMOVED***" % path***REMOVED***
        # Delete the target file if needed or break
        if not self.delete_file(path, prefixed_path, source_storage***REMOVED***:
            return
        # The full path of the source file
        source_path = source_storage.path(path***REMOVED***
        # Finally link the file
        if self.dry_run:
            self.log("Pretending to link '%s'" % source_path, level=1***REMOVED***
        else:
            self.log("Linking '%s'" % source_path, level=1***REMOVED***
            full_path = self.storage.path(prefixed_path***REMOVED***
            ***REMOVED***
                os.makedirs(os.path.dirname(full_path***REMOVED******REMOVED***
            except OSError:
                pass
            ***REMOVED***
                if os.path.lexists(full_path***REMOVED***:
                    os.unlink(full_path***REMOVED***
                os.symlink(source_path, full_path***REMOVED***
            except AttributeError:
                import platform
                raise CommandError("Symlinking is not supported by Python %s." %
                                   platform.python_version(***REMOVED******REMOVED***
            except NotImplementedError:
                import platform
                raise CommandError("Symlinking is not supported in this "
                                   "platform (%s***REMOVED***." % platform.platform(***REMOVED******REMOVED***
            except OSError as e:
                raise CommandError(e***REMOVED***
        if prefixed_path not in self.symlinked_files:
            self.symlinked_files.append(prefixed_path***REMOVED***

    def copy_file(self, path, prefixed_path, source_storage***REMOVED***:
        ***REMOVED***
        Attempt to copy ``path`` with storage
        ***REMOVED***
        # Skip this file if it was already copied earlier
        if prefixed_path in self.copied_files:
            return self.log("Skipping '%s' (already copied earlier***REMOVED***" % path***REMOVED***
        # Delete the target file if needed or break
        if not self.delete_file(path, prefixed_path, source_storage***REMOVED***:
            return
        # The full path of the source file
        source_path = source_storage.path(path***REMOVED***
        # Finally start copying
        if self.dry_run:
            self.log("Pretending to copy '%s'" % source_path, level=1***REMOVED***
        else:
            self.log("Copying '%s'" % source_path, level=1***REMOVED***
            with source_storage.open(path***REMOVED*** as source_file:
                self.storage.save(prefixed_path, source_file***REMOVED***
        self.copied_files.append(prefixed_path***REMOVED***
