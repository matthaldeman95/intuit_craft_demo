from django.db.models import Field, FloatField
from django.db.models.expressions import CombinedExpression, Func, Value
from django.db.models.functions import Coalesce
from django.db.models.lookups import Lookup


class SearchVectorExact(Lookup***REMOVED***:
    lookup_name = 'exact'

    def process_rhs(self, qn, connection***REMOVED***:
        if not hasattr(self.rhs, 'resolve_expression'***REMOVED***:
            config = getattr(self.lhs, 'config', None***REMOVED***
            self.rhs = SearchQuery(self.rhs, config=config***REMOVED***
        rhs, rhs_params = super(SearchVectorExact, self***REMOVED***.process_rhs(qn, connection***REMOVED***
        return rhs, rhs_params

    def as_sql(self, qn, connection***REMOVED***:
        lhs, lhs_params = self.process_lhs(qn, connection***REMOVED***
        rhs, rhs_params = self.process_rhs(qn, connection***REMOVED***
        params = lhs_params + rhs_params
        return '%s @@ %s = true' % (lhs, rhs***REMOVED***, params


class SearchVectorField(Field***REMOVED***:

    def db_type(self, connection***REMOVED***:
        return 'tsvector'


class SearchQueryField(Field***REMOVED***:

    def db_type(self, connection***REMOVED***:
        return 'tsquery'


class SearchVectorCombinable(object***REMOVED***:
    ADD = '||'

    def _combine(self, other, connector, reversed, node=None***REMOVED***:
        if not isinstance(other, SearchVectorCombinable***REMOVED*** or not self.config == other.config:
            raise TypeError('SearchVector can only be combined with other SearchVectors'***REMOVED***
        if reversed:
            return CombinedSearchVector(other, connector, self, self.config***REMOVED***
        return CombinedSearchVector(self, connector, other, self.config***REMOVED***


class SearchVector(SearchVectorCombinable, Func***REMOVED***:
    function = 'to_tsvector'
    arg_joiner = " || ' ' || "
    _output_field = SearchVectorField(***REMOVED***
    config = None

    def __init__(self, *expressions, **extra***REMOVED***:
        super(SearchVector, self***REMOVED***.__init__(*expressions, **extra***REMOVED***
        self.source_expressions = [
            Coalesce(expression, Value(''***REMOVED******REMOVED*** for expression in self.source_expressions
        ***REMOVED***
        self.config = self.extra.get('config', self.config***REMOVED***
        weight = self.extra.get('weight'***REMOVED***
        if weight is not None and not hasattr(weight, 'resolve_expression'***REMOVED***:
            weight = Value(weight***REMOVED***
        self.weight = weight

    def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False***REMOVED***:
        resolved = super(SearchVector, self***REMOVED***.resolve_expression(query, allow_joins, reuse, summarize, for_save***REMOVED***
        if self.config:
            if not hasattr(self.config, 'resolve_expression'***REMOVED***:
                resolved.config = Value(self.config***REMOVED***.resolve_expression(query, allow_joins, reuse, summarize, for_save***REMOVED***
            else:
                resolved.config = self.config.resolve_expression(query, allow_joins, reuse, summarize, for_save***REMOVED***
        return resolved

    def as_sql(self, compiler, connection, function=None, template=None***REMOVED***:
        config_params = [***REMOVED***
        if template is None:
            if self.config:
                config_sql, config_params = compiler.compile(self.config***REMOVED***
                template = "%(function***REMOVED***s({***REMOVED***::regconfig, %(expressions***REMOVED***s***REMOVED***".format(config_sql.replace('%', '%%'***REMOVED******REMOVED***
            else:
                template = self.template
        sql, params = super(SearchVector, self***REMOVED***.as_sql(compiler, connection, function=function, template=template***REMOVED***
        extra_params = [***REMOVED***
        if self.weight:
            weight_sql, extra_params = compiler.compile(self.weight***REMOVED***
            sql = 'setweight({***REMOVED***, {***REMOVED******REMOVED***'.format(sql, weight_sql***REMOVED***
        return sql, config_params + params + extra_params


class CombinedSearchVector(SearchVectorCombinable, CombinedExpression***REMOVED***:
    def __init__(self, lhs, connector, rhs, config, output_field=None***REMOVED***:
        self.config = config
        super(CombinedSearchVector, self***REMOVED***.__init__(lhs, connector, rhs, output_field***REMOVED***


class SearchQueryCombinable(object***REMOVED***:
    BITAND = '&&'
    BITOR = '||'

    def _combine(self, other, connector, reversed, node=None***REMOVED***:
        if not isinstance(other, SearchQueryCombinable***REMOVED***:
            raise TypeError(
                'SearchQuery can only be combined with other SearchQuerys, '
                'got {***REMOVED***.'.format(type(other***REMOVED******REMOVED***
            ***REMOVED***
        if not self.config == other.config:
            raise TypeError("SearchQuery configs don't match."***REMOVED***
        if reversed:
            return CombinedSearchQuery(other, connector, self, self.config***REMOVED***
        return CombinedSearchQuery(self, connector, other, self.config***REMOVED***

    # On Combinable, these are not implemented to reduce confusion with Q. In
    # this case we are actually (ab***REMOVED***using them to do logical combination so
    # it's consistent with other usage in Django.
    def __or__(self, other***REMOVED***:
        return self._combine(other, self.BITOR, False***REMOVED***

    def __ror__(self, other***REMOVED***:
        return self._combine(other, self.BITOR, True***REMOVED***

    def __and__(self, other***REMOVED***:
        return self._combine(other, self.BITAND, False***REMOVED***

    def __rand__(self, other***REMOVED***:
        return self._combine(other, self.BITAND, True***REMOVED***


class SearchQuery(SearchQueryCombinable, Value***REMOVED***:
    invert = False
    _output_field = SearchQueryField(***REMOVED***
    config = None

    def __init__(self, value, output_field=None, **extra***REMOVED***:
        self.config = extra.pop('config', self.config***REMOVED***
        self.invert = extra.pop('invert', self.invert***REMOVED***
        super(SearchQuery, self***REMOVED***.__init__(value, output_field=output_field***REMOVED***

    def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False***REMOVED***:
        resolved = super(SearchQuery, self***REMOVED***.resolve_expression(query, allow_joins, reuse, summarize, for_save***REMOVED***
        if self.config:
            if not hasattr(self.config, 'resolve_expression'***REMOVED***:
                resolved.config = Value(self.config***REMOVED***.resolve_expression(query, allow_joins, reuse, summarize, for_save***REMOVED***
            else:
                resolved.config = self.config.resolve_expression(query, allow_joins, reuse, summarize, for_save***REMOVED***
        return resolved

    def as_sql(self, compiler, connection***REMOVED***:
        params = [self.value***REMOVED***
        if self.config:
            config_sql, config_params = compiler.compile(self.config***REMOVED***
            template = 'plainto_tsquery({***REMOVED***::regconfig, %s***REMOVED***'.format(config_sql***REMOVED***
            params = config_params + [self.value***REMOVED***
        else:
            template = 'plainto_tsquery(%s***REMOVED***'
        if self.invert:
            template = '!!({***REMOVED******REMOVED***'.format(template***REMOVED***
        return template, params

    def _combine(self, other, connector, reversed, node=None***REMOVED***:
        combined = super(SearchQuery, self***REMOVED***._combine(other, connector, reversed, node***REMOVED***
        combined.output_field = SearchQueryField(***REMOVED***
        return combined

    def __invert__(self***REMOVED***:
        extra = {
            'invert': not self.invert,
            'config': self.config,
    ***REMOVED***
        return type(self***REMOVED***(self.value, **extra***REMOVED***


class CombinedSearchQuery(SearchQueryCombinable, CombinedExpression***REMOVED***:
    def __init__(self, lhs, connector, rhs, config, output_field=None***REMOVED***:
        self.config = config
        super(CombinedSearchQuery, self***REMOVED***.__init__(lhs, connector, rhs, output_field***REMOVED***


class SearchRank(Func***REMOVED***:
    function = 'ts_rank'
    _output_field = FloatField(***REMOVED***

    def __init__(self, vector, query, **extra***REMOVED***:
        if not hasattr(vector, 'resolve_expression'***REMOVED***:
            vector = SearchVector(vector***REMOVED***
        if not hasattr(query, 'resolve_expression'***REMOVED***:
            query = SearchQuery(query***REMOVED***
        weights = extra.get('weights'***REMOVED***
        if weights is not None and not hasattr(weights, 'resolve_expression'***REMOVED***:
            weights = Value(weights***REMOVED***
        self.weights = weights
        super(SearchRank, self***REMOVED***.__init__(vector, query, **extra***REMOVED***

    def as_sql(self, compiler, connection, function=None, template=None***REMOVED***:
        extra_params = [***REMOVED***
        extra_context = {***REMOVED***
        if template is None and self.extra.get('weights'***REMOVED***:
            if self.weights:
                template = '%(function***REMOVED***s(%(weights***REMOVED***s, %(expressions***REMOVED***s***REMOVED***'
                weight_sql, extra_params = compiler.compile(self.weights***REMOVED***
                extra_context['weights'***REMOVED*** = weight_sql
        sql, params = super(SearchRank, self***REMOVED***.as_sql(
            compiler, connection,
            function=function, template=template, **extra_context
        ***REMOVED***
        return sql, extra_params + params


SearchVectorField.register_lookup(SearchVectorExact***REMOVED***


class TrigramBase(Func***REMOVED***:
    def __init__(self, expression, string, **extra***REMOVED***:
        if not hasattr(string, 'resolve_expression'***REMOVED***:
            string = Value(string***REMOVED***
        super(TrigramBase, self***REMOVED***.__init__(expression, string, output_field=FloatField(***REMOVED***, **extra***REMOVED***


class TrigramSimilarity(TrigramBase***REMOVED***:
    function = 'SIMILARITY'


class TrigramDistance(TrigramBase***REMOVED***:
    function = ''
    arg_joiner = ' <-> '
