from __future__ import unicode_literals

from functools import partial

from django.contrib.admin.checks import InlineModelAdminChecks
from django.contrib.admin.options import InlineModelAdmin, flatten_fieldsets
from django.contrib.contenttypes.fields import GenericForeignKey
from django.contrib.contenttypes.forms import (
    BaseGenericInlineFormSet, generic_inlineformset_factory,
***REMOVED***
from django.core import checks
from django.core.exceptions import FieldDoesNotExist
from django.forms import ALL_FIELDS
from django.forms.models import modelform_defines_fields


class GenericInlineModelAdminChecks(InlineModelAdminChecks***REMOVED***:
    def _check_exclude_of_parent_model(self, obj, parent_model***REMOVED***:
        # There's no FK to exclude, so no exclusion checks are required.
        return [***REMOVED***

    def _check_relation(self, obj, parent_model***REMOVED***:
        # There's no FK, but we do need to confirm that the ct_field and ct_fk_field are valid,
        # and that they are part of a GenericForeignKey.

        gfks = [
            f for f in obj.model._meta.private_fields
            if isinstance(f, GenericForeignKey***REMOVED***
        ***REMOVED***
        if len(gfks***REMOVED*** == 0:
            return [
                checks.Error(
                    "'%s.%s' has no GenericForeignKey." % (
                        obj.model._meta.app_label, obj.model._meta.object_name
                    ***REMOVED***,
                    obj=obj.__class__,
                    id='admin.E301'
                ***REMOVED***
            ***REMOVED***
        else:
            # Check that the ct_field and ct_fk_fields exist
            ***REMOVED***
                obj.model._meta.get_field(obj.ct_field***REMOVED***
            except FieldDoesNotExist:
                return [
                    checks.Error(
                        "'ct_field' references '%s', which is not a field on '%s.%s'." % (
                            obj.ct_field, obj.model._meta.app_label, obj.model._meta.object_name
                        ***REMOVED***,
                        obj=obj.__class__,
                        id='admin.E302'
                    ***REMOVED***
                ***REMOVED***

            ***REMOVED***
                obj.model._meta.get_field(obj.ct_fk_field***REMOVED***
            except FieldDoesNotExist:
                return [
                    checks.Error(
                        "'ct_fk_field' references '%s', which is not a field on '%s.%s'." % (
                            obj.ct_fk_field, obj.model._meta.app_label, obj.model._meta.object_name
                        ***REMOVED***,
                        obj=obj.__class__,
                        id='admin.E303'
                    ***REMOVED***
                ***REMOVED***

            # There's one or more GenericForeignKeys; make sure that one of them
            # uses the right ct_field and ct_fk_field.
            for gfk in gfks:
                if gfk.ct_field == obj.ct_field and gfk.fk_field == obj.ct_fk_field:
                    return [***REMOVED***

            return [
                checks.Error(
                    "'%s.%s' has no GenericForeignKey using content type field '%s' and object ID field '%s'." % (
                        obj.model._meta.app_label, obj.model._meta.object_name, obj.ct_field, obj.ct_fk_field
                    ***REMOVED***,
                    obj=obj.__class__,
                    id='admin.E304'
                ***REMOVED***
            ***REMOVED***


class GenericInlineModelAdmin(InlineModelAdmin***REMOVED***:
    ct_field = "content_type"
    ct_fk_field = "object_id"
    formset = BaseGenericInlineFormSet

    checks_class = GenericInlineModelAdminChecks

    def get_formset(self, request, obj=None, **kwargs***REMOVED***:
        if 'fields' in kwargs:
            fields = kwargs.pop('fields'***REMOVED***
        else:
            fields = flatten_fieldsets(self.get_fieldsets(request, obj***REMOVED******REMOVED***
        if self.exclude is None:
            exclude = [***REMOVED***
        else:
            exclude = list(self.exclude***REMOVED***
        exclude.extend(self.get_readonly_fields(request, obj***REMOVED******REMOVED***
        if self.exclude is None and hasattr(self.form, '_meta'***REMOVED*** and self.form._meta.exclude:
            # Take the custom ModelForm's Meta.exclude into account only if the
            # GenericInlineModelAdmin doesn't define its own.
            exclude.extend(self.form._meta.exclude***REMOVED***
        exclude = exclude or None
        can_delete = self.can_delete and self.has_delete_permission(request, obj***REMOVED***
        defaults = {
            "ct_field": self.ct_field,
            "fk_field": self.ct_fk_field,
            "form": self.form,
            "formfield_callback": partial(self.formfield_for_dbfield, request=request***REMOVED***,
            "formset": self.formset,
            "extra": self.get_extra(request, obj***REMOVED***,
            "can_delete": can_delete,
            "can_order": False,
            "fields": fields,
            "min_num": self.get_min_num(request, obj***REMOVED***,
            "max_num": self.get_max_num(request, obj***REMOVED***,
            "exclude": exclude
    ***REMOVED***
        defaults.update(kwargs***REMOVED***

        if defaults['fields'***REMOVED*** is None and not modelform_defines_fields(defaults['form'***REMOVED******REMOVED***:
            defaults['fields'***REMOVED*** = ALL_FIELDS

        return generic_inlineformset_factory(self.model, **defaults***REMOVED***


class GenericStackedInline(GenericInlineModelAdmin***REMOVED***:
    template = 'admin/edit_inline/stacked.html'


class GenericTabularInline(GenericInlineModelAdmin***REMOVED***:
    template = 'admin/edit_inline/tabular.html'
