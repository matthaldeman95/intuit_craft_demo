from __future__ import unicode_literals

from collections import defaultdict

from django.contrib.contenttypes.models import ContentType
from django.core import checks
from django.core.exceptions import FieldDoesNotExist, ObjectDoesNotExist
from django.db import DEFAULT_DB_ALIAS, models, router, transaction
from django.db.models import DO_NOTHING
from django.db.models.base import ModelBase, make_foreign_order_accessors
from django.db.models.fields.related import (
    ForeignObject, ForeignObjectRel, ReverseManyToOneDescriptor,
    lazy_related_operation,
***REMOVED***
from django.db.models.query_utils import PathInfo
from django.utils.encoding import python_2_unicode_compatible, smart_text
from django.utils.functional import cached_property


@python_2_unicode_compatible
class GenericForeignKey(object***REMOVED***:
    ***REMOVED***
    Provide a generic many-to-one relation through the ``content_type`` and
    ``object_id`` fields.

    This class also doubles as an accessor to the related object (similar to
    ForwardManyToOneDescriptor***REMOVED*** by adding itself as a model attribute.
    ***REMOVED***

    # Field flags
    auto_created = False
    concrete = False
    editable = False
    hidden = False

    is_relation = True
    many_to_many = False
    many_to_one = True
    one_to_many = False
    one_to_one = False
    related_model = None
    remote_field = None

    def __init__(self, ct_field='content_type', fk_field='object_id', for_concrete_model=True***REMOVED***:
        self.ct_field = ct_field
        self.fk_field = fk_field
        self.for_concrete_model = for_concrete_model
        self.editable = False
        self.rel = None
        self.column = None

    def contribute_to_class(self, cls, name, **kwargs***REMOVED***:
        self.name = name
        self.model = cls
        self.cache_attr = "_%s_cache" % name
        cls._meta.add_field(self, private=True***REMOVED***
        setattr(cls, name, self***REMOVED***

    def get_filter_kwargs_for_object(self, obj***REMOVED***:
        ***REMOVED***See corresponding method on Field***REMOVED***
        return {
            self.fk_field: getattr(obj, self.fk_field***REMOVED***,
            self.ct_field: getattr(obj, self.ct_field***REMOVED***,
    ***REMOVED***

    def get_forward_related_filter(self, obj***REMOVED***:
        ***REMOVED***See corresponding method on RelatedField***REMOVED***
        return {
            self.fk_field: obj.pk,
            self.ct_field: ContentType.objects.get_for_model(obj***REMOVED***.pk,
    ***REMOVED***

    def __str__(self***REMOVED***:
        model = self.model
        app = model._meta.app_label
        return '%s.%s.%s' % (app, model._meta.object_name, self.name***REMOVED***

    def check(self, **kwargs***REMOVED***:
        errors = [***REMOVED***
        errors.extend(self._check_field_name(***REMOVED******REMOVED***
        errors.extend(self._check_object_id_field(***REMOVED******REMOVED***
        errors.extend(self._check_content_type_field(***REMOVED******REMOVED***
        return errors

    def _check_field_name(self***REMOVED***:
        if self.name.endswith("_"***REMOVED***:
            return [
                checks.Error(
                    'Field names must not end with an underscore.',
                    obj=self,
                    id='fields.E001',
                ***REMOVED***
            ***REMOVED***
        else:
            return [***REMOVED***

    def _check_object_id_field(self***REMOVED***:
        ***REMOVED***
            self.model._meta.get_field(self.fk_field***REMOVED***
        except FieldDoesNotExist:
            return [
                checks.Error(
                    "The GenericForeignKey object ID references the non-existent field '%s'." % self.fk_field,
                    obj=self,
                    id='contenttypes.E001',
                ***REMOVED***
            ***REMOVED***
        else:
            return [***REMOVED***

    def _check_content_type_field(self***REMOVED***:
        ***REMOVED***
        Check if field named `field_name` in model `model` exists and is a
        valid content_type field (is a ForeignKey to ContentType***REMOVED***.
        ***REMOVED***
        ***REMOVED***
            field = self.model._meta.get_field(self.ct_field***REMOVED***
        except FieldDoesNotExist:
            return [
                checks.Error(
                    "The GenericForeignKey content type references the non-existent field '%s.%s'." % (
                        self.model._meta.object_name, self.ct_field
                    ***REMOVED***,
                    obj=self,
                    id='contenttypes.E002',
                ***REMOVED***
            ***REMOVED***
        else:
            if not isinstance(field, models.ForeignKey***REMOVED***:
                return [
                    checks.Error(
                        "'%s.%s' is not a ForeignKey." % (
                            self.model._meta.object_name, self.ct_field
                        ***REMOVED***,
                        hint=(
                            "GenericForeignKeys must use a ForeignKey to "
                            "'contenttypes.ContentType' as the 'content_type' field."
                        ***REMOVED***,
                        obj=self,
                        id='contenttypes.E003',
                    ***REMOVED***
                ***REMOVED***
            elif field.remote_field.model != ContentType:
                return [
                    checks.Error(
                        "'%s.%s' is not a ForeignKey to 'contenttypes.ContentType'." % (
                            self.model._meta.object_name, self.ct_field
                        ***REMOVED***,
                        hint=(
                            "GenericForeignKeys must use a ForeignKey to "
                            "'contenttypes.ContentType' as the 'content_type' field."
                        ***REMOVED***,
                        obj=self,
                        id='contenttypes.E004',
                    ***REMOVED***
                ***REMOVED***
            else:
                return [***REMOVED***

    def get_content_type(self, obj=None, id=None, using=None***REMOVED***:
        if obj is not None:
            return ContentType.objects.db_manager(obj._state.db***REMOVED***.get_for_model(
                obj, for_concrete_model=self.for_concrete_model***REMOVED***
        elif id is not None:
            return ContentType.objects.db_manager(using***REMOVED***.get_for_id(id***REMOVED***
        else:
            # This should never happen. I love comments like this, don't you?
            raise Exception("Impossible arguments to GFK.get_content_type!"***REMOVED***

    def get_prefetch_queryset(self, instances, queryset=None***REMOVED***:
        if queryset is not None:
            raise ValueError("Custom queryset can't be used for this lookup."***REMOVED***

        # For efficiency, group the instances by content type and then do one
        # query per model
        fk_dict = defaultdict(set***REMOVED***
        # We need one instance for each group in order to get the right db:
        instance_dict = {***REMOVED***
        ct_attname = self.model._meta.get_field(self.ct_field***REMOVED***.get_attname(***REMOVED***
        for instance in instances:
            # We avoid looking for values if either ct_id or fkey value is None
            ct_id = getattr(instance, ct_attname***REMOVED***
            if ct_id is not None:
                fk_val = getattr(instance, self.fk_field***REMOVED***
                if fk_val is not None:
                    fk_dict[ct_id***REMOVED***.add(fk_val***REMOVED***
                    instance_dict[ct_id***REMOVED*** = instance

        ret_val = [***REMOVED***
        for ct_id, fkeys in fk_dict.items(***REMOVED***:
            instance = instance_dict[ct_id***REMOVED***
            ct = self.get_content_type(id=ct_id, using=instance._state.db***REMOVED***
            ret_val.extend(ct.get_all_objects_for_this_type(pk__in=fkeys***REMOVED******REMOVED***

        # For doing the join in Python, we have to match both the FK val and the
        # content type, so we use a callable that returns a (fk, class***REMOVED*** pair.
        def gfk_key(obj***REMOVED***:
            ct_id = getattr(obj, ct_attname***REMOVED***
            if ct_id is None:
                return None
            else:
                model = self.get_content_type(id=ct_id,
                                              using=obj._state.db***REMOVED***.model_class(***REMOVED***
                return (model._meta.pk.get_prep_value(getattr(obj, self.fk_field***REMOVED******REMOVED***,
                        model***REMOVED***

        return (ret_val,
                lambda obj: (obj._get_pk_val(***REMOVED***, obj.__class__***REMOVED***,
                gfk_key,
                True,
                self.name***REMOVED***

    def is_cached(self, instance***REMOVED***:
        return hasattr(instance, self.cache_attr***REMOVED***

    def __get__(self, instance, cls=None***REMOVED***:
        if instance is None:
            return self

        # Don't use getattr(instance, self.ct_field***REMOVED*** here because that might
        # reload the same ContentType over and over (#5570***REMOVED***. Instead, get the
        # content type ID here, and later when the actual instance is needed,
        # use ContentType.objects.get_for_id(***REMOVED***, which has a global cache.
        f = self.model._meta.get_field(self.ct_field***REMOVED***
        ct_id = getattr(instance, f.get_attname(***REMOVED***, None***REMOVED***
        pk_val = getattr(instance, self.fk_field***REMOVED***

        ***REMOVED***
            rel_obj = getattr(instance, self.cache_attr***REMOVED***
        except AttributeError:
            rel_obj = None
        else:
            if rel_obj and (ct_id != self.get_content_type(obj=rel_obj, using=instance._state.db***REMOVED***.id or
                            rel_obj._meta.pk.to_python(pk_val***REMOVED*** != rel_obj._get_pk_val(***REMOVED******REMOVED***:
                rel_obj = None

        if rel_obj is not None:
            return rel_obj

        if ct_id is not None:
            ct = self.get_content_type(id=ct_id, using=instance._state.db***REMOVED***
            ***REMOVED***
                rel_obj = ct.get_object_for_this_type(pk=pk_val***REMOVED***
            except ObjectDoesNotExist:
                pass
        setattr(instance, self.cache_attr, rel_obj***REMOVED***
        return rel_obj

    def __set__(self, instance, value***REMOVED***:
        ct = None
        fk = None
        if value is not None:
            ct = self.get_content_type(obj=value***REMOVED***
            fk = value._get_pk_val(***REMOVED***

        setattr(instance, self.ct_field, ct***REMOVED***
        setattr(instance, self.fk_field, fk***REMOVED***
        setattr(instance, self.cache_attr, value***REMOVED***


class GenericRel(ForeignObjectRel***REMOVED***:
    ***REMOVED***
    Used by GenericRelation to store information about the relation.
    ***REMOVED***

    def __init__(self, field, to, related_name=None, related_query_name=None, limit_choices_to=None***REMOVED***:
        super(GenericRel, self***REMOVED***.__init__(
            field, to,
            related_name=related_query_name or '+',
            related_query_name=related_query_name,
            limit_choices_to=limit_choices_to,
            on_delete=DO_NOTHING,
        ***REMOVED***


class GenericRelation(ForeignObject***REMOVED***:
    ***REMOVED***
    Provide a reverse to a relation created by a GenericForeignKey.
    ***REMOVED***

    # Field flags
    auto_created = False

    many_to_many = False
    many_to_one = False
    one_to_many = True
    one_to_one = False

    rel_class = GenericRel

    def __init__(self, to, object_id_field='object_id', content_type_field='content_type',
                 for_concrete_model=True, related_query_name=None, limit_choices_to=None, **kwargs***REMOVED***:
        kwargs['rel'***REMOVED*** = self.rel_class(
            self, to,
            related_query_name=related_query_name,
            limit_choices_to=limit_choices_to,
        ***REMOVED***

        kwargs['blank'***REMOVED*** = True
        kwargs['on_delete'***REMOVED*** = models.CASCADE
        kwargs['editable'***REMOVED*** = False
        kwargs['serialize'***REMOVED*** = False

        # This construct is somewhat of an abuse of ForeignObject. This field
        # represents a relation from pk to object_id field. But, this relation
        # isn't direct, the join is generated reverse along foreign key. So,
        # the from_field is object_id field, to_field is pk because of the
        # reverse join.
        super(GenericRelation, self***REMOVED***.__init__(
            to, from_fields=[object_id_field***REMOVED***, to_fields=[***REMOVED***, **kwargs***REMOVED***

        self.object_id_field_name = object_id_field
        self.content_type_field_name = content_type_field
        self.for_concrete_model = for_concrete_model

    def check(self, **kwargs***REMOVED***:
        errors = super(GenericRelation, self***REMOVED***.check(**kwargs***REMOVED***
        errors.extend(self._check_generic_foreign_key_existence(***REMOVED******REMOVED***
        return errors

    def _is_matching_generic_foreign_key(self, field***REMOVED***:
        ***REMOVED***
        Return True if field is a GenericForeignKey whose content type and
        object id fields correspond to the equivalent attributes on this
        GenericRelation.
        ***REMOVED***
        return (
            isinstance(field, GenericForeignKey***REMOVED*** and
            field.ct_field == self.content_type_field_name and
            field.fk_field == self.object_id_field_name
        ***REMOVED***

    def _check_generic_foreign_key_existence(self***REMOVED***:
        target = self.remote_field.model
        if isinstance(target, ModelBase***REMOVED***:
            fields = target._meta.private_fields
            if any(self._is_matching_generic_foreign_key(field***REMOVED*** for field in fields***REMOVED***:
                return [***REMOVED***
            else:
                return [
                    checks.Error(
                        "The GenericRelation defines a relation with the model "
                        "'%s.%s', but that model does not have a GenericForeignKey." % (
                            target._meta.app_label, target._meta.object_name
                        ***REMOVED***,
                        obj=self,
                        id='contenttypes.E004',
                    ***REMOVED***
                ***REMOVED***
        else:
            return [***REMOVED***

    def resolve_related_fields(self***REMOVED***:
        self.to_fields = [self.model._meta.pk.name***REMOVED***
        return [(self.remote_field.model._meta.get_field(self.object_id_field_name***REMOVED***, self.model._meta.pk***REMOVED******REMOVED***

    def _get_path_info_with_parent(self***REMOVED***:
        ***REMOVED***
        Return the path that joins the current model through any parent models.
        The idea is that if you have a GFK defined on a parent model then we
        need to join the parent model first, then the child model.
        ***REMOVED***
        # With an inheritance chain ChildTag -> Tag and Tag defines the
        # GenericForeignKey, and a TaggedItem model has a GenericRelation to
        # ChildTag, then we need to generate a join from TaggedItem to Tag
        # (as Tag.object_id == TaggedItem.pk***REMOVED***, and another join from Tag to
        # ChildTag (as that is where the relation is to***REMOVED***. Do this by first
        # generating a join to the parent model, then generating joins to the
        # child models.
        path = [***REMOVED***
        opts = self.remote_field.model._meta
        parent_opts = opts.get_field(self.object_id_field_name***REMOVED***.model._meta
        target = parent_opts.pk
        path.append(PathInfo(self.model._meta, parent_opts, (target,***REMOVED***, self.remote_field, True, False***REMOVED******REMOVED***
        # Collect joins needed for the parent -> child chain. This is easiest
        # to do if we collect joins for the child -> parent chain and then
        # reverse the direction (call to reverse(***REMOVED*** and use of
        # field.remote_field.get_path_info(***REMOVED******REMOVED***.
        parent_field_chain = [***REMOVED***
        while parent_opts != opts:
            field = opts.get_ancestor_link(parent_opts.model***REMOVED***
            parent_field_chain.append(field***REMOVED***
            opts = field.remote_field.model._meta
        parent_field_chain.reverse(***REMOVED***
        for field in parent_field_chain:
            path.extend(field.remote_field.get_path_info(***REMOVED******REMOVED***
        return path

    def get_path_info(self***REMOVED***:
        opts = self.remote_field.model._meta
        object_id_field = opts.get_field(self.object_id_field_name***REMOVED***
        if object_id_field.model != opts.model:
            return self._get_path_info_with_parent(***REMOVED***
        else:
            target = opts.pk
            return [PathInfo(self.model._meta, opts, (target,***REMOVED***, self.remote_field, True, False***REMOVED******REMOVED***

    def get_reverse_path_info(self***REMOVED***:
        opts = self.model._meta
        from_opts = self.remote_field.model._meta
        return [PathInfo(from_opts, opts, (opts.pk,***REMOVED***, self, not self.unique, False***REMOVED******REMOVED***

    def value_to_string(self, obj***REMOVED***:
        qs = getattr(obj, self.name***REMOVED***.all(***REMOVED***
        return smart_text([instance._get_pk_val(***REMOVED*** for instance in qs***REMOVED******REMOVED***

    def contribute_to_class(self, cls, name, **kwargs***REMOVED***:
        kwargs['private_only'***REMOVED*** = True
        super(GenericRelation, self***REMOVED***.contribute_to_class(cls, name, **kwargs***REMOVED***
        self.model = cls
        setattr(cls, self.name, ReverseGenericManyToOneDescriptor(self.remote_field***REMOVED******REMOVED***

        # Add get_RELATED_order(***REMOVED*** and set_RELATED_order(***REMOVED*** to the model this
        # field belongs to, if the model on the other end of this relation
        # is ordered with respect to its corresponding GenericForeignKey.
        if not cls._meta.abstract:

            def make_generic_foreign_order_accessors(related_model, model***REMOVED***:
                if self._is_matching_generic_foreign_key(model._meta.order_with_respect_to***REMOVED***:
                    make_foreign_order_accessors(model, related_model***REMOVED***

            lazy_related_operation(make_generic_foreign_order_accessors, self.model, self.remote_field.model***REMOVED***

    def set_attributes_from_rel(self***REMOVED***:
        pass

    def get_internal_type(self***REMOVED***:
        return "ManyToManyField"

    def get_content_type(self***REMOVED***:
        ***REMOVED***
        Return the content type associated with this field's model.
        ***REMOVED***
        return ContentType.objects.get_for_model(self.model,
                                                 for_concrete_model=self.for_concrete_model***REMOVED***

    def get_extra_restriction(self, where_class, alias, remote_alias***REMOVED***:
        field = self.remote_field.model._meta.get_field(self.content_type_field_name***REMOVED***
        contenttype_pk = self.get_content_type(***REMOVED***.pk
        cond = where_class(***REMOVED***
        lookup = field.get_lookup('exact'***REMOVED***(field.get_col(remote_alias***REMOVED***, contenttype_pk***REMOVED***
        cond.add(lookup, 'AND'***REMOVED***
        return cond

    def bulk_related_objects(self, objs, using=DEFAULT_DB_ALIAS***REMOVED***:
        ***REMOVED***
        Return all objects related to ``objs`` via this ``GenericRelation``.
        ***REMOVED***
        return self.remote_field.model._base_manager.db_manager(using***REMOVED***.filter(**{
            "%s__pk" % self.content_type_field_name: ContentType.objects.db_manager(using***REMOVED***.get_for_model(
                self.model, for_concrete_model=self.for_concrete_model***REMOVED***.pk,
            "%s__in" % self.object_id_field_name: [obj.pk for obj in objs***REMOVED***
    ***REMOVED******REMOVED***


class ReverseGenericManyToOneDescriptor(ReverseManyToOneDescriptor***REMOVED***:
    ***REMOVED***
    Accessor to the related objects manager on the one-to-many relation created
    by GenericRelation.

    In the example::

        class Post(Model***REMOVED***:
            comments = GenericRelation(Comment***REMOVED***

    ``post.comments`` is a ReverseGenericManyToOneDescriptor instance.
    ***REMOVED***

    @cached_property
    def related_manager_cls(self***REMOVED***:
        return create_generic_related_manager(
            self.rel.model._default_manager.__class__,
            self.rel,
        ***REMOVED***


def create_generic_related_manager(superclass, rel***REMOVED***:
    ***REMOVED***
    Factory function to create a manager that subclasses another manager
    (generally the default manager of a given model***REMOVED*** and adds behaviors
    specific to generic relations.
    ***REMOVED***

    class GenericRelatedObjectManager(superclass***REMOVED***:
        def __init__(self, instance=None***REMOVED***:
            super(GenericRelatedObjectManager, self***REMOVED***.__init__(***REMOVED***

            self.instance = instance

            self.model = rel.model

            content_type = ContentType.objects.db_manager(instance._state.db***REMOVED***.get_for_model(
                instance, for_concrete_model=rel.field.for_concrete_model***REMOVED***
            self.content_type = content_type
            self.content_type_field_name = rel.field.content_type_field_name
            self.object_id_field_name = rel.field.object_id_field_name
            self.prefetch_cache_name = rel.field.attname
            self.pk_val = instance._get_pk_val(***REMOVED***

            self.core_filters = {
                '%s__pk' % self.content_type_field_name: content_type.id,
                self.object_id_field_name: self.pk_val,
        ***REMOVED***

        def __call__(self, **kwargs***REMOVED***:
            # We use **kwargs rather than a kwarg argument to enforce the
            # `manager='manager_name'` syntax.
            manager = getattr(self.model, kwargs.pop('manager'***REMOVED******REMOVED***
            manager_class = create_generic_related_manager(manager.__class__, rel***REMOVED***
            return manager_class(instance=self.instance***REMOVED***
        do_not_call_in_templates = True

        def __str__(self***REMOVED***:
            return repr(self***REMOVED***

        def _apply_rel_filters(self, queryset***REMOVED***:
            ***REMOVED***
            Filter the queryset for the instance this manager is bound to.
            ***REMOVED***
            db = self._db or router.db_for_read(self.model, instance=self.instance***REMOVED***
            return queryset.using(db***REMOVED***.filter(**self.core_filters***REMOVED***

        def get_queryset(self***REMOVED***:
            ***REMOVED***
                return self.instance._prefetched_objects_cache[self.prefetch_cache_name***REMOVED***
            except (AttributeError, KeyError***REMOVED***:
                queryset = super(GenericRelatedObjectManager, self***REMOVED***.get_queryset(***REMOVED***
                return self._apply_rel_filters(queryset***REMOVED***

        def get_prefetch_queryset(self, instances, queryset=None***REMOVED***:
            if queryset is None:
                queryset = super(GenericRelatedObjectManager, self***REMOVED***.get_queryset(***REMOVED***

            queryset._add_hints(instance=instances[0***REMOVED******REMOVED***
            queryset = queryset.using(queryset._db or self._db***REMOVED***

            query = {
                '%s__pk' % self.content_type_field_name: self.content_type.id,
                '%s__in' % self.object_id_field_name: set(obj._get_pk_val(***REMOVED*** for obj in instances***REMOVED***
        ***REMOVED***

            # We (possibly***REMOVED*** need to convert object IDs to the type of the
            # instances' PK in order to match up instances:
            object_id_converter = instances[0***REMOVED***._meta.pk.to_python
            return (queryset.filter(**query***REMOVED***,
                    lambda relobj: object_id_converter(getattr(relobj, self.object_id_field_name***REMOVED******REMOVED***,
                    lambda obj: obj._get_pk_val(***REMOVED***,
                    False,
                    self.prefetch_cache_name***REMOVED***

        def add(self, *objs, **kwargs***REMOVED***:
            bulk = kwargs.pop('bulk', True***REMOVED***
            db = router.db_for_write(self.model, instance=self.instance***REMOVED***

            def check_and_update_obj(obj***REMOVED***:
                if not isinstance(obj, self.model***REMOVED***:
                    raise TypeError("'%s' instance expected, got %r" % (
                        self.model._meta.object_name, obj
                    ***REMOVED******REMOVED***
                setattr(obj, self.content_type_field_name, self.content_type***REMOVED***
                setattr(obj, self.object_id_field_name, self.pk_val***REMOVED***

            if bulk:
                pks = [***REMOVED***
                for obj in objs:
                    if obj._state.adding or obj._state.db != db:
                        raise ValueError(
                            "%r instance isn't saved. Use bulk=False or save "
                            "the object first." % obj
                        ***REMOVED***
                    check_and_update_obj(obj***REMOVED***
                    pks.append(obj.pk***REMOVED***

                self.model._base_manager.using(db***REMOVED***.filter(pk__in=pks***REMOVED***.update(**{
                    self.content_type_field_name: self.content_type,
                    self.object_id_field_name: self.pk_val,
            ***REMOVED******REMOVED***
            else:
                with transaction.atomic(using=db, savepoint=False***REMOVED***:
                    for obj in objs:
                        check_and_update_obj(obj***REMOVED***
                        obj.save(***REMOVED***
        add.alters_data = True

        def remove(self, *objs, **kwargs***REMOVED***:
            if not objs:
                return
            bulk = kwargs.pop('bulk', True***REMOVED***
            self._clear(self.filter(pk__in=[o.pk for o in objs***REMOVED******REMOVED***, bulk***REMOVED***
        remove.alters_data = True

        def clear(self, **kwargs***REMOVED***:
            bulk = kwargs.pop('bulk', True***REMOVED***
            self._clear(self, bulk***REMOVED***
        clear.alters_data = True

        def _clear(self, queryset, bulk***REMOVED***:
            db = router.db_for_write(self.model, instance=self.instance***REMOVED***
            queryset = queryset.using(db***REMOVED***
            if bulk:
                # `QuerySet.delete(***REMOVED***` creates its own atomic block which
                # contains the `pre_delete` and `post_delete` signal handlers.
                queryset.delete(***REMOVED***
            else:
                with transaction.atomic(using=db, savepoint=False***REMOVED***:
                    for obj in queryset:
                        obj.delete(***REMOVED***
        _clear.alters_data = True

        def set(self, objs, **kwargs***REMOVED***:
            # Force evaluation of `objs` in case it's a queryset whose value
            # could be affected by `manager.clear(***REMOVED***`. Refs #19816.
            objs = tuple(objs***REMOVED***

            bulk = kwargs.pop('bulk', True***REMOVED***
            clear = kwargs.pop('clear', False***REMOVED***

            db = router.db_for_write(self.model, instance=self.instance***REMOVED***
            with transaction.atomic(using=db, savepoint=False***REMOVED***:
                if clear:
                    self.clear(***REMOVED***
                    self.add(*objs, bulk=bulk***REMOVED***
                else:
                    old_objs = set(self.using(db***REMOVED***.all(***REMOVED******REMOVED***
                    new_objs = [***REMOVED***
                    for obj in objs:
                        if obj in old_objs:
                            old_objs.remove(obj***REMOVED***
                        else:
                            new_objs.append(obj***REMOVED***

                    self.remove(*old_objs***REMOVED***
                    self.add(*new_objs, bulk=bulk***REMOVED***
        set.alters_data = True

        def create(self, **kwargs***REMOVED***:
            kwargs[self.content_type_field_name***REMOVED*** = self.content_type
            kwargs[self.object_id_field_name***REMOVED*** = self.pk_val
            db = router.db_for_write(self.model, instance=self.instance***REMOVED***
            return super(GenericRelatedObjectManager, self***REMOVED***.using(db***REMOVED***.create(**kwargs***REMOVED***
        create.alters_data = True

        def get_or_create(self, **kwargs***REMOVED***:
            kwargs[self.content_type_field_name***REMOVED*** = self.content_type
            kwargs[self.object_id_field_name***REMOVED*** = self.pk_val
            db = router.db_for_write(self.model, instance=self.instance***REMOVED***
            return super(GenericRelatedObjectManager, self***REMOVED***.using(db***REMOVED***.get_or_create(**kwargs***REMOVED***
        get_or_create.alters_data = True

        def update_or_create(self, **kwargs***REMOVED***:
            kwargs[self.content_type_field_name***REMOVED*** = self.content_type
            kwargs[self.object_id_field_name***REMOVED*** = self.pk_val
            db = router.db_for_write(self.model, instance=self.instance***REMOVED***
            return super(GenericRelatedObjectManager, self***REMOVED***.using(db***REMOVED***.update_or_create(**kwargs***REMOVED***
        update_or_create.alters_data = True

    return GenericRelatedObjectManager
