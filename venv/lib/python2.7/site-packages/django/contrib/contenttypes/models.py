from __future__ import unicode_literals

from django.apps import apps
from django.db import models
from django.utils.encoding import force_text, python_2_unicode_compatible
from django.utils.translation import ugettext_lazy as _


class ContentTypeManager(models.Manager***REMOVED***:
    use_in_migrations = True

    def __init__(self, *args, **kwargs***REMOVED***:
        super(ContentTypeManager, self***REMOVED***.__init__(*args, **kwargs***REMOVED***
        # Cache shared by all the get_for_* methods to speed up
        # ContentType retrieval.
        self._cache = {***REMOVED***

    def get_by_natural_key(self, app_label, model***REMOVED***:
        ***REMOVED***
            ct = self._cache[self.db***REMOVED***[(app_label, model***REMOVED******REMOVED***
        except KeyError:
            ct = self.get(app_label=app_label, model=model***REMOVED***
            self._add_to_cache(self.db, ct***REMOVED***
        return ct

    def _get_opts(self, model, for_concrete_model***REMOVED***:
        if for_concrete_model:
            model = model._meta.concrete_model
        return model._meta

    def _get_from_cache(self, opts***REMOVED***:
        key = (opts.app_label, opts.model_name***REMOVED***
        return self._cache[self.db***REMOVED***[key***REMOVED***

    def get_for_model(self, model, for_concrete_model=True***REMOVED***:
        ***REMOVED***
        Returns the ContentType object for a given model, creating the
        ContentType if necessary. Lookups are cached so that subsequent lookups
        for the same model don't hit the database.
        ***REMOVED***
        opts = self._get_opts(model, for_concrete_model***REMOVED***
        ***REMOVED***
            return self._get_from_cache(opts***REMOVED***
        except KeyError:
            pass

        # The ContentType entry was not found in the cache, therefore we
        # proceed to load or create it.
        ***REMOVED***
            # Start with get(***REMOVED*** and not get_or_create(***REMOVED*** in order to use
            # the db_for_read (see #20401***REMOVED***.
            ct = self.get(app_label=opts.app_label, model=opts.model_name***REMOVED***
        except self.model.DoesNotExist:
            # Not found in the database; we proceed to create it. This time
            # use get_or_create to take care of any race conditions.
            ct, created = self.get_or_create(
                app_label=opts.app_label,
                model=opts.model_name,
            ***REMOVED***
        self._add_to_cache(self.db, ct***REMOVED***
        return ct

    def get_for_models(self, *models, **kwargs***REMOVED***:
        ***REMOVED***
        Given *models, returns a dictionary mapping {model: content_type***REMOVED***.
        ***REMOVED***
        for_concrete_models = kwargs.pop('for_concrete_models', True***REMOVED***
        # Final results
        results = {***REMOVED***
        # models that aren't already in the cache
        needed_app_labels = set(***REMOVED***
        needed_models = set(***REMOVED***
        needed_opts = set(***REMOVED***
        for model in models:
            opts = self._get_opts(model, for_concrete_models***REMOVED***
            ***REMOVED***
                ct = self._get_from_cache(opts***REMOVED***
            except KeyError:
                needed_app_labels.add(opts.app_label***REMOVED***
                needed_models.add(opts.model_name***REMOVED***
                needed_opts.add(opts***REMOVED***
            else:
                results[model***REMOVED*** = ct
        if needed_opts:
            cts = self.filter(
                app_label__in=needed_app_labels,
                model__in=needed_models
            ***REMOVED***
            for ct in cts:
                model = ct.model_class(***REMOVED***
                if model._meta in needed_opts:
                    results[model***REMOVED*** = ct
                    needed_opts.remove(model._meta***REMOVED***
                self._add_to_cache(self.db, ct***REMOVED***
        for opts in needed_opts:
            # These weren't in the cache, or the DB, create them.
            ct = self.create(
                app_label=opts.app_label,
                model=opts.model_name,
            ***REMOVED***
            self._add_to_cache(self.db, ct***REMOVED***
            results[ct.model_class(***REMOVED******REMOVED*** = ct
        return results

    def get_for_id(self, id***REMOVED***:
        ***REMOVED***
        Lookup a ContentType by ID. Uses the same shared cache as get_for_model
        (though ContentTypes are obviously not created on-the-fly by get_by_id***REMOVED***.
        ***REMOVED***
        ***REMOVED***
            ct = self._cache[self.db***REMOVED***[id***REMOVED***
        except KeyError:
            # This could raise a DoesNotExist; that's correct behavior and will
            # make sure that only correct ctypes get stored in the cache dict.
            ct = self.get(pk=id***REMOVED***
            self._add_to_cache(self.db, ct***REMOVED***
        return ct

    def clear_cache(self***REMOVED***:
        ***REMOVED***
        Clear out the content-type cache. This needs to happen during database
        flushes to prevent caching of "stale" content type IDs (see
        django.contrib.contenttypes.management.update_contenttypes for where
        this gets called***REMOVED***.
        ***REMOVED***
        self._cache.clear(***REMOVED***

    def _add_to_cache(self, using, ct***REMOVED***:
        ***REMOVED***Insert a ContentType into the cache.***REMOVED***
        # Note it's possible for ContentType objects to be stale; model_class(***REMOVED*** will return None.
        # Hence, there is no reliance on model._meta.app_label here, just using the model fields instead.
        key = (ct.app_label, ct.model***REMOVED***
        self._cache.setdefault(using, {***REMOVED******REMOVED***[key***REMOVED*** = ct
        self._cache.setdefault(using, {***REMOVED******REMOVED***[ct.id***REMOVED*** = ct


@python_2_unicode_compatible
class ContentType(models.Model***REMOVED***:
    app_label = models.CharField(max_length=100***REMOVED***
    model = models.CharField(_('python model class name'***REMOVED***, max_length=100***REMOVED***
    objects = ContentTypeManager(***REMOVED***

    class Meta:
        verbose_name = _('content type'***REMOVED***
        verbose_name_plural = _('content types'***REMOVED***
        db_table = 'django_content_type'
        unique_together = (('app_label', 'model'***REMOVED***,***REMOVED***

    def __str__(self***REMOVED***:
        return self.name

    @property
    def name(self***REMOVED***:
        model = self.model_class(***REMOVED***
        if not model:
            return self.model
        return force_text(model._meta.verbose_name***REMOVED***

    def model_class(self***REMOVED***:
        "Returns the Python model class for this type of content."
        ***REMOVED***
            return apps.get_model(self.app_label, self.model***REMOVED***
        except LookupError:
            return None

    def get_object_for_this_type(self, **kwargs***REMOVED***:
        ***REMOVED***
        Returns an object of this type for the keyword arguments given.
        Basically, this is a proxy around this object_type's get_object(***REMOVED*** model
        method. The ObjectNotExist exception, if thrown, will not be caught,
        so code that calls this method should catch it.
        ***REMOVED***
        return self.model_class(***REMOVED***._base_manager.using(self._state.db***REMOVED***.get(**kwargs***REMOVED***

    def get_all_objects_for_this_type(self, **kwargs***REMOVED***:
        ***REMOVED***
        Returns all objects of this type for the keyword arguments given.
        ***REMOVED***
        return self.model_class(***REMOVED***._base_manager.using(self._state.db***REMOVED***.filter(**kwargs***REMOVED***

    def natural_key(self***REMOVED***:
        return (self.app_label, self.model***REMOVED***
