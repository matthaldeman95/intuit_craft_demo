from django.apps import apps as global_apps
from django.db import DEFAULT_DB_ALIAS, migrations, router, transaction
from django.db.utils import IntegrityError
from django.utils import six
from django.utils.six.moves import input


class RenameContentType(migrations.RunPython***REMOVED***:
    def __init__(self, app_label, old_model, new_model***REMOVED***:
        self.app_label = app_label
        self.old_model = old_model
        self.new_model = new_model
        super(RenameContentType, self***REMOVED***.__init__(self.rename_forward, self.rename_backward***REMOVED***

    def _rename(self, apps, schema_editor, old_model, new_model***REMOVED***:
        ContentType = apps.get_model('contenttypes', 'ContentType'***REMOVED***
        db = schema_editor.connection.alias
        if not router.allow_migrate_model(db, ContentType***REMOVED***:
            return

        ***REMOVED***
            content_type = ContentType.objects.db_manager(db***REMOVED***.get_by_natural_key(self.app_label, old_model***REMOVED***
        except ContentType.DoesNotExist:
            pass
        else:
            content_type.model = new_model
            ***REMOVED***
                with transaction.atomic(using=db***REMOVED***:
                    content_type.save(update_fields={'model'***REMOVED******REMOVED***
            except IntegrityError:
                # Gracefully fallback if a stale content type causes a
                # conflict as update_contenttypes will take care of asking the
                # user what should be done next.
                content_type.model = old_model
            else:
                # Clear the cache as the `get_by_natual_key(***REMOVED***` call will cache
                # the renamed ContentType instance by its old model name.
                ContentType.objects.clear_cache(***REMOVED***

    def rename_forward(self, apps, schema_editor***REMOVED***:
        self._rename(apps, schema_editor, self.old_model, self.new_model***REMOVED***

    def rename_backward(self, apps, schema_editor***REMOVED***:
        self._rename(apps, schema_editor, self.new_model, self.old_model***REMOVED***


def inject_rename_contenttypes_operations(plan=None, apps=global_apps, using=DEFAULT_DB_ALIAS, **kwargs***REMOVED***:
    ***REMOVED***
    Insert a `RenameContentType` operation after every planned `RenameModel`
    operation.
    ***REMOVED***
    if plan is None:
        return

    # Determine whether or not the ContentType model is available.
    ***REMOVED***
        ContentType = apps.get_model('contenttypes', 'ContentType'***REMOVED***
    except LookupError:
        available = False
    else:
        if not router.allow_migrate_model(using, ContentType***REMOVED***:
            return
        available = True

    for migration, backward in plan:
        if ((migration.app_label, migration.name***REMOVED*** == ('contenttypes', '0001_initial'***REMOVED******REMOVED***:
            # There's no point in going forward if the initial contenttypes
            # migration is unapplied as the ContentType model will be
            # unavailable from this point.
            if backward:
                break
            else:
                available = True
                continue
        # The ContentType model is not available yet.
        if not available:
            continue
        inserts = [***REMOVED***
        for index, operation in enumerate(migration.operations***REMOVED***:
            if isinstance(operation, migrations.RenameModel***REMOVED***:
                operation = RenameContentType(
                    migration.app_label, operation.old_name_lower, operation.new_name_lower
                ***REMOVED***
                inserts.append((index + 1, operation***REMOVED******REMOVED***
        for inserted, (index, operation***REMOVED*** in enumerate(inserts***REMOVED***:
            migration.operations.insert(inserted + index, operation***REMOVED***


def update_contenttypes(app_config, verbosity=2, interactive=True, using=DEFAULT_DB_ALIAS, apps=global_apps, **kwargs***REMOVED***:
    ***REMOVED***
    Creates content types for models in the given app, removing any model
    entries that no longer have a matching model class.
    ***REMOVED***
    if not app_config.models_module:
        return

    app_label = app_config.label
    ***REMOVED***
        app_config = apps.get_app_config(app_label***REMOVED***
        ContentType = apps.get_model('contenttypes', 'ContentType'***REMOVED***
    except LookupError:
        return

    if not router.allow_migrate_model(using, ContentType***REMOVED***:
        return

    ContentType.objects.clear_cache(***REMOVED***
    # Always clear the global content types cache.
    if apps is not global_apps:
        global_apps.get_model('contenttypes', 'ContentType'***REMOVED***.objects.clear_cache(***REMOVED***

    app_models = {
        model._meta.model_name: model
        for model in app_config.get_models(***REMOVED******REMOVED***

    if not app_models:
        return

    # Get all the content types
    content_types = {
        ct.model: ct
        for ct in ContentType.objects.using(using***REMOVED***.filter(app_label=app_label***REMOVED***
***REMOVED***
    to_remove = [
        ct
        for (model_name, ct***REMOVED*** in six.iteritems(content_types***REMOVED***
        if model_name not in app_models
    ***REMOVED***

    cts = [
        ContentType(
            app_label=app_label,
            model=model_name,
        ***REMOVED***
        for (model_name, model***REMOVED*** in six.iteritems(app_models***REMOVED***
        if model_name not in content_types
    ***REMOVED***
    ContentType.objects.using(using***REMOVED***.bulk_create(cts***REMOVED***
    if verbosity >= 2:
        for ct in cts:
            print("Adding content type '%s | %s'" % (ct.app_label, ct.model***REMOVED******REMOVED***

    # Confirm that the content type is stale before deletion.
    if to_remove:
        if interactive:
            content_type_display = '\n'.join(
                '    %s | %s' % (ct.app_label, ct.model***REMOVED***
                for ct in to_remove
            ***REMOVED***
            ok_to_delete = input(***REMOVED***The following content types are stale and need to be deleted:

%s

Any objects related to these content types by a foreign key will also
be deleted. Are you sure you want to delete these content types?
If you're unsure, answer 'no'.

    Type 'yes' to continue, or 'no' to cancel: ***REMOVED*** % content_type_display***REMOVED***
        else:
            ok_to_delete = False

        if ok_to_delete == 'yes':
            for ct in to_remove:
                if verbosity >= 2:
                    print("Deleting stale content type '%s | %s'" % (ct.app_label, ct.model***REMOVED******REMOVED***
                ct.delete(***REMOVED***
        else:
            if verbosity >= 2:
                print("Stale content types remain."***REMOVED***
