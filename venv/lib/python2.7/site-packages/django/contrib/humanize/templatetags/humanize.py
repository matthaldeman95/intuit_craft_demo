# -*- encoding: utf-8 -*-
from __future__ import unicode_literals

import re
from datetime import date, datetime
from decimal import Decimal

from django import template
from django.conf import settings
from django.template import defaultfilters
from django.utils.encoding import force_text
from django.utils.formats import number_format
from django.utils.safestring import mark_safe
from django.utils.timezone import is_aware, utc
from django.utils.translation import pgettext, ugettext as _, ungettext

register = template.Library(***REMOVED***


@register.filter(is_safe=True***REMOVED***
def ordinal(value***REMOVED***:
    ***REMOVED***
    Converts an integer to its ordinal as a string. 1 is '1st', 2 is '2nd',
    3 is '3rd', etc. Works for any integer.
    ***REMOVED***
    ***REMOVED***
        value = int(value***REMOVED***
    except (TypeError, ValueError***REMOVED***:
        return value
    suffixes = (_('th'***REMOVED***, _('st'***REMOVED***, _('nd'***REMOVED***, _('rd'***REMOVED***, _('th'***REMOVED***, _('th'***REMOVED***, _('th'***REMOVED***, _('th'***REMOVED***, _('th'***REMOVED***, _('th'***REMOVED******REMOVED***
    if value % 100 in (11, 12, 13***REMOVED***:  # special case
        return mark_safe("%d%s" % (value, suffixes[0***REMOVED******REMOVED******REMOVED***
    # Mark value safe so i18n does not break with <sup> or <sub> see #19988
    return mark_safe("%d%s" % (value, suffixes[value % 10***REMOVED******REMOVED******REMOVED***


@register.filter(is_safe=True***REMOVED***
def intcomma(value, use_l10n=True***REMOVED***:
    ***REMOVED***
    Converts an integer to a string containing commas every three digits.
    For example, 3000 becomes '3,000' and 45000 becomes '45,000'.
    ***REMOVED***
    if settings.USE_L10N and use_l10n:
        ***REMOVED***
            if not isinstance(value, (float, Decimal***REMOVED******REMOVED***:
                value = int(value***REMOVED***
        except (TypeError, ValueError***REMOVED***:
            return intcomma(value, False***REMOVED***
        else:
            return number_format(value, force_grouping=True***REMOVED***
    orig = force_text(value***REMOVED***
    new = re.sub("^(-?\d+***REMOVED***(\d{3***REMOVED******REMOVED***", '\g<1>,\g<2>', orig***REMOVED***
    if orig == new:
        return new
    else:
        return intcomma(new, use_l10n***REMOVED***

# A tuple of standard large number to their converters
intword_converters = (
    (6, lambda number: (
        ungettext('%(value***REMOVED***.1f million', '%(value***REMOVED***.1f million', number***REMOVED***,
        ungettext('%(value***REMOVED***s million', '%(value***REMOVED***s million', number***REMOVED***,
    ***REMOVED******REMOVED***,
    (9, lambda number: (
        ungettext('%(value***REMOVED***.1f billion', '%(value***REMOVED***.1f billion', number***REMOVED***,
        ungettext('%(value***REMOVED***s billion', '%(value***REMOVED***s billion', number***REMOVED***,
    ***REMOVED******REMOVED***,
    (12, lambda number: (
        ungettext('%(value***REMOVED***.1f trillion', '%(value***REMOVED***.1f trillion', number***REMOVED***,
        ungettext('%(value***REMOVED***s trillion', '%(value***REMOVED***s trillion', number***REMOVED***,
    ***REMOVED******REMOVED***,
    (15, lambda number: (
        ungettext('%(value***REMOVED***.1f quadrillion', '%(value***REMOVED***.1f quadrillion', number***REMOVED***,
        ungettext('%(value***REMOVED***s quadrillion', '%(value***REMOVED***s quadrillion', number***REMOVED***,
    ***REMOVED******REMOVED***,
    (18, lambda number: (
        ungettext('%(value***REMOVED***.1f quintillion', '%(value***REMOVED***.1f quintillion', number***REMOVED***,
        ungettext('%(value***REMOVED***s quintillion', '%(value***REMOVED***s quintillion', number***REMOVED***,
    ***REMOVED******REMOVED***,
    (21, lambda number: (
        ungettext('%(value***REMOVED***.1f sextillion', '%(value***REMOVED***.1f sextillion', number***REMOVED***,
        ungettext('%(value***REMOVED***s sextillion', '%(value***REMOVED***s sextillion', number***REMOVED***,
    ***REMOVED******REMOVED***,
    (24, lambda number: (
        ungettext('%(value***REMOVED***.1f septillion', '%(value***REMOVED***.1f septillion', number***REMOVED***,
        ungettext('%(value***REMOVED***s septillion', '%(value***REMOVED***s septillion', number***REMOVED***,
    ***REMOVED******REMOVED***,
    (27, lambda number: (
        ungettext('%(value***REMOVED***.1f octillion', '%(value***REMOVED***.1f octillion', number***REMOVED***,
        ungettext('%(value***REMOVED***s octillion', '%(value***REMOVED***s octillion', number***REMOVED***,
    ***REMOVED******REMOVED***,
    (30, lambda number: (
        ungettext('%(value***REMOVED***.1f nonillion', '%(value***REMOVED***.1f nonillion', number***REMOVED***,
        ungettext('%(value***REMOVED***s nonillion', '%(value***REMOVED***s nonillion', number***REMOVED***,
    ***REMOVED******REMOVED***,
    (33, lambda number: (
        ungettext('%(value***REMOVED***.1f decillion', '%(value***REMOVED***.1f decillion', number***REMOVED***,
        ungettext('%(value***REMOVED***s decillion', '%(value***REMOVED***s decillion', number***REMOVED***,
    ***REMOVED******REMOVED***,
    (100, lambda number: (
        ungettext('%(value***REMOVED***.1f googol', '%(value***REMOVED***.1f googol', number***REMOVED***,
        ungettext('%(value***REMOVED***s googol', '%(value***REMOVED***s googol', number***REMOVED***,
    ***REMOVED******REMOVED***,
***REMOVED***


@register.filter(is_safe=False***REMOVED***
def intword(value***REMOVED***:
    ***REMOVED***
    Converts a large integer to a friendly text representation. Works best
    for numbers over 1 million. For example, 1000000 becomes '1.0 million',
    1200000 becomes '1.2 million' and '1200000000' becomes '1.2 billion'.
    ***REMOVED***
    ***REMOVED***
        value = int(value***REMOVED***
    except (TypeError, ValueError***REMOVED***:
        return value

    if value < 1000000:
        return value

    def _check_for_i18n(value, float_formatted, string_formatted***REMOVED***:
        ***REMOVED***
        Use the i18n enabled defaultfilters.floatformat if possible
        ***REMOVED***
        if settings.USE_L10N:
            value = defaultfilters.floatformat(value, 1***REMOVED***
            template = string_formatted
        else:
            template = float_formatted
        return template % {'value': value***REMOVED***

    for exponent, converters in intword_converters:
        large_number = 10 ** exponent
        if value < large_number * 1000:
            new_value = value / float(large_number***REMOVED***
            return _check_for_i18n(new_value, *converters(new_value***REMOVED******REMOVED***
    return value


@register.filter(is_safe=True***REMOVED***
def apnumber(value***REMOVED***:
    ***REMOVED***
    For numbers 1-9, returns the number spelled out. Otherwise, returns the
    number. This follows Associated Press style.
    ***REMOVED***
    ***REMOVED***
        value = int(value***REMOVED***
    except (TypeError, ValueError***REMOVED***:
        return value
    if not 0 < value < 10:
        return value
    return (_('one'***REMOVED***, _('two'***REMOVED***, _('three'***REMOVED***, _('four'***REMOVED***, _('five'***REMOVED***,
            _('six'***REMOVED***, _('seven'***REMOVED***, _('eight'***REMOVED***, _('nine'***REMOVED******REMOVED***[value - 1***REMOVED***


# Perform the comparison in the default time zone when ***REMOVED***
# (unless a specific time zone has been applied with the |timezone filter***REMOVED***.
@register.filter(expects_localtime=True***REMOVED***
def naturalday(value, arg=None***REMOVED***:
    ***REMOVED***
    For date values that are tomorrow, today or yesterday compared to
    present day returns representing string. Otherwise, returns a string
    formatted according to settings.DATE_FORMAT.
    ***REMOVED***
    ***REMOVED***
        tzinfo = getattr(value, 'tzinfo', None***REMOVED***
        value = date(value.year, value.month, value.day***REMOVED***
    except AttributeError:
        # Passed value wasn't a date object
        return value
    except ValueError:
        # Date arguments out of range
        return value
    today = datetime.now(tzinfo***REMOVED***.date(***REMOVED***
    delta = value - today
    if delta.days == 0:
        return _('today'***REMOVED***
    elif delta.days == 1:
        return _('tomorrow'***REMOVED***
    elif delta.days == -1:
        return _('yesterday'***REMOVED***
    return defaultfilters.date(value, arg***REMOVED***


# This filter doesn't require expects_localtime=True because it deals properly
# with both naive and aware datetimes. Therefore avoid the cost of conversion.
@register.filter
def naturaltime(value***REMOVED***:
    ***REMOVED***
    For date and time values shows how many seconds, minutes or hours ago
    compared to current timestamp returns representing string.
    ***REMOVED***
    if not isinstance(value, date***REMOVED***:  # datetime is a subclass of date
        return value

    now = datetime.now(utc if is_aware(value***REMOVED*** else None***REMOVED***
    if value < now:
        delta = now - value
        if delta.days != 0:
            return pgettext(
                'naturaltime', '%(delta***REMOVED***s ago'
            ***REMOVED*** % {'delta': defaultfilters.timesince(value, now***REMOVED******REMOVED***
        elif delta.seconds == 0:
            return _('now'***REMOVED***
        elif delta.seconds < 60:
            return ungettext(
                # Translators: please keep a non-breaking space (U+00A0***REMOVED***
                # between count and time unit.
                'a second ago', '%(count***REMOVED***s seconds ago', delta.seconds
            ***REMOVED*** % {'count': delta.seconds***REMOVED***
        elif delta.seconds // 60 < 60:
            count = delta.seconds // 60
            return ungettext(
                # Translators: please keep a non-breaking space (U+00A0***REMOVED***
                # between count and time unit.
                'a minute ago', '%(count***REMOVED***s minutes ago', count
            ***REMOVED*** % {'count': count***REMOVED***
        else:
            count = delta.seconds // 60 // 60
            return ungettext(
                # Translators: please keep a non-breaking space (U+00A0***REMOVED***
                # between count and time unit.
                'an hour ago', '%(count***REMOVED***s hours ago', count
            ***REMOVED*** % {'count': count***REMOVED***
    else:
        delta = value - now
        if delta.days != 0:
            return pgettext(
                'naturaltime', '%(delta***REMOVED***s from now'
            ***REMOVED*** % {'delta': defaultfilters.timeuntil(value, now***REMOVED******REMOVED***
        elif delta.seconds == 0:
            return _('now'***REMOVED***
        elif delta.seconds < 60:
            return ungettext(
                # Translators: please keep a non-breaking space (U+00A0***REMOVED***
                # between count and time unit.
                'a second from now', '%(count***REMOVED***s seconds from now', delta.seconds
            ***REMOVED*** % {'count': delta.seconds***REMOVED***
        elif delta.seconds // 60 < 60:
            count = delta.seconds // 60
            return ungettext(
                # Translators: please keep a non-breaking space (U+00A0***REMOVED***
                # between count and time unit.
                'a minute from now', '%(count***REMOVED***s minutes from now', count
            ***REMOVED*** % {'count': count***REMOVED***
        else:
            count = delta.seconds // 60 // 60
            return ungettext(
                # Translators: please keep a non-breaking space (U+00A0***REMOVED***
                # between count and time unit.
                'an hour from now', '%(count***REMOVED***s hours from now', count
            ***REMOVED*** % {'count': count***REMOVED***
