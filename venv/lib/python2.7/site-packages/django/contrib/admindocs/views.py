import inspect
***REMOVED***
import re
from importlib import import_module

from django.apps import apps
from django.conf import settings
from django.contrib import admin
from django.contrib.admin.views.decorators import staff_member_required
from django.contrib.admindocs import utils
from django.core.exceptions import ImproperlyConfigured, ViewDoesNotExist
from django.db import models
from django.http import Http404
from django.template.engine import Engine
from django.urls import get_mod_func, get_resolver, get_urlconf, reverse
from django.utils import six
from django.utils.decorators import method_decorator
from django.utils.inspect import (
    func_accepts_kwargs, func_accepts_var_args, func_has_no_args,
    get_func_full_args,
***REMOVED***
from django.utils.translation import ugettext as _
from django.views.generic import TemplateView

# Exclude methods starting with these strings from documentation
MODEL_METHODS_EXCLUDE = ('_', 'add_', 'delete', 'save', 'set_'***REMOVED***


class BaseAdminDocsView(TemplateView***REMOVED***:
    ***REMOVED***
    Base view for admindocs views.
    ***REMOVED***
    @method_decorator(staff_member_required***REMOVED***
    def dispatch(self, request, *args, **kwargs***REMOVED***:
        if not utils.docutils_is_available:
            # Display an error message for people without docutils
            self.template_name = 'admin_doc/missing_docutils.html'
            return self.render_to_response(admin.site.each_context(request***REMOVED******REMOVED***
        return super(BaseAdminDocsView, self***REMOVED***.dispatch(request, *args, **kwargs***REMOVED***

    def get_context_data(self, **kwargs***REMOVED***:
        kwargs.update({'root_path': reverse('admin:index'***REMOVED******REMOVED******REMOVED***
        kwargs.update(admin.site.each_context(self.request***REMOVED******REMOVED***
        return super(BaseAdminDocsView, self***REMOVED***.get_context_data(**kwargs***REMOVED***


class BookmarkletsView(BaseAdminDocsView***REMOVED***:
    template_name = 'admin_doc/bookmarklets.html'

    def get_context_data(self, **kwargs***REMOVED***:
        context = super(BookmarkletsView, self***REMOVED***.get_context_data(**kwargs***REMOVED***
        context.update({
            'admin_url': "%s://%s%s" % (
                self.request.scheme, self.request.get_host(***REMOVED***, context['root_path'***REMOVED******REMOVED***
    ***REMOVED******REMOVED***
        return context


class TemplateTagIndexView(BaseAdminDocsView***REMOVED***:
    template_name = 'admin_doc/template_tag_index.html'

    def get_context_data(self, **kwargs***REMOVED***:
        tags = [***REMOVED***
        ***REMOVED***
            engine = Engine.get_default(***REMOVED***
        except ImproperlyConfigured:
            # Non-trivial TEMPLATES settings aren't supported (#24125***REMOVED***.
            pass
        else:
            app_libs = sorted(engine.template_libraries.items(***REMOVED******REMOVED***
            builtin_libs = [('', lib***REMOVED*** for lib in engine.template_builtins***REMOVED***
            for module_name, library in builtin_libs + app_libs:
                for tag_name, tag_func in library.tags.items(***REMOVED***:
                    title, body, metadata = utils.parse_docstring(tag_func.__doc__***REMOVED***
                    if title:
                        title = utils.parse_rst(title, 'tag', _('tag:'***REMOVED*** + tag_name***REMOVED***
                    if body:
                        body = utils.parse_rst(body, 'tag', _('tag:'***REMOVED*** + tag_name***REMOVED***
                    for key in metadata:
                        metadata[key***REMOVED*** = utils.parse_rst(metadata[key***REMOVED***, 'tag', _('tag:'***REMOVED*** + tag_name***REMOVED***
                    tag_library = module_name.split('.'***REMOVED***[-1***REMOVED***
                    tags.append({
                        'name': tag_name,
                        'title': title,
                        'body': body,
                        'meta': metadata,
                        'library': tag_library,
                ***REMOVED******REMOVED***
        kwargs.update({'tags': tags***REMOVED******REMOVED***
        return super(TemplateTagIndexView, self***REMOVED***.get_context_data(**kwargs***REMOVED***


class TemplateFilterIndexView(BaseAdminDocsView***REMOVED***:
    template_name = 'admin_doc/template_filter_index.html'

    def get_context_data(self, **kwargs***REMOVED***:
        filters = [***REMOVED***
        ***REMOVED***
            engine = Engine.get_default(***REMOVED***
        except ImproperlyConfigured:
            # Non-trivial TEMPLATES settings aren't supported (#24125***REMOVED***.
            pass
        else:
            app_libs = sorted(engine.template_libraries.items(***REMOVED******REMOVED***
            builtin_libs = [('', lib***REMOVED*** for lib in engine.template_builtins***REMOVED***
            for module_name, library in builtin_libs + app_libs:
                for filter_name, filter_func in library.filters.items(***REMOVED***:
                    title, body, metadata = utils.parse_docstring(filter_func.__doc__***REMOVED***
                    if title:
                        title = utils.parse_rst(title, 'filter', _('filter:'***REMOVED*** + filter_name***REMOVED***
                    if body:
                        body = utils.parse_rst(body, 'filter', _('filter:'***REMOVED*** + filter_name***REMOVED***
                    for key in metadata:
                        metadata[key***REMOVED*** = utils.parse_rst(metadata[key***REMOVED***, 'filter', _('filter:'***REMOVED*** + filter_name***REMOVED***
                    tag_library = module_name.split('.'***REMOVED***[-1***REMOVED***
                    filters.append({
                        'name': filter_name,
                        'title': title,
                        'body': body,
                        'meta': metadata,
                        'library': tag_library,
                ***REMOVED******REMOVED***
        kwargs.update({'filters': filters***REMOVED******REMOVED***
        return super(TemplateFilterIndexView, self***REMOVED***.get_context_data(**kwargs***REMOVED***


class ViewIndexView(BaseAdminDocsView***REMOVED***:
    template_name = 'admin_doc/view_index.html'

    @staticmethod
    def _get_full_name(func***REMOVED***:
        mod_name = func.__module__
        if six.PY3:
            return '%s.%s' % (mod_name, func.__qualname__***REMOVED***
        else:
            # PY2 does not support __qualname__
            func_name = getattr(func, '__name__', func.__class__.__name__***REMOVED***
            return '%s.%s' % (mod_name, func_name***REMOVED***

    def get_context_data(self, **kwargs***REMOVED***:
        views = [***REMOVED***
        urlconf = import_module(settings.ROOT_URLCONF***REMOVED***
        view_functions = extract_views_from_urlpatterns(urlconf.urlpatterns***REMOVED***
        for (func, regex, namespace, name***REMOVED*** in view_functions:
            views.append({
                'full_name': self._get_full_name(func***REMOVED***,
                'url': simplify_regex(regex***REMOVED***,
                'url_name': ':'.join((namespace or [***REMOVED******REMOVED*** + (name and [name***REMOVED*** or [***REMOVED******REMOVED******REMOVED***,
                'namespace': ':'.join((namespace or [***REMOVED******REMOVED******REMOVED***,
                'name': name,
        ***REMOVED******REMOVED***
        kwargs.update({'views': views***REMOVED******REMOVED***
        return super(ViewIndexView, self***REMOVED***.get_context_data(**kwargs***REMOVED***


class ViewDetailView(BaseAdminDocsView***REMOVED***:
    template_name = 'admin_doc/view_detail.html'

    @staticmethod
    def _get_view_func(view***REMOVED***:
        urlconf = get_urlconf(***REMOVED***
        if get_resolver(urlconf***REMOVED***._is_callback(view***REMOVED***:
            mod, func = get_mod_func(view***REMOVED***
            ***REMOVED***
                # Separate the module and function, e.g.
                # 'mymodule.views.myview' -> 'mymodule.views', 'myview'***REMOVED***.
                return getattr(import_module(mod***REMOVED***, func***REMOVED***
            except ImportError:
                # Import may fail because view contains a class name, e.g.
                # 'mymodule.views.ViewContainer.my_view', so mod takes the form
                # 'mymodule.views.ViewContainer'. Parse it again to separate
                # the module and class.
                mod, klass = get_mod_func(mod***REMOVED***
                return getattr(getattr(import_module(mod***REMOVED***, klass***REMOVED***, func***REMOVED***
            except AttributeError:
                # PY2 generates incorrect paths for views that are methods,
                # e.g. 'mymodule.views.ViewContainer.my_view' will be
                # listed as 'mymodule.views.my_view' because the class name
                # can't be detected. This causes an AttributeError when
                # trying to resolve the view.
                return None

    def get_context_data(self, **kwargs***REMOVED***:
        view = self.kwargs['view'***REMOVED***
        view_func = self._get_view_func(view***REMOVED***
        if view_func is None:
            raise Http404
        title, body, metadata = utils.parse_docstring(view_func.__doc__***REMOVED***
        if title:
            title = utils.parse_rst(title, 'view', _('view:'***REMOVED*** + view***REMOVED***
        if body:
            body = utils.parse_rst(body, 'view', _('view:'***REMOVED*** + view***REMOVED***
        for key in metadata:
            metadata[key***REMOVED*** = utils.parse_rst(metadata[key***REMOVED***, 'model', _('view:'***REMOVED*** + view***REMOVED***
        kwargs.update({
            'name': view,
            'summary': title,
            'body': body,
            'meta': metadata,
    ***REMOVED******REMOVED***
        return super(ViewDetailView, self***REMOVED***.get_context_data(**kwargs***REMOVED***


class ModelIndexView(BaseAdminDocsView***REMOVED***:
    template_name = 'admin_doc/model_index.html'

    def get_context_data(self, **kwargs***REMOVED***:
        m_list = [m._meta for m in apps.get_models(***REMOVED******REMOVED***
        kwargs.update({'models': m_list***REMOVED******REMOVED***
        return super(ModelIndexView, self***REMOVED***.get_context_data(**kwargs***REMOVED***


class ModelDetailView(BaseAdminDocsView***REMOVED***:
    template_name = 'admin_doc/model_detail.html'

    def get_context_data(self, **kwargs***REMOVED***:
        model_name = self.kwargs['model_name'***REMOVED***
        # Get the model class.
        ***REMOVED***
            app_config = apps.get_app_config(self.kwargs['app_label'***REMOVED******REMOVED***
        except LookupError:
            raise Http404(_("App %(app_label***REMOVED***r not found"***REMOVED*** % self.kwargs***REMOVED***
        ***REMOVED***
            model = app_config.get_model(model_name***REMOVED***
        except LookupError:
            raise Http404(_("Model %(model_name***REMOVED***r not found in app %(app_label***REMOVED***r"***REMOVED*** % self.kwargs***REMOVED***

        opts = model._meta

        title, body, metadata = utils.parse_docstring(model.__doc__***REMOVED***
        if title:
            title = utils.parse_rst(title, 'model', _('model:'***REMOVED*** + model_name***REMOVED***
        if body:
            body = utils.parse_rst(body, 'model', _('model:'***REMOVED*** + model_name***REMOVED***

        # Gather fields/field descriptions.
        fields = [***REMOVED***
        for field in opts.fields:
            # ForeignKey is a special case since the field will actually be a
            # descriptor that returns the other object
            if isinstance(field, models.ForeignKey***REMOVED***:
                data_type = field.remote_field.model.__name__
                app_label = field.remote_field.model._meta.app_label
                verbose = utils.parse_rst(
                    (_("the related `%(app_label***REMOVED***s.%(data_type***REMOVED***s` object"***REMOVED*** % {
                        'app_label': app_label, 'data_type': data_type,
                ***REMOVED******REMOVED***,
                    'model',
                    _('model:'***REMOVED*** + data_type,
                ***REMOVED***
            else:
                data_type = get_readable_field_data_type(field***REMOVED***
                verbose = field.verbose_name
            fields.append({
                'name': field.name,
                'data_type': data_type,
                'verbose': verbose or '',
                'help_text': field.help_text,
        ***REMOVED******REMOVED***

        # Gather many-to-many fields.
        for field in opts.many_to_many:
            data_type = field.remote_field.model.__name__
            app_label = field.remote_field.model._meta.app_label
            verbose = _("related `%(app_label***REMOVED***s.%(object_name***REMOVED***s` objects"***REMOVED*** % {
                'app_label': app_label,
                'object_name': data_type,
        ***REMOVED***
            fields.append({
                'name': "%s.all" % field.name,
                "data_type": 'List',
                'verbose': utils.parse_rst(_("all %s"***REMOVED*** % verbose, 'model', _('model:'***REMOVED*** + opts.model_name***REMOVED***,
        ***REMOVED******REMOVED***
            fields.append({
                'name': "%s.count" % field.name,
                'data_type': 'Integer',
                'verbose': utils.parse_rst(_("number of %s"***REMOVED*** % verbose, 'model', _('model:'***REMOVED*** + opts.model_name***REMOVED***,
        ***REMOVED******REMOVED***

        methods = [***REMOVED***
        # Gather model methods.
        for func_name, func in model.__dict__.items(***REMOVED***:
            if inspect.isfunction(func***REMOVED***:
                ***REMOVED***
                    for exclude in MODEL_METHODS_EXCLUDE:
                        if func_name.startswith(exclude***REMOVED***:
                            raise StopIteration
                except StopIteration:
                    continue
                verbose = func.__doc__
                if verbose:
                    verbose = utils.parse_rst(utils.trim_docstring(verbose***REMOVED***, 'model', _('model:'***REMOVED*** + opts.model_name***REMOVED***
                # If a method has no arguments, show it as a 'field', otherwise
                # as a 'method with arguments'.
                if func_has_no_args(func***REMOVED*** and not func_accepts_kwargs(func***REMOVED*** and not func_accepts_var_args(func***REMOVED***:
                    fields.append({
                        'name': func_name,
                        'data_type': get_return_data_type(func_name***REMOVED***,
                        'verbose': verbose or '',
                ***REMOVED******REMOVED***
                else:
                    arguments = get_func_full_args(func***REMOVED***
                    print_arguments = arguments
                    # Join arguments with ', ' and in case of default value,
                    # join it with '='. Use repr(***REMOVED*** so that strings will be
                    # correctly displayed.
                    print_arguments = ', '.join([
                        '='.join(list(arg_el[:1***REMOVED******REMOVED*** + [repr(el***REMOVED*** for el in arg_el[1:***REMOVED******REMOVED******REMOVED***
                        for arg_el in arguments
                    ***REMOVED******REMOVED***
                    methods.append({
                        'name': func_name,
                        'arguments': print_arguments,
                        'verbose': verbose or '',
                ***REMOVED******REMOVED***

        # Gather related objects
        for rel in opts.related_objects:
            verbose = _("related `%(app_label***REMOVED***s.%(object_name***REMOVED***s` objects"***REMOVED*** % {
                'app_label': rel.related_model._meta.app_label,
                'object_name': rel.related_model._meta.object_name,
        ***REMOVED***
            accessor = rel.get_accessor_name(***REMOVED***
            fields.append({
                'name': "%s.all" % accessor,
                'data_type': 'List',
                'verbose': utils.parse_rst(_("all %s"***REMOVED*** % verbose, 'model', _('model:'***REMOVED*** + opts.model_name***REMOVED***,
        ***REMOVED******REMOVED***
            fields.append({
                'name': "%s.count" % accessor,
                'data_type': 'Integer',
                'verbose': utils.parse_rst(_("number of %s"***REMOVED*** % verbose, 'model', _('model:'***REMOVED*** + opts.model_name***REMOVED***,
        ***REMOVED******REMOVED***
        kwargs.update({
            'name': '%s.%s' % (opts.app_label, opts.object_name***REMOVED***,
            'summary': title,
            'description': body,
            'fields': fields,
            'methods': methods,
    ***REMOVED******REMOVED***
        return super(ModelDetailView, self***REMOVED***.get_context_data(**kwargs***REMOVED***


class TemplateDetailView(BaseAdminDocsView***REMOVED***:
    template_name = 'admin_doc/template_detail.html'

    def get_context_data(self, **kwargs***REMOVED***:
        template = self.kwargs['template'***REMOVED***
        templates = [***REMOVED***
        ***REMOVED***
            default_engine = Engine.get_default(***REMOVED***
        except ImproperlyConfigured:
            # Non-trivial TEMPLATES settings aren't supported (#24125***REMOVED***.
            pass
        else:
            # This doesn't account for template loaders (#24128***REMOVED***.
            for index, directory in enumerate(default_engine.dirs***REMOVED***:
                template_file = os.path.join(directory, template***REMOVED***
                templates.append({
                    'file': template_file,
                    'exists': os.path.exists(template_file***REMOVED***,
                    'contents': lambda: open(template_file***REMOVED***.read(***REMOVED*** if os.path.exists(template_file***REMOVED*** else '',
                    'order': index,
            ***REMOVED******REMOVED***
        kwargs.update({
            'name': template,
            'templates': templates,
    ***REMOVED******REMOVED***
        return super(TemplateDetailView, self***REMOVED***.get_context_data(**kwargs***REMOVED***


####################
# Helper functions #
####################


def get_return_data_type(func_name***REMOVED***:
    ***REMOVED***Return a somewhat-helpful data type given a function name***REMOVED***
    if func_name.startswith('get_'***REMOVED***:
        if func_name.endswith('_list'***REMOVED***:
            return 'List'
        elif func_name.endswith('_count'***REMOVED***:
            return 'Integer'
    return ''


def get_readable_field_data_type(field***REMOVED***:
    ***REMOVED***Returns the description for a given field type, if it exists,
    Fields' descriptions can contain format strings, which will be interpolated
    against the values of field.__dict__ before being output.***REMOVED***

    return field.description % field.__dict__


def extract_views_from_urlpatterns(urlpatterns, base='', namespace=None***REMOVED***:
    ***REMOVED***
    Return a list of views from a list of urlpatterns.

    Each object in the returned list is a two-tuple: (view_func, regex***REMOVED***
    ***REMOVED***
    views = [***REMOVED***
    for p in urlpatterns:
        if hasattr(p, 'url_patterns'***REMOVED***:
            ***REMOVED***
                patterns = p.url_patterns
            except ImportError:
                continue
            views.extend(extract_views_from_urlpatterns(
                patterns,
                base + p.regex.pattern,
                (namespace or [***REMOVED******REMOVED*** + (p.namespace and [p.namespace***REMOVED*** or [***REMOVED******REMOVED***
            ***REMOVED******REMOVED***
        elif hasattr(p, 'callback'***REMOVED***:
            ***REMOVED***
                views.append((p.callback, base + p.regex.pattern,
                              namespace, p.name***REMOVED******REMOVED***
            except ViewDoesNotExist:
                continue
        else:
            raise TypeError(_("%s does not appear to be a urlpattern object"***REMOVED*** % p***REMOVED***
    return views

named_group_matcher = re.compile(r'\(\?P(<\w+>***REMOVED***.+?\***REMOVED***'***REMOVED***
non_named_group_matcher = re.compile(r'\(.*?\***REMOVED***'***REMOVED***


def simplify_regex(pattern***REMOVED***:
    ***REMOVED***
    Clean up urlpattern regexes into something somewhat readable by Mere Humans:
    turns something like "^(?P<sport_slug>\w+***REMOVED***/athletes/(?P<athlete_slug>\w+***REMOVED***/$"
    into "<sport_slug>/athletes/<athlete_slug>/"
    ***REMOVED***
    # handle named groups first
    pattern = named_group_matcher.sub(lambda m: m.group(1***REMOVED***, pattern***REMOVED***

    # handle non-named groups
    pattern = non_named_group_matcher.sub("<var>", pattern***REMOVED***

    # clean up any outstanding regex-y characters.
    pattern = pattern.replace('^', ''***REMOVED***.replace('$', ''***REMOVED***.replace('?', ''***REMOVED***.replace('//', '/'***REMOVED***.replace('\\', ''***REMOVED***
    if not pattern.startswith('/'***REMOVED***:
        pattern = '/' + pattern
    return pattern
