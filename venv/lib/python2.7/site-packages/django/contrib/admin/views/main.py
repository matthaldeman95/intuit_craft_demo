import sys
from collections import OrderedDict

from django.contrib.admin import FieldListFilter
from django.contrib.admin.exceptions import (
    DisallowedModelAdminLookup, DisallowedModelAdminToField,
***REMOVED***
from django.contrib.admin.options import (
    IS_POPUP_VAR, TO_FIELD_VAR, IncorrectLookupParameters,
***REMOVED***
from django.contrib.admin.utils import (
    get_fields_from_path, lookup_needs_distinct, prepare_lookup_value, quote,
***REMOVED***
from django.core.exceptions import (
    FieldDoesNotExist, ImproperlyConfigured, SuspiciousOperation,
***REMOVED***
from django.core.paginator import InvalidPage
from django.db import models
from django.urls import reverse
from django.utils import six
from django.utils.encoding import force_text
from django.utils.http import urlencode
from django.utils.translation import ugettext

# Changelist settings
ALL_VAR = 'all'
ORDER_VAR = 'o'
ORDER_TYPE_VAR = 'ot'
PAGE_VAR = 'p'
SEARCH_VAR = 'q'
ERROR_FLAG = 'e'

IGNORED_PARAMS = (
    ALL_VAR, ORDER_VAR, ORDER_TYPE_VAR, SEARCH_VAR, IS_POPUP_VAR, TO_FIELD_VAR***REMOVED***


class ChangeList(object***REMOVED***:
    def __init__(self, request, model, list_display, list_display_links,
                 list_filter, date_hierarchy, search_fields, list_select_related,
                 list_per_page, list_max_show_all, list_editable, model_admin***REMOVED***:
        self.model = model
        self.opts = model._meta
        self.lookup_opts = self.opts
        self.root_queryset = model_admin.get_queryset(request***REMOVED***
        self.list_display = list_display
        self.list_display_links = list_display_links
        self.list_filter = list_filter
        self.date_hierarchy = date_hierarchy
        self.search_fields = search_fields
        self.list_select_related = list_select_related
        self.list_per_page = list_per_page
        self.list_max_show_all = list_max_show_all
        self.model_admin = model_admin
        self.preserved_filters = model_admin.get_preserved_filters(request***REMOVED***

        # Get search parameters from the query string.
        ***REMOVED***
            self.page_num = int(request.GET.get(PAGE_VAR, 0***REMOVED******REMOVED***
        except ValueError:
            self.page_num = 0
        self.show_all = ALL_VAR in request.GET
        self.is_popup = IS_POPUP_VAR in request.GET
        to_field = request.GET.get(TO_FIELD_VAR***REMOVED***
        if to_field and not model_admin.to_field_allowed(request, to_field***REMOVED***:
            raise DisallowedModelAdminToField("The field %s cannot be referenced." % to_field***REMOVED***
        self.to_field = to_field
        self.params = dict(request.GET.items(***REMOVED******REMOVED***
        if PAGE_VAR in self.params:
            del self.params[PAGE_VAR***REMOVED***
        if ERROR_FLAG in self.params:
            del self.params[ERROR_FLAG***REMOVED***

        if self.is_popup:
            self.list_editable = (***REMOVED***
        else:
            self.list_editable = list_editable
        self.query = request.GET.get(SEARCH_VAR, ''***REMOVED***
        self.queryset = self.get_queryset(request***REMOVED***
        self.get_results(request***REMOVED***
        if self.is_popup:
            title = ugettext('Select %s'***REMOVED***
        else:
            title = ugettext('Select %s to change'***REMOVED***
        self.title = title % force_text(self.opts.verbose_name***REMOVED***
        self.pk_attname = self.lookup_opts.pk.attname

    def get_filters_params(self, params=None***REMOVED***:
        ***REMOVED***
        Returns all params except IGNORED_PARAMS
        ***REMOVED***
        if not params:
            params = self.params
        lookup_params = params.copy(***REMOVED***  # a dictionary of the query string
        # Remove all the parameters that are globally and systematically
        # ignored.
        for ignored in IGNORED_PARAMS:
            if ignored in lookup_params:
                del lookup_params[ignored***REMOVED***
        return lookup_params

    def get_filters(self, request***REMOVED***:
        lookup_params = self.get_filters_params(***REMOVED***
        use_distinct = False

        for key, value in lookup_params.items(***REMOVED***:
            if not self.model_admin.lookup_allowed(key, value***REMOVED***:
                raise DisallowedModelAdminLookup("Filtering by %s not allowed" % key***REMOVED***

        filter_specs = [***REMOVED***
        if self.list_filter:
            for list_filter in self.list_filter:
                if callable(list_filter***REMOVED***:
                    # This is simply a custom list filter class.
                    spec = list_filter(request, lookup_params, self.model, self.model_admin***REMOVED***
                else:
                    field_path = None
                    if isinstance(list_filter, (tuple, list***REMOVED******REMOVED***:
                        # This is a custom FieldListFilter class for a given field.
                        field, field_list_filter_class = list_filter
                    else:
                        # This is simply a field name, so use the default
                        # FieldListFilter class that has been registered for
                        # the type of the given field.
                        field, field_list_filter_class = list_filter, FieldListFilter.create
                    if not isinstance(field, models.Field***REMOVED***:
                        field_path = field
                        field = get_fields_from_path(self.model, field_path***REMOVED***[-1***REMOVED***
                    spec = field_list_filter_class(
                        field, request, lookup_params,
                        self.model, self.model_admin, field_path=field_path
                    ***REMOVED***
                    # Check if we need to use distinct(***REMOVED***
                    use_distinct = use_distinct or lookup_needs_distinct(self.lookup_opts, field_path***REMOVED***
                if spec and spec.has_output(***REMOVED***:
                    filter_specs.append(spec***REMOVED***

        # At this point, all the parameters used by the various ListFilters
        # have been removed from lookup_params, which now only contains other
        # parameters passed via the query string. We now loop through the
        # remaining parameters both to ensure that all the parameters are valid
        # fields and to determine if at least one of them needs distinct(***REMOVED***. If
        # the lookup parameters aren't real fields, then bail out.
        ***REMOVED***
            for key, value in lookup_params.items(***REMOVED***:
                lookup_params[key***REMOVED*** = prepare_lookup_value(key, value***REMOVED***
                use_distinct = use_distinct or lookup_needs_distinct(self.lookup_opts, key***REMOVED***
            return filter_specs, bool(filter_specs***REMOVED***, lookup_params, use_distinct
        except FieldDoesNotExist as e:
            six.reraise(IncorrectLookupParameters, IncorrectLookupParameters(e***REMOVED***, sys.exc_info(***REMOVED***[2***REMOVED******REMOVED***

    def get_query_string(self, new_params=None, remove=None***REMOVED***:
        if new_params is None:
            new_params = {***REMOVED***
        if remove is None:
            remove = [***REMOVED***
        p = self.params.copy(***REMOVED***
        for r in remove:
            for k in list(p***REMOVED***:
                if k.startswith(r***REMOVED***:
                    del p[k***REMOVED***
        for k, v in new_params.items(***REMOVED***:
            if v is None:
                if k in p:
                    del p[k***REMOVED***
            else:
                p[k***REMOVED*** = v
        return '?%s' % urlencode(sorted(p.items(***REMOVED******REMOVED******REMOVED***

    def get_results(self, request***REMOVED***:
        paginator = self.model_admin.get_paginator(request, self.queryset, self.list_per_page***REMOVED***
        # Get the number of objects, with admin filters applied.
        result_count = paginator.count

        # Get the total number of objects, with no admin filters applied.
        if self.model_admin.show_full_result_count:
            full_result_count = self.root_queryset.count(***REMOVED***
        else:
            full_result_count = None
        can_show_all = result_count <= self.list_max_show_all
        multi_page = result_count > self.list_per_page

        # Get the list of objects to display on this page.
        if (self.show_all and can_show_all***REMOVED*** or not multi_page:
            result_list = self.queryset._clone(***REMOVED***
        else:
            ***REMOVED***
                result_list = paginator.page(self.page_num + 1***REMOVED***.object_list
            except InvalidPage:
                raise IncorrectLookupParameters

        self.result_count = result_count
        self.show_full_result_count = self.model_admin.show_full_result_count
        # Admin actions are shown if there is at least one entry
        # or if entries are not counted because show_full_result_count is disabled
        self.show_admin_actions = not self.show_full_result_count or bool(full_result_count***REMOVED***
        self.full_result_count = full_result_count
        self.result_list = result_list
        self.can_show_all = can_show_all
        self.multi_page = multi_page
        self.paginator = paginator

    def _get_default_ordering(self***REMOVED***:
        ordering = [***REMOVED***
        if self.model_admin.ordering:
            ordering = self.model_admin.ordering
        elif self.lookup_opts.ordering:
            ordering = self.lookup_opts.ordering
        return ordering

    def get_ordering_field(self, field_name***REMOVED***:
        ***REMOVED***
        Returns the proper model field name corresponding to the given
        field_name to use for ordering. field_name may either be the name of a
        proper model field or the name of a method (on the admin or model***REMOVED*** or a
        callable with the 'admin_order_field' attribute. Returns None if no
        proper model field name can be matched.
        ***REMOVED***
        ***REMOVED***
            field = self.lookup_opts.get_field(field_name***REMOVED***
            return field.name
        except FieldDoesNotExist:
            # See whether field_name is a name of a non-field
            # that allows sorting.
            if callable(field_name***REMOVED***:
                attr = field_name
            elif hasattr(self.model_admin, field_name***REMOVED***:
                attr = getattr(self.model_admin, field_name***REMOVED***
            else:
                attr = getattr(self.model, field_name***REMOVED***
            return getattr(attr, 'admin_order_field', None***REMOVED***

    def get_ordering(self, request, queryset***REMOVED***:
        ***REMOVED***
        Returns the list of ordering fields for the change list.
        First we check the get_ordering(***REMOVED*** method in model admin, then we check
        the object's default ordering. Then, any manually-specified ordering
        from the query string overrides anything. Finally, a deterministic
        order is guaranteed by ensuring the primary key is used as the last
        ordering field.
        ***REMOVED***
        params = self.params
        ordering = list(self.model_admin.get_ordering(request***REMOVED*** or self._get_default_ordering(***REMOVED******REMOVED***
        if ORDER_VAR in params:
            # Clear ordering and used params
            ordering = [***REMOVED***
            order_params = params[ORDER_VAR***REMOVED***.split('.'***REMOVED***
            for p in order_params:
                ***REMOVED***
                    none, pfx, idx = p.rpartition('-'***REMOVED***
                    field_name = self.list_display[int(idx***REMOVED******REMOVED***
                    order_field = self.get_ordering_field(field_name***REMOVED***
                    if not order_field:
                        continue  # No 'admin_order_field', skip it
                    # reverse order if order_field has already "-" as prefix
                    if order_field.startswith('-'***REMOVED*** and pfx == "-":
                        ordering.append(order_field[1:***REMOVED******REMOVED***
                    else:
                        ordering.append(pfx + order_field***REMOVED***
                except (IndexError, ValueError***REMOVED***:
                    continue  # Invalid ordering specified, skip it.

        # Add the given query's ordering fields, if any.
        ordering.extend(queryset.query.order_by***REMOVED***

        # Ensure that the primary key is systematically present in the list of
        # ordering fields so we can guarantee a deterministic order across all
        # database backends.
        pk_name = self.lookup_opts.pk.name
        if not (set(ordering***REMOVED*** & {'pk', '-pk', pk_name, '-' + pk_name***REMOVED******REMOVED***:
            # The two sets do not intersect, meaning the pk isn't present. So
            # we add it.
            ordering.append('-pk'***REMOVED***

        return ordering

    def get_ordering_field_columns(self***REMOVED***:
        ***REMOVED***
        Returns an OrderedDict of ordering field column numbers and asc/desc
        ***REMOVED***

        # We must cope with more than one column having the same underlying sort
        # field, so we base things on column numbers.
        ordering = self._get_default_ordering(***REMOVED***
        ordering_fields = OrderedDict(***REMOVED***
        if ORDER_VAR not in self.params:
            # for ordering specified on ModelAdmin or model Meta, we don't know
            # the right column numbers absolutely, because there might be more
            # than one column associated with that ordering, so we guess.
            for field in ordering:
                if field.startswith('-'***REMOVED***:
                    field = field[1:***REMOVED***
                    order_type = 'desc'
                else:
                    order_type = 'asc'
                for index, attr in enumerate(self.list_display***REMOVED***:
                    if self.get_ordering_field(attr***REMOVED*** == field:
                        ordering_fields[index***REMOVED*** = order_type
                        break
        else:
            for p in self.params[ORDER_VAR***REMOVED***.split('.'***REMOVED***:
                none, pfx, idx = p.rpartition('-'***REMOVED***
                ***REMOVED***
                    idx = int(idx***REMOVED***
                except ValueError:
                    continue  # skip it
                ordering_fields[idx***REMOVED*** = 'desc' if pfx == '-' else 'asc'
        return ordering_fields

    def get_queryset(self, request***REMOVED***:
        # First, we collect all the declared list filters.
        (self.filter_specs, self.has_filters, remaining_lookup_params,
         filters_use_distinct***REMOVED*** = self.get_filters(request***REMOVED***

        # Then, we let every list filter modify the queryset to its liking.
        qs = self.root_queryset
        for filter_spec in self.filter_specs:
            new_qs = filter_spec.queryset(request, qs***REMOVED***
            if new_qs is not None:
                qs = new_qs

        ***REMOVED***
            # Finally, we apply the remaining lookup parameters from the query
            # string (i.e. those that haven't already been processed by the
            # filters***REMOVED***.
            qs = qs.filter(**remaining_lookup_params***REMOVED***
        except (SuspiciousOperation, ImproperlyConfigured***REMOVED***:
            # Allow certain types of errors to be re-raised as-is so that the
            # caller can treat them in a special way.
            raise
        except Exception as e:
            # Every other error is caught with a naked except, because we don't
            # have any other way of validating lookup parameters. They might be
            # invalid if the keyword arguments are incorrect, or if the values
            # are not in the correct type, so we might get FieldError,
            # ValueError, ValidationError, or ?.
            raise IncorrectLookupParameters(e***REMOVED***

        if not qs.query.select_related:
            qs = self.apply_select_related(qs***REMOVED***

        # Set ordering.
        ordering = self.get_ordering(request, qs***REMOVED***
        qs = qs.order_by(*ordering***REMOVED***

        # Apply search results
        qs, search_use_distinct = self.model_admin.get_search_results(request, qs, self.query***REMOVED***

        # Remove duplicates from results, if necessary
        if filters_use_distinct | search_use_distinct:
            return qs.distinct(***REMOVED***
        else:
            return qs

    def apply_select_related(self, qs***REMOVED***:
        if self.list_select_related is True:
            return qs.select_related(***REMOVED***

        if self.list_select_related is False:
            if self.has_related_field_in_list_display(***REMOVED***:
                return qs.select_related(***REMOVED***

        if self.list_select_related:
            return qs.select_related(*self.list_select_related***REMOVED***
        return qs

    def has_related_field_in_list_display(self***REMOVED***:
        for field_name in self.list_display:
            ***REMOVED***
                field = self.lookup_opts.get_field(field_name***REMOVED***
            except FieldDoesNotExist:
                pass
            else:
                if isinstance(field.remote_field, models.ManyToOneRel***REMOVED***:
                    return True
        return False

    def url_for_result(self, result***REMOVED***:
        pk = getattr(result, self.pk_attname***REMOVED***
        return reverse('admin:%s_%s_change' % (self.opts.app_label,
                                               self.opts.model_name***REMOVED***,
                       args=(quote(pk***REMOVED***,***REMOVED***,
                       current_app=self.model_admin.admin_site.name***REMOVED***
