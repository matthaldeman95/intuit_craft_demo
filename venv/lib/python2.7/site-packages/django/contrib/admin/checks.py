# -*- coding: utf-8 -*-
from __future__ import unicode_literals

from itertools import chain

from django.apps import apps
from django.conf import settings
from django.contrib.admin.utils import (
    NotRelationField, flatten, get_fields_from_path,
***REMOVED***
from django.core import checks
from django.core.exceptions import FieldDoesNotExist
from django.db import models
from django.forms.models import (
    BaseModelForm, BaseModelFormSet, _get_foreign_key,
***REMOVED***
from django.template.engine import Engine


def check_admin_app(**kwargs***REMOVED***:
    from django.contrib.admin.sites import system_check_errors

    return system_check_errors


def check_dependencies(**kwargs***REMOVED***:
    ***REMOVED***
    Check that the admin's dependencies are correctly installed.
    ***REMOVED***
    errors = [***REMOVED***
    # contrib.contenttypes must be installed.
    if not apps.is_installed('django.contrib.contenttypes'***REMOVED***:
        missing_app = checks.Error(
            "'django.contrib.contenttypes' must be in INSTALLED_APPS in order "
            "to use the admin application.",
            id="admin.E401",
        ***REMOVED***
        errors.append(missing_app***REMOVED***
    # The auth context processor must be installed if using the default
    # authentication backend.
    ***REMOVED***
        default_template_engine = Engine.get_default(***REMOVED***
    except Exception:
        # Skip this non-critical check:
        # 1. if the user has a non-trivial TEMPLATES setting and Django
        #    can't find a default template engine
        # 2. if anything goes wrong while loading template engines, in
        #    order to avoid raising an exception from a confusing location
        # Catching ImproperlyConfigured suffices for 1. but 2. requires
        # catching all exceptions.
        pass
    else:
        if ('django.contrib.auth.context_processors.auth'
                not in default_template_engine.context_processors and
                'django.contrib.auth.backends.ModelBackend' in settings.AUTHENTICATION_BACKENDS***REMOVED***:
            missing_template = checks.Error(
                "'django.contrib.auth.context_processors.auth' must be in "
                "TEMPLATES in order to use the admin application.",
                id="admin.E402"
            ***REMOVED***
            errors.append(missing_template***REMOVED***
    return errors


class BaseModelAdminChecks(object***REMOVED***:

    def check(self, admin_obj, **kwargs***REMOVED***:
        errors = [***REMOVED***
        errors.extend(self._check_raw_id_fields(admin_obj***REMOVED******REMOVED***
        errors.extend(self._check_fields(admin_obj***REMOVED******REMOVED***
        errors.extend(self._check_fieldsets(admin_obj***REMOVED******REMOVED***
        errors.extend(self._check_exclude(admin_obj***REMOVED******REMOVED***
        errors.extend(self._check_form(admin_obj***REMOVED******REMOVED***
        errors.extend(self._check_filter_vertical(admin_obj***REMOVED******REMOVED***
        errors.extend(self._check_filter_horizontal(admin_obj***REMOVED******REMOVED***
        errors.extend(self._check_radio_fields(admin_obj***REMOVED******REMOVED***
        errors.extend(self._check_prepopulated_fields(admin_obj***REMOVED******REMOVED***
        errors.extend(self._check_view_on_site_url(admin_obj***REMOVED******REMOVED***
        errors.extend(self._check_ordering(admin_obj***REMOVED******REMOVED***
        errors.extend(self._check_readonly_fields(admin_obj***REMOVED******REMOVED***
        return errors

    def _check_raw_id_fields(self, obj***REMOVED***:
        ***REMOVED*** Check that `raw_id_fields` only contains field names that are listed
        on the model. ***REMOVED***

        if not isinstance(obj.raw_id_fields, (list, tuple***REMOVED******REMOVED***:
            return must_be('a list or tuple', option='raw_id_fields', obj=obj, id='admin.E001'***REMOVED***
        else:
            return list(chain(*[
                self._check_raw_id_fields_item(obj, obj.model, field_name, 'raw_id_fields[%d***REMOVED***' % index***REMOVED***
                for index, field_name in enumerate(obj.raw_id_fields***REMOVED***
            ***REMOVED******REMOVED******REMOVED***

    def _check_raw_id_fields_item(self, obj, model, field_name, label***REMOVED***:
        ***REMOVED*** Check an item of `raw_id_fields`, i.e. check that field named
        `field_name` exists in model `model` and is a ForeignKey or a
        ManyToManyField. ***REMOVED***

        ***REMOVED***
            field = model._meta.get_field(field_name***REMOVED***
        except FieldDoesNotExist:
            return refer_to_missing_field(field=field_name, option=label,
                                          model=model, obj=obj, id='admin.E002'***REMOVED***
        else:
            if not field.many_to_many and not isinstance(field, models.ForeignKey***REMOVED***:
                return must_be('a foreign key or a many-to-many field',
                               option=label, obj=obj, id='admin.E003'***REMOVED***
            else:
                return [***REMOVED***

    def _check_fields(self, obj***REMOVED***:
        ***REMOVED*** Check that `fields` only refer to existing fields, doesn't contain
        duplicates. Check if at most one of `fields` and `fieldsets` is defined.
        ***REMOVED***

        if obj.fields is None:
            return [***REMOVED***
        elif not isinstance(obj.fields, (list, tuple***REMOVED******REMOVED***:
            return must_be('a list or tuple', option='fields', obj=obj, id='admin.E004'***REMOVED***
        elif obj.fieldsets:
            return [
                checks.Error(
                    "Both 'fieldsets' and 'fields' are specified.",
                    obj=obj.__class__,
                    id='admin.E005',
                ***REMOVED***
            ***REMOVED***
        fields = flatten(obj.fields***REMOVED***
        if len(fields***REMOVED*** != len(set(fields***REMOVED******REMOVED***:
            return [
                checks.Error(
                    "The value of 'fields' contains duplicate field(s***REMOVED***.",
                    obj=obj.__class__,
                    id='admin.E006',
                ***REMOVED***
            ***REMOVED***

        return list(chain(*[
            self._check_field_spec(obj, obj.model, field_name, 'fields'***REMOVED***
            for field_name in obj.fields
        ***REMOVED******REMOVED******REMOVED***

    def _check_fieldsets(self, obj***REMOVED***:
        ***REMOVED*** Check that fieldsets is properly formatted and doesn't contain
        duplicates. ***REMOVED***

        if obj.fieldsets is None:
            return [***REMOVED***
        elif not isinstance(obj.fieldsets, (list, tuple***REMOVED******REMOVED***:
            return must_be('a list or tuple', option='fieldsets', obj=obj, id='admin.E007'***REMOVED***
        else:
            return list(chain(*[
                self._check_fieldsets_item(obj, obj.model, fieldset, 'fieldsets[%d***REMOVED***' % index***REMOVED***
                for index, fieldset in enumerate(obj.fieldsets***REMOVED***
            ***REMOVED******REMOVED******REMOVED***

    def _check_fieldsets_item(self, obj, model, fieldset, label***REMOVED***:
        ***REMOVED*** Check an item of `fieldsets`, i.e. check that this is a pair of a
        set name and a dictionary containing "fields" key. ***REMOVED***

        if not isinstance(fieldset, (list, tuple***REMOVED******REMOVED***:
            return must_be('a list or tuple', option=label, obj=obj, id='admin.E008'***REMOVED***
        elif len(fieldset***REMOVED*** != 2:
            return must_be('of length 2', option=label, obj=obj, id='admin.E009'***REMOVED***
        elif not isinstance(fieldset[1***REMOVED***, dict***REMOVED***:
            return must_be('a dictionary', option='%s[1***REMOVED***' % label, obj=obj, id='admin.E010'***REMOVED***
        elif 'fields' not in fieldset[1***REMOVED***:
            return [
                checks.Error(
                    "The value of '%s[1***REMOVED***' must contain the key 'fields'." % label,
                    obj=obj.__class__,
                    id='admin.E011',
                ***REMOVED***
            ***REMOVED***
        elif not isinstance(fieldset[1***REMOVED***['fields'***REMOVED***, (list, tuple***REMOVED******REMOVED***:
            return must_be('a list or tuple', option="%s[1***REMOVED***['fields'***REMOVED***" % label, obj=obj, id='admin.E008'***REMOVED***

        fields = flatten(fieldset[1***REMOVED***['fields'***REMOVED******REMOVED***
        if len(fields***REMOVED*** != len(set(fields***REMOVED******REMOVED***:
            return [
                checks.Error(
                    "There are duplicate field(s***REMOVED*** in '%s[1***REMOVED***'." % label,
                    obj=obj.__class__,
                    id='admin.E012',
                ***REMOVED***
            ***REMOVED***
        return list(chain(*[
            self._check_field_spec(obj, model, fieldset_fields, '%s[1***REMOVED***["fields"***REMOVED***' % label***REMOVED***
            for fieldset_fields in fieldset[1***REMOVED***['fields'***REMOVED***
        ***REMOVED******REMOVED******REMOVED***

    def _check_field_spec(self, obj, model, fields, label***REMOVED***:
        ***REMOVED*** `fields` should be an item of `fields` or an item of
        fieldset[1***REMOVED***['fields'***REMOVED*** for any `fieldset` in `fieldsets`. It should be a
        field name or a tuple of field names. ***REMOVED***

        if isinstance(fields, tuple***REMOVED***:
            return list(chain(*[
                self._check_field_spec_item(obj, model, field_name, "%s[%d***REMOVED***" % (label, index***REMOVED******REMOVED***
                for index, field_name in enumerate(fields***REMOVED***
            ***REMOVED******REMOVED******REMOVED***
        else:
            return self._check_field_spec_item(obj, model, fields, label***REMOVED***

    def _check_field_spec_item(self, obj, model, field_name, label***REMOVED***:
        if field_name in obj.readonly_fields:
            # Stuff can be put in fields that isn't actually a model field if
            # it's in readonly_fields, readonly_fields will handle the
            # validation of such things.
            return [***REMOVED***
        else:
            ***REMOVED***
                field = model._meta.get_field(field_name***REMOVED***
            except FieldDoesNotExist:
                # If we can't find a field on the model that matches, it could
                # be an extra field on the form.
                return [***REMOVED***
            else:
                if (isinstance(field, models.ManyToManyField***REMOVED*** and
                        not field.remote_field.through._meta.auto_created***REMOVED***:
                    return [
                        checks.Error(
                            "The value of '%s' cannot include the ManyToManyField '%s', "
                            "because that field manually specifies a relationship model."
                            % (label, field_name***REMOVED***,
                            obj=obj.__class__,
                            id='admin.E013',
                        ***REMOVED***
                    ***REMOVED***
                else:
                    return [***REMOVED***

    def _check_exclude(self, obj***REMOVED***:
        ***REMOVED*** Check that exclude is a sequence without duplicates. ***REMOVED***

        if obj.exclude is None:  # default value is None
            return [***REMOVED***
        elif not isinstance(obj.exclude, (list, tuple***REMOVED******REMOVED***:
            return must_be('a list or tuple', option='exclude', obj=obj, id='admin.E014'***REMOVED***
        elif len(obj.exclude***REMOVED*** > len(set(obj.exclude***REMOVED******REMOVED***:
            return [
                checks.Error(
                    "The value of 'exclude' contains duplicate field(s***REMOVED***.",
                    obj=obj.__class__,
                    id='admin.E015',
                ***REMOVED***
            ***REMOVED***
        else:
            return [***REMOVED***

    def _check_form(self, obj***REMOVED***:
        ***REMOVED*** Check that form subclasses BaseModelForm. ***REMOVED***

        if hasattr(obj, 'form'***REMOVED*** and not issubclass(obj.form, BaseModelForm***REMOVED***:
            return must_inherit_from(parent='BaseModelForm', option='form',
                                     obj=obj, id='admin.E016'***REMOVED***
        else:
            return [***REMOVED***

    def _check_filter_vertical(self, obj***REMOVED***:
        ***REMOVED*** Check that filter_vertical is a sequence of field names. ***REMOVED***

        if not hasattr(obj, 'filter_vertical'***REMOVED***:
            return [***REMOVED***
        elif not isinstance(obj.filter_vertical, (list, tuple***REMOVED******REMOVED***:
            return must_be('a list or tuple', option='filter_vertical', obj=obj, id='admin.E017'***REMOVED***
        else:
            return list(chain(*[
                self._check_filter_item(obj, obj.model, field_name, "filter_vertical[%d***REMOVED***" % index***REMOVED***
                for index, field_name in enumerate(obj.filter_vertical***REMOVED***
            ***REMOVED******REMOVED******REMOVED***

    def _check_filter_horizontal(self, obj***REMOVED***:
        ***REMOVED*** Check that filter_horizontal is a sequence of field names. ***REMOVED***

        if not hasattr(obj, 'filter_horizontal'***REMOVED***:
            return [***REMOVED***
        elif not isinstance(obj.filter_horizontal, (list, tuple***REMOVED******REMOVED***:
            return must_be('a list or tuple', option='filter_horizontal', obj=obj, id='admin.E018'***REMOVED***
        else:
            return list(chain(*[
                self._check_filter_item(obj, obj.model, field_name, "filter_horizontal[%d***REMOVED***" % index***REMOVED***
                for index, field_name in enumerate(obj.filter_horizontal***REMOVED***
            ***REMOVED******REMOVED******REMOVED***

    def _check_filter_item(self, obj, model, field_name, label***REMOVED***:
        ***REMOVED*** Check one item of `filter_vertical` or `filter_horizontal`, i.e.
        check that given field exists and is a ManyToManyField. ***REMOVED***

        ***REMOVED***
            field = model._meta.get_field(field_name***REMOVED***
        except FieldDoesNotExist:
            return refer_to_missing_field(field=field_name, option=label,
                                          model=model, obj=obj, id='admin.E019'***REMOVED***
        else:
            if not field.many_to_many:
                return must_be('a many-to-many field', option=label, obj=obj, id='admin.E020'***REMOVED***
            else:
                return [***REMOVED***

    def _check_radio_fields(self, obj***REMOVED***:
        ***REMOVED*** Check that `radio_fields` is a dictionary. ***REMOVED***

        if not hasattr(obj, 'radio_fields'***REMOVED***:
            return [***REMOVED***
        elif not isinstance(obj.radio_fields, dict***REMOVED***:
            return must_be('a dictionary', option='radio_fields', obj=obj, id='admin.E021'***REMOVED***
        else:
            return list(chain(*[
                self._check_radio_fields_key(obj, obj.model, field_name, 'radio_fields'***REMOVED*** +
                self._check_radio_fields_value(obj, val, 'radio_fields["%s"***REMOVED***' % field_name***REMOVED***
                for field_name, val in obj.radio_fields.items(***REMOVED***
            ***REMOVED******REMOVED******REMOVED***

    def _check_radio_fields_key(self, obj, model, field_name, label***REMOVED***:
        ***REMOVED*** Check that a key of `radio_fields` dictionary is name of existing
        field and that the field is a ForeignKey or has `choices` defined. ***REMOVED***

        ***REMOVED***
            field = model._meta.get_field(field_name***REMOVED***
        except FieldDoesNotExist:
            return refer_to_missing_field(field=field_name, option=label,
                                          model=model, obj=obj, id='admin.E022'***REMOVED***
        else:
            if not (isinstance(field, models.ForeignKey***REMOVED*** or field.choices***REMOVED***:
                return [
                    checks.Error(
                        "The value of '%s' refers to '%s', which is not an "
                        "instance of ForeignKey, and does not have a 'choices' definition." % (
                            label, field_name
                        ***REMOVED***,
                        obj=obj.__class__,
                        id='admin.E023',
                    ***REMOVED***
                ***REMOVED***
            else:
                return [***REMOVED***

    def _check_radio_fields_value(self, obj, val, label***REMOVED***:
        ***REMOVED*** Check type of a value of `radio_fields` dictionary. ***REMOVED***

        from django.contrib.admin.options import HORIZONTAL, VERTICAL

        if val not in (HORIZONTAL, VERTICAL***REMOVED***:
            return [
                checks.Error(
                    "The value of '%s' must be either admin.HORIZONTAL or admin.VERTICAL." % label,
                    obj=obj.__class__,
                    id='admin.E024',
                ***REMOVED***
            ***REMOVED***
        else:
            return [***REMOVED***

    def _check_view_on_site_url(self, obj***REMOVED***:
        if hasattr(obj, 'view_on_site'***REMOVED***:
            if not callable(obj.view_on_site***REMOVED*** and not isinstance(obj.view_on_site, bool***REMOVED***:
                return [
                    checks.Error(
                        "The value of 'view_on_site' must be a callable or a boolean value.",
                        obj=obj.__class__,
                        id='admin.E025',
                    ***REMOVED***
                ***REMOVED***
            else:
                return [***REMOVED***
        else:
            return [***REMOVED***

    def _check_prepopulated_fields(self, obj***REMOVED***:
        ***REMOVED*** Check that `prepopulated_fields` is a dictionary containing allowed
        field types. ***REMOVED***

        if not hasattr(obj, 'prepopulated_fields'***REMOVED***:
            return [***REMOVED***
        elif not isinstance(obj.prepopulated_fields, dict***REMOVED***:
            return must_be('a dictionary', option='prepopulated_fields', obj=obj, id='admin.E026'***REMOVED***
        else:
            return list(chain(*[
                self._check_prepopulated_fields_key(obj, obj.model, field_name, 'prepopulated_fields'***REMOVED*** +
                self._check_prepopulated_fields_value(obj, obj.model, val, 'prepopulated_fields["%s"***REMOVED***' % field_name***REMOVED***
                for field_name, val in obj.prepopulated_fields.items(***REMOVED***
            ***REMOVED******REMOVED******REMOVED***

    def _check_prepopulated_fields_key(self, obj, model, field_name, label***REMOVED***:
        ***REMOVED*** Check a key of `prepopulated_fields` dictionary, i.e. check that it
        is a name of existing field and the field is one of the allowed types.
        ***REMOVED***

        ***REMOVED***
            field = model._meta.get_field(field_name***REMOVED***
        except FieldDoesNotExist:
            return refer_to_missing_field(field=field_name, option=label,
                                          model=model, obj=obj, id='admin.E027'***REMOVED***
        else:
            if isinstance(field, (models.DateTimeField, models.ForeignKey, models.ManyToManyField***REMOVED******REMOVED***:
                return [
                    checks.Error(
                        "The value of '%s' refers to '%s', which must not be a DateTimeField, "
                        "a ForeignKey, or a ManyToManyField." % (label, field_name***REMOVED***,
                        obj=obj.__class__,
                        id='admin.E028',
                    ***REMOVED***
                ***REMOVED***
            else:
                return [***REMOVED***

    def _check_prepopulated_fields_value(self, obj, model, val, label***REMOVED***:
        ***REMOVED*** Check a value of `prepopulated_fields` dictionary, i.e. it's an
        iterable of existing fields. ***REMOVED***

        if not isinstance(val, (list, tuple***REMOVED******REMOVED***:
            return must_be('a list or tuple', option=label, obj=obj, id='admin.E029'***REMOVED***
        else:
            return list(chain(*[
                self._check_prepopulated_fields_value_item(obj, model, subfield_name, "%s[%r***REMOVED***" % (label, index***REMOVED******REMOVED***
                for index, subfield_name in enumerate(val***REMOVED***
            ***REMOVED******REMOVED******REMOVED***

    def _check_prepopulated_fields_value_item(self, obj, model, field_name, label***REMOVED***:
        ***REMOVED*** For `prepopulated_fields` equal to {"slug": ("title",***REMOVED******REMOVED***,
        `field_name` is "title". ***REMOVED***

        ***REMOVED***
            model._meta.get_field(field_name***REMOVED***
        except FieldDoesNotExist:
            return refer_to_missing_field(field=field_name, option=label, model=model, obj=obj, id='admin.E030'***REMOVED***
        else:
            return [***REMOVED***

    def _check_ordering(self, obj***REMOVED***:
        ***REMOVED*** Check that ordering refers to existing fields or is random. ***REMOVED***

        # ordering = None
        if obj.ordering is None:  # The default value is None
            return [***REMOVED***
        elif not isinstance(obj.ordering, (list, tuple***REMOVED******REMOVED***:
            return must_be('a list or tuple', option='ordering', obj=obj, id='admin.E031'***REMOVED***
        else:
            return list(chain(*[
                self._check_ordering_item(obj, obj.model, field_name, 'ordering[%d***REMOVED***' % index***REMOVED***
                for index, field_name in enumerate(obj.ordering***REMOVED***
            ***REMOVED******REMOVED******REMOVED***

    def _check_ordering_item(self, obj, model, field_name, label***REMOVED***:
        ***REMOVED*** Check that `ordering` refers to existing fields. ***REMOVED***

        if field_name == '?' and len(obj.ordering***REMOVED*** != 1:
            return [
                checks.Error(
                    "The value of 'ordering' has the random ordering marker '?', "
                    "but contains other fields as well.",
                    hint='Either remove the "?", or remove the other fields.',
                    obj=obj.__class__,
                    id='admin.E032',
                ***REMOVED***
            ***REMOVED***
        elif field_name == '?':
            return [***REMOVED***
        elif '__' in field_name:
            # Skip ordering in the format field1__field2 (FIXME: checking
            # this format would be nice, but it's a little fiddly***REMOVED***.
            return [***REMOVED***
        else:
            if field_name.startswith('-'***REMOVED***:
                field_name = field_name[1:***REMOVED***

            ***REMOVED***
                model._meta.get_field(field_name***REMOVED***
            except FieldDoesNotExist:
                return refer_to_missing_field(field=field_name, option=label, model=model, obj=obj, id='admin.E033'***REMOVED***
            else:
                return [***REMOVED***

    def _check_readonly_fields(self, obj***REMOVED***:
        ***REMOVED*** Check that readonly_fields refers to proper attribute or field. ***REMOVED***

        if obj.readonly_fields == (***REMOVED***:
            return [***REMOVED***
        elif not isinstance(obj.readonly_fields, (list, tuple***REMOVED******REMOVED***:
            return must_be('a list or tuple', option='readonly_fields', obj=obj, id='admin.E034'***REMOVED***
        else:
            return list(chain(*[
                self._check_readonly_fields_item(obj, obj.model, field_name, "readonly_fields[%d***REMOVED***" % index***REMOVED***
                for index, field_name in enumerate(obj.readonly_fields***REMOVED***
            ***REMOVED******REMOVED******REMOVED***

    def _check_readonly_fields_item(self, obj, model, field_name, label***REMOVED***:
        if callable(field_name***REMOVED***:
            return [***REMOVED***
        elif hasattr(obj, field_name***REMOVED***:
            return [***REMOVED***
        elif hasattr(model, field_name***REMOVED***:
            return [***REMOVED***
        else:
            ***REMOVED***
                model._meta.get_field(field_name***REMOVED***
            except FieldDoesNotExist:
                return [
                    checks.Error(
                        "The value of '%s' is not a callable, an attribute of '%s', or an attribute of '%s.%s'." % (
                            label, obj.__class__.__name__, model._meta.app_label, model._meta.object_name
                        ***REMOVED***,
                        obj=obj.__class__,
                        id='admin.E035',
                    ***REMOVED***
                ***REMOVED***
            else:
                return [***REMOVED***


class ModelAdminChecks(BaseModelAdminChecks***REMOVED***:

    def check(self, admin_obj, **kwargs***REMOVED***:
        errors = super(ModelAdminChecks, self***REMOVED***.check(admin_obj***REMOVED***
        errors.extend(self._check_save_as(admin_obj***REMOVED******REMOVED***
        errors.extend(self._check_save_on_top(admin_obj***REMOVED******REMOVED***
        errors.extend(self._check_inlines(admin_obj***REMOVED******REMOVED***
        errors.extend(self._check_list_display(admin_obj***REMOVED******REMOVED***
        errors.extend(self._check_list_display_links(admin_obj***REMOVED******REMOVED***
        errors.extend(self._check_list_filter(admin_obj***REMOVED******REMOVED***
        errors.extend(self._check_list_select_related(admin_obj***REMOVED******REMOVED***
        errors.extend(self._check_list_per_page(admin_obj***REMOVED******REMOVED***
        errors.extend(self._check_list_max_show_all(admin_obj***REMOVED******REMOVED***
        errors.extend(self._check_list_editable(admin_obj***REMOVED******REMOVED***
        errors.extend(self._check_search_fields(admin_obj***REMOVED******REMOVED***
        errors.extend(self._check_date_hierarchy(admin_obj***REMOVED******REMOVED***
        return errors

    def _check_save_as(self, obj***REMOVED***:
        ***REMOVED*** Check save_as is a boolean. ***REMOVED***

        if not isinstance(obj.save_as, bool***REMOVED***:
            return must_be('a boolean', option='save_as',
                           obj=obj, id='admin.E101'***REMOVED***
        else:
            return [***REMOVED***

    def _check_save_on_top(self, obj***REMOVED***:
        ***REMOVED*** Check save_on_top is a boolean. ***REMOVED***

        if not isinstance(obj.save_on_top, bool***REMOVED***:
            return must_be('a boolean', option='save_on_top',
                           obj=obj, id='admin.E102'***REMOVED***
        else:
            return [***REMOVED***

    def _check_inlines(self, obj***REMOVED***:
        ***REMOVED*** Check all inline model admin classes. ***REMOVED***

        if not isinstance(obj.inlines, (list, tuple***REMOVED******REMOVED***:
            return must_be('a list or tuple', option='inlines', obj=obj, id='admin.E103'***REMOVED***
        else:
            return list(chain(*[
                self._check_inlines_item(obj, obj.model, item, "inlines[%d***REMOVED***" % index***REMOVED***
                for index, item in enumerate(obj.inlines***REMOVED***
            ***REMOVED******REMOVED******REMOVED***

    def _check_inlines_item(self, obj, model, inline, label***REMOVED***:
        ***REMOVED*** Check one inline model admin. ***REMOVED***
        inline_label = '.'.join([inline.__module__, inline.__name__***REMOVED******REMOVED***

        from django.contrib.admin.options import BaseModelAdmin

        if not issubclass(inline, BaseModelAdmin***REMOVED***:
            return [
                checks.Error(
                    "'%s' must inherit from 'BaseModelAdmin'." % inline_label,
                    obj=obj.__class__,
                    id='admin.E104',
                ***REMOVED***
            ***REMOVED***
        elif not inline.model:
            return [
                checks.Error(
                    "'%s' must have a 'model' attribute." % inline_label,
                    obj=obj.__class__,
                    id='admin.E105',
                ***REMOVED***
            ***REMOVED***
        elif not issubclass(inline.model, models.Model***REMOVED***:
            return must_be('a Model', option='%s.model' % inline_label, obj=obj, id='admin.E106'***REMOVED***
        else:
            return inline(model, obj.admin_site***REMOVED***.check(***REMOVED***

    def _check_list_display(self, obj***REMOVED***:
        ***REMOVED*** Check that list_display only contains fields or usable attributes.
        ***REMOVED***

        if not isinstance(obj.list_display, (list, tuple***REMOVED******REMOVED***:
            return must_be('a list or tuple', option='list_display', obj=obj, id='admin.E107'***REMOVED***
        else:
            return list(chain(*[
                self._check_list_display_item(obj, obj.model, item, "list_display[%d***REMOVED***" % index***REMOVED***
                for index, item in enumerate(obj.list_display***REMOVED***
            ***REMOVED******REMOVED******REMOVED***

    def _check_list_display_item(self, obj, model, item, label***REMOVED***:
        if callable(item***REMOVED***:
            return [***REMOVED***
        elif hasattr(obj, item***REMOVED***:
            return [***REMOVED***
        elif hasattr(model, item***REMOVED***:
            # getattr(model, item***REMOVED*** could be an X_RelatedObjectsDescriptor
            ***REMOVED***
                field = model._meta.get_field(item***REMOVED***
            except FieldDoesNotExist:
                ***REMOVED***
                    field = getattr(model, item***REMOVED***
                except AttributeError:
                    field = None

            if field is None:
                return [
                    checks.Error(
                        "The value of '%s' refers to '%s', which is not a "
                        "callable, an attribute of '%s', or an attribute or method on '%s.%s'." % (
                            label, item, obj.__class__.__name__, model._meta.app_label, model._meta.object_name
                        ***REMOVED***,
                        obj=obj.__class__,
                        id='admin.E108',
                    ***REMOVED***
                ***REMOVED***
            elif isinstance(field, models.ManyToManyField***REMOVED***:
                return [
                    checks.Error(
                        "The value of '%s' must not be a ManyToManyField." % label,
                        obj=obj.__class__,
                        id='admin.E109',
                    ***REMOVED***
                ***REMOVED***
            else:
                return [***REMOVED***
        else:
            ***REMOVED***
                model._meta.get_field(item***REMOVED***
            except FieldDoesNotExist:
                return [
                    # This is a deliberate repeat of E108; there's more than one path
                    # required to test this condition.
                    checks.Error(
                        "The value of '%s' refers to '%s', which is not a callable, "
                        "an attribute of '%s', or an attribute or method on '%s.%s'." % (
                            label, item, obj.__class__.__name__, model._meta.app_label, model._meta.object_name
                        ***REMOVED***,
                        obj=obj.__class__,
                        id='admin.E108',
                    ***REMOVED***
                ***REMOVED***
            else:
                return [***REMOVED***

    def _check_list_display_links(self, obj***REMOVED***:
        ***REMOVED*** Check that list_display_links is a unique subset of list_display.
        ***REMOVED***

        if obj.list_display_links is None:
            return [***REMOVED***
        elif not isinstance(obj.list_display_links, (list, tuple***REMOVED******REMOVED***:
            return must_be('a list, a tuple, or None', option='list_display_links', obj=obj, id='admin.E110'***REMOVED***
        else:
            return list(chain(*[
                self._check_list_display_links_item(obj, field_name, "list_display_links[%d***REMOVED***" % index***REMOVED***
                for index, field_name in enumerate(obj.list_display_links***REMOVED***
            ***REMOVED******REMOVED******REMOVED***

    def _check_list_display_links_item(self, obj, field_name, label***REMOVED***:
        if field_name not in obj.list_display:
            return [
                checks.Error(
                    "The value of '%s' refers to '%s', which is not defined in 'list_display'." % (
                        label, field_name
                    ***REMOVED***,
                    obj=obj.__class__,
                    id='admin.E111',
                ***REMOVED***
            ***REMOVED***
        else:
            return [***REMOVED***

    def _check_list_filter(self, obj***REMOVED***:
        if not isinstance(obj.list_filter, (list, tuple***REMOVED******REMOVED***:
            return must_be('a list or tuple', option='list_filter', obj=obj, id='admin.E112'***REMOVED***
        else:
            return list(chain(*[
                self._check_list_filter_item(obj, obj.model, item, "list_filter[%d***REMOVED***" % index***REMOVED***
                for index, item in enumerate(obj.list_filter***REMOVED***
            ***REMOVED******REMOVED******REMOVED***

    def _check_list_filter_item(self, obj, model, item, label***REMOVED***:
        ***REMOVED***
        Check one item of `list_filter`, i.e. check if it is one of three options:
        1. 'field' -- a basic field filter, possibly w/ relationships (e.g.
           'field__rel'***REMOVED***
        2. ('field', SomeFieldListFilter***REMOVED*** - a field-based list filter class
        3. SomeListFilter - a non-field list filter class
        ***REMOVED***

        from django.contrib.admin import ListFilter, FieldListFilter

        if callable(item***REMOVED*** and not isinstance(item, models.Field***REMOVED***:
            # If item is option 3, it should be a ListFilter...
            if not issubclass(item, ListFilter***REMOVED***:
                return must_inherit_from(parent='ListFilter', option=label,
                                         obj=obj, id='admin.E113'***REMOVED***
            # ...  but not a FieldListFilter.
            elif issubclass(item, FieldListFilter***REMOVED***:
                return [
                    checks.Error(
                        "The value of '%s' must not inherit from 'FieldListFilter'." % label,
                        obj=obj.__class__,
                        id='admin.E114',
                    ***REMOVED***
                ***REMOVED***
            else:
                return [***REMOVED***
        elif isinstance(item, (tuple, list***REMOVED******REMOVED***:
            # item is option #2
            field, list_filter_class = item
            if not issubclass(list_filter_class, FieldListFilter***REMOVED***:
                return must_inherit_from(parent='FieldListFilter', option='%s[1***REMOVED***' % label, obj=obj, id='admin.E115'***REMOVED***
            else:
                return [***REMOVED***
        else:
            # item is option #1
            field = item

            # Validate the field string
            ***REMOVED***
                get_fields_from_path(model, field***REMOVED***
            except (NotRelationField, FieldDoesNotExist***REMOVED***:
                return [
                    checks.Error(
                        "The value of '%s' refers to '%s', which does not refer to a Field." % (label, field***REMOVED***,
                        obj=obj.__class__,
                        id='admin.E116',
                    ***REMOVED***
                ***REMOVED***
            else:
                return [***REMOVED***

    def _check_list_select_related(self, obj***REMOVED***:
        ***REMOVED*** Check that list_select_related is a boolean, a list or a tuple. ***REMOVED***

        if not isinstance(obj.list_select_related, (bool, list, tuple***REMOVED******REMOVED***:
            return must_be('a boolean, tuple or list', option='list_select_related', obj=obj, id='admin.E117'***REMOVED***
        else:
            return [***REMOVED***

    def _check_list_per_page(self, obj***REMOVED***:
        ***REMOVED*** Check that list_per_page is an integer. ***REMOVED***

        if not isinstance(obj.list_per_page, int***REMOVED***:
            return must_be('an integer', option='list_per_page', obj=obj, id='admin.E118'***REMOVED***
        else:
            return [***REMOVED***

    def _check_list_max_show_all(self, obj***REMOVED***:
        ***REMOVED*** Check that list_max_show_all is an integer. ***REMOVED***

        if not isinstance(obj.list_max_show_all, int***REMOVED***:
            return must_be('an integer', option='list_max_show_all', obj=obj, id='admin.E119'***REMOVED***
        else:
            return [***REMOVED***

    def _check_list_editable(self, obj***REMOVED***:
        ***REMOVED*** Check that list_editable is a sequence of editable fields from
        list_display without first element. ***REMOVED***

        if not isinstance(obj.list_editable, (list, tuple***REMOVED******REMOVED***:
            return must_be('a list or tuple', option='list_editable', obj=obj, id='admin.E120'***REMOVED***
        else:
            return list(chain(*[
                self._check_list_editable_item(obj, obj.model, item, "list_editable[%d***REMOVED***" % index***REMOVED***
                for index, item in enumerate(obj.list_editable***REMOVED***
            ***REMOVED******REMOVED******REMOVED***

    def _check_list_editable_item(self, obj, model, field_name, label***REMOVED***:
        ***REMOVED***
            field = model._meta.get_field(field_name***REMOVED***
        except FieldDoesNotExist:
            return refer_to_missing_field(field=field_name, option=label, model=model, obj=obj, id='admin.E121'***REMOVED***
        else:
            if field_name not in obj.list_display:
                return [
                    checks.Error(
                        "The value of '%s' refers to '%s', which is not "
                        "contained in 'list_display'." % (label, field_name***REMOVED***,
                        obj=obj.__class__,
                        id='admin.E122',
                    ***REMOVED***
                ***REMOVED***
            elif obj.list_display_links and field_name in obj.list_display_links:
                return [
                    checks.Error(
                        "The value of '%s' cannot be in both 'list_editable' and 'list_display_links'." % field_name,
                        obj=obj.__class__,
                        id='admin.E123',
                    ***REMOVED***
                ***REMOVED***
            # If list_display[0***REMOVED*** is in list_editable, check that
            # list_display_links is set. See #22792 and #26229 for use cases.
            elif (obj.list_display[0***REMOVED*** == field_name and not obj.list_display_links and
                    obj.list_display_links is not None***REMOVED***:
                return [
                    checks.Error(
                        "The value of '%s' refers to the first field in 'list_display' ('%s'***REMOVED***, "
                        "which cannot be used unless 'list_display_links' is set." % (
                            label, obj.list_display[0***REMOVED***
                        ***REMOVED***,
                        obj=obj.__class__,
                        id='admin.E124',
                    ***REMOVED***
                ***REMOVED***
            elif not field.editable:
                return [
                    checks.Error(
                        "The value of '%s' refers to '%s', which is not editable through the admin." % (
                            label, field_name
                        ***REMOVED***,
                        obj=obj.__class__,
                        id='admin.E125',
                    ***REMOVED***
                ***REMOVED***
            else:
                return [***REMOVED***

    def _check_search_fields(self, obj***REMOVED***:
        ***REMOVED*** Check search_fields is a sequence. ***REMOVED***

        if not isinstance(obj.search_fields, (list, tuple***REMOVED******REMOVED***:
            return must_be('a list or tuple', option='search_fields', obj=obj, id='admin.E126'***REMOVED***
        else:
            return [***REMOVED***

    def _check_date_hierarchy(self, obj***REMOVED***:
        ***REMOVED*** Check that date_hierarchy refers to DateField or DateTimeField. ***REMOVED***

        if obj.date_hierarchy is None:
            return [***REMOVED***
        else:
            ***REMOVED***
                field = obj.model._meta.get_field(obj.date_hierarchy***REMOVED***
            except FieldDoesNotExist:
                return refer_to_missing_field(
                    option='date_hierarchy', field=obj.date_hierarchy,
                    model=obj.model, obj=obj, id='admin.E127',
                ***REMOVED***
            else:
                if not isinstance(field, (models.DateField, models.DateTimeField***REMOVED******REMOVED***:
                    return must_be('a DateField or DateTimeField', option='date_hierarchy', obj=obj, id='admin.E128'***REMOVED***
                else:
                    return [***REMOVED***


class InlineModelAdminChecks(BaseModelAdminChecks***REMOVED***:

    def check(self, inline_obj, **kwargs***REMOVED***:
        errors = super(InlineModelAdminChecks, self***REMOVED***.check(inline_obj***REMOVED***
        parent_model = inline_obj.parent_model
        errors.extend(self._check_relation(inline_obj, parent_model***REMOVED******REMOVED***
        errors.extend(self._check_exclude_of_parent_model(inline_obj, parent_model***REMOVED******REMOVED***
        errors.extend(self._check_extra(inline_obj***REMOVED******REMOVED***
        errors.extend(self._check_max_num(inline_obj***REMOVED******REMOVED***
        errors.extend(self._check_min_num(inline_obj***REMOVED******REMOVED***
        errors.extend(self._check_formset(inline_obj***REMOVED******REMOVED***
        return errors

    def _check_exclude_of_parent_model(self, obj, parent_model***REMOVED***:
        # Do not perform more specific checks if the base checks result in an
        # error.
        errors = super(InlineModelAdminChecks, self***REMOVED***._check_exclude(obj***REMOVED***
        if errors:
            return [***REMOVED***

        # Skip if `fk_name` is invalid.
        if self._check_relation(obj, parent_model***REMOVED***:
            return [***REMOVED***

        if obj.exclude is None:
            return [***REMOVED***

        fk = _get_foreign_key(parent_model, obj.model, fk_name=obj.fk_name***REMOVED***
        if fk.name in obj.exclude:
            return [
                checks.Error(
                    "Cannot exclude the field '%s', because it is the foreign key "
                    "to the parent model '%s.%s'." % (
                        fk.name, parent_model._meta.app_label, parent_model._meta.object_name
                    ***REMOVED***,
                    obj=obj.__class__,
                    id='admin.E201',
                ***REMOVED***
            ***REMOVED***
        else:
            return [***REMOVED***

    def _check_relation(self, obj, parent_model***REMOVED***:
        ***REMOVED***
            _get_foreign_key(parent_model, obj.model, fk_name=obj.fk_name***REMOVED***
        except ValueError as e:
            return [checks.Error(e.args[0***REMOVED***, obj=obj.__class__, id='admin.E202'***REMOVED******REMOVED***
        else:
            return [***REMOVED***

    def _check_extra(self, obj***REMOVED***:
        ***REMOVED*** Check that extra is an integer. ***REMOVED***

        if not isinstance(obj.extra, int***REMOVED***:
            return must_be('an integer', option='extra', obj=obj, id='admin.E203'***REMOVED***
        else:
            return [***REMOVED***

    def _check_max_num(self, obj***REMOVED***:
        ***REMOVED*** Check that max_num is an integer. ***REMOVED***

        if obj.max_num is None:
            return [***REMOVED***
        elif not isinstance(obj.max_num, int***REMOVED***:
            return must_be('an integer', option='max_num', obj=obj, id='admin.E204'***REMOVED***
        else:
            return [***REMOVED***

    def _check_min_num(self, obj***REMOVED***:
        ***REMOVED*** Check that min_num is an integer. ***REMOVED***

        if obj.min_num is None:
            return [***REMOVED***
        elif not isinstance(obj.min_num, int***REMOVED***:
            return must_be('an integer', option='min_num', obj=obj, id='admin.E205'***REMOVED***
        else:
            return [***REMOVED***

    def _check_formset(self, obj***REMOVED***:
        ***REMOVED*** Check formset is a subclass of BaseModelFormSet. ***REMOVED***

        if not issubclass(obj.formset, BaseModelFormSet***REMOVED***:
            return must_inherit_from(parent='BaseModelFormSet', option='formset', obj=obj, id='admin.E206'***REMOVED***
        else:
            return [***REMOVED***


def must_be(type, option, obj, id***REMOVED***:
    return [
        checks.Error(
            "The value of '%s' must be %s." % (option, type***REMOVED***,
            obj=obj.__class__,
            id=id,
        ***REMOVED***,
    ***REMOVED***


def must_inherit_from(parent, option, obj, id***REMOVED***:
    return [
        checks.Error(
            "The value of '%s' must inherit from '%s'." % (option, parent***REMOVED***,
            obj=obj.__class__,
            id=id,
        ***REMOVED***,
    ***REMOVED***


def refer_to_missing_field(field, option, model, obj, id***REMOVED***:
    return [
        checks.Error(
            "The value of '%s' refers to '%s', which is not an attribute of '%s.%s'." % (
                option, field, model._meta.app_label, model._meta.object_name
            ***REMOVED***,
            obj=obj.__class__,
            id=id,
        ***REMOVED***,
    ***REMOVED***
