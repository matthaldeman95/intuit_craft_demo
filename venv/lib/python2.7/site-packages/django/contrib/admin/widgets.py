***REMOVED***
Form Widget classes specific to the Django admin site.
***REMOVED***
from __future__ import unicode_literals

import copy

from django import forms
from django.db.models.deletion import CASCADE
from django.forms.utils import flatatt
from django.forms.widgets import RadioFieldRenderer
from django.template.loader import render_to_string
from django.urls import reverse
from django.urls.exceptions import NoReverseMatch
from django.utils import six
from django.utils.encoding import force_text
from django.utils.html import format_html, format_html_join, smart_urlquote
from django.utils.safestring import mark_safe
from django.utils.text import Truncator
from django.utils.translation import ugettext as _


class FilteredSelectMultiple(forms.SelectMultiple***REMOVED***:
    ***REMOVED***
    A SelectMultiple with a JavaScript filter interface.

    Note that the resulting JavaScript assumes that the jsi18n
    catalog has been loaded in the page
    ***REMOVED***
    @property
    def media(self***REMOVED***:
        js = ["core.js", "SelectBox.js", "SelectFilter2.js"***REMOVED***
        return forms.Media(js=["admin/js/%s" % path for path in js***REMOVED******REMOVED***

    def __init__(self, verbose_name, is_stacked, attrs=None, choices=(***REMOVED******REMOVED***:
        self.verbose_name = verbose_name
        self.is_stacked = is_stacked
        super(FilteredSelectMultiple, self***REMOVED***.__init__(attrs, choices***REMOVED***

    def render(self, name, value, attrs=None***REMOVED***:
        if attrs is None:
            attrs = {***REMOVED***
        attrs['class'***REMOVED*** = 'selectfilter'
        if self.is_stacked:
            attrs['class'***REMOVED*** += 'stacked'

        attrs['data-field-name'***REMOVED*** = self.verbose_name
        attrs['data-is-stacked'***REMOVED*** = int(self.is_stacked***REMOVED***
        output = super(FilteredSelectMultiple, self***REMOVED***.render(name, value, attrs***REMOVED***
        return mark_safe(output***REMOVED***


class AdminDateWidget(forms.DateInput***REMOVED***:
    @property
    def media(self***REMOVED***:
        js = ["calendar.js", "admin/DateTimeShortcuts.js"***REMOVED***
        return forms.Media(js=["admin/js/%s" % path for path in js***REMOVED******REMOVED***

    def __init__(self, attrs=None, format=None***REMOVED***:
        final_attrs = {'class': 'vDateField', 'size': '10'***REMOVED***
        if attrs is not None:
            final_attrs.update(attrs***REMOVED***
        super(AdminDateWidget, self***REMOVED***.__init__(attrs=final_attrs, format=format***REMOVED***


class AdminTimeWidget(forms.TimeInput***REMOVED***:
    @property
    def media(self***REMOVED***:
        js = ["calendar.js", "admin/DateTimeShortcuts.js"***REMOVED***
        return forms.Media(js=["admin/js/%s" % path for path in js***REMOVED******REMOVED***

    def __init__(self, attrs=None, format=None***REMOVED***:
        final_attrs = {'class': 'vTimeField', 'size': '8'***REMOVED***
        if attrs is not None:
            final_attrs.update(attrs***REMOVED***
        super(AdminTimeWidget, self***REMOVED***.__init__(attrs=final_attrs, format=format***REMOVED***


class AdminSplitDateTime(forms.SplitDateTimeWidget***REMOVED***:
    ***REMOVED***
    A SplitDateTime Widget that has some admin-specific styling.
    ***REMOVED***
    def __init__(self, attrs=None***REMOVED***:
        widgets = [AdminDateWidget, AdminTimeWidget***REMOVED***
        # Note that we're calling MultiWidget, not SplitDateTimeWidget, because
        # we want to define widgets.
        forms.MultiWidget.__init__(self, widgets, attrs***REMOVED***

    def format_output(self, rendered_widgets***REMOVED***:
        return format_html('<p class="datetime">{***REMOVED*** {***REMOVED***<br />{***REMOVED*** {***REMOVED***</p>',
                           _('Date:'***REMOVED***, rendered_widgets[0***REMOVED***,
                           _('Time:'***REMOVED***, rendered_widgets[1***REMOVED******REMOVED***


class AdminRadioFieldRenderer(RadioFieldRenderer***REMOVED***:
    def render(self***REMOVED***:
        ***REMOVED***Outputs a <ul> for this set of radio fields.***REMOVED***
        return format_html('<ul{***REMOVED***>\n{***REMOVED***\n</ul>',
                           flatatt(self.attrs***REMOVED***,
                           format_html_join('\n', '<li>{***REMOVED***</li>',
                                            ((force_text(w***REMOVED***,***REMOVED*** for w in self***REMOVED******REMOVED******REMOVED***


class AdminRadioSelect(forms.RadioSelect***REMOVED***:
    renderer = AdminRadioFieldRenderer


class AdminFileWidget(forms.ClearableFileInput***REMOVED***:
    template_with_initial = (
        '<p class="file-upload">%s</p>' % forms.ClearableFileInput.template_with_initial
    ***REMOVED***
    template_with_clear = (
        '<span class="clearable-file-input">%s</span>' % forms.ClearableFileInput.template_with_clear
    ***REMOVED***


def url_params_from_lookup_dict(lookups***REMOVED***:
    ***REMOVED***
    Converts the type of lookups specified in a ForeignKey limit_choices_to
    attribute to a dictionary of query parameters
    ***REMOVED***
    params = {***REMOVED***
    if lookups and hasattr(lookups, 'items'***REMOVED***:
        items = [***REMOVED***
        for k, v in lookups.items(***REMOVED***:
            if callable(v***REMOVED***:
                v = v(***REMOVED***
            if isinstance(v, (tuple, list***REMOVED******REMOVED***:
                v = ','.join(str(x***REMOVED*** for x in v***REMOVED***
            elif isinstance(v, bool***REMOVED***:
                v = ('0', '1'***REMOVED***[v***REMOVED***
            else:
                v = six.text_type(v***REMOVED***
            items.append((k, v***REMOVED******REMOVED***
        params.update(dict(items***REMOVED******REMOVED***
    return params


class ForeignKeyRawIdWidget(forms.TextInput***REMOVED***:
    ***REMOVED***
    A Widget for displaying ForeignKeys in the "raw_id" interface rather than
    in a <select> box.
    ***REMOVED***
    def __init__(self, rel, admin_site, attrs=None, using=None***REMOVED***:
        self.rel = rel
        self.admin_site = admin_site
        self.db = using
        super(ForeignKeyRawIdWidget, self***REMOVED***.__init__(attrs***REMOVED***

    def render(self, name, value, attrs=None***REMOVED***:
        rel_to = self.rel.model
        if attrs is None:
            attrs = {***REMOVED***
        extra = [***REMOVED***
        if rel_to in self.admin_site._regis***REMOVED***
            # The related object is registered with the same AdminSite
            related_url = reverse(
                'admin:%s_%s_changelist' % (
                    rel_to._meta.app_label,
                    rel_to._meta.model_name,
                ***REMOVED***,
                current_app=self.admin_site.name,
            ***REMOVED***

            params = self.url_parameters(***REMOVED***
            if params:
                url = '?' + '&amp;'.join('%s=%s' % (k, v***REMOVED*** for k, v in params.items(***REMOVED******REMOVED***
            else:
                url = ''
            if "class" not in attrs:
                attrs['class'***REMOVED*** = 'vForeignKeyRawIdAdminField'  # The JavaScript code looks for this hook.
            # TODO: "lookup_id_" is hard-coded here. This should instead use
            # the correct API to determine the ID dynamically.
            extra.append(
                '<a href="%s%s" class="related-lookup" id="lookup_id_%s" title="%s"></a>'
                % (related_url, url, name, _('Lookup'***REMOVED******REMOVED***
            ***REMOVED***
        output = [super(ForeignKeyRawIdWidget, self***REMOVED***.render(name, value, attrs***REMOVED******REMOVED*** + extra
        if value:
            output.append(self.label_for_value(value***REMOVED******REMOVED***
        return mark_safe(''.join(output***REMOVED******REMOVED***

    def base_url_parameters(self***REMOVED***:
        limit_choices_to = self.rel.limit_choices_to
        if callable(limit_choices_to***REMOVED***:
            limit_choices_to = limit_choices_to(***REMOVED***
        return url_params_from_lookup_dict(limit_choices_to***REMOVED***

    def url_parameters(self***REMOVED***:
        from django.contrib.admin.views.main import TO_FIELD_VAR
        params = self.base_url_parameters(***REMOVED***
        params.update({TO_FIELD_VAR: self.rel.get_related_field(***REMOVED***.name***REMOVED******REMOVED***
        return params

    def label_for_value(self, value***REMOVED***:
        key = self.rel.get_related_field(***REMOVED***.name
        ***REMOVED***
            obj = self.rel.model._default_manager.using(self.db***REMOVED***.get(**{key: value***REMOVED******REMOVED***
        except (ValueError, self.rel.model.DoesNotExist***REMOVED***:
            return ''

        label = '&nbsp;<strong>{***REMOVED***</strong>'
        text = Truncator(obj***REMOVED***.words(14, truncate='...'***REMOVED***
        ***REMOVED***
            change_url = reverse(
                '%s:%s_%s_change' % (
                    self.admin_site.name,
                    obj._meta.app_label,
                    obj._meta.object_name.lower(***REMOVED***,
                ***REMOVED***,
                args=(obj.pk,***REMOVED***
            ***REMOVED***
        except NoReverseMatch:
            pass  # Admin not registered for target model.
        else:
            text = format_html('<a href="{***REMOVED***">{***REMOVED***</a>', change_url, text***REMOVED***

        return format_html(label, text***REMOVED***


class ManyToManyRawIdWidget(ForeignKeyRawIdWidget***REMOVED***:
    ***REMOVED***
    A Widget for displaying ManyToMany ids in the "raw_id" interface rather than
    in a <select multiple> box.
    ***REMOVED***
    def render(self, name, value, attrs=None***REMOVED***:
        if attrs is None:
            attrs = {***REMOVED***
        if self.rel.model in self.admin_site._regis***REMOVED***
            # The related object is registered with the same AdminSite
            attrs['class'***REMOVED*** = 'vManyToManyRawIdAdminField'
        if value:
            value = ','.join(force_text(v***REMOVED*** for v in value***REMOVED***
        else:
            value = ''
        return super(ManyToManyRawIdWidget, self***REMOVED***.render(name, value, attrs***REMOVED***

    def url_parameters(self***REMOVED***:
        return self.base_url_parameters(***REMOVED***

    def label_for_value(self, value***REMOVED***:
        return ''

    def value_from_datadict(self, data, files, name***REMOVED***:
        value = data.get(name***REMOVED***
        if value:
            return value.split(','***REMOVED***


class RelatedFieldWidgetWrapper(forms.Widget***REMOVED***:
    ***REMOVED***
    This class is a wrapper to a given widget to add the add icon for the
    admin interface.
    ***REMOVED***
    template = 'admin/related_widget_wrapper.html'

    def __init__(self, widget, rel, admin_site, can_add_related=None,
                 can_change_related=False, can_delete_related=False***REMOVED***:
        self.needs_multipart_form = widget.needs_multipart_form
        self.attrs = widget.attrs
        self.choices = widget.choices
        self.widget = widget
        self.rel = rel
        # Backwards compatible check for whether a user can add related
        # objects.
        if can_add_related is None:
            can_add_related = rel.model in admin_site._registry
        self.can_add_related = can_add_related
        # XXX: The UX does not support multiple selected values.
        multiple = getattr(widget, 'allow_multiple_selected', False***REMOVED***
        self.can_change_related = not multiple and can_change_related
        # XXX: The deletion UX can be confusing when dealing with cascading deletion.
        cascade = getattr(rel, 'on_delete', None***REMOVED*** is CASCADE
        self.can_delete_related = not multiple and not cascade and can_delete_related
        # so we can check if the related object is registered with this AdminSite
        self.admin_site = admin_site

    def __deepcopy__(self, memo***REMOVED***:
        obj = copy.copy(self***REMOVED***
        obj.widget = copy.deepcopy(self.widget, memo***REMOVED***
        obj.attrs = self.widget.attrs
        memo[id(self***REMOVED******REMOVED*** = obj
        return obj

    @property
    def is_hidden(self***REMOVED***:
        return self.widget.is_hidden

    @property
    def media(self***REMOVED***:
        return self.widget.media

    def get_related_url(self, info, action, *args***REMOVED***:
        return reverse("admin:%s_%s_%s" % (info + (action,***REMOVED******REMOVED***,
                       current_app=self.admin_site.name, args=args***REMOVED***

    def render(self, name, value, *args, **kwargs***REMOVED***:
        from django.contrib.admin.views.main import IS_POPUP_VAR, TO_FIELD_VAR
        rel_opts = self.rel.model._meta
        info = (rel_opts.app_label, rel_opts.model_name***REMOVED***
        self.widget.choices = self.choices
        url_params = '&'.join("%s=%s" % param for param in [
            (TO_FIELD_VAR, self.rel.get_related_field(***REMOVED***.name***REMOVED***,
            (IS_POPUP_VAR, 1***REMOVED***,
        ***REMOVED******REMOVED***
        context = {
            'widget': self.widget.render(name, value, *args, **kwargs***REMOVED***,
            'name': name,
            'url_params': url_params,
            'model': rel_opts.verbose_name,
    ***REMOVED***
        if self.can_change_related:
            change_related_template_url = self.get_related_url(info, 'change', '__fk__'***REMOVED***
            context.update(
                can_change_related=True,
                change_related_template_url=change_related_template_url,
            ***REMOVED***
        if self.can_add_related:
            add_related_url = self.get_related_url(info, 'add'***REMOVED***
            context.update(
                can_add_related=True,
                add_related_url=add_related_url,
            ***REMOVED***
        if self.can_delete_related:
            delete_related_template_url = self.get_related_url(info, 'delete', '__fk__'***REMOVED***
            context.update(
                can_delete_related=True,
                delete_related_template_url=delete_related_template_url,
            ***REMOVED***
        return mark_safe(render_to_string(self.template, context***REMOVED******REMOVED***

    def build_attrs(self, extra_attrs=None, **kwargs***REMOVED***:
        "Helper function for building an attribute dictionary."
        self.attrs = self.widget.build_attrs(extra_attrs=None, **kwargs***REMOVED***
        return self.attrs

    def value_from_datadict(self, data, files, name***REMOVED***:
        return self.widget.value_from_datadict(data, files, name***REMOVED***

    def id_for_label(self, id_***REMOVED***:
        return self.widget.id_for_label(id_***REMOVED***


class AdminTextareaWidget(forms.Textarea***REMOVED***:
    def __init__(self, attrs=None***REMOVED***:
        final_attrs = {'class': 'vLargeTextField'***REMOVED***
        if attrs is not None:
            final_attrs.update(attrs***REMOVED***
        super(AdminTextareaWidget, self***REMOVED***.__init__(attrs=final_attrs***REMOVED***


class AdminTextInputWidget(forms.TextInput***REMOVED***:
    def __init__(self, attrs=None***REMOVED***:
        final_attrs = {'class': 'vTextField'***REMOVED***
        if attrs is not None:
            final_attrs.update(attrs***REMOVED***
        super(AdminTextInputWidget, self***REMOVED***.__init__(attrs=final_attrs***REMOVED***


class AdminEmailInputWidget(forms.EmailInput***REMOVED***:
    def __init__(self, attrs=None***REMOVED***:
        final_attrs = {'class': 'vTextField'***REMOVED***
        if attrs is not None:
            final_attrs.update(attrs***REMOVED***
        super(AdminEmailInputWidget, self***REMOVED***.__init__(attrs=final_attrs***REMOVED***


class AdminURLFieldWidget(forms.URLInput***REMOVED***:
    def __init__(self, attrs=None***REMOVED***:
        final_attrs = {'class': 'vURLField'***REMOVED***
        if attrs is not None:
            final_attrs.update(attrs***REMOVED***
        super(AdminURLFieldWidget, self***REMOVED***.__init__(attrs=final_attrs***REMOVED***

    def render(self, name, value, attrs=None***REMOVED***:
        html = super(AdminURLFieldWidget, self***REMOVED***.render(name, value, attrs***REMOVED***
        if value:
            value = force_text(self.format_value(value***REMOVED******REMOVED***
            final_attrs = {'href': smart_urlquote(value***REMOVED******REMOVED***
            html = format_html(
                '<p class="url">{***REMOVED*** <a{***REMOVED***>{***REMOVED***</a><br />{***REMOVED*** {***REMOVED***</p>',
                _('Currently:'***REMOVED***, flatatt(final_attrs***REMOVED***, value,
                _('Change:'***REMOVED***, html
            ***REMOVED***
        return html


class AdminIntegerFieldWidget(forms.TextInput***REMOVED***:
    class_name = 'vIntegerField'

    def __init__(self, attrs=None***REMOVED***:
        final_attrs = {'class': self.class_name***REMOVED***
        if attrs is not None:
            final_attrs.update(attrs***REMOVED***
        super(AdminIntegerFieldWidget, self***REMOVED***.__init__(attrs=final_attrs***REMOVED***


class AdminBigIntegerFieldWidget(AdminIntegerFieldWidget***REMOVED***:
    class_name = 'vBigIntegerField'
