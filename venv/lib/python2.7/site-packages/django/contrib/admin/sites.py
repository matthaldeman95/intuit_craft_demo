from functools import update_wrapper

from django.apps import apps
from django.conf import settings
from django.contrib.admin import ModelAdmin, actions
from django.contrib.auth import REDIRECT_FIELD_NAME
from django.core.exceptions import ImproperlyConfigured, PermissionDenied
from django.db.models.base import ModelBase
from django.http import Http404, HttpResponseRedirect
from django.template.response import TemplateResponse
from django.urls import NoReverseMatch, reverse
from django.utils import six
from django.utils.text import capfirst
from django.utils.translation import ugettext as _, ugettext_lazy
from django.views.decorators.cache import never_cache
from django.views.decorators.csrf import csrf_protect
from django.views.i18n import JavaScriptCatalog

system_check_errors = [***REMOVED***


class AlreadyRegistered(Exception***REMOVED***:
    pass


class NotRegistered(Exception***REMOVED***:
    pass


class AdminSite(object***REMOVED***:
    ***REMOVED***
    An AdminSite object encapsulates an instance of the Django admin application, ready
    to be hooked in to your URLconf. Models are registered with the AdminSite using the
    register(***REMOVED*** method, and the get_urls(***REMOVED*** method can then be used to access Django view
    functions that present a full admin interface for the collection of registered
    models.
    ***REMOVED***

    # Text to put at the end of each page's <title>.
    site_title = ugettext_lazy('Django site admin'***REMOVED***

    # Text to put in each page's <h1>.
    site_header = ugettext_lazy('Django administration'***REMOVED***

    # Text to put at the top of the admin index page.
    index_title = ugettext_lazy('Site administration'***REMOVED***

    # URL for the "View site" link at the top of each admin page.
    site_url = '/'

    _empty_value_display = '-'

    login_form = None
    index_template = None
    app_index_template = None
    login_template = None
    logout_template = None
    password_change_template = None
    password_change_done_template = None

    def __init__(self, name='admin'***REMOVED***:
        self._registry = {***REMOVED***  # model_class class -> admin_class instance
        self.name = name
        self._actions = {'delete_selected': actions.delete_selected***REMOVED***
        self._global_actions = self._actions.copy(***REMOVED***

    def register(self, model_or_iterable, admin_class=None, **options***REMOVED***:
        ***REMOVED***
        Registers the given model(s***REMOVED*** with the given admin class.

        The model(s***REMOVED*** should be Model classes, not instances.

        If an admin class isn't given, it will use ModelAdmin (the default
        admin options***REMOVED***. If keyword arguments are given -- e.g., list_display --
        they'll be applied as options to the admin class.

        If a model is already registered, this will raise AlreadyRegistered.

        If a model is abstract, this will raise ImproperlyConfigured.
        ***REMOVED***
        if not admin_class:
            admin_class = ModelAdmin

        if isinstance(model_or_iterable, ModelBase***REMOVED***:
            model_or_iterable = [model_or_iterable***REMOVED***
        for model in model_or_iterable:
            if model._meta.abstract:
                raise ImproperlyConfigured(
                    'The model %s is abstract, so it cannot be registered with admin.' % model.__name__
                ***REMOVED***

            if model in self._regis***REMOVED***
                raise AlreadyRegistered('The model %s is already registered' % model.__name__***REMOVED***

            # Ignore the registration if the model has been
            # swapped out.
            if not model._meta.swapped:
                # If we got **options then dynamically construct a subclass of
                # admin_class with those **options.
                if options:
                    # For reasons I don't quite understand, without a __module__
                    # the created class appears to "live" in the wrong place,
                    # which causes issues later on.
                    options['__module__'***REMOVED*** = __name__
                    admin_class = type("%sAdmin" % model.__name__, (admin_class,***REMOVED***, options***REMOVED***

                # Instantiate the admin class to save in the registry
                admin_obj = admin_class(model, self***REMOVED***
                if admin_class is not ModelAdmin and settings.DEBUG:
                    system_check_errors.extend(admin_obj.check(***REMOVED******REMOVED***

                self._registry[model***REMOVED*** = admin_obj

    def unregister(self, model_or_iterable***REMOVED***:
        ***REMOVED***
        Unregisters the given model(s***REMOVED***.

        If a model isn't already registered, this will raise NotRegistered.
        ***REMOVED***
        if isinstance(model_or_iterable, ModelBase***REMOVED***:
            model_or_iterable = [model_or_iterable***REMOVED***
        for model in model_or_iterable:
            if model not in self._regis***REMOVED***
                raise NotRegistered('The model %s is not registered' % model.__name__***REMOVED***
            del self._registry[model***REMOVED***

    def is_registered(self, model***REMOVED***:
        ***REMOVED***
        Check if a model class is registered with this `AdminSite`.
        ***REMOVED***
        return model in self._registry

    def add_action(self, action, name=None***REMOVED***:
        ***REMOVED***
        Register an action to be available globally.
        ***REMOVED***
        name = name or action.__name__
        self._actions[name***REMOVED*** = action
        self._global_actions[name***REMOVED*** = action

    def disable_action(self, name***REMOVED***:
        ***REMOVED***
        Disable a globally-registered action. Raises KeyError for invalid names.
        ***REMOVED***
        del self._actions[name***REMOVED***

    def get_action(self, name***REMOVED***:
        ***REMOVED***
        Explicitly get a registered global action whether it's enabled or
        not. Raises KeyError for invalid names.
        ***REMOVED***
        return self._global_actions[name***REMOVED***

    @property
    def actions(self***REMOVED***:
        ***REMOVED***
        Get all the enabled actions as an iterable of (name, func***REMOVED***.
        ***REMOVED***
        return six.iteritems(self._actions***REMOVED***

    @property
    def empty_value_display(self***REMOVED***:
        return self._empty_value_display

    @empty_value_display.setter
    def empty_value_display(self, empty_value_display***REMOVED***:
        self._empty_value_display = empty_value_display

    def has_permission(self, request***REMOVED***:
        ***REMOVED***
        Returns True if the given HttpRequest has permission to view
        *at least one* page in the admin site.
        ***REMOVED***
        return request.user.is_active and request.user.is_staff

    def admin_view(self, view, cacheable=False***REMOVED***:
        ***REMOVED***
        Decorator to create an admin view attached to this ``AdminSite``. This
        wraps the view and provides permission checking by calling
        ``self.has_permission``.

        You'll want to use this from within ``AdminSite.get_urls(***REMOVED***``:

            class MyAdminSite(AdminSite***REMOVED***:

                def get_urls(self***REMOVED***:
                    from django.conf.urls import url

                    urls = super(MyAdminSite, self***REMOVED***.get_urls(***REMOVED***
                    urls += [
                        url(r'^my_view/$', self.admin_view(some_view***REMOVED******REMOVED***
                    ***REMOVED***
                    return urls

        By default, admin_views are marked non-cacheable using the
        ``never_cache`` decorator. If the view can be safely cached, set
        cacheable=True.
        ***REMOVED***
        def inner(request, *args, **kwargs***REMOVED***:
            if not self.has_permission(request***REMOVED***:
                if request.path == reverse('admin:logout', current_app=self.name***REMOVED***:
                    index_path = reverse('admin:index', current_app=self.name***REMOVED***
                    return HttpResponseRedirect(index_path***REMOVED***
                # Inner import to prevent django.contrib.admin (app***REMOVED*** from
                # importing django.contrib.auth.models.User (unrelated model***REMOVED***.
                from django.contrib.auth.views import redirect_to_login
                return redirect_to_login(
                    request.get_full_path(***REMOVED***,
                    reverse('admin:login', current_app=self.name***REMOVED***
                ***REMOVED***
            return view(request, *args, **kwargs***REMOVED***
        if not cacheable:
            inner = never_cache(inner***REMOVED***
        # We add csrf_protect here so this function can be used as a utility
        # function for any view, without having to repeat 'csrf_protect'.
        if not getattr(view, 'csrf_exempt', False***REMOVED***:
            inner = csrf_protect(inner***REMOVED***
        return update_wrapper(inner, view***REMOVED***

    def get_urls(self***REMOVED***:
        from django.conf.urls import url, include
        # Since this module gets imported in the application's root package,
        # it cannot import models from other applications at the module level,
        # and django.contrib.contenttypes.views imports ContentType.
        from django.contrib.contenttypes import views as contenttype_views

        def wrap(view, cacheable=False***REMOVED***:
            def wrapper(*args, **kwargs***REMOVED***:
                return self.admin_view(view, cacheable***REMOVED***(*args, **kwargs***REMOVED***
            wrapper.admin_site = self
            return update_wrapper(wrapper, view***REMOVED***

        # Admin-site-wide views.
        urlpatterns = [
            url(r'^$', wrap(self.index***REMOVED***, name='index'***REMOVED***,
            url(r'^login/$', self.login, name='login'***REMOVED***,
            url(r'^logout/$', wrap(self.logout***REMOVED***, name='logout'***REMOVED***,
            url(r'^password_change/$', wrap(self.password_change, cacheable=True***REMOVED***, name='password_change'***REMOVED***,
            url(r'^password_change/done/$', wrap(self.password_change_done, cacheable=True***REMOVED***,
                name='password_change_done'***REMOVED***,
            url(r'^jsi18n/$', wrap(self.i18n_javascript, cacheable=True***REMOVED***, name='jsi18n'***REMOVED***,
            url(r'^r/(?P<content_type_id>\d+***REMOVED***/(?P<object_id>.+***REMOVED***/$', wrap(contenttype_views.shortcut***REMOVED***,
                name='view_on_site'***REMOVED***,
        ***REMOVED***

        # Add in each model's views, and create a list of valid URLS for the
        # app_index
        valid_app_labels = [***REMOVED***
        for model, model_admin in self._registry.items(***REMOVED***:
            urlpatterns += [
                url(r'^%s/%s/' % (model._meta.app_label, model._meta.model_name***REMOVED***, include(model_admin.urls***REMOVED******REMOVED***,
            ***REMOVED***
            if model._meta.app_label not in valid_app_labels:
                valid_app_labels.append(model._meta.app_label***REMOVED***

        # If there were ModelAdmins registered, we should have a list of app
        # labels for which we need to allow access to the app_index view,
        if valid_app_labels:
            regex = r'^(?P<app_label>' + '|'.join(valid_app_labels***REMOVED*** + '***REMOVED***/$'
            urlpatterns += [
                url(regex, wrap(self.app_index***REMOVED***, name='app_list'***REMOVED***,
            ***REMOVED***
        return urlpatterns

    @property
    def urls(self***REMOVED***:
        return self.get_urls(***REMOVED***, 'admin', self.name

    def each_context(self, request***REMOVED***:
        ***REMOVED***
        Returns a dictionary of variables to put in the template context for
        *every* page in the admin site.

        For sites running on a subpath, use the SCRIPT_NAME value if site_url
        hasn't been customized.
        ***REMOVED***
        script_name = request.META['SCRIPT_NAME'***REMOVED***
        site_url = script_name if self.site_url == '/' and script_name else self.site_url
        return {
            'site_title': self.site_title,
            'site_header': self.site_header,
            'site_url': site_url,
            'has_permission': self.has_permission(request***REMOVED***,
            'available_apps': self.get_app_list(request***REMOVED***,
    ***REMOVED***

    def password_change(self, request, extra_context=None***REMOVED***:
        ***REMOVED***
        Handles the "change password" task -- both form display and validation.
        ***REMOVED***
        from django.contrib.admin.forms import AdminPasswordChangeForm
        from django.contrib.auth.views import password_change
        url = reverse('admin:password_change_done', current_app=self.name***REMOVED***
        defaults = {
            'password_change_form': AdminPasswordChangeForm,
            'post_change_redirect': url,
            'extra_context': dict(self.each_context(request***REMOVED***, **(extra_context or {***REMOVED******REMOVED******REMOVED***,
    ***REMOVED***
        if self.password_change_template is not None:
            defaults['template_name'***REMOVED*** = self.password_change_template
        request.current_app = self.name
        return password_change(request, **defaults***REMOVED***

    def password_change_done(self, request, extra_context=None***REMOVED***:
        ***REMOVED***
        Displays the "success" page after a password change.
        ***REMOVED***
        from django.contrib.auth.views import password_change_done
        defaults = {
            'extra_context': dict(self.each_context(request***REMOVED***, **(extra_context or {***REMOVED******REMOVED******REMOVED***,
    ***REMOVED***
        if self.password_change_done_template is not None:
            defaults['template_name'***REMOVED*** = self.password_change_done_template
        request.current_app = self.name
        return password_change_done(request, **defaults***REMOVED***

    def i18n_javascript(self, request***REMOVED***:
        ***REMOVED***
        Displays the i18n JavaScript that the Django admin requires.
        ***REMOVED***
        return JavaScriptCatalog.as_view(packages=['django.contrib.admin'***REMOVED******REMOVED***(request***REMOVED***

    @never_cache
    def logout(self, request, extra_context=None***REMOVED***:
        ***REMOVED***
        Logs out the user for the given HttpRequest.

        This should *not* assume the user is already logged in.
        ***REMOVED***
        from django.contrib.auth.views import logout
        defaults = {
            'extra_context': dict(
                self.each_context(request***REMOVED***,
                # Since the user isn't logged out at this point, the value of
                # has_permission must be overridden.
                has_permission=False,
                **(extra_context or {***REMOVED******REMOVED***
            ***REMOVED***,
    ***REMOVED***
        if self.logout_template is not None:
            defaults['template_name'***REMOVED*** = self.logout_template
        request.current_app = self.name
        return logout(request, **defaults***REMOVED***

    @never_cache
    def login(self, request, extra_context=None***REMOVED***:
        ***REMOVED***
        Displays the login form for the given HttpRequest.
        ***REMOVED***
        if request.method == 'GET' and self.has_permission(request***REMOVED***:
            # Already logged-in, redirect to admin index
            index_path = reverse('admin:index', current_app=self.name***REMOVED***
            return HttpResponseRedirect(index_path***REMOVED***

        from django.contrib.auth.views import login
        # Since this module gets imported in the application's root package,
        # it cannot import models from other applications at the module level,
        # and django.contrib.admin.forms eventually imports User.
        from django.contrib.admin.forms import AdminAuthenticationForm
        context = dict(
            self.each_context(request***REMOVED***,
            title=_('Log in'***REMOVED***,
            app_path=request.get_full_path(***REMOVED***,
            username=request.user.get_username(***REMOVED***,
        ***REMOVED***
        if (REDIRECT_FIELD_NAME not in request.GET and
                REDIRECT_FIELD_NAME not in request.POST***REMOVED***:
            context[REDIRECT_FIELD_NAME***REMOVED*** = reverse('admin:index', current_app=self.name***REMOVED***
        context.update(extra_context or {***REMOVED******REMOVED***

        defaults = {
            'extra_context': context,
            'authentication_form': self.login_form or AdminAuthenticationForm,
            'template_name': self.login_template or 'admin/login.html',
    ***REMOVED***
        request.current_app = self.name
        return login(request, **defaults***REMOVED***

    def _build_app_dict(self, request, label=None***REMOVED***:
        ***REMOVED***
        Builds the app dictionary. Takes an optional label parameters to filter
        models of a specific app.
        ***REMOVED***
        app_dict = {***REMOVED***

        if label:
            models = {
                m: m_a for m, m_a in self._registry.items(***REMOVED***
                if m._meta.app_label == label
        ***REMOVED***
        else:
            models = self._registry

        for model, model_admin in models.items(***REMOVED***:
            app_label = model._meta.app_label

            has_module_perms = model_admin.has_module_permission(request***REMOVED***
            if not has_module_perms:
                if label:
                    raise PermissionDenied
                continue

            perms = model_admin.get_model_perms(request***REMOVED***

            # Check whether user has any perm for this module.
            # If so, add the module to the model_list.
            if True not in perms.values(***REMOVED***:
                continue

            info = (app_label, model._meta.model_name***REMOVED***
            model_dict = {
                'name': capfirst(model._meta.verbose_name_plural***REMOVED***,
                'object_name': model._meta.object_name,
                'perms': perms,
        ***REMOVED***
            if perms.get('change'***REMOVED***:
                ***REMOVED***
                    model_dict['admin_url'***REMOVED*** = reverse('admin:%s_%s_changelist' % info, current_app=self.name***REMOVED***
                except NoReverseMatch:
                    pass
            if perms.get('add'***REMOVED***:
                ***REMOVED***
                    model_dict['add_url'***REMOVED*** = reverse('admin:%s_%s_add' % info, current_app=self.name***REMOVED***
                except NoReverseMatch:
                    pass

            if app_label in app_dict:
                app_dict[app_label***REMOVED***['models'***REMOVED***.append(model_dict***REMOVED***
            else:
                app_dict[app_label***REMOVED*** = {
                    'name': apps.get_app_config(app_label***REMOVED***.verbose_name,
                    'app_label': app_label,
                    'app_url': reverse(
                        'admin:app_list',
                        kwargs={'app_label': app_label***REMOVED***,
                        current_app=self.name,
                    ***REMOVED***,
                    'has_module_perms': has_module_perms,
                    'models': [model_dict***REMOVED***,
            ***REMOVED***

        if label:
            return app_dict.get(label***REMOVED***
        return app_dict

    def get_app_list(self, request***REMOVED***:
        ***REMOVED***
        Returns a sorted list of all the installed apps that have been
        registered in this site.
        ***REMOVED***
        app_dict = self._build_app_dict(request***REMOVED***

        # Sort the apps alphabetically.
        app_list = sorted(app_dict.values(***REMOVED***, key=lambda x: x['name'***REMOVED***.lower(***REMOVED******REMOVED***

        # Sort the models alphabetically within each app.
        for app in app_list:
            app['models'***REMOVED***.sort(key=lambda x: x['name'***REMOVED******REMOVED***

        return app_list

    @never_cache
    def index(self, request, extra_context=None***REMOVED***:
        ***REMOVED***
        Displays the main admin index page, which lists all of the installed
        apps that have been registered in this site.
        ***REMOVED***
        app_list = self.get_app_list(request***REMOVED***

        context = dict(
            self.each_context(request***REMOVED***,
            title=self.index_title,
            app_list=app_list,
        ***REMOVED***
        context.update(extra_context or {***REMOVED******REMOVED***

        request.current_app = self.name

        return TemplateResponse(request, self.index_template or 'admin/index.html', context***REMOVED***

    def app_index(self, request, app_label, extra_context=None***REMOVED***:
        app_dict = self._build_app_dict(request, app_label***REMOVED***
        if not app_dict:
            raise Http404('The requested admin page does not exist.'***REMOVED***
        # Sort the models alphabetically within each app.
        app_dict['models'***REMOVED***.sort(key=lambda x: x['name'***REMOVED******REMOVED***
        app_name = apps.get_app_config(app_label***REMOVED***.verbose_name
        context = dict(
            self.each_context(request***REMOVED***,
            title=_('%(app***REMOVED***s administration'***REMOVED*** % {'app': app_name***REMOVED***,
            app_list=[app_dict***REMOVED***,
            app_label=app_label,
        ***REMOVED***
        context.update(extra_context or {***REMOVED******REMOVED***

        request.current_app = self.name

        return TemplateResponse(request, self.app_index_template or [
            'admin/%s/app_index.html' % app_label,
            'admin/app_index.html'
        ***REMOVED***, context***REMOVED***

# This global object represents the default admin site, for the common case.
# You can instantiate AdminSite in your own code to create a custom admin site.
site = AdminSite(***REMOVED***
