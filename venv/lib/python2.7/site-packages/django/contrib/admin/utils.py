from __future__ import unicode_literals

import datetime
import decimal
from collections import defaultdict

from django.contrib.auth import get_permission_codename
from django.core.exceptions import FieldDoesNotExist
from django.db import models
from django.db.models.constants import LOOKUP_SEP
from django.db.models.deletion import Collector
from django.db.models.sql.constants import QUERY_TERMS
from django.forms.utils import pretty_name
from django.urls import NoReverseMatch, reverse
from django.utils import formats, six, timezone
from django.utils.encoding import force_str, force_text, smart_text
from django.utils.html import format_html
from django.utils.text import capfirst
from django.utils.translation import ungettext


def lookup_needs_distinct(opts, lookup_path***REMOVED***:
    ***REMOVED***
    Returns True if 'distinct(***REMOVED***' should be used to query the given lookup path.
    ***REMOVED***
    lookup_fields = lookup_path.split('__'***REMOVED***
    # Remove the last item of the lookup path if it is a query term
    if lookup_fields[-1***REMOVED*** in QUERY_TERMS:
        lookup_fields = lookup_fields[:-1***REMOVED***
    # Now go through the fields (following all relations***REMOVED*** and look for an m2m
    for field_name in lookup_fields:
        field = opts.get_field(field_name***REMOVED***
        if hasattr(field, 'get_path_info'***REMOVED***:
            # This field is a relation, update opts to follow the relation
            path_info = field.get_path_info(***REMOVED***
            opts = path_info[-1***REMOVED***.to_opts
            if any(path.m2m for path in path_info***REMOVED***:
                # This field is a m2m relation so we know we need to call distinct
                return True
    return False


def prepare_lookup_value(key, value***REMOVED***:
    ***REMOVED***
    Returns a lookup value prepared to be used in queryset filtering.
    ***REMOVED***
    # if key ends with __in, split parameter into separate values
    if key.endswith('__in'***REMOVED***:
        value = value.split(','***REMOVED***
    # if key ends with __isnull, special case '' and the string literals 'false' and '0'
    if key.endswith('__isnull'***REMOVED***:
        if value.lower(***REMOVED*** in ('', 'false', '0'***REMOVED***:
            value = False
        else:
            value = True
    return value


def quote(s***REMOVED***:
    ***REMOVED***
    Ensure that primary key values do not confuse the admin URLs by escaping
    any '/', '_' and ':' and similarly problematic characters.
    Similar to urllib.quote, except that the quoting is slightly different so
    that it doesn't get automatically unquoted by the Web browser.
    ***REMOVED***
    if not isinstance(s, six.string_types***REMOVED***:
        return s
    res = list(s***REMOVED***
    for i in range(len(res***REMOVED******REMOVED***:
        c = res[i***REMOVED***
        if c in ***REMOVED***:/_#?;@&=+$,"[***REMOVED***<>%\n\\***REMOVED***:
            res[i***REMOVED*** = '_%02X' % ord(c***REMOVED***
    return ''.join(res***REMOVED***


def unquote(s***REMOVED***:
    ***REMOVED***
    Undo the effects of quote(***REMOVED***. Based heavily on urllib.unquote(***REMOVED***.
    ***REMOVED***
    mychr = chr
    myatoi = int
    list = s.split('_'***REMOVED***
    res = [list[0***REMOVED******REMOVED***
    myappend = res.append
    del list[0***REMOVED***
    for item in list:
        if item[1:2***REMOVED***:
            ***REMOVED***
                myappend(mychr(myatoi(item[:2***REMOVED***, 16***REMOVED******REMOVED*** + item[2:***REMOVED******REMOVED***
            except ValueError:
                myappend('_' + item***REMOVED***
        else:
            myappend('_' + item***REMOVED***
    return "".join(res***REMOVED***


def flatten(fields***REMOVED***:
    ***REMOVED***Returns a list which is a single level of flattening of the
    original list.***REMOVED***
    flat = [***REMOVED***
    for field in fields:
        if isinstance(field, (list, tuple***REMOVED******REMOVED***:
            flat.extend(field***REMOVED***
        else:
            flat.append(field***REMOVED***
    return flat


def flatten_fieldsets(fieldsets***REMOVED***:
    ***REMOVED***Returns a list of field names from an admin fieldsets structure.***REMOVED***
    field_names = [***REMOVED***
    for name, opts in fieldsets:
        field_names.extend(
            flatten(opts['fields'***REMOVED******REMOVED***
        ***REMOVED***
    return field_names


def get_deleted_objects(objs, opts, user, admin_site, using***REMOVED***:
    ***REMOVED***
    Find all objects related to ``objs`` that should also be deleted. ``objs``
    must be a homogeneous iterable of objects (e.g. a QuerySet***REMOVED***.

    Returns a nested list of strings suitable for display in the
    template with the ``unordered_list`` filter.
    ***REMOVED***
    collector = NestedObjects(using=using***REMOVED***
    collector.collect(objs***REMOVED***
    perms_needed = set(***REMOVED***

    def format_callback(obj***REMOVED***:
        has_admin = obj.__class__ in admin_site._registry
        opts = obj._meta

        no_edit_link = '%s: %s' % (capfirst(opts.verbose_name***REMOVED***,
                                   force_text(obj***REMOVED******REMOVED***

        if has_admin:
            ***REMOVED***
                admin_url = reverse('%s:%s_%s_change'
                                    % (admin_site.name,
                                       opts.app_label,
                                       opts.model_name***REMOVED***,
                                    None, (quote(obj._get_pk_val(***REMOVED******REMOVED***,***REMOVED******REMOVED***
            except NoReverseMatch:
                # Change url doesn't exist -- don't display link to edit
                return no_edit_link

            p = '%s.%s' % (opts.app_label,
                           get_permission_codename('delete', opts***REMOVED******REMOVED***
            if not user.has_perm(p***REMOVED***:
                perms_needed.add(opts.verbose_name***REMOVED***
            # Display a link to the admin page.
            return format_html('{***REMOVED***: <a href="{***REMOVED***">{***REMOVED***</a>',
                               capfirst(opts.verbose_name***REMOVED***,
                               admin_url,
                               obj***REMOVED***
        else:
            # Don't display link to edit, because it either has no
            # admin or is edited inline.
            return no_edit_link

    to_delete = collector.nested(format_callback***REMOVED***

    protected = [format_callback(obj***REMOVED*** for obj in collector.protected***REMOVED***
    model_count = {model._meta.verbose_name_plural: len(objs***REMOVED*** for model, objs in collector.model_objs.items(***REMOVED******REMOVED***

    return to_delete, model_count, perms_needed, protected


class NestedObjects(Collector***REMOVED***:
    def __init__(self, *args, **kwargs***REMOVED***:
        super(NestedObjects, self***REMOVED***.__init__(*args, **kwargs***REMOVED***
        self.edges = {***REMOVED***  # {from_instance: [to_instances***REMOVED******REMOVED***
        self.protected = set(***REMOVED***
        self.model_objs = defaultdict(set***REMOVED***

    def add_edge(self, source, target***REMOVED***:
        self.edges.setdefault(source, [***REMOVED******REMOVED***.append(target***REMOVED***

    def collect(self, objs, source=None, source_attr=None, **kwargs***REMOVED***:
        for obj in objs:
            if source_attr and not source_attr.endswith('+'***REMOVED***:
                related_name = source_attr % {
                    'class': source._meta.model_name,
                    'app_label': source._meta.app_label,
            ***REMOVED***
                self.add_edge(getattr(obj, related_name***REMOVED***, obj***REMOVED***
            else:
                self.add_edge(None, obj***REMOVED***
            self.model_objs[obj._meta.model***REMOVED***.add(obj***REMOVED***
        ***REMOVED***
            return super(NestedObjects, self***REMOVED***.collect(objs, source_attr=source_attr, **kwargs***REMOVED***
        except models.ProtectedError as e:
            self.protected.update(e.protected_objects***REMOVED***

    def related_objects(self, related, objs***REMOVED***:
        qs = super(NestedObjects, self***REMOVED***.related_objects(related, objs***REMOVED***
        return qs.select_related(related.field.name***REMOVED***

    def _nested(self, obj, seen, format_callback***REMOVED***:
        if obj in seen:
            return [***REMOVED***
        seen.add(obj***REMOVED***
        children = [***REMOVED***
        for child in self.edges.get(obj, (***REMOVED******REMOVED***:
            children.extend(self._nested(child, seen, format_callback***REMOVED******REMOVED***
        if format_callback:
            ret = [format_callback(obj***REMOVED******REMOVED***
        else:
            ret = [obj***REMOVED***
        if children:
            ret.append(children***REMOVED***
        return ret

    def nested(self, format_callback=None***REMOVED***:
        ***REMOVED***
        Return the graph as a nested list.
        ***REMOVED***
        seen = set(***REMOVED***
        roots = [***REMOVED***
        for root in self.edges.get(None, (***REMOVED******REMOVED***:
            roots.extend(self._nested(root, seen, format_callback***REMOVED******REMOVED***
        return roots

    def can_fast_delete(self, *args, **kwargs***REMOVED***:
        ***REMOVED***
        We always want to load the objects into memory so that we can display
        them to the user in confirm page.
        ***REMOVED***
        return False


def model_format_dict(obj***REMOVED***:
    ***REMOVED***
    Return a `dict` with keys 'verbose_name' and 'verbose_name_plural',
    typically for use with string formatting.

    `obj` may be a `Model` instance, `Model` subclass, or `QuerySet` instance.
    ***REMOVED***
    if isinstance(obj, (models.Model, models.base.ModelBase***REMOVED******REMOVED***:
        opts = obj._meta
    elif isinstance(obj, models.query.QuerySet***REMOVED***:
        opts = obj.model._meta
    else:
        opts = obj
    return {
        'verbose_name': force_text(opts.verbose_name***REMOVED***,
        'verbose_name_plural': force_text(opts.verbose_name_plural***REMOVED***
***REMOVED***


def model_ngettext(obj, n=None***REMOVED***:
    ***REMOVED***
    Return the appropriate `verbose_name` or `verbose_name_plural` value for
    `obj` depending on the count `n`.

    `obj` may be a `Model` instance, `Model` subclass, or `QuerySet` instance.
    If `obj` is a `QuerySet` instance, `n` is optional and the length of the
    `QuerySet` is used.
    ***REMOVED***
    if isinstance(obj, models.query.QuerySet***REMOVED***:
        if n is None:
            n = obj.count(***REMOVED***
        obj = obj.model
    d = model_format_dict(obj***REMOVED***
    singular, plural = d["verbose_name"***REMOVED***, d["verbose_name_plural"***REMOVED***
    return ungettext(singular, plural, n or 0***REMOVED***


def lookup_field(name, obj, model_admin=None***REMOVED***:
    opts = obj._meta
    ***REMOVED***
        f = _get_non_gfk_field(opts, name***REMOVED***
    except FieldDoesNotExist:
        # For non-field values, the value is either a method, property or
        # returned via a callable.
        if callable(name***REMOVED***:
            attr = name
            value = attr(obj***REMOVED***
        elif (model_admin is not None and
                hasattr(model_admin, name***REMOVED*** and
                not name == '__str__' and
                not name == '__unicode__'***REMOVED***:
            attr = getattr(model_admin, name***REMOVED***
            value = attr(obj***REMOVED***
        else:
            attr = getattr(obj, name***REMOVED***
            if callable(attr***REMOVED***:
                value = attr(***REMOVED***
            else:
                value = attr
        f = None
    else:
        attr = None
        value = getattr(obj, name***REMOVED***
    return f, attr, value


def _get_non_gfk_field(opts, name***REMOVED***:
    ***REMOVED***
    For historical reasons, the admin app relies on GenericForeignKeys as being
    "not found" by get_field(***REMOVED***. This could likely be cleaned up.

    Reverse relations should also be excluded as these aren't attributes of the
    model (rather something like `foo_set`***REMOVED***.
    ***REMOVED***
    field = opts.get_field(name***REMOVED***
    if (field.is_relation and
            # Generic foreign keys OR reverse relations
            ((field.many_to_one and not field.related_model***REMOVED*** or field.one_to_many***REMOVED******REMOVED***:
        raise FieldDoesNotExist(***REMOVED***
    return field


def label_for_field(name, model, model_admin=None, return_attr=False***REMOVED***:
    ***REMOVED***
    Returns a sensible label for a field name. The name can be a callable,
    property (but not created with @property decorator***REMOVED*** or the name of an
    object's attribute, as well as a genuine fields. If return_attr is
    True, the resolved attribute (which could be a callable***REMOVED*** is also returned.
    This will be None if (and only if***REMOVED*** the name refers to a field.
    ***REMOVED***
    attr = None
    ***REMOVED***
        field = _get_non_gfk_field(model._meta, name***REMOVED***
        ***REMOVED***
            label = field.verbose_name
        except AttributeError:
            # field is likely a ForeignObjectRel
            label = field.related_model._meta.verbose_name
    except FieldDoesNotExist:
        if name == "__unicode__":
            label = force_text(model._meta.verbose_name***REMOVED***
            attr = six.text_type
        elif name == "__str__":
            label = force_str(model._meta.verbose_name***REMOVED***
            attr = bytes
        else:
            if callable(name***REMOVED***:
                attr = name
            elif model_admin is not None and hasattr(model_admin, name***REMOVED***:
                attr = getattr(model_admin, name***REMOVED***
            elif hasattr(model, name***REMOVED***:
                attr = getattr(model, name***REMOVED***
            else:
                message = "Unable to lookup '%s' on %s" % (name, model._meta.object_name***REMOVED***
                if model_admin:
                    message += " or %s" % (model_admin.__class__.__name__,***REMOVED***
                raise AttributeError(message***REMOVED***

            if hasattr(attr, "short_description"***REMOVED***:
                label = attr.short_description
            elif (isinstance(attr, property***REMOVED*** and
                  hasattr(attr, "fget"***REMOVED*** and
                  hasattr(attr.fget, "short_description"***REMOVED******REMOVED***:
                label = attr.fget.short_description
            elif callable(attr***REMOVED***:
                if attr.__name__ == "<lambda>":
                    label = "--"
                else:
                    label = pretty_name(attr.__name__***REMOVED***
            else:
                label = pretty_name(name***REMOVED***
    if return_attr:
        return (label, attr***REMOVED***
    else:
        return label


def help_text_for_field(name, model***REMOVED***:
    help_text = ""
    ***REMOVED***
        field = _get_non_gfk_field(model._meta, name***REMOVED***
    except FieldDoesNotExist:
        pass
    else:
        if hasattr(field, 'help_text'***REMOVED***:
            help_text = field.help_text
    return smart_text(help_text***REMOVED***


def display_for_field(value, field, empty_value_display***REMOVED***:
    from django.contrib.admin.templatetags.admin_list import _boolean_icon

    if getattr(field, 'flatchoices', None***REMOVED***:
        return dict(field.flatchoices***REMOVED***.get(value, empty_value_display***REMOVED***
    # NullBooleanField needs special-case null-handling, so it comes
    # before the general null test.
    elif isinstance(field, models.BooleanField***REMOVED*** or isinstance(field, models.NullBooleanField***REMOVED***:
        return _boolean_icon(value***REMOVED***
    elif value is None:
        return empty_value_display
    elif isinstance(field, models.DateTimeField***REMOVED***:
        return formats.localize(timezone.template_localtime(value***REMOVED******REMOVED***
    elif isinstance(field, (models.DateField, models.TimeField***REMOVED******REMOVED***:
        return formats.localize(value***REMOVED***
    elif isinstance(field, models.DecimalField***REMOVED***:
        return formats.number_format(value, field.decimal_places***REMOVED***
    elif isinstance(field, (models.IntegerField, models.FloatField***REMOVED******REMOVED***:
        return formats.number_format(value***REMOVED***
    elif isinstance(field, models.FileField***REMOVED*** and value:
        return format_html('<a href="{***REMOVED***">{***REMOVED***</a>', value.url, value***REMOVED***
    else:
        return display_for_value(value, empty_value_display***REMOVED***


def display_for_value(value, empty_value_display, boolean=False***REMOVED***:
    from django.contrib.admin.templatetags.admin_list import _boolean_icon

    if boolean:
        return _boolean_icon(value***REMOVED***
    elif value is None:
        return empty_value_display
    elif isinstance(value, datetime.datetime***REMOVED***:
        return formats.localize(timezone.template_localtime(value***REMOVED******REMOVED***
    elif isinstance(value, (datetime.date, datetime.time***REMOVED******REMOVED***:
        return formats.localize(value***REMOVED***
    elif isinstance(value, six.integer_types + (decimal.Decimal, float***REMOVED******REMOVED***:
        return formats.number_format(value***REMOVED***
    elif isinstance(value, (list, tuple***REMOVED******REMOVED***:
        return ', '.join(force_text(v***REMOVED*** for v in value***REMOVED***
    else:
        return smart_text(value***REMOVED***


class NotRelationField(Exception***REMOVED***:
    pass


def get_model_from_relation(field***REMOVED***:
    if hasattr(field, 'get_path_info'***REMOVED***:
        return field.get_path_info(***REMOVED***[-1***REMOVED***.to_opts.model
    else:
        raise NotRelationField


def reverse_field_path(model, path***REMOVED***:
    ***REMOVED*** Create a reversed field path.

    E.g. Given (Order, "user__groups"***REMOVED***,
    return (Group, "user__order"***REMOVED***.

    Final field must be a related model, not a data field.
    ***REMOVED***
    reversed_path = [***REMOVED***
    parent = model
    pieces = path.split(LOOKUP_SEP***REMOVED***
    for piece in pieces:
        field = parent._meta.get_field(piece***REMOVED***
        # skip trailing data field if extant:
        if len(reversed_path***REMOVED*** == len(pieces***REMOVED*** - 1:  # final iteration
            ***REMOVED***
                get_model_from_relation(field***REMOVED***
            except NotRelationField:
                break

        # Field should point to another model
        if field.is_relation and not (field.auto_created and not field.concrete***REMOVED***:
            related_name = field.related_query_name(***REMOVED***
            parent = field.remote_field.model
        else:
            related_name = field.field.name
            parent = field.related_model
        reversed_path.insert(0, related_name***REMOVED***
    return (parent, LOOKUP_SEP.join(reversed_path***REMOVED******REMOVED***


def get_fields_from_path(model, path***REMOVED***:
    ***REMOVED*** Return list of Fields given path relative to model.

    e.g. (ModelX, "user__groups__name"***REMOVED*** -> [
        <django.db.models.fields.related.ForeignKey object at 0x...>,
        <django.db.models.fields.related.ManyToManyField object at 0x...>,
        <django.db.models.fields.CharField object at 0x...>,
    ***REMOVED***
    ***REMOVED***
    pieces = path.split(LOOKUP_SEP***REMOVED***
    fields = [***REMOVED***
    for piece in pieces:
        if fields:
            parent = get_model_from_relation(fields[-1***REMOVED******REMOVED***
        else:
            parent = model
        fields.append(parent._meta.get_field(piece***REMOVED******REMOVED***
    return fields


def remove_trailing_data_field(fields***REMOVED***:
    ***REMOVED*** Discard trailing non-relation field if extant. ***REMOVED***
    ***REMOVED***
        get_model_from_relation(fields[-1***REMOVED******REMOVED***
    except NotRelationField:
        fields = fields[:-1***REMOVED***
    return fields
