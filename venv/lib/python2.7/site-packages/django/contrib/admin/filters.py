***REMOVED***
This encapsulates the logic for displaying filters in the Django admin.
Filters are specified in models with the "list_filter" option.

Each filter subclass knows how to display a filter for a field that passes a
certain test -- e.g. being a DateField or ForeignKey.
***REMOVED***
import datetime

from django.contrib.admin.options import IncorrectLookupParameters
from django.contrib.admin.utils import (
    get_model_from_relation, prepare_lookup_value, reverse_field_path,
***REMOVED***
from django.core.exceptions import ImproperlyConfigured, ValidationError
from django.db import models
from django.utils import timezone
from django.utils.encoding import force_text, smart_text
from django.utils.translation import ugettext_lazy as _


class ListFilter(object***REMOVED***:
    title = None  # Human-readable title to appear in the right sidebar.
    template = 'admin/filter.html'

    def __init__(self, request, params, model, model_admin***REMOVED***:
        # This dictionary will eventually contain the request's query string
        # parameters actually used by this filter.
        self.used_parameters = {***REMOVED***
        if self.title is None:
            raise ImproperlyConfigured(
                "The list filter '%s' does not specify "
                "a 'title'." % self.__class__.__name__***REMOVED***

    def has_output(self***REMOVED***:
        ***REMOVED***
        Returns True if some choices would be output for this filter.
        ***REMOVED***
        raise NotImplementedError('subclasses of ListFilter must provide a has_output(***REMOVED*** method'***REMOVED***

    def choices(self, changelist***REMOVED***:
        ***REMOVED***
        Returns choices ready to be output in the template.

        `changelist` is the ChangeList to be displayed.
        ***REMOVED***
        raise NotImplementedError('subclasses of ListFilter must provide a choices(***REMOVED*** method'***REMOVED***

    def queryset(self, request, queryset***REMOVED***:
        ***REMOVED***
        Returns the filtered queryset.
        ***REMOVED***
        raise NotImplementedError('subclasses of ListFilter must provide a queryset(***REMOVED*** method'***REMOVED***

    def expected_parameters(self***REMOVED***:
        ***REMOVED***
        Returns the list of parameter names that are expected from the
        request's query string and that will be used by this filter.
        ***REMOVED***
        raise NotImplementedError('subclasses of ListFilter must provide an expected_parameters(***REMOVED*** method'***REMOVED***


class SimpleListFilter(ListFilter***REMOVED***:
    # The parameter that should be used in the query string for that filter.
    parameter_name = None

    def __init__(self, request, params, model, model_admin***REMOVED***:
        super(SimpleListFilter, self***REMOVED***.__init__(
            request, params, model, model_admin***REMOVED***
        if self.parameter_name is None:
            raise ImproperlyConfigured(
                "The list filter '%s' does not specify "
                "a 'parameter_name'." % self.__class__.__name__***REMOVED***
        if self.parameter_name in params:
            value = params.pop(self.parameter_name***REMOVED***
            self.used_parameters[self.parameter_name***REMOVED*** = value
        lookup_choices = self.lookups(request, model_admin***REMOVED***
        if lookup_choices is None:
            lookup_choices = (***REMOVED***
        self.lookup_choices = list(lookup_choices***REMOVED***

    def has_output(self***REMOVED***:
        return len(self.lookup_choices***REMOVED*** > 0

    def value(self***REMOVED***:
        ***REMOVED***
        Returns the value (in string format***REMOVED*** provided in the request's
        query string for this filter, if any. If the value wasn't provided then
        returns None.
        ***REMOVED***
        return self.used_parameters.get(self.parameter_name***REMOVED***

    def lookups(self, request, model_admin***REMOVED***:
        ***REMOVED***
        Must be overridden to return a list of tuples (value, verbose value***REMOVED***
        ***REMOVED***
        raise NotImplementedError(
            'The SimpleListFilter.lookups(***REMOVED*** method must be overridden to '
            'return a list of tuples (value, verbose value***REMOVED***'***REMOVED***

    def expected_parameters(self***REMOVED***:
        return [self.parameter_name***REMOVED***

    def choices(self, changelist***REMOVED***:
        yield {
            'selected': self.value(***REMOVED*** is None,
            'query_string': changelist.get_query_string({***REMOVED***, [self.parameter_name***REMOVED******REMOVED***,
            'display': _('All'***REMOVED***,
    ***REMOVED***
        for lookup, title in self.lookup_choices:
            yield {
                'selected': self.value(***REMOVED*** == force_text(lookup***REMOVED***,
                'query_string': changelist.get_query_string({self.parameter_name: lookup***REMOVED***, [***REMOVED******REMOVED***,
                'display': title,
        ***REMOVED***


class FieldListFilter(ListFilter***REMOVED***:
    _field_list_filters = [***REMOVED***
    _take_priority_index = 0

    def __init__(self, field, request, params, model, model_admin, field_path***REMOVED***:
        self.field = field
        self.field_path = field_path
        self.title = getattr(field, 'verbose_name', field_path***REMOVED***
        super(FieldListFilter, self***REMOVED***.__init__(
            request, params, model, model_admin***REMOVED***
        for p in self.expected_parameters(***REMOVED***:
            if p in params:
                value = params.pop(p***REMOVED***
                self.used_parameters[p***REMOVED*** = prepare_lookup_value(p, value***REMOVED***

    def has_output(self***REMOVED***:
        return True

    def queryset(self, request, queryset***REMOVED***:
        ***REMOVED***
            return queryset.filter(**self.used_parameters***REMOVED***
        except ValidationError as e:
            raise IncorrectLookupParameters(e***REMOVED***

    @classmethod
    def register(cls, test, list_filter_class, take_priority=False***REMOVED***:
        if take_priority:
            # This is to allow overriding the default filters for certain types
            # of fields with some custom filters. The first found in the list
            # is used in priority.
            cls._field_list_filters.insert(
                cls._take_priority_index, (test, list_filter_class***REMOVED******REMOVED***
            cls._take_priority_index += 1
        else:
            cls._field_list_filters.append((test, list_filter_class***REMOVED******REMOVED***

    @classmethod
    def create(cls, field, request, params, model, model_admin, field_path***REMOVED***:
        for test, list_filter_class in cls._field_list_filters:
            if not test(field***REMOVED***:
                continue
            return list_filter_class(field, request, params, model, model_admin, field_path=field_path***REMOVED***


class RelatedFieldListFilter(FieldListFilter***REMOVED***:
    def __init__(self, field, request, params, model, model_admin, field_path***REMOVED***:
        other_model = get_model_from_relation(field***REMOVED***
        self.lookup_kwarg = '%s__%s__exact' % (field_path, field.target_field.name***REMOVED***
        self.lookup_kwarg_isnull = '%s__isnull' % field_path
        self.lookup_val = request.GET.get(self.lookup_kwarg***REMOVED***
        self.lookup_val_isnull = request.GET.get(self.lookup_kwarg_isnull***REMOVED***
        super(RelatedFieldListFilter, self***REMOVED***.__init__(
            field, request, params, model, model_admin, field_path***REMOVED***
        self.lookup_choices = self.field_choices(field, request, model_admin***REMOVED***
        if hasattr(field, 'verbose_name'***REMOVED***:
            self.lookup_title = field.verbose_name
        else:
            self.lookup_title = other_model._meta.verbose_name
        self.title = self.lookup_title
        self.empty_value_display = model_admin.get_empty_value_display(***REMOVED***

    @property
    def include_empty_choice(self***REMOVED***:
        ***REMOVED***
        Return True if a "(None***REMOVED***" choice should be included, which filters
        out everything except empty relationships.
        ***REMOVED***
        return self.field.null or (self.field.is_relation and self.field.many_to_many***REMOVED***

    def has_output(self***REMOVED***:
        if self.include_empty_choice:
            extra = 1
        else:
            extra = 0
        return len(self.lookup_choices***REMOVED*** + extra > 1

    def expected_parameters(self***REMOVED***:
        return [self.lookup_kwarg, self.lookup_kwarg_isnull***REMOVED***

    def field_choices(self, field, request, model_admin***REMOVED***:
        return field.get_choices(include_blank=False***REMOVED***

    def choices(self, changelist***REMOVED***:
        yield {
            'selected': self.lookup_val is None and not self.lookup_val_isnull,
            'query_string': changelist.get_query_string(
            ***REMOVED******REMOVED***,
                [self.lookup_kwarg, self.lookup_kwarg_isnull***REMOVED***
            ***REMOVED***,
            'display': _('All'***REMOVED***,
    ***REMOVED***
        for pk_val, val in self.lookup_choices:
            yield {
                'selected': self.lookup_val == smart_text(pk_val***REMOVED***,
                'query_string': changelist.get_query_string({
                    self.lookup_kwarg: pk_val,
        ***REMOVED*** [self.lookup_kwarg_isnull***REMOVED******REMOVED***,
                'display': val,
        ***REMOVED***
        if self.include_empty_choice:
            yield {
                'selected': bool(self.lookup_val_isnull***REMOVED***,
                'query_string': changelist.get_query_string({
                    self.lookup_kwarg_isnull: 'True',
        ***REMOVED*** [self.lookup_kwarg***REMOVED******REMOVED***,
                'display': self.empty_value_display,
        ***REMOVED***

FieldListFilter.register(lambda f: f.remote_field, RelatedFieldListFilter***REMOVED***


class BooleanFieldListFilter(FieldListFilter***REMOVED***:
    def __init__(self, field, request, params, model, model_admin, field_path***REMOVED***:
        self.lookup_kwarg = '%s__exact' % field_path
        self.lookup_kwarg2 = '%s__isnull' % field_path
        self.lookup_val = request.GET.get(self.lookup_kwarg***REMOVED***
        self.lookup_val2 = request.GET.get(self.lookup_kwarg2***REMOVED***
        super(BooleanFieldListFilter, self***REMOVED***.__init__(field, request, params, model, model_admin, field_path***REMOVED***
        if (self.used_parameters and self.lookup_kwarg in self.used_parameters and
                self.used_parameters[self.lookup_kwarg***REMOVED*** in ('1', '0'***REMOVED******REMOVED***:
            self.used_parameters[self.lookup_kwarg***REMOVED*** = bool(int(self.used_parameters[self.lookup_kwarg***REMOVED******REMOVED******REMOVED***

    def expected_parameters(self***REMOVED***:
        return [self.lookup_kwarg, self.lookup_kwarg2***REMOVED***

    def choices(self, changelist***REMOVED***:
        for lookup, title in (
                (None, _('All'***REMOVED******REMOVED***,
                ('1', _('Yes'***REMOVED******REMOVED***,
                ('0', _('No'***REMOVED******REMOVED******REMOVED***:
            yield {
                'selected': self.lookup_val == lookup and not self.lookup_val2,
                'query_string': changelist.get_query_string({
                    self.lookup_kwarg: lookup,
        ***REMOVED*** [self.lookup_kwarg2***REMOVED******REMOVED***,
                'display': title,
        ***REMOVED***
        if isinstance(self.field, models.NullBooleanField***REMOVED***:
            yield {
                'selected': self.lookup_val2 == 'True',
                'query_string': changelist.get_query_string({
                    self.lookup_kwarg2: 'True',
        ***REMOVED*** [self.lookup_kwarg***REMOVED******REMOVED***,
                'display': _('Unknown'***REMOVED***,
        ***REMOVED***

FieldListFilter.register(
    lambda f: isinstance(f, (models.BooleanField, models.NullBooleanField***REMOVED******REMOVED***,
    BooleanFieldListFilter
***REMOVED***


class ChoicesFieldListFilter(FieldListFilter***REMOVED***:
    def __init__(self, field, request, params, model, model_admin, field_path***REMOVED***:
        self.lookup_kwarg = '%s__exact' % field_path
        self.lookup_kwarg_isnull = '%s__isnull' % field_path
        self.lookup_val = request.GET.get(self.lookup_kwarg***REMOVED***
        self.lookup_val_isnull = request.GET.get(self.lookup_kwarg_isnull***REMOVED***
        super(ChoicesFieldListFilter, self***REMOVED***.__init__(
            field, request, params, model, model_admin, field_path***REMOVED***

    def expected_parameters(self***REMOVED***:
        return [self.lookup_kwarg, self.lookup_kwarg_isnull***REMOVED***

    def choices(self, changelist***REMOVED***:
        yield {
            'selected': self.lookup_val is None,
            'query_string': changelist.get_query_string(
            ***REMOVED******REMOVED***, [self.lookup_kwarg, self.lookup_kwarg_isnull***REMOVED***
            ***REMOVED***,
            'display': _('All'***REMOVED***
    ***REMOVED***
        none_title = ''
        for lookup, title in self.field.flatchoices:
            if lookup is None:
                none_title = title
                continue
            yield {
                'selected': smart_text(lookup***REMOVED*** == self.lookup_val,
                'query_string': changelist.get_query_string(
                ***REMOVED***self.lookup_kwarg: lookup***REMOVED***, [self.lookup_kwarg_isnull***REMOVED***
                ***REMOVED***,
                'display': title,
        ***REMOVED***
        if none_title:
            yield {
                'selected': bool(self.lookup_val_isnull***REMOVED***,
                'query_string': changelist.get_query_string({
                    self.lookup_kwarg_isnull: 'True',
        ***REMOVED*** [self.lookup_kwarg***REMOVED******REMOVED***,
                'display': none_title,
        ***REMOVED***

FieldListFilter.register(lambda f: bool(f.choices***REMOVED***, ChoicesFieldListFilter***REMOVED***


class DateFieldListFilter(FieldListFilter***REMOVED***:
    def __init__(self, field, request, params, model, model_admin, field_path***REMOVED***:
        self.field_generic = '%s__' % field_path
        self.date_params = {k: v for k, v in params.items(***REMOVED*** if k.startswith(self.field_generic***REMOVED******REMOVED***

        now = timezone.now(***REMOVED***
        # When time zone support is enabled, convert "now" to the user's time
        # zone so Django's definition of "Today" matches what the user expects.
        if timezone.is_aware(now***REMOVED***:
            now = timezone.localtime(now***REMOVED***

        if isinstance(field, models.DateTimeField***REMOVED***:
            today = now.replace(hour=0, minute=0, second=0, microsecond=0***REMOVED***
        else:       # field is a models.DateField
            today = now.date(***REMOVED***
        tomorrow = today + datetime.timedelta(days=1***REMOVED***
        if today.month == 12:
            next_month = today.replace(year=today.year + 1, month=1, day=1***REMOVED***
        else:
            next_month = today.replace(month=today.month + 1, day=1***REMOVED***
        next_year = today.replace(year=today.year + 1, month=1, day=1***REMOVED***

        self.lookup_kwarg_since = '%s__gte' % field_path
        self.lookup_kwarg_until = '%s__lt' % field_path
        self.links = (
            (_('Any date'***REMOVED***, {***REMOVED******REMOVED***,
            (_('Today'***REMOVED***, {
                self.lookup_kwarg_since: str(today***REMOVED***,
                self.lookup_kwarg_until: str(tomorrow***REMOVED***,
        ***REMOVED******REMOVED***,
            (_('Past 7 days'***REMOVED***, {
                self.lookup_kwarg_since: str(today - datetime.timedelta(days=7***REMOVED******REMOVED***,
                self.lookup_kwarg_until: str(tomorrow***REMOVED***,
        ***REMOVED******REMOVED***,
            (_('This month'***REMOVED***, {
                self.lookup_kwarg_since: str(today.replace(day=1***REMOVED******REMOVED***,
                self.lookup_kwarg_until: str(next_month***REMOVED***,
        ***REMOVED******REMOVED***,
            (_('This year'***REMOVED***, {
                self.lookup_kwarg_since: str(today.replace(month=1, day=1***REMOVED******REMOVED***,
                self.lookup_kwarg_until: str(next_year***REMOVED***,
        ***REMOVED******REMOVED***,
        ***REMOVED***
        if field.null:
            self.lookup_kwarg_isnull = '%s__isnull' % field_path
            self.links += (
                (_('No date'***REMOVED***, {self.field_generic + 'isnull': 'True'***REMOVED******REMOVED***,
                (_('Has date'***REMOVED***, {self.field_generic + 'isnull': 'False'***REMOVED******REMOVED***,
            ***REMOVED***
        super(DateFieldListFilter, self***REMOVED***.__init__(
            field, request, params, model, model_admin, field_path***REMOVED***

    def expected_parameters(self***REMOVED***:
        params = [self.lookup_kwarg_since, self.lookup_kwarg_until***REMOVED***
        if self.field.null:
            params.append(self.lookup_kwarg_isnull***REMOVED***
        return params

    def choices(self, changelist***REMOVED***:
        for title, param_dict in self.links:
            yield {
                'selected': self.date_params == param_dict,
                'query_string': changelist.get_query_string(param_dict, [self.field_generic***REMOVED******REMOVED***,
                'display': title,
        ***REMOVED***

FieldListFilter.register(
    lambda f: isinstance(f, models.DateField***REMOVED***, DateFieldListFilter***REMOVED***


# This should be registered last, because it's a last resort. For example,
# if a field is eligible to use the BooleanFieldListFilter, that'd be much
# more appropriate, and the AllValuesFieldListFilter won't get used for it.
class AllValuesFieldListFilter(FieldListFilter***REMOVED***:
    def __init__(self, field, request, params, model, model_admin, field_path***REMOVED***:
        self.lookup_kwarg = field_path
        self.lookup_kwarg_isnull = '%s__isnull' % field_path
        self.lookup_val = request.GET.get(self.lookup_kwarg***REMOVED***
        self.lookup_val_isnull = request.GET.get(self.lookup_kwarg_isnull***REMOVED***
        self.empty_value_display = model_admin.get_empty_value_display(***REMOVED***
        parent_model, reverse_path = reverse_field_path(model, field_path***REMOVED***
        # Obey parent ModelAdmin queryset when deciding which options to show
        if model == parent_model:
            queryset = model_admin.get_queryset(request***REMOVED***
        else:
            queryset = parent_model._default_manager.all(***REMOVED***
        self.lookup_choices = (queryset
                               .distinct(***REMOVED***
                               .order_by(field.name***REMOVED***
                               .values_list(field.name, flat=True***REMOVED******REMOVED***
        super(AllValuesFieldListFilter, self***REMOVED***.__init__(
            field, request, params, model, model_admin, field_path***REMOVED***

    def expected_parameters(self***REMOVED***:
        return [self.lookup_kwarg, self.lookup_kwarg_isnull***REMOVED***

    def choices(self, changelist***REMOVED***:
        yield {
            'selected': self.lookup_val is None and self.lookup_val_isnull is None,
            'query_string': changelist.get_query_string({***REMOVED***, [self.lookup_kwarg, self.lookup_kwarg_isnull***REMOVED******REMOVED***,
            'display': _('All'***REMOVED***,
    ***REMOVED***
        include_none = False
        for val in self.lookup_choices:
            if val is None:
                include_none = True
                continue
            val = smart_text(val***REMOVED***
            yield {
                'selected': self.lookup_val == val,
                'query_string': changelist.get_query_string({
                    self.lookup_kwarg: val,
        ***REMOVED*** [self.lookup_kwarg_isnull***REMOVED******REMOVED***,
                'display': val,
        ***REMOVED***
        if include_none:
            yield {
                'selected': bool(self.lookup_val_isnull***REMOVED***,
                'query_string': changelist.get_query_string({
                    self.lookup_kwarg_isnull: 'True',
        ***REMOVED*** [self.lookup_kwarg***REMOVED******REMOVED***,
                'display': self.empty_value_display,
        ***REMOVED***

FieldListFilter.register(lambda f: True, AllValuesFieldListFilter***REMOVED***


class RelatedOnlyFieldListFilter(RelatedFieldListFilter***REMOVED***:
    def field_choices(self, field, request, model_admin***REMOVED***:
        pk_qs = model_admin.get_queryset(request***REMOVED***.distinct(***REMOVED***.values_list('%s__pk' % self.field_path, flat=True***REMOVED***
        return field.get_choices(include_blank=False, limit_choices_to={'pk__in': pk_qs***REMOVED******REMOVED***
