***REMOVED***
Cross Site Request Forgery Middleware.

This module provides a middleware that implements protection
against request forgeries from other sites.
***REMOVED***
from __future__ import unicode_literals

import logging
import re
import string

from django.conf import settings
from django.urls import get_callable
from django.utils.cache import patch_vary_headers
from django.utils.crypto import constant_time_compare, get_random_string
from django.utils.deprecation import MiddlewareMixin
from django.utils.encoding import force_text
from django.utils.http import is_same_domain
from django.utils.six.moves import zip
from django.utils.six.moves.urllib.parse import urlparse

logger = logging.getLogger('django.request'***REMOVED***

REASON_NO_REFERER = "Referer checking failed - no Referer."
REASON_BAD_REFERER = "Referer checking failed - %s does not match any trusted origins."
REASON_NO_CSRF_COOKIE = "CSRF cookie not set."
REASON_BAD_TOKEN = "CSRF token missing or incorrect."
REASON_MALFORMED_REFERER = "Referer checking failed - Referer is malformed."
REASON_INSECURE_REFERER = "Referer checking failed - Referer is insecure while host is secure."

CSRF_SECRET_LENGTH = 32
CSRF_TOKEN_LENGTH = 2 * CSRF_SECRET_LENGTH
CSRF_ALLOWED_CHARS = string.ascii_letters + string.digits


def _get_failure_view(***REMOVED***:
    ***REMOVED***
    Returns the view to be used for CSRF rejections
    ***REMOVED***
    return get_callable(settings.CSRF_FAILURE_VIEW***REMOVED***


def _get_new_csrf_string(***REMOVED***:
    return get_random_string(CSRF_SECRET_LENGTH, allowed_chars=CSRF_ALLOWED_CHARS***REMOVED***


def _salt_cipher_secret(secret***REMOVED***:
    ***REMOVED***
    Given a secret (assumed to be a string of CSRF_ALLOWED_CHARS***REMOVED***, generate a
    token by adding a salt and using it to encrypt the secret.
    ***REMOVED***
    salt = _get_new_csrf_string(***REMOVED***
    chars = CSRF_ALLOWED_CHARS
    pairs = zip((chars.index(x***REMOVED*** for x in secret***REMOVED***, (chars.index(x***REMOVED*** for x in salt***REMOVED******REMOVED***
    cipher = ''.join(chars[(x + y***REMOVED*** % len(chars***REMOVED******REMOVED*** for x, y in pairs***REMOVED***
    return salt + cipher


def _unsalt_cipher_token(token***REMOVED***:
    ***REMOVED***
    Given a token (assumed to be a string of CSRF_ALLOWED_CHARS, of length
    CSRF_TOKEN_LENGTH, and that its first half is a salt***REMOVED***, use it to decrypt
    the second half to produce the original secret.
    ***REMOVED***
    salt = token[:CSRF_SECRET_LENGTH***REMOVED***
    token = token[CSRF_SECRET_LENGTH:***REMOVED***
    chars = CSRF_ALLOWED_CHARS
    pairs = zip((chars.index(x***REMOVED*** for x in token***REMOVED***, (chars.index(x***REMOVED*** for x in salt***REMOVED******REMOVED***
    secret = ''.join(chars[x - y***REMOVED*** for x, y in pairs***REMOVED***  # Note negative values are ok
    return secret


def _get_new_csrf_token(***REMOVED***:
    return _salt_cipher_secret(_get_new_csrf_string(***REMOVED******REMOVED***


def get_token(request***REMOVED***:
    ***REMOVED***
    Returns the CSRF token required for a POST form. The token is an
    alphanumeric value. A new token is created if one is not already set.

    A side effect of calling this function is to make the csrf_protect
    decorator and the CsrfViewMiddleware add a CSRF cookie and a 'Vary: Cookie'
    header to the outgoing response.  For this reason, you may need to use this
    function lazily, as is done by the csrf context processor.
    ***REMOVED***
    if "CSRF_COOKIE" not in request.META:
        csrf_secret = _get_new_csrf_string(***REMOVED***
        request.META["CSRF_COOKIE"***REMOVED*** = _salt_cipher_secret(csrf_secret***REMOVED***
    else:
        csrf_secret = _unsalt_cipher_token(request.META["CSRF_COOKIE"***REMOVED******REMOVED***
    request.META["CSRF_COOKIE_USED"***REMOVED*** = True
    return _salt_cipher_secret(csrf_secret***REMOVED***


def rotate_token(request***REMOVED***:
    ***REMOVED***
    Changes the CSRF token in use for a request - should be done on login
    for security purposes.
    ***REMOVED***
    request.META.update({
        "CSRF_COOKIE_USED": True,
        "CSRF_COOKIE": _get_new_csrf_token(***REMOVED***,
***REMOVED******REMOVED***
    request.csrf_cookie_needs_reset = True


def _sanitize_token(token***REMOVED***:
    # Allow only ASCII alphanumerics
    if re.search('[^a-zA-Z0-9***REMOVED***', force_text(token***REMOVED******REMOVED***:
        return _get_new_csrf_token(***REMOVED***
    elif len(token***REMOVED*** == CSRF_TOKEN_LENGTH:
        return token
    elif len(token***REMOVED*** == CSRF_SECRET_LENGTH:
        # Older Django versions set cookies to values of CSRF_SECRET_LENGTH
        # alphanumeric characters. For backwards compatibility, accept
        # such values as unsalted secrets.
        # It's easier to salt here and be consistent later, rather than add
        # different code paths in the checks, although that might be a tad more
        # efficient.
        return _salt_cipher_secret(token***REMOVED***
    return _get_new_csrf_token(***REMOVED***


def _compare_salted_tokens(request_csrf_token, csrf_token***REMOVED***:
    # Assume both arguments are sanitized -- that is, strings of
    # length CSRF_TOKEN_LENGTH, all CSRF_ALLOWED_CHARS.
    return constant_time_compare(
        _unsalt_cipher_token(request_csrf_token***REMOVED***,
        _unsalt_cipher_token(csrf_token***REMOVED***,
    ***REMOVED***


class CsrfViewMiddleware(MiddlewareMixin***REMOVED***:
    ***REMOVED***
    Middleware that requires a present and correct csrfmiddlewaretoken
    for POST requests that have a CSRF cookie, and sets an outgoing
    CSRF cookie.

    This middleware should be used in conjunction with the csrf_token template
    tag.
    ***REMOVED***
    # The _accept and _reject methods currently only exist for the sake of the
    # requires_csrf_token decorator.
    def _accept(self, request***REMOVED***:
        # Avoid checking the request twice by adding a custom attribute to
        # request.  This will be relevant when both decorator and middleware
        # are used.
        request.csrf_processing_done = True
        return None

    def _reject(self, request, reason***REMOVED***:
        logger.warning(
            'Forbidden (%s***REMOVED***: %s', reason, request.path,
            extra={
                'status_code': 403,
                'request': request,
        ***REMOVED***
        ***REMOVED***
        return _get_failure_view(***REMOVED***(request, reason=reason***REMOVED***

    def process_view(self, request, callback, callback_args, callback_kwargs***REMOVED***:
        if getattr(request, 'csrf_processing_done', False***REMOVED***:
            return None

        ***REMOVED***
            cookie_token = request.COOKIES[settings.CSRF_COOKIE_NAME***REMOVED***
        except KeyError:
            csrf_token = None
        else:
            csrf_token = _sanitize_token(cookie_token***REMOVED***
            if csrf_token != cookie_token:
                # Cookie token needed to be replaced;
                # the cookie needs to be reset.
                request.csrf_cookie_needs_reset = True
            # Use same token next time.
            request.META['CSRF_COOKIE'***REMOVED*** = csrf_token

        # Wait until request.META["CSRF_COOKIE"***REMOVED*** has been manipulated before
        # bailing out, so that get_token still works
        if getattr(callback, 'csrf_exempt', False***REMOVED***:
            return None

        # Assume that anything not defined as 'safe' by RFC7231 needs protection
        if request.method not in ('GET', 'HEAD', 'OPTIONS', 'TRACE'***REMOVED***:
            if getattr(request, '_dont_enforce_csrf_checks', False***REMOVED***:
                # Mechanism to turn off CSRF checks for test suite.
                # It comes after the creation of CSRF cookies, so that
                # everything else continues to work exactly the same
                # (e.g. cookies are sent, etc.***REMOVED***, but before any
                # branches that call reject(***REMOVED***.
                return self._accept(request***REMOVED***

            if request.is_secure(***REMOVED***:
                # Suppose user visits http://example.com/
                # An active network attacker (man-in-the-middle, MITM***REMOVED*** sends a
                # POST form that targets https://example.com/detonate-bomb/ and
                # submits it via JavaScript.
                #
                # The attacker will need to provide a CSRF cookie and token, but
                # that's no problem for a MITM and the session-independent
                # secret we're using. So the MITM can circumvent the CSRF
                # protection. This is true for any HTTP connection, but anyone
                # using HTTPS expects better! For this reason, for
                # https://example.com/ we need additional protection that treats
                # http://example.com/ as completely untrusted. Under HTTPS,
                # Barth et al. found that the Referer header is missing for
                # same-domain requests in only about 0.2% of cases or less, so
                # we can use strict Referer checking.
                referer = force_text(
                    request.META.get('HTTP_REFERER'***REMOVED***,
                    strings_only=True,
                    errors='replace'
                ***REMOVED***
                if referer is None:
                    return self._reject(request, REASON_NO_REFERER***REMOVED***

                referer = urlparse(referer***REMOVED***

                # Make sure we have a valid URL for Referer.
                if '' in (referer.scheme, referer.netloc***REMOVED***:
                    return self._reject(request, REASON_MALFORMED_REFERER***REMOVED***

                # Ensure that our Referer is also secure.
                if referer.scheme != 'https':
                    return self._reject(request, REASON_INSECURE_REFERER***REMOVED***

                # If there isn't a CSRF_COOKIE_DOMAIN, assume we need an exact
                # match on host:port. If not, obey the cookie rules.
                if settings.CSRF_COOKIE_DOMAIN is None:
                    # request.get_host(***REMOVED*** includes the port.
                    good_referer = request.get_host(***REMOVED***
                else:
                    good_referer = settings.CSRF_COOKIE_DOMAIN
                    server_port = request.get_port(***REMOVED***
                    if server_port not in ('443', '80'***REMOVED***:
                        good_referer = '%s:%s' % (good_referer, server_port***REMOVED***

                # Here we generate a list of all acceptable HTTP referers,
                # including the current host since that has been validated
                # upstream.
                good_hosts = list(settings.CSRF_TRUSTED_ORIGINS***REMOVED***
                good_hosts.append(good_referer***REMOVED***

                if not any(is_same_domain(referer.netloc, host***REMOVED*** for host in good_hosts***REMOVED***:
                    reason = REASON_BAD_REFERER % referer.geturl(***REMOVED***
                    return self._reject(request, reason***REMOVED***

            if csrf_token is None:
                # No CSRF cookie. For POST requests, we insist on a CSRF cookie,
                # and in this way we can avoid all CSRF attacks, including login
                # CSRF.
                return self._reject(request, REASON_NO_CSRF_COOKIE***REMOVED***

            # Check non-cookie token for match.
            request_csrf_token = ""
            if request.method == "POST":
                ***REMOVED***
                    request_csrf_token = request.POST.get('csrfmiddlewaretoken', ''***REMOVED***
                except IOError:
                    # Handle a broken connection before we've completed reading
                    # the POST data. process_view shouldn't raise any
                    # exceptions, so we'll ignore and serve the user a 403
                    # (assuming they're still listening, which they probably
                    # aren't because of the error***REMOVED***.
                    pass

            if request_csrf_token == "":
                # Fall back to X-CSRFToken, to make things easier for AJAX,
                # and possible for PUT/DELETE.
                request_csrf_token = request.META.get(settings.CSRF_HEADER_NAME, ''***REMOVED***

            request_csrf_token = _sanitize_token(request_csrf_token***REMOVED***
            if not _compare_salted_tokens(request_csrf_token, csrf_token***REMOVED***:
                return self._reject(request, REASON_BAD_TOKEN***REMOVED***

        return self._accept(request***REMOVED***

    def process_response(self, request, response***REMOVED***:
        if not getattr(request, 'csrf_cookie_needs_reset', False***REMOVED***:
            if getattr(response, 'csrf_cookie_set', False***REMOVED***:
                return response

        if not request.META.get("CSRF_COOKIE_USED", False***REMOVED***:
            return response

        # Set the CSRF cookie even if it's already set, so we renew
        # the expiry timer.
        response.set_cookie(settings.CSRF_COOKIE_NAME,
                            request.META["CSRF_COOKIE"***REMOVED***,
                            max_age=settings.CSRF_COOKIE_AGE,
                            domain=settings.CSRF_COOKIE_DOMAIN,
                            path=settings.CSRF_COOKIE_PATH,
                            secure=settings.CSRF_COOKIE_SECURE,
                            httponly=settings.CSRF_COOKIE_HTTPONLY
                            ***REMOVED***
        # Content varies with the CSRF cookie, so set the Vary header.
        patch_vary_headers(response, ('Cookie',***REMOVED******REMOVED***
        response.csrf_cookie_set = True
        return response
