***REMOVED***
Accessors for related objects.

When a field defines a relation between two models, each model class provides
an attribute to access related instances of the other model class (unless the
reverse accessor has been disabled with related_name='+'***REMOVED***.

Accessors are implemented as descriptors in order to customize access and
assignment. This module defines the descriptor classes.

Forward accessors follow foreign keys. Reverse accessors trace them back. For
example, with the following models::

    class Parent(Model***REMOVED***:
        pass

    class Child(Model***REMOVED***:
        parent = ForeignKey(Parent, related_name='children'***REMOVED***

 ``child.parent`` is a forward many-to-one relation. ``parent.children`` is a
reverse many-to-one relation.

There are three types of relations (many-to-one, one-to-one, and many-to-many***REMOVED***
and two directions (forward and reverse***REMOVED*** for a total of six combinations.

1. Related instance on the forward side of a many-to-one or one-to-one
   relation: ``ForwardManyToOneDescriptor``.

   Uniqueness of foreign key values is irrelevant to accessing the related
   instance, making the many-to-one and one-to-one cases identical as far as
   the descriptor is concerned. The constraint is checked upstream (unicity
   validation in forms***REMOVED*** or downstream (unique indexes in the database***REMOVED***.

   If you're looking for ``ForwardOneToOneDescriptor``, use
   ``ForwardManyToOneDescriptor`` instead.

2. Related instance on the reverse side of a one-to-one relation:
   ``ReverseOneToOneDescriptor``.

   One-to-one relations are asymmetrical, despite the apparent symmetry of the
   name, because they're implemented in the database with a foreign key from
   one table to another. As a consequence ``ReverseOneToOneDescriptor`` is
   slightly different from ``ForwardManyToOneDescriptor``.

3. Related objects manager for related instances on the reverse side of a
   many-to-one relation: ``ReverseManyToOneDescriptor``.

   Unlike the previous two classes, this one provides access to a collection
   of objects. It returns a manager rather than an instance.

4. Related objects manager for related instances on the forward or reverse
   sides of a many-to-many relation: ``ManyToManyDescriptor``.

   Many-to-many relations are symmetrical. The syntax of Django models
   requires declaring them on one side but that's an implementation detail.
   They could be declared on the other side without any change in behavior.
   Therefore the forward and reverse descriptors can be the same.

   If you're looking for ``ForwardManyToManyDescriptor`` or
   ``ReverseManyToManyDescriptor``, use ``ManyToManyDescriptor`` instead.
***REMOVED***

from __future__ import unicode_literals

import warnings
from operator import attrgetter

from django.db import connections, router, transaction
from django.db.models import Q, signals
from django.db.models.query import QuerySet
from django.utils.deprecation import RemovedInDjango20Warning
from django.utils.functional import cached_property


class ForwardManyToOneDescriptor(object***REMOVED***:
    ***REMOVED***
    Accessor to the related object on the forward side of a many-to-one or
    one-to-one relation.

    In the example::

        class Child(Model***REMOVED***:
            parent = ForeignKey(Parent, related_name='children'***REMOVED***

    ``child.parent`` is a ``ForwardManyToOneDescriptor`` instance.
    ***REMOVED***

    def __init__(self, field_with_rel***REMOVED***:
        self.field = field_with_rel
        self.cache_name = self.field.get_cache_name(***REMOVED***

    @cached_property
    def RelatedObjectDoesNotExist(self***REMOVED***:
        # The exception can't be created at initialization time since the
        # related model might not be resolved yet; `rel.model` might still be
        # a string model reference.
        return type(
            str('RelatedObjectDoesNotExist'***REMOVED***,
            (self.field.remote_field.model.DoesNotExist, AttributeError***REMOVED***,
        ***REMOVED******REMOVED***
        ***REMOVED***

    def is_cached(self, instance***REMOVED***:
        return hasattr(instance, self.cache_name***REMOVED***

    def get_queryset(self, **hints***REMOVED***:
        related_model = self.field.remote_field.model

        if getattr(related_model._default_manager, 'use_for_related_fields', False***REMOVED***:
            if not getattr(related_model._default_manager, 'silence_use_for_related_fields_deprecation', False***REMOVED***:
                warnings.warn(
                    "use_for_related_fields is deprecated, instead "
                    "set Meta.base_manager_name on '{***REMOVED***'.".format(related_model._meta.label***REMOVED***,
                    RemovedInDjango20Warning, 2
                ***REMOVED***
            manager = related_model._default_manager
        else:
            manager = related_model._base_manager

        return manager.db_manager(hints=hints***REMOVED***.all(***REMOVED***

    def get_prefetch_queryset(self, instances, queryset=None***REMOVED***:
        if queryset is None:
            queryset = self.get_queryset(***REMOVED***
        queryset._add_hints(instance=instances[0***REMOVED******REMOVED***

        rel_obj_attr = self.field.get_foreign_related_value
        instance_attr = self.field.get_local_related_value
        instances_dict = {instance_attr(inst***REMOVED***: inst for inst in instances***REMOVED***
        related_field = self.field.foreign_related_fields[0***REMOVED***

        # FIXME: This will need to be revisited when we introduce support for
        # composite fields. In the meantime we take this practical approach to
        # solve a regression on 1.6 when the reverse manager in hidden
        # (related_name ends with a '+'***REMOVED***. Refs #21410.
        # The check for len(...***REMOVED*** == 1 is a special case that allows the query
        # to be join-less and smaller. Refs #21760.
        if self.field.remote_field.is_hidden(***REMOVED*** or len(self.field.foreign_related_fields***REMOVED*** == 1:
            query = {'%s__in' % related_field.name: set(instance_attr(inst***REMOVED***[0***REMOVED*** for inst in instances***REMOVED******REMOVED***
        else:
            query = {'%s__in' % self.field.related_query_name(***REMOVED***: instances***REMOVED***
        queryset = queryset.filter(**query***REMOVED***

        # Since we're going to assign directly in the cache,
        # we must manage the reverse relation cache manually.
        if not self.field.remote_field.multiple:
            rel_obj_cache_name = self.field.remote_field.get_cache_name(***REMOVED***
            for rel_obj in queryset:
                instance = instances_dict[rel_obj_attr(rel_obj***REMOVED******REMOVED***
                setattr(rel_obj, rel_obj_cache_name, instance***REMOVED***
        return queryset, rel_obj_attr, instance_attr, True, self.cache_name

    def __get__(self, instance, cls=None***REMOVED***:
        ***REMOVED***
        Get the related instance through the forward relation.

        With the example above, when getting ``child.parent``:

        - ``self`` is the descriptor managing the ``parent`` attribute
        - ``instance`` is the ``child`` instance
        - ``cls`` is the ``Child`` class (we don't need it***REMOVED***
        ***REMOVED***
        if instance is None:
            return self

        # The related instance is loaded from the database and then cached in
        # the attribute defined in self.cache_name. It can also be pre-cached
        # by the reverse accessor (ReverseOneToOneDescriptor***REMOVED***.
        ***REMOVED***
            rel_obj = getattr(instance, self.cache_name***REMOVED***
        except AttributeError:
            val = self.field.get_local_related_value(instance***REMOVED***
            if None in val:
                rel_obj = None
            else:
                qs = self.get_queryset(instance=instance***REMOVED***
                qs = qs.filter(self.field.get_reverse_related_filter(instance***REMOVED******REMOVED***
                # Assuming the database enforces foreign keys, this won't fail.
                rel_obj = qs.get(***REMOVED***
                # If this is a one-to-one relation, set the reverse accessor
                # cache on the related object to the current instance to avoid
                # an extra SQL query if it's accessed later on.
                if not self.field.remote_field.multiple:
                    setattr(rel_obj, self.field.remote_field.get_cache_name(***REMOVED***, instance***REMOVED***
            setattr(instance, self.cache_name, rel_obj***REMOVED***

        if rel_obj is None and not self.field.null:
            raise self.RelatedObjectDoesNotExist(
                "%s has no %s." % (self.field.model.__name__, self.field.name***REMOVED***
            ***REMOVED***
        else:
            return rel_obj

    def __set__(self, instance, value***REMOVED***:
        ***REMOVED***
        Set the related instance through the forward relation.

        With the example above, when setting ``child.parent = parent``:

        - ``self`` is the descriptor managing the ``parent`` attribute
        - ``instance`` is the ``child`` instance
        - ``value`` is the ``parent`` instance on the right of the equal sign
        ***REMOVED***
        # An object must be an instance of the related class.
        if value is not None and not isinstance(value, self.field.remote_field.model._meta.concrete_model***REMOVED***:
            raise ValueError(
                'Cannot assign "%r": "%s.%s" must be a "%s" instance.' % (
                    value,
                    instance._meta.object_name,
                    self.field.name,
                    self.field.remote_field.model._meta.object_name,
                ***REMOVED***
            ***REMOVED***
        elif value is not None:
            if instance._state.db is None:
                instance._state.db = router.db_for_write(instance.__class__, instance=value***REMOVED***
            elif value._state.db is None:
                value._state.db = router.db_for_write(value.__class__, instance=instance***REMOVED***
            elif value._state.db is not None and instance._state.db is not None:
                if not router.allow_relation(value, instance***REMOVED***:
                    raise ValueError('Cannot assign "%r": the current database router prevents this relation.' % value***REMOVED***

        # If we're setting the value of a OneToOneField to None, we need to clear
        # out the cache on any old related object. Otherwise, deleting the
        # previously-related object will also cause this object to be deleted,
        # which is wrong.
        if value is None:
            # Look up the previously-related object, which may still be available
            # since we've not yet cleared out the related field.
            # Use the cache directly, instead of the accessor; if we haven't
            # populated the cache, then we don't care - we're only accessing
            # the object to invalidate the accessor cache, so there's no
            # need to populate the cache just to expire it again.
            related = getattr(instance, self.cache_name, None***REMOVED***

            # If we've got an old related object, we need to clear out its
            # cache. This cache also might not exist if the related object
            # hasn't been accessed yet.
            if related is not None:
                setattr(related, self.field.remote_field.get_cache_name(***REMOVED***, None***REMOVED***

            for lh_field, rh_field in self.field.related_fields:
                setattr(instance, lh_field.attname, None***REMOVED***

        # Set the values of the related field.
        else:
            for lh_field, rh_field in self.field.related_fields:
                setattr(instance, lh_field.attname, getattr(value, rh_field.attname***REMOVED******REMOVED***

        # Set the related instance cache used by __get__ to avoid an SQL query
        # when accessing the attribute we just set.
        setattr(instance, self.cache_name, value***REMOVED***

        # If this is a one-to-one relation, set the reverse accessor cache on
        # the related object to the current instance to avoid an extra SQL
        # query if it's accessed later on.
        if value is not None and not self.field.remote_field.multiple:
            setattr(value, self.field.remote_field.get_cache_name(***REMOVED***, instance***REMOVED***


class ReverseOneToOneDescriptor(object***REMOVED***:
    ***REMOVED***
    Accessor to the related object on the reverse side of a one-to-one
    relation.

    In the example::

        class Restaurant(Model***REMOVED***:
            place = OneToOneField(Place, related_name='restaurant'***REMOVED***

    ``place.restaurant`` is a ``ReverseOneToOneDescriptor`` instance.
    ***REMOVED***

    def __init__(self, related***REMOVED***:
        self.related = related
        self.cache_name = related.get_cache_name(***REMOVED***

    @cached_property
    def RelatedObjectDoesNotExist(self***REMOVED***:
        # The exception isn't created at initialization time for the sake of
        # consistency with `ForwardManyToOneDescriptor`.
        return type(
            str('RelatedObjectDoesNotExist'***REMOVED***,
            (self.related.related_model.DoesNotExist, AttributeError***REMOVED***,
        ***REMOVED******REMOVED***
        ***REMOVED***

    def is_cached(self, instance***REMOVED***:
        return hasattr(instance, self.cache_name***REMOVED***

    def get_queryset(self, **hints***REMOVED***:
        related_model = self.related.related_model

        if getattr(related_model._default_manager, 'use_for_related_fields', False***REMOVED***:
            if not getattr(related_model._default_manager, 'silence_use_for_related_fields_deprecation', False***REMOVED***:
                warnings.warn(
                    "use_for_related_fields is deprecated, instead "
                    "set Meta.base_manager_name on '{***REMOVED***'.".format(related_model._meta.label***REMOVED***,
                    RemovedInDjango20Warning, 2
                ***REMOVED***
            manager = related_model._default_manager
        else:
            manager = related_model._base_manager

        return manager.db_manager(hints=hints***REMOVED***.all(***REMOVED***

    def get_prefetch_queryset(self, instances, queryset=None***REMOVED***:
        if queryset is None:
            queryset = self.get_queryset(***REMOVED***
        queryset._add_hints(instance=instances[0***REMOVED******REMOVED***

        rel_obj_attr = attrgetter(self.related.field.attname***REMOVED***

        def instance_attr(obj***REMOVED***:
            return obj._get_pk_val(***REMOVED***

        instances_dict = {instance_attr(inst***REMOVED***: inst for inst in instances***REMOVED***
        query = {'%s__in' % self.related.field.name: instances***REMOVED***
        queryset = queryset.filter(**query***REMOVED***

        # Since we're going to assign directly in the cache,
        # we must manage the reverse relation cache manually.
        rel_obj_cache_name = self.related.field.get_cache_name(***REMOVED***
        for rel_obj in queryset:
            instance = instances_dict[rel_obj_attr(rel_obj***REMOVED******REMOVED***
            setattr(rel_obj, rel_obj_cache_name, instance***REMOVED***
        return queryset, rel_obj_attr, instance_attr, True, self.cache_name

    def __get__(self, instance, cls=None***REMOVED***:
        ***REMOVED***
        Get the related instance through the reverse relation.

        With the example above, when getting ``place.restaurant``:

        - ``self`` is the descriptor managing the ``restaurant`` attribute
        - ``instance`` is the ``place`` instance
        - ``cls`` is the ``Place`` class (unused***REMOVED***

        Keep in mind that ``Restaurant`` holds the foreign key to ``Place``.
        ***REMOVED***
        if instance is None:
            return self

        # The related instance is loaded from the database and then cached in
        # the attribute defined in self.cache_name. It can also be pre-cached
        # by the forward accessor (ForwardManyToOneDescriptor***REMOVED***.
        ***REMOVED***
            rel_obj = getattr(instance, self.cache_name***REMOVED***
        except AttributeError:
            related_pk = instance._get_pk_val(***REMOVED***
            if related_pk is None:
                rel_obj = None
            else:
                filter_args = self.related.field.get_forward_related_filter(instance***REMOVED***
                ***REMOVED***
                    rel_obj = self.get_queryset(instance=instance***REMOVED***.get(**filter_args***REMOVED***
                except self.related.related_model.DoesNotExist:
                    rel_obj = None
                else:
                    # Set the forward accessor cache on the related object to
                    # the current instance to avoid an extra SQL query if it's
                    # accessed later on.
                    setattr(rel_obj, self.related.field.get_cache_name(***REMOVED***, instance***REMOVED***
            setattr(instance, self.cache_name, rel_obj***REMOVED***

        if rel_obj is None:
            raise self.RelatedObjectDoesNotExist(
                "%s has no %s." % (
                    instance.__class__.__name__,
                    self.related.get_accessor_name(***REMOVED***
                ***REMOVED***
            ***REMOVED***
        else:
            return rel_obj

    def __set__(self, instance, value***REMOVED***:
        ***REMOVED***
        Set the related instance through the reverse relation.

        With the example above, when setting ``place.restaurant = restaurant``:

        - ``self`` is the descriptor managing the ``restaurant`` attribute
        - ``instance`` is the ``place`` instance
        - ``value`` is the ``restaurant`` instance on the right of the equal sign

        Keep in mind that ``Restaurant`` holds the foreign key to ``Place``.
        ***REMOVED***
        # The similarity of the code below to the code in
        # ForwardManyToOneDescriptor is annoying, but there's a bunch
        # of small differences that would make a common base class convoluted.

        if value is None:
            # Update the cached related instance (if any***REMOVED*** & clear the cache.
            ***REMOVED***
                rel_obj = getattr(instance, self.cache_name***REMOVED***
            except AttributeError:
                pass
            else:
                delattr(instance, self.cache_name***REMOVED***
                setattr(rel_obj, self.related.field.name, None***REMOVED***
        elif not isinstance(value, self.related.related_model***REMOVED***:
            # An object must be an instance of the related class.
            raise ValueError(
                'Cannot assign "%r": "%s.%s" must be a "%s" instance.' % (
                    value,
                    instance._meta.object_name,
                    self.related.get_accessor_name(***REMOVED***,
                    self.related.related_model._meta.object_name,
                ***REMOVED***
            ***REMOVED***
        else:
            if instance._state.db is None:
                instance._state.db = router.db_for_write(instance.__class__, instance=value***REMOVED***
            elif value._state.db is None:
                value._state.db = router.db_for_write(value.__class__, instance=instance***REMOVED***
            elif value._state.db is not None and instance._state.db is not None:
                if not router.allow_relation(value, instance***REMOVED***:
                    raise ValueError('Cannot assign "%r": the current database router prevents this relation.' % value***REMOVED***

            related_pk = tuple(getattr(instance, field.attname***REMOVED*** for field in self.related.field.foreign_related_fields***REMOVED***
            # Set the value of the related field to the value of the related object's related field
            for index, field in enumerate(self.related.field.local_related_fields***REMOVED***:
                setattr(value, field.attname, related_pk[index***REMOVED******REMOVED***

            # Set the related instance cache used by __get__ to avoid an SQL query
            # when accessing the attribute we just set.
            setattr(instance, self.cache_name, value***REMOVED***

            # Set the forward accessor cache on the related object to the current
            # instance to avoid an extra SQL query if it's accessed later on.
            setattr(value, self.related.field.get_cache_name(***REMOVED***, instance***REMOVED***


class ReverseManyToOneDescriptor(object***REMOVED***:
    ***REMOVED***
    Accessor to the related objects manager on the reverse side of a
    many-to-one relation.

    In the example::

        class Child(Model***REMOVED***:
            parent = ForeignKey(Parent, related_name='children'***REMOVED***

    ``parent.children`` is a ``ReverseManyToOneDescriptor`` instance.

    Most of the implementation is delegated to a dynamically defined manager
    class built by ``create_forward_many_to_many_manager(***REMOVED***`` defined below.
    ***REMOVED***

    def __init__(self, rel***REMOVED***:
        self.rel = rel
        self.field = rel.field

    @cached_property
    def related_manager_cls(self***REMOVED***:
        related_model = self.rel.related_model

        return create_reverse_many_to_one_manager(
            related_model._default_manager.__class__,
            self.rel,
        ***REMOVED***

    def __get__(self, instance, cls=None***REMOVED***:
        ***REMOVED***
        Get the related objects through the reverse relation.

        With the example above, when getting ``parent.children``:

        - ``self`` is the descriptor managing the ``children`` attribute
        - ``instance`` is the ``parent`` instance
        - ``cls`` is the ``Parent`` class (unused***REMOVED***
        ***REMOVED***
        if instance is None:
            return self

        return self.related_manager_cls(instance***REMOVED***

    def _get_set_deprecation_msg_params(self***REMOVED***:
        return (  # RemovedInDjango20Warning
            'reverse side of a related set',
            self.rel.get_accessor_name(***REMOVED***,
        ***REMOVED***

    def __set__(self, instance, value***REMOVED***:
        ***REMOVED***
        Set the related objects through the reverse relation.

        With the example above, when setting ``parent.children = children``:

        - ``self`` is the descriptor managing the ``children`` attribute
        - ``instance`` is the ``parent`` instance
        - ``value`` is the ``children`` sequence on the right of the equal sign
        ***REMOVED***
        warnings.warn(
            'Direct assignment to the %s is deprecated due to the implicit '
            'save(***REMOVED*** that happens. Use %s.set(***REMOVED*** instead.' % self._get_set_deprecation_msg_params(***REMOVED***,
            RemovedInDjango20Warning, stacklevel=2,
        ***REMOVED***
        manager = self.__get__(instance***REMOVED***
        manager.set(value***REMOVED***


def create_reverse_many_to_one_manager(superclass, rel***REMOVED***:
    ***REMOVED***
    Create a manager for the reverse side of a many-to-one relation.

    This manager subclasses another manager, generally the default manager of
    the related model, and adds behaviors specific to many-to-one relations.
    ***REMOVED***

    class RelatedManager(superclass***REMOVED***:
        def __init__(self, instance***REMOVED***:
            super(RelatedManager, self***REMOVED***.__init__(***REMOVED***

            self.instance = instance
            self.model = rel.related_model
            self.field = rel.field

            self.core_filters = {self.field.name: instance***REMOVED***

        def __call__(self, **kwargs***REMOVED***:
            # We use **kwargs rather than a kwarg argument to enforce the
            # `manager='manager_name'` syntax.
            manager = getattr(self.model, kwargs.pop('manager'***REMOVED******REMOVED***
            manager_class = create_reverse_many_to_one_manager(manager.__class__, rel***REMOVED***
            return manager_class(self.instance***REMOVED***
        do_not_call_in_templates = True

        def _apply_rel_filters(self, queryset***REMOVED***:
            ***REMOVED***
            Filter the queryset for the instance this manager is bound to.
            ***REMOVED***
            db = self._db or router.db_for_read(self.model, instance=self.instance***REMOVED***
            empty_strings_as_null = connections[db***REMOVED***.features.interprets_empty_strings_as_nulls
            queryset._add_hints(instance=self.instance***REMOVED***
            if self._db:
                queryset = queryset.using(self._db***REMOVED***
            queryset = queryset.filter(**self.core_filters***REMOVED***
            for field in self.field.foreign_related_fields:
                val = getattr(self.instance, field.attname***REMOVED***
                if val is None or (val == '' and empty_strings_as_null***REMOVED***:
                    return queryset.none(***REMOVED***
            queryset._known_related_objects = {self.field: {self.instance.pk: self.instance***REMOVED******REMOVED***
            return queryset

        def get_queryset(self***REMOVED***:
            ***REMOVED***
                return self.instance._prefetched_objects_cache[self.field.related_query_name(***REMOVED******REMOVED***
            except (AttributeError, KeyError***REMOVED***:
                queryset = super(RelatedManager, self***REMOVED***.get_queryset(***REMOVED***
                return self._apply_rel_filters(queryset***REMOVED***

        def get_prefetch_queryset(self, instances, queryset=None***REMOVED***:
            if queryset is None:
                queryset = super(RelatedManager, self***REMOVED***.get_queryset(***REMOVED***

            queryset._add_hints(instance=instances[0***REMOVED******REMOVED***
            queryset = queryset.using(queryset._db or self._db***REMOVED***

            rel_obj_attr = self.field.get_local_related_value
            instance_attr = self.field.get_foreign_related_value
            instances_dict = {instance_attr(inst***REMOVED***: inst for inst in instances***REMOVED***
            query = {'%s__in' % self.field.name: instances***REMOVED***
            queryset = queryset.filter(**query***REMOVED***

            # Since we just bypassed this class' get_queryset(***REMOVED***, we must manage
            # the reverse relation manually.
            for rel_obj in queryset:
                instance = instances_dict[rel_obj_attr(rel_obj***REMOVED******REMOVED***
                setattr(rel_obj, self.field.name, instance***REMOVED***
            cache_name = self.field.related_query_name(***REMOVED***
            return queryset, rel_obj_attr, instance_attr, False, cache_name

        def add(self, *objs, **kwargs***REMOVED***:
            bulk = kwargs.pop('bulk', True***REMOVED***
            objs = list(objs***REMOVED***
            db = router.db_for_write(self.model, instance=self.instance***REMOVED***

            def check_and_update_obj(obj***REMOVED***:
                if not isinstance(obj, self.model***REMOVED***:
                    raise TypeError("'%s' instance expected, got %r" % (
                        self.model._meta.object_name, obj,
                    ***REMOVED******REMOVED***
                setattr(obj, self.field.name, self.instance***REMOVED***

            if bulk:
                pks = [***REMOVED***
                for obj in objs:
                    check_and_update_obj(obj***REMOVED***
                    if obj._state.adding or obj._state.db != db:
                        raise ValueError(
                            "%r instance isn't saved. Use bulk=False or save "
                            "the object first." % obj
                        ***REMOVED***
                    pks.append(obj.pk***REMOVED***
                self.model._base_manager.using(db***REMOVED***.filter(pk__in=pks***REMOVED***.update(**{
                    self.field.name: self.instance,
            ***REMOVED******REMOVED***
            else:
                with transaction.atomic(using=db, savepoint=False***REMOVED***:
                    for obj in objs:
                        check_and_update_obj(obj***REMOVED***
                        obj.save(***REMOVED***
        add.alters_data = True

        def create(self, **kwargs***REMOVED***:
            kwargs[self.field.name***REMOVED*** = self.instance
            db = router.db_for_write(self.model, instance=self.instance***REMOVED***
            return super(RelatedManager, self.db_manager(db***REMOVED******REMOVED***.create(**kwargs***REMOVED***
        create.alters_data = True

        def get_or_create(self, **kwargs***REMOVED***:
            kwargs[self.field.name***REMOVED*** = self.instance
            db = router.db_for_write(self.model, instance=self.instance***REMOVED***
            return super(RelatedManager, self.db_manager(db***REMOVED******REMOVED***.get_or_create(**kwargs***REMOVED***
        get_or_create.alters_data = True

        def update_or_create(self, **kwargs***REMOVED***:
            kwargs[self.field.name***REMOVED*** = self.instance
            db = router.db_for_write(self.model, instance=self.instance***REMOVED***
            return super(RelatedManager, self.db_manager(db***REMOVED******REMOVED***.update_or_create(**kwargs***REMOVED***
        update_or_create.alters_data = True

        # remove(***REMOVED*** and clear(***REMOVED*** are only provided if the ForeignKey can have a value of null.
        if rel.field.null:
            def remove(self, *objs, **kwargs***REMOVED***:
                if not objs:
                    return
                bulk = kwargs.pop('bulk', True***REMOVED***
                val = self.field.get_foreign_related_value(self.instance***REMOVED***
                old_ids = set(***REMOVED***
                for obj in objs:
                    # Is obj actually part of this descriptor set?
                    if self.field.get_local_related_value(obj***REMOVED*** == val:
                        old_ids.add(obj.pk***REMOVED***
                    else:
                        raise self.field.remote_field.model.DoesNotExist(
                            "%r is not related to %r." % (obj, self.instance***REMOVED***
                        ***REMOVED***
                self._clear(self.filter(pk__in=old_ids***REMOVED***, bulk***REMOVED***
            remove.alters_data = True

            def clear(self, **kwargs***REMOVED***:
                bulk = kwargs.pop('bulk', True***REMOVED***
                self._clear(self, bulk***REMOVED***
            clear.alters_data = True

            def _clear(self, queryset, bulk***REMOVED***:
                db = router.db_for_write(self.model, instance=self.instance***REMOVED***
                queryset = queryset.using(db***REMOVED***
                if bulk:
                    # `QuerySet.update(***REMOVED***` is intrinsically atomic.
                    queryset.update(**{self.field.name: None***REMOVED******REMOVED***
                else:
                    with transaction.atomic(using=db, savepoint=False***REMOVED***:
                        for obj in queryset:
                            setattr(obj, self.field.name, None***REMOVED***
                            obj.save(update_fields=[self.field.name***REMOVED******REMOVED***
            _clear.alters_data = True

        def set(self, objs, **kwargs***REMOVED***:
            # Force evaluation of `objs` in case it's a queryset whose value
            # could be affected by `manager.clear(***REMOVED***`. Refs #19816.
            objs = tuple(objs***REMOVED***

            bulk = kwargs.pop('bulk', True***REMOVED***
            clear = kwargs.pop('clear', False***REMOVED***

            if self.field.null:
                db = router.db_for_write(self.model, instance=self.instance***REMOVED***
                with transaction.atomic(using=db, savepoint=False***REMOVED***:
                    if clear:
                        self.clear(***REMOVED***
                        self.add(*objs, bulk=bulk***REMOVED***
                    else:
                        old_objs = set(self.using(db***REMOVED***.all(***REMOVED******REMOVED***
                        new_objs = [***REMOVED***
                        for obj in objs:
                            if obj in old_objs:
                                old_objs.remove(obj***REMOVED***
                            else:
                                new_objs.append(obj***REMOVED***

                        self.remove(*old_objs, bulk=bulk***REMOVED***
                        self.add(*new_objs, bulk=bulk***REMOVED***
            else:
                self.add(*objs, bulk=bulk***REMOVED***
        set.alters_data = True

    return RelatedManager


class ManyToManyDescriptor(ReverseManyToOneDescriptor***REMOVED***:
    ***REMOVED***
    Accessor to the related objects manager on the forward and reverse sides of
    a many-to-many relation.

    In the example::

        class Pizza(Model***REMOVED***:
            toppings = ManyToManyField(Topping, related_name='pizzas'***REMOVED***

    ``pizza.toppings`` and ``topping.pizzas`` are ``ManyToManyDescriptor``
    instances.

    Most of the implementation is delegated to a dynamically defined manager
    class built by ``create_forward_many_to_many_manager(***REMOVED***`` defined below.
    ***REMOVED***

    def __init__(self, rel, reverse=False***REMOVED***:
        super(ManyToManyDescriptor, self***REMOVED***.__init__(rel***REMOVED***

        self.reverse = reverse

    @property
    def through(self***REMOVED***:
        # through is provided so that you have easy access to the through
        # model (Book.authors.through***REMOVED*** for inlines, etc. This is done as
        # a property to ensure that the fully resolved value is returned.
        return self.rel.through

    @cached_property
    def related_manager_cls(self***REMOVED***:
        related_model = self.rel.related_model if self.reverse else self.rel.model

        return create_forward_many_to_many_manager(
            related_model._default_manager.__class__,
            self.rel,
            reverse=self.reverse,
        ***REMOVED***

    def _get_set_deprecation_msg_params(self***REMOVED***:
        return (  # RemovedInDjango20Warning
            '%s side of a many-to-many set' % ('reverse' if self.reverse else 'forward'***REMOVED***,
            self.rel.get_accessor_name(***REMOVED*** if self.reverse else self.field.name,
        ***REMOVED***


def create_forward_many_to_many_manager(superclass, rel, reverse***REMOVED***:
    ***REMOVED***
    Create a manager for the either side of a many-to-many relation.

    This manager subclasses another manager, generally the default manager of
    the related model, and adds behaviors specific to many-to-many relations.
    ***REMOVED***

    class ManyRelatedManager(superclass***REMOVED***:
        def __init__(self, instance=None***REMOVED***:
            super(ManyRelatedManager, self***REMOVED***.__init__(***REMOVED***

            self.instance = instance

            if not reverse:
                self.model = rel.model
                self.query_field_name = rel.field.related_query_name(***REMOVED***
                self.prefetch_cache_name = rel.field.name
                self.source_field_name = rel.field.m2m_field_name(***REMOVED***
                self.target_field_name = rel.field.m2m_reverse_field_name(***REMOVED***
                self.symmetrical = rel.symmetrical
            else:
                self.model = rel.related_model
                self.query_field_name = rel.field.name
                self.prefetch_cache_name = rel.field.related_query_name(***REMOVED***
                self.source_field_name = rel.field.m2m_reverse_field_name(***REMOVED***
                self.target_field_name = rel.field.m2m_field_name(***REMOVED***
                self.symmetrical = False

            self.through = rel.through
            self.reverse = reverse

            self.source_field = self.through._meta.get_field(self.source_field_name***REMOVED***
            self.target_field = self.through._meta.get_field(self.target_field_name***REMOVED***

            self.core_filters = {***REMOVED***
            for lh_field, rh_field in self.source_field.related_fields:
                core_filter_key = '%s__%s' % (self.query_field_name, rh_field.name***REMOVED***
                self.core_filters[core_filter_key***REMOVED*** = getattr(instance, rh_field.attname***REMOVED***

            self.related_val = self.source_field.get_foreign_related_value(instance***REMOVED***
            if None in self.related_val:
                raise ValueError('"%r" needs to have a value for field "%s" before '
                                 'this many-to-many relationship can be used.' %
                                 (instance, self.source_field_name***REMOVED******REMOVED***
            # Even if this relation is not to pk, we require still pk value.
            # The wish is that the instance has been already saved to DB,
            # although having a pk value isn't a guarantee of that.
            if instance.pk is None:
                raise ValueError("%r instance needs to have a primary key value before "
                                 "a many-to-many relationship can be used." %
                                 instance.__class__.__name__***REMOVED***

        def __call__(self, **kwargs***REMOVED***:
            # We use **kwargs rather than a kwarg argument to enforce the
            # `manager='manager_name'` syntax.
            manager = getattr(self.model, kwargs.pop('manager'***REMOVED******REMOVED***
            manager_class = create_forward_many_to_many_manager(manager.__class__, rel, reverse***REMOVED***
            return manager_class(instance=self.instance***REMOVED***
        do_not_call_in_templates = True

        def _build_remove_filters(self, removed_vals***REMOVED***:
            filters = Q(**{self.source_field_name: self.related_val***REMOVED******REMOVED***
            # No need to add a subquery condition if removed_vals is a QuerySet without
            # filters.
            removed_vals_filters = (not isinstance(removed_vals, QuerySet***REMOVED*** or
                                    removed_vals._has_filters(***REMOVED******REMOVED***
            if removed_vals_filters:
                filters &= Q(**{'%s__in' % self.target_field_name: removed_vals***REMOVED******REMOVED***
            if self.symmetrical:
                symmetrical_filters = Q(**{self.target_field_name: self.related_val***REMOVED******REMOVED***
                if removed_vals_filters:
                    symmetrical_filters &= Q(
                        **{'%s__in' % self.source_field_name: removed_vals***REMOVED******REMOVED***
                filters |= symmetrical_filters
            return filters

        def _apply_rel_filters(self, queryset***REMOVED***:
            ***REMOVED***
            Filter the queryset for the instance this manager is bound to.
            ***REMOVED***
            queryset._add_hints(instance=self.instance***REMOVED***
            if self._db:
                queryset = queryset.using(self._db***REMOVED***
            return queryset._next_is_sticky(***REMOVED***.filter(**self.core_filters***REMOVED***

        def get_queryset(self***REMOVED***:
            ***REMOVED***
                return self.instance._prefetched_objects_cache[self.prefetch_cache_name***REMOVED***
            except (AttributeError, KeyError***REMOVED***:
                queryset = super(ManyRelatedManager, self***REMOVED***.get_queryset(***REMOVED***
                return self._apply_rel_filters(queryset***REMOVED***

        def get_prefetch_queryset(self, instances, queryset=None***REMOVED***:
            if queryset is None:
                queryset = super(ManyRelatedManager, self***REMOVED***.get_queryset(***REMOVED***

            queryset._add_hints(instance=instances[0***REMOVED******REMOVED***
            queryset = queryset.using(queryset._db or self._db***REMOVED***

            query = {'%s__in' % self.query_field_name: instances***REMOVED***
            queryset = queryset._next_is_sticky(***REMOVED***.filter(**query***REMOVED***

            # M2M: need to annotate the query in order to get the primary model
            # that the secondary model was actually related to. We know that
            # there will already be a join on the join table, so we can just add
            # the select.

            # For non-autocreated 'through' models, can't assume we are
            # dealing with PK values.
            fk = self.through._meta.get_field(self.source_field_name***REMOVED***
            join_table = self.through._meta.db_table
            connection = connections[queryset.db***REMOVED***
            qn = connection.ops.quote_name
            queryset = queryset.extra(select={
                '_prefetch_related_val_%s' % f.attname:
                '%s.%s' % (qn(join_table***REMOVED***, qn(f.column***REMOVED******REMOVED*** for f in fk.local_related_fields***REMOVED******REMOVED***
            return (
                queryset,
                lambda result: tuple(
                    getattr(result, '_prefetch_related_val_%s' % f.attname***REMOVED***
                    for f in fk.local_related_fields
                ***REMOVED***,
                lambda inst: tuple(
                    f.get_db_prep_value(getattr(inst, f.attname***REMOVED***, connection***REMOVED***
                    for f in fk.foreign_related_fields
                ***REMOVED***,
                False,
                self.prefetch_cache_name,
            ***REMOVED***

        def add(self, *objs***REMOVED***:
            if not rel.through._meta.auto_created:
                opts = self.through._meta
                raise AttributeError(
                    "Cannot use add(***REMOVED*** on a ManyToManyField which specifies an "
                    "intermediary model. Use %s.%s's Manager instead." %
                    (opts.app_label, opts.object_name***REMOVED***
                ***REMOVED***

            db = router.db_for_write(self.through, instance=self.instance***REMOVED***
            with transaction.atomic(using=db, savepoint=False***REMOVED***:
                self._add_items(self.source_field_name, self.target_field_name, *objs***REMOVED***

                # If this is a symmetrical m2m relation to self, add the mirror entry in the m2m table
                if self.symmetrical:
                    self._add_items(self.target_field_name, self.source_field_name, *objs***REMOVED***
        add.alters_data = True

        def remove(self, *objs***REMOVED***:
            if not rel.through._meta.auto_created:
                opts = self.through._meta
                raise AttributeError(
                    "Cannot use remove(***REMOVED*** on a ManyToManyField which specifies "
                    "an intermediary model. Use %s.%s's Manager instead." %
                    (opts.app_label, opts.object_name***REMOVED***
                ***REMOVED***
            self._remove_items(self.source_field_name, self.target_field_name, *objs***REMOVED***
        remove.alters_data = True

        def clear(self***REMOVED***:
            db = router.db_for_write(self.through, instance=self.instance***REMOVED***
            with transaction.atomic(using=db, savepoint=False***REMOVED***:
                signals.m2m_changed.send(
                    sender=self.through, action="pre_clear",
                    instance=self.instance, reverse=self.reverse,
                    model=self.model, pk_set=None, using=db,
                ***REMOVED***
                filters = self._build_remove_filters(super(ManyRelatedManager, self***REMOVED***.get_queryset(***REMOVED***.using(db***REMOVED******REMOVED***
                self.through._default_manager.using(db***REMOVED***.filter(filters***REMOVED***.delete(***REMOVED***

                signals.m2m_changed.send(
                    sender=self.through, action="post_clear",
                    instance=self.instance, reverse=self.reverse,
                    model=self.model, pk_set=None, using=db,
                ***REMOVED***
        clear.alters_data = True

        def set(self, objs, **kwargs***REMOVED***:
            if not rel.through._meta.auto_created:
                opts = self.through._meta
                raise AttributeError(
                    "Cannot set values on a ManyToManyField which specifies an "
                    "intermediary model. Use %s.%s's Manager instead." %
                    (opts.app_label, opts.object_name***REMOVED***
                ***REMOVED***

            # Force evaluation of `objs` in case it's a queryset whose value
            # could be affected by `manager.clear(***REMOVED***`. Refs #19816.
            objs = tuple(objs***REMOVED***

            clear = kwargs.pop('clear', False***REMOVED***

            db = router.db_for_write(self.through, instance=self.instance***REMOVED***
            with transaction.atomic(using=db, savepoint=False***REMOVED***:
                if clear:
                    self.clear(***REMOVED***
                    self.add(*objs***REMOVED***
                else:
                    old_ids = set(self.using(db***REMOVED***.values_list(self.target_field.target_field.attname, flat=True***REMOVED******REMOVED***

                    new_objs = [***REMOVED***
                    for obj in objs:
                        fk_val = (
                            self.target_field.get_foreign_related_value(obj***REMOVED***[0***REMOVED***
                            if isinstance(obj, self.model***REMOVED*** else obj
                        ***REMOVED***
                        if fk_val in old_ids:
                            old_ids.remove(fk_val***REMOVED***
                        else:
                            new_objs.append(obj***REMOVED***

                    self.remove(*old_ids***REMOVED***
                    self.add(*new_objs***REMOVED***
        set.alters_data = True

        def create(self, **kwargs***REMOVED***:
            # This check needs to be done here, since we can't later remove this
            # from the method lookup table, as we do with add and remove.
            if not self.through._meta.auto_created:
                opts = self.through._meta
                raise AttributeError(
                    "Cannot use create(***REMOVED*** on a ManyToManyField which specifies "
                    "an intermediary model. Use %s.%s's Manager instead." %
                    (opts.app_label, opts.object_name***REMOVED***
                ***REMOVED***
            db = router.db_for_write(self.instance.__class__, instance=self.instance***REMOVED***
            new_obj = super(ManyRelatedManager, self.db_manager(db***REMOVED******REMOVED***.create(**kwargs***REMOVED***
            self.add(new_obj***REMOVED***
            return new_obj
        create.alters_data = True

        def get_or_create(self, **kwargs***REMOVED***:
            db = router.db_for_write(self.instance.__class__, instance=self.instance***REMOVED***
            obj, created = super(ManyRelatedManager, self.db_manager(db***REMOVED******REMOVED***.get_or_create(**kwargs***REMOVED***
            # We only need to add(***REMOVED*** if created because if we got an object back
            # from get(***REMOVED*** then the relationship already exists.
            if created:
                self.add(obj***REMOVED***
            return obj, created
        get_or_create.alters_data = True

        def update_or_create(self, **kwargs***REMOVED***:
            db = router.db_for_write(self.instance.__class__, instance=self.instance***REMOVED***
            obj, created = super(ManyRelatedManager, self.db_manager(db***REMOVED******REMOVED***.update_or_create(**kwargs***REMOVED***
            # We only need to add(***REMOVED*** if created because if we got an object back
            # from get(***REMOVED*** then the relationship already exists.
            if created:
                self.add(obj***REMOVED***
            return obj, created
        update_or_create.alters_data = True

        def _add_items(self, source_field_name, target_field_name, *objs***REMOVED***:
            # source_field_name: the PK fieldname in join table for the source object
            # target_field_name: the PK fieldname in join table for the target object
            # *objs - objects to add. Either object instances, or primary keys of object instances.

            # If there aren't any objects, there is nothing to do.
            from django.db.models import Model
            if objs:
                new_ids = set(***REMOVED***
                for obj in objs:
                    if isinstance(obj, self.model***REMOVED***:
                        if not router.allow_relation(obj, self.instance***REMOVED***:
                            raise ValueError(
                                'Cannot add "%r": instance is on database "%s", value is on database "%s"' %
                                (obj, self.instance._state.db, obj._state.db***REMOVED***
                            ***REMOVED***
                        fk_val = self.through._meta.get_field(
                            target_field_name***REMOVED***.get_foreign_related_value(obj***REMOVED***[0***REMOVED***
                        if fk_val is None:
                            raise ValueError(
                                'Cannot add "%r": the value for field "%s" is None' %
                                (obj, target_field_name***REMOVED***
                            ***REMOVED***
                        new_ids.add(fk_val***REMOVED***
                    elif isinstance(obj, Model***REMOVED***:
                        raise TypeError(
                            "'%s' instance expected, got %r" %
                            (self.model._meta.object_name, obj***REMOVED***
                        ***REMOVED***
                    else:
                        new_ids.add(obj***REMOVED***

                db = router.db_for_write(self.through, instance=self.instance***REMOVED***
                vals = (self.through._default_manager.using(db***REMOVED***
                        .values_list(target_field_name, flat=True***REMOVED***
                        .filter(**{
                            source_field_name: self.related_val[0***REMOVED***,
                            '%s__in' % target_field_name: new_ids,
                    ***REMOVED******REMOVED******REMOVED***
                new_ids = new_ids - set(vals***REMOVED***

                with transaction.atomic(using=db, savepoint=False***REMOVED***:
                    if self.reverse or source_field_name == self.source_field_name:
                        # Don't send the signal when we are inserting the
                        # duplicate data row for symmetrical reverse entries.
                        signals.m2m_changed.send(
                            sender=self.through, action='pre_add',
                            instance=self.instance, reverse=self.reverse,
                            model=self.model, pk_set=new_ids, using=db,
                        ***REMOVED***

                    # Add the ones that aren't there already
                    self.through._default_manager.using(db***REMOVED***.bulk_create([
                        self.through(**{
                            '%s_id' % source_field_name: self.related_val[0***REMOVED***,
                            '%s_id' % target_field_name: obj_id,
                    ***REMOVED******REMOVED***
                        for obj_id in new_ids
                    ***REMOVED******REMOVED***

                    if self.reverse or source_field_name == self.source_field_name:
                        # Don't send the signal when we are inserting the
                        # duplicate data row for symmetrical reverse entries.
                        signals.m2m_changed.send(
                            sender=self.through, action='post_add',
                            instance=self.instance, reverse=self.reverse,
                            model=self.model, pk_set=new_ids, using=db,
                        ***REMOVED***

        def _remove_items(self, source_field_name, target_field_name, *objs***REMOVED***:
            # source_field_name: the PK colname in join table for the source object
            # target_field_name: the PK colname in join table for the target object
            # *objs - objects to remove
            if not objs:
                return

            # Check that all the objects are of the right type
            old_ids = set(***REMOVED***
            for obj in objs:
                if isinstance(obj, self.model***REMOVED***:
                    fk_val = self.target_field.get_foreign_related_value(obj***REMOVED***[0***REMOVED***
                    old_ids.add(fk_val***REMOVED***
                else:
                    old_ids.add(obj***REMOVED***

            db = router.db_for_write(self.through, instance=self.instance***REMOVED***
            with transaction.atomic(using=db, savepoint=False***REMOVED***:
                # Send a signal to the other end if need be.
                signals.m2m_changed.send(
                    sender=self.through, action="pre_remove",
                    instance=self.instance, reverse=self.reverse,
                    model=self.model, pk_set=old_ids, using=db,
                ***REMOVED***
                target_model_qs = super(ManyRelatedManager, self***REMOVED***.get_queryset(***REMOVED***
                if target_model_qs._has_filters(***REMOVED***:
                    old_vals = target_model_qs.using(db***REMOVED***.filter(**{
                        '%s__in' % self.target_field.target_field.attname: old_ids***REMOVED******REMOVED***
                else:
                    old_vals = old_ids
                filters = self._build_remove_filters(old_vals***REMOVED***
                self.through._default_manager.using(db***REMOVED***.filter(filters***REMOVED***.delete(***REMOVED***

                signals.m2m_changed.send(
                    sender=self.through, action="post_remove",
                    instance=self.instance, reverse=self.reverse,
                    model=self.model, pk_set=old_ids, using=db,
                ***REMOVED***

    return ManyRelatedManager
