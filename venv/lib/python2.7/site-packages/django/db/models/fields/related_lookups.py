from django.db.models.lookups import (
    Exact, GreaterThan, GreaterThanOrEqual, In, IsNull, LessThan,
    LessThanOrEqual,
***REMOVED***


class MultiColSource(object***REMOVED***:
    contains_aggregate = False

    def __init__(self, alias, targets, sources, field***REMOVED***:
        self.targets, self.sources, self.field, self.alias = targets, sources, field, alias
        self.output_field = self.field

    def __repr__(self***REMOVED***:
        return "{***REMOVED***({***REMOVED***, {***REMOVED******REMOVED***".format(
            self.__class__.__name__, self.alias, self.field***REMOVED***

    def relabeled_clone(self, relabels***REMOVED***:
        return self.__class__(relabels.get(self.alias, self.alias***REMOVED***,
                              self.targets, self.sources, self.field***REMOVED***


def get_normalized_value(value, lhs***REMOVED***:
    from django.db.models import Model
    if isinstance(value, Model***REMOVED***:
        value_list = [***REMOVED***
        sources = lhs.output_field.get_path_info(***REMOVED***[-1***REMOVED***.target_fields
        for source in sources:
            while not isinstance(value, source.model***REMOVED*** and source.remote_field:
                source = source.remote_field.model._meta.get_field(source.remote_field.field_name***REMOVED***
            ***REMOVED***
                value_list.append(getattr(value, source.attname***REMOVED******REMOVED***
            except AttributeError:
                # A case like Restaurant.objects.filter(place=restaurant_instance***REMOVED***,
                # where place is a OneToOneField and the primary key of Restaurant.
                return (value.pk,***REMOVED***
        return tuple(value_list***REMOVED***
    if not isinstance(value, tuple***REMOVED***:
        return (value,***REMOVED***
    return value


class RelatedIn(In***REMOVED***:
    def get_prep_lookup(self***REMOVED***:
        if not isinstance(self.lhs, MultiColSource***REMOVED*** and self.rhs_is_direct_value(***REMOVED***:
            # If we get here, we are dealing with single-column relations.
            self.rhs = [get_normalized_value(val, self.lhs***REMOVED***[0***REMOVED*** for val in self.rhs***REMOVED***
            # We need to run the related field's get_prep_value(***REMOVED***. Consider case
            # ForeignKey to IntegerField given value 'abc'. The ForeignKey itself
            # doesn't have validation for non-integers, so we must run validation
            # using the target field.
            if hasattr(self.lhs.output_field, 'get_path_info'***REMOVED***:
                # Run the target field's get_prep_value. We can safely assume there is
                # only one as we don't get to the direct value branch otherwise.
                target_field = self.lhs.output_field.get_path_info(***REMOVED***[-1***REMOVED***.target_fields[-1***REMOVED***
                self.rhs = [target_field.get_prep_value(v***REMOVED*** for v in self.rhs***REMOVED***
        return super(RelatedIn, self***REMOVED***.get_prep_lookup(***REMOVED***

    def as_sql(self, compiler, connection***REMOVED***:
        if isinstance(self.lhs, MultiColSource***REMOVED***:
            # For multicolumn lookups we need to build a multicolumn where clause.
            # This clause is either a SubqueryConstraint (for values that need to be compiled to
            # SQL***REMOVED*** or a OR-combined list of (col1 = val1 AND col2 = val2 AND ...***REMOVED*** clauses.
            from django.db.models.sql.where import WhereNode, SubqueryConstraint, AND, OR

            root_constraint = WhereNode(connector=OR***REMOVED***
            if self.rhs_is_direct_value(***REMOVED***:
                values = [get_normalized_value(value, self.lhs***REMOVED*** for value in self.rhs***REMOVED***
                for value in values:
                    value_constraint = WhereNode(***REMOVED***
                    for source, target, val in zip(self.lhs.sources, self.lhs.targets, value***REMOVED***:
                        lookup_class = target.get_lookup('exact'***REMOVED***
                        lookup = lookup_class(target.get_col(self.lhs.alias, source***REMOVED***, val***REMOVED***
                        value_constraint.add(lookup, AND***REMOVED***
                    root_constraint.add(value_constraint, OR***REMOVED***
            else:
                root_constraint.add(
                    SubqueryConstraint(
                        self.lhs.alias, [target.column for target in self.lhs.targets***REMOVED***,
                        [source.name for source in self.lhs.sources***REMOVED***, self.rhs***REMOVED***,
                    AND***REMOVED***
            return root_constraint.as_sql(compiler, connection***REMOVED***
        else:
            return super(RelatedIn, self***REMOVED***.as_sql(compiler, connection***REMOVED***


class RelatedLookupMixin(object***REMOVED***:
    def get_prep_lookup(self***REMOVED***:
        if not isinstance(self.lhs, MultiColSource***REMOVED*** and self.rhs_is_direct_value(***REMOVED***:
            # If we get here, we are dealing with single-column relations.
            self.rhs = get_normalized_value(self.rhs, self.lhs***REMOVED***[0***REMOVED***
            # We need to run the related field's get_prep_value(***REMOVED***. Consider case
            # ForeignKey to IntegerField given value 'abc'. The ForeignKey itself
            # doesn't have validation for non-integers, so we must run validation
            # using the target field.
            if self.prepare_rhs and hasattr(self.lhs.output_field, 'get_path_info'***REMOVED***:
                # Get the target field. We can safely assume there is only one
                # as we don't get to the direct value branch otherwise.
                target_field = self.lhs.output_field.get_path_info(***REMOVED***[-1***REMOVED***.target_fields[-1***REMOVED***
                self.rhs = target_field.get_prep_value(self.rhs***REMOVED***

        return super(RelatedLookupMixin, self***REMOVED***.get_prep_lookup(***REMOVED***

    def as_sql(self, compiler, connection***REMOVED***:
        if isinstance(self.lhs, MultiColSource***REMOVED***:
            assert self.rhs_is_direct_value(***REMOVED***
            self.rhs = get_normalized_value(self.rhs, self.lhs***REMOVED***
            from django.db.models.sql.where import WhereNode, AND
            root_constraint = WhereNode(***REMOVED***
            for target, source, val in zip(self.lhs.targets, self.lhs.sources, self.rhs***REMOVED***:
                lookup_class = target.get_lookup(self.lookup_name***REMOVED***
                root_constraint.add(
                    lookup_class(target.get_col(self.lhs.alias, source***REMOVED***, val***REMOVED***, AND***REMOVED***
            return root_constraint.as_sql(compiler, connection***REMOVED***
        return super(RelatedLookupMixin, self***REMOVED***.as_sql(compiler, connection***REMOVED***


class RelatedExact(RelatedLookupMixin, Exact***REMOVED***:
    pass


class RelatedLessThan(RelatedLookupMixin, LessThan***REMOVED***:
    pass


class RelatedGreaterThan(RelatedLookupMixin, GreaterThan***REMOVED***:
    pass


class RelatedGreaterThanOrEqual(RelatedLookupMixin, GreaterThanOrEqual***REMOVED***:
    pass


class RelatedLessThanOrEqual(RelatedLookupMixin, LessThanOrEqual***REMOVED***:
    pass


class RelatedIsNull(RelatedLookupMixin, IsNull***REMOVED***:
    pass
