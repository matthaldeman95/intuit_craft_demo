***REMOVED***
"Rel objects" for related fields.

"Rel objects" (for lack of a better name***REMOVED*** carry information about the relation
modeled by a related field and provide some utility functions. They're stored
in the ``remote_field`` attribute of the field.

They also act as reverse fields for the purposes of the Meta API because
they're the closest concept currently available.
***REMOVED***

from __future__ import unicode_literals

import warnings

from django.core import exceptions
from django.utils.deprecation import RemovedInDjango20Warning
from django.utils.encoding import smart_text
from django.utils.functional import cached_property

from . import BLANK_CHOICE_DASH


class ForeignObjectRel(object***REMOVED***:
    ***REMOVED***
    Used by ForeignObject to store information about the relation.

    ``_meta.get_fields(***REMOVED***`` returns this class to provide access to the field
    flags for the reverse relation.
    ***REMOVED***

    # Field flags
    auto_created = True
    concrete = False
    editable = False
    is_relation = True

    # Reverse relations are always nullable (Django can't enforce that a
    # foreign key on the related model points to this model***REMOVED***.
    null = True

    def __init__(self, field, to, related_name=None, related_query_name=None,
                 limit_choices_to=None, parent_link=False, on_delete=None***REMOVED***:
        self.field = field
        self.model = to
        self.related_name = related_name
        self.related_query_name = related_query_name
        self.limit_choices_to = {***REMOVED*** if limit_choices_to is None else limit_choices_to
        self.parent_link = parent_link
        self.on_delete = on_delete

        self.symmetrical = False
        self.multiple = True

    # Some of the following cached_properties can't be initialized in
    # __init__ as the field doesn't have its model yet. Calling these methods
    # before field.contribute_to_class(***REMOVED*** has been called will result in
    # AttributeError
    @property
    def to(self***REMOVED***:
        warnings.warn(
            "Usage of ForeignObjectRel.to attribute has been deprecated. "
            "Use the model attribute instead.",
            RemovedInDjango20Warning, 2***REMOVED***
        return self.model

    @cached_property
    def hidden(self***REMOVED***:
        return self.is_hidden(***REMOVED***

    @cached_property
    def name(self***REMOVED***:
        return self.field.related_query_name(***REMOVED***

    @property
    def remote_field(self***REMOVED***:
        return self.field

    @property
    def target_field(self***REMOVED***:
        ***REMOVED***
        When filtering against this relation, returns the field on the remote
        model against which the filtering should happen.
        ***REMOVED***
        target_fields = self.get_path_info(***REMOVED***[-1***REMOVED***.target_fields
        if len(target_fields***REMOVED*** > 1:
            raise exceptions.FieldError("Can't use target_field for multicolumn relations."***REMOVED***
        return target_fields[0***REMOVED***

    @cached_property
    def related_model(self***REMOVED***:
        if not self.field.model:
            raise AttributeError(
                "This property can't be accessed before self.field.contribute_to_class has been called."***REMOVED***
        return self.field.model

    @cached_property
    def many_to_many(self***REMOVED***:
        return self.field.many_to_many

    @cached_property
    def many_to_one(self***REMOVED***:
        return self.field.one_to_many

    @cached_property
    def one_to_many(self***REMOVED***:
        return self.field.many_to_one

    @cached_property
    def one_to_one(self***REMOVED***:
        return self.field.one_to_one

    def get_lookup(self, lookup_name***REMOVED***:
        return self.field.get_lookup(lookup_name***REMOVED***

    def get_internal_type(self***REMOVED***:
        return self.field.get_internal_type(***REMOVED***

    @property
    def db_type(self***REMOVED***:
        return self.field.db_type

    def __repr__(self***REMOVED***:
        return '<%s: %s.%s>' % (
            type(self***REMOVED***.__name__,
            self.related_model._meta.app_label,
            self.related_model._meta.model_name,
        ***REMOVED***

    def get_choices(self, include_blank=True, blank_choice=BLANK_CHOICE_DASH***REMOVED***:
        ***REMOVED***
        Return choices with a default blank choices included, for use as
        SelectField choices for this field.

        Analog of django.db.models.fields.Field.get_choices(***REMOVED***, provided
        initially for utilization by RelatedFieldListFilter.
        ***REMOVED***
        return (blank_choice if include_blank else [***REMOVED******REMOVED*** + [
            (x._get_pk_val(***REMOVED***, smart_text(x***REMOVED******REMOVED*** for x in self.related_model._default_manager.all(***REMOVED***
        ***REMOVED***

    def is_hidden(self***REMOVED***:
        "Should the related object be hidden?"
        return bool(self.related_name***REMOVED*** and self.related_name[-1***REMOVED*** == '+'

    def get_joining_columns(self***REMOVED***:
        return self.field.get_reverse_joining_columns(***REMOVED***

    def get_extra_restriction(self, where_class, alias, related_alias***REMOVED***:
        return self.field.get_extra_restriction(where_class, related_alias, alias***REMOVED***

    def set_field_name(self***REMOVED***:
        ***REMOVED***
        Set the related field's name, this is not available until later stages
        of app loading, so set_field_name is called from
        set_attributes_from_rel(***REMOVED***
        ***REMOVED***
        # By default foreign object doesn't relate to any remote field (for
        # example custom multicolumn joins currently have no remote field***REMOVED***.
        self.field_name = None

    def get_accessor_name(self, model=None***REMOVED***:
        # This method encapsulates the logic that decides what name to give an
        # accessor descriptor that retrieves related many-to-one or
        # many-to-many objects. It uses the lower-cased object_name + "_set",
        # but this can be overridden with the "related_name" option.
        # Due to backwards compatibility ModelForms need to be able to provide
        # an alternate model. See BaseInlineFormSet.get_default_prefix(***REMOVED***.
        opts = model._meta if model else self.related_model._meta
        model = model or self.related_model
        if self.multiple:
            # If this is a symmetrical m2m relation on self, there is no reverse accessor.
            if self.symmetrical and model == self.model:
                return None
        if self.related_name:
            return self.related_name
        return opts.model_name + ('_set' if self.multiple else ''***REMOVED***

    def get_cache_name(self***REMOVED***:
        return "_%s_cache" % self.get_accessor_name(***REMOVED***

    def get_path_info(self***REMOVED***:
        return self.field.get_reverse_path_info(***REMOVED***


class ManyToOneRel(ForeignObjectRel***REMOVED***:
    ***REMOVED***
    Used by the ForeignKey field to store information about the relation.

    ``_meta.get_fields(***REMOVED***`` returns this class to provide access to the field
    flags for the reverse relation.

    Note: Because we somewhat abuse the Rel objects by using them as reverse
    fields we get the funny situation where
    ``ManyToOneRel.many_to_one == False`` and
    ``ManyToOneRel.one_to_many == True``. This is unfortunate but the actual
    ManyToOneRel class is a private API and there is work underway to turn
    reverse relations into actual fields.
    ***REMOVED***

    def __init__(self, field, to, field_name, related_name=None, related_query_name=None,
                 limit_choices_to=None, parent_link=False, on_delete=None***REMOVED***:
        super(ManyToOneRel, self***REMOVED***.__init__(
            field, to,
            related_name=related_name,
            related_query_name=related_query_name,
            limit_choices_to=limit_choices_to,
            parent_link=parent_link,
            on_delete=on_delete,
        ***REMOVED***

        self.field_name = field_name

    def __getstate__(self***REMOVED***:
        state = self.__dict__.copy(***REMOVED***
        state.pop('related_model', None***REMOVED***
        return state

    def get_related_field(self***REMOVED***:
        ***REMOVED***
        Return the Field in the 'to' object to which this relationship is tied.
        ***REMOVED***
        field = self.model._meta.get_field(self.field_name***REMOVED***
        if not field.concrete:
            raise exceptions.FieldDoesNotExist("No related field named '%s'" % self.field_name***REMOVED***
        return field

    def set_field_name(self***REMOVED***:
        self.field_name = self.field_name or self.model._meta.pk.name


class OneToOneRel(ManyToOneRel***REMOVED***:
    ***REMOVED***
    Used by OneToOneField to store information about the relation.

    ``_meta.get_fields(***REMOVED***`` returns this class to provide access to the field
    flags for the reverse relation.
    ***REMOVED***

    def __init__(self, field, to, field_name, related_name=None, related_query_name=None,
                 limit_choices_to=None, parent_link=False, on_delete=None***REMOVED***:
        super(OneToOneRel, self***REMOVED***.__init__(
            field, to, field_name,
            related_name=related_name,
            related_query_name=related_query_name,
            limit_choices_to=limit_choices_to,
            parent_link=parent_link,
            on_delete=on_delete,
        ***REMOVED***

        self.multiple = False


class ManyToManyRel(ForeignObjectRel***REMOVED***:
    ***REMOVED***
    Used by ManyToManyField to store information about the relation.

    ``_meta.get_fields(***REMOVED***`` returns this class to provide access to the field
    flags for the reverse relation.
    ***REMOVED***

    def __init__(self, field, to, related_name=None, related_query_name=None,
                 limit_choices_to=None, symmetrical=True, through=None,
                 through_fields=None, db_constraint=True***REMOVED***:
        super(ManyToManyRel, self***REMOVED***.__init__(
            field, to,
            related_name=related_name,
            related_query_name=related_query_name,
            limit_choices_to=limit_choices_to,
        ***REMOVED***

        if through and not db_constraint:
            raise ValueError("Can't supply a through model and db_constraint=False"***REMOVED***
        self.through = through

        if through_fields and not through:
            raise ValueError("Cannot specify through_fields without a through model"***REMOVED***
        self.through_fields = through_fields

        self.symmetrical = symmetrical
        self.db_constraint = db_constraint

    def get_related_field(self***REMOVED***:
        ***REMOVED***
        Return the field in the 'to' object to which this relationship is tied.
        Provided for symmetry with ManyToOneRel.
        ***REMOVED***
        opts = self.through._meta
        if self.through_fields:
            field = opts.get_field(self.through_fields[0***REMOVED******REMOVED***
        else:
            for field in opts.fields:
                rel = getattr(field, 'remote_field', None***REMOVED***
                if rel and rel.model == self.model:
                    break
        return field.foreign_related_fields[0***REMOVED***
