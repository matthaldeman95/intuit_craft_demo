***REMOVED***
Various data structures used in query construction.

Factored out from django.db.models.query to avoid making the main module very
large and/or so that they can be used by other modules without getting into
circular import difficulties.
***REMOVED***
from __future__ import unicode_literals

import inspect
from collections import namedtuple

from django.core.exceptions import FieldDoesNotExist
from django.db.models.constants import LOOKUP_SEP
from django.utils import tree

# PathInfo is used when converting lookups (fk__somecol***REMOVED***. The contents
# describe the relation in Model terms (model Options and Fields for both
# sides of the relation. The join_field is the field backing the relation.
PathInfo = namedtuple('PathInfo', 'from_opts to_opts target_fields join_field m2m direct'***REMOVED***


class InvalidQuery(Exception***REMOVED***:
    ***REMOVED***
    The query passed to raw isn't a safe query to use with raw.
    ***REMOVED***
    pass


class QueryWrapper(object***REMOVED***:
    ***REMOVED***
    A type that indicates the contents are an SQL fragment and the associate
    parameters. Can be used to pass opaque data to a where-clause, for example.
    ***REMOVED***
    contains_aggregate = False

    def __init__(self, sql, params***REMOVED***:
        self.data = sql, list(params***REMOVED***

    def as_sql(self, compiler=None, connection=None***REMOVED***:
        return self.data


class Q(tree.Node***REMOVED***:
    ***REMOVED***
    Encapsulates filters as objects that can then be combined logically (using
    `&` and `|`***REMOVED***.
    ***REMOVED***
    # Connection types
    AND = 'AND'
    OR = 'OR'
    default = AND

    def __init__(self, *args, **kwargs***REMOVED***:
        super(Q, self***REMOVED***.__init__(children=list(args***REMOVED*** + list(kwargs.items(***REMOVED******REMOVED******REMOVED***

    def _combine(self, other, conn***REMOVED***:
        if not isinstance(other, Q***REMOVED***:
            raise TypeError(other***REMOVED***
        obj = type(self***REMOVED***(***REMOVED***
        obj.connector = conn
        obj.add(self, conn***REMOVED***
        obj.add(other, conn***REMOVED***
        return obj

    def __or__(self, other***REMOVED***:
        return self._combine(other, self.OR***REMOVED***

    def __and__(self, other***REMOVED***:
        return self._combine(other, self.AND***REMOVED***

    def __invert__(self***REMOVED***:
        obj = type(self***REMOVED***(***REMOVED***
        obj.add(self, self.AND***REMOVED***
        obj.negate(***REMOVED***
        return obj

    def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False***REMOVED***:
        # We must promote any new joins to left outer joins so that when Q is
        # used as an expression, rows aren't filtered due to joins.
        clause, joins = query._add_q(self, reuse, allow_joins=allow_joins, split_subq=False***REMOVED***
        query.promote_joins(joins***REMOVED***
        return clause


class DeferredAttribute(object***REMOVED***:
    ***REMOVED***
    A wrapper for a deferred-loading field. When the value is read from this
    object the first time, the query is executed.
    ***REMOVED***
    def __init__(self, field_name, model***REMOVED***:
        self.field_name = field_name

    def __get__(self, instance, cls=None***REMOVED***:
        ***REMOVED***
        Retrieves and caches the value from the datastore on the first lookup.
        Returns the cached value.
        ***REMOVED***
        if instance is None:
            return self
        opts = instance._meta
        data = instance.__dict__
        if data.get(self.field_name, self***REMOVED*** is self:
            # self.field_name is the attname of the field, but only(***REMOVED*** takes the
            # actual name, so we need to translate it here.
            ***REMOVED***
                f = opts.get_field(self.field_name***REMOVED***
            except FieldDoesNotExist:
                f = [f for f in opts.fields if f.attname == self.field_name***REMOVED***[0***REMOVED***
            name = f.name
            # Let's see if the field is part of the parent chain. If so we
            # might be able to reuse the already loaded value. Refs #18343.
            val = self._check_parent_chain(instance, name***REMOVED***
            if val is None:
                instance.refresh_from_db(fields=[self.field_name***REMOVED******REMOVED***
                val = getattr(instance, self.field_name***REMOVED***
            data[self.field_name***REMOVED*** = val
        return data[self.field_name***REMOVED***

    def _check_parent_chain(self, instance, name***REMOVED***:
        ***REMOVED***
        Check if the field value can be fetched from a parent field already
        loaded in the instance. This can be done if the to-be fetched
        field is a primary key field.
        ***REMOVED***
        opts = instance._meta
        f = opts.get_field(name***REMOVED***
        link_field = opts.get_ancestor_link(f.model***REMOVED***
        if f.primary_key and f != link_field:
            return getattr(instance, link_field.attname***REMOVED***
        return None


class RegisterLookupMixin(object***REMOVED***:
    def _get_lookup(self, lookup_name***REMOVED***:
        ***REMOVED***
            return self.class_lookups[lookup_name***REMOVED***
        except KeyError:
            # To allow for inheritance, check parent class' class_lookups.
            for parent in inspect.getmro(self.__class__***REMOVED***:
                if 'class_lookups' not in parent.__dict__:
                    continue
                if lookup_name in parent.class_lookups:
                    return parent.class_lookups[lookup_name***REMOVED***
        except AttributeError:
            # This class didn't have any class_lookups
            pass
        return None

    def get_lookup(self, lookup_name***REMOVED***:
        from django.db.models.lookups import Lookup
        found = self._get_lookup(lookup_name***REMOVED***
        if found is None and hasattr(self, 'output_field'***REMOVED***:
            return self.output_field.get_lookup(lookup_name***REMOVED***
        if found is not None and not issubclass(found, Lookup***REMOVED***:
            return None
        return found

    def get_transform(self, lookup_name***REMOVED***:
        from django.db.models.lookups import Transform
        found = self._get_lookup(lookup_name***REMOVED***
        if found is None and hasattr(self, 'output_field'***REMOVED***:
            return self.output_field.get_transform(lookup_name***REMOVED***
        if found is not None and not issubclass(found, Transform***REMOVED***:
            return None
        return found

    @classmethod
    def register_lookup(cls, lookup, lookup_name=None***REMOVED***:
        if lookup_name is None:
            lookup_name = lookup.lookup_name
        if 'class_lookups' not in cls.__dict__:
            cls.class_lookups = {***REMOVED***
        cls.class_lookups[lookup_name***REMOVED*** = lookup
        return lookup

    @classmethod
    def _unregister_lookup(cls, lookup, lookup_name=None***REMOVED***:
        ***REMOVED***
        Remove given lookup from cls lookups. For use in tests only as it's
        not thread-safe.
        ***REMOVED***
        if lookup_name is None:
            lookup_name = lookup.lookup_name
        del cls.class_lookups[lookup_name***REMOVED***


def select_related_descend(field, restricted, requested, load_fields, reverse=False***REMOVED***:
    ***REMOVED***
    Returns True if this field should be used to descend deeper for
    select_related(***REMOVED*** purposes. Used by both the query construction code
    (sql.query.fill_related_selections(***REMOVED******REMOVED*** and the model instance creation code
    (query.get_klass_info(***REMOVED******REMOVED***.

    Arguments:
     * field - the field to be checked
     * restricted - a boolean field, indicating if the field list has been
       manually restricted using a requested clause***REMOVED***
     * requested - The select_related(***REMOVED*** dictionary.
     * load_fields - the set of fields to be loaded on this model
     * reverse - boolean, True if we are checking a reverse select related
    ***REMOVED***
    if not field.remote_field:
        return False
    if field.remote_field.parent_link and not reverse:
        return False
    if restricted:
        if reverse and field.related_query_name(***REMOVED*** not in requested:
            return False
        if not reverse and field.name not in requested:
            return False
    if not restricted and field.null:
        return False
    if load_fields:
        if field.attname not in load_fields:
            if restricted and field.name in requested:
                raise InvalidQuery("Field %s.%s cannot be both deferred"
                                   " and traversed using select_related"
                                   " at the same time." %
                                   (field.model._meta.object_name, field.name***REMOVED******REMOVED***
    return True


def refs_expression(lookup_parts, annotations***REMOVED***:
    ***REMOVED***
    A helper method to check if the lookup_parts contains references
    to the given annotations set. Because the LOOKUP_SEP is contained in the
    default annotation names we must check each prefix of the lookup_parts
    for a match.
    ***REMOVED***
    for n in range(len(lookup_parts***REMOVED*** + 1***REMOVED***:
        level_n_lookup = LOOKUP_SEP.join(lookup_parts[0:n***REMOVED******REMOVED***
        if level_n_lookup in annotations and annotations[level_n_lookup***REMOVED***:
            return annotations[level_n_lookup***REMOVED***, lookup_parts[n:***REMOVED***
    return False, (***REMOVED***


def check_rel_lookup_compatibility(model, target_opts, field***REMOVED***:
    ***REMOVED***
    Check that self.model is compatible with target_opts. Compatibility
    is OK if:
      1***REMOVED*** model and opts match (where proxy inheritance is removed***REMOVED***
      2***REMOVED*** model is parent of opts' model or the other way around
    ***REMOVED***
    def check(opts***REMOVED***:
        return (
            model._meta.concrete_model == opts.concrete_model or
            opts.concrete_model in model._meta.get_parent_list(***REMOVED*** or
            model in opts.get_parent_list(***REMOVED***
        ***REMOVED***
    # If the field is a primary key, then doing a query against the field's
    # model is ok, too. Consider the case:
    # class Restaurant(models.Model***REMOVED***:
    #     place = OnetoOneField(Place, primary_key=True***REMOVED***:
    # Restaurant.objects.filter(pk__in=Restaurant.objects.all(***REMOVED******REMOVED***.
    # If we didn't have the primary key check, then pk__in (== place__in***REMOVED*** would
    # give Place's opts as the target opts, but Restaurant isn't compatible
    # with that. This logic applies only to primary keys, as when doing __in=qs,
    # we are going to turn this into __in=qs.values('pk'***REMOVED*** later on.
    return (
        check(target_opts***REMOVED*** or
        (getattr(field, 'primary_key', False***REMOVED*** and check(field.model._meta***REMOVED******REMOVED***
    ***REMOVED***
