import copy
import inspect
from importlib import import_module

from django.db import router
from django.db.models.query import QuerySet
from django.utils import six
from django.utils.encoding import python_2_unicode_compatible


@python_2_unicode_compatible
class BaseManager(object***REMOVED***:
    # Tracks each time a Manager instance is created. Used to retain order.
    creation_counter = 0

    # Set to True for the 'objects' managers that are automatically created.
    auto_created = False

    #: If set to True the manager will be serialized into migrations and will
    #: thus be available in e.g. RunPython operations
    use_in_migrations = False

    def __new__(cls, *args, **kwargs***REMOVED***:
        # We capture the arguments to make returning them trivial
        obj = super(BaseManager, cls***REMOVED***.__new__(cls***REMOVED***
        obj._constructor_args = (args, kwargs***REMOVED***
        return obj

    def __init__(self***REMOVED***:
        super(BaseManager, self***REMOVED***.__init__(***REMOVED***
        self._set_creation_counter(***REMOVED***
        self.model = None
        self.name = None
        self._db = None
        self._hints = {***REMOVED***

    def __str__(self***REMOVED***:
        ***REMOVED*** Return "app_label.model_label.manager_name". ***REMOVED***
        return '%s.%s' % (self.model._meta.label, self.name***REMOVED***

    def deconstruct(self***REMOVED***:
        ***REMOVED***
        Returns a 5-tuple of the form (as_manager (True***REMOVED***, manager_class,
        queryset_class, args, kwargs***REMOVED***.

        Raises a ValueError if the manager is dynamically generated.
        ***REMOVED***
        qs_class = self._queryset_class
        if getattr(self, '_built_with_as_manager', False***REMOVED***:
            # using MyQuerySet.as_manager(***REMOVED***
            return (
                True,  # as_manager
                None,  # manager_class
                '%s.%s' % (qs_class.__module__, qs_class.__name__***REMOVED***,  # qs_class
                None,  # args
                None,  # kwargs
            ***REMOVED***
        else:
            module_name = self.__module__
            name = self.__class__.__name__
            # Make sure it's actually there and not an inner class
            module = import_module(module_name***REMOVED***
            if not hasattr(module, name***REMOVED***:
                raise ValueError(
                    "Could not find manager %s in %s.\n"
                    "Please note that you need to inherit from managers you "
                    "dynamically generated with 'from_queryset(***REMOVED***'."
                    % (name, module_name***REMOVED***
                ***REMOVED***
            return (
                False,  # as_manager
                '%s.%s' % (module_name, name***REMOVED***,  # manager_class
                None,  # qs_class
                self._constructor_args[0***REMOVED***,  # args
                self._constructor_args[1***REMOVED***,  # kwargs
            ***REMOVED***

    def check(self, **kwargs***REMOVED***:
        return [***REMOVED***

    @classmethod
    def _get_queryset_methods(cls, queryset_class***REMOVED***:
        def create_method(name, method***REMOVED***:
            def manager_method(self, *args, **kwargs***REMOVED***:
                return getattr(self.get_queryset(***REMOVED***, name***REMOVED***(*args, **kwargs***REMOVED***
            manager_method.__name__ = method.__name__
            manager_method.__doc__ = method.__doc__
            return manager_method

        new_methods = {***REMOVED***
        # Refs http://bugs.python.org/issue1785.
        predicate = inspect.isfunction if six.PY3 else inspect.ismethod
        for name, method in inspect.getmembers(queryset_class, predicate=predicate***REMOVED***:
            # Only copy missing methods.
            if hasattr(cls, name***REMOVED***:
                continue
            # Only copy public methods or methods with the attribute `queryset_only=False`.
            queryset_only = getattr(method, 'queryset_only', None***REMOVED***
            if queryset_only or (queryset_only is None and name.startswith('_'***REMOVED******REMOVED***:
                continue
            # Copy the method onto the manager.
            new_methods[name***REMOVED*** = create_method(name, method***REMOVED***
        return new_methods

    @classmethod
    def from_queryset(cls, queryset_class, class_name=None***REMOVED***:
        if class_name is None:
            class_name = '%sFrom%s' % (cls.__name__, queryset_class.__name__***REMOVED***
        class_dict = {
            '_queryset_class': queryset_class,
    ***REMOVED***
        class_dict.update(cls._get_queryset_methods(queryset_class***REMOVED******REMOVED***
        return type(class_name, (cls,***REMOVED***, class_dict***REMOVED***

    def contribute_to_class(self, model, name***REMOVED***:
        if not self.name:
            self.name = name
        self.model = model

        setattr(model, name, ManagerDescriptor(self***REMOVED******REMOVED***

        model._meta.add_manager(self***REMOVED***

    def _set_creation_counter(self***REMOVED***:
        ***REMOVED***
        Sets the creation counter value for this instance and increments the
        class-level copy.
        ***REMOVED***
        self.creation_counter = BaseManager.creation_counter
        BaseManager.creation_counter += 1

    def db_manager(self, using=None, hints=None***REMOVED***:
        obj = copy.copy(self***REMOVED***
        obj._db = using or self._db
        obj._hints = hints or self._hints
        return obj

    @property
    def db(self***REMOVED***:
        return self._db or router.db_for_read(self.model, **self._hints***REMOVED***

    #######################
    # PROXIES TO QUERYSET #
    #######################

    def get_queryset(self***REMOVED***:
        ***REMOVED***
        Returns a new QuerySet object.  Subclasses can override this method to
        easily customize the behavior of the Manager.
        ***REMOVED***
        return self._queryset_class(model=self.model, using=self._db, hints=self._hints***REMOVED***

    def all(self***REMOVED***:
        # We can't proxy this method through the `QuerySet` like we do for the
        # rest of the `QuerySet` methods. This is because `QuerySet.all(***REMOVED***`
        # works by creating a "copy" of the current queryset and in making said
        # copy, all the cached `prefetch_related` lookups are lost. See the
        # implementation of `RelatedManager.get_queryset(***REMOVED***` for a better
        # understanding of how this comes into play.
        return self.get_queryset(***REMOVED***

    def __eq__(self, other***REMOVED***:
        return (
            isinstance(other, self.__class__***REMOVED*** and
            self._constructor_args == other._constructor_args
        ***REMOVED***

    def __ne__(self, other***REMOVED***:
        return not (self == other***REMOVED***

    def __hash__(self***REMOVED***:
        return id(self***REMOVED***


class Manager(BaseManager.from_queryset(QuerySet***REMOVED******REMOVED***:
    pass


class ManagerDescriptor(object***REMOVED***:

    def __init__(self, manager***REMOVED***:
        self.manager = manager

    def __get__(self, instance, cls=None***REMOVED***:
        if instance is not None:
            raise AttributeError("Manager isn't accessible via %s instances" % cls.__name__***REMOVED***

        if cls._meta.abstract:
            raise AttributeError("Manager isn't available; %s is abstract" % (
                cls._meta.object_name,
            ***REMOVED******REMOVED***

        if cls._meta.swapped:
            raise AttributeError(
                "Manager isn't available; '%s.%s' has been swapped for '%s'" % (
                    cls._meta.app_label,
                    cls._meta.object_name,
                    cls._meta.swapped,
                ***REMOVED***
            ***REMOVED***

        return cls._meta.managers_map[self.manager.name***REMOVED***


class EmptyManager(Manager***REMOVED***:
    def __init__(self, model***REMOVED***:
        super(EmptyManager, self***REMOVED***.__init__(***REMOVED***
        self.model = model

    def get_queryset(self***REMOVED***:
        return super(EmptyManager, self***REMOVED***.get_queryset(***REMOVED***.none(***REMOVED***
