***REMOVED***
Classes that represent database functions.
***REMOVED***
from django.db.models import Func, Transform, Value, fields


class Cast(Func***REMOVED***:
    ***REMOVED***
    Coerce an expression to a new field type.
    ***REMOVED***
    function = 'CAST'
    template = '%(function***REMOVED***s(%(expressions***REMOVED***s AS %(db_type***REMOVED***s***REMOVED***'

    mysql_types = {
        fields.CharField: 'char',
        fields.IntegerField: 'signed integer',
        fields.FloatField: 'signed',
***REMOVED***

    def __init__(self, expression, output_field***REMOVED***:
        super(Cast, self***REMOVED***.__init__(expression, output_field=output_field***REMOVED***

    def as_sql(self, compiler, connection, **extra_context***REMOVED***:
        if 'db_type' not in extra_context:
            extra_context['db_type'***REMOVED*** = self._output_field.db_type(connection***REMOVED***
        return super(Cast, self***REMOVED***.as_sql(compiler, connection, **extra_context***REMOVED***

    def as_mysql(self, compiler, connection***REMOVED***:
        extra_context = {***REMOVED***
        output_field_class = type(self._output_field***REMOVED***
        if output_field_class in self.mysql_types:
            extra_context['db_type'***REMOVED*** = self.mysql_types[output_field_class***REMOVED***
        return self.as_sql(compiler, connection, **extra_context***REMOVED***

    def as_postgresql(self, compiler, connection***REMOVED***:
        # CAST would be valid too, but the :: shortcut syntax is more readable.
        return self.as_sql(compiler, connection, template='%(expressions***REMOVED***s::%(db_type***REMOVED***s'***REMOVED***


class Coalesce(Func***REMOVED***:
    ***REMOVED***
    Chooses, from left to right, the first non-null expression and returns it.
    ***REMOVED***
    function = 'COALESCE'

    def __init__(self, *expressions, **extra***REMOVED***:
        if len(expressions***REMOVED*** < 2:
            raise ValueError('Coalesce must take at least two expressions'***REMOVED***
        super(Coalesce, self***REMOVED***.__init__(*expressions, **extra***REMOVED***

    def as_oracle(self, compiler, connection***REMOVED***:
        # we can't mix TextField (NCLOB***REMOVED*** and CharField (NVARCHAR***REMOVED***, so convert
        # all fields to NCLOB when we expect NCLOB
        if self.output_field.get_internal_type(***REMOVED*** == 'TextField':
            class ToNCLOB(Func***REMOVED***:
                function = 'TO_NCLOB'

            expressions = [
                ToNCLOB(expression***REMOVED*** for expression in self.get_source_expressions(***REMOVED******REMOVED***
            clone = self.copy(***REMOVED***
            clone.set_source_expressions(expressions***REMOVED***
            return super(Coalesce, clone***REMOVED***.as_sql(compiler, connection***REMOVED***
        return self.as_sql(compiler, connection***REMOVED***


class ConcatPair(Func***REMOVED***:
    ***REMOVED***
    A helper class that concatenates two arguments together. This is used
    by `Concat` because not all backend databases support more than two
    arguments.
    ***REMOVED***
    function = 'CONCAT'

    def __init__(self, left, right, **extra***REMOVED***:
        super(ConcatPair, self***REMOVED***.__init__(left, right, **extra***REMOVED***

    def as_sqlite(self, compiler, connection***REMOVED***:
        coalesced = self.coalesce(***REMOVED***
        return super(ConcatPair, coalesced***REMOVED***.as_sql(
            compiler, connection, template='%(expressions***REMOVED***s', arg_joiner=' || '
        ***REMOVED***

    def as_mysql(self, compiler, connection***REMOVED***:
        # Use CONCAT_WS with an empty separator so that NULLs are ignored.
        return super(ConcatPair, self***REMOVED***.as_sql(
            compiler, connection, function='CONCAT_WS', template="%(function***REMOVED***s('', %(expressions***REMOVED***s***REMOVED***"
        ***REMOVED***

    def coalesce(self***REMOVED***:
        # null on either side results in null for expression, wrap with coalesce
        c = self.copy(***REMOVED***
        expressions = [
            Coalesce(expression, Value(''***REMOVED******REMOVED*** for expression in c.get_source_expressions(***REMOVED***
        ***REMOVED***
        c.set_source_expressions(expressions***REMOVED***
        return c


class Concat(Func***REMOVED***:
    ***REMOVED***
    Concatenates text fields together. Backends that result in an entire
    null expression when any arguments are null will wrap each argument in
    coalesce functions to ensure we always get a non-null result.
    ***REMOVED***
    function = None
    template = "%(expressions***REMOVED***s"

    def __init__(self, *expressions, **extra***REMOVED***:
        if len(expressions***REMOVED*** < 2:
            raise ValueError('Concat must take at least two expressions'***REMOVED***
        paired = self._paired(expressions***REMOVED***
        super(Concat, self***REMOVED***.__init__(paired, **extra***REMOVED***

    def _paired(self, expressions***REMOVED***:
        # wrap pairs of expressions in successive concat functions
        # exp = [a, b, c, d***REMOVED***
        # -> ConcatPair(a, ConcatPair(b, ConcatPair(c, d***REMOVED******REMOVED******REMOVED******REMOVED***
        if len(expressions***REMOVED*** == 2:
            return ConcatPair(*expressions***REMOVED***
        return ConcatPair(expressions[0***REMOVED***, self._paired(expressions[1:***REMOVED******REMOVED******REMOVED***


class Greatest(Func***REMOVED***:
    ***REMOVED***
    Chooses the maximum expression and returns it.

    If any expression is null the return value is database-specific:
    On Postgres, the maximum not-null expression is returned.
    On MySQL, Oracle, and SQLite, if any expression is null, null is returned.
    ***REMOVED***
    function = 'GREATEST'

    def __init__(self, *expressions, **extra***REMOVED***:
        if len(expressions***REMOVED*** < 2:
            raise ValueError('Greatest must take at least two expressions'***REMOVED***
        super(Greatest, self***REMOVED***.__init__(*expressions, **extra***REMOVED***

    def as_sqlite(self, compiler, connection***REMOVED***:
        ***REMOVED***Use the MAX function on SQLite.***REMOVED***
        return super(Greatest, self***REMOVED***.as_sql(compiler, connection, function='MAX'***REMOVED***


class Least(Func***REMOVED***:
    ***REMOVED***
    Chooses the minimum expression and returns it.

    If any expression is null the return value is database-specific:
    On Postgres, the minimum not-null expression is returned.
    On MySQL, Oracle, and SQLite, if any expression is null, null is returned.
    ***REMOVED***
    function = 'LEAST'

    def __init__(self, *expressions, **extra***REMOVED***:
        if len(expressions***REMOVED*** < 2:
            raise ValueError('Least must take at least two expressions'***REMOVED***
        super(Least, self***REMOVED***.__init__(*expressions, **extra***REMOVED***

    def as_sqlite(self, compiler, connection***REMOVED***:
        ***REMOVED***Use the MIN function on SQLite.***REMOVED***
        return super(Least, self***REMOVED***.as_sql(compiler, connection, function='MIN'***REMOVED***


class Length(Transform***REMOVED***:
    ***REMOVED***Returns the number of characters in the expression***REMOVED***
    function = 'LENGTH'
    lookup_name = 'length'

    def __init__(self, expression, **extra***REMOVED***:
        output_field = extra.pop('output_field', fields.IntegerField(***REMOVED******REMOVED***
        super(Length, self***REMOVED***.__init__(expression, output_field=output_field, **extra***REMOVED***

    def as_mysql(self, compiler, connection***REMOVED***:
        return super(Length, self***REMOVED***.as_sql(compiler, connection, function='CHAR_LENGTH'***REMOVED***


class Lower(Transform***REMOVED***:
    function = 'LOWER'
    lookup_name = 'lower'


class Now(Func***REMOVED***:
    template = 'CURRENT_TIMESTAMP'

    def __init__(self, output_field=None, **extra***REMOVED***:
        if output_field is None:
            output_field = fields.DateTimeField(***REMOVED***
        super(Now, self***REMOVED***.__init__(output_field=output_field, **extra***REMOVED***

    def as_postgresql(self, compiler, connection***REMOVED***:
        # Postgres' CURRENT_TIMESTAMP means "the time at the start of the
        # transaction". We use STATEMENT_TIMESTAMP to be cross-compatible with
        # other databases.
        return self.as_sql(compiler, connection, template='STATEMENT_TIMESTAMP(***REMOVED***'***REMOVED***


class Substr(Func***REMOVED***:
    function = 'SUBSTRING'

    def __init__(self, expression, pos, length=None, **extra***REMOVED***:
        ***REMOVED***
        expression: the name of a field, or an expression returning a string
        pos: an integer > 0, or an expression returning an integer
        length: an optional number of characters to return
        ***REMOVED***
        if not hasattr(pos, 'resolve_expression'***REMOVED***:
            if pos < 1:
                raise ValueError("'pos' must be greater than 0"***REMOVED***
            pos = Value(pos***REMOVED***
        expressions = [expression, pos***REMOVED***
        if length is not None:
            if not hasattr(length, 'resolve_expression'***REMOVED***:
                length = Value(length***REMOVED***
            expressions.append(length***REMOVED***
        super(Substr, self***REMOVED***.__init__(*expressions, **extra***REMOVED***

    def as_sqlite(self, compiler, connection***REMOVED***:
        return super(Substr, self***REMOVED***.as_sql(compiler, connection, function='SUBSTR'***REMOVED***

    def as_oracle(self, compiler, connection***REMOVED***:
        return super(Substr, self***REMOVED***.as_sql(compiler, connection, function='SUBSTR'***REMOVED***


class Upper(Transform***REMOVED***:
    function = 'UPPER'
    lookup_name = 'upper'
