from __future__ import absolute_import

from datetime import datetime

from django.conf import settings
from django.db.models import (
    DateField, DateTimeField, IntegerField, TimeField, Transform,
***REMOVED***
from django.db.models.lookups import (
    YearExact, YearGt, YearGte, YearLt, YearLte,
***REMOVED***
from django.utils import timezone
from django.utils.functional import cached_property


class TimezoneMixin(object***REMOVED***:
    tzinfo = None

    def get_tzname(self***REMOVED***:
        # Timezone conversions must happen to the input datetime *before*
        # applying a function. 2015-12-31 23:00:00 -02:00 is stored in the
        # database as 2016-01-01 01:00:00 +00:00. Any results should be
        # based on the input datetime not the stored datetime.
        tzname = None
        if settings.USE_TZ:
            if self.tzinfo is None:
                tzname = timezone.get_current_timezone_name(***REMOVED***
            else:
                tzname = timezone._get_timezone_name(self.tzinfo***REMOVED***
        return tzname


class Extract(TimezoneMixin, Transform***REMOVED***:
    lookup_name = None

    def __init__(self, expression, lookup_name=None, tzinfo=None, **extra***REMOVED***:
        if self.lookup_name is None:
            self.lookup_name = lookup_name
        if self.lookup_name is None:
            raise ValueError('lookup_name must be provided'***REMOVED***
        self.tzinfo = tzinfo
        super(Extract, self***REMOVED***.__init__(expression, **extra***REMOVED***

    def as_sql(self, compiler, connection***REMOVED***:
        sql, params = compiler.compile(self.lhs***REMOVED***
        lhs_output_field = self.lhs.output_field
        if isinstance(lhs_output_field, DateTimeField***REMOVED***:
            tzname = self.get_tzname(***REMOVED***
            sql, tz_params = connection.ops.datetime_extract_sql(self.lookup_name, sql, tzname***REMOVED***
            params.extend(tz_params***REMOVED***
        elif isinstance(lhs_output_field, DateField***REMOVED***:
            sql = connection.ops.date_extract_sql(self.lookup_name, sql***REMOVED***
        elif isinstance(lhs_output_field, TimeField***REMOVED***:
            sql = connection.ops.time_extract_sql(self.lookup_name, sql***REMOVED***
        else:
            # resolve_expression has already validated the output_field so this
            # assert should never be hit.
            assert False, "Tried to Extract from an invalid type."
        return sql, params

    def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False***REMOVED***:
        copy = super(Extract, self***REMOVED***.resolve_expression(query, allow_joins, reuse, summarize, for_save***REMOVED***
        field = copy.lhs.output_field
        if not isinstance(field, (DateField, DateTimeField, TimeField***REMOVED******REMOVED***:
            raise ValueError('Extract input expression must be DateField, DateTimeField, or TimeField.'***REMOVED***
        # Passing dates to functions expecting datetimes is most likely a mistake.
        if type(field***REMOVED*** == DateField and copy.lookup_name in ('hour', 'minute', 'second'***REMOVED***:
            raise ValueError(
                "Cannot extract time component '%s' from DateField '%s'. " % (copy.lookup_name, field.name***REMOVED***
            ***REMOVED***
        return copy

    @cached_property
    def output_field(self***REMOVED***:
        return IntegerField(***REMOVED***


class ExtractYear(Extract***REMOVED***:
    lookup_name = 'year'


class ExtractMonth(Extract***REMOVED***:
    lookup_name = 'month'


class ExtractDay(Extract***REMOVED***:
    lookup_name = 'day'


class ExtractWeekDay(Extract***REMOVED***:
    ***REMOVED***
    Return Sunday=1 through Saturday=7.

    To replicate this in Python: (mydatetime.isoweekday(***REMOVED*** % 7***REMOVED*** + 1
    ***REMOVED***
    lookup_name = 'week_day'


class ExtractHour(Extract***REMOVED***:
    lookup_name = 'hour'


class ExtractMinute(Extract***REMOVED***:
    lookup_name = 'minute'


class ExtractSecond(Extract***REMOVED***:
    lookup_name = 'second'


DateField.register_lookup(ExtractYear***REMOVED***
DateField.register_lookup(ExtractMonth***REMOVED***
DateField.register_lookup(ExtractDay***REMOVED***
DateField.register_lookup(ExtractWeekDay***REMOVED***

TimeField.register_lookup(ExtractHour***REMOVED***
TimeField.register_lookup(ExtractMinute***REMOVED***
TimeField.register_lookup(ExtractSecond***REMOVED***

DateTimeField.register_lookup(ExtractYear***REMOVED***
DateTimeField.register_lookup(ExtractMonth***REMOVED***
DateTimeField.register_lookup(ExtractDay***REMOVED***
DateTimeField.register_lookup(ExtractWeekDay***REMOVED***
DateTimeField.register_lookup(ExtractHour***REMOVED***
DateTimeField.register_lookup(ExtractMinute***REMOVED***
DateTimeField.register_lookup(ExtractSecond***REMOVED***

ExtractYear.register_lookup(YearExact***REMOVED***
ExtractYear.register_lookup(YearGt***REMOVED***
ExtractYear.register_lookup(YearGte***REMOVED***
ExtractYear.register_lookup(YearLt***REMOVED***
ExtractYear.register_lookup(YearLte***REMOVED***


class TruncBase(TimezoneMixin, Transform***REMOVED***:
    arity = 1
    kind = None
    tzinfo = None

    def __init__(self, expression, output_field=None, tzinfo=None, **extra***REMOVED***:
        self.tzinfo = tzinfo
        super(TruncBase, self***REMOVED***.__init__(expression, output_field=output_field, **extra***REMOVED***

    def as_sql(self, compiler, connection***REMOVED***:
        inner_sql, inner_params = compiler.compile(self.lhs***REMOVED***
        # Escape any params because trunc_sql will format the string.
        inner_sql = inner_sql.replace('%s', '%%s'***REMOVED***
        if isinstance(self.output_field, DateTimeField***REMOVED***:
            tzname = self.get_tzname(***REMOVED***
            sql, params = connection.ops.datetime_trunc_sql(self.kind, inner_sql, tzname***REMOVED***
        elif isinstance(self.output_field, DateField***REMOVED***:
            sql = connection.ops.date_trunc_sql(self.kind, inner_sql***REMOVED***
            params = [***REMOVED***
        else:
            raise ValueError('Trunc only valid on DateField or DateTimeField.'***REMOVED***
        return sql, inner_params + params

    def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False***REMOVED***:
        copy = super(TruncBase, self***REMOVED***.resolve_expression(query, allow_joins, reuse, summarize, for_save***REMOVED***
        field = copy.lhs.output_field
        # DateTimeField is a subclass of DateField so this works for both.
        assert isinstance(field, DateField***REMOVED***, (
            "%r isn't a DateField or DateTimeField." % field.name
        ***REMOVED***
        # If self.output_field was None, then accessing the field will trigger
        # the resolver to assign it to self.lhs.output_field.
        if not isinstance(copy.output_field, (DateField, DateTimeField***REMOVED******REMOVED***:
            raise ValueError('output_field must be either DateField or DateTimeField'***REMOVED***
        # Passing dates to functions expecting datetimes is most likely a
        # mistake.
        if type(field***REMOVED*** == DateField and (
                isinstance(copy.output_field, DateTimeField***REMOVED*** or copy.kind in ('hour', 'minute', 'second'***REMOVED******REMOVED***:
            raise ValueError("Cannot truncate DateField '%s' to DateTimeField. " % field.name***REMOVED***
        return copy

    def convert_value(self, value, expression, connection, context***REMOVED***:
        if isinstance(self.output_field, DateTimeField***REMOVED***:
            if settings.USE_TZ:
                if value is None:
                    raise ValueError(
                        "Database returned an invalid datetime value. "
                        "Are time zone definitions for your database and pytz installed?"
                    ***REMOVED***
                value = value.replace(tzinfo=None***REMOVED***
                value = timezone.make_aware(value, self.tzinfo***REMOVED***
        elif isinstance(value, datetime***REMOVED***:
            # self.output_field is definitely a DateField here.
            value = value.date(***REMOVED***
        return value


class Trunc(TruncBase***REMOVED***:

    def __init__(self, expression, kind, output_field=None, tzinfo=None, **extra***REMOVED***:
        self.kind = kind
        super(Trunc, self***REMOVED***.__init__(expression, output_field=output_field, tzinfo=tzinfo, **extra***REMOVED***


class TruncYear(TruncBase***REMOVED***:
    kind = 'year'


class TruncMonth(TruncBase***REMOVED***:
    kind = 'month'


class TruncDay(TruncBase***REMOVED***:
    kind = 'day'


class TruncDate(TruncBase***REMOVED***:
    lookup_name = 'date'

    @cached_property
    def output_field(self***REMOVED***:
        return DateField(***REMOVED***

    def as_sql(self, compiler, connection***REMOVED***:
        # Cast to date rather than truncate to date.
        lhs, lhs_params = compiler.compile(self.lhs***REMOVED***
        tzname = timezone.get_current_timezone_name(***REMOVED*** if settings.USE_TZ else None
        sql, tz_params = connection.ops.datetime_cast_date_sql(lhs, tzname***REMOVED***
        lhs_params.extend(tz_params***REMOVED***
        return sql, lhs_params


class TruncHour(TruncBase***REMOVED***:
    kind = 'hour'

    @cached_property
    def output_field(self***REMOVED***:
        return DateTimeField(***REMOVED***


class TruncMinute(TruncBase***REMOVED***:
    kind = 'minute'

    @cached_property
    def output_field(self***REMOVED***:
        return DateTimeField(***REMOVED***


class TruncSecond(TruncBase***REMOVED***:
    kind = 'second'

    @cached_property
    def output_field(self***REMOVED***:
        return DateTimeField(***REMOVED***


DateTimeField.register_lookup(TruncDate***REMOVED***
