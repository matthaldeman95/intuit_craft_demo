***REMOVED***
Classes to represent the definitions of aggregate functions.
***REMOVED***
from django.core.exceptions import FieldError
from django.db.models.expressions import Func, Star
from django.db.models.fields import DecimalField, FloatField, IntegerField

__all__ = [
    'Aggregate', 'Avg', 'Count', 'Max', 'Min', 'StdDev', 'Sum', 'Variance',
***REMOVED***


class Aggregate(Func***REMOVED***:
    contains_aggregate = True
    name = None

    def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False***REMOVED***:
        # Aggregates are not allowed in UPDATE queries, so ignore for_save
        c = super(Aggregate, self***REMOVED***.resolve_expression(query, allow_joins, reuse, summarize***REMOVED***
        if not summarize:
            expressions = c.get_source_expressions(***REMOVED***
            for index, expr in enumerate(expressions***REMOVED***:
                if expr.contains_aggregate:
                    before_resolved = self.get_source_expressions(***REMOVED***[index***REMOVED***
                    name = before_resolved.name if hasattr(before_resolved, 'name'***REMOVED*** else repr(before_resolved***REMOVED***
                    raise FieldError("Cannot compute %s('%s'***REMOVED***: '%s' is an aggregate" % (c.name, name, name***REMOVED******REMOVED***
        return c

    @property
    def default_alias(self***REMOVED***:
        expressions = self.get_source_expressions(***REMOVED***
        if len(expressions***REMOVED*** == 1 and hasattr(expressions[0***REMOVED***, 'name'***REMOVED***:
            return '%s__%s' % (expressions[0***REMOVED***.name, self.name.lower(***REMOVED******REMOVED***
        raise TypeError("Complex expressions require an alias"***REMOVED***

    def get_group_by_cols(self***REMOVED***:
        return [***REMOVED***


class Avg(Aggregate***REMOVED***:
    function = 'AVG'
    name = 'Avg'

    def _resolve_output_field(self***REMOVED***:
        source_field = self.get_source_fields(***REMOVED***[0***REMOVED***
        if isinstance(source_field, (IntegerField, DecimalField***REMOVED******REMOVED***:
            self._output_field = FloatField(***REMOVED***
        super(Avg, self***REMOVED***._resolve_output_field(***REMOVED***

    def as_oracle(self, compiler, connection***REMOVED***:
        if self.output_field.get_internal_type(***REMOVED*** == 'DurationField':
            expression = self.get_source_expressions(***REMOVED***[0***REMOVED***
            from django.db.backends.oracle.functions import IntervalToSeconds, SecondsToInterval
            return compiler.compile(
                SecondsToInterval(Avg(IntervalToSeconds(expression***REMOVED******REMOVED******REMOVED***
            ***REMOVED***
        return super(Avg, self***REMOVED***.as_sql(compiler, connection***REMOVED***


class Count(Aggregate***REMOVED***:
    function = 'COUNT'
    name = 'Count'
    template = '%(function***REMOVED***s(%(distinct***REMOVED***s%(expressions***REMOVED***s***REMOVED***'

    def __init__(self, expression, distinct=False, **extra***REMOVED***:
        if expression == '*':
            expression = Star(***REMOVED***
        super(Count, self***REMOVED***.__init__(
            expression, distinct='DISTINCT ' if distinct else '', output_field=IntegerField(***REMOVED***, **extra***REMOVED***

    def __repr__(self***REMOVED***:
        return "{***REMOVED***({***REMOVED***, distinct={***REMOVED******REMOVED***".format(
            self.__class__.__name__,
            self.arg_joiner.join(str(arg***REMOVED*** for arg in self.source_expressions***REMOVED***,
            'False' if self.extra['distinct'***REMOVED*** == '' else 'True',
        ***REMOVED***

    def convert_value(self, value, expression, connection, context***REMOVED***:
        if value is None:
            return 0
        return int(value***REMOVED***


class Max(Aggregate***REMOVED***:
    function = 'MAX'
    name = 'Max'


class Min(Aggregate***REMOVED***:
    function = 'MIN'
    name = 'Min'


class StdDev(Aggregate***REMOVED***:
    name = 'StdDev'

    def __init__(self, expression, sample=False, **extra***REMOVED***:
        self.function = 'STDDEV_SAMP' if sample else 'STDDEV_POP'
        super(StdDev, self***REMOVED***.__init__(expression, output_field=FloatField(***REMOVED***, **extra***REMOVED***

    def __repr__(self***REMOVED***:
        return "{***REMOVED***({***REMOVED***, sample={***REMOVED******REMOVED***".format(
            self.__class__.__name__,
            self.arg_joiner.join(str(arg***REMOVED*** for arg in self.source_expressions***REMOVED***,
            'False' if self.function == 'STDDEV_POP' else 'True',
        ***REMOVED***

    def convert_value(self, value, expression, connection, context***REMOVED***:
        if value is None:
            return value
        return float(value***REMOVED***


class Sum(Aggregate***REMOVED***:
    function = 'SUM'
    name = 'Sum'

    def as_oracle(self, compiler, connection***REMOVED***:
        if self.output_field.get_internal_type(***REMOVED*** == 'DurationField':
            expression = self.get_source_expressions(***REMOVED***[0***REMOVED***
            from django.db.backends.oracle.functions import IntervalToSeconds, SecondsToInterval
            return compiler.compile(
                SecondsToInterval(Sum(IntervalToSeconds(expression***REMOVED******REMOVED******REMOVED***
            ***REMOVED***
        return super(Sum, self***REMOVED***.as_sql(compiler, connection***REMOVED***


class Variance(Aggregate***REMOVED***:
    name = 'Variance'

    def __init__(self, expression, sample=False, **extra***REMOVED***:
        self.function = 'VAR_SAMP' if sample else 'VAR_POP'
        super(Variance, self***REMOVED***.__init__(expression, output_field=FloatField(***REMOVED***, **extra***REMOVED***

    def __repr__(self***REMOVED***:
        return "{***REMOVED***({***REMOVED***, sample={***REMOVED******REMOVED***".format(
            self.__class__.__name__,
            self.arg_joiner.join(str(arg***REMOVED*** for arg in self.source_expressions***REMOVED***,
            'False' if self.function == 'VAR_POP' else 'True',
        ***REMOVED***

    def convert_value(self, value, expression, connection, context***REMOVED***:
        if value is None:
            return value
        return float(value***REMOVED***
