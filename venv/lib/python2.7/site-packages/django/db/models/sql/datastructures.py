***REMOVED***
Useful auxiliary data structures for query construction. Not useful outside
the SQL domain.
***REMOVED***
from django.db.models.sql.constants import INNER, LOUTER


class EmptyResultSet(Exception***REMOVED***:
    pass


class MultiJoin(Exception***REMOVED***:
    ***REMOVED***
    Used by join construction code to indicate the point at which a
    multi-valued join was attempted (if the caller wants to treat that
    exceptionally***REMOVED***.
    ***REMOVED***
    def __init__(self, names_pos, path_with_names***REMOVED***:
        self.level = names_pos
        # The path travelled, this includes the path to the multijoin.
        self.names_with_path = path_with_names


class Empty(object***REMOVED***:
    pass


class Join(object***REMOVED***:
    ***REMOVED***
    Used by sql.Query and sql.SQLCompiler to generate JOIN clauses into the
    FROM entry. For example, the SQL generated could be
        LEFT OUTER JOIN "sometable" T1 ON ("othertable"."sometable_id" = "sometable"."id"***REMOVED***

    This class is primarily used in Query.alias_map. All entries in alias_map
    must be Join compatible by providing the following attributes and methods:
        - table_name (string***REMOVED***
        - table_alias (possible alias for the table, can be None***REMOVED***
        - join_type (can be None for those entries that aren't joined from
          anything***REMOVED***
        - parent_alias (which table is this join's parent, can be None similarly
          to join_type***REMOVED***
        - as_sql(***REMOVED***
        - relabeled_clone(***REMOVED***
    ***REMOVED***
    def __init__(self, table_name, parent_alias, table_alias, join_type,
                 join_field, nullable***REMOVED***:
        # Join table
        self.table_name = table_name
        self.parent_alias = parent_alias
        # Note: table_alias is not necessarily known at instantiation time.
        self.table_alias = table_alias
        # LOUTER or INNER
        self.join_type = join_type
        # A list of 2-tuples to use in the ON clause of the JOIN.
        # Each 2-tuple will create one join condition in the ON clause.
        self.join_cols = join_field.get_joining_columns(***REMOVED***
        # Along which field (or ForeignObjectRel in the reverse join case***REMOVED***
        self.join_field = join_field
        # Is this join nullabled?
        self.nullable = nullable

    def as_sql(self, compiler, connection***REMOVED***:
        ***REMOVED***
        Generates the full
           LEFT OUTER JOIN sometable ON sometable.somecol = othertable.othercol, params
        clause for this join.
        ***REMOVED***
        join_conditions = [***REMOVED***
        params = [***REMOVED***
        qn = compiler.quote_name_unless_alias
        qn2 = connection.ops.quote_name

        # Add a join condition for each pair of joining columns.
        for index, (lhs_col, rhs_col***REMOVED*** in enumerate(self.join_cols***REMOVED***:
            join_conditions.append('%s.%s = %s.%s' % (
                qn(self.parent_alias***REMOVED***,
                qn2(lhs_col***REMOVED***,
                qn(self.table_alias***REMOVED***,
                qn2(rhs_col***REMOVED***,
            ***REMOVED******REMOVED***

        # Add a single condition inside parentheses for whatever
        # get_extra_restriction(***REMOVED*** returns.
        extra_cond = self.join_field.get_extra_restriction(
            compiler.query.where_class, self.table_alias, self.parent_alias***REMOVED***
        if extra_cond:
            extra_sql, extra_params = compiler.compile(extra_cond***REMOVED***
            join_conditions.append('(%s***REMOVED***' % extra_sql***REMOVED***
            params.extend(extra_params***REMOVED***

        if not join_conditions:
            # This might be a rel on the other end of an actual declared field.
            declared_field = getattr(self.join_field, 'field', self.join_field***REMOVED***
            raise ValueError(
                "Join generated an empty ON clause. %s did not yield either "
                "joining columns or extra restrictions." % declared_field.__class__
            ***REMOVED***
        on_clause_sql = ' AND '.join(join_conditions***REMOVED***
        alias_str = '' if self.table_alias == self.table_name else (' %s' % self.table_alias***REMOVED***
        sql = '%s %s%s ON (%s***REMOVED***' % (self.join_type, qn(self.table_name***REMOVED***, alias_str, on_clause_sql***REMOVED***
        return sql, params

    def relabeled_clone(self, change_map***REMOVED***:
        new_parent_alias = change_map.get(self.parent_alias, self.parent_alias***REMOVED***
        new_table_alias = change_map.get(self.table_alias, self.table_alias***REMOVED***
        return self.__class__(
            self.table_name, new_parent_alias, new_table_alias, self.join_type,
            self.join_field, self.nullable***REMOVED***

    def __eq__(self, other***REMOVED***:
        if isinstance(other, self.__class__***REMOVED***:
            return (
                self.table_name == other.table_name and
                self.parent_alias == other.parent_alias and
                self.join_field == other.join_field
            ***REMOVED***
        return False

    def demote(self***REMOVED***:
        new = self.relabeled_clone({***REMOVED******REMOVED***
        new.join_type = INNER
        return new

    def promote(self***REMOVED***:
        new = self.relabeled_clone({***REMOVED******REMOVED***
        new.join_type = LOUTER
        return new


class BaseTable(object***REMOVED***:
    ***REMOVED***
    The BaseTable class is used for base table references in FROM clause. For
    example, the SQL "foo" in
        SELECT * FROM "foo" WHERE somecond
    could be generated by this class.
    ***REMOVED***
    join_type = None
    parent_alias = None

    def __init__(self, table_name, alias***REMOVED***:
        self.table_name = table_name
        self.table_alias = alias

    def as_sql(self, compiler, connection***REMOVED***:
        alias_str = '' if self.table_alias == self.table_name else (' %s' % self.table_alias***REMOVED***
        base_sql = compiler.quote_name_unless_alias(self.table_name***REMOVED***
        return base_sql + alias_str, [***REMOVED***

    def relabeled_clone(self, change_map***REMOVED***:
        return self.__class__(self.table_name, change_map.get(self.table_alias, self.table_alias***REMOVED******REMOVED***
