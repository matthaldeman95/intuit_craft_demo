***REMOVED***
Query subclasses which provide extra functionality beyond simple data retrieval.
***REMOVED***

from django.core.exceptions import FieldError
from django.db import connections
from django.db.models.query_utils import Q
from django.db.models.sql.constants import (
    CURSOR, GET_ITERATOR_CHUNK_SIZE, NO_RESULTS,
***REMOVED***
from django.db.models.sql.query import Query
from django.utils import six

__all__ = ['DeleteQuery', 'UpdateQuery', 'InsertQuery', 'AggregateQuery'***REMOVED***


class DeleteQuery(Query***REMOVED***:
    ***REMOVED***
    Delete queries are done through this class, since they are more constrained
    than general queries.
    ***REMOVED***

    compiler = 'SQLDeleteCompiler'

    def do_query(self, table, where, using***REMOVED***:
        self.tables = [table***REMOVED***
        self.where = where
        cursor = self.get_compiler(using***REMOVED***.execute_sql(CURSOR***REMOVED***
        return cursor.rowcount if cursor else 0

    def delete_batch(self, pk_list, using, field=None***REMOVED***:
        ***REMOVED***
        Set up and execute delete queries for all the objects in pk_list.

        More than one physical query may be executed if there are a
        lot of values in pk_list.
        ***REMOVED***
        # number of objects deleted
        num_deleted = 0
        if not field:
            field = self.get_meta(***REMOVED***.pk
        for offset in range(0, len(pk_list***REMOVED***, GET_ITERATOR_CHUNK_SIZE***REMOVED***:
            self.where = self.where_class(***REMOVED***
            self.add_q(Q(
                **{field.attname + '__in': pk_list[offset:offset + GET_ITERATOR_CHUNK_SIZE***REMOVED******REMOVED******REMOVED******REMOVED***
            num_deleted += self.do_query(self.get_meta(***REMOVED***.db_table, self.where, using=using***REMOVED***
        return num_deleted

    def delete_qs(self, query, using***REMOVED***:
        ***REMOVED***
        Delete the queryset in one SQL query (if possible***REMOVED***. For simple queries
        this is done by copying the query.query.where to self.query, for
        complex queries by using subquery.
        ***REMOVED***
        innerq = query.query
        # Make sure the inner query has at least one table in use.
        innerq.get_initial_alias(***REMOVED***
        # The same for our new query.
        self.get_initial_alias(***REMOVED***
        innerq_used_tables = [t for t in innerq.tables
                              if innerq.alias_refcount[t***REMOVED******REMOVED***
        if not innerq_used_tables or innerq_used_tables == self.tables:
            # There is only the base table in use in the query.
            self.where = innerq.where
        else:
            pk = query.model._meta.pk
            if not connections[using***REMOVED***.features.update_can_self_select:
                # We can't do the delete using subquery.
                values = list(query.values_list('pk', flat=True***REMOVED******REMOVED***
                if not values:
                    return 0
                return self.delete_batch(values, using***REMOVED***
            else:
                innerq.clear_select_clause(***REMOVED***
                innerq.select = [
                    pk.get_col(self.get_initial_alias(***REMOVED******REMOVED***
                ***REMOVED***
                values = innerq
            self.where = self.where_class(***REMOVED***
            self.add_q(Q(pk__in=values***REMOVED******REMOVED***
        cursor = self.get_compiler(using***REMOVED***.execute_sql(CURSOR***REMOVED***
        return cursor.rowcount if cursor else 0


class UpdateQuery(Query***REMOVED***:
    ***REMOVED***
    Represents an "update" SQL query.
    ***REMOVED***

    compiler = 'SQLUpdateCompiler'

    def __init__(self, *args, **kwargs***REMOVED***:
        super(UpdateQuery, self***REMOVED***.__init__(*args, **kwargs***REMOVED***
        self._setup_query(***REMOVED***

    def _setup_query(self***REMOVED***:
        ***REMOVED***
        Runs on initialization and after cloning. Any attributes that would
        normally be set in __init__ should go in here, instead, so that they
        are also set up after a clone(***REMOVED*** call.
        ***REMOVED***
        self.values = [***REMOVED***
        self.related_ids = None
        if not hasattr(self, 'related_updates'***REMOVED***:
            self.related_updates = {***REMOVED***

    def clone(self, klass=None, **kwargs***REMOVED***:
        return super(UpdateQuery, self***REMOVED***.clone(klass, related_updates=self.related_updates.copy(***REMOVED***, **kwargs***REMOVED***

    def update_batch(self, pk_list, values, using***REMOVED***:
        self.add_update_values(values***REMOVED***
        for offset in range(0, len(pk_list***REMOVED***, GET_ITERATOR_CHUNK_SIZE***REMOVED***:
            self.where = self.where_class(***REMOVED***
            self.add_q(Q(pk__in=pk_list[offset: offset + GET_ITERATOR_CHUNK_SIZE***REMOVED******REMOVED******REMOVED***
            self.get_compiler(using***REMOVED***.execute_sql(NO_RESULTS***REMOVED***

    def add_update_values(self, values***REMOVED***:
        ***REMOVED***
        Convert a dictionary of field name to value mappings into an update
        query. This is the entry point for the public update(***REMOVED*** method on
        querysets.
        ***REMOVED***
        values_seq = [***REMOVED***
        for name, val in six.iteritems(values***REMOVED***:
            field = self.get_meta(***REMOVED***.get_field(name***REMOVED***
            direct = not (field.auto_created and not field.concrete***REMOVED*** or not field.concrete
            model = field.model._meta.concrete_model
            if not direct or (field.is_relation and field.many_to_many***REMOVED***:
                raise FieldError(
                    'Cannot update model field %r (only non-relations and '
                    'foreign keys permitted***REMOVED***.' % field
                ***REMOVED***
            if model is not self.get_meta(***REMOVED***.model:
                self.add_related_update(model, field, val***REMOVED***
                continue
            values_seq.append((field, model, val***REMOVED******REMOVED***
        return self.add_update_fields(values_seq***REMOVED***

    def add_update_fields(self, values_seq***REMOVED***:
        ***REMOVED***
        Append a sequence of (field, model, value***REMOVED*** triples to the internal list
        that will be used to generate the UPDATE query. Might be more usefully
        called add_update_targets(***REMOVED*** to hint at the extra information here.
        ***REMOVED***
        self.values.extend(values_seq***REMOVED***

    def add_related_update(self, model, field, value***REMOVED***:
        ***REMOVED***
        Adds (name, value***REMOVED*** to an update query for an ancestor model.

        Updates are coalesced so that we only run one update query per ancestor.
        ***REMOVED***
        self.related_updates.setdefault(model, [***REMOVED******REMOVED***.append((field, None, value***REMOVED******REMOVED***

    def get_related_updates(self***REMOVED***:
        ***REMOVED***
        Returns a list of query objects: one for each update required to an
        ancestor model. Each query will have the same filtering conditions as
        the current query but will only update a single table.
        ***REMOVED***
        if not self.related_updates:
            return [***REMOVED***
        result = [***REMOVED***
        for model, values in six.iteritems(self.related_updates***REMOVED***:
            query = UpdateQuery(model***REMOVED***
            query.values = values
            if self.related_ids is not None:
                query.add_filter(('pk__in', self.related_ids***REMOVED******REMOVED***
            result.append(query***REMOVED***
        return result


class InsertQuery(Query***REMOVED***:
    compiler = 'SQLInsertCompiler'

    def __init__(self, *args, **kwargs***REMOVED***:
        super(InsertQuery, self***REMOVED***.__init__(*args, **kwargs***REMOVED***
        self.fields = [***REMOVED***
        self.objs = [***REMOVED***

    def clone(self, klass=None, **kwargs***REMOVED***:
        extras = {
            'fields': self.fields[:***REMOVED***,
            'objs': self.objs[:***REMOVED***,
            'raw': self.raw,
    ***REMOVED***
        extras.update(kwargs***REMOVED***
        return super(InsertQuery, self***REMOVED***.clone(klass, **extras***REMOVED***

    def insert_values(self, fields, objs, raw=False***REMOVED***:
        ***REMOVED***
        Set up the insert query from the 'insert_values' dictionary. The
        dictionary gives the model field names and their target values.

        If 'raw_values' is True, the values in the 'insert_values' dictionary
        are inserted directly into the query, rather than passed as SQL
        parameters. This provides a way to insert NULL and DEFAULT keywords
        into the query, for example.
        ***REMOVED***
        self.fields = fields
        self.objs = objs
        self.raw = raw


class AggregateQuery(Query***REMOVED***:
    ***REMOVED***
    An AggregateQuery takes another query as a parameter to the FROM
    clause and only selects the elements in the provided list.
    ***REMOVED***

    compiler = 'SQLAggregateCompiler'

    def add_subquery(self, query, using***REMOVED***:
        self.subquery, self.sub_params = query.get_compiler(using***REMOVED***.as_sql(
            with_col_aliases=True,
            subquery=True,
        ***REMOVED***
