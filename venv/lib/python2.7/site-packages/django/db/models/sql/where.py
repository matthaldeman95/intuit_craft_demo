***REMOVED***
Code to manage the creation and SQL rendering of 'where' constraints.
***REMOVED***

from django.db.models.sql.datastructures import EmptyResultSet
from django.utils import tree
from django.utils.functional import cached_property

# Connection types
AND = 'AND'
OR = 'OR'


class WhereNode(tree.Node***REMOVED***:
    ***REMOVED***
    Used to represent the SQL where-clause.

    The class is tied to the Query class that created it (in order to create
    the correct SQL***REMOVED***.

    A child is usually an expression producing boolean values. Most likely the
    expression is a Lookup instance.

    However, a child could also be any class with as_sql(***REMOVED*** and either
    relabeled_clone(***REMOVED*** method or relabel_aliases(***REMOVED*** and clone(***REMOVED*** methods and
    contains_aggregate attribute.
    ***REMOVED***
    default = AND

    def split_having(self, negated=False***REMOVED***:
        ***REMOVED***
        Returns two possibly None nodes: one for those parts of self that
        should be included in the WHERE clause and one for those parts of
        self that must be included in the HAVING clause.
        ***REMOVED***
        if not self.contains_aggregate:
            return self, None
        in_negated = negated ^ self.negated
        # If the effective connector is OR and this node contains an aggregate,
        # then we need to push the whole branch to HAVING clause.
        may_need_split = (
            (in_negated and self.connector == AND***REMOVED*** or
            (not in_negated and self.connector == OR***REMOVED******REMOVED***
        if may_need_split and self.contains_aggregate:
            return None, self
        where_parts = [***REMOVED***
        having_parts = [***REMOVED***
        for c in self.children:
            if hasattr(c, 'split_having'***REMOVED***:
                where_part, having_part = c.split_having(in_negated***REMOVED***
                if where_part is not None:
                    where_parts.append(where_part***REMOVED***
                if having_part is not None:
                    having_parts.append(having_part***REMOVED***
            elif c.contains_aggregate:
                having_parts.append(c***REMOVED***
            else:
                where_parts.append(c***REMOVED***
        having_node = self.__class__(having_parts, self.connector, self.negated***REMOVED*** if having_parts else None
        where_node = self.__class__(where_parts, self.connector, self.negated***REMOVED*** if where_parts else None
        return where_node, having_node

    def as_sql(self, compiler, connection***REMOVED***:
        ***REMOVED***
        Returns the SQL version of the where clause and the value to be
        substituted in. Returns '', [***REMOVED*** if this node matches everything,
        None, [***REMOVED*** if this node is empty, and raises EmptyResultSet if this
        node can't match anything.
        ***REMOVED***
        result = [***REMOVED***
        result_params = [***REMOVED***
        if self.connector == AND:
            full_needed, empty_needed = len(self.children***REMOVED***, 1
        else:
            full_needed, empty_needed = 1, len(self.children***REMOVED***

        for child in self.children:
            ***REMOVED***
                sql, params = compiler.compile(child***REMOVED***
            except EmptyResultSet:
                empty_needed -= 1
            else:
                if sql:
                    result.append(sql***REMOVED***
                    result_params.extend(params***REMOVED***
                else:
                    full_needed -= 1
            # Check if this node matches nothing or everything.
            # First check the amount of full nodes and empty nodes
            # to make this node empty/full.
            # Now, check if this node is full/empty using the
            # counts.
            if empty_needed == 0:
                if self.negated:
                    return '', [***REMOVED***
                else:
                    raise EmptyResultSet
            if full_needed == 0:
                if self.negated:
                    raise EmptyResultSet
                else:
                    return '', [***REMOVED***
        conn = ' %s ' % self.connector
        sql_string = conn.join(result***REMOVED***
        if sql_string:
            if self.negated:
                # Some backends (Oracle at least***REMOVED*** need parentheses
                # around the inner SQL in the negated case, even if the
                # inner SQL contains just a single expression.
                sql_string = 'NOT (%s***REMOVED***' % sql_string
            elif len(result***REMOVED*** > 1:
                sql_string = '(%s***REMOVED***' % sql_string
        return sql_string, result_params

    def get_group_by_cols(self***REMOVED***:
        cols = [***REMOVED***
        for child in self.children:
            cols.extend(child.get_group_by_cols(***REMOVED******REMOVED***
        return cols

    def relabel_aliases(self, change_map***REMOVED***:
        ***REMOVED***
        Relabels the alias values of any children. 'change_map' is a dictionary
        mapping old (current***REMOVED*** alias values to the new values.
        ***REMOVED***
        for pos, child in enumerate(self.children***REMOVED***:
            if hasattr(child, 'relabel_aliases'***REMOVED***:
                # For example another WhereNode
                child.relabel_aliases(change_map***REMOVED***
            elif hasattr(child, 'relabeled_clone'***REMOVED***:
                self.children[pos***REMOVED*** = child.relabeled_clone(change_map***REMOVED***

    def clone(self***REMOVED***:
        ***REMOVED***
        Creates a clone of the tree. Must only be called on root nodes (nodes
        with empty subtree_parents***REMOVED***. Childs must be either (Contraint, lookup,
        value***REMOVED*** tuples, or objects supporting .clone(***REMOVED***.
        ***REMOVED***
        clone = self.__class__._new_instance(
            children=[***REMOVED***, connector=self.connector, negated=self.negated***REMOVED***
        for child in self.children:
            if hasattr(child, 'clone'***REMOVED***:
                clone.children.append(child.clone(***REMOVED******REMOVED***
            else:
                clone.children.append(child***REMOVED***
        return clone

    def relabeled_clone(self, change_map***REMOVED***:
        clone = self.clone(***REMOVED***
        clone.relabel_aliases(change_map***REMOVED***
        return clone

    @classmethod
    def _contains_aggregate(cls, obj***REMOVED***:
        if isinstance(obj, tree.Node***REMOVED***:
            return any(cls._contains_aggregate(c***REMOVED*** for c in obj.children***REMOVED***
        return obj.contains_aggregate

    @cached_property
    def contains_aggregate(self***REMOVED***:
        return self._contains_aggregate(self***REMOVED***


class NothingNode(object***REMOVED***:
    ***REMOVED***
    A node that matches nothing.
    ***REMOVED***
    contains_aggregate = False

    def as_sql(self, compiler=None, connection=None***REMOVED***:
        raise EmptyResultSet


class ExtraWhere(object***REMOVED***:
    # The contents are a black box - assume no aggregates are used.
    contains_aggregate = False

    def __init__(self, sqls, params***REMOVED***:
        self.sqls = sqls
        self.params = params

    def as_sql(self, compiler=None, connection=None***REMOVED***:
        sqls = ["(%s***REMOVED***" % sql for sql in self.sqls***REMOVED***
        return " AND ".join(sqls***REMOVED***, list(self.params or (***REMOVED******REMOVED***


class SubqueryConstraint(object***REMOVED***:
    # Even if aggregates would be used in a subquery, the outer query isn't
    # interested about those.
    contains_aggregate = False

    def __init__(self, alias, columns, targets, query_object***REMOVED***:
        self.alias = alias
        self.columns = columns
        self.targets = targets
        self.query_object = query_object

    def as_sql(self, compiler, connection***REMOVED***:
        query = self.query_object

        # QuerySet was sent
        if hasattr(query, 'values'***REMOVED***:
            if query._db and connection.alias != query._db:
                raise ValueError("Can't do subqueries with queries on different DBs."***REMOVED***
            # Do not override already existing values.
            if query._fields is None:
                query = query.values(*self.targets***REMOVED***
            else:
                query = query._clone(***REMOVED***
            query = query.query
            if query.can_filter(***REMOVED***:
                # If there is no slicing in use, then we can safely drop all ordering
                query.clear_ordering(True***REMOVED***

        query_compiler = query.get_compiler(connection=connection***REMOVED***
        return query_compiler.as_subquery_condition(self.alias, self.columns, compiler***REMOVED***

    def relabel_aliases(self, change_map***REMOVED***:
        self.alias = change_map.get(self.alias, self.alias***REMOVED***

    def clone(self***REMOVED***:
        return self.__class__(
            self.alias, self.columns, self.targets,
            self.query_object***REMOVED***
