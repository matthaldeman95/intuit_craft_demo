import math
import warnings
from copy import copy

from django.db.models.expressions import Func, Value
from django.db.models.fields import DateTimeField, Field, IntegerField
from django.db.models.query_utils import RegisterLookupMixin
from django.utils.deprecation import RemovedInDjango20Warning
from django.utils.functional import cached_property
from django.utils.six.moves import range


class Lookup(object***REMOVED***:
    lookup_name = None
    prepare_rhs = True

    def __init__(self, lhs, rhs***REMOVED***:
        self.lhs, self.rhs = lhs, rhs
        self.rhs = self.get_prep_lookup(***REMOVED***
        if hasattr(self.lhs, 'get_bilateral_transforms'***REMOVED***:
            bilateral_transforms = self.lhs.get_bilateral_transforms(***REMOVED***
        else:
            bilateral_transforms = [***REMOVED***
        if bilateral_transforms:
            # Warn the user as soon as possible if they are trying to apply
            # a bilateral transformation on a nested QuerySet: that won't work.
            # We need to import QuerySet here so as to avoid circular
            from django.db.models.query import QuerySet
            if isinstance(rhs, QuerySet***REMOVED***:
                raise NotImplementedError("Bilateral transformations on nested querysets are not supported."***REMOVED***
        self.bilateral_transforms = bilateral_transforms

    def apply_bilateral_transforms(self, value***REMOVED***:
        for transform in self.bilateral_transforms:
            value = transform(value***REMOVED***
        return value

    def batch_process_rhs(self, compiler, connection, rhs=None***REMOVED***:
        if rhs is None:
            rhs = self.rhs
        if self.bilateral_transforms:
            sqls, sqls_params = [***REMOVED***, [***REMOVED***
            for p in rhs:
                value = Value(p, output_field=self.lhs.output_field***REMOVED***
                value = self.apply_bilateral_transforms(value***REMOVED***
                value = value.resolve_expression(compiler.query***REMOVED***
                sql, sql_params = compiler.compile(value***REMOVED***
                sqls.append(sql***REMOVED***
                sqls_params.extend(sql_params***REMOVED***
        else:
            _, params = self.get_db_prep_lookup(rhs, connection***REMOVED***
            sqls, sqls_params = ['%s'***REMOVED*** * len(params***REMOVED***, params
        return sqls, sqls_params

    def get_prep_lookup(self***REMOVED***:
        if hasattr(self.rhs, '_prepare'***REMOVED***:
            return self.rhs._prepare(self.lhs.output_field***REMOVED***
        if self.prepare_rhs and hasattr(self.lhs.output_field, 'get_prep_value'***REMOVED***:
            return self.lhs.output_field.get_prep_value(self.rhs***REMOVED***
        return self.rhs

    def get_db_prep_lookup(self, value, connection***REMOVED***:
        return ('%s', [value***REMOVED******REMOVED***

    def process_lhs(self, compiler, connection, lhs=None***REMOVED***:
        lhs = lhs or self.lhs
        return compiler.compile(lhs***REMOVED***

    def process_rhs(self, compiler, connection***REMOVED***:
        value = self.rhs
        if self.bilateral_transforms:
            if self.rhs_is_direct_value(***REMOVED***:
                # Do not call get_db_prep_lookup here as the value will be
                # transformed before being used for lookup
                value = Value(value, output_field=self.lhs.output_field***REMOVED***
            value = self.apply_bilateral_transforms(value***REMOVED***
            value = value.resolve_expression(compiler.query***REMOVED***
        # Due to historical reasons there are a couple of different
        # ways to produce sql here. get_compiler is likely a Query
        # instance, _as_sql QuerySet and as_sql just something with
        # as_sql. Finally the value can of course be just plain
        # Python value.
        if hasattr(value, 'get_compiler'***REMOVED***:
            value = value.get_compiler(connection=connection***REMOVED***
        if hasattr(value, 'as_sql'***REMOVED***:
            sql, params = compiler.compile(value***REMOVED***
            return '(' + sql + '***REMOVED***', params
        if hasattr(value, '_as_sql'***REMOVED***:
            sql, params = value._as_sql(connection=connection***REMOVED***
            return '(' + sql + '***REMOVED***', params
        else:
            return self.get_db_prep_lookup(value, connection***REMOVED***

    def rhs_is_direct_value(self***REMOVED***:
        return not(
            hasattr(self.rhs, 'as_sql'***REMOVED*** or
            hasattr(self.rhs, '_as_sql'***REMOVED*** or
            hasattr(self.rhs, 'get_compiler'***REMOVED******REMOVED***

    def relabeled_clone(self, relabels***REMOVED***:
        new = copy(self***REMOVED***
        new.lhs = new.lhs.relabeled_clone(relabels***REMOVED***
        if hasattr(new.rhs, 'relabeled_clone'***REMOVED***:
            new.rhs = new.rhs.relabeled_clone(relabels***REMOVED***
        return new

    def get_group_by_cols(self***REMOVED***:
        cols = self.lhs.get_group_by_cols(***REMOVED***
        if hasattr(self.rhs, 'get_group_by_cols'***REMOVED***:
            cols.extend(self.rhs.get_group_by_cols(***REMOVED******REMOVED***
        return cols

    def as_sql(self, compiler, connection***REMOVED***:
        raise NotImplementedError

    @cached_property
    def contains_aggregate(self***REMOVED***:
        return self.lhs.contains_aggregate or getattr(self.rhs, 'contains_aggregate', False***REMOVED***


class Transform(RegisterLookupMixin, Func***REMOVED***:
    ***REMOVED***
    RegisterLookupMixin(***REMOVED*** is first so that get_lookup(***REMOVED*** and get_transform(***REMOVED***
    first examine self and then check output_field.
    ***REMOVED***
    bilateral = False
    arity = 1

    @property
    def lhs(self***REMOVED***:
        return self.get_source_expressions(***REMOVED***[0***REMOVED***

    def get_bilateral_transforms(self***REMOVED***:
        if hasattr(self.lhs, 'get_bilateral_transforms'***REMOVED***:
            bilateral_transforms = self.lhs.get_bilateral_transforms(***REMOVED***
        else:
            bilateral_transforms = [***REMOVED***
        if self.bilateral:
            bilateral_transforms.append(self.__class__***REMOVED***
        return bilateral_transforms


class BuiltinLookup(Lookup***REMOVED***:
    def process_lhs(self, compiler, connection, lhs=None***REMOVED***:
        lhs_sql, params = super(BuiltinLookup, self***REMOVED***.process_lhs(
            compiler, connection, lhs***REMOVED***
        field_internal_type = self.lhs.output_field.get_internal_type(***REMOVED***
        db_type = self.lhs.output_field.db_type(connection=connection***REMOVED***
        lhs_sql = connection.ops.field_cast_sql(
            db_type, field_internal_type***REMOVED*** % lhs_sql
        lhs_sql = connection.ops.lookup_cast(self.lookup_name, field_internal_type***REMOVED*** % lhs_sql
        return lhs_sql, list(params***REMOVED***

    def as_sql(self, compiler, connection***REMOVED***:
        lhs_sql, params = self.process_lhs(compiler, connection***REMOVED***
        rhs_sql, rhs_params = self.process_rhs(compiler, connection***REMOVED***
        params.extend(rhs_params***REMOVED***
        rhs_sql = self.get_rhs_op(connection, rhs_sql***REMOVED***
        return '%s %s' % (lhs_sql, rhs_sql***REMOVED***, params

    def get_rhs_op(self, connection, rhs***REMOVED***:
        return connection.operators[self.lookup_name***REMOVED*** % rhs


class FieldGetDbPrepValueMixin(object***REMOVED***:
    ***REMOVED***
    Some lookups require Field.get_db_prep_value(***REMOVED*** to be called on their
    inputs.
    ***REMOVED***
    get_db_prep_lookup_value_is_iterable = False

    def get_db_prep_lookup(self, value, connection***REMOVED***:
        # For relational fields, use the output_field of the 'field' attribute.
        field = getattr(self.lhs.output_field, 'field', None***REMOVED***
        get_db_prep_value = getattr(field, 'get_db_prep_value', None***REMOVED***
        if not get_db_prep_value:
            get_db_prep_value = self.lhs.output_field.get_db_prep_value
        return (
            '%s',
            [get_db_prep_value(v, connection, prepared=True***REMOVED*** for v in value***REMOVED***
            if self.get_db_prep_lookup_value_is_iterable else
            [get_db_prep_value(value, connection, prepared=True***REMOVED******REMOVED***
        ***REMOVED***


class FieldGetDbPrepValueIterableMixin(FieldGetDbPrepValueMixin***REMOVED***:
    ***REMOVED***
    Some lookups require Field.get_db_prep_value(***REMOVED*** to be called on each value
    in an iterable.
    ***REMOVED***
    get_db_prep_lookup_value_is_iterable = True


class Exact(FieldGetDbPrepValueMixin, BuiltinLookup***REMOVED***:
    lookup_name = 'exact'
Field.register_lookup(Exact***REMOVED***


class IExact(BuiltinLookup***REMOVED***:
    lookup_name = 'iexact'
    prepare_rhs = False

    def process_rhs(self, qn, connection***REMOVED***:
        rhs, params = super(IExact, self***REMOVED***.process_rhs(qn, connection***REMOVED***
        if params:
            params[0***REMOVED*** = connection.ops.prep_for_iexact_query(params[0***REMOVED******REMOVED***
        return rhs, params


Field.register_lookup(IExact***REMOVED***


class GreaterThan(FieldGetDbPrepValueMixin, BuiltinLookup***REMOVED***:
    lookup_name = 'gt'
Field.register_lookup(GreaterThan***REMOVED***


class GreaterThanOrEqual(FieldGetDbPrepValueMixin, BuiltinLookup***REMOVED***:
    lookup_name = 'gte'
Field.register_lookup(GreaterThanOrEqual***REMOVED***


class LessThan(FieldGetDbPrepValueMixin, BuiltinLookup***REMOVED***:
    lookup_name = 'lt'
Field.register_lookup(LessThan***REMOVED***


class LessThanOrEqual(FieldGetDbPrepValueMixin, BuiltinLookup***REMOVED***:
    lookup_name = 'lte'
Field.register_lookup(LessThanOrEqual***REMOVED***


class IntegerFieldFloatRounding(object***REMOVED***:
    ***REMOVED***
    Allow floats to work as query values for IntegerField. Without this, the
    decimal portion of the float would always be discarded.
    ***REMOVED***
    def get_prep_lookup(self***REMOVED***:
        if isinstance(self.rhs, float***REMOVED***:
            self.rhs = math.ceil(self.rhs***REMOVED***
        return super(IntegerFieldFloatRounding, self***REMOVED***.get_prep_lookup(***REMOVED***


class IntegerGreaterThanOrEqual(IntegerFieldFloatRounding, GreaterThanOrEqual***REMOVED***:
    pass
IntegerField.register_lookup(IntegerGreaterThanOrEqual***REMOVED***


class IntegerLessThan(IntegerFieldFloatRounding, LessThan***REMOVED***:
    pass
IntegerField.register_lookup(IntegerLessThan***REMOVED***


class In(FieldGetDbPrepValueIterableMixin, BuiltinLookup***REMOVED***:
    lookup_name = 'in'

    def get_prep_lookup(self***REMOVED***:
        if hasattr(self.rhs, '_prepare'***REMOVED***:
            return self.rhs._prepare(self.lhs.output_field***REMOVED***
        if hasattr(self.lhs.output_field, 'get_prep_value'***REMOVED***:
            return [self.lhs.output_field.get_prep_value(v***REMOVED*** for v in self.rhs***REMOVED***
        return self.rhs

    def process_rhs(self, compiler, connection***REMOVED***:
        db_rhs = getattr(self.rhs, '_db', None***REMOVED***
        if db_rhs is not None and db_rhs != connection.alias:
            raise ValueError(
                "Subqueries aren't allowed across different databases. Force "
                "the inner query to be evaluated using `list(inner_query***REMOVED***`."
            ***REMOVED***

        if self.rhs_is_direct_value(***REMOVED***:
            ***REMOVED***
                rhs = set(self.rhs***REMOVED***
            except TypeError:  # Unhashable items in self.rhs
                rhs = self.rhs

            if not rhs:
                from django.db.models.sql.datastructures import EmptyResultSet
                raise EmptyResultSet

            # rhs should be an iterable; use batch_process_rhs(***REMOVED*** to
            # prepare/transform those values.
            sqls, sqls_params = self.batch_process_rhs(compiler, connection, rhs***REMOVED***
            placeholder = '(' + ', '.join(sqls***REMOVED*** + '***REMOVED***'
            return (placeholder, sqls_params***REMOVED***
        else:
            return super(In, self***REMOVED***.process_rhs(compiler, connection***REMOVED***

    def get_rhs_op(self, connection, rhs***REMOVED***:
        return 'IN %s' % rhs

    def as_sql(self, compiler, connection***REMOVED***:
        max_in_list_size = connection.ops.max_in_list_size(***REMOVED***
        if self.rhs_is_direct_value(***REMOVED*** and max_in_list_size and len(self.rhs***REMOVED*** > max_in_list_size:
            return self.split_parameter_list_as_sql(compiler, connection***REMOVED***
        return super(In, self***REMOVED***.as_sql(compiler, connection***REMOVED***

    def split_parameter_list_as_sql(self, compiler, connection***REMOVED***:
        # This is a special case for databases which limit the number of
        # elements which can appear in an 'IN' clause.
        max_in_list_size = connection.ops.max_in_list_size(***REMOVED***
        lhs, lhs_params = self.process_lhs(compiler, connection***REMOVED***
        rhs, rhs_params = self.batch_process_rhs(compiler, connection***REMOVED***
        in_clause_elements = ['('***REMOVED***
        params = [***REMOVED***
        for offset in range(0, len(rhs_params***REMOVED***, max_in_list_size***REMOVED***:
            if offset > 0:
                in_clause_elements.append(' OR '***REMOVED***
            in_clause_elements.append('%s IN (' % lhs***REMOVED***
            params.extend(lhs_params***REMOVED***
            sqls = rhs[offset: offset + max_in_list_size***REMOVED***
            sqls_params = rhs_params[offset: offset + max_in_list_size***REMOVED***
            param_group = ', '.join(sqls***REMOVED***
            in_clause_elements.append(param_group***REMOVED***
            in_clause_elements.append('***REMOVED***'***REMOVED***
            params.extend(sqls_params***REMOVED***
        in_clause_elements.append('***REMOVED***'***REMOVED***
        return ''.join(in_clause_elements***REMOVED***, params
Field.register_lookup(In***REMOVED***


class PatternLookup(BuiltinLookup***REMOVED***:

    def get_rhs_op(self, connection, rhs***REMOVED***:
        # Assume we are in startswith. We need to produce SQL like:
        #     col LIKE %s, ['thevalue%'***REMOVED***
        # For python values we can (and should***REMOVED*** do that directly in Python,
        # but if the value is for example reference to other column, then
        # we need to add the % pattern match to the lookup by something like
        #     col LIKE othercol || '%%'
        # So, for Python values we don't need any special pattern, but for
        # SQL reference values or SQL transformations we need the correct
        # pattern added.
        if (hasattr(self.rhs, 'get_compiler'***REMOVED*** or hasattr(self.rhs, 'as_sql'***REMOVED*** or
                hasattr(self.rhs, '_as_sql'***REMOVED*** or self.bilateral_transforms***REMOVED***:
            pattern = connection.pattern_ops[self.lookup_name***REMOVED***.format(connection.pattern_esc***REMOVED***
            return pattern.format(rhs***REMOVED***
        else:
            return super(PatternLookup, self***REMOVED***.get_rhs_op(connection, rhs***REMOVED***


class Contains(PatternLookup***REMOVED***:
    lookup_name = 'contains'
    prepare_rhs = False

    def process_rhs(self, qn, connection***REMOVED***:
        rhs, params = super(Contains, self***REMOVED***.process_rhs(qn, connection***REMOVED***
        if params and not self.bilateral_transforms:
            params[0***REMOVED*** = "%%%s%%" % connection.ops.prep_for_like_query(params[0***REMOVED******REMOVED***
        return rhs, params
Field.register_lookup(Contains***REMOVED***


class IContains(Contains***REMOVED***:
    lookup_name = 'icontains'
    prepare_rhs = False
Field.register_lookup(IContains***REMOVED***


class StartsWith(PatternLookup***REMOVED***:
    lookup_name = 'startswith'
    prepare_rhs = False

    def process_rhs(self, qn, connection***REMOVED***:
        rhs, params = super(StartsWith, self***REMOVED***.process_rhs(qn, connection***REMOVED***
        if params and not self.bilateral_transforms:
            params[0***REMOVED*** = "%s%%" % connection.ops.prep_for_like_query(params[0***REMOVED******REMOVED***
        return rhs, params
Field.register_lookup(StartsWith***REMOVED***


class IStartsWith(PatternLookup***REMOVED***:
    lookup_name = 'istartswith'
    prepare_rhs = False

    def process_rhs(self, qn, connection***REMOVED***:
        rhs, params = super(IStartsWith, self***REMOVED***.process_rhs(qn, connection***REMOVED***
        if params and not self.bilateral_transforms:
            params[0***REMOVED*** = "%s%%" % connection.ops.prep_for_like_query(params[0***REMOVED******REMOVED***
        return rhs, params
Field.register_lookup(IStartsWith***REMOVED***


class EndsWith(PatternLookup***REMOVED***:
    lookup_name = 'endswith'
    prepare_rhs = False

    def process_rhs(self, qn, connection***REMOVED***:
        rhs, params = super(EndsWith, self***REMOVED***.process_rhs(qn, connection***REMOVED***
        if params and not self.bilateral_transforms:
            params[0***REMOVED*** = "%%%s" % connection.ops.prep_for_like_query(params[0***REMOVED******REMOVED***
        return rhs, params
Field.register_lookup(EndsWith***REMOVED***


class IEndsWith(PatternLookup***REMOVED***:
    lookup_name = 'iendswith'
    prepare_rhs = False

    def process_rhs(self, qn, connection***REMOVED***:
        rhs, params = super(IEndsWith, self***REMOVED***.process_rhs(qn, connection***REMOVED***
        if params and not self.bilateral_transforms:
            params[0***REMOVED*** = "%%%s" % connection.ops.prep_for_like_query(params[0***REMOVED******REMOVED***
        return rhs, params
Field.register_lookup(IEndsWith***REMOVED***


class Range(FieldGetDbPrepValueIterableMixin, BuiltinLookup***REMOVED***:
    lookup_name = 'range'

    def get_prep_lookup(self***REMOVED***:
        if hasattr(self.rhs, '_prepare'***REMOVED***:
            return self.rhs._prepare(self.lhs.output_field***REMOVED***
        return [self.lhs.output_field.get_prep_value(v***REMOVED*** for v in self.rhs***REMOVED***

    def get_rhs_op(self, connection, rhs***REMOVED***:
        return "BETWEEN %s AND %s" % (rhs[0***REMOVED***, rhs[1***REMOVED******REMOVED***

    def process_rhs(self, compiler, connection***REMOVED***:
        if self.rhs_is_direct_value(***REMOVED***:
            # rhs should be an iterable of 2 values, we use batch_process_rhs
            # to prepare/transform those values
            return self.batch_process_rhs(compiler, connection***REMOVED***
        else:
            return super(Range, self***REMOVED***.process_rhs(compiler, connection***REMOVED***
Field.register_lookup(Range***REMOVED***


class IsNull(BuiltinLookup***REMOVED***:
    lookup_name = 'isnull'
    prepare_rhs = False

    def as_sql(self, compiler, connection***REMOVED***:
        sql, params = compiler.compile(self.lhs***REMOVED***
        if self.rhs:
            return "%s IS NULL" % sql, params
        else:
            return "%s IS NOT NULL" % sql, params
Field.register_lookup(IsNull***REMOVED***


class Search(BuiltinLookup***REMOVED***:
    lookup_name = 'search'
    prepare_rhs = False

    def as_sql(self, compiler, connection***REMOVED***:
        warnings.warn(
            'The `__search` lookup is deprecated. See the 1.10 release notes '
            'for how to replace it.', RemovedInDjango20Warning, stacklevel=2
        ***REMOVED***
        lhs, lhs_params = self.process_lhs(compiler, connection***REMOVED***
        rhs, rhs_params = self.process_rhs(compiler, connection***REMOVED***
        sql_template = connection.ops.fulltext_search_sql(field_name=lhs***REMOVED***
        return sql_template, lhs_params + rhs_params
Field.register_lookup(Search***REMOVED***


class Regex(BuiltinLookup***REMOVED***:
    lookup_name = 'regex'
    prepare_rhs = False

    def as_sql(self, compiler, connection***REMOVED***:
        if self.lookup_name in connection.operators:
            return super(Regex, self***REMOVED***.as_sql(compiler, connection***REMOVED***
        else:
            lhs, lhs_params = self.process_lhs(compiler, connection***REMOVED***
            rhs, rhs_params = self.process_rhs(compiler, connection***REMOVED***
            sql_template = connection.ops.regex_lookup(self.lookup_name***REMOVED***
            return sql_template % (lhs, rhs***REMOVED***, lhs_params + rhs_params
Field.register_lookup(Regex***REMOVED***


class IRegex(Regex***REMOVED***:
    lookup_name = 'iregex'
Field.register_lookup(IRegex***REMOVED***


class YearLookup(Lookup***REMOVED***:
    def year_lookup_bounds(self, connection, year***REMOVED***:
        output_field = self.lhs.lhs.output_field
        if isinstance(output_field, DateTimeField***REMOVED***:
            bounds = connection.ops.year_lookup_bounds_for_datetime_field(year***REMOVED***
        else:
            bounds = connection.ops.year_lookup_bounds_for_date_field(year***REMOVED***
        return bounds


class YearComparisonLookup(YearLookup***REMOVED***:
    def as_sql(self, compiler, connection***REMOVED***:
        # We will need to skip the extract part and instead go
        # directly with the originating field, that is self.lhs.lhs.
        lhs_sql, params = self.process_lhs(compiler, connection, self.lhs.lhs***REMOVED***
        rhs_sql, rhs_params = self.process_rhs(compiler, connection***REMOVED***
        rhs_sql = self.get_rhs_op(connection, rhs_sql***REMOVED***
        start, finish = self.year_lookup_bounds(connection, rhs_params[0***REMOVED******REMOVED***
        params.append(self.get_bound(start, finish***REMOVED******REMOVED***
        return '%s %s' % (lhs_sql, rhs_sql***REMOVED***, params

    def get_rhs_op(self, connection, rhs***REMOVED***:
        return connection.operators[self.lookup_name***REMOVED*** % rhs

    def get_bound(self***REMOVED***:
        raise NotImplementedError(
            'subclasses of YearComparisonLookup must provide a get_bound(***REMOVED*** method'
        ***REMOVED***


class YearExact(YearLookup, Exact***REMOVED***:
    lookup_name = 'exact'

    def as_sql(self, compiler, connection***REMOVED***:
        # We will need to skip the extract part and instead go
        # directly with the originating field, that is self.lhs.lhs.
        lhs_sql, params = self.process_lhs(compiler, connection, self.lhs.lhs***REMOVED***
        rhs_sql, rhs_params = self.process_rhs(compiler, connection***REMOVED***
        ***REMOVED***
            # Check that rhs_params[0***REMOVED*** exists (IndexError***REMOVED***,
            # it isn't None (TypeError***REMOVED***, and is a number (ValueError***REMOVED***
            int(rhs_params[0***REMOVED******REMOVED***
        except (IndexError, TypeError, ValueError***REMOVED***:
            # Can't determine the bounds before executing the query, so skip
            # optimizations by falling back to a standard exact comparison.
            return super(Exact, self***REMOVED***.as_sql(compiler, connection***REMOVED***
        bounds = self.year_lookup_bounds(connection, rhs_params[0***REMOVED******REMOVED***
        params.extend(bounds***REMOVED***
        return '%s BETWEEN %%s AND %%s' % lhs_sql, params


class YearGt(YearComparisonLookup***REMOVED***:
    lookup_name = 'gt'

    def get_bound(self, start, finish***REMOVED***:
        return finish


class YearGte(YearComparisonLookup***REMOVED***:
    lookup_name = 'gte'

    def get_bound(self, start, finish***REMOVED***:
        return start


class YearLt(YearComparisonLookup***REMOVED***:
    lookup_name = 'lt'

    def get_bound(self, start, finish***REMOVED***:
        return start


class YearLte(YearComparisonLookup***REMOVED***:
    lookup_name = 'lte'

    def get_bound(self, start, finish***REMOVED***:
        return finish
