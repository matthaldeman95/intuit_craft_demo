***REMOVED***
import pkgutil
from importlib import import_module
from threading import local

from django.conf import settings
from django.core.exceptions import ImproperlyConfigured
from django.utils import six
from django.utils._os import npath, upath
from django.utils.functional import cached_property
from django.utils.module_loading import import_string

DEFAULT_DB_ALIAS = 'default'
DJANGO_VERSION_PICKLE_KEY = '_django_version'


class Error(Exception if six.PY3 else StandardError***REMOVED***:  # NOQA: StandardError undefined on PY3
    pass


class InterfaceError(Error***REMOVED***:
    pass


class DatabaseError(Error***REMOVED***:
    pass


class DataError(DatabaseError***REMOVED***:
    pass


class OperationalError(DatabaseError***REMOVED***:
    pass


class IntegrityError(DatabaseError***REMOVED***:
    pass


class InternalError(DatabaseError***REMOVED***:
    pass


class ProgrammingError(DatabaseError***REMOVED***:
    pass


class NotSupportedError(DatabaseError***REMOVED***:
    pass


class DatabaseErrorWrapper(object***REMOVED***:
    ***REMOVED***
    Context manager and decorator that re-throws backend-specific database
    exceptions using Django's common wrappers.
    ***REMOVED***

    def __init__(self, wrapper***REMOVED***:
        ***REMOVED***
        wrapper is a database wrapper.

        It must have a Database attribute defining PEP-249 exceptions.
        ***REMOVED***
        self.wrapper = wrapper

    def __enter__(self***REMOVED***:
        pass

    def __exit__(self, exc_type, exc_value, traceback***REMOVED***:
        if exc_type is None:
            return
        for dj_exc_type in (
                DataError,
                OperationalError,
                IntegrityError,
                InternalError,
                ProgrammingError,
                NotSupportedError,
                DatabaseError,
                InterfaceError,
                Error,
        ***REMOVED***:
            db_exc_type = getattr(self.wrapper.Database, dj_exc_type.__name__***REMOVED***
            if issubclass(exc_type, db_exc_type***REMOVED***:
                dj_exc_value = dj_exc_type(*exc_value.args***REMOVED***
                dj_exc_value.__cause__ = exc_value
                if not hasattr(exc_value, '__traceback__'***REMOVED***:
                    exc_value.__traceback__ = traceback
                # Only set the 'errors_occurred' flag for errors that may make
                # the connection unusable.
                if dj_exc_type not in (DataError, IntegrityError***REMOVED***:
                    self.wrapper.errors_occurred = True
                six.reraise(dj_exc_type, dj_exc_value, traceback***REMOVED***

    def __call__(self, func***REMOVED***:
        # Note that we are intentionally not using @wraps here for performance
        # reasons. Refs #21109.
        def inner(*args, **kwargs***REMOVED***:
            with self:
                return func(*args, **kwargs***REMOVED***
        return inner


def load_backend(backend_name***REMOVED***:
    ***REMOVED***
    Return a database backend's "base" module given a fully qualified database
    backend name, or raise an error if it doesn't exist.
    ***REMOVED***
    # This backend was renamed in Django 1.9.
    if backend_name == 'django.db.backends.postgresql_psycopg2':
        backend_name = 'django.db.backends.postgresql'

    ***REMOVED***
        return import_module('%s.base' % backend_name***REMOVED***
    except ImportError as e_user:
        # The database backend wasn't found. Display a helpful error message
        # listing all possible (built-in***REMOVED*** database backends.
        backend_dir = os.path.join(os.path.dirname(upath(__file__***REMOVED******REMOVED***, 'backends'***REMOVED***
        ***REMOVED***
            builtin_backends = [
                name for _, name, ispkg in pkgutil.iter_modules([npath(backend_dir***REMOVED******REMOVED******REMOVED***
                if ispkg and name not in {'base', 'dummy', 'postgresql_psycopg2'***REMOVED***
            ***REMOVED***
        except EnvironmentError:
            builtin_backends = [***REMOVED***
        if backend_name not in ['django.db.backends.%s' % b for b in
                                builtin_backends***REMOVED***:
            backend_reprs = map(repr, sorted(builtin_backends***REMOVED******REMOVED***
            error_msg = ("%r isn't an available database backend.\n"
                         "Try using 'django.db.backends.XXX', where XXX "
                         "is one of:\n    %s\nError was: %s" %
                         (backend_name, ", ".join(backend_reprs***REMOVED***, e_user***REMOVED******REMOVED***
            raise ImproperlyConfigured(error_msg***REMOVED***
        else:
            # If there's some other error, this must be an error in Django
            raise


class ConnectionDoesNotExist(Exception***REMOVED***:
    pass


class ConnectionHandler(object***REMOVED***:
    def __init__(self, databases=None***REMOVED***:
        ***REMOVED***
        databases is an optional dictionary of database definitions (structured
        like settings.DATABASES***REMOVED***.
        ***REMOVED***
        self._databases = databases
        self._connections = local(***REMOVED***

    @cached_property
    def databases(self***REMOVED***:
        if self._databases is None:
            self._databases = settings.DATABASES
        if self._databases == {***REMOVED***:
            self._databases = {
                DEFAULT_DB_ALIAS: {
                    'ENGINE': 'django.db.backends.dummy',
        ***REMOVED***
        ***REMOVED***
        if self._databases[DEFAULT_DB_ALIAS***REMOVED*** == {***REMOVED***:
            self._databases[DEFAULT_DB_ALIAS***REMOVED***['ENGINE'***REMOVED*** = 'django.db.backends.dummy'

        if DEFAULT_DB_ALIAS not in self._databases:
            raise ImproperlyConfigured("You must define a '%s' database" % DEFAULT_DB_ALIAS***REMOVED***
        return self._databases

    def ensure_defaults(self, alias***REMOVED***:
        ***REMOVED***
        Puts the defaults into the settings dictionary for a given connection
        where no settings is provided.
        ***REMOVED***
        ***REMOVED***
            conn = self.databases[alias***REMOVED***
        except KeyError:
            raise ConnectionDoesNotExist("The connection %s doesn't exist" % alias***REMOVED***

        conn.setdefault('ATOMIC_REQUESTS', False***REMOVED***
        conn.setdefault('AUTOCOMMIT', True***REMOVED***
        conn.setdefault('ENGINE', 'django.db.backends.dummy'***REMOVED***
        if conn['ENGINE'***REMOVED*** == 'django.db.backends.' or not conn['ENGINE'***REMOVED***:
            conn['ENGINE'***REMOVED*** = 'django.db.backends.dummy'
        conn.setdefault('CONN_MAX_AGE', 0***REMOVED***
        conn.setdefault('OPTIONS', {***REMOVED******REMOVED***
        conn.setdefault('TIME_ZONE', None***REMOVED***
        for setting in ['NAME', 'USER', 'PASSWORD', 'HOST', 'PORT'***REMOVED***:
            conn.setdefault(setting, ''***REMOVED***

    def prepare_test_settings(self, alias***REMOVED***:
        ***REMOVED***
        Makes sure the test settings are available in the 'TEST' sub-dictionary.
        ***REMOVED***
        ***REMOVED***
            conn = self.databases[alias***REMOVED***
        except KeyError:
            raise ConnectionDoesNotExist("The connection %s doesn't exist" % alias***REMOVED***

        test_settings = conn.setdefault('TEST', {***REMOVED******REMOVED***
        for key in ['CHARSET', 'COLLATION', 'NAME', 'MIRROR'***REMOVED***:
            test_settings.setdefault(key, None***REMOVED***

    def __getitem__(self, alias***REMOVED***:
        if hasattr(self._connections, alias***REMOVED***:
            return getattr(self._connections, alias***REMOVED***

        self.ensure_defaults(alias***REMOVED***
        self.prepare_test_settings(alias***REMOVED***
        db = self.databases[alias***REMOVED***
        backend = load_backend(db['ENGINE'***REMOVED******REMOVED***
        conn = backend.DatabaseWrapper(db, alias***REMOVED***
        setattr(self._connections, alias, conn***REMOVED***
        return conn

    def __setitem__(self, key, value***REMOVED***:
        setattr(self._connections, key, value***REMOVED***

    def __delitem__(self, key***REMOVED***:
        delattr(self._connections, key***REMOVED***

    def __iter__(self***REMOVED***:
        return iter(self.databases***REMOVED***

    def all(self***REMOVED***:
        return [self[alias***REMOVED*** for alias in self***REMOVED***

    def close_all(self***REMOVED***:
        for alias in self:
            ***REMOVED***
                connection = getattr(self._connections, alias***REMOVED***
            except AttributeError:
                continue
            connection.close(***REMOVED***


class ConnectionRouter(object***REMOVED***:
    def __init__(self, routers=None***REMOVED***:
        ***REMOVED***
        If routers is not specified, will default to settings.DATABASE_ROUTERS.
        ***REMOVED***
        self._routers = routers

    @cached_property
    def routers(self***REMOVED***:
        if self._routers is None:
            self._routers = settings.DATABASE_ROUTERS
        routers = [***REMOVED***
        for r in self._routers:
            if isinstance(r, six.string_types***REMOVED***:
                router = import_string(r***REMOVED***(***REMOVED***
            else:
                router = r
            routers.append(router***REMOVED***
        return routers

    def _router_func(action***REMOVED***:
        def _route_db(self, model, **hints***REMOVED***:
            chosen_db = None
            for router in self.routers:
                ***REMOVED***
                    method = getattr(router, action***REMOVED***
                except AttributeError:
                    # If the router doesn't have a method, skip to the next one.
                    pass
                else:
                    chosen_db = method(model, **hints***REMOVED***
                    if chosen_db:
                        return chosen_db
            instance = hints.get('instance'***REMOVED***
            if instance is not None and instance._state.db:
                return instance._state.db
            return DEFAULT_DB_ALIAS
        return _route_db

    db_for_read = _router_func('db_for_read'***REMOVED***
    db_for_write = _router_func('db_for_write'***REMOVED***

    def allow_relation(self, obj1, obj2, **hints***REMOVED***:
        for router in self.routers:
            ***REMOVED***
                method = router.allow_relation
            except AttributeError:
                # If the router doesn't have a method, skip to the next one.
                pass
            else:
                allow = method(obj1, obj2, **hints***REMOVED***
                if allow is not None:
                    return allow
        return obj1._state.db == obj2._state.db

    def allow_migrate(self, db, app_label, **hints***REMOVED***:
        for router in self.routers:
            ***REMOVED***
                method = router.allow_migrate
            except AttributeError:
                # If the router doesn't have a method, skip to the next one.
                continue

            allow = method(db, app_label, **hints***REMOVED***

            if allow is not None:
                return allow
        return True

    def allow_migrate_model(self, db, model***REMOVED***:
        return self.allow_migrate(
            db,
            model._meta.app_label,
            model_name=model._meta.model_name,
            model=model,
        ***REMOVED***

    def get_migratable_models(self, app_config, db, include_auto_created=False***REMOVED***:
        ***REMOVED***
        Return app models allowed to be synchronized on provided db.
        ***REMOVED***
        models = app_config.get_models(include_auto_created=include_auto_created***REMOVED***
        return [model for model in models if self.allow_migrate_model(db, model***REMOVED******REMOVED***
