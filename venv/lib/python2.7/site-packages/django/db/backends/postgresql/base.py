***REMOVED***
PostgreSQL database backend for Django.

Requires psycopg 2: http://initd.org/projects/psycopg2
***REMOVED***

import warnings

from django.conf import settings
from django.core.exceptions import ImproperlyConfigured
from django.db import DEFAULT_DB_ALIAS
from django.db.backends.base.base import BaseDatabaseWrapper
from django.db.backends.base.validation import BaseDatabaseValidation
from django.db.utils import DatabaseError as WrappedDatabaseError
from django.utils.encoding import force_str
from django.utils.functional import cached_property
from django.utils.safestring import SafeBytes, SafeText

***REMOVED***
    import psycopg2 as Database
    import psycopg2.extensions
    import psycopg2.extras
except ImportError as e:
    raise ImproperlyConfigured("Error loading psycopg2 module: %s" % e***REMOVED***


def psycopg2_version(***REMOVED***:
    version = psycopg2.__version__.split(' ', 1***REMOVED***[0***REMOVED***
    return tuple(int(v***REMOVED*** for v in version.split('.'***REMOVED*** if v.isdigit(***REMOVED******REMOVED***

PSYCOPG2_VERSION = psycopg2_version(***REMOVED***

if PSYCOPG2_VERSION < (2, 4, 5***REMOVED***:
    raise ImproperlyConfigured("psycopg2_version 2.4.5 or newer is required; you have %s" % psycopg2.__version__***REMOVED***


# Some of these import psycopg2, so import them after checking if it's installed.
from .client import DatabaseClient                          # NOQA isort:skip
from .creation import DatabaseCreation                      # NOQA isort:skip
from .features import DatabaseFeatures                      # NOQA isort:skip
from .introspection import DatabaseIntrospection            # NOQA isort:skip
from .operations import DatabaseOperations                  # NOQA isort:skip
from .schema import DatabaseSchemaEditor                    # NOQA isort:skip
from .utils import utc_tzinfo_factory                       # NOQA isort:skip
from .version import get_version                            # NOQA isort:skip

DatabaseError = Database.DatabaseError
IntegrityError = Database.IntegrityError

psycopg2.extensions.register_type(psycopg2.extensions.UNICODE***REMOVED***
psycopg2.extensions.register_type(psycopg2.extensions.UNICODEARRAY***REMOVED***
psycopg2.extensions.register_adapter(SafeBytes, psycopg2.extensions.QuotedString***REMOVED***
psycopg2.extensions.register_adapter(SafeText, psycopg2.extensions.QuotedString***REMOVED***
psycopg2.extras.register_uuid(***REMOVED***

# Register support for inet[***REMOVED*** manually so we don't have to handle the Inet(***REMOVED***
# object on load all the time.
INETARRAY_OID = 1041
INETARRAY = psycopg2.extensions.new_array_type(
    (INETARRAY_OID,***REMOVED***,
    'INETARRAY',
    psycopg2.extensions.UNICODE,
***REMOVED***
psycopg2.extensions.register_type(INETARRAY***REMOVED***


class DatabaseWrapper(BaseDatabaseWrapper***REMOVED***:
    vendor = 'postgresql'
    # This dictionary maps Field objects to their associated PostgreSQL column
    # types, as strings. Column-type strings can contain format strings; they'll
    # be interpolated against the values of Field.__dict__ before being output.
    # If a column type is set to None, it won't be included in the output.
    data_types = {
        'AutoField': 'serial',
        'BigAutoField': 'bigserial',
        'BinaryField': 'bytea',
        'BooleanField': 'boolean',
        'CharField': 'varchar(%(max_length***REMOVED***s***REMOVED***',
        'CommaSeparatedIntegerField': 'varchar(%(max_length***REMOVED***s***REMOVED***',
        'DateField': 'date',
        'DateTimeField': 'timestamp with time zone',
        'DecimalField': 'numeric(%(max_digits***REMOVED***s, %(decimal_places***REMOVED***s***REMOVED***',
        'DurationField': 'interval',
        'FileField': 'varchar(%(max_length***REMOVED***s***REMOVED***',
        'FilePathField': 'varchar(%(max_length***REMOVED***s***REMOVED***',
        'FloatField': 'double precision',
        'IntegerField': 'integer',
        'BigIntegerField': 'bigint',
        'IPAddressField': 'inet',
        'GenericIPAddressField': 'inet',
        'NullBooleanField': 'boolean',
        'OneToOneField': 'integer',
        'PositiveIntegerField': 'integer',
        'PositiveSmallIntegerField': 'smallint',
        'SlugField': 'varchar(%(max_length***REMOVED***s***REMOVED***',
        'SmallIntegerField': 'smallint',
        'TextField': 'text',
        'TimeField': 'time',
        'UUIDField': 'uuid',
***REMOVED***
    data_type_check_constraints = {
        'PositiveIntegerField': '"%(column***REMOVED***s" >= 0',
        'PositiveSmallIntegerField': '"%(column***REMOVED***s" >= 0',
***REMOVED***
    operators = {
        'exact': '= %s',
        'iexact': '= UPPER(%s***REMOVED***',
        'contains': 'LIKE %s',
        'icontains': 'LIKE UPPER(%s***REMOVED***',
        'regex': '~ %s',
        'iregex': '~* %s',
        'gt': '> %s',
        'gte': '>= %s',
        'lt': '< %s',
        'lte': '<= %s',
        'startswith': 'LIKE %s',
        'endswith': 'LIKE %s',
        'istartswith': 'LIKE UPPER(%s***REMOVED***',
        'iendswith': 'LIKE UPPER(%s***REMOVED***',
***REMOVED***

    # The patterns below are used to generate SQL pattern lookup clauses when
    # the right-hand side of the lookup isn't a raw string (it might be an expression
    # or the result of a bilateral transformation***REMOVED***.
    # In those cases, special characters for LIKE operators (e.g. \, *, _***REMOVED*** should be
    # escaped on database side.
    #
    # Note: we use str.format(***REMOVED*** here for readability as '%' is used as a wildcard for
    # the LIKE operator.
    pattern_esc = r"REPLACE(REPLACE(REPLACE({***REMOVED***, '\', '\\'***REMOVED***, '%%', '\%%'***REMOVED***, '_', '\_'***REMOVED***"
    pattern_ops = {
        'contains': "LIKE '%%' || {***REMOVED*** || '%%'",
        'icontains': "LIKE '%%' || UPPER({***REMOVED******REMOVED*** || '%%'",
        'startswith': "LIKE {***REMOVED*** || '%%'",
        'istartswith': "LIKE UPPER({***REMOVED******REMOVED*** || '%%'",
        'endswith': "LIKE '%%' || {***REMOVED***",
        'iendswith': "LIKE '%%' || UPPER({***REMOVED******REMOVED***",
***REMOVED***

    Database = Database
    SchemaEditorClass = DatabaseSchemaEditor

    def __init__(self, *args, **kwargs***REMOVED***:
        super(DatabaseWrapper, self***REMOVED***.__init__(*args, **kwargs***REMOVED***

        self.features = DatabaseFeatures(self***REMOVED***
        self.ops = DatabaseOperations(self***REMOVED***
        self.client = DatabaseClient(self***REMOVED***
        self.creation = DatabaseCreation(self***REMOVED***
        self.introspection = DatabaseIntrospection(self***REMOVED***
        self.validation = BaseDatabaseValidation(self***REMOVED***

    def get_connection_params(self***REMOVED***:
        settings_dict = self.settings_dict
        # None may be used to connect to the default 'postgres' db
        if settings_dict['NAME'***REMOVED*** == '':
            raise ImproperlyConfigured(
                "settings.DATABASES is improperly configured. "
                "Please supply the NAME value."***REMOVED***
        conn_params = {
            'database': settings_dict['NAME'***REMOVED*** or 'postgres',
    ***REMOVED***
        conn_params.update(settings_dict['OPTIONS'***REMOVED******REMOVED***
        conn_params.pop('isolation_level', None***REMOVED***
        if settings_dict['USER'***REMOVED***:
            conn_params['user'***REMOVED*** = settings_dict['USER'***REMOVED***
        if settings_dict['PASSWORD'***REMOVED***:
            conn_params['password'***REMOVED*** = force_str(settings_dict['PASSWORD'***REMOVED******REMOVED***
        if settings_dict['HOST'***REMOVED***:
            conn_params['host'***REMOVED*** = settings_dict['HOST'***REMOVED***
        if settings_dict['PORT'***REMOVED***:
            conn_params['port'***REMOVED*** = settings_dict['PORT'***REMOVED***
        return conn_params

    def get_new_connection(self, conn_params***REMOVED***:
        connection = Database.connect(**conn_params***REMOVED***

        # self.isolation_level must be set:
        # - after connecting to the database in order to obtain the database's
        #   default when no value is explicitly specified in options.
        # - before calling _set_autocommit(***REMOVED*** because if autocommit is on, that
        #   will set connection.isolation_level to ISOLATION_LEVEL_AUTOCOMMIT.
        options = self.settings_dict['OPTIONS'***REMOVED***
        ***REMOVED***
            self.isolation_level = options['isolation_level'***REMOVED***
        except KeyError:
            self.isolation_level = connection.isolation_level
        else:
            # Set the isolation level to the value from OPTIONS.
            if self.isolation_level != connection.isolation_level:
                connection.set_session(isolation_level=self.isolation_level***REMOVED***

        return connection

    def init_connection_state(self***REMOVED***:
        self.connection.set_client_encoding('UTF8'***REMOVED***

        conn_timezone_name = self.connection.get_parameter_status('TimeZone'***REMOVED***

        if self.timezone_name and conn_timezone_name != self.timezone_name:
            cursor = self.connection.cursor(***REMOVED***
            ***REMOVED***
                cursor.execute(self.ops.set_time_zone_sql(***REMOVED***, [self.timezone_name***REMOVED******REMOVED***
            finally:
                cursor.close(***REMOVED***
            # Commit after setting the time zone (see #17062***REMOVED***
            if not self.get_autocommit(***REMOVED***:
                self.connection.commit(***REMOVED***

    def create_cursor(self***REMOVED***:
        cursor = self.connection.cursor(***REMOVED***
        cursor.tzinfo_factory = utc_tzinfo_factory if settings.USE_TZ else None
        return cursor

    def _set_autocommit(self, autocommit***REMOVED***:
        with self.wrap_database_errors:
            self.connection.autocommit = autocommit

    def check_constraints(self, table_names=None***REMOVED***:
        ***REMOVED***
        To check constraints, we set constraints to immediate. Then, when, we're done we must ensure they
        are returned to deferred.
        ***REMOVED***
        self.cursor(***REMOVED***.execute('SET CONSTRAINTS ALL IMMEDIATE'***REMOVED***
        self.cursor(***REMOVED***.execute('SET CONSTRAINTS ALL DEFERRED'***REMOVED***

    def is_usable(self***REMOVED***:
        ***REMOVED***
            # Use a psycopg cursor directly, bypassing Django's utilities.
            self.connection.cursor(***REMOVED***.execute("SELECT 1"***REMOVED***
        except Database.Error:
            return False
        else:
            return True

    @property
    def _nodb_connection(self***REMOVED***:
        nodb_connection = super(DatabaseWrapper, self***REMOVED***._nodb_connection
        ***REMOVED***
            nodb_connection.ensure_connection(***REMOVED***
        except (DatabaseError, WrappedDatabaseError***REMOVED***:
            warnings.warn(
                "Normally Django will use a connection to the 'postgres' database "
                "to avoid running initialization queries against the production "
                "database when it's not needed (for example, when running tests***REMOVED***. "
                "Django was unable to create a connection to the 'postgres' database "
                "and will use the default database instead.",
                RuntimeWarning
            ***REMOVED***
            settings_dict = self.settings_dict.copy(***REMOVED***
            settings_dict['NAME'***REMOVED*** = settings.DATABASES[DEFAULT_DB_ALIAS***REMOVED***['NAME'***REMOVED***
            nodb_connection = self.__class__(
                self.settings_dict.copy(***REMOVED***,
                alias=self.alias,
                allow_thread_sharing=False***REMOVED***
        return nodb_connection

    @cached_property
    def psycopg2_version(self***REMOVED***:
        return PSYCOPG2_VERSION

    @cached_property
    def pg_version(self***REMOVED***:
        with self.temporary_connection(***REMOVED***:
            return get_version(self.connection***REMOVED***
