from __future__ import unicode_literals

from collections import namedtuple

from django.db.backends.base.introspection import (
    BaseDatabaseIntrospection, FieldInfo, TableInfo,
***REMOVED***
from django.utils.encoding import force_text

FieldInfo = namedtuple('FieldInfo', FieldInfo._fields + ('default',***REMOVED******REMOVED***


class DatabaseIntrospection(BaseDatabaseIntrospection***REMOVED***:
    # Maps type codes to Django Field types.
    data_types_reverse = {
        16: 'BooleanField',
        17: 'BinaryField',
        20: 'BigIntegerField',
        21: 'SmallIntegerField',
        23: 'IntegerField',
        25: 'TextField',
        700: 'FloatField',
        701: 'FloatField',
        869: 'GenericIPAddressField',
        1042: 'CharField',  # blank-padded
        1043: 'CharField',
        1082: 'DateField',
        1083: 'TimeField',
        1114: 'DateTimeField',
        1184: 'DateTimeField',
        1266: 'TimeField',
        1700: 'DecimalField',
***REMOVED***

    ignored_tables = [***REMOVED***

    _get_indexes_query = ***REMOVED***
        SELECT attr.attname, idx.indkey, idx.indisunique, idx.indisprimary
        FROM pg_catalog.pg_class c, pg_catalog.pg_class c2,
            pg_catalog.pg_index idx, pg_catalog.pg_attribute attr
        WHERE c.oid = idx.indrelid
            AND idx.indexrelid = c2.oid
            AND attr.attrelid = c.oid
            AND attr.attnum = idx.indkey[0***REMOVED***
            AND c.relname = %s***REMOVED***

    def get_field_type(self, data_type, description***REMOVED***:
        field_type = super(DatabaseIntrospection, self***REMOVED***.get_field_type(data_type, description***REMOVED***
        if description.default and 'nextval' in description.default:
            if field_type == 'IntegerField':
                return 'AutoField'
            elif field_type == 'BigIntegerField':
                return 'BigAutoField'
        return field_type

    def get_table_list(self, cursor***REMOVED***:
        ***REMOVED***
        Returns a list of table and view names in the current database.
        ***REMOVED***
        cursor.execute(***REMOVED***
            SELECT c.relname, c.relkind
            FROM pg_catalog.pg_class c
            LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
            WHERE c.relkind IN ('r', 'v'***REMOVED***
                AND n.nspname NOT IN ('pg_catalog', 'pg_toast'***REMOVED***
                AND pg_catalog.pg_table_is_visible(c.oid***REMOVED******REMOVED******REMOVED***
        return [TableInfo(row[0***REMOVED***, {'r': 't', 'v': 'v'***REMOVED***.get(row[1***REMOVED******REMOVED******REMOVED***
                for row in cursor.fetchall(***REMOVED***
                if row[0***REMOVED*** not in self.ignored_tables***REMOVED***

    def get_table_description(self, cursor, table_name***REMOVED***:
        "Returns a description of the table, with the DB-API cursor.description interface."
        # As cursor.description does not return reliably the nullable property,
        # we have to query the information_schema (#7783***REMOVED***
        cursor.execute(***REMOVED***
            SELECT column_name, is_nullable, column_default
            FROM information_schema.columns
            WHERE table_name = %s***REMOVED***, [table_name***REMOVED******REMOVED***
        field_map = {line[0***REMOVED***: line[1:***REMOVED*** for line in cursor.fetchall(***REMOVED******REMOVED***
        cursor.execute("SELECT * FROM %s LIMIT 1" % self.connection.ops.quote_name(table_name***REMOVED******REMOVED***
        return [
            FieldInfo(*(
                (force_text(line[0***REMOVED******REMOVED***,***REMOVED*** +
                line[1:6***REMOVED*** +
                (field_map[force_text(line[0***REMOVED******REMOVED******REMOVED***[0***REMOVED*** == 'YES', field_map[force_text(line[0***REMOVED******REMOVED******REMOVED***[1***REMOVED******REMOVED***
            ***REMOVED******REMOVED*** for line in cursor.description
        ***REMOVED***

    def get_relations(self, cursor, table_name***REMOVED***:
        ***REMOVED***
        Returns a dictionary of {field_name: (field_name_other_table, other_table***REMOVED******REMOVED***
        representing all relationships to the given table.
        ***REMOVED***
        cursor.execute(***REMOVED***
            SELECT c2.relname, a1.attname, a2.attname
            FROM pg_constraint con
            LEFT JOIN pg_class c1 ON con.conrelid = c1.oid
            LEFT JOIN pg_class c2 ON con.confrelid = c2.oid
            LEFT JOIN pg_attribute a1 ON c1.oid = a1.attrelid AND a1.attnum = con.conkey[1***REMOVED***
            LEFT JOIN pg_attribute a2 ON c2.oid = a2.attrelid AND a2.attnum = con.confkey[1***REMOVED***
            WHERE c1.relname = %s
                AND con.contype = 'f'***REMOVED***, [table_name***REMOVED******REMOVED***
        relations = {***REMOVED***
        for row in cursor.fetchall(***REMOVED***:
            relations[row[1***REMOVED******REMOVED*** = (row[2***REMOVED***, row[0***REMOVED******REMOVED***
        return relations

    def get_key_columns(self, cursor, table_name***REMOVED***:
        key_columns = [***REMOVED***
        cursor.execute(***REMOVED***
            SELECT kcu.column_name, ccu.table_name AS referenced_table, ccu.column_name AS referenced_column
            FROM information_schema.constraint_column_usage ccu
            LEFT JOIN information_schema.key_column_usage kcu
                ON ccu.constraint_catalog = kcu.constraint_catalog
                    AND ccu.constraint_schema = kcu.constraint_schema
                    AND ccu.constraint_name = kcu.constraint_name
            LEFT JOIN information_schema.table_constraints tc
                ON ccu.constraint_catalog = tc.constraint_catalog
                    AND ccu.constraint_schema = tc.constraint_schema
                    AND ccu.constraint_name = tc.constraint_name
            WHERE kcu.table_name = %s AND tc.constraint_type = 'FOREIGN KEY'***REMOVED***, [table_name***REMOVED******REMOVED***
        key_columns.extend(cursor.fetchall(***REMOVED******REMOVED***
        return key_columns

    def get_indexes(self, cursor, table_name***REMOVED***:
        # This query retrieves each index on the given table, including the
        # first associated field name
        cursor.execute(self._get_indexes_query, [table_name***REMOVED******REMOVED***
        indexes = {***REMOVED***
        for row in cursor.fetchall(***REMOVED***:
            # row[1***REMOVED*** (idx.indkey***REMOVED*** is stored in the DB as an array. It comes out as
            # a string of space-separated integers. This designates the field
            # indexes (1-based***REMOVED*** of the fields that have indexes on the table.
            # Here, we skip any indexes across multiple fields.
            if ' ' in row[1***REMOVED***:
                continue
            if row[0***REMOVED*** not in indexes:
                indexes[row[0***REMOVED******REMOVED*** = {'primary_key': False, 'unique': False***REMOVED***
            # It's possible to have the unique and PK constraints in separate indexes.
            if row[3***REMOVED***:
                indexes[row[0***REMOVED******REMOVED***['primary_key'***REMOVED*** = True
            if row[2***REMOVED***:
                indexes[row[0***REMOVED******REMOVED***['unique'***REMOVED*** = True
        return indexes

    def get_constraints(self, cursor, table_name***REMOVED***:
        ***REMOVED***
        Retrieves any constraints or keys (unique, pk, fk, check, index***REMOVED*** across one or more columns.
        ***REMOVED***
        constraints = {***REMOVED***
        # Loop over the key table, collecting things as constraints
        # This will get PKs, FKs, and uniques, but not CHECK
        cursor.execute(***REMOVED***
            SELECT
                kc.constraint_name,
                kc.column_name,
                c.constraint_type,
                array(SELECT table_name::text || '.' || column_name::text
                      FROM information_schema.constraint_column_usage
                      WHERE constraint_name = kc.constraint_name***REMOVED***
            FROM information_schema.key_column_usage AS kc
            JOIN information_schema.table_constraints AS c ON
                kc.table_schema = c.table_schema AND
                kc.table_name = c.table_name AND
                kc.constraint_name = c.constraint_name
            WHERE
                kc.table_schema = %s AND
                kc.table_name = %s
            ORDER BY kc.ordinal_position ASC
        ***REMOVED***, ["public", table_name***REMOVED******REMOVED***
        for constraint, column, kind, used_cols in cursor.fetchall(***REMOVED***:
            # If we're the first column, make the record
            if constraint not in constraints:
                constraints[constraint***REMOVED*** = {
                    "columns": [***REMOVED***,
                    "primary_key": kind.lower(***REMOVED*** == "primary key",
                    "unique": kind.lower(***REMOVED*** in ["primary key", "unique"***REMOVED***,
                    "foreign_key": tuple(used_cols[0***REMOVED***.split(".", 1***REMOVED******REMOVED*** if kind.lower(***REMOVED*** == "foreign key" else None,
                    "check": False,
                    "index": False,
            ***REMOVED***
            # Record the details
            constraints[constraint***REMOVED***['columns'***REMOVED***.append(column***REMOVED***
        # Now get CHECK constraint columns
        cursor.execute(***REMOVED***
            SELECT kc.constraint_name, kc.column_name
            FROM information_schema.constraint_column_usage AS kc
            JOIN information_schema.table_constraints AS c ON
                kc.table_schema = c.table_schema AND
                kc.table_name = c.table_name AND
                kc.constraint_name = c.constraint_name
            WHERE
                c.constraint_type = 'CHECK' AND
                kc.table_schema = %s AND
                kc.table_name = %s
        ***REMOVED***, ["public", table_name***REMOVED******REMOVED***
        for constraint, column in cursor.fetchall(***REMOVED***:
            # If we're the first column, make the record
            if constraint not in constraints:
                constraints[constraint***REMOVED*** = {
                    "columns": [***REMOVED***,
                    "primary_key": False,
                    "unique": False,
                    "foreign_key": None,
                    "check": True,
                    "index": False,
            ***REMOVED***
            # Record the details
            constraints[constraint***REMOVED***['columns'***REMOVED***.append(column***REMOVED***
        # Now get indexes
        cursor.execute(***REMOVED***
            SELECT
                c2.relname,
                ARRAY(
                    SELECT (SELECT attname FROM pg_catalog.pg_attribute WHERE attnum = i AND attrelid = c.oid***REMOVED***
                    FROM unnest(idx.indkey***REMOVED*** i
                ***REMOVED***,
                idx.indisunique,
                idx.indisprimary
            FROM pg_catalog.pg_class c, pg_catalog.pg_class c2,
                pg_catalog.pg_index idx
            WHERE c.oid = idx.indrelid
                AND idx.indexrelid = c2.oid
                AND c.relname = %s
        ***REMOVED***, [table_name***REMOVED******REMOVED***
        for index, columns, unique, primary in cursor.fetchall(***REMOVED***:
            if index not in constraints:
                constraints[index***REMOVED*** = {
                    "columns": list(columns***REMOVED***,
                    "primary_key": primary,
                    "unique": unique,
                    "foreign_key": None,
                    "check": False,
                    "index": True,
            ***REMOVED***
        return constraints
