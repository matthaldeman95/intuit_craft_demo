import psycopg2

from django.db.backends.base.schema import BaseDatabaseSchemaEditor


class DatabaseSchemaEditor(BaseDatabaseSchemaEditor***REMOVED***:

    sql_alter_column_type = "ALTER COLUMN %(column***REMOVED***s TYPE %(type***REMOVED***s USING %(column***REMOVED***s::%(type***REMOVED***s"

    sql_create_sequence = "CREATE SEQUENCE %(sequence***REMOVED***s"
    sql_delete_sequence = "DROP SEQUENCE IF EXISTS %(sequence***REMOVED***s CASCADE"
    sql_set_sequence_max = "SELECT setval('%(sequence***REMOVED***s', MAX(%(column***REMOVED***s***REMOVED******REMOVED*** FROM %(table***REMOVED***s"

    sql_create_varchar_index = "CREATE INDEX %(name***REMOVED***s ON %(table***REMOVED***s (%(columns***REMOVED***s varchar_pattern_ops***REMOVED***%(extra***REMOVED***s"
    sql_create_text_index = "CREATE INDEX %(name***REMOVED***s ON %(table***REMOVED***s (%(columns***REMOVED***s text_pattern_ops***REMOVED***%(extra***REMOVED***s"

    def quote_value(self, value***REMOVED***:
        return psycopg2.extensions.adapt(value***REMOVED***

    def add_field(self, model, field***REMOVED***:
        super(DatabaseSchemaEditor, self***REMOVED***.add_field(model, field***REMOVED***
        like_index_statement = self._create_like_index_sql(model, field***REMOVED***
        if like_index_statement is not None:
            self.deferred_sql.append(like_index_statement***REMOVED***

    def _model_indexes_sql(self, model***REMOVED***:
        output = super(DatabaseSchemaEditor, self***REMOVED***._model_indexes_sql(model***REMOVED***
        if not model._meta.managed or model._meta.proxy or model._meta.swapped:
            return output

        for field in model._meta.local_fields:
            like_index_statement = self._create_like_index_sql(model, field***REMOVED***
            if like_index_statement is not None:
                output.append(like_index_statement***REMOVED***
        return output

    def _create_like_index_sql(self, model, field***REMOVED***:
        ***REMOVED***
        Return the statement to create an index with varchar operator pattern
        when the column type is 'varchar' or 'text', otherwise return None.
        ***REMOVED***
        db_type = field.db_type(connection=self.connection***REMOVED***
        if db_type is not None and (field.db_index or field.unique***REMOVED***:
            # Fields with database column types of `varchar` and `text` need
            # a second index that specifies their operator class, which is
            # needed when performing correct LIKE queries outside the
            # C locale. See #12234.
            #
            # The same doesn't apply to array fields such as varchar[size***REMOVED***
            # and text[size***REMOVED***, so skip them.
            if '[' in db_type:
                return None
            if db_type.startswith('varchar'***REMOVED***:
                return self._create_index_sql(model, [field***REMOVED***, suffix='_like', sql=self.sql_create_varchar_index***REMOVED***
            elif db_type.startswith('text'***REMOVED***:
                return self._create_index_sql(model, [field***REMOVED***, suffix='_like', sql=self.sql_create_text_index***REMOVED***
        return None

    def _alter_column_type_sql(self, table, old_field, new_field, new_type***REMOVED***:
        ***REMOVED***
        Makes ALTER TYPE with SERIAL make sense.
        ***REMOVED***
        if new_type.lower(***REMOVED*** in ("serial", "bigserial"***REMOVED***:
            column = new_field.column
            sequence_name = "%s_%s_seq" % (table, column***REMOVED***
            col_type = "integer" if new_type.lower(***REMOVED*** == "serial" else "bigint"
            return (
                (
                    self.sql_alter_column_type % {
                        "column": self.quote_name(column***REMOVED***,
                        "type": col_type,
            ***REMOVED***
                    [***REMOVED***,
                ***REMOVED***,
                [
                    (
                        self.sql_delete_sequence % {
                            "sequence": self.quote_name(sequence_name***REMOVED***,
                ***REMOVED***
                        [***REMOVED***,
                    ***REMOVED***,
                    (
                        self.sql_create_sequence % {
                            "sequence": self.quote_name(sequence_name***REMOVED***,
                ***REMOVED***
                        [***REMOVED***,
                    ***REMOVED***,
                    (
                        self.sql_alter_column % {
                            "table": self.quote_name(table***REMOVED***,
                            "changes": self.sql_alter_column_default % {
                                "column": self.quote_name(column***REMOVED***,
                                "default": "nextval('%s'***REMOVED***" % self.quote_name(sequence_name***REMOVED***,
                        ***REMOVED***
                ***REMOVED***
                        [***REMOVED***,
                    ***REMOVED***,
                    (
                        self.sql_set_sequence_max % {
                            "table": self.quote_name(table***REMOVED***,
                            "column": self.quote_name(column***REMOVED***,
                            "sequence": self.quote_name(sequence_name***REMOVED***,
                ***REMOVED***
                        [***REMOVED***,
                    ***REMOVED***,
                ***REMOVED***,
            ***REMOVED***
        else:
            return super(DatabaseSchemaEditor, self***REMOVED***._alter_column_type_sql(
                table, old_field, new_field, new_type
            ***REMOVED***

    def _alter_field(self, model, old_field, new_field, old_type, new_type,
                     old_db_params, new_db_params, strict=False***REMOVED***:
        super(DatabaseSchemaEditor, self***REMOVED***._alter_field(
            model, old_field, new_field, old_type, new_type, old_db_params,
            new_db_params, strict,
        ***REMOVED***
        # Added an index? Create any PostgreSQL-specific indexes.
        if not old_field.db_index and not old_field.unique and (new_field.db_index or new_field.unique***REMOVED***:
            like_index_statement = self._create_like_index_sql(model, new_field***REMOVED***
            if like_index_statement is not None:
                self.execute(like_index_statement***REMOVED***

        # Removed an index? Drop any PostgreSQL-specific indexes.
        if (old_field.db_index or old_field.unique***REMOVED*** and not (new_field.db_index or new_field.unique***REMOVED***:
            index_to_remove = self._create_index_name(model, [old_field.column***REMOVED***, suffix='_like'***REMOVED***
            index_names = self._constraint_names(model, [old_field.column***REMOVED***, index=True***REMOVED***
            for index_name in index_names:
                if index_name == index_to_remove:
                    self.execute(self._delete_constraint_sql(self.sql_delete_index, model, index_name***REMOVED******REMOVED***
