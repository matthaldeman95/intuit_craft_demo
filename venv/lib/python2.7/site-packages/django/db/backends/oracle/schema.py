import binascii
import copy
import datetime
import re

from django.db.backends.base.schema import BaseDatabaseSchemaEditor
from django.db.utils import DatabaseError
from django.utils import six
from django.utils.text import force_text


class DatabaseSchemaEditor(BaseDatabaseSchemaEditor***REMOVED***:

    sql_create_column = "ALTER TABLE %(table***REMOVED***s ADD %(column***REMOVED***s %(definition***REMOVED***s"
    sql_alter_column_type = "MODIFY %(column***REMOVED***s %(type***REMOVED***s"
    sql_alter_column_null = "MODIFY %(column***REMOVED***s NULL"
    sql_alter_column_not_null = "MODIFY %(column***REMOVED***s NOT NULL"
    sql_alter_column_default = "MODIFY %(column***REMOVED***s DEFAULT %(default***REMOVED***s"
    sql_alter_column_no_default = "MODIFY %(column***REMOVED***s DEFAULT NULL"
    sql_delete_column = "ALTER TABLE %(table***REMOVED***s DROP COLUMN %(column***REMOVED***s"
    sql_delete_table = "DROP TABLE %(table***REMOVED***s CASCADE CONSTRAINTS"

    def quote_value(self, value***REMOVED***:
        if isinstance(value, (datetime.date, datetime.time, datetime.datetime***REMOVED******REMOVED***:
            return "'%s'" % value
        elif isinstance(value, six.string_types***REMOVED***:
            return "'%s'" % six.text_type(value***REMOVED***.replace("\'", "\'\'"***REMOVED***
        elif isinstance(value, six.buffer_types***REMOVED***:
            return "'%s'" % force_text(binascii.hexlify(value***REMOVED******REMOVED***
        elif isinstance(value, bool***REMOVED***:
            return "1" if value else "0"
        else:
            return str(value***REMOVED***

    def delete_model(self, model***REMOVED***:
        # Run superclass action
        super(DatabaseSchemaEditor, self***REMOVED***.delete_model(model***REMOVED***
        # Clean up any autoincrement trigger
        self.execute(***REMOVED***
            DECLARE
                i INTEGER;
            BEGIN
                SELECT COUNT(****REMOVED*** INTO i FROM USER_CATALOG
                    WHERE TABLE_NAME = '%(sq_name***REMOVED***s' AND TABLE_TYPE = 'SEQUENCE';
                IF i = 1 THEN
                    EXECUTE IMMEDIATE 'DROP SEQUENCE "%(sq_name***REMOVED***s"';
                END IF;
            END;
        /***REMOVED*** % {'sq_name': self.connection.ops._get_sequence_name(model._meta.db_table***REMOVED******REMOVED******REMOVED***

    def alter_field(self, model, old_field, new_field, strict=False***REMOVED***:
        ***REMOVED***
            super(DatabaseSchemaEditor, self***REMOVED***.alter_field(model, old_field, new_field, strict***REMOVED***
        except DatabaseError as e:
            description = str(e***REMOVED***
            # If we're changing type to an unsupported type we need a
            # SQLite-ish workaround
            if 'ORA-22858' in description or 'ORA-22859' in description:
                self._alter_field_type_workaround(model, old_field, new_field***REMOVED***
            else:
                raise

    def _alter_field_type_workaround(self, model, old_field, new_field***REMOVED***:
        ***REMOVED***
        Oracle refuses to change from some type to other type.
        What we need to do instead is:
        - Add a nullable version of the desired field with a temporary name
        - Update the table to transfer values from old to new
        - Drop old column
        - Rename the new column and possibly drop the nullable property
        ***REMOVED***
        # Make a new field that's like the new one but with a temporary
        # column name.
        new_temp_field = copy.deepcopy(new_field***REMOVED***
        new_temp_field.null = True
        new_temp_field.column = self._generate_temp_name(new_field.column***REMOVED***
        # Add it
        self.add_field(model, new_temp_field***REMOVED***
        # Explicit data type conversion
        # https://docs.oracle.com/cd/B19306_01/server.102/b14200/sql_elements002.htm#sthref340
        new_value = self.quote_name(old_field.column***REMOVED***
        old_type = old_field.db_type(self.connection***REMOVED***
        if re.match('^N?CLOB', old_type***REMOVED***:
            new_value = "TO_CHAR(%s***REMOVED***" % new_value
            old_type = 'VARCHAR2'
        if re.match('^N?VARCHAR2', old_type***REMOVED***:
            new_internal_type = new_field.get_internal_type(***REMOVED***
            if new_internal_type == 'DateField':
                new_value = "TO_DATE(%s, 'YYYY-MM-DD'***REMOVED***" % new_value
            elif new_internal_type == 'DateTimeField':
                new_value = "TO_TIMESTAMP(%s, 'YYYY-MM-DD HH24:MI:SS.FF'***REMOVED***" % new_value
            elif new_internal_type == 'TimeField':
                # TimeField are stored as TIMESTAMP with a 1900-01-01 date part.
                new_value = "TO_TIMESTAMP(CONCAT('1900-01-01 ', %s***REMOVED***, 'YYYY-MM-DD HH24:MI:SS.FF'***REMOVED***" % new_value
        # Transfer values across
        self.execute("UPDATE %s set %s=%s" % (
            self.quote_name(model._meta.db_table***REMOVED***,
            self.quote_name(new_temp_field.column***REMOVED***,
            new_value,
        ***REMOVED******REMOVED***
        # Drop the old field
        self.remove_field(model, old_field***REMOVED***
        # Rename and possibly make the new field NOT NULL
        super(DatabaseSchemaEditor, self***REMOVED***.alter_field(model, new_temp_field, new_field***REMOVED***

    def normalize_name(self, name***REMOVED***:
        ***REMOVED***
        Get the properly shortened and uppercased identifier as returned by
        quote_name(***REMOVED***, but without the actual quotes.
        ***REMOVED***
        nn = self.quote_name(name***REMOVED***
        if nn[0***REMOVED*** == '"' and nn[-1***REMOVED*** == '"':
            nn = nn[1:-1***REMOVED***
        return nn

    def _generate_temp_name(self, for_name***REMOVED***:
        ***REMOVED***
        Generates temporary names for workarounds that need temp columns
        ***REMOVED***
        suffix = hex(hash(for_name***REMOVED******REMOVED***.upper(***REMOVED***[1:***REMOVED***
        return self.normalize_name(for_name + "_" + suffix***REMOVED***

    def prepare_default(self, value***REMOVED***:
        return self.quote_value(value***REMOVED***
