import cx_Oracle

from django.db.backends.base.introspection import (
    BaseDatabaseIntrospection, FieldInfo, TableInfo,
***REMOVED***
from django.utils.encoding import force_text


class DatabaseIntrospection(BaseDatabaseIntrospection***REMOVED***:
    # Maps type objects to Django Field types.
    data_types_reverse = {
        cx_Oracle.BLOB: 'BinaryField',
        cx_Oracle.CLOB: 'TextField',
        cx_Oracle.DATETIME: 'DateField',
        cx_Oracle.FIXED_CHAR: 'CharField',
        cx_Oracle.NCLOB: 'TextField',
        cx_Oracle.NUMBER: 'DecimalField',
        cx_Oracle.STRING: 'CharField',
        cx_Oracle.TIMESTAMP: 'DateTimeField',
***REMOVED***

    ***REMOVED***
        data_types_reverse[cx_Oracle.NATIVE_FLOAT***REMOVED*** = 'FloatField'
    except AttributeError:
        pass

    ***REMOVED***
        data_types_reverse[cx_Oracle.UNICODE***REMOVED*** = 'CharField'
    except AttributeError:
        pass

    cache_bust_counter = 1

    def get_field_type(self, data_type, description***REMOVED***:
        # If it's a NUMBER with scale == 0, consider it an IntegerField
        if data_type == cx_Oracle.NUMBER:
            precision, scale = description[4:6***REMOVED***
            if scale == 0:
                if precision > 11:
                    return 'BigIntegerField'
                elif precision == 1:
                    return 'BooleanField'
                else:
                    return 'IntegerField'
            elif scale == -127:
                return 'FloatField'

        return super(DatabaseIntrospection, self***REMOVED***.get_field_type(data_type, description***REMOVED***

    def get_table_list(self, cursor***REMOVED***:
        ***REMOVED***
        Returns a list of table and view names in the current database.
        ***REMOVED***
        cursor.execute("SELECT TABLE_NAME, 't' FROM USER_TABLES UNION ALL "
                       "SELECT VIEW_NAME, 'v' FROM USER_VIEWS"***REMOVED***
        return [TableInfo(row[0***REMOVED***.lower(***REMOVED***, row[1***REMOVED******REMOVED*** for row in cursor.fetchall(***REMOVED******REMOVED***

    def get_table_description(self, cursor, table_name***REMOVED***:
        "Returns a description of the table, with the DB-API cursor.description interface."
        self.cache_bust_counter += 1
        cursor.execute("SELECT * FROM {***REMOVED*** WHERE ROWNUM < 2 AND {***REMOVED*** > 0".format(
            self.connection.ops.quote_name(table_name***REMOVED***,
            self.cache_bust_counter***REMOVED******REMOVED***
        description = [***REMOVED***
        for desc in cursor.description:
            name = force_text(desc[0***REMOVED******REMOVED***  # cx_Oracle always returns a 'str' on both Python 2 and 3
            name = name % {***REMOVED***  # cx_Oracle, for some reason, doubles percent signs.
            description.append(FieldInfo(*(name.lower(***REMOVED***,***REMOVED*** + desc[1:***REMOVED******REMOVED******REMOVED***
        return description

    def table_name_converter(self, name***REMOVED***:
        "Table name comparison is case insensitive under Oracle"
        return name.lower(***REMOVED***

    def _name_to_index(self, cursor, table_name***REMOVED***:
        ***REMOVED***
        Returns a dictionary of {field_name: field_index***REMOVED*** for the given table.
        Indexes are 0-based.
        ***REMOVED***
        return {d[0***REMOVED***: i for i, d in enumerate(self.get_table_description(cursor, table_name***REMOVED******REMOVED******REMOVED***

    def get_relations(self, cursor, table_name***REMOVED***:
        ***REMOVED***
        Returns a dictionary of {field_name: (field_name_other_table, other_table***REMOVED******REMOVED***
        representing all relationships to the given table.
        ***REMOVED***
        table_name = table_name.upper(***REMOVED***
        cursor.execute(***REMOVED***
    SELECT ta.column_name, tb.table_name, tb.column_name
    FROM   user_constraints, USER_CONS_COLUMNS ca, USER_CONS_COLUMNS cb,
           user_tab_cols ta, user_tab_cols tb
    WHERE  user_constraints.table_name = %s AND
           ta.table_name = user_constraints.table_name AND
           ta.column_name = ca.column_name AND
           ca.table_name = ta.table_name AND
           user_constraints.constraint_name = ca.constraint_name AND
           user_constraints.r_constraint_name = cb.constraint_name AND
           cb.table_name = tb.table_name AND
           cb.column_name = tb.column_name AND
           ca.position = cb.position***REMOVED***, [table_name***REMOVED******REMOVED***

        relations = {***REMOVED***
        for row in cursor.fetchall(***REMOVED***:
            relations[row[0***REMOVED***.lower(***REMOVED******REMOVED*** = (row[2***REMOVED***.lower(***REMOVED***, row[1***REMOVED***.lower(***REMOVED******REMOVED***
        return relations

    def get_key_columns(self, cursor, table_name***REMOVED***:
        cursor.execute(***REMOVED***
            SELECT ccol.column_name, rcol.table_name AS referenced_table, rcol.column_name AS referenced_column
            FROM user_constraints c
            JOIN user_cons_columns ccol
              ON ccol.constraint_name = c.constraint_name
            JOIN user_cons_columns rcol
              ON rcol.constraint_name = c.r_constraint_name
            WHERE c.table_name = %s AND c.constraint_type = 'R'***REMOVED***, [table_name.upper(***REMOVED******REMOVED******REMOVED***
        return [tuple(cell.lower(***REMOVED*** for cell in row***REMOVED***
                for row in cursor.fetchall(***REMOVED******REMOVED***

    def get_indexes(self, cursor, table_name***REMOVED***:
        sql = ***REMOVED***
    SELECT LOWER(uic1.column_name***REMOVED*** AS column_name,
           CASE user_constraints.constraint_type
               WHEN 'P' THEN 1 ELSE 0
           END AS is_primary_key,
           CASE user_indexes.uniqueness
               WHEN 'UNIQUE' THEN 1 ELSE 0
           END AS is_unique
    FROM   user_constraints, user_indexes, user_ind_columns uic1
    WHERE  user_constraints.constraint_type (+***REMOVED*** = 'P'
      AND  user_constraints.index_name (+***REMOVED*** = uic1.index_name
      AND  user_indexes.uniqueness (+***REMOVED*** = 'UNIQUE'
      AND  user_indexes.index_name (+***REMOVED*** = uic1.index_name
      AND  uic1.table_name = UPPER(%s***REMOVED***
      AND  uic1.column_position = 1
      AND  NOT EXISTS (
              SELECT 1
              FROM   user_ind_columns uic2
              WHERE  uic2.index_name = uic1.index_name
                AND  uic2.column_position = 2
           ***REMOVED***
        ***REMOVED***
        cursor.execute(sql, [table_name***REMOVED******REMOVED***
        indexes = {***REMOVED***
        for row in cursor.fetchall(***REMOVED***:
            indexes[row[0***REMOVED******REMOVED*** = {'primary_key': bool(row[1***REMOVED******REMOVED***,
                               'unique': bool(row[2***REMOVED******REMOVED******REMOVED***
        return indexes

    def get_constraints(self, cursor, table_name***REMOVED***:
        ***REMOVED***
        Retrieves any constraints or keys (unique, pk, fk, check, index***REMOVED*** across one or more columns.
        ***REMOVED***
        constraints = {***REMOVED***
        # Loop over the constraints, getting PKs and uniques
        cursor.execute(***REMOVED***
            SELECT
                user_constraints.constraint_name,
                LOWER(cols.column_name***REMOVED*** AS column_name,
                CASE user_constraints.constraint_type
                    WHEN 'P' THEN 1
                    ELSE 0
                END AS is_primary_key,
                CASE user_indexes.uniqueness
                    WHEN 'UNIQUE' THEN 1
                    ELSE 0
                END AS is_unique,
                CASE user_constraints.constraint_type
                    WHEN 'C' THEN 1
                    ELSE 0
                END AS is_check_constraint
            FROM
                user_constraints
            INNER JOIN
                user_indexes ON user_indexes.index_name = user_constraints.index_name
            LEFT OUTER JOIN
                user_cons_columns cols ON user_constraints.constraint_name = cols.constraint_name
            WHERE
                (
                    user_constraints.constraint_type = 'P' OR
                    user_constraints.constraint_type = 'U'
                ***REMOVED***
                AND user_constraints.table_name = UPPER(%s***REMOVED***
            ORDER BY cols.position
        ***REMOVED***, [table_name***REMOVED******REMOVED***
        for constraint, column, pk, unique, check in cursor.fetchall(***REMOVED***:
            # If we're the first column, make the record
            if constraint not in constraints:
                constraints[constraint***REMOVED*** = {
                    "columns": [***REMOVED***,
                    "primary_key": pk,
                    "unique": unique,
                    "foreign_key": None,
                    "check": check,
                    "index": True,  # All P and U come with index, see inner join above
            ***REMOVED***
            # Record the details
            constraints[constraint***REMOVED***['columns'***REMOVED***.append(column***REMOVED***
        # Check constraints
        cursor.execute(***REMOVED***
            SELECT
                cons.constraint_name,
                LOWER(cols.column_name***REMOVED*** AS column_name
            FROM
                user_constraints cons
            LEFT OUTER JOIN
                user_cons_columns cols ON cons.constraint_name = cols.constraint_name
            WHERE
                cons.constraint_type = 'C' AND
                cons.table_name = UPPER(%s***REMOVED***
            ORDER BY cols.position
        ***REMOVED***, [table_name***REMOVED******REMOVED***
        for constraint, column in cursor.fetchall(***REMOVED***:
            # If we're the first column, make the record
            if constraint not in constraints:
                constraints[constraint***REMOVED*** = {
                    "columns": [***REMOVED***,
                    "primary_key": False,
                    "unique": False,
                    "foreign_key": None,
                    "check": True,
                    "index": False,
            ***REMOVED***
            # Record the details
            constraints[constraint***REMOVED***['columns'***REMOVED***.append(column***REMOVED***
        # Foreign key constraints
        cursor.execute(***REMOVED***
            SELECT
                cons.constraint_name,
                LOWER(cols.column_name***REMOVED*** AS column_name,
                LOWER(rcons.table_name***REMOVED***,
                LOWER(rcols.column_name***REMOVED***
            FROM
                user_constraints cons
            INNER JOIN
                user_constraints rcons ON cons.r_constraint_name = rcons.constraint_name
            INNER JOIN
                user_cons_columns rcols ON rcols.constraint_name = rcons.constraint_name
            LEFT OUTER JOIN
                user_cons_columns cols ON cons.constraint_name = cols.constraint_name
            WHERE
                cons.constraint_type = 'R' AND
                cons.table_name = UPPER(%s***REMOVED***
            ORDER BY cols.position
        ***REMOVED***, [table_name***REMOVED******REMOVED***
        for constraint, column, other_table, other_column in cursor.fetchall(***REMOVED***:
            # If we're the first column, make the record
            if constraint not in constraints:
                constraints[constraint***REMOVED*** = {
                    "columns": [***REMOVED***,
                    "primary_key": False,
                    "unique": False,
                    "foreign_key": (other_table, other_column***REMOVED***,
                    "check": False,
                    "index": False,
            ***REMOVED***
            # Record the details
            constraints[constraint***REMOVED***['columns'***REMOVED***.append(column***REMOVED***
        # Now get indexes
        cursor.execute(***REMOVED***
            SELECT
                index_name,
                LOWER(column_name***REMOVED***
            FROM
                user_ind_columns cols
            WHERE
                table_name = UPPER(%s***REMOVED*** AND
                NOT EXISTS (
                    SELECT 1
                    FROM user_constraints cons
                    WHERE cols.index_name = cons.index_name
                ***REMOVED***
            ORDER BY cols.column_position
        ***REMOVED***, [table_name***REMOVED******REMOVED***
        for constraint, column in cursor.fetchall(***REMOVED***:
            # If we're the first column, make the record
            if constraint not in constraints:
                constraints[constraint***REMOVED*** = {
                    "columns": [***REMOVED***,
                    "primary_key": False,
                    "unique": False,
                    "foreign_key": None,
                    "check": False,
                    "index": True,
            ***REMOVED***
            # Record the details
            constraints[constraint***REMOVED***['columns'***REMOVED***.append(column***REMOVED***
        return constraints
