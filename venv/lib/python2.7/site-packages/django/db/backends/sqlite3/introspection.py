import re
from collections import namedtuple

from django.db.backends.base.introspection import (
    BaseDatabaseIntrospection, FieldInfo, TableInfo,
***REMOVED***

field_size_re = re.compile(r'^\s*(?:var***REMOVED***?char\s*\(\s*(\d+***REMOVED***\s*\***REMOVED***\s*$'***REMOVED***
FieldInfo = namedtuple('FieldInfo', FieldInfo._fields + ('default',***REMOVED******REMOVED***


def get_field_size(name***REMOVED***:
    ***REMOVED*** Extract the size number from a "varchar(11***REMOVED***" type name ***REMOVED***
    m = field_size_re.search(name***REMOVED***
    return int(m.group(1***REMOVED******REMOVED*** if m else None


# This light wrapper "fakes" a dictionary interface, because some SQLite data
# types include variables in them -- e.g. "varchar(30***REMOVED***" -- and can't be matched
# as a simple dictionary lookup.
class FlexibleFieldLookupDict(object***REMOVED***:
    # Maps SQL types to Django Field types. Some of the SQL types have multiple
    # entries here because SQLite allows for anything and doesn't normalize the
    # field type; it uses whatever was given.
    base_data_types_reverse = {
        'bool': 'BooleanField',
        'boolean': 'BooleanField',
        'smallint': 'SmallIntegerField',
        'smallint unsigned': 'PositiveSmallIntegerField',
        'smallinteger': 'SmallIntegerField',
        'int': 'IntegerField',
        'integer': 'IntegerField',
        'bigint': 'BigIntegerField',
        'integer unsigned': 'PositiveIntegerField',
        'decimal': 'DecimalField',
        'real': 'FloatField',
        'text': 'TextField',
        'char': 'CharField',
        'blob': 'BinaryField',
        'date': 'DateField',
        'datetime': 'DateTimeField',
        'time': 'TimeField',
***REMOVED***

    def __getitem__(self, key***REMOVED***:
        key = key.lower(***REMOVED***
        ***REMOVED***
            return self.base_data_types_reverse[key***REMOVED***
        except KeyError:
            size = get_field_size(key***REMOVED***
            if size is not None:
                return ('CharField', {'max_length': size***REMOVED******REMOVED***
            raise KeyError


class DatabaseIntrospection(BaseDatabaseIntrospection***REMOVED***:
    data_types_reverse = FlexibleFieldLookupDict(***REMOVED***

    def get_table_list(self, cursor***REMOVED***:
        ***REMOVED***
        Returns a list of table and view names in the current database.
        ***REMOVED***
        # Skip the sqlite_sequence system table used for autoincrement key
        # generation.
        cursor.execute(***REMOVED***
            SELECT name, type FROM sqlite_master
            WHERE type in ('table', 'view'***REMOVED*** AND NOT name='sqlite_sequence'
            ORDER BY name***REMOVED******REMOVED***
        return [TableInfo(row[0***REMOVED***, row[1***REMOVED***[0***REMOVED******REMOVED*** for row in cursor.fetchall(***REMOVED******REMOVED***

    def get_table_description(self, cursor, table_name***REMOVED***:
        "Returns a description of the table, with the DB-API cursor.description interface."
        return [
            FieldInfo(
                info['name'***REMOVED***,
                info['type'***REMOVED***,
                None,
                info['size'***REMOVED***,
                None,
                None,
                info['null_ok'***REMOVED***,
                info['default'***REMOVED***,
            ***REMOVED*** for info in self._table_info(cursor, table_name***REMOVED***
        ***REMOVED***

    def column_name_converter(self, name***REMOVED***:
        ***REMOVED***
        SQLite will in some cases, e.g. when returning columns from views and
        subselects, return column names in 'alias."column"' format instead of
        simply 'column'.

        Affects SQLite < 3.7.15, fixed by http://www.sqlite.org/src/info/5526e0aa3c
        ***REMOVED***
        # TODO: remove when SQLite < 3.7.15 is sufficiently old.
        # 3.7.13 ships in Debian stable as of 2014-03-21.
        if self.connection.Database.sqlite_version_info < (3, 7, 15***REMOVED***:
            return name.split('.'***REMOVED***[-1***REMOVED***.strip('"'***REMOVED***
        else:
            return name

    def get_relations(self, cursor, table_name***REMOVED***:
        ***REMOVED***
        Return a dictionary of {field_name: (field_name_other_table, other_table***REMOVED******REMOVED***
        representing all relationships to the given table.
        ***REMOVED***
        # Dictionary of relations to return
        relations = {***REMOVED***

        # Schema for this table
        cursor.execute("SELECT sql FROM sqlite_master WHERE tbl_name = %s AND type = %s", [table_name, "table"***REMOVED******REMOVED***
        ***REMOVED***
            results = cursor.fetchone(***REMOVED***[0***REMOVED***.strip(***REMOVED***
        except TypeError:
            # It might be a view, then no results will be returned
            return relations
        results = results[results.index('('***REMOVED*** + 1:results.rindex('***REMOVED***'***REMOVED******REMOVED***

        # Walk through and look for references to other tables. SQLite doesn't
        # really have enforced references, but since it echoes out the SQL used
        # to create the table we can look for REFERENCES statements used there.
        for field_desc in results.split(','***REMOVED***:
            field_desc = field_desc.strip(***REMOVED***
            if field_desc.startswith("UNIQUE"***REMOVED***:
                continue

            m = re.search('references (\S****REMOVED*** ?\(["|***REMOVED***?(.****REMOVED***["|***REMOVED***?\***REMOVED***', field_desc, re.I***REMOVED***
            if not m:
                continue
            table, column = [s.strip('"'***REMOVED*** for s in m.groups(***REMOVED******REMOVED***

            if field_desc.startswith("FOREIGN KEY"***REMOVED***:
                # Find name of the target FK field
                m = re.match('FOREIGN KEY\(([^\***REMOVED******REMOVED*******REMOVED***\***REMOVED***.*', field_desc, re.I***REMOVED***
                field_name = m.groups(***REMOVED***[0***REMOVED***.strip('"'***REMOVED***
            else:
                field_name = field_desc.split(***REMOVED***[0***REMOVED***.strip('"'***REMOVED***

            cursor.execute("SELECT sql FROM sqlite_master WHERE tbl_name = %s", [table***REMOVED******REMOVED***
            result = cursor.fetchall(***REMOVED***[0***REMOVED***
            other_table_results = result[0***REMOVED***.strip(***REMOVED***
            li, ri = other_table_results.index('('***REMOVED***, other_table_results.rindex('***REMOVED***'***REMOVED***
            other_table_results = other_table_results[li + 1:ri***REMOVED***

            for other_desc in other_table_results.split(','***REMOVED***:
                other_desc = other_desc.strip(***REMOVED***
                if other_desc.startswith('UNIQUE'***REMOVED***:
                    continue

                other_name = other_desc.split(' ', 1***REMOVED***[0***REMOVED***.strip('"'***REMOVED***
                if other_name == column:
                    relations[field_name***REMOVED*** = (other_name, table***REMOVED***
                    break

        return relations

    def get_key_columns(self, cursor, table_name***REMOVED***:
        ***REMOVED***
        Returns a list of (column_name, referenced_table_name, referenced_column_name***REMOVED*** for all
        key columns in given table.
        ***REMOVED***
        key_columns = [***REMOVED***

        # Schema for this table
        cursor.execute("SELECT sql FROM sqlite_master WHERE tbl_name = %s AND type = %s", [table_name, "table"***REMOVED******REMOVED***
        results = cursor.fetchone(***REMOVED***[0***REMOVED***.strip(***REMOVED***
        results = results[results.index('('***REMOVED*** + 1:results.rindex('***REMOVED***'***REMOVED******REMOVED***

        # Walk through and look for references to other tables. SQLite doesn't
        # really have enforced references, but since it echoes out the SQL used
        # to create the table we can look for REFERENCES statements used there.
        for field_index, field_desc in enumerate(results.split(','***REMOVED******REMOVED***:
            field_desc = field_desc.strip(***REMOVED***
            if field_desc.startswith("UNIQUE"***REMOVED***:
                continue

            m = re.search('"(.****REMOVED***".*references (.****REMOVED*** \(["|***REMOVED***(.****REMOVED***["|***REMOVED***\***REMOVED***', field_desc, re.I***REMOVED***
            if not m:
                continue

            # This will append (column_name, referenced_table_name, referenced_column_name***REMOVED*** to key_columns
            key_columns.append(tuple(s.strip('"'***REMOVED*** for s in m.groups(***REMOVED******REMOVED******REMOVED***

        return key_columns

    def get_indexes(self, cursor, table_name***REMOVED***:
        indexes = {***REMOVED***
        for info in self._table_info(cursor, table_name***REMOVED***:
            if info['pk'***REMOVED*** != 0:
                indexes[info['name'***REMOVED******REMOVED*** = {'primary_key': True,
                                         'unique': False***REMOVED***
        cursor.execute('PRAGMA index_list(%s***REMOVED***' % self.connection.ops.quote_name(table_name***REMOVED******REMOVED***
        # seq, name, unique
        for index, unique in [(field[1***REMOVED***, field[2***REMOVED******REMOVED*** for field in cursor.fetchall(***REMOVED******REMOVED***:
            cursor.execute('PRAGMA index_info(%s***REMOVED***' % self.connection.ops.quote_name(index***REMOVED******REMOVED***
            info = cursor.fetchall(***REMOVED***
            # Skip indexes across multiple fields
            if len(info***REMOVED*** != 1:
                continue
            name = info[0***REMOVED***[2***REMOVED***  # seqno, cid, name
            indexes[name***REMOVED*** = {'primary_key': indexes.get(name, {***REMOVED******REMOVED***.get("primary_key", False***REMOVED***,
                             'unique': unique***REMOVED***
        return indexes

    def get_primary_key_column(self, cursor, table_name***REMOVED***:
        ***REMOVED***
        Get the column name of the primary key for the given table.
        ***REMOVED***
        # Don't use PRAGMA because that causes issues with some transactions
        cursor.execute("SELECT sql FROM sqlite_master WHERE tbl_name = %s AND type = %s", [table_name, "table"***REMOVED******REMOVED***
        row = cursor.fetchone(***REMOVED***
        if row is None:
            raise ValueError("Table %s does not exist" % table_name***REMOVED***
        results = row[0***REMOVED***.strip(***REMOVED***
        results = results[results.index('('***REMOVED*** + 1:results.rindex('***REMOVED***'***REMOVED******REMOVED***
        for field_desc in results.split(','***REMOVED***:
            field_desc = field_desc.strip(***REMOVED***
            m = re.search('"(.****REMOVED***".*PRIMARY KEY( AUTOINCREMENT***REMOVED***?$', field_desc***REMOVED***
            if m:
                return m.groups(***REMOVED***[0***REMOVED***
        return None

    def _table_info(self, cursor, name***REMOVED***:
        cursor.execute('PRAGMA table_info(%s***REMOVED***' % self.connection.ops.quote_name(name***REMOVED******REMOVED***
        # cid, name, type, notnull, default_value, pk
        return [{
            'name': field[1***REMOVED***,
            'type': field[2***REMOVED***,
            'size': get_field_size(field[2***REMOVED******REMOVED***,
            'null_ok': not field[3***REMOVED***,
            'default': field[4***REMOVED***,
            'pk': field[5***REMOVED***,  # undocumented
    ***REMOVED*** for field in cursor.fetchall(***REMOVED******REMOVED***

    def get_constraints(self, cursor, table_name***REMOVED***:
        ***REMOVED***
        Retrieves any constraints or keys (unique, pk, fk, check, index***REMOVED*** across one or more columns.
        ***REMOVED***
        constraints = {***REMOVED***
        # Get the index info
        cursor.execute("PRAGMA index_list(%s***REMOVED***" % self.connection.ops.quote_name(table_name***REMOVED******REMOVED***
        for row in cursor.fetchall(***REMOVED***:
            # Sqlite3 3.8.9+ has 5 columns, however older versions only give 3
            # columns. Discard last 2 columns if there.
            number, index, unique = row[:3***REMOVED***
            # Get the index info for that index
            cursor.execute('PRAGMA index_info(%s***REMOVED***' % self.connection.ops.quote_name(index***REMOVED******REMOVED***
            for index_rank, column_rank, column in cursor.fetchall(***REMOVED***:
                if index not in constraints:
                    constraints[index***REMOVED*** = {
                        "columns": [***REMOVED***,
                        "primary_key": False,
                        "unique": bool(unique***REMOVED***,
                        "foreign_key": False,
                        "check": False,
                        "index": True,
                ***REMOVED***
                constraints[index***REMOVED***['columns'***REMOVED***.append(column***REMOVED***
        # Get the PK
        pk_column = self.get_primary_key_column(cursor, table_name***REMOVED***
        if pk_column:
            # SQLite doesn't actually give a name to the PK constraint,
            # so we invent one. This is fine, as the SQLite backend never
            # deletes PK constraints by name, as you can't delete constraints
            # in SQLite; we remake the table with a new PK instead.
            constraints["__primary__"***REMOVED*** = {
                "columns": [pk_column***REMOVED***,
                "primary_key": True,
                "unique": False,  # It's not actually a unique constraint.
                "foreign_key": False,
                "check": False,
                "index": False,
        ***REMOVED***
        return constraints
