***REMOVED***
SQLite3 backend for django.

Works with either the pysqlite2 module or the sqlite3 module in the
standard library.
***REMOVED***
from __future__ import unicode_literals

import datetime
import decimal
import re
import warnings

from django.conf import settings
from django.db import utils
from django.db.backends import utils as backend_utils
from django.db.backends.base.base import BaseDatabaseWrapper
from django.db.backends.base.validation import BaseDatabaseValidation
from django.utils import six, timezone
from django.utils.dateparse import (
    parse_date, parse_datetime, parse_duration, parse_time,
***REMOVED***
from django.utils.deprecation import RemovedInDjango20Warning
from django.utils.encoding import force_text
from django.utils.safestring import SafeBytes

***REMOVED***
    import pytz
except ImportError:
    pytz = None

***REMOVED***
    ***REMOVED***
        from pysqlite2 import dbapi2 as Database
    except ImportError:
        from sqlite3 import dbapi2 as Database
except ImportError as exc:
    from django.core.exceptions import ImproperlyConfigured
    raise ImproperlyConfigured("Error loading either pysqlite2 or sqlite3 modules (tried in that order***REMOVED***: %s" % exc***REMOVED***

# Some of these import sqlite3, so import them after checking if it's installed.
from .client import DatabaseClient                          # isort:skip
from .creation import DatabaseCreation                      # isort:skip
from .features import DatabaseFeatures                      # isort:skip
from .introspection import DatabaseIntrospection            # isort:skip
from .operations import DatabaseOperations                  # isort:skip
from .schema import DatabaseSchemaEditor                    # isort:skip

DatabaseError = Database.DatabaseError
IntegrityError = Database.IntegrityError


def adapt_datetime_warn_on_aware_datetime(value***REMOVED***:
    # Remove this function and rely on the default adapter in Django 2.0.
    if settings.USE_TZ and timezone.is_aware(value***REMOVED***:
        warnings.warn(
            "The SQLite database adapter received an aware datetime (%s***REMOVED***, "
            "probably from cursor.execute(***REMOVED***. Update your code to pass a "
            "naive datetime in the database connection's time zone (UTC by "
            "default***REMOVED***.", RemovedInDjango20Warning***REMOVED***
        # This doesn't account for the database connection's timezone,
        # which isn't known. (That's why this adapter is deprecated.***REMOVED***
        value = value.astimezone(timezone.utc***REMOVED***.replace(tzinfo=None***REMOVED***
    return value.isoformat(str(" "***REMOVED******REMOVED***


def decoder(conv_func***REMOVED***:
    ***REMOVED*** The Python sqlite3 interface returns always byte strings.
        This function converts the received value to a regular string before
        passing it to the receiver function.
    ***REMOVED***
    return lambda s: conv_func(s.decode('utf-8'***REMOVED******REMOVED***

Database.register_converter(str("bool"***REMOVED***, decoder(lambda s: s == '1'***REMOVED******REMOVED***
Database.register_converter(str("time"***REMOVED***, decoder(parse_time***REMOVED******REMOVED***
Database.register_converter(str("date"***REMOVED***, decoder(parse_date***REMOVED******REMOVED***
Database.register_converter(str("datetime"***REMOVED***, decoder(parse_datetime***REMOVED******REMOVED***
Database.register_converter(str("timestamp"***REMOVED***, decoder(parse_datetime***REMOVED******REMOVED***
Database.register_converter(str("TIMESTAMP"***REMOVED***, decoder(parse_datetime***REMOVED******REMOVED***
Database.register_converter(str("decimal"***REMOVED***, decoder(backend_utils.typecast_decimal***REMOVED******REMOVED***

Database.register_adapter(datetime.datetime, adapt_datetime_warn_on_aware_datetime***REMOVED***
Database.register_adapter(decimal.Decimal, backend_utils.rev_typecast_decimal***REMOVED***
if six.PY2:
    Database.register_adapter(str, lambda s: s.decode('utf-8'***REMOVED******REMOVED***
    Database.register_adapter(SafeBytes, lambda s: s.decode('utf-8'***REMOVED******REMOVED***


class DatabaseWrapper(BaseDatabaseWrapper***REMOVED***:
    vendor = 'sqlite'
    # SQLite doesn't actually support most of these types, but it "does the right
    # thing" given more verbose field definitions, so leave them as is so that
    # schema inspection is more useful.
    data_types = {
        'AutoField': 'integer',
        'BigAutoField': 'integer',
        'BinaryField': 'BLOB',
        'BooleanField': 'bool',
        'CharField': 'varchar(%(max_length***REMOVED***s***REMOVED***',
        'CommaSeparatedIntegerField': 'varchar(%(max_length***REMOVED***s***REMOVED***',
        'DateField': 'date',
        'DateTimeField': 'datetime',
        'DecimalField': 'decimal',
        'DurationField': 'bigint',
        'FileField': 'varchar(%(max_length***REMOVED***s***REMOVED***',
        'FilePathField': 'varchar(%(max_length***REMOVED***s***REMOVED***',
        'FloatField': 'real',
        'IntegerField': 'integer',
        'BigIntegerField': 'bigint',
        'IPAddressField': 'char(15***REMOVED***',
        'GenericIPAddressField': 'char(39***REMOVED***',
        'NullBooleanField': 'bool',
        'OneToOneField': 'integer',
        'PositiveIntegerField': 'integer unsigned',
        'PositiveSmallIntegerField': 'smallint unsigned',
        'SlugField': 'varchar(%(max_length***REMOVED***s***REMOVED***',
        'SmallIntegerField': 'smallint',
        'TextField': 'text',
        'TimeField': 'time',
        'UUIDField': 'char(32***REMOVED***',
***REMOVED***
    data_types_suffix = {
        'AutoField': 'AUTOINCREMENT',
        'BigAutoField': 'AUTOINCREMENT',
***REMOVED***
    # SQLite requires LIKE statements to include an ESCAPE clause if the value
    # being escaped has a percent or underscore in it.
    # See http://www.sqlite.org/lang_expr.html for an explanation.
    operators = {
        'exact': '= %s',
        'iexact': "LIKE %s ESCAPE '\\'",
        'contains': "LIKE %s ESCAPE '\\'",
        'icontains': "LIKE %s ESCAPE '\\'",
        'regex': 'REGEXP %s',
        'iregex': "REGEXP '(?i***REMOVED***' || %s",
        'gt': '> %s',
        'gte': '>= %s',
        'lt': '< %s',
        'lte': '<= %s',
        'startswith': "LIKE %s ESCAPE '\\'",
        'endswith': "LIKE %s ESCAPE '\\'",
        'istartswith': "LIKE %s ESCAPE '\\'",
        'iendswith': "LIKE %s ESCAPE '\\'",
***REMOVED***

    # The patterns below are used to generate SQL pattern lookup clauses when
    # the right-hand side of the lookup isn't a raw string (it might be an expression
    # or the result of a bilateral transformation***REMOVED***.
    # In those cases, special characters for LIKE operators (e.g. \, *, _***REMOVED*** should be
    # escaped on database side.
    #
    # Note: we use str.format(***REMOVED*** here for readability as '%' is used as a wildcard for
    # the LIKE operator.
    pattern_esc = r"REPLACE(REPLACE(REPLACE({***REMOVED***, '\', '\\'***REMOVED***, '%%', '\%%'***REMOVED***, '_', '\_'***REMOVED***"
    pattern_ops = {
        'contains': r"LIKE '%%' || {***REMOVED*** || '%%' ESCAPE '\'",
        'icontains': r"LIKE '%%' || UPPER({***REMOVED******REMOVED*** || '%%' ESCAPE '\'",
        'startswith': r"LIKE {***REMOVED*** || '%%' ESCAPE '\'",
        'istartswith': r"LIKE UPPER({***REMOVED******REMOVED*** || '%%' ESCAPE '\'",
        'endswith': r"LIKE '%%' || {***REMOVED*** ESCAPE '\'",
        'iendswith': r"LIKE '%%' || UPPER({***REMOVED******REMOVED*** ESCAPE '\'",
***REMOVED***

    Database = Database
    SchemaEditorClass = DatabaseSchemaEditor

    def __init__(self, *args, **kwargs***REMOVED***:
        super(DatabaseWrapper, self***REMOVED***.__init__(*args, **kwargs***REMOVED***

        self.features = DatabaseFeatures(self***REMOVED***
        self.ops = DatabaseOperations(self***REMOVED***
        self.client = DatabaseClient(self***REMOVED***
        self.creation = DatabaseCreation(self***REMOVED***
        self.introspection = DatabaseIntrospection(self***REMOVED***
        self.validation = BaseDatabaseValidation(self***REMOVED***

    def get_connection_params(self***REMOVED***:
        settings_dict = self.settings_dict
        if not settings_dict['NAME'***REMOVED***:
            from django.core.exceptions import ImproperlyConfigured
            raise ImproperlyConfigured(
                "settings.DATABASES is improperly configured. "
                "Please supply the NAME value."***REMOVED***
        kwargs = {
            'database': settings_dict['NAME'***REMOVED***,
            'detect_types': Database.PARSE_DECLTYPES | Database.PARSE_COLNAMES,
    ***REMOVED***
        kwargs.update(settings_dict['OPTIONS'***REMOVED******REMOVED***
        # Always allow the underlying SQLite connection to be shareable
        # between multiple threads. The safe-guarding will be handled at a
        # higher level by the `BaseDatabaseWrapper.allow_thread_sharing`
        # property. This is necessary as the shareability is disabled by
        # default in pysqlite and it cannot be changed once a connection is
        # opened.
        if 'check_same_thread' in kwargs and kwargs['check_same_thread'***REMOVED***:
            warnings.warn(
                'The `check_same_thread` option was provided and set to '
                'True. It will be overridden with False. Use the '
                '`DatabaseWrapper.allow_thread_sharing` property instead '
                'for controlling thread shareability.',
                RuntimeWarning
            ***REMOVED***
        kwargs.update({'check_same_thread': False***REMOVED******REMOVED***
        if self.features.can_share_in_memory_db:
            kwargs.update({'uri': True***REMOVED******REMOVED***
        return kwargs

    def get_new_connection(self, conn_params***REMOVED***:
        conn = Database.connect(**conn_params***REMOVED***
        conn.create_function("django_date_extract", 2, _sqlite_date_extract***REMOVED***
        conn.create_function("django_date_trunc", 2, _sqlite_date_trunc***REMOVED***
        conn.create_function("django_datetime_cast_date", 2, _sqlite_datetime_cast_date***REMOVED***
        conn.create_function("django_datetime_extract", 3, _sqlite_datetime_extract***REMOVED***
        conn.create_function("django_datetime_trunc", 3, _sqlite_datetime_trunc***REMOVED***
        conn.create_function("django_time_extract", 2, _sqlite_time_extract***REMOVED***
        conn.create_function("django_time_diff", 2, _sqlite_time_diff***REMOVED***
        conn.create_function("django_timestamp_diff", 2, _sqlite_timestamp_diff***REMOVED***
        conn.create_function("regexp", 2, _sqlite_regexp***REMOVED***
        conn.create_function("django_format_dtdelta", 3, _sqlite_format_dtdelta***REMOVED***
        conn.create_function("django_power", 2, _sqlite_power***REMOVED***
        return conn

    def init_connection_state(self***REMOVED***:
        pass

    def create_cursor(self***REMOVED***:
        return self.connection.cursor(factory=SQLiteCursorWrapper***REMOVED***

    def close(self***REMOVED***:
        self.validate_thread_sharing(***REMOVED***
        # If database is in memory, closing the connection destroys the
        # database. To prevent accidental data loss, ignore close requests on
        # an in-memory db.
        if not self.is_in_memory_db(self.settings_dict['NAME'***REMOVED******REMOVED***:
            BaseDatabaseWrapper.close(self***REMOVED***

    def _savepoint_allowed(self***REMOVED***:
        # Two conditions are required here:
        # - A sufficiently recent version of SQLite to support savepoints,
        # - Being in a transaction, which can only happen inside 'atomic'.

        # When 'isolation_level' is not None, sqlite3 commits before each
        # savepoint; it's a bug. When it is None, savepoints don't make sense
        # because autocommit is enabled. The only exception is inside 'atomic'
        # blocks. To work around that bug, on SQLite, 'atomic' starts a
        # transaction explicitly rather than simply disable autocommit.
        return self.features.uses_savepoints and self.in_atomic_block

    def _set_autocommit(self, autocommit***REMOVED***:
        if autocommit:
            level = None
        else:
            # sqlite3's internal default is ''. It's different from None.
            # See Modules/_sqlite/connection.c.
            level = ''
        # 'isolation_level' is a misleading API.
        # SQLite always runs at the SERIALIZABLE isolation level.
        with self.wrap_database_errors:
            self.connection.isolation_level = level

    def check_constraints(self, table_names=None***REMOVED***:
        ***REMOVED***
        Checks each table name in `table_names` for rows with invalid foreign
        key references. This method is intended to be used in conjunction with
        `disable_constraint_checking(***REMOVED***` and `enable_constraint_checking(***REMOVED***`, to
        determine if rows with invalid references were entered while constraint
        checks were off.

        Raises an IntegrityError on the first invalid foreign key reference
        encountered (if any***REMOVED*** and provides detailed information about the
        invalid reference in the error message.

        Backends can override this method if they can more directly apply
        constraint checking (e.g. via "SET CONSTRAINTS ALL IMMEDIATE"***REMOVED***
        ***REMOVED***
        cursor = self.cursor(***REMOVED***
        if table_names is None:
            table_names = self.introspection.table_names(cursor***REMOVED***
        for table_name in table_names:
            primary_key_column_name = self.introspection.get_primary_key_column(cursor, table_name***REMOVED***
            if not primary_key_column_name:
                continue
            key_columns = self.introspection.get_key_columns(cursor, table_name***REMOVED***
            for column_name, referenced_table_name, referenced_column_name in key_columns:
                cursor.execute(
                    ***REMOVED***
                    SELECT REFERRING.`%s`, REFERRING.`%s` FROM `%s` as REFERRING
                    LEFT JOIN `%s` as REFERRED
                    ON (REFERRING.`%s` = REFERRED.`%s`***REMOVED***
                    WHERE REFERRING.`%s` IS NOT NULL AND REFERRED.`%s` IS NULL
                    ***REMOVED***
                    % (
                        primary_key_column_name, column_name, table_name,
                        referenced_table_name, column_name, referenced_column_name,
                        column_name, referenced_column_name,
                    ***REMOVED***
                ***REMOVED***
                for bad_row in cursor.fetchall(***REMOVED***:
                    raise utils.IntegrityError(
                        "The row in table '%s' with primary key '%s' has an "
                        "invalid foreign key: %s.%s contains a value '%s' that "
                        "does not have a corresponding value in %s.%s." % (
                            table_name, bad_row[0***REMOVED***, table_name, column_name,
                            bad_row[1***REMOVED***, referenced_table_name, referenced_column_name,
                        ***REMOVED***
                    ***REMOVED***

    def is_usable(self***REMOVED***:
        return True

    def _start_transaction_under_autocommit(self***REMOVED***:
        ***REMOVED***
        Start a transaction explicitly in autocommit mode.

        Staying in autocommit mode works around a bug of sqlite3 that breaks
        savepoints when autocommit is disabled.
        ***REMOVED***
        self.cursor(***REMOVED***.execute("BEGIN"***REMOVED***

    def is_in_memory_db(self, name***REMOVED***:
        return name == ":memory:" or "mode=memory" in force_text(name***REMOVED***


FORMAT_QMARK_REGEX = re.compile(r'(?<!%***REMOVED***%s'***REMOVED***


class SQLiteCursorWrapper(Database.Cursor***REMOVED***:
    ***REMOVED***
    Django uses "format" style placeholders, but pysqlite2 uses "qmark" style.
    This fixes it -- but note that if you want to use a literal "%s" in a query,
    you'll need to use "%%s".
    ***REMOVED***
    def execute(self, query, params=None***REMOVED***:
        if params is None:
            return Database.Cursor.execute(self, query***REMOVED***
        query = self.convert_query(query***REMOVED***
        return Database.Cursor.execute(self, query, params***REMOVED***

    def executemany(self, query, param_list***REMOVED***:
        query = self.convert_query(query***REMOVED***
        return Database.Cursor.executemany(self, query, param_list***REMOVED***

    def convert_query(self, query***REMOVED***:
        return FORMAT_QMARK_REGEX.sub('?', query***REMOVED***.replace('%%', '%'***REMOVED***


def _sqlite_date_extract(lookup_type, dt***REMOVED***:
    if dt is None:
        return None
    ***REMOVED***
        dt = backend_utils.typecast_timestamp(dt***REMOVED***
    except (ValueError, TypeError***REMOVED***:
        return None
    if lookup_type == 'week_day':
        return (dt.isoweekday(***REMOVED*** % 7***REMOVED*** + 1
    else:
        return getattr(dt, lookup_type***REMOVED***


def _sqlite_date_trunc(lookup_type, dt***REMOVED***:
    ***REMOVED***
        dt = backend_utils.typecast_timestamp(dt***REMOVED***
    except (ValueError, TypeError***REMOVED***:
        return None
    if lookup_type == 'year':
        return "%i-01-01" % dt.year
    elif lookup_type == 'month':
        return "%i-%02i-01" % (dt.year, dt.month***REMOVED***
    elif lookup_type == 'day':
        return "%i-%02i-%02i" % (dt.year, dt.month, dt.day***REMOVED***


def _sqlite_datetime_parse(dt, tzname***REMOVED***:
    if dt is None:
        return None
    ***REMOVED***
        dt = backend_utils.typecast_timestamp(dt***REMOVED***
    except (ValueError, TypeError***REMOVED***:
        return None
    if tzname is not None:
        dt = timezone.localtime(dt, pytz.timezone(tzname***REMOVED******REMOVED***
    return dt


def _sqlite_datetime_cast_date(dt, tzname***REMOVED***:
    dt = _sqlite_datetime_parse(dt, tzname***REMOVED***
    if dt is None:
        return None
    return dt.date(***REMOVED***.isoformat(***REMOVED***


def _sqlite_datetime_extract(lookup_type, dt, tzname***REMOVED***:
    dt = _sqlite_datetime_parse(dt, tzname***REMOVED***
    if dt is None:
        return None
    if lookup_type == 'week_day':
        return (dt.isoweekday(***REMOVED*** % 7***REMOVED*** + 1
    else:
        return getattr(dt, lookup_type***REMOVED***


def _sqlite_datetime_trunc(lookup_type, dt, tzname***REMOVED***:
    dt = _sqlite_datetime_parse(dt, tzname***REMOVED***
    if dt is None:
        return None
    if lookup_type == 'year':
        return "%i-01-01 00:00:00" % dt.year
    elif lookup_type == 'month':
        return "%i-%02i-01 00:00:00" % (dt.year, dt.month***REMOVED***
    elif lookup_type == 'day':
        return "%i-%02i-%02i 00:00:00" % (dt.year, dt.month, dt.day***REMOVED***
    elif lookup_type == 'hour':
        return "%i-%02i-%02i %02i:00:00" % (dt.year, dt.month, dt.day, dt.hour***REMOVED***
    elif lookup_type == 'minute':
        return "%i-%02i-%02i %02i:%02i:00" % (dt.year, dt.month, dt.day, dt.hour, dt.minute***REMOVED***
    elif lookup_type == 'second':
        return "%i-%02i-%02i %02i:%02i:%02i" % (dt.year, dt.month, dt.day, dt.hour, dt.minute, dt.second***REMOVED***


def _sqlite_time_extract(lookup_type, dt***REMOVED***:
    if dt is None:
        return None
    ***REMOVED***
        dt = backend_utils.typecast_time(dt***REMOVED***
    except (ValueError, TypeError***REMOVED***:
        return None
    return getattr(dt, lookup_type***REMOVED***


def _sqlite_format_dtdelta(conn, lhs, rhs***REMOVED***:
    ***REMOVED***
    LHS and RHS can be either:
        - An integer number of microseconds
        - A string representing a timedelta object
        - A string representing a datetime
    ***REMOVED***
    ***REMOVED***
        if isinstance(lhs, six.integer_types***REMOVED***:
            lhs = str(decimal.Decimal(lhs***REMOVED*** / decimal.Decimal(1000000***REMOVED******REMOVED***
        real_lhs = parse_duration(lhs***REMOVED***
        if real_lhs is None:
            real_lhs = backend_utils.typecast_timestamp(lhs***REMOVED***
        if isinstance(rhs, six.integer_types***REMOVED***:
            rhs = str(decimal.Decimal(rhs***REMOVED*** / decimal.Decimal(1000000***REMOVED******REMOVED***
        real_rhs = parse_duration(rhs***REMOVED***
        if real_rhs is None:
            real_rhs = backend_utils.typecast_timestamp(rhs***REMOVED***
        if conn.strip(***REMOVED*** == '+':
            out = real_lhs + real_rhs
        else:
            out = real_lhs - real_rhs
    except (ValueError, TypeError***REMOVED***:
        return None
    # typecast_timestamp returns a date or a datetime without timezone.
    # It will be formatted as "%Y-%m-%d" or "%Y-%m-%d %H:%M:%S[.%f***REMOVED***"
    return str(out***REMOVED***


def _sqlite_time_diff(lhs, rhs***REMOVED***:
    left = backend_utils.typecast_time(lhs***REMOVED***
    right = backend_utils.typecast_time(rhs***REMOVED***
    return (
        (left.hour * 60 * 60 * 1000000***REMOVED*** +
        (left.minute * 60 * 1000000***REMOVED*** +
        (left.second * 1000000***REMOVED*** +
        (left.microsecond***REMOVED*** -
        (right.hour * 60 * 60 * 1000000***REMOVED*** -
        (right.minute * 60 * 1000000***REMOVED*** -
        (right.second * 1000000***REMOVED*** -
        (right.microsecond***REMOVED***
    ***REMOVED***


def _sqlite_timestamp_diff(lhs, rhs***REMOVED***:
    left = backend_utils.typecast_timestamp(lhs***REMOVED***
    right = backend_utils.typecast_timestamp(rhs***REMOVED***
    return (left - right***REMOVED***.total_seconds(***REMOVED*** * 1000000


def _sqlite_regexp(re_pattern, re_string***REMOVED***:
    return bool(re.search(re_pattern, force_text(re_string***REMOVED******REMOVED******REMOVED*** if re_string is not None else False


def _sqlite_power(x, y***REMOVED***:
    return x ** y
