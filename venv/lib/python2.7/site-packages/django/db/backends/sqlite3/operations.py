from __future__ import unicode_literals

import datetime
import uuid

from django.conf import settings
from django.core.exceptions import FieldError, ImproperlyConfigured
from django.db import utils
from django.db.backends import utils as backend_utils
from django.db.backends.base.operations import BaseDatabaseOperations
from django.db.models import aggregates, fields
from django.utils import six, timezone
from django.utils.dateparse import parse_date, parse_datetime, parse_time
from django.utils.duration import duration_string

***REMOVED***
    import pytz
except ImportError:
    pytz = None


class DatabaseOperations(BaseDatabaseOperations***REMOVED***:
    def bulk_batch_size(self, fields, objs***REMOVED***:
        ***REMOVED***
        SQLite has a compile-time default (SQLITE_LIMIT_VARIABLE_NUMBER***REMOVED*** of
        999 variables per query.

        If there is just single field to insert, then we can hit another
        limit, SQLITE_MAX_COMPOUND_SELECT which defaults to 500.
        ***REMOVED***
        limit = 999 if len(fields***REMOVED*** > 1 else 500
        return (limit // len(fields***REMOVED******REMOVED*** if len(fields***REMOVED*** > 0 else len(objs***REMOVED***

    def check_expression_support(self, expression***REMOVED***:
        bad_fields = (fields.DateField, fields.DateTimeField, fields.TimeField***REMOVED***
        bad_aggregates = (aggregates.Sum, aggregates.Avg, aggregates.Variance, aggregates.StdDev***REMOVED***
        if isinstance(expression, bad_aggregates***REMOVED***:
            for expr in expression.get_source_expressions(***REMOVED***:
                ***REMOVED***
                    output_field = expr.output_field
                    if isinstance(output_field, bad_fields***REMOVED***:
                        raise NotImplementedError(
                            'You cannot use Sum, Avg, StdDev, and Variance '
                            'aggregations on date/time fields in sqlite3 '
                            'since date/time is saved as text.'
                        ***REMOVED***
                except FieldError:
                    # Not every subexpression has an output_field which is fine
                    # to ignore.
                    pass

    def date_extract_sql(self, lookup_type, field_name***REMOVED***:
        # sqlite doesn't support extract, so we fake it with the user-defined
        # function django_date_extract that's registered in connect(***REMOVED***. Note that
        # single quotes are used because this is a string (and could otherwise
        # cause a collision with a field name***REMOVED***.
        return "django_date_extract('%s', %s***REMOVED***" % (lookup_type.lower(***REMOVED***, field_name***REMOVED***

    def date_interval_sql(self, timedelta***REMOVED***:
        return "'%s'" % duration_string(timedelta***REMOVED***, [***REMOVED***

    def format_for_duration_arithmetic(self, sql***REMOVED***:
        ***REMOVED***Do nothing here, we will handle it in the custom function.***REMOVED***
        return sql

    def date_trunc_sql(self, lookup_type, field_name***REMOVED***:
        # sqlite doesn't support DATE_TRUNC, so we fake it with a user-defined
        # function django_date_trunc that's registered in connect(***REMOVED***. Note that
        # single quotes are used because this is a string (and could otherwise
        # cause a collision with a field name***REMOVED***.
        return "django_date_trunc('%s', %s***REMOVED***" % (lookup_type.lower(***REMOVED***, field_name***REMOVED***

    def _require_pytz(self***REMOVED***:
        if settings.USE_TZ and pytz is None:
            raise ImproperlyConfigured("This query requires pytz, but it isn't installed."***REMOVED***

    def datetime_cast_date_sql(self, field_name, tzname***REMOVED***:
        self._require_pytz(***REMOVED***
        return "django_datetime_cast_date(%s, %%s***REMOVED***" % field_name, [tzname***REMOVED***

    def datetime_extract_sql(self, lookup_type, field_name, tzname***REMOVED***:
        # Same comment as in date_extract_sql.
        self._require_pytz(***REMOVED***
        return "django_datetime_extract('%s', %s, %%s***REMOVED***" % (
            lookup_type.lower(***REMOVED***, field_name***REMOVED***, [tzname***REMOVED***

    def datetime_trunc_sql(self, lookup_type, field_name, tzname***REMOVED***:
        # Same comment as in date_trunc_sql.
        self._require_pytz(***REMOVED***
        return "django_datetime_trunc('%s', %s, %%s***REMOVED***" % (
            lookup_type.lower(***REMOVED***, field_name***REMOVED***, [tzname***REMOVED***

    def time_extract_sql(self, lookup_type, field_name***REMOVED***:
        # sqlite doesn't support extract, so we fake it with the user-defined
        # function django_time_extract that's registered in connect(***REMOVED***. Note that
        # single quotes are used because this is a string (and could otherwise
        # cause a collision with a field name***REMOVED***.
        return "django_time_extract('%s', %s***REMOVED***" % (lookup_type.lower(***REMOVED***, field_name***REMOVED***

    def drop_foreignkey_sql(self***REMOVED***:
        return ""

    def pk_default_value(self***REMOVED***:
        return "NULL"

    def _quote_params_for_last_executed_query(self, params***REMOVED***:
        ***REMOVED***
        Only for last_executed_query! Don't use this to execute SQL queries!
        ***REMOVED***
        # This function is limited both by SQLITE_LIMIT_VARIABLE_NUMBER (the
        # number of parameters, default = 999***REMOVED*** and SQLITE_MAX_COLUMN (the
        # number of return values, default = 2000***REMOVED***. Since Python's sqlite3
        # module doesn't expose the get_limit(***REMOVED*** C API, assume the default
        # limits are in effect and split the work in batches if needed.
        BATCH_SIZE = 999
        if len(params***REMOVED*** > BATCH_SIZE:
            results = (***REMOVED***
            for index in range(0, len(params***REMOVED***, BATCH_SIZE***REMOVED***:
                chunk = params[index:index + BATCH_SIZE***REMOVED***
                results += self._quote_params_for_last_executed_query(chunk***REMOVED***
            return results

        sql = 'SELECT ' + ', '.join(['QUOTE(?***REMOVED***'***REMOVED*** * len(params***REMOVED******REMOVED***
        # Bypass Django's wrappers and use the underlying sqlite3 connection
        # to avoid logging this query - it would trigger infinite recursion.
        cursor = self.connection.connection.cursor(***REMOVED***
        # Native sqlite3 cursors cannot be used as context managers.
        ***REMOVED***
            return cursor.execute(sql, params***REMOVED***.fetchone(***REMOVED***
        finally:
            cursor.close(***REMOVED***

    def last_executed_query(self, cursor, sql, params***REMOVED***:
        # Python substitutes parameters in Modules/_sqlite/cursor.c with:
        # pysqlite_statement_bind_parameters(self->statement, parameters, allow_8bit_chars***REMOVED***;
        # Unfortunately there is no way to reach self->statement from Python,
        # so we quote and substitute parameters manually.
        if params:
            if isinstance(params, (list, tuple***REMOVED******REMOVED***:
                params = self._quote_params_for_last_executed_query(params***REMOVED***
            else:
                keys = params.keys(***REMOVED***
                values = tuple(params.values(***REMOVED******REMOVED***
                values = self._quote_params_for_last_executed_query(values***REMOVED***
                params = dict(zip(keys, values***REMOVED******REMOVED***
            return sql % params
        # For consistency with SQLiteCursorWrapper.execute(***REMOVED***, just return sql
        # when there are no parameters. See #13648 and #17158.
        else:
            return sql

    def quote_name(self, name***REMOVED***:
        if name.startswith('"'***REMOVED*** and name.endswith('"'***REMOVED***:
            return name  # Quoting once is enough.
        return '"%s"' % name

    def no_limit_value(self***REMOVED***:
        return -1

    def sql_flush(self, style, tables, sequences, allow_cascade=False***REMOVED***:
        # NB: The generated SQL below is specific to SQLite
        # Note: The DELETE FROM... SQL generated below works for SQLite databases
        # because constraints don't exist
        sql = ['%s %s %s;' % (
            style.SQL_KEYWORD('DELETE'***REMOVED***,
            style.SQL_KEYWORD('FROM'***REMOVED***,
            style.SQL_FIELD(self.quote_name(table***REMOVED******REMOVED***
        ***REMOVED*** for table in tables***REMOVED***
        # Note: No requirement for reset of auto-incremented indices (cf. other
        # sql_flush(***REMOVED*** implementations***REMOVED***. Just return SQL at this point
        return sql

    def adapt_datetimefield_value(self, value***REMOVED***:
        if value is None:
            return None

        # SQLite doesn't support tz-aware datetimes
        if timezone.is_aware(value***REMOVED***:
            if settings.USE_TZ:
                value = timezone.make_naive(value, self.connection.timezone***REMOVED***
            else:
                raise ValueError("SQLite backend does not support timezone-aware datetimes when USE_TZ is False."***REMOVED***

        return six.text_type(value***REMOVED***

    def adapt_timefield_value(self, value***REMOVED***:
        if value is None:
            return None

        # SQLite doesn't support tz-aware datetimes
        if timezone.is_aware(value***REMOVED***:
            raise ValueError("SQLite backend does not support timezone-aware times."***REMOVED***

        return six.text_type(value***REMOVED***

    def get_db_converters(self, expression***REMOVED***:
        converters = super(DatabaseOperations, self***REMOVED***.get_db_converters(expression***REMOVED***
        internal_type = expression.output_field.get_internal_type(***REMOVED***
        if internal_type == 'DateTimeField':
            converters.append(self.convert_datetimefield_value***REMOVED***
        elif internal_type == 'DateField':
            converters.append(self.convert_datefield_value***REMOVED***
        elif internal_type == 'TimeField':
            converters.append(self.convert_timefield_value***REMOVED***
        elif internal_type == 'DecimalField':
            converters.append(self.convert_decimalfield_value***REMOVED***
        elif internal_type == 'UUIDField':
            converters.append(self.convert_uuidfield_value***REMOVED***
        return converters

    def convert_datetimefield_value(self, value, expression, connection, context***REMOVED***:
        if value is not None:
            if not isinstance(value, datetime.datetime***REMOVED***:
                value = parse_datetime(value***REMOVED***
            if settings.USE_TZ:
                value = timezone.make_aware(value, self.connection.timezone***REMOVED***
        return value

    def convert_datefield_value(self, value, expression, connection, context***REMOVED***:
        if value is not None:
            if not isinstance(value, datetime.date***REMOVED***:
                value = parse_date(value***REMOVED***
        return value

    def convert_timefield_value(self, value, expression, connection, context***REMOVED***:
        if value is not None:
            if not isinstance(value, datetime.time***REMOVED***:
                value = parse_time(value***REMOVED***
        return value

    def convert_decimalfield_value(self, value, expression, connection, context***REMOVED***:
        if value is not None:
            value = expression.output_field.format_number(value***REMOVED***
            value = backend_utils.typecast_decimal(value***REMOVED***
        return value

    def convert_uuidfield_value(self, value, expression, connection, context***REMOVED***:
        if value is not None:
            value = uuid.UUID(value***REMOVED***
        return value

    def bulk_insert_sql(self, fields, placeholder_rows***REMOVED***:
        return " UNION ALL ".join(
            "SELECT %s" % ", ".join(row***REMOVED***
            for row in placeholder_rows
        ***REMOVED***

    def combine_expression(self, connector, sub_expressions***REMOVED***:
        # SQLite doesn't have a power function, so we fake it with a
        # user-defined function django_power that's registered in connect(***REMOVED***.
        if connector == '^':
            return 'django_power(%s***REMOVED***' % ','.join(sub_expressions***REMOVED***
        return super(DatabaseOperations, self***REMOVED***.combine_expression(connector, sub_expressions***REMOVED***

    def combine_duration_expression(self, connector, sub_expressions***REMOVED***:
        if connector not in ['+', '-'***REMOVED***:
            raise utils.DatabaseError('Invalid connector for timedelta: %s.' % connector***REMOVED***
        fn_params = ["'%s'" % connector***REMOVED*** + sub_expressions
        if len(fn_params***REMOVED*** > 3:
            raise ValueError('Too many params for timedelta operations.'***REMOVED***
        return "django_format_dtdelta(%s***REMOVED***" % ', '.join(fn_params***REMOVED***

    def integer_field_range(self, internal_type***REMOVED***:
        # SQLite doesn't enforce any integer constraints
        return (None, None***REMOVED***

    def subtract_temporals(self, internal_type, lhs, rhs***REMOVED***:
        lhs_sql, lhs_params = lhs
        rhs_sql, rhs_params = rhs
        if internal_type == 'TimeField':
            return "django_time_diff(%s, %s***REMOVED***" % (lhs_sql, rhs_sql***REMOVED***, lhs_params + rhs_params
        return "django_timestamp_diff(%s, %s***REMOVED***" % (lhs_sql, rhs_sql***REMOVED***, lhs_params + rhs_params
