import codecs
import contextlib
import copy
from decimal import Decimal

from django.apps.registry import Apps
from django.db.backends.base.schema import BaseDatabaseSchemaEditor
from django.utils import six


class DatabaseSchemaEditor(BaseDatabaseSchemaEditor***REMOVED***:

    sql_delete_table = "DROP TABLE %(table***REMOVED***s"
    sql_create_inline_fk = "REFERENCES %(to_table***REMOVED***s (%(to_column***REMOVED***s***REMOVED***"
    sql_create_unique = "CREATE UNIQUE INDEX %(name***REMOVED***s ON %(table***REMOVED***s (%(columns***REMOVED***s***REMOVED***"
    sql_delete_unique = "DROP INDEX %(name***REMOVED***s"

    def __enter__(self***REMOVED***:
        with self.connection.cursor(***REMOVED*** as c:
            # Some SQLite schema alterations need foreign key constraints to be
            # disabled. This is the default in SQLite but can be changed with a
            # build flag and might change in future, so can't be relied upon.
            # We enforce it here for the duration of the transaction.
            c.execute('PRAGMA foreign_keys'***REMOVED***
            self._initial_pragma_fk = c.fetchone(***REMOVED***[0***REMOVED***
            c.execute('PRAGMA foreign_keys = 0'***REMOVED***
        return super(DatabaseSchemaEditor, self***REMOVED***.__enter__(***REMOVED***

    def __exit__(self, exc_type, exc_value, traceback***REMOVED***:
        super(DatabaseSchemaEditor, self***REMOVED***.__exit__(exc_type, exc_value, traceback***REMOVED***
        with self.connection.cursor(***REMOVED*** as c:
            # Restore initial FK setting - PRAGMA values can't be parametrized
            c.execute('PRAGMA foreign_keys = %s' % int(self._initial_pragma_fk***REMOVED******REMOVED***

    def quote_value(self, value***REMOVED***:
        # The backend "mostly works" without this function and there are use
        # cases for compiling Python without the sqlite3 libraries (e.g.
        # security hardening***REMOVED***.
        ***REMOVED***
            import sqlite3
            value = sqlite3.adapt(value***REMOVED***
        except ImportError:
            pass
        except sqlite3.ProgrammingError:
            pass
        # Manual emulation of SQLite parameter quoting
        if isinstance(value, type(True***REMOVED******REMOVED***:
            return str(int(value***REMOVED******REMOVED***
        elif isinstance(value, (Decimal, float***REMOVED******REMOVED***:
            return str(value***REMOVED***
        elif isinstance(value, six.integer_types***REMOVED***:
            return str(value***REMOVED***
        elif isinstance(value, six.string_types***REMOVED***:
            return "'%s'" % six.text_type(value***REMOVED***.replace("\'", "\'\'"***REMOVED***
        elif value is None:
            return "NULL"
        elif isinstance(value, (bytes, bytearray, six.memoryview***REMOVED******REMOVED***:
            # Bytes are only allowed for BLOB fields, encoded as string
            # literals containing hexadecimal data and preceded by a single "X"
            # character:
            # value = b'\x01\x02' => value_hex = b'0102' => return X'0102'
            value = bytes(value***REMOVED***
            hex_encoder = codecs.getencoder('hex_codec'***REMOVED***
            value_hex, _length = hex_encoder(value***REMOVED***
            # Use 'ascii' encoding for b'01' => '01', no need to use force_text here.
            return "X'%s'" % value_hex.decode('ascii'***REMOVED***
        else:
            raise ValueError("Cannot quote parameter value %r of type %s" % (value, type(value***REMOVED******REMOVED******REMOVED***

    def _remake_table(self, model, create_fields=[***REMOVED***, delete_fields=[***REMOVED***, alter_fields=[***REMOVED***, override_uniques=None,
                      override_indexes=None***REMOVED***:
        ***REMOVED***
        Shortcut to transform a model from old_model into new_model

        The essential steps are:
          1. rename the model's existing table, e.g. "app_model" to "app_model__old"
          2. create a table with the updated definition called "app_model"
          3. copy the data from the old renamed table to the new table
          4. delete the "app_model__old" table
        ***REMOVED***
        # Self-referential fields must be recreated rather than copied from
        # the old model to ensure their remote_field.field_name doesn't refer
        # to an altered field.
        def is_self_referential(f***REMOVED***:
            return f.is_relation and f.remote_field.model is model
        # Work out the new fields dict / mapping
        body = {
            f.name: f.clone(***REMOVED*** if is_self_referential(f***REMOVED*** else f
            for f in model._meta.local_concrete_fields
    ***REMOVED***
        # Since mapping might mix column names and default values,
        # its values must be already quoted.
        mapping = {f.column: self.quote_name(f.column***REMOVED*** for f in model._meta.local_concrete_fields***REMOVED***
        # This maps field names (not columns***REMOVED*** for things like unique_together
        rename_mapping = {***REMOVED***
        # If any of the new or altered fields is introducing a new PK,
        # remove the old one
        restore_pk_field = None
        if any(f.primary_key for f in create_fields***REMOVED*** or any(n.primary_key for o, n in alter_fields***REMOVED***:
            for name, field in list(body.items(***REMOVED******REMOVED***:
                if field.primary_key:
                    field.primary_key = False
                    restore_pk_field = field
                    if field.auto_created:
                        del body[name***REMOVED***
                        del mapping[field.column***REMOVED***
        # Add in any created fields
        for field in create_fields:
            body[field.name***REMOVED*** = field
            # Choose a default and insert it into the copy map
            if not field.many_to_many and field.concrete:
                mapping[field.column***REMOVED*** = self.quote_value(
                    self.effective_default(field***REMOVED***
                ***REMOVED***
        # Add in any altered fields
        for (old_field, new_field***REMOVED*** in alter_fields:
            body.pop(old_field.name, None***REMOVED***
            mapping.pop(old_field.column, None***REMOVED***
            body[new_field.name***REMOVED*** = new_field
            if old_field.null and not new_field.null:
                case_sql = "coalesce(%(col***REMOVED***s, %(default***REMOVED***s***REMOVED***" % {
                    'col': self.quote_name(old_field.column***REMOVED***,
                    'default': self.quote_value(self.effective_default(new_field***REMOVED******REMOVED***
            ***REMOVED***
                mapping[new_field.column***REMOVED*** = case_sql
            else:
                mapping[new_field.column***REMOVED*** = self.quote_name(old_field.column***REMOVED***
            rename_mapping[old_field.name***REMOVED*** = new_field.name
        # Remove any deleted fields
        for field in delete_fields:
            del body[field.name***REMOVED***
            del mapping[field.column***REMOVED***
            # Remove any implicit M2M tables
            if field.many_to_many and field.remote_field.through._meta.auto_created:
                return self.delete_model(field.remote_field.through***REMOVED***
        # Work inside a new app registry
        apps = Apps(***REMOVED***

        # Provide isolated instances of the fields to the new model body so
        # that the existing model's internals aren't interfered with when
        # the dummy model is constructed.
        body = copy.deepcopy(body***REMOVED***

        # Work out the new value of unique_together, taking renames into
        # account
        if override_uniques is None:
            override_uniques = [
                [rename_mapping.get(n, n***REMOVED*** for n in unique***REMOVED***
                for unique in model._meta.unique_together
            ***REMOVED***

        # Work out the new value for index_together, taking renames into
        # account
        if override_indexes is None:
            override_indexes = [
                [rename_mapping.get(n, n***REMOVED*** for n in index***REMOVED***
                for index in model._meta.index_together
            ***REMOVED***

        # Construct a new model for the new state
        meta_contents = {
            'app_label': model._meta.app_label,
            'db_table': model._meta.db_table,
            'unique_together': override_uniques,
            'index_together': override_indexes,
            'apps': apps,
    ***REMOVED***
        meta = type("Meta", tuple(***REMOVED***, meta_contents***REMOVED***
        body['Meta'***REMOVED*** = meta
        body['__module__'***REMOVED*** = model.__module__

        temp_model = type(model._meta.object_name, model.__bases__, body***REMOVED***

        # We need to modify model._meta.db_table, but everything explodes
        # if the change isn't reversed before the end of this method. This
        # context manager helps us avoid that situation.
        @contextlib.contextmanager
        def altered_table_name(model, temporary_table_name***REMOVED***:
            original_table_name = model._meta.db_table
            model._meta.db_table = temporary_table_name
            yield
            model._meta.db_table = original_table_name

        with altered_table_name(model, model._meta.db_table + "__old"***REMOVED***:
            # Rename the old table to make way for the new
            self.alter_db_table(model, temp_model._meta.db_table, model._meta.db_table***REMOVED***

            # Create a new table with the updated schema. We remove things
            # from the deferred SQL that match our table name, too
            self.deferred_sql = [x for x in self.deferred_sql if temp_model._meta.db_table not in x***REMOVED***
            self.create_model(temp_model***REMOVED***

            # Copy data from the old table into the new table
            field_maps = list(mapping.items(***REMOVED******REMOVED***
            self.execute("INSERT INTO %s (%s***REMOVED*** SELECT %s FROM %s" % (
                self.quote_name(temp_model._meta.db_table***REMOVED***,
                ', '.join(self.quote_name(x***REMOVED*** for x, y in field_maps***REMOVED***,
                ', '.join(y for x, y in field_maps***REMOVED***,
                self.quote_name(model._meta.db_table***REMOVED***,
            ***REMOVED******REMOVED***

            # Delete the old table
            self.delete_model(model, handle_autom2m=False***REMOVED***

        # Run deferred SQL on correct table
        for sql in self.deferred_sql:
            self.execute(sql***REMOVED***
        self.deferred_sql = [***REMOVED***
        # Fix any PK-removed field
        if restore_pk_field:
            restore_pk_field.primary_key = True

    def delete_model(self, model, handle_autom2m=True***REMOVED***:
        if handle_autom2m:
            super(DatabaseSchemaEditor, self***REMOVED***.delete_model(model***REMOVED***
        else:
            # Delete the table (and only that***REMOVED***
            self.execute(self.sql_delete_table % {
                "table": self.quote_name(model._meta.db_table***REMOVED***,
        ***REMOVED******REMOVED***

    def add_field(self, model, field***REMOVED***:
        ***REMOVED***
        Creates a field on a model.
        Usually involves adding a column, but may involve adding a
        table instead (for M2M fields***REMOVED***
        ***REMOVED***
        # Special-case implicit M2M tables
        if field.many_to_many and field.remote_field.through._meta.auto_created:
            return self.create_model(field.remote_field.through***REMOVED***
        self._remake_table(model, create_fields=[field***REMOVED******REMOVED***

    def remove_field(self, model, field***REMOVED***:
        ***REMOVED***
        Removes a field from a model. Usually involves deleting a column,
        but for M2Ms may involve deleting a table.
        ***REMOVED***
        # M2M fields are a special case
        if field.many_to_many:
            # For implicit M2M tables, delete the auto-created table
            if field.remote_field.through._meta.auto_created:
                self.delete_model(field.remote_field.through***REMOVED***
            # For explicit "through" M2M fields, do nothing
        # For everything else, remake.
        else:
            # It might not actually have a column behind it
            if field.db_parameters(connection=self.connection***REMOVED***['type'***REMOVED*** is None:
                return
            self._remake_table(model, delete_fields=[field***REMOVED******REMOVED***

    def _alter_field(self, model, old_field, new_field, old_type, new_type,
                     old_db_params, new_db_params, strict=False***REMOVED***:
        ***REMOVED***Actually perform a "physical" (non-ManyToMany***REMOVED*** field update.***REMOVED***
        # Alter by remaking table
        self._remake_table(model, alter_fields=[(old_field, new_field***REMOVED******REMOVED******REMOVED***

    def alter_index_together(self, model, old_index_together, new_index_together***REMOVED***:
        ***REMOVED***
        Deals with a model changing its index_together.
        Note: The input index_togethers must be doubly-nested, not the single-
        nested ["foo", "bar"***REMOVED*** format.
        ***REMOVED***
        self._remake_table(model, override_indexes=new_index_together***REMOVED***

    def alter_unique_together(self, model, old_unique_together, new_unique_together***REMOVED***:
        ***REMOVED***
        Deals with a model changing its unique_together.
        Note: The input unique_togethers must be doubly-nested, not the single-
        nested ["foo", "bar"***REMOVED*** format.
        ***REMOVED***
        self._remake_table(model, override_uniques=new_unique_together***REMOVED***

    def _alter_many_to_many(self, model, old_field, new_field, strict***REMOVED***:
        ***REMOVED***
        Alters M2Ms to repoint their to= endpoints.
        ***REMOVED***
        if old_field.remote_field.through._meta.db_table == new_field.remote_field.through._meta.db_table:
            # The field name didn't change, but some options did; we have to propagate this altering.
            self._remake_table(
                old_field.remote_field.through,
                alter_fields=[(
                    # We need the field that points to the target model, so we can tell alter_field to change it -
                    # this is m2m_reverse_field_name(***REMOVED*** (as opposed to m2m_field_name, which points to our model***REMOVED***
                    old_field.remote_field.through._meta.get_field(old_field.m2m_reverse_field_name(***REMOVED******REMOVED***,
                    new_field.remote_field.through._meta.get_field(new_field.m2m_reverse_field_name(***REMOVED******REMOVED***,
                ***REMOVED******REMOVED***,
                override_uniques=(new_field.m2m_field_name(***REMOVED***, new_field.m2m_reverse_field_name(***REMOVED******REMOVED***,
            ***REMOVED***
            return

        # Make a new through table
        self.create_model(new_field.remote_field.through***REMOVED***
        # Copy the data across
        self.execute("INSERT INTO %s (%s***REMOVED*** SELECT %s FROM %s" % (
            self.quote_name(new_field.remote_field.through._meta.db_table***REMOVED***,
            ', '.join([
                "id",
                new_field.m2m_column_name(***REMOVED***,
                new_field.m2m_reverse_name(***REMOVED***,
            ***REMOVED******REMOVED***,
            ', '.join([
                "id",
                old_field.m2m_column_name(***REMOVED***,
                old_field.m2m_reverse_name(***REMOVED***,
            ***REMOVED******REMOVED***,
            self.quote_name(old_field.remote_field.through._meta.db_table***REMOVED***,
        ***REMOVED******REMOVED***
        # Delete the old through table
        self.delete_model(old_field.remote_field.through***REMOVED***
