***REMOVED***
import shutil
import sys

from django.core.exceptions import ImproperlyConfigured
from django.db.backends.base.creation import BaseDatabaseCreation
from django.utils.six.moves import input


class DatabaseCreation(BaseDatabaseCreation***REMOVED***:

    def _get_test_db_name(self***REMOVED***:
        test_database_name = self.connection.settings_dict['TEST'***REMOVED***['NAME'***REMOVED***
        can_share_in_memory_db = self.connection.features.can_share_in_memory_db
        if test_database_name and test_database_name != ':memory:':
            if 'mode=memory' in test_database_name and not can_share_in_memory_db:
                raise ImproperlyConfigured(
                    "Using a shared memory database with `mode=memory` in the "
                    "database name is not supported in your environment, "
                    "use `:memory:` instead."
                ***REMOVED***
            return test_database_name
        if can_share_in_memory_db:
            return 'file:memorydb_%s?mode=memory&cache=shared' % self.connection.alias
        return ':memory:'

    def _create_test_db(self, verbosity, autoclobber, keepdb=False***REMOVED***:
        test_database_name = self._get_test_db_name(***REMOVED***

        if keepdb:
            return test_database_name
        if not self.connection.is_in_memory_db(test_database_name***REMOVED***:
            # Erase the old test database
            if verbosity >= 1:
                print("Destroying old test database for alias %s..." % (
                    self._get_database_display_str(verbosity, test_database_name***REMOVED***,
                ***REMOVED******REMOVED***
            if os.access(test_database_name, os.F_OK***REMOVED***:
                if not autoclobber:
                    confirm = input(
                        "Type 'yes' if you would like to try deleting the test "
                        "database '%s', or 'no' to cancel: " % test_database_name
                    ***REMOVED***
                if autoclobber or confirm == 'yes':
                    ***REMOVED***
                        os.remove(test_database_name***REMOVED***
                    except Exception as e:
                        sys.stderr.write("Got an error deleting the old test database: %s\n" % e***REMOVED***
                        sys.exit(2***REMOVED***
                else:
                    print("Tests cancelled."***REMOVED***
                    sys.exit(1***REMOVED***
        return test_database_name

    def get_test_db_clone_settings(self, number***REMOVED***:
        orig_settings_dict = self.connection.settings_dict
        source_database_name = orig_settings_dict['NAME'***REMOVED***
        if self.connection.is_in_memory_db(source_database_name***REMOVED***:
            return orig_settings_dict
        else:
            new_settings_dict = orig_settings_dict.copy(***REMOVED***
            root, ext = os.path.splitext(orig_settings_dict['NAME'***REMOVED******REMOVED***
            new_settings_dict['NAME'***REMOVED*** = '{***REMOVED***_{***REMOVED***.{***REMOVED***'.format(root, number, ext***REMOVED***
            return new_settings_dict

    def _clone_test_db(self, number, verbosity, keepdb=False***REMOVED***:
        source_database_name = self.connection.settings_dict['NAME'***REMOVED***
        target_database_name = self.get_test_db_clone_settings(number***REMOVED***['NAME'***REMOVED***
        # Forking automatically makes a copy of an in-memory database.
        if not self.connection.is_in_memory_db(source_database_name***REMOVED***:
            # Erase the old test database
            if os.access(target_database_name, os.F_OK***REMOVED***:
                if keepdb:
                    return
                if verbosity >= 1:
                    print("Destroying old test database for alias %s..." % (
                        self._get_database_display_str(verbosity, target_database_name***REMOVED***,
                    ***REMOVED******REMOVED***
                ***REMOVED***
                    os.remove(target_database_name***REMOVED***
                except Exception as e:
                    sys.stderr.write("Got an error deleting the old test database: %s\n" % e***REMOVED***
                    sys.exit(2***REMOVED***
            ***REMOVED***
                shutil.copy(source_database_name, target_database_name***REMOVED***
            except Exception as e:
                sys.stderr.write("Got an error cloning the test database: %s\n" % e***REMOVED***
                sys.exit(2***REMOVED***

    def _destroy_test_db(self, test_database_name, verbosity***REMOVED***:
        if test_database_name and not self.connection.is_in_memory_db(test_database_name***REMOVED***:
            # Remove the SQLite database file
            os.remove(test_database_name***REMOVED***

    def test_db_signature(self***REMOVED***:
        ***REMOVED***
        Returns a tuple that uniquely identifies a test database.

        This takes into account the special cases of ":memory:" and "" for
        SQLite since the databases will be distinct despite having the same
        TEST NAME. See http://www.sqlite.org/inmemorydb.html
        ***REMOVED***
        test_database_name = self._get_test_db_name(***REMOVED***
        sig = [self.connection.settings_dict['NAME'***REMOVED******REMOVED***
        if self.connection.is_in_memory_db(test_database_name***REMOVED***:
            sig.append(self.connection.alias***REMOVED***
        return tuple(sig***REMOVED***
