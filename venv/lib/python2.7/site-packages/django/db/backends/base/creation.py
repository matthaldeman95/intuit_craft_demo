import sys
import time

from django.apps import apps
from django.conf import settings
from django.core import serializers
from django.db import router
from django.utils.six import StringIO
from django.utils.six.moves import input

# The prefix to put on the default database name when creating
# the test database.
TEST_DATABASE_PREFIX = 'test_'


class BaseDatabaseCreation(object***REMOVED***:
    ***REMOVED***
    This class encapsulates all backend-specific differences that pertain to
    creation and destruction of the test database.
    ***REMOVED***
    def __init__(self, connection***REMOVED***:
        self.connection = connection

    @property
    def _nodb_connection(self***REMOVED***:
        ***REMOVED***
        Used to be defined here, now moved to DatabaseWrapper.
        ***REMOVED***
        return self.connection._nodb_connection

    def create_test_db(self, verbosity=1, autoclobber=False, serialize=True, keepdb=False***REMOVED***:
        ***REMOVED***
        Creates a test database, prompting the user for confirmation if the
        database already exists. Returns the name of the test database created.
        ***REMOVED***
        # Don't import django.core.management if it isn't needed.
        from django.core.management import call_command

        test_database_name = self._get_test_db_name(***REMOVED***

        if verbosity >= 1:
            action = 'Creating'
            if keepdb:
                action = "Using existing"

            print("%s test database for alias %s..." % (
                action,
                self._get_database_display_str(verbosity, test_database_name***REMOVED***,
            ***REMOVED******REMOVED***

        # We could skip this call if keepdb is True, but we instead
        # give it the keepdb param. This is to handle the case
        # where the test DB doesn't exist, in which case we need to
        # create it, then just not destroy it. If we instead skip
        # this, we will get an exception.
        self._create_test_db(verbosity, autoclobber, keepdb***REMOVED***

        self.connection.close(***REMOVED***
        settings.DATABASES[self.connection.alias***REMOVED***["NAME"***REMOVED*** = test_database_name
        self.connection.settings_dict["NAME"***REMOVED*** = test_database_name

        # We report migrate messages at one level lower than that requested.
        # This ensures we don't get flooded with messages during testing
        # (unless you really ask to be flooded***REMOVED***.
        call_command(
            'migrate',
            verbosity=max(verbosity - 1, 0***REMOVED***,
            interactive=False,
            database=self.connection.alias,
            run_syncdb=True,
        ***REMOVED***

        # We then serialize the current state of the database into a string
        # and store it on the connection. This slightly horrific process is so people
        # who are testing on databases without transactions or who are using
        # a TransactionTestCase still get a clean database on every test run.
        if serialize:
            self.connection._test_serialized_contents = self.serialize_db_to_string(***REMOVED***

        call_command('createcachetable', database=self.connection.alias***REMOVED***

        # Ensure a connection for the side effect of initializing the test database.
        self.connection.ensure_connection(***REMOVED***

        return test_database_name

    def set_as_test_mirror(self, primary_settings_dict***REMOVED***:
        ***REMOVED***
        Set this database up to be used in testing as a mirror of a primary database
        whose settings are given
        ***REMOVED***
        self.connection.settings_dict['NAME'***REMOVED*** = primary_settings_dict['NAME'***REMOVED***

    def serialize_db_to_string(self***REMOVED***:
        ***REMOVED***
        Serializes all data in the database into a JSON string.
        Designed only for test runner usage; will not handle large
        amounts of data.
        ***REMOVED***
        # Build list of all apps to serialize
        from django.db.migrations.loader import MigrationLoader
        loader = MigrationLoader(self.connection***REMOVED***
        app_list = [***REMOVED***
        for app_config in apps.get_app_configs(***REMOVED***:
            if (
                app_config.models_module is not None and
                app_config.label in loader.migrated_apps and
                app_config.name not in settings.TEST_NON_SERIALIZED_APPS
            ***REMOVED***:
                app_list.append((app_config, None***REMOVED******REMOVED***

        # Make a function to iteratively return every object
        def get_objects(***REMOVED***:
            for model in serializers.sort_dependencies(app_list***REMOVED***:
                if (model._meta.can_migrate(self.connection***REMOVED*** and
                        router.allow_migrate_model(self.connection.alias, model***REMOVED******REMOVED***:
                    queryset = model._default_manager.using(self.connection.alias***REMOVED***.order_by(model._meta.pk.name***REMOVED***
                    for obj in queryset.iterator(***REMOVED***:
                        yield obj
        # Serialize to a string
        out = StringIO(***REMOVED***
        serializers.serialize("json", get_objects(***REMOVED***, indent=None, stream=out***REMOVED***
        return out.getvalue(***REMOVED***

    def deserialize_db_from_string(self, data***REMOVED***:
        ***REMOVED***
        Reloads the database with data from a string generated by
        the serialize_db_to_string method.
        ***REMOVED***
        data = StringIO(data***REMOVED***
        for obj in serializers.deserialize("json", data, using=self.connection.alias***REMOVED***:
            obj.save(***REMOVED***

    def _get_database_display_str(self, verbosity, database_name***REMOVED***:
        ***REMOVED***
        Return display string for a database for use in various actions.
        ***REMOVED***
        return "'%s'%s" % (
            self.connection.alias,
            (" ('%s'***REMOVED***" % database_name***REMOVED*** if verbosity >= 2 else '',
        ***REMOVED***

    def _get_test_db_name(self***REMOVED***:
        ***REMOVED***
        Internal implementation - returns the name of the test DB that will be
        created. Only useful when called from create_test_db(***REMOVED*** and
        _create_test_db(***REMOVED*** and when no external munging is done with the 'NAME'
        settings.
        ***REMOVED***
        if self.connection.settings_dict['TEST'***REMOVED***['NAME'***REMOVED***:
            return self.connection.settings_dict['TEST'***REMOVED***['NAME'***REMOVED***
        return TEST_DATABASE_PREFIX + self.connection.settings_dict['NAME'***REMOVED***

    def _create_test_db(self, verbosity, autoclobber, keepdb=False***REMOVED***:
        ***REMOVED***
        Internal implementation - creates the test db tables.
        ***REMOVED***
        suffix = self.sql_table_creation_suffix(***REMOVED***

        test_database_name = self._get_test_db_name(***REMOVED***

        qn = self.connection.ops.quote_name

        # Create the test database and connect to it.
        with self._nodb_connection.cursor(***REMOVED*** as cursor:
            ***REMOVED***
                cursor.execute(
                    "CREATE DATABASE %s %s" % (qn(test_database_name***REMOVED***, suffix***REMOVED******REMOVED***
            except Exception as e:
                # if we want to keep the db, then no need to do any of the below,
                # just return and skip it all.
                if keepdb:
                    return test_database_name

                sys.stderr.write(
                    "Got an error creating the test database: %s\n" % e***REMOVED***
                if not autoclobber:
                    confirm = input(
                        "Type 'yes' if you would like to try deleting the test "
                        "database '%s', or 'no' to cancel: " % test_database_name***REMOVED***
                if autoclobber or confirm == 'yes':
                    ***REMOVED***
                        if verbosity >= 1:
                            print("Destroying old test database for alias %s..." % (
                                self._get_database_display_str(verbosity, test_database_name***REMOVED***,
                            ***REMOVED******REMOVED***
                        cursor.execute(
                            "DROP DATABASE %s" % qn(test_database_name***REMOVED******REMOVED***
                        cursor.execute(
                            "CREATE DATABASE %s %s" % (qn(test_database_name***REMOVED***,
                                                       suffix***REMOVED******REMOVED***
                    except Exception as e:
                        sys.stderr.write(
                            "Got an error recreating the test database: %s\n" % e***REMOVED***
                        sys.exit(2***REMOVED***
                else:
                    print("Tests cancelled."***REMOVED***
                    sys.exit(1***REMOVED***

        return test_database_name

    def clone_test_db(self, number, verbosity=1, autoclobber=False, keepdb=False***REMOVED***:
        ***REMOVED***
        Clone a test database.
        ***REMOVED***
        source_database_name = self.connection.settings_dict['NAME'***REMOVED***

        if verbosity >= 1:
            action = 'Cloning test database'
            if keepdb:
                action = 'Using existing clone'
            print("%s for alias %s..." % (
                action,
                self._get_database_display_str(verbosity, source_database_name***REMOVED***,
            ***REMOVED******REMOVED***

        # We could skip this call if keepdb is True, but we instead
        # give it the keepdb param. See create_test_db for details.
        self._clone_test_db(number, verbosity, keepdb***REMOVED***

    def get_test_db_clone_settings(self, number***REMOVED***:
        ***REMOVED***
        Return a modified connection settings dict for the n-th clone of a DB.
        ***REMOVED***
        # When this function is called, the test database has been created
        # already and its name has been copied to settings_dict['NAME'***REMOVED*** so
        # we don't need to call _get_test_db_name.
        orig_settings_dict = self.connection.settings_dict
        new_settings_dict = orig_settings_dict.copy(***REMOVED***
        new_settings_dict['NAME'***REMOVED*** = '{***REMOVED***_{***REMOVED***'.format(orig_settings_dict['NAME'***REMOVED***, number***REMOVED***
        return new_settings_dict

    def _clone_test_db(self, number, verbosity, keepdb=False***REMOVED***:
        ***REMOVED***
        Internal implementation - duplicate the test db tables.
        ***REMOVED***
        raise NotImplementedError(
            "The database backend doesn't support cloning databases. "
            "Disable the option to run tests in parallel processes."***REMOVED***

    def destroy_test_db(self, old_database_name=None, verbosity=1, keepdb=False, number=None***REMOVED***:
        ***REMOVED***
        Destroy a test database, prompting the user for confirmation if the
        database already exists.
        ***REMOVED***
        self.connection.close(***REMOVED***
        if number is None:
            test_database_name = self.connection.settings_dict['NAME'***REMOVED***
        else:
            test_database_name = self.get_test_db_clone_settings(number***REMOVED***['NAME'***REMOVED***

        if verbosity >= 1:
            action = 'Destroying'
            if keepdb:
                action = 'Preserving'
            print("%s test database for alias %s..." % (
                action,
                self._get_database_display_str(verbosity, test_database_name***REMOVED***,
            ***REMOVED******REMOVED***

        # if we want to preserve the database
        # skip the actual destroying piece.
        if not keepdb:
            self._destroy_test_db(test_database_name, verbosity***REMOVED***

        # Restore the original database name
        if old_database_name is not None:
            settings.DATABASES[self.connection.alias***REMOVED***["NAME"***REMOVED*** = old_database_name
            self.connection.settings_dict["NAME"***REMOVED*** = old_database_name

    def _destroy_test_db(self, test_database_name, verbosity***REMOVED***:
        ***REMOVED***
        Internal implementation - remove the test db tables.
        ***REMOVED***
        # Remove the test database to clean up after
        # ourselves. Connect to the previous database (not the test database***REMOVED***
        # to do so, because it's not allowed to delete a database while being
        # connected to it.
        with self.connection._nodb_connection.cursor(***REMOVED*** as cursor:
            # Wait to avoid "database is being accessed by other users" errors.
            time.sleep(1***REMOVED***
            cursor.execute("DROP DATABASE %s"
                           % self.connection.ops.quote_name(test_database_name***REMOVED******REMOVED***

    def sql_table_creation_suffix(self***REMOVED***:
        ***REMOVED***
        SQL to append to the end of the test table creation statements.
        ***REMOVED***
        return ''

    def test_db_signature(self***REMOVED***:
        ***REMOVED***
        Returns a tuple with elements of self.connection.settings_dict (a
        DATABASES setting value***REMOVED*** that uniquely identify a database
        accordingly to the RDBMS particularities.
        ***REMOVED***
        settings_dict = self.connection.settings_dict
        return (
            settings_dict['HOST'***REMOVED***,
            settings_dict['PORT'***REMOVED***,
            settings_dict['ENGINE'***REMOVED***,
            self._get_test_db_name(***REMOVED***,
        ***REMOVED***
