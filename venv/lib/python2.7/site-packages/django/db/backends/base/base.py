import copy
import time
import warnings
from collections import deque
from contextlib import contextmanager

from django.conf import settings
from django.core.exceptions import ImproperlyConfigured
from django.db import DEFAULT_DB_ALIAS
from django.db.backends import utils
from django.db.backends.signals import connection_created
from django.db.transaction import TransactionManagementError
from django.db.utils import DatabaseError, DatabaseErrorWrapper
from django.utils import timezone
from django.utils.functional import cached_property
from django.utils.six.moves import _thread as thread

***REMOVED***
    import pytz
except ImportError:
    pytz = None

NO_DB_ALIAS = '__no_db__'


class BaseDatabaseWrapper(object***REMOVED***:
    ***REMOVED***
    Represents a database connection.
    ***REMOVED***
    # Mapping of Field objects to their column types.
    data_types = {***REMOVED***
    # Mapping of Field objects to their SQL suffix such as AUTOINCREMENT.
    data_types_suffix = {***REMOVED***
    # Mapping of Field objects to their SQL for CHECK constraints.
    data_type_check_constraints = {***REMOVED***
    ops = None
    vendor = 'unknown'
    SchemaEditorClass = None

    queries_limit = 9000

    def __init__(self, settings_dict, alias=DEFAULT_DB_ALIAS,
                 allow_thread_sharing=False***REMOVED***:
        # Connection related attributes.
        # The underlying database connection.
        self.connection = None
        # `settings_dict` should be a dictionary containing keys such as
        # NAME, USER, etc. It's called `settings_dict` instead of `settings`
        # to disambiguate it from Django settings modules.
        self.settings_dict = settings_dict
        self.alias = alias
        # Query logging in debug mode or when explicitly enabled.
        self.queries_log = deque(maxlen=self.queries_limit***REMOVED***
        self.force_debug_cursor = False

        # Transaction related attributes.
        # Tracks if the connection is in autocommit mode. Per PEP 249, by
        # default, it isn't.
        self.autocommit = False
        # Tracks if the connection is in a transaction managed by 'atomic'.
        self.in_atomic_block = False
        # Increment to generate unique savepoint ids.
        self.savepoint_state = 0
        # List of savepoints created by 'atomic'.
        self.savepoint_ids = [***REMOVED***
        # Tracks if the outermost 'atomic' block should commit on exit,
        # ie. if autocommit was active on entry.
        self.commit_on_exit = True
        # Tracks if the transaction should be rolled back to the next
        # available savepoint because of an exception in an inner block.
        self.needs_rollback = False

        # Connection termination related attributes.
        self.close_at = None
        self.closed_in_transaction = False
        self.errors_occurred = False

        # Thread-safety related attributes.
        self.allow_thread_sharing = allow_thread_sharing
        self._thread_ident = thread.get_ident(***REMOVED***

        # A list of no-argument functions to run when the transaction commits.
        # Each entry is an (sids, func***REMOVED*** tuple, where sids is a set of the
        # active savepoint IDs when this function was registered.
        self.run_on_commit = [***REMOVED***

        # Should we run the on-commit hooks the next time set_autocommit(True***REMOVED***
        # is called?
        self.run_commit_hooks_on_set_autocommit_on = False

    @cached_property
    def timezone(self***REMOVED***:
        ***REMOVED***
        Time zone for datetimes stored as naive values in the database.

        Returns a tzinfo object or None.

        This is only needed when time zone support is enabled and the database
        doesn't support time zones. (When the database supports time zones,
        the adapter handles aware datetimes so Django doesn't need to.***REMOVED***
        ***REMOVED***
        if not settings.USE_TZ:
            return None
        elif self.features.supports_timezones:
            return None
        elif self.settings_dict['TIME_ZONE'***REMOVED*** is None:
            return timezone.utc
        else:
            # Only this branch requires pytz.
            return pytz.timezone(self.settings_dict['TIME_ZONE'***REMOVED******REMOVED***

    @cached_property
    def timezone_name(self***REMOVED***:
        ***REMOVED***
        Name of the time zone of the database connection.
        ***REMOVED***
        if not settings.USE_TZ:
            return settings.TIME_ZONE
        elif self.settings_dict['TIME_ZONE'***REMOVED*** is None:
            return 'UTC'
        else:
            return self.settings_dict['TIME_ZONE'***REMOVED***

    @property
    def queries_logged(self***REMOVED***:
        return self.force_debug_cursor or settings.DEBUG

    @property
    def queries(self***REMOVED***:
        if len(self.queries_log***REMOVED*** == self.queries_log.maxlen:
            warnings.warn(
                "Limit for query logging exceeded, only the last {***REMOVED*** queries "
                "will be returned.".format(self.queries_log.maxlen***REMOVED******REMOVED***
        return list(self.queries_log***REMOVED***

    # ##### Backend-specific methods for creating connections and cursors #####

    def get_connection_params(self***REMOVED***:
        ***REMOVED***Returns a dict of parameters suitable for get_new_connection.***REMOVED***
        raise NotImplementedError('subclasses of BaseDatabaseWrapper may require a get_connection_params(***REMOVED*** method'***REMOVED***

    def get_new_connection(self, conn_params***REMOVED***:
        ***REMOVED***Opens a connection to the database.***REMOVED***
        raise NotImplementedError('subclasses of BaseDatabaseWrapper may require a get_new_connection(***REMOVED*** method'***REMOVED***

    def init_connection_state(self***REMOVED***:
        ***REMOVED***Initializes the database connection settings.***REMOVED***
        raise NotImplementedError('subclasses of BaseDatabaseWrapper may require an init_connection_state(***REMOVED*** method'***REMOVED***

    def create_cursor(self***REMOVED***:
        ***REMOVED***Creates a cursor. Assumes that a connection is established.***REMOVED***
        raise NotImplementedError('subclasses of BaseDatabaseWrapper may require a create_cursor(***REMOVED*** method'***REMOVED***

    # ##### Backend-specific methods for creating connections #####

    def connect(self***REMOVED***:
        ***REMOVED***Connects to the database. Assumes that the connection is closed.***REMOVED***
        # Check for invalid configurations.
        self.check_settings(***REMOVED***
        # In case the previous connection was closed while in an atomic block
        self.in_atomic_block = False
        self.savepoint_ids = [***REMOVED***
        self.needs_rollback = False
        # Reset parameters defining when to close the connection
        max_age = self.settings_dict['CONN_MAX_AGE'***REMOVED***
        self.close_at = None if max_age is None else time.time(***REMOVED*** + max_age
        self.closed_in_transaction = False
        self.errors_occurred = False
        # Establish the connection
        conn_params = self.get_connection_params(***REMOVED***
        self.connection = self.get_new_connection(conn_params***REMOVED***
        self.set_autocommit(self.settings_dict['AUTOCOMMIT'***REMOVED******REMOVED***
        self.init_connection_state(***REMOVED***
        connection_created.send(sender=self.__class__, connection=self***REMOVED***

        self.run_on_commit = [***REMOVED***

    def check_settings(self***REMOVED***:
        if self.settings_dict['TIME_ZONE'***REMOVED*** is not None:
            if not settings.USE_TZ:
                raise ImproperlyConfigured(
                    "Connection '%s' cannot set TIME_ZONE because USE_TZ is "
                    "False." % self.alias***REMOVED***
            elif self.features.supports_timezones:
                raise ImproperlyConfigured(
                    "Connection '%s' cannot set TIME_ZONE because its engine "
                    "handles time zones conversions natively." % self.alias***REMOVED***
            elif pytz is None:
                raise ImproperlyConfigured(
                    "Connection '%s' cannot set TIME_ZONE because pytz isn't "
                    "installed." % self.alias***REMOVED***

    def ensure_connection(self***REMOVED***:
        ***REMOVED***
        Guarantees that a connection to the database is established.
        ***REMOVED***
        if self.connection is None:
            with self.wrap_database_errors:
                self.connect(***REMOVED***

    # ##### Backend-specific wrappers for PEP-249 connection methods #####

    def _cursor(self***REMOVED***:
        self.ensure_connection(***REMOVED***
        with self.wrap_database_errors:
            return self.create_cursor(***REMOVED***

    def _commit(self***REMOVED***:
        if self.connection is not None:
            with self.wrap_database_errors:
                return self.connection.commit(***REMOVED***

    def _rollback(self***REMOVED***:
        if self.connection is not None:
            with self.wrap_database_errors:
                return self.connection.rollback(***REMOVED***

    def _close(self***REMOVED***:
        if self.connection is not None:
            with self.wrap_database_errors:
                return self.connection.close(***REMOVED***

    # ##### Generic wrappers for PEP-249 connection methods #####

    def cursor(self***REMOVED***:
        ***REMOVED***
        Creates a cursor, opening a connection if necessary.
        ***REMOVED***
        self.validate_thread_sharing(***REMOVED***
        if self.queries_logged:
            cursor = self.make_debug_cursor(self._cursor(***REMOVED******REMOVED***
        else:
            cursor = self.make_cursor(self._cursor(***REMOVED******REMOVED***
        return cursor

    def commit(self***REMOVED***:
        ***REMOVED***
        Commits a transaction and resets the dirty flag.
        ***REMOVED***
        self.validate_thread_sharing(***REMOVED***
        self.validate_no_atomic_block(***REMOVED***
        self._commit(***REMOVED***
        # A successful commit means that the database connection works.
        self.errors_occurred = False
        self.run_commit_hooks_on_set_autocommit_on = True

    def rollback(self***REMOVED***:
        ***REMOVED***
        Rolls back a transaction and resets the dirty flag.
        ***REMOVED***
        self.validate_thread_sharing(***REMOVED***
        self.validate_no_atomic_block(***REMOVED***
        self._rollback(***REMOVED***
        # A successful rollback means that the database connection works.
        self.errors_occurred = False

        self.run_on_commit = [***REMOVED***

    def close(self***REMOVED***:
        ***REMOVED***
        Closes the connection to the database.
        ***REMOVED***
        self.validate_thread_sharing(***REMOVED***
        self.run_on_commit = [***REMOVED***

        # Don't call validate_no_atomic_block(***REMOVED*** to avoid making it difficult
        # to get rid of a connection in an invalid state. The next connect(***REMOVED***
        # will reset the transaction state anyway.
        if self.closed_in_transaction or self.connection is None:
            return
        ***REMOVED***
            self._close(***REMOVED***
        finally:
            if self.in_atomic_block:
                self.closed_in_transaction = True
                self.needs_rollback = True
            else:
                self.connection = None

    # ##### Backend-specific savepoint management methods #####

    def _savepoint(self, sid***REMOVED***:
        with self.cursor(***REMOVED*** as cursor:
            cursor.execute(self.ops.savepoint_create_sql(sid***REMOVED******REMOVED***

    def _savepoint_rollback(self, sid***REMOVED***:
        with self.cursor(***REMOVED*** as cursor:
            cursor.execute(self.ops.savepoint_rollback_sql(sid***REMOVED******REMOVED***

    def _savepoint_commit(self, sid***REMOVED***:
        with self.cursor(***REMOVED*** as cursor:
            cursor.execute(self.ops.savepoint_commit_sql(sid***REMOVED******REMOVED***

    def _savepoint_allowed(self***REMOVED***:
        # Savepoints cannot be created outside a transaction
        return self.features.uses_savepoints and not self.get_autocommit(***REMOVED***

    # ##### Generic savepoint management methods #####

    def savepoint(self***REMOVED***:
        ***REMOVED***
        Creates a savepoint inside the current transaction. Returns an
        identifier for the savepoint that will be used for the subsequent
        rollback or commit. Does nothing if savepoints are not supported.
        ***REMOVED***
        if not self._savepoint_allowed(***REMOVED***:
            return

        thread_ident = thread.get_ident(***REMOVED***
        tid = str(thread_ident***REMOVED***.replace('-', ''***REMOVED***

        self.savepoint_state += 1
        sid = "s%s_x%d" % (tid, self.savepoint_state***REMOVED***

        self.validate_thread_sharing(***REMOVED***
        self._savepoint(sid***REMOVED***

        return sid

    def savepoint_rollback(self, sid***REMOVED***:
        ***REMOVED***
        Rolls back to a savepoint. Does nothing if savepoints are not supported.
        ***REMOVED***
        if not self._savepoint_allowed(***REMOVED***:
            return

        self.validate_thread_sharing(***REMOVED***
        self._savepoint_rollback(sid***REMOVED***

        # Remove any callbacks registered while this savepoint was active.
        self.run_on_commit = [
            (sids, func***REMOVED*** for (sids, func***REMOVED*** in self.run_on_commit if sid not in sids
        ***REMOVED***

    def savepoint_commit(self, sid***REMOVED***:
        ***REMOVED***
        Releases a savepoint. Does nothing if savepoints are not supported.
        ***REMOVED***
        if not self._savepoint_allowed(***REMOVED***:
            return

        self.validate_thread_sharing(***REMOVED***
        self._savepoint_commit(sid***REMOVED***

    def clean_savepoints(self***REMOVED***:
        ***REMOVED***
        Resets the counter used to generate unique savepoint ids in this thread.
        ***REMOVED***
        self.savepoint_state = 0

    # ##### Backend-specific transaction management methods #####

    def _set_autocommit(self, autocommit***REMOVED***:
        ***REMOVED***
        Backend-specific implementation to enable or disable autocommit.
        ***REMOVED***
        raise NotImplementedError('subclasses of BaseDatabaseWrapper may require a _set_autocommit(***REMOVED*** method'***REMOVED***

    # ##### Generic transaction management methods #####

    def get_autocommit(self***REMOVED***:
        ***REMOVED***
        Check the autocommit state.
        ***REMOVED***
        self.ensure_connection(***REMOVED***
        return self.autocommit

    def set_autocommit(self, autocommit, force_begin_transaction_with_broken_autocommit=False***REMOVED***:
        ***REMOVED***
        Enable or disable autocommit.

        The usual way to start a transaction is to turn autocommit off.
        SQLite does not properly start a transaction when disabling
        autocommit. To avoid this buggy behavior and to actually enter a new
        transaction, an explcit BEGIN is required. Using
        force_begin_transaction_with_broken_autocommit=True will issue an
        explicit BEGIN with SQLite. This option will be ignored for other
        backends.
        ***REMOVED***
        self.validate_no_atomic_block(***REMOVED***
        self.ensure_connection(***REMOVED***

        start_transaction_under_autocommit = (
            force_begin_transaction_with_broken_autocommit and not autocommit and
            self.features.autocommits_when_autocommit_is_off
        ***REMOVED***

        if start_transaction_under_autocommit:
            self._start_transaction_under_autocommit(***REMOVED***
        else:
            self._set_autocommit(autocommit***REMOVED***

        self.autocommit = autocommit

        if autocommit and self.run_commit_hooks_on_set_autocommit_on:
            self.run_and_clear_commit_hooks(***REMOVED***
            self.run_commit_hooks_on_set_autocommit_on = False

    def get_rollback(self***REMOVED***:
        ***REMOVED***
        Get the "needs rollback" flag -- for *advanced use* only.
        ***REMOVED***
        if not self.in_atomic_block:
            raise TransactionManagementError(
                "The rollback flag doesn't work outside of an 'atomic' block."***REMOVED***
        return self.needs_rollback

    def set_rollback(self, rollback***REMOVED***:
        ***REMOVED***
        Set or unset the "needs rollback" flag -- for *advanced use* only.
        ***REMOVED***
        if not self.in_atomic_block:
            raise TransactionManagementError(
                "The rollback flag doesn't work outside of an 'atomic' block."***REMOVED***
        self.needs_rollback = rollback

    def validate_no_atomic_block(self***REMOVED***:
        ***REMOVED***
        Raise an error if an atomic block is active.
        ***REMOVED***
        if self.in_atomic_block:
            raise TransactionManagementError(
                "This is forbidden when an 'atomic' block is active."***REMOVED***

    def validate_no_broken_transaction(self***REMOVED***:
        if self.needs_rollback:
            raise TransactionManagementError(
                "An error occurred in the current transaction. You can't "
                "execute queries until the end of the 'atomic' block."***REMOVED***

    # ##### Foreign key constraints checks handling #####

    @contextmanager
    def constraint_checks_disabled(self***REMOVED***:
        ***REMOVED***
        Context manager that disables foreign key constraint checking.
        ***REMOVED***
        disabled = self.disable_constraint_checking(***REMOVED***
        ***REMOVED***
            yield
        finally:
            if disabled:
                self.enable_constraint_checking(***REMOVED***

    def disable_constraint_checking(self***REMOVED***:
        ***REMOVED***
        Backends can implement as needed to temporarily disable foreign key
        constraint checking. Should return True if the constraints were
        disabled and will need to be reenabled.
        ***REMOVED***
        return False

    def enable_constraint_checking(self***REMOVED***:
        ***REMOVED***
        Backends can implement as needed to re-enable foreign key constraint
        checking.
        ***REMOVED***
        pass

    def check_constraints(self, table_names=None***REMOVED***:
        ***REMOVED***
        Backends can override this method if they can apply constraint
        checking (e.g. via "SET CONSTRAINTS ALL IMMEDIATE"***REMOVED***. Should raise an
        IntegrityError if any invalid foreign key references are encountered.
        ***REMOVED***
        pass

    # ##### Connection termination handling #####

    def is_usable(self***REMOVED***:
        ***REMOVED***
        Tests if the database connection is usable.

        This function may assume that self.connection is not None.

        Actual implementations should take care not to raise exceptions
        as that may prevent Django from recycling unusable connections.
        ***REMOVED***
        raise NotImplementedError(
            "subclasses of BaseDatabaseWrapper may require an is_usable(***REMOVED*** method"***REMOVED***

    def close_if_unusable_or_obsolete(self***REMOVED***:
        ***REMOVED***
        Closes the current connection if unrecoverable errors have occurred,
        or if it outlived its maximum age.
        ***REMOVED***
        if self.connection is not None:
            # If the application didn't restore the original autocommit setting,
            # don't take chances, drop the connection.
            if self.get_autocommit(***REMOVED*** != self.settings_dict['AUTOCOMMIT'***REMOVED***:
                self.close(***REMOVED***
                return

            # If an exception other than DataError or IntegrityError occurred
            # since the last commit / rollback, check if the connection works.
            if self.errors_occurred:
                if self.is_usable(***REMOVED***:
                    self.errors_occurred = False
                else:
                    self.close(***REMOVED***
                    return

            if self.close_at is not None and time.time(***REMOVED*** >= self.close_at:
                self.close(***REMOVED***
                return

    # ##### Thread safety handling #####

    def validate_thread_sharing(self***REMOVED***:
        ***REMOVED***
        Validates that the connection isn't accessed by another thread than the
        one which originally created it, unless the connection was explicitly
        authorized to be shared between threads (via the `allow_thread_sharing`
        property***REMOVED***. Raises an exception if the validation fails.
        ***REMOVED***
        if not (self.allow_thread_sharing or self._thread_ident == thread.get_ident(***REMOVED******REMOVED***:
            raise DatabaseError(
                "DatabaseWrapper objects created in a "
                "thread can only be used in that same thread. The object "
                "with alias '%s' was created in thread id %s and this is "
                "thread id %s."
                % (self.alias, self._thread_ident, thread.get_ident(***REMOVED******REMOVED***
            ***REMOVED***

    # ##### Miscellaneous #####

    def prepare_database(self***REMOVED***:
        ***REMOVED***
        Hook to do any database check or preparation, generally called before
        migrating a project or an app.
        ***REMOVED***
        pass

    @cached_property
    def wrap_database_errors(self***REMOVED***:
        ***REMOVED***
        Context manager and decorator that re-throws backend-specific database
        exceptions using Django's common wrappers.
        ***REMOVED***
        return DatabaseErrorWrapper(self***REMOVED***

    def make_debug_cursor(self, cursor***REMOVED***:
        ***REMOVED***
        Creates a cursor that logs all queries in self.queries_log.
        ***REMOVED***
        return utils.CursorDebugWrapper(cursor, self***REMOVED***

    def make_cursor(self, cursor***REMOVED***:
        ***REMOVED***
        Creates a cursor without debug logging.
        ***REMOVED***
        return utils.CursorWrapper(cursor, self***REMOVED***

    @contextmanager
    def temporary_connection(self***REMOVED***:
        ***REMOVED***
        Context manager that ensures that a connection is established, and
        if it opened one, closes it to avoid leaving a dangling connection.
        This is useful for operations outside of the request-response cycle.

        Provides a cursor: with self.temporary_connection(***REMOVED*** as cursor: ...
        ***REMOVED***
        must_close = self.connection is None
        cursor = self.cursor(***REMOVED***
        ***REMOVED***
            yield cursor
        finally:
            cursor.close(***REMOVED***
            if must_close:
                self.close(***REMOVED***

    @property
    def _nodb_connection(self***REMOVED***:
        ***REMOVED***
        Return an alternative connection to be used when there is no need to access
        the main database, specifically for test db creation/deletion.
        This also prevents the production database from being exposed to
        potential child threads while (or after***REMOVED*** the test database is destroyed.
        Refs #10868, #17786, #16969.
        ***REMOVED***
        settings_dict = self.settings_dict.copy(***REMOVED***
        settings_dict['NAME'***REMOVED*** = None
        nodb_connection = self.__class__(
            settings_dict,
            alias=NO_DB_ALIAS,
            allow_thread_sharing=False***REMOVED***
        return nodb_connection

    def _start_transaction_under_autocommit(self***REMOVED***:
        ***REMOVED***
        Only required when autocommits_when_autocommit_is_off = True.
        ***REMOVED***
        raise NotImplementedError(
            'subclasses of BaseDatabaseWrapper may require a '
            '_start_transaction_under_autocommit(***REMOVED*** method'
        ***REMOVED***

    def schema_editor(self, *args, **kwargs***REMOVED***:
        ***REMOVED***
        Returns a new instance of this backend's SchemaEditor.
        ***REMOVED***
        if self.SchemaEditorClass is None:
            raise NotImplementedError(
                'The SchemaEditorClass attribute of this database wrapper is still None'***REMOVED***
        return self.SchemaEditorClass(self, *args, **kwargs***REMOVED***

    def on_commit(self, func***REMOVED***:
        if self.in_atomic_block:
            # Transaction in progress; save for execution on commit.
            self.run_on_commit.append((set(self.savepoint_ids***REMOVED***, func***REMOVED******REMOVED***
        elif not self.get_autocommit(***REMOVED***:
            raise TransactionManagementError('on_commit(***REMOVED*** cannot be used in manual transaction management'***REMOVED***
        else:
            # No transaction in progress and in autocommit mode; execute
            # immediately.
            func(***REMOVED***

    def run_and_clear_commit_hooks(self***REMOVED***:
        self.validate_no_atomic_block(***REMOVED***
        current_run_on_commit = self.run_on_commit
        self.run_on_commit = [***REMOVED***
        while current_run_on_commit:
            sids, func = current_run_on_commit.pop(0***REMOVED***
            func(***REMOVED***

    def copy(self, alias=None, allow_thread_sharing=None***REMOVED***:
        ***REMOVED***
        Return a copy of this connection.

        For tests that require two connections to the same database.
        ***REMOVED***
        settings_dict = copy.deepcopy(self.settings_dict***REMOVED***
        if alias is None:
            alias = self.alias
        if allow_thread_sharing is None:
            allow_thread_sharing = self.allow_thread_sharing
        return type(self***REMOVED***(settings_dict, alias, allow_thread_sharing***REMOVED***
