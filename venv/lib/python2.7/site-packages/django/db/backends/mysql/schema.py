from django.db.backends.base.schema import BaseDatabaseSchemaEditor
from django.db.models import NOT_PROVIDED


class DatabaseSchemaEditor(BaseDatabaseSchemaEditor***REMOVED***:

    sql_rename_table = "RENAME TABLE %(old_table***REMOVED***s TO %(new_table***REMOVED***s"

    sql_alter_column_null = "MODIFY %(column***REMOVED***s %(type***REMOVED***s NULL"
    sql_alter_column_not_null = "MODIFY %(column***REMOVED***s %(type***REMOVED***s NOT NULL"
    sql_alter_column_type = "MODIFY %(column***REMOVED***s %(type***REMOVED***s"
    sql_rename_column = "ALTER TABLE %(table***REMOVED***s CHANGE %(old_column***REMOVED***s %(new_column***REMOVED***s %(type***REMOVED***s"

    sql_delete_unique = "ALTER TABLE %(table***REMOVED***s DROP INDEX %(name***REMOVED***s"

    sql_delete_fk = "ALTER TABLE %(table***REMOVED***s DROP FOREIGN KEY %(name***REMOVED***s"

    sql_delete_index = "DROP INDEX %(name***REMOVED***s ON %(table***REMOVED***s"

    sql_create_pk = "ALTER TABLE %(table***REMOVED***s ADD CONSTRAINT %(name***REMOVED***s PRIMARY KEY (%(columns***REMOVED***s***REMOVED***"
    sql_delete_pk = "ALTER TABLE %(table***REMOVED***s DROP PRIMARY KEY"

    def quote_value(self, value***REMOVED***:
        # Inner import to allow module to fail to load gracefully
        import MySQLdb.converters
        return MySQLdb.escape(value, MySQLdb.converters.conversions***REMOVED***

    def skip_default(self, field***REMOVED***:
        ***REMOVED***
        MySQL doesn't accept default values for TEXT and BLOB types, and
        implicitly treats these columns as nullable.
        ***REMOVED***
        db_type = field.db_type(self.connection***REMOVED***
        return (
            db_type is not None and
            db_type.lower(***REMOVED*** in {
                'tinyblob', 'blob', 'mediumblob', 'longblob',
                'tinytext', 'text', 'mediumtext', 'longtext',
        ***REMOVED***
        ***REMOVED***

    def add_field(self, model, field***REMOVED***:
        super(DatabaseSchemaEditor, self***REMOVED***.add_field(model, field***REMOVED***

        # Simulate the effect of a one-off default.
        # field.default may be unhashable, so a set isn't used for "in" check.
        if self.skip_default(field***REMOVED*** and field.default not in (None, NOT_PROVIDED***REMOVED***:
            effective_default = self.effective_default(field***REMOVED***
            self.execute('UPDATE %(table***REMOVED***s SET %(column***REMOVED***s = %%s' % {
                'table': self.quote_name(model._meta.db_table***REMOVED***,
                'column': self.quote_name(field.column***REMOVED***,
    ***REMOVED*** [effective_default***REMOVED******REMOVED***

    def _field_should_be_indexed(self, model, field***REMOVED***:
        create_index = super(DatabaseSchemaEditor, self***REMOVED***._field_should_be_indexed(model, field***REMOVED***
        storage = self.connection.introspection.get_storage_engine(
            self.connection.cursor(***REMOVED***, model._meta.db_table
        ***REMOVED***
        # No need to create an index for ForeignKey fields except if
        # db_constraint=False because the index from that constraint won't be
        # created.
        if (storage == "InnoDB" and
                create_index and
                field.get_internal_type(***REMOVED*** == 'ForeignKey' and
                field.db_constraint***REMOVED***:
            return False
        return create_index

    def _delete_composed_index(self, model, fields, *args***REMOVED***:
        ***REMOVED***
        MySQL can remove an implicit FK index on a field when that field is
        covered by another index like a unique_together. "covered" here means
        that the more complex index starts like the simpler one.
        http://bugs.mysql.com/bug.php?id=37910 / Django ticket #24757
        We check here before removing the [unique|index***REMOVED***_together if we have to
        recreate a FK index.
        ***REMOVED***
        first_field = model._meta.get_field(fields[0***REMOVED******REMOVED***
        if first_field.get_internal_type(***REMOVED*** == 'ForeignKey':
            constraint_names = self._constraint_names(model, [first_field.column***REMOVED***, index=True***REMOVED***
            if not constraint_names:
                self.execute(self._create_index_sql(model, [first_field***REMOVED***, suffix=""***REMOVED******REMOVED***
        return super(DatabaseSchemaEditor, self***REMOVED***._delete_composed_index(model, fields, *args***REMOVED***

    def _set_field_new_type_null_status(self, field, new_type***REMOVED***:
        ***REMOVED***
        Keep the null property of the old field. If it has changed, it will be
        handled separately.
        ***REMOVED***
        if field.null:
            new_type += " NULL"
        else:
            new_type += " NOT NULL"
        return new_type

    def _alter_column_type_sql(self, table, old_field, new_field, new_type***REMOVED***:
        new_type = self._set_field_new_type_null_status(old_field, new_type***REMOVED***
        return super(DatabaseSchemaEditor, self***REMOVED***._alter_column_type_sql(table, old_field, new_field, new_type***REMOVED***

    def _rename_field_sql(self, table, old_field, new_field, new_type***REMOVED***:
        new_type = self._set_field_new_type_null_status(old_field, new_type***REMOVED***
        return super(DatabaseSchemaEditor, self***REMOVED***._rename_field_sql(table, old_field, new_field, new_type***REMOVED***
