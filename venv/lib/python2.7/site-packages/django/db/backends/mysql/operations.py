from __future__ import unicode_literals

import uuid

from django.conf import settings
from django.db.backends.base.operations import BaseDatabaseOperations
from django.utils import six, timezone
from django.utils.encoding import force_text


class DatabaseOperations(BaseDatabaseOperations***REMOVED***:
    compiler_module = "django.db.backends.mysql.compiler"

    # MySQL stores positive fields as UNSIGNED ints.
    integer_field_ranges = dict(
        BaseDatabaseOperations.integer_field_ranges,
        PositiveSmallIntegerField=(0, 65535***REMOVED***,
        PositiveIntegerField=(0, 4294967295***REMOVED***,
    ***REMOVED***

    def date_extract_sql(self, lookup_type, field_name***REMOVED***:
        # http://dev.mysql.com/doc/mysql/en/date-and-time-functions.html
        if lookup_type == 'week_day':
            # DAYOFWEEK(***REMOVED*** returns an integer, 1-7, Sunday=1.
            # Note: WEEKDAY(***REMOVED*** returns 0-6, Monday=0.
            return "DAYOFWEEK(%s***REMOVED***" % field_name
        else:
            return "EXTRACT(%s FROM %s***REMOVED***" % (lookup_type.upper(***REMOVED***, field_name***REMOVED***

    def date_trunc_sql(self, lookup_type, field_name***REMOVED***:
        fields = {
            'year': '%%Y-01-01',
            'month': '%%Y-%%m-01',
    ***REMOVED***  # Use double percents to escape.
        if lookup_type in fields:
            format_str = fields[lookup_type***REMOVED***
            return "CAST(DATE_FORMAT(%s, '%s'***REMOVED*** AS DATE***REMOVED***" % (field_name, format_str***REMOVED***
        else:
            return "DATE(%s***REMOVED***" % (field_name***REMOVED***

    def _convert_field_to_tz(self, field_name, tzname***REMOVED***:
        if settings.USE_TZ:
            field_name = "CONVERT_TZ(%s, 'UTC', %%s***REMOVED***" % field_name
            params = [tzname***REMOVED***
        else:
            params = [***REMOVED***
        return field_name, params

    def datetime_cast_date_sql(self, field_name, tzname***REMOVED***:
        field_name, params = self._convert_field_to_tz(field_name, tzname***REMOVED***
        sql = "DATE(%s***REMOVED***" % field_name
        return sql, params

    def datetime_extract_sql(self, lookup_type, field_name, tzname***REMOVED***:
        field_name, params = self._convert_field_to_tz(field_name, tzname***REMOVED***
        sql = self.date_extract_sql(lookup_type, field_name***REMOVED***
        return sql, params

    def datetime_trunc_sql(self, lookup_type, field_name, tzname***REMOVED***:
        field_name, params = self._convert_field_to_tz(field_name, tzname***REMOVED***
        fields = ['year', 'month', 'day', 'hour', 'minute', 'second'***REMOVED***
        format = ('%%Y-', '%%m', '-%%d', ' %%H:', '%%i', ':%%s'***REMOVED***  # Use double percents to escape.
        format_def = ('0000-', '01', '-01', ' 00:', '00', ':00'***REMOVED***
        ***REMOVED***
            i = fields.index(lookup_type***REMOVED*** + 1
        except ValueError:
            sql = field_name
        else:
            format_str = ''.join([f for f in format[:i***REMOVED******REMOVED*** + [f for f in format_def[i:***REMOVED******REMOVED******REMOVED***
            sql = "CAST(DATE_FORMAT(%s, '%s'***REMOVED*** AS DATETIME***REMOVED***" % (field_name, format_str***REMOVED***
        return sql, params

    def date_interval_sql(self, timedelta***REMOVED***:
        return "INTERVAL '%d 0:0:%d:%d' DAY_MICROSECOND" % (
            timedelta.days, timedelta.seconds, timedelta.microseconds***REMOVED***, [***REMOVED***

    def format_for_duration_arithmetic(self, sql***REMOVED***:
        if self.connection.features.supports_microsecond_precision:
            return 'INTERVAL %s MICROSECOND' % sql
        else:
            return 'INTERVAL FLOOR(%s / 1000000***REMOVED*** SECOND' % sql

    def drop_foreignkey_sql(self***REMOVED***:
        return "DROP FOREIGN KEY"

    def force_no_ordering(self***REMOVED***:
        ***REMOVED***
        "ORDER BY NULL" prevents MySQL from implicitly ordering by grouped
        columns. If no ordering would otherwise be applied, we don't want any
        implicit sorting going on.
        ***REMOVED***
        return [(None, ("NULL", [***REMOVED***, False***REMOVED******REMOVED******REMOVED***

    def fulltext_search_sql(self, field_name***REMOVED***:
        # RemovedInDjango20Warning
        return 'MATCH (%s***REMOVED*** AGAINST (%%s IN BOOLEAN MODE***REMOVED***' % field_name

    def last_executed_query(self, cursor, sql, params***REMOVED***:
        # With MySQLdb, cursor objects have an (undocumented***REMOVED*** "_last_executed"
        # attribute where the exact query sent to the database is saved.
        # See MySQLdb/cursors.py in the source distribution.
        return force_text(getattr(cursor, '_last_executed', None***REMOVED***, errors='replace'***REMOVED***

    def no_limit_value(self***REMOVED***:
        # 2**64 - 1, as recommended by the MySQL documentation
        return 18446744073709551615

    def quote_name(self, name***REMOVED***:
        if name.startswith("`"***REMOVED*** and name.endswith("`"***REMOVED***:
            return name  # Quoting once is enough.
        return "`%s`" % name

    def random_function_sql(self***REMOVED***:
        return 'RAND(***REMOVED***'

    def sql_flush(self, style, tables, sequences, allow_cascade=False***REMOVED***:
        # NB: The generated SQL below is specific to MySQL
        # 'TRUNCATE x;', 'TRUNCATE y;', 'TRUNCATE z;'... style SQL statements
        # to clear all tables of all data
        if tables:
            sql = ['SET FOREIGN_KEY_CHECKS = 0;'***REMOVED***
            for table in tables:
                sql.append('%s %s;' % (
                    style.SQL_KEYWORD('TRUNCATE'***REMOVED***,
                    style.SQL_FIELD(self.quote_name(table***REMOVED******REMOVED***,
                ***REMOVED******REMOVED***
            sql.append('SET FOREIGN_KEY_CHECKS = 1;'***REMOVED***
            sql.extend(self.sequence_reset_by_name_sql(style, sequences***REMOVED******REMOVED***
            return sql
        else:
            return [***REMOVED***

    def validate_autopk_value(self, value***REMOVED***:
        # MySQLism: zero in AUTO_INCREMENT field does not work. Refs #17653.
        if value == 0:
            raise ValueError('The database backend does not accept 0 as a '
                             'value for AutoField.'***REMOVED***
        return value

    def adapt_datetimefield_value(self, value***REMOVED***:
        if value is None:
            return None

        # MySQL doesn't support tz-aware datetimes
        if timezone.is_aware(value***REMOVED***:
            if settings.USE_TZ:
                value = timezone.make_naive(value, self.connection.timezone***REMOVED***
            else:
                raise ValueError("MySQL backend does not support timezone-aware datetimes when USE_TZ is False."***REMOVED***

        if not self.connection.features.supports_microsecond_precision:
            value = value.replace(microsecond=0***REMOVED***

        return six.text_type(value***REMOVED***

    def adapt_timefield_value(self, value***REMOVED***:
        if value is None:
            return None

        # MySQL doesn't support tz-aware times
        if timezone.is_aware(value***REMOVED***:
            raise ValueError("MySQL backend does not support timezone-aware times."***REMOVED***

        return six.text_type(value***REMOVED***

    def max_name_length(self***REMOVED***:
        return 64

    def bulk_insert_sql(self, fields, placeholder_rows***REMOVED***:
        placeholder_rows_sql = (", ".join(row***REMOVED*** for row in placeholder_rows***REMOVED***
        values_sql = ", ".join("(%s***REMOVED***" % sql for sql in placeholder_rows_sql***REMOVED***
        return "VALUES " + values_sql

    def combine_expression(self, connector, sub_expressions***REMOVED***:
        ***REMOVED***
        MySQL requires special cases for ^ operators in query expressions
        ***REMOVED***
        if connector == '^':
            return 'POW(%s***REMOVED***' % ','.join(sub_expressions***REMOVED***
        return super(DatabaseOperations, self***REMOVED***.combine_expression(connector, sub_expressions***REMOVED***

    def get_db_converters(self, expression***REMOVED***:
        converters = super(DatabaseOperations, self***REMOVED***.get_db_converters(expression***REMOVED***
        internal_type = expression.output_field.get_internal_type(***REMOVED***
        if internal_type == 'TextField':
            converters.append(self.convert_textfield_value***REMOVED***
        elif internal_type in ['BooleanField', 'NullBooleanField'***REMOVED***:
            converters.append(self.convert_booleanfield_value***REMOVED***
        elif internal_type == 'DateTimeField':
            converters.append(self.convert_datetimefield_value***REMOVED***
        elif internal_type == 'UUIDField':
            converters.append(self.convert_uuidfield_value***REMOVED***
        return converters

    def convert_textfield_value(self, value, expression, connection, context***REMOVED***:
        if value is not None:
            value = force_text(value***REMOVED***
        return value

    def convert_booleanfield_value(self, value, expression, connection, context***REMOVED***:
        if value in (0, 1***REMOVED***:
            value = bool(value***REMOVED***
        return value

    def convert_datetimefield_value(self, value, expression, connection, context***REMOVED***:
        if value is not None:
            if settings.USE_TZ:
                value = timezone.make_aware(value, self.connection.timezone***REMOVED***
        return value

    def convert_uuidfield_value(self, value, expression, connection, context***REMOVED***:
        if value is not None:
            value = uuid.UUID(value***REMOVED***
        return value

    def binary_placeholder_sql(self, value***REMOVED***:
        return '_binary %s' if value is not None else '%s'

    def subtract_temporals(self, internal_type, lhs, rhs***REMOVED***:
        lhs_sql, lhs_params = lhs
        rhs_sql, rhs_params = rhs
        if self.connection.features.supports_microsecond_precision:
            if internal_type == 'TimeField':
                return (
                    "((TIME_TO_SEC(%(lhs***REMOVED***s***REMOVED*** * POW(10, 6***REMOVED*** + MICROSECOND(%(lhs***REMOVED***s***REMOVED******REMOVED*** -"
                    " (TIME_TO_SEC(%(rhs***REMOVED***s***REMOVED*** * POW(10, 6***REMOVED*** + MICROSECOND(%(rhs***REMOVED***s***REMOVED******REMOVED******REMOVED***"
                ***REMOVED*** % {'lhs': lhs_sql, 'rhs': rhs_sql***REMOVED***, lhs_params * 2 + rhs_params * 2
            else:
                return "TIMESTAMPDIFF(MICROSECOND, %s, %s***REMOVED***" % (rhs_sql, lhs_sql***REMOVED***, rhs_params + lhs_params
        elif internal_type == 'TimeField':
            return (
                "(TIME_TO_SEC(%s***REMOVED*** * POW(10, 6***REMOVED*** - TIME_TO_SEC(%s***REMOVED*** * POW(10, 6***REMOVED******REMOVED***"
            ***REMOVED*** % (lhs_sql, rhs_sql***REMOVED***, lhs_params + rhs_params
        else:
            return "(TIMESTAMPDIFF(SECOND, %s, %s***REMOVED*** * POW(10, 6***REMOVED******REMOVED***" % (rhs_sql, lhs_sql***REMOVED***, rhs_params + lhs_params
