from collections import namedtuple

from MySQLdb.constants import FIELD_TYPE

from django.db.backends.base.introspection import (
    BaseDatabaseIntrospection, FieldInfo, TableInfo,
***REMOVED***
from django.utils.datastructures import OrderedSet
from django.utils.encoding import force_text

FieldInfo = namedtuple('FieldInfo', FieldInfo._fields + ('extra', 'default'***REMOVED******REMOVED***
InfoLine = namedtuple('InfoLine', 'col_name data_type max_len num_prec num_scale extra column_default'***REMOVED***


class DatabaseIntrospection(BaseDatabaseIntrospection***REMOVED***:
    data_types_reverse = {
        FIELD_TYPE.BLOB: 'TextField',
        FIELD_TYPE.CHAR: 'CharField',
        FIELD_TYPE.DECIMAL: 'DecimalField',
        FIELD_TYPE.NEWDECIMAL: 'DecimalField',
        FIELD_TYPE.DATE: 'DateField',
        FIELD_TYPE.DATETIME: 'DateTimeField',
        FIELD_TYPE.DOUBLE: 'FloatField',
        FIELD_TYPE.FLOAT: 'FloatField',
        FIELD_TYPE.INT24: 'IntegerField',
        FIELD_TYPE.LONG: 'IntegerField',
        FIELD_TYPE.LONGLONG: 'BigIntegerField',
        FIELD_TYPE.SHORT: 'SmallIntegerField',
        FIELD_TYPE.STRING: 'CharField',
        FIELD_TYPE.TIME: 'TimeField',
        FIELD_TYPE.TIMESTAMP: 'DateTimeField',
        FIELD_TYPE.TINY: 'IntegerField',
        FIELD_TYPE.TINY_BLOB: 'TextField',
        FIELD_TYPE.MEDIUM_BLOB: 'TextField',
        FIELD_TYPE.LONG_BLOB: 'TextField',
        FIELD_TYPE.VAR_STRING: 'CharField',
***REMOVED***

    def get_field_type(self, data_type, description***REMOVED***:
        field_type = super(DatabaseIntrospection, self***REMOVED***.get_field_type(data_type, description***REMOVED***
        if 'auto_increment' in description.extra:
            if field_type == 'IntegerField':
                return 'AutoField'
            elif field_type == 'BigIntegerField':
                return 'BigAutoField'

        return field_type

    def get_table_list(self, cursor***REMOVED***:
        ***REMOVED***
        Returns a list of table and view names in the current database.
        ***REMOVED***
        cursor.execute("SHOW FULL TABLES"***REMOVED***
        return [TableInfo(row[0***REMOVED***, {'BASE TABLE': 't', 'VIEW': 'v'***REMOVED***.get(row[1***REMOVED******REMOVED******REMOVED***
                for row in cursor.fetchall(***REMOVED******REMOVED***

    def get_table_description(self, cursor, table_name***REMOVED***:
        ***REMOVED***
        Returns a description of the table, with the DB-API cursor.description interface."
        ***REMOVED***
        # information_schema database gives more accurate results for some figures:
        # - varchar length returned by cursor.description is an internal length,
        #   not visible length (#5725***REMOVED***
        # - precision and scale (for decimal fields***REMOVED*** (#5014***REMOVED***
        # - auto_increment is not available in cursor.description
        cursor.execute(***REMOVED***
            SELECT column_name, data_type, character_maximum_length, numeric_precision,
                   numeric_scale, extra, column_default
            FROM information_schema.columns
            WHERE table_name = %s AND table_schema = DATABASE(***REMOVED******REMOVED***, [table_name***REMOVED******REMOVED***
        field_info = {line[0***REMOVED***: InfoLine(*line***REMOVED*** for line in cursor.fetchall(***REMOVED******REMOVED***

        cursor.execute("SELECT * FROM %s LIMIT 1" % self.connection.ops.quote_name(table_name***REMOVED******REMOVED***

        def to_int(i***REMOVED***:
            return int(i***REMOVED*** if i is not None else i

        fields = [***REMOVED***
        for line in cursor.description:
            col_name = force_text(line[0***REMOVED******REMOVED***
            fields.append(
                FieldInfo(*(
                    (col_name,***REMOVED*** +
                    line[1:3***REMOVED*** +
                    (
                        to_int(field_info[col_name***REMOVED***.max_len***REMOVED*** or line[3***REMOVED***,
                        to_int(field_info[col_name***REMOVED***.num_prec***REMOVED*** or line[4***REMOVED***,
                        to_int(field_info[col_name***REMOVED***.num_scale***REMOVED*** or line[5***REMOVED***,
                        line[6***REMOVED***,
                        field_info[col_name***REMOVED***.extra,
                        field_info[col_name***REMOVED***.column_default,
                    ***REMOVED***
                ***REMOVED******REMOVED***
            ***REMOVED***
        return fields

    def get_relations(self, cursor, table_name***REMOVED***:
        ***REMOVED***
        Returns a dictionary of {field_name: (field_name_other_table, other_table***REMOVED******REMOVED***
        representing all relationships to the given table.
        ***REMOVED***
        constraints = self.get_key_columns(cursor, table_name***REMOVED***
        relations = {***REMOVED***
        for my_fieldname, other_table, other_field in constraints:
            relations[my_fieldname***REMOVED*** = (other_field, other_table***REMOVED***
        return relations

    def get_key_columns(self, cursor, table_name***REMOVED***:
        ***REMOVED***
        Returns a list of (column_name, referenced_table_name, referenced_column_name***REMOVED*** for all
        key columns in given table.
        ***REMOVED***
        key_columns = [***REMOVED***
        cursor.execute(***REMOVED***
            SELECT column_name, referenced_table_name, referenced_column_name
            FROM information_schema.key_column_usage
            WHERE table_name = %s
                AND table_schema = DATABASE(***REMOVED***
                AND referenced_table_name IS NOT NULL
                AND referenced_column_name IS NOT NULL***REMOVED***, [table_name***REMOVED******REMOVED***
        key_columns.extend(cursor.fetchall(***REMOVED******REMOVED***
        return key_columns

    def get_indexes(self, cursor, table_name***REMOVED***:
        cursor.execute("SHOW INDEX FROM %s" % self.connection.ops.quote_name(table_name***REMOVED******REMOVED***
        # Do a two-pass search for indexes: on first pass check which indexes
        # are multicolumn, on second pass check which single-column indexes
        # are present.
        rows = list(cursor.fetchall(***REMOVED******REMOVED***
        multicol_indexes = set(***REMOVED***
        for row in rows:
            if row[3***REMOVED*** > 1:
                multicol_indexes.add(row[2***REMOVED******REMOVED***
        indexes = {***REMOVED***
        for row in rows:
            if row[2***REMOVED*** in multicol_indexes:
                continue
            if row[4***REMOVED*** not in indexes:
                indexes[row[4***REMOVED******REMOVED*** = {'primary_key': False, 'unique': False***REMOVED***
            # It's possible to have the unique and PK constraints in separate indexes.
            if row[2***REMOVED*** == 'PRIMARY':
                indexes[row[4***REMOVED******REMOVED***['primary_key'***REMOVED*** = True
            if not row[1***REMOVED***:
                indexes[row[4***REMOVED******REMOVED***['unique'***REMOVED*** = True
        return indexes

    def get_storage_engine(self, cursor, table_name***REMOVED***:
        ***REMOVED***
        Retrieves the storage engine for a given table. Returns the default
        storage engine if the table doesn't exist.
        ***REMOVED***
        cursor.execute(
            "SELECT engine "
            "FROM information_schema.tables "
            "WHERE table_name = %s", [table_name***REMOVED******REMOVED***
        result = cursor.fetchone(***REMOVED***
        if not result:
            return self.connection.features._mysql_storage_engine
        return result[0***REMOVED***

    def get_constraints(self, cursor, table_name***REMOVED***:
        ***REMOVED***
        Retrieves any constraints or keys (unique, pk, fk, check, index***REMOVED*** across one or more columns.
        ***REMOVED***
        constraints = {***REMOVED***
        # Get the actual constraint names and columns
        name_query = ***REMOVED***
            SELECT kc.`constraint_name`, kc.`column_name`,
                kc.`referenced_table_name`, kc.`referenced_column_name`
            FROM information_schema.key_column_usage AS kc
            WHERE
                kc.table_schema = DATABASE(***REMOVED*** AND
                kc.table_name = %s
        ***REMOVED***
        cursor.execute(name_query, [table_name***REMOVED******REMOVED***
        for constraint, column, ref_table, ref_column in cursor.fetchall(***REMOVED***:
            if constraint not in constraints:
                constraints[constraint***REMOVED*** = {
                    'columns': OrderedSet(***REMOVED***,
                    'primary_key': False,
                    'unique': False,
                    'index': False,
                    'check': False,
                    'foreign_key': (ref_table, ref_column***REMOVED*** if ref_column else None,
            ***REMOVED***
            constraints[constraint***REMOVED***['columns'***REMOVED***.add(column***REMOVED***
        # Now get the constraint types
        type_query = ***REMOVED***
            SELECT c.constraint_name, c.constraint_type
            FROM information_schema.table_constraints AS c
            WHERE
                c.table_schema = DATABASE(***REMOVED*** AND
                c.table_name = %s
        ***REMOVED***
        cursor.execute(type_query, [table_name***REMOVED******REMOVED***
        for constraint, kind in cursor.fetchall(***REMOVED***:
            if kind.lower(***REMOVED*** == "primary key":
                constraints[constraint***REMOVED***['primary_key'***REMOVED*** = True
                constraints[constraint***REMOVED***['unique'***REMOVED*** = True
            elif kind.lower(***REMOVED*** == "unique":
                constraints[constraint***REMOVED***['unique'***REMOVED*** = True
        # Now add in the indexes
        cursor.execute("SHOW INDEX FROM %s" % self.connection.ops.quote_name(table_name***REMOVED******REMOVED***
        for table, non_unique, index, colseq, column in [x[:5***REMOVED*** for x in cursor.fetchall(***REMOVED******REMOVED***:
            if index not in constraints:
                constraints[index***REMOVED*** = {
                    'columns': OrderedSet(***REMOVED***,
                    'primary_key': False,
                    'unique': False,
                    'index': True,
                    'check': False,
                    'foreign_key': None,
            ***REMOVED***
            constraints[index***REMOVED***['index'***REMOVED*** = True
            constraints[index***REMOVED***['columns'***REMOVED***.add(column***REMOVED***
        # Convert the sorted sets to lists
        for constraint in constraints.values(***REMOVED***:
            constraint['columns'***REMOVED*** = list(constraint['columns'***REMOVED******REMOVED***
        return constraints
