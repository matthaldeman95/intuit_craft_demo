from __future__ import unicode_literals

import datetime
import decimal
import hashlib
import logging
from time import time

from django.conf import settings
from django.utils.encoding import force_bytes
from django.utils.timezone import utc

logger = logging.getLogger('django.db.backends'***REMOVED***


class CursorWrapper(object***REMOVED***:
    def __init__(self, cursor, db***REMOVED***:
        self.cursor = cursor
        self.db = db

    WRAP_ERROR_ATTRS = frozenset(['fetchone', 'fetchmany', 'fetchall', 'nextset'***REMOVED******REMOVED***

    def __getattr__(self, attr***REMOVED***:
        cursor_attr = getattr(self.cursor, attr***REMOVED***
        if attr in CursorWrapper.WRAP_ERROR_ATTRS:
            return self.db.wrap_database_errors(cursor_attr***REMOVED***
        else:
            return cursor_attr

    def __iter__(self***REMOVED***:
        with self.db.wrap_database_errors:
            for item in self.cursor:
                yield item

    def __enter__(self***REMOVED***:
        return self

    def __exit__(self, type, value, traceback***REMOVED***:
        # Ticket #17671 - Close instead of passing thru to avoid backend
        # specific behavior. Catch errors liberally because errors in cleanup
        # code aren't useful.
        ***REMOVED***
            self.close(***REMOVED***
        except self.db.Database.Error:
            pass

    # The following methods cannot be implemented in __getattr__, because the
    # code must run when the method is invoked, not just when it is accessed.

    def callproc(self, procname, params=None***REMOVED***:
        self.db.validate_no_broken_transaction(***REMOVED***
        with self.db.wrap_database_errors:
            if params is None:
                return self.cursor.callproc(procname***REMOVED***
            else:
                return self.cursor.callproc(procname, params***REMOVED***

    def execute(self, sql, params=None***REMOVED***:
        self.db.validate_no_broken_transaction(***REMOVED***
        with self.db.wrap_database_errors:
            if params is None:
                return self.cursor.execute(sql***REMOVED***
            else:
                return self.cursor.execute(sql, params***REMOVED***

    def executemany(self, sql, param_list***REMOVED***:
        self.db.validate_no_broken_transaction(***REMOVED***
        with self.db.wrap_database_errors:
            return self.cursor.executemany(sql, param_list***REMOVED***


class CursorDebugWrapper(CursorWrapper***REMOVED***:

    # XXX callproc isn't instrumented at this time.

    def execute(self, sql, params=None***REMOVED***:
        start = time(***REMOVED***
        ***REMOVED***
            return super(CursorDebugWrapper, self***REMOVED***.execute(sql, params***REMOVED***
        finally:
            stop = time(***REMOVED***
            duration = stop - start
            sql = self.db.ops.last_executed_query(self.cursor, sql, params***REMOVED***
            self.db.queries_log.append({
                'sql': sql,
                'time': "%.3f" % duration,
        ***REMOVED******REMOVED***
            logger.debug(
                '(%.3f***REMOVED*** %s; args=%s', duration, sql, params,
                extra={'duration': duration, 'sql': sql, 'params': params***REMOVED***
            ***REMOVED***

    def executemany(self, sql, param_list***REMOVED***:
        start = time(***REMOVED***
        ***REMOVED***
            return super(CursorDebugWrapper, self***REMOVED***.executemany(sql, param_list***REMOVED***
        finally:
            stop = time(***REMOVED***
            duration = stop - start
            ***REMOVED***
                times = len(param_list***REMOVED***
            except TypeError:           # param_list could be an iterator
                times = '?'
            self.db.queries_log.append({
                'sql': '%s times: %s' % (times, sql***REMOVED***,
                'time': "%.3f" % duration,
        ***REMOVED******REMOVED***
            logger.debug(
                '(%.3f***REMOVED*** %s; args=%s', duration, sql, param_list,
                extra={'duration': duration, 'sql': sql, 'params': param_list***REMOVED***
            ***REMOVED***


###############################################
# Converters from database (string***REMOVED*** to Python #
###############################################

def typecast_date(s***REMOVED***:
    return datetime.date(*map(int, s.split('-'***REMOVED******REMOVED******REMOVED*** if s else None  # returns None if s is null


def typecast_time(s***REMOVED***:  # does NOT store time zone information
    if not s:
        return None
    hour, minutes, seconds = s.split(':'***REMOVED***
    if '.' in seconds:  # check whether seconds have a fractional part
        seconds, microseconds = seconds.split('.'***REMOVED***
    else:
        microseconds = '0'
    return datetime.time(int(hour***REMOVED***, int(minutes***REMOVED***, int(seconds***REMOVED***, int((microseconds + '000000'***REMOVED***[:6***REMOVED******REMOVED******REMOVED***


def typecast_timestamp(s***REMOVED***:  # does NOT store time zone information
    # "2005-07-29 15:48:00.590358-05"
    # "2005-07-29 09:56:00-05"
    if not s:
        return None
    if ' ' not in s:
        return typecast_date(s***REMOVED***
    d, t = s.split(***REMOVED***
    # Extract timezone information, if it exists. Currently we just throw
    # it away, but in the future we may make use of it.
    if '-' in t:
        t, tz = t.split('-', 1***REMOVED***
        tz = '-' + tz
    elif '+' in t:
        t, tz = t.split('+', 1***REMOVED***
        tz = '+' + tz
    else:
        tz = ''
    dates = d.split('-'***REMOVED***
    times = t.split(':'***REMOVED***
    seconds = times[2***REMOVED***
    if '.' in seconds:  # check whether seconds have a fractional part
        seconds, microseconds = seconds.split('.'***REMOVED***
    else:
        microseconds = '0'
    tzinfo = utc if settings.USE_TZ else None
    return datetime.datetime(
        int(dates[0***REMOVED******REMOVED***, int(dates[1***REMOVED******REMOVED***, int(dates[2***REMOVED******REMOVED***,
        int(times[0***REMOVED******REMOVED***, int(times[1***REMOVED******REMOVED***, int(seconds***REMOVED***,
        int((microseconds + '000000'***REMOVED***[:6***REMOVED******REMOVED***, tzinfo
    ***REMOVED***


def typecast_decimal(s***REMOVED***:
    if s is None or s == '':
        return None
    return decimal.Decimal(s***REMOVED***


###############################################
# Converters from Python to database (string***REMOVED*** #
###############################################

def rev_typecast_decimal(d***REMOVED***:
    if d is None:
        return None
    return str(d***REMOVED***


def truncate_name(name, length=None, hash_len=4***REMOVED***:
    ***REMOVED***Shortens a string to a repeatable mangled version with the given length.
    ***REMOVED***
    if length is None or len(name***REMOVED*** <= length:
        return name

    hsh = hashlib.md5(force_bytes(name***REMOVED******REMOVED***.hexdigest(***REMOVED***[:hash_len***REMOVED***
    return '%s%s' % (name[:length - hash_len***REMOVED***, hsh***REMOVED***


def format_number(value, max_digits, decimal_places***REMOVED***:
    ***REMOVED***
    Formats a number into a string with the requisite number of digits and
    decimal places.
    ***REMOVED***
    if value is None:
        return None
    if isinstance(value, decimal.Decimal***REMOVED***:
        context = decimal.getcontext(***REMOVED***.copy(***REMOVED***
        if max_digits is not None:
            context.prec = max_digits
        if decimal_places is not None:
            value = value.quantize(decimal.Decimal(".1"***REMOVED*** ** decimal_places, context=context***REMOVED***
        else:
            context.traps[decimal.Rounded***REMOVED*** = 1
            value = context.create_decimal(value***REMOVED***
        return "{:f***REMOVED***".format(value***REMOVED***
    if decimal_places is not None:
        return "%.*f" % (decimal_places, value***REMOVED***
    return "{:f***REMOVED***".format(value***REMOVED***
