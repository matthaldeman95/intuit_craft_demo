from __future__ import print_function, unicode_literals

import importlib
***REMOVED***
import sys

from django.apps import apps
from django.db.models.fields import NOT_PROVIDED
from django.utils import datetime_safe, six, timezone
from django.utils.six.moves import input

from .loader import MigrationLoader


class MigrationQuestioner(object***REMOVED***:
    ***REMOVED***
    Gives the autodetector responses to questions it might have.
    This base class has a built-in noninteractive mode, but the
    interactive subclass is what the command-line arguments will use.
    ***REMOVED***

    def __init__(self, defaults=None, specified_apps=None, dry_run=None***REMOVED***:
        self.defaults = defaults or {***REMOVED***
        self.specified_apps = specified_apps or set(***REMOVED***
        self.dry_run = dry_run

    def ask_initial(self, app_label***REMOVED***:
        "Should we create an initial migration for the app?"
        # If it was specified on the command line, definitely true
        if app_label in self.specified_apps:
            return True
        # Otherwise, we look to see if it has a migrations module
        # without any Python files in it, apart from __init__.py.
        # Apps from the new app template will have these; the python
        # file check will ensure we skip South ones.
        ***REMOVED***
            app_config = apps.get_app_config(app_label***REMOVED***
        except LookupError:         # It's a fake app.
            return self.defaults.get("ask_initial", False***REMOVED***
        migrations_import_path = MigrationLoader.migrations_module(app_config.label***REMOVED***
        if migrations_import_path is None:
            # It's an application with migrations disabled.
            return self.defaults.get("ask_initial", False***REMOVED***
        ***REMOVED***
            migrations_module = importlib.import_module(migrations_import_path***REMOVED***
        except ImportError:
            return self.defaults.get("ask_initial", False***REMOVED***
        else:
            if hasattr(migrations_module, "__file__"***REMOVED***:
                filenames = os.listdir(os.path.dirname(migrations_module.__file__***REMOVED******REMOVED***
            elif hasattr(migrations_module, "__path__"***REMOVED***:
                if len(migrations_module.__path__***REMOVED*** > 1:
                    return False
                filenames = os.listdir(list(migrations_module.__path__***REMOVED***[0***REMOVED******REMOVED***
            return not any(x.endswith(".py"***REMOVED*** for x in filenames if x != "__init__.py"***REMOVED***

    def ask_not_null_addition(self, field_name, model_name***REMOVED***:
        "Adding a NOT NULL field to a model"
        # None means quit
        return None

    def ask_not_null_alteration(self, field_name, model_name***REMOVED***:
        "Changing a NULL field to NOT NULL"
        # None means quit
        return None

    def ask_rename(self, model_name, old_name, new_name, field_instance***REMOVED***:
        "Was this field really renamed?"
        return self.defaults.get("ask_rename", False***REMOVED***

    def ask_rename_model(self, old_model_state, new_model_state***REMOVED***:
        "Was this model really renamed?"
        return self.defaults.get("ask_rename_model", False***REMOVED***

    def ask_merge(self, app_label***REMOVED***:
        "Do you really want to merge these migrations?"
        return self.defaults.get("ask_merge", False***REMOVED***

    def ask_auto_now_add_addition(self, field_name, model_name***REMOVED***:
        "Adding an auto_now_add field to a model"
        # None means quit
        return None


class InteractiveMigrationQuestioner(MigrationQuestioner***REMOVED***:

    def _boolean_input(self, question, default=None***REMOVED***:
        result = input("%s " % question***REMOVED***
        if not result and default is not None:
            return default
        while len(result***REMOVED*** < 1 or result[0***REMOVED***.lower(***REMOVED*** not in "yn":
            result = input("Please answer yes or no: "***REMOVED***
        return result[0***REMOVED***.lower(***REMOVED*** == "y"

    def _choice_input(self, question, choices***REMOVED***:
        print(question***REMOVED***
        for i, choice in enumerate(choices***REMOVED***:
            print(" %s***REMOVED*** %s" % (i + 1, choice***REMOVED******REMOVED***
        result = input("Select an option: "***REMOVED***
        while True:
            ***REMOVED***
                value = int(result***REMOVED***
                if 0 < value <= len(choices***REMOVED***:
                    return value
            except ValueError:
                pass
            result = input("Please select a valid option: "***REMOVED***

    def _ask_default(self, default=''***REMOVED***:
        ***REMOVED***
        Prompt for a default value.

        The ``default`` argument allows providing a custom default value (as a
        string***REMOVED*** which will be shown to the user and used as the return value
        if the user doesn't provide any other input.
        ***REMOVED***
        print("Please enter the default value now, as valid Python"***REMOVED***
        if default:
            print(
                "You can accept the default '{***REMOVED***' by pressing 'Enter' or you "
                "can provide another value.".format(default***REMOVED***
            ***REMOVED***
        print("The datetime and django.utils.timezone modules are available, so you can do e.g. timezone.now"***REMOVED***
        print("Type 'exit' to exit this prompt"***REMOVED***
        while True:
            if default:
                prompt = "[default: {***REMOVED******REMOVED*** >>> ".format(default***REMOVED***
            else:
                prompt = ">>> "
            if six.PY3:
                # Six does not correctly abstract over the fact that
                # py3 input returns a unicode string, while py2 raw_input
                # returns a bytestring.
                code = input(prompt***REMOVED***
            else:
                code = input(prompt***REMOVED***.decode(sys.stdin.encoding***REMOVED***
            if not code and default:
                code = default
            if not code:
                print("Please enter some code, or 'exit' (with no quotes***REMOVED*** to exit."***REMOVED***
            elif code == "exit":
                sys.exit(1***REMOVED***
            else:
                ***REMOVED***
                    return eval(code, {***REMOVED***, {"datetime": datetime_safe, "timezone": timezone***REMOVED******REMOVED***
                except (SyntaxError, NameError***REMOVED*** as e:
                    print("Invalid input: %s" % e***REMOVED***

    def ask_not_null_addition(self, field_name, model_name***REMOVED***:
        "Adding a NOT NULL field to a model"
        if not self.dry_run:
            choice = self._choice_input(
                "You are trying to add a non-nullable field '%s' to %s without a default; "
                "we can't do that (the database needs something to populate existing rows***REMOVED***.\n"
                "Please select a fix:" % (field_name, model_name***REMOVED***,
                [
                    ("Provide a one-off default now (will be set on all existing "
                     "rows with a null value for this column***REMOVED***"***REMOVED***,
                    "Quit, and let me add a default in models.py",
                ***REMOVED***
            ***REMOVED***
            if choice == 2:
                sys.exit(3***REMOVED***
            else:
                return self._ask_default(***REMOVED***
        return None

    def ask_not_null_alteration(self, field_name, model_name***REMOVED***:
        "Changing a NULL field to NOT NULL"
        if not self.dry_run:
            choice = self._choice_input(
                "You are trying to change the nullable field '%s' on %s to non-nullable "
                "without a default; we can't do that (the database needs something to "
                "populate existing rows***REMOVED***.\n"
                "Please select a fix:" % (field_name, model_name***REMOVED***,
                [
                    ("Provide a one-off default now (will be set on all existing "
                     "rows with a null value for this column***REMOVED***"***REMOVED***,
                    ("Ignore for now, and let me handle existing rows with NULL myself "
                     "(e.g. because you added a RunPython or RunSQL operation to handle "
                     "NULL values in a previous data migration***REMOVED***"***REMOVED***,
                    "Quit, and let me add a default in models.py",
                ***REMOVED***
            ***REMOVED***
            if choice == 2:
                return NOT_PROVIDED
            elif choice == 3:
                sys.exit(3***REMOVED***
            else:
                return self._ask_default(***REMOVED***
        return None

    def ask_rename(self, model_name, old_name, new_name, field_instance***REMOVED***:
        "Was this field really renamed?"
        msg = "Did you rename %s.%s to %s.%s (a %s***REMOVED***? [y/N***REMOVED***"
        return self._boolean_input(msg % (model_name, old_name, model_name, new_name,
                                          field_instance.__class__.__name__***REMOVED***, False***REMOVED***

    def ask_rename_model(self, old_model_state, new_model_state***REMOVED***:
        "Was this model really renamed?"
        msg = "Did you rename the %s.%s model to %s? [y/N***REMOVED***"
        return self._boolean_input(msg % (old_model_state.app_label, old_model_state.name,
                                          new_model_state.name***REMOVED***, False***REMOVED***

    def ask_merge(self, app_label***REMOVED***:
        return self._boolean_input(
            "\nMerging will only work if the operations printed above do not conflict\n" +
            "with each other (working on different fields or models***REMOVED***\n" +
            "Do you want to merge these migration branches? [y/N***REMOVED***",
            False,
        ***REMOVED***

    def ask_auto_now_add_addition(self, field_name, model_name***REMOVED***:
        "Adding an auto_now_add field to a model"
        if not self.dry_run:
            choice = self._choice_input(
                "You are trying to add the field '{***REMOVED***' with 'auto_now_add=True' "
                "to {***REMOVED*** without a default; the database needs something to "
                "populate existing rows.\n".format(field_name, model_name***REMOVED***,
                [
                    "Provide a one-off default now (will be set on all "
                    "existing rows***REMOVED***",
                    "Quit, and let me add a default in models.py",
                ***REMOVED***
            ***REMOVED***
            if choice == 2:
                sys.exit(3***REMOVED***
            else:
                return self._ask_default(default='timezone.now'***REMOVED***
        return None


class NonInteractiveMigrationQuestioner(MigrationQuestioner***REMOVED***:

    def ask_not_null_addition(self, field_name, model_name***REMOVED***:
        # We can't ask the user, so act like the user aborted.
        sys.exit(3***REMOVED***

    def ask_not_null_alteration(self, field_name, model_name***REMOVED***:
        # We can't ask the user, so set as not provided.
        return NOT_PROVIDED

    def ask_auto_now_add_addition(self, field_name, model_name***REMOVED***:
        # We can't ask the user, so act like the user aborted.
        sys.exit(3***REMOVED***
