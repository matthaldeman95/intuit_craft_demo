from __future__ import unicode_literals

import collections
import datetime
import decimal
import functools
import math
import types
from importlib import import_module

from django.db import models
from django.db.migrations.operations.base import Operation
from django.db.migrations.utils import COMPILED_REGEX_TYPE, RegexObject
from django.utils import datetime_safe, six
from django.utils.encoding import force_text
from django.utils.functional import LazyObject, Promise
from django.utils.timezone import utc
from django.utils.version import get_docs_version

***REMOVED***
    import enum
except ImportError:
    # No support on Python 2 if enum34 isn't installed.
    enum = None


class BaseSerializer(object***REMOVED***:
    def __init__(self, value***REMOVED***:
        self.value = value

    def serialize(self***REMOVED***:
        raise NotImplementedError('Subclasses of BaseSerializer must implement the serialize(***REMOVED*** method.'***REMOVED***


class BaseSequenceSerializer(BaseSerializer***REMOVED***:
    def _format(self***REMOVED***:
        raise NotImplementedError('Subclasses of BaseSequenceSerializer must implement the _format(***REMOVED*** method.'***REMOVED***

    def serialize(self***REMOVED***:
        imports = set(***REMOVED***
        strings = [***REMOVED***
        for item in self.value:
            item_string, item_imports = serializer_factory(item***REMOVED***.serialize(***REMOVED***
            imports.update(item_imports***REMOVED***
            strings.append(item_string***REMOVED***
        value = self._format(***REMOVED***
        return value % (", ".join(strings***REMOVED******REMOVED***, imports


class BaseSimpleSerializer(BaseSerializer***REMOVED***:
    def serialize(self***REMOVED***:
        return repr(self.value***REMOVED***, set(***REMOVED***


class ByteTypeSerializer(BaseSerializer***REMOVED***:
    def serialize(self***REMOVED***:
        value_repr = repr(self.value***REMOVED***
        if six.PY2:
            # Prepend the `b` prefix since we're importing unicode_literals
            value_repr = 'b' + value_repr
        return value_repr, set(***REMOVED***


class DatetimeSerializer(BaseSerializer***REMOVED***:
    def serialize(self***REMOVED***:
        if self.value.tzinfo is not None and self.value.tzinfo != utc:
            self.value = self.value.astimezone(utc***REMOVED***
        value_repr = repr(self.value***REMOVED***.replace("<UTC>", "utc"***REMOVED***
        if isinstance(self.value, datetime_safe.datetime***REMOVED***:
            value_repr = "datetime.%s" % value_repr
        imports = ["import datetime"***REMOVED***
        if self.value.tzinfo is not None:
            imports.append("from django.utils.timezone import utc"***REMOVED***
        return value_repr, set(imports***REMOVED***


class DateSerializer(BaseSerializer***REMOVED***:
    def serialize(self***REMOVED***:
        value_repr = repr(self.value***REMOVED***
        if isinstance(self.value, datetime_safe.date***REMOVED***:
            value_repr = "datetime.%s" % value_repr
        return value_repr, {"import datetime"***REMOVED***


class DecimalSerializer(BaseSerializer***REMOVED***:
    def serialize(self***REMOVED***:
        return repr(self.value***REMOVED***, {"from decimal import Decimal"***REMOVED***


class DeconstructableSerializer(BaseSerializer***REMOVED***:
    @staticmethod
    def serialize_deconstructed(path, args, kwargs***REMOVED***:
        name, imports = DeconstructableSerializer._serialize_path(path***REMOVED***
        strings = [***REMOVED***
        for arg in args:
            arg_string, arg_imports = serializer_factory(arg***REMOVED***.serialize(***REMOVED***
            strings.append(arg_string***REMOVED***
            imports.update(arg_imports***REMOVED***
        for kw, arg in sorted(kwargs.items(***REMOVED******REMOVED***:
            arg_string, arg_imports = serializer_factory(arg***REMOVED***.serialize(***REMOVED***
            imports.update(arg_imports***REMOVED***
            strings.append("%s=%s" % (kw, arg_string***REMOVED******REMOVED***
        return "%s(%s***REMOVED***" % (name, ", ".join(strings***REMOVED******REMOVED***, imports

    @staticmethod
    def _serialize_path(path***REMOVED***:
        module, name = path.rsplit(".", 1***REMOVED***
        if module == "django.db.models":
            imports = {"from django.db import models"***REMOVED***
            name = "models.%s" % name
        else:
            imports = {"import %s" % module***REMOVED***
            name = path
        return name, imports

    def serialize(self***REMOVED***:
        return self.serialize_deconstructed(*self.value.deconstruct(***REMOVED******REMOVED***


class DictionarySerializer(BaseSerializer***REMOVED***:
    def serialize(self***REMOVED***:
        imports = set(***REMOVED***
        strings = [***REMOVED***
        for k, v in sorted(self.value.items(***REMOVED******REMOVED***:
            k_string, k_imports = serializer_factory(k***REMOVED***.serialize(***REMOVED***
            v_string, v_imports = serializer_factory(v***REMOVED***.serialize(***REMOVED***
            imports.update(k_imports***REMOVED***
            imports.update(v_imports***REMOVED***
            strings.append((k_string, v_string***REMOVED******REMOVED***
        return "{%s***REMOVED***" % (", ".join("%s: %s" % (k, v***REMOVED*** for k, v in strings***REMOVED******REMOVED***, imports


class EnumSerializer(BaseSerializer***REMOVED***:
    def serialize(self***REMOVED***:
        enum_class = self.value.__class__
        module = enum_class.__module__
        imports = {"import %s" % module***REMOVED***
        v_string, v_imports = serializer_factory(self.value.value***REMOVED***.serialize(***REMOVED***
        imports.update(v_imports***REMOVED***
        return "%s.%s(%s***REMOVED***" % (module, enum_class.__name__, v_string***REMOVED***, imports


class FloatSerializer(BaseSimpleSerializer***REMOVED***:
    def serialize(self***REMOVED***:
        if math.isnan(self.value***REMOVED*** or math.isinf(self.value***REMOVED***:
            return 'float("{***REMOVED***"***REMOVED***'.format(self.value***REMOVED***, set(***REMOVED***
        return super(FloatSerializer, self***REMOVED***.serialize(***REMOVED***


class FrozensetSerializer(BaseSequenceSerializer***REMOVED***:
    def _format(self***REMOVED***:
        return "frozenset([%s***REMOVED******REMOVED***"


class FunctionTypeSerializer(BaseSerializer***REMOVED***:
    def serialize(self***REMOVED***:
        if getattr(self.value, "__self__", None***REMOVED*** and isinstance(self.value.__self__, type***REMOVED***:
            klass = self.value.__self__
            module = klass.__module__
            return "%s.%s.%s" % (module, klass.__name__, self.value.__name__***REMOVED***, {"import %s" % module***REMOVED***
        # Further error checking
        if self.value.__name__ == '<lambda>':
            raise ValueError("Cannot serialize function: lambda"***REMOVED***
        if self.value.__module__ is None:
            raise ValueError("Cannot serialize function %r: No module" % self.value***REMOVED***
        # Python 3 is a lot easier, and only uses this branch if it's not local.
        if getattr(self.value, "__qualname__", None***REMOVED*** and getattr(self.value, "__module__", None***REMOVED***:
            if "<" not in self.value.__qualname__:  # Qualname can include <locals>
                return "%s.%s" % \
                    (self.value.__module__, self.value.__qualname__***REMOVED***, {"import %s" % self.value.__module__***REMOVED***
        # Python 2/fallback version
        module_name = self.value.__module__
        # Make sure it's actually there and not an unbound method
        module = import_module(module_name***REMOVED***
        if not hasattr(module, self.value.__name__***REMOVED***:
            raise ValueError(
                "Could not find function %s in %s.\n"
                "Please note that due to Python 2 limitations, you cannot "
                "serialize unbound method functions (e.g. a method "
                "declared and used in the same class body***REMOVED***. Please move "
                "the function into the main module body to use migrations.\n"
                "For more information, see "
                "https://docs.djangoproject.com/en/%s/topics/migrations/#serializing-values"
                % (self.value.__name__, module_name, get_docs_version(***REMOVED******REMOVED***
            ***REMOVED***
        # Needed on Python 2 only
        if module_name == '__builtin__':
            return self.value.__name__, set(***REMOVED***
        return "%s.%s" % (module_name, self.value.__name__***REMOVED***, {"import %s" % module_name***REMOVED***


class FunctoolsPartialSerializer(BaseSerializer***REMOVED***:
    def serialize(self***REMOVED***:
        imports = {'import functools'***REMOVED***
        # Serialize functools.partial(***REMOVED*** arguments
        func_string, func_imports = serializer_factory(self.value.func***REMOVED***.serialize(***REMOVED***
        args_string, args_imports = serializer_factory(self.value.args***REMOVED***.serialize(***REMOVED***
        keywords_string, keywords_imports = serializer_factory(self.value.keywords***REMOVED***.serialize(***REMOVED***
        # Add any imports needed by arguments
        imports.update(func_imports***REMOVED***
        imports.update(args_imports***REMOVED***
        imports.update(keywords_imports***REMOVED***
        return (
            "functools.partial(%s, *%s, **%s***REMOVED***" % (
                func_string, args_string, keywords_string,
            ***REMOVED***,
            imports,
        ***REMOVED***


class IterableSerializer(BaseSerializer***REMOVED***:
    def serialize(self***REMOVED***:
        imports = set(***REMOVED***
        strings = [***REMOVED***
        for item in self.value:
            item_string, item_imports = serializer_factory(item***REMOVED***.serialize(***REMOVED***
            imports.update(item_imports***REMOVED***
            strings.append(item_string***REMOVED***
        # When len(strings***REMOVED***==0, the empty iterable should be serialized as
        # "(***REMOVED***", not "(,***REMOVED***" because (,***REMOVED*** is invalid Python syntax.
        value = "(%s***REMOVED***" if len(strings***REMOVED*** != 1 else "(%s,***REMOVED***"
        return value % (", ".join(strings***REMOVED******REMOVED***, imports


class ModelFieldSerializer(DeconstructableSerializer***REMOVED***:
    def serialize(self***REMOVED***:
        attr_name, path, args, kwargs = self.value.deconstruct(***REMOVED***
        return self.serialize_deconstructed(path, args, kwargs***REMOVED***


class ModelManagerSerializer(DeconstructableSerializer***REMOVED***:
    def serialize(self***REMOVED***:
        as_manager, manager_path, qs_path, args, kwargs = self.value.deconstruct(***REMOVED***
        if as_manager:
            name, imports = self._serialize_path(qs_path***REMOVED***
            return "%s.as_manager(***REMOVED***" % name, imports
        else:
            return self.serialize_deconstructed(manager_path, args, kwargs***REMOVED***


class OperationSerializer(BaseSerializer***REMOVED***:
    def serialize(self***REMOVED***:
        from django.db.migrations.writer import OperationWriter
        string, imports = OperationWriter(self.value, indentation=0***REMOVED***.serialize(***REMOVED***
        # Nested operation, trailing comma is handled in upper OperationWriter._write(***REMOVED***
        return string.rstrip(','***REMOVED***, imports


class RegexSerializer(BaseSerializer***REMOVED***:
    def serialize(self***REMOVED***:
        imports = {"import re"***REMOVED***
        regex_pattern, pattern_imports = serializer_factory(self.value.pattern***REMOVED***.serialize(***REMOVED***
        regex_flags, flag_imports = serializer_factory(self.value.flags***REMOVED***.serialize(***REMOVED***
        imports.update(pattern_imports***REMOVED***
        imports.update(flag_imports***REMOVED***
        args = [regex_pattern***REMOVED***
        if self.value.flags:
            args.append(regex_flags***REMOVED***
        return "re.compile(%s***REMOVED***" % ', '.join(args***REMOVED***, imports


class SequenceSerializer(BaseSequenceSerializer***REMOVED***:
    def _format(self***REMOVED***:
        return "[%s***REMOVED***"


class SetSerializer(BaseSequenceSerializer***REMOVED***:
    def _format(self***REMOVED***:
        # Don't use the literal "{%s***REMOVED***" as it doesn't support empty set
        return "set([%s***REMOVED******REMOVED***"


class SettingsReferenceSerializer(BaseSerializer***REMOVED***:
    def serialize(self***REMOVED***:
        return "settings.%s" % self.value.setting_name, {"from django.conf import settings"***REMOVED***


class TextTypeSerializer(BaseSerializer***REMOVED***:
    def serialize(self***REMOVED***:
        value_repr = repr(self.value***REMOVED***
        if six.PY2:
            # Strip the `u` prefix since we're importing unicode_literals
            value_repr = value_repr[1:***REMOVED***
        return value_repr, set(***REMOVED***


class TimedeltaSerializer(BaseSerializer***REMOVED***:
    def serialize(self***REMOVED***:
        return repr(self.value***REMOVED***, {"import datetime"***REMOVED***


class TimeSerializer(BaseSerializer***REMOVED***:
    def serialize(self***REMOVED***:
        value_repr = repr(self.value***REMOVED***
        if isinstance(self.value, datetime_safe.time***REMOVED***:
            value_repr = "datetime.%s" % value_repr
        return value_repr, {"import datetime"***REMOVED***


class TupleSerializer(BaseSequenceSerializer***REMOVED***:
    def _format(self***REMOVED***:
        # When len(value***REMOVED***==0, the empty tuple should be serialized as "(***REMOVED***",
        # not "(,***REMOVED***" because (,***REMOVED*** is invalid Python syntax.
        return "(%s***REMOVED***" if len(self.value***REMOVED*** != 1 else "(%s,***REMOVED***"


class TypeSerializer(BaseSerializer***REMOVED***:
    def serialize(self***REMOVED***:
        special_cases = [
            (models.Model, "models.Model", [***REMOVED******REMOVED***,
        ***REMOVED***
        for case, string, imports in special_cases:
            if case is self.value:
                return string, set(imports***REMOVED***
        if hasattr(self.value, "__module__"***REMOVED***:
            module = self.value.__module__
            if module == six.moves.builtins.__name__:
                return self.value.__name__, set(***REMOVED***
            else:
                return "%s.%s" % (module, self.value.__name__***REMOVED***, {"import %s" % module***REMOVED***


def serializer_factory(value***REMOVED***:
    from django.db.migrations.writer import SettingsReference
    if isinstance(value, Promise***REMOVED***:
        value = force_text(value***REMOVED***
    elif isinstance(value, LazyObject***REMOVED***:
        # The unwrapped value is returned as the first item of the arguments
        # tuple.
        value = value.__reduce__(***REMOVED***[1***REMOVED***[0***REMOVED***

    if isinstance(value, models.Field***REMOVED***:
        return ModelFieldSerializer(value***REMOVED***
    if isinstance(value, models.manager.BaseManager***REMOVED***:
        return ModelManagerSerializer(value***REMOVED***
    if isinstance(value, Operation***REMOVED***:
        return OperationSerializer(value***REMOVED***
    if isinstance(value, type***REMOVED***:
        return TypeSerializer(value***REMOVED***
    # Anything that knows how to deconstruct itself.
    if hasattr(value, 'deconstruct'***REMOVED***:
        return DeconstructableSerializer(value***REMOVED***

    # Unfortunately some of these are order-dependent.
    if isinstance(value, frozenset***REMOVED***:
        return FrozensetSerializer(value***REMOVED***
    if isinstance(value, list***REMOVED***:
        return SequenceSerializer(value***REMOVED***
    if isinstance(value, set***REMOVED***:
        return SetSerializer(value***REMOVED***
    if isinstance(value, tuple***REMOVED***:
        return TupleSerializer(value***REMOVED***
    if isinstance(value, dict***REMOVED***:
        return DictionarySerializer(value***REMOVED***
    if enum and isinstance(value, enum.Enum***REMOVED***:
        return EnumSerializer(value***REMOVED***
    if isinstance(value, datetime.datetime***REMOVED***:
        return DatetimeSerializer(value***REMOVED***
    if isinstance(value, datetime.date***REMOVED***:
        return DateSerializer(value***REMOVED***
    if isinstance(value, datetime.time***REMOVED***:
        return TimeSerializer(value***REMOVED***
    if isinstance(value, datetime.timedelta***REMOVED***:
        return TimedeltaSerializer(value***REMOVED***
    if isinstance(value, SettingsReference***REMOVED***:
        return SettingsReferenceSerializer(value***REMOVED***
    if isinstance(value, float***REMOVED***:
        return FloatSerializer(value***REMOVED***
    if isinstance(value, six.integer_types + (bool, type(None***REMOVED******REMOVED******REMOVED***:
        return BaseSimpleSerializer(value***REMOVED***
    if isinstance(value, six.binary_type***REMOVED***:
        return ByteTypeSerializer(value***REMOVED***
    if isinstance(value, six.text_type***REMOVED***:
        return TextTypeSerializer(value***REMOVED***
    if isinstance(value, decimal.Decimal***REMOVED***:
        return DecimalSerializer(value***REMOVED***
    if isinstance(value, functools.partial***REMOVED***:
        return FunctoolsPartialSerializer(value***REMOVED***
    if isinstance(value, (types.FunctionType, types.BuiltinFunctionType***REMOVED******REMOVED***:
        return FunctionTypeSerializer(value***REMOVED***
    if isinstance(value, collections.Iterable***REMOVED***:
        return IterableSerializer(value***REMOVED***
    if isinstance(value, (COMPILED_REGEX_TYPE, RegexObject***REMOVED******REMOVED***:
        return RegexSerializer(value***REMOVED***
    raise ValueError(
        "Cannot serialize: %r\nThere are some values Django cannot serialize into "
        "migration files.\nFor more, see https://docs.djangoproject.com/en/%s/"
        "topics/migrations/#migration-serializing" % (value, get_docs_version(***REMOVED******REMOVED***
    ***REMOVED***
