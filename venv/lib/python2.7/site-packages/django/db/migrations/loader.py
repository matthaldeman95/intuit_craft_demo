from __future__ import unicode_literals

***REMOVED***
import sys
from importlib import import_module

from django.apps import apps
from django.conf import settings
from django.db.migrations.graph import MigrationGraph
from django.db.migrations.recorder import MigrationRecorder
from django.utils import six

from .exceptions import (
    AmbiguityError, BadMigrationError, InconsistentMigrationHistory,
    NodeNotFoundError,
***REMOVED***

MIGRATIONS_MODULE_NAME = 'migrations'


class MigrationLoader(object***REMOVED***:
    ***REMOVED***
    Loads migration files from disk, and their status from the database.

    Migration files are expected to live in the "migrations" directory of
    an app. Their names are entirely unimportant from a code perspective,
    but will probably follow the 1234_name.py convention.

    On initialization, this class will scan those directories, and open and
    read the python files, looking for a class called Migration, which should
    inherit from django.db.migrations.Migration. See
    django.db.migrations.migration for what that looks like.

    Some migrations will be marked as "replacing" another set of migrations.
    These are loaded into a separate set of migrations away from the main ones.
    If all the migrations they replace are either unapplied or missing from
    disk, then they are injected into the main set, replacing the named migrations.
    Any dependency pointers to the replaced migrations are re-pointed to the
    new migration.

    This does mean that this class MUST also talk to the database as well as
    to disk, but this is probably fine. We're already not just operating
    in memory.
    ***REMOVED***

    def __init__(self, connection, load=True, ignore_no_migrations=False***REMOVED***:
        self.connection = connection
        self.disk_migrations = None
        self.applied_migrations = None
        self.ignore_no_migrations = ignore_no_migrations
        if load:
            self.build_graph(***REMOVED***

    @classmethod
    def migrations_module(cls, app_label***REMOVED***:
        if app_label in settings.MIGRATION_MODULES:
            return settings.MIGRATION_MODULES[app_label***REMOVED***
        else:
            app_package_name = apps.get_app_config(app_label***REMOVED***.name
            return '%s.%s' % (app_package_name, MIGRATIONS_MODULE_NAME***REMOVED***

    def load_disk(self***REMOVED***:
        ***REMOVED***
        Loads the migrations from all INSTALLED_APPS from disk.
        ***REMOVED***
        self.disk_migrations = {***REMOVED***
        self.unmigrated_apps = set(***REMOVED***
        self.migrated_apps = set(***REMOVED***
        for app_config in apps.get_app_configs(***REMOVED***:
            # Get the migrations module directory
            module_name = self.migrations_module(app_config.label***REMOVED***
            if module_name is None:
                self.unmigrated_apps.add(app_config.label***REMOVED***
                continue
            was_loaded = module_name in sys.modules
            ***REMOVED***
                module = import_module(module_name***REMOVED***
            except ImportError as e:
                # I hate doing this, but I don't want to squash other import errors.
                # Might be better to try a directory check directly.
                if "No module named" in str(e***REMOVED*** and MIGRATIONS_MODULE_NAME in str(e***REMOVED***:
                    self.unmigrated_apps.add(app_config.label***REMOVED***
                    continue
                raise
            else:
                # PY3 will happily import empty dirs as namespaces.
                if not hasattr(module, '__file__'***REMOVED***:
                    self.unmigrated_apps.add(app_config.label***REMOVED***
                    continue
                # Module is not a package (e.g. migrations.py***REMOVED***.
                if not hasattr(module, '__path__'***REMOVED***:
                    self.unmigrated_apps.add(app_config.label***REMOVED***
                    continue
                # Force a reload if it's already loaded (tests need this***REMOVED***
                if was_loaded:
                    six.moves.reload_module(module***REMOVED***
            self.migrated_apps.add(app_config.label***REMOVED***
            directory = os.path.dirname(module.__file__***REMOVED***
            # Scan for .py files
            migration_names = set(***REMOVED***
            for name in os.listdir(directory***REMOVED***:
                if name.endswith(".py"***REMOVED***:
                    import_name = name.rsplit(".", 1***REMOVED***[0***REMOVED***
                    if import_name[0***REMOVED*** not in "_.~":
                        migration_names.add(import_name***REMOVED***
            # Load them
            for migration_name in migration_names:
                migration_module = import_module("%s.%s" % (module_name, migration_name***REMOVED******REMOVED***
                if not hasattr(migration_module, "Migration"***REMOVED***:
                    raise BadMigrationError(
                        "Migration %s in app %s has no Migration class" % (migration_name, app_config.label***REMOVED***
                    ***REMOVED***
                self.disk_migrations[app_config.label, migration_name***REMOVED*** = migration_module.Migration(
                    migration_name,
                    app_config.label,
                ***REMOVED***

    def get_migration(self, app_label, name_prefix***REMOVED***:
        "Gets the migration exactly named, or raises `graph.NodeNotFoundError`"
        return self.graph.nodes[app_label, name_prefix***REMOVED***

    def get_migration_by_prefix(self, app_label, name_prefix***REMOVED***:
        "Returns the migration(s***REMOVED*** which match the given app label and name _prefix_"
        # Do the search
        results = [***REMOVED***
        for l, n in self.disk_migrations:
            if l == app_label and n.startswith(name_prefix***REMOVED***:
                results.append((l, n***REMOVED******REMOVED***
        if len(results***REMOVED*** > 1:
            raise AmbiguityError(
                "There is more than one migration for '%s' with the prefix '%s'" % (app_label, name_prefix***REMOVED***
            ***REMOVED***
        elif len(results***REMOVED*** == 0:
            raise KeyError("There no migrations for '%s' with the prefix '%s'" % (app_label, name_prefix***REMOVED******REMOVED***
        else:
            return self.disk_migrations[results[0***REMOVED******REMOVED***

    def check_key(self, key, current_app***REMOVED***:
        if (key[1***REMOVED*** != "__first__" and key[1***REMOVED*** != "__latest__"***REMOVED*** or key in self.graph:
            return key
        # Special-case __first__, which means "the first migration" for
        # migrated apps, and is ignored for unmigrated apps. It allows
        # makemigrations to declare dependencies on apps before they even have
        # migrations.
        if key[0***REMOVED*** == current_app:
            # Ignore __first__ references to the same app (#22325***REMOVED***
            return
        if key[0***REMOVED*** in self.unmigrated_apps:
            # This app isn't migrated, but something depends on it.
            # The models will get auto-added into the state, though
            # so we're fine.
            return
        if key[0***REMOVED*** in self.migrated_apps:
            ***REMOVED***
                if key[1***REMOVED*** == "__first__":
                    return list(self.graph.root_nodes(key[0***REMOVED******REMOVED******REMOVED***[0***REMOVED***
                else:  # "__latest__"
                    return list(self.graph.leaf_nodes(key[0***REMOVED******REMOVED******REMOVED***[0***REMOVED***
            except IndexError:
                if self.ignore_no_migrations:
                    return None
                else:
                    raise ValueError("Dependency on app with no migrations: %s" % key[0***REMOVED******REMOVED***
        raise ValueError("Dependency on unknown app: %s" % key[0***REMOVED******REMOVED***

    def add_internal_dependencies(self, key, migration***REMOVED***:
        ***REMOVED***
        Internal dependencies need to be added first to ensure `__first__`
        dependencies find the correct root node.
        ***REMOVED***
        for parent in migration.dependencies:
            if parent[0***REMOVED*** != key[0***REMOVED*** or parent[1***REMOVED*** == '__first__':
                # Ignore __first__ references to the same app (#22325***REMOVED***.
                continue
            self.graph.add_dependency(migration, key, parent, skip_validation=True***REMOVED***

    def add_external_dependencies(self, key, migration***REMOVED***:
        for parent in migration.dependencies:
            # Skip internal dependencies
            if key[0***REMOVED*** == parent[0***REMOVED***:
                continue
            parent = self.check_key(parent, key[0***REMOVED******REMOVED***
            if parent is not None:
                self.graph.add_dependency(migration, key, parent, skip_validation=True***REMOVED***
        for child in migration.run_before:
            child = self.check_key(child, key[0***REMOVED******REMOVED***
            if child is not None:
                self.graph.add_dependency(migration, child, key, skip_validation=True***REMOVED***

    def build_graph(self***REMOVED***:
        ***REMOVED***
        Builds a migration dependency graph using both the disk and database.
        You'll need to rebuild the graph if you apply migrations. This isn't
        usually a problem as generally migration stuff runs in a one-shot process.
        ***REMOVED***
        # Load disk data
        self.load_disk(***REMOVED***
        # Load database data
        if self.connection is None:
            self.applied_migrations = set(***REMOVED***
        else:
            recorder = MigrationRecorder(self.connection***REMOVED***
            self.applied_migrations = recorder.applied_migrations(***REMOVED***
        # To start, populate the migration graph with nodes for ALL migrations
        # and their dependencies. Also make note of replacing migrations at this step.
        self.graph = MigrationGraph(***REMOVED***
        self.replacements = {***REMOVED***
        for key, migration in self.disk_migrations.items(***REMOVED***:
            self.graph.add_node(key, migration***REMOVED***
            # Internal (aka same-app***REMOVED*** dependencies.
            self.add_internal_dependencies(key, migration***REMOVED***
            # Replacing migrations.
            if migration.replaces:
                self.replacements[key***REMOVED*** = migration
        # Add external dependencies now that the internal ones have been resolved.
        for key, migration in self.disk_migrations.items(***REMOVED***:
            self.add_external_dependencies(key, migration***REMOVED***
        # Carry out replacements where possible.
        for key, migration in self.replacements.items(***REMOVED***:
            # Get applied status of each of this migration's replacement targets.
            applied_statuses = [(target in self.applied_migrations***REMOVED*** for target in migration.replaces***REMOVED***
            # Ensure the replacing migration is only marked as applied if all of
            # its replacement targets are.
            if all(applied_statuses***REMOVED***:
                self.applied_migrations.add(key***REMOVED***
            else:
                self.applied_migrations.discard(key***REMOVED***
            # A replacing migration can be used if either all or none of its
            # replacement targets have been applied.
            if all(applied_statuses***REMOVED*** or (not any(applied_statuses***REMOVED******REMOVED***:
                self.graph.remove_replaced_nodes(key, migration.replaces***REMOVED***
            else:
                # This replacing migration cannot be used because it is partially applied.
                # Remove it from the graph and remap dependencies to it (#25945***REMOVED***.
                self.graph.remove_replacement_node(key, migration.replaces***REMOVED***
        # Ensure the graph is consistent.
        ***REMOVED***
            self.graph.validate_consistency(***REMOVED***
        except NodeNotFoundError as exc:
            # Check if the missing node could have been replaced by any squash
            # migration but wasn't because the squash migration was partially
            # applied before. In that case raise a more understandable exception
            # (#23556***REMOVED***.
            # Get reverse replacements.
            reverse_replacements = {***REMOVED***
            for key, migration in self.replacements.items(***REMOVED***:
                for replaced in migration.replaces:
                    reverse_replacements.setdefault(replaced, set(***REMOVED******REMOVED***.add(key***REMOVED***
            # Try to reraise exception with more detail.
            if exc.node in reverse_replacements:
                candidates = reverse_replacements.get(exc.node, set(***REMOVED******REMOVED***
                is_replaced = any(candidate in self.graph.nodes for candidate in candidates***REMOVED***
                if not is_replaced:
                    tries = ', '.join('%s.%s' % c for c in candidates***REMOVED***
                    exc_value = NodeNotFoundError(
                        "Migration {0***REMOVED*** depends on nonexistent node ('{1***REMOVED***', '{2***REMOVED***'***REMOVED***. "
                        "Django tried to replace migration {1***REMOVED***.{2***REMOVED*** with any of [{3***REMOVED******REMOVED*** "
                        "but wasn't able to because some of the replaced migrations "
                        "are already applied.".format(
                            exc.origin, exc.node[0***REMOVED***, exc.node[1***REMOVED***, tries
                        ***REMOVED***,
                        exc.node
                    ***REMOVED***
                    exc_value.__cause__ = exc
                    if not hasattr(exc, '__traceback__'***REMOVED***:
                        exc.__traceback__ = sys.exc_info(***REMOVED***[2***REMOVED***
                    six.reraise(NodeNotFoundError, exc_value, sys.exc_info(***REMOVED***[2***REMOVED******REMOVED***
            raise exc

    def check_consistent_history(self, connection***REMOVED***:
        ***REMOVED***
        Raise InconsistentMigrationHistory if any applied migrations have
        unapplied dependencies.
        ***REMOVED***
        recorder = MigrationRecorder(connection***REMOVED***
        applied = recorder.applied_migrations(***REMOVED***
        for migration in applied:
            # If the migration is unknown, skip it.
            if migration not in self.graph.nodes:
                continue
            for parent in self.graph.node_map[migration***REMOVED***.parents:
                if parent not in applied:
                    # Skip unapplied squashed migrations that have all of their
                    # `replaces` applied.
                    if parent in self.replacements:
                        if all(m in applied for m in self.replacements[parent***REMOVED***.replaces***REMOVED***:
                            continue
                    raise InconsistentMigrationHistory(
                        "Migration {***REMOVED***.{***REMOVED*** is applied before its dependency "
                        "{***REMOVED***.{***REMOVED*** on database '{***REMOVED***'.".format(
                            migration[0***REMOVED***, migration[1***REMOVED***, parent[0***REMOVED***, parent[1***REMOVED***,
                            connection.alias,
                        ***REMOVED***
                    ***REMOVED***

    def detect_conflicts(self***REMOVED***:
        ***REMOVED***
        Looks through the loaded graph and detects any conflicts - apps
        with more than one leaf migration. Returns a dict of the app labels
        that conflict with the migration names that conflict.
        ***REMOVED***
        seen_apps = {***REMOVED***
        conflicting_apps = set(***REMOVED***
        for app_label, migration_name in self.graph.leaf_nodes(***REMOVED***:
            if app_label in seen_apps:
                conflicting_apps.add(app_label***REMOVED***
            seen_apps.setdefault(app_label, set(***REMOVED******REMOVED***.add(migration_name***REMOVED***
        return {app_label: seen_apps[app_label***REMOVED*** for app_label in conflicting_apps***REMOVED***

    def project_state(self, nodes=None, at_end=True***REMOVED***:
        ***REMOVED***
        Returns a ProjectState object representing the most recent state
        that the migrations we loaded represent.

        See graph.make_state for the meaning of "nodes" and "at_end"
        ***REMOVED***
        return self.graph.make_state(nodes=nodes, at_end=at_end, real_apps=list(self.unmigrated_apps***REMOVED******REMOVED***
