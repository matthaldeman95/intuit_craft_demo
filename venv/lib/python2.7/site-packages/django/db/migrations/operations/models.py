from __future__ import unicode_literals

from django.db import models
from django.db.migrations.operations.base import Operation
from django.db.migrations.state import ModelState
from django.db.models.options import normalize_together
from django.utils import six
from django.utils.functional import cached_property

from .fields import (
    AddField, AlterField, FieldOperation, RemoveField, RenameField,
***REMOVED***


def _check_for_duplicates(arg_name, objs***REMOVED***:
    used_vals = set(***REMOVED***
    for val in objs:
        if val in used_vals:
            raise ValueError(
                "Found duplicate value %s in CreateModel %s argument." % (val, arg_name***REMOVED***
            ***REMOVED***
        used_vals.add(val***REMOVED***


class ModelOperation(Operation***REMOVED***:
    def __init__(self, name***REMOVED***:
        self.name = name

    @cached_property
    def name_lower(self***REMOVED***:
        return self.name.lower(***REMOVED***

    def references_model(self, name, app_label=None***REMOVED***:
        return name.lower(***REMOVED*** == self.name_lower

    def reduce(self, operation, in_between, app_label=None***REMOVED***:
        return (
            super(ModelOperation, self***REMOVED***.reduce(operation, in_between, app_label=app_label***REMOVED*** or
            not operation.references_model(self.name, app_label***REMOVED***
        ***REMOVED***


class CreateModel(ModelOperation***REMOVED***:
    ***REMOVED***
    Create a model's table.
    ***REMOVED***

    serialization_expand_args = ['fields', 'options', 'managers'***REMOVED***

    def __init__(self, name, fields, options=None, bases=None, managers=None***REMOVED***:
        self.fields = fields
        self.options = options or {***REMOVED***
        self.bases = bases or (models.Model,***REMOVED***
        self.managers = managers or [***REMOVED***
        super(CreateModel, self***REMOVED***.__init__(name***REMOVED***
        # Sanity-check that there are no duplicated field names, bases, or
        # manager names
        _check_for_duplicates('fields', (name for name, _ in self.fields***REMOVED******REMOVED***
        _check_for_duplicates('bases', (
            base._meta.label_lower if hasattr(base, '_meta'***REMOVED*** else
            base.lower(***REMOVED*** if isinstance(base, six.string_types***REMOVED*** else base
            for base in self.bases
        ***REMOVED******REMOVED***
        _check_for_duplicates('managers', (name for name, _ in self.managers***REMOVED******REMOVED***

    def deconstruct(self***REMOVED***:
        kwargs = {
            'name': self.name,
            'fields': self.fields,
    ***REMOVED***
        if self.options:
            kwargs['options'***REMOVED*** = self.options
        if self.bases and self.bases != (models.Model,***REMOVED***:
            kwargs['bases'***REMOVED*** = self.bases
        if self.managers and self.managers != [('objects', models.Manager(***REMOVED******REMOVED******REMOVED***:
            kwargs['managers'***REMOVED*** = self.managers
        return (
            self.__class__.__name__,
            [***REMOVED***,
            kwargs
        ***REMOVED***

    def state_forwards(self, app_label, state***REMOVED***:
        state.add_model(ModelState(
            app_label,
            self.name,
            list(self.fields***REMOVED***,
            dict(self.options***REMOVED***,
            tuple(self.bases***REMOVED***,
            list(self.managers***REMOVED***,
        ***REMOVED******REMOVED***

    def database_forwards(self, app_label, schema_editor, from_state, to_state***REMOVED***:
        model = to_state.apps.get_model(app_label, self.name***REMOVED***
        if self.allow_migrate_model(schema_editor.connection.alias, model***REMOVED***:
            schema_editor.create_model(model***REMOVED***

    def database_backwards(self, app_label, schema_editor, from_state, to_state***REMOVED***:
        model = from_state.apps.get_model(app_label, self.name***REMOVED***
        if self.allow_migrate_model(schema_editor.connection.alias, model***REMOVED***:
            schema_editor.delete_model(model***REMOVED***

    def describe(self***REMOVED***:
        return "Create %smodel %s" % ("proxy " if self.options.get("proxy", False***REMOVED*** else "", self.name***REMOVED***

    def references_model(self, name, app_label=None***REMOVED***:
        strings_to_check = [self.name***REMOVED***
        # Check we didn't inherit from the model
        for base in self.bases:
            if isinstance(base, six.string_types***REMOVED***:
                strings_to_check.append(base.split("."***REMOVED***[-1***REMOVED******REMOVED***
        # Check we have no FKs/M2Ms with it
        for fname, field in self.fields:
            if field.remote_field:
                if isinstance(field.remote_field.model, six.string_types***REMOVED***:
                    strings_to_check.append(field.remote_field.model.split("."***REMOVED***[-1***REMOVED******REMOVED***
        # Now go over all the strings and compare them
        for string in strings_to_check:
            if string.lower(***REMOVED*** == name.lower(***REMOVED***:
                return True
        return False

    def model_to_key(self, model***REMOVED***:
        ***REMOVED***
        Take either a model class or an "app_label.ModelName" string
        and return (app_label, object_name***REMOVED***.
        ***REMOVED***
        if isinstance(model, six.string_types***REMOVED***:
            return model.split(".", 1***REMOVED***
        else:
            return model._meta.app_label, model._meta.object_name

    def reduce(self, operation, in_between, app_label=None***REMOVED***:
        if (isinstance(operation, DeleteModel***REMOVED*** and
                self.name_lower == operation.name_lower and
                not self.options.get("proxy", False***REMOVED******REMOVED***:
            return [***REMOVED***
        elif isinstance(operation, RenameModel***REMOVED*** and self.name_lower == operation.old_name_lower:
            return [
                CreateModel(
                    operation.new_name,
                    fields=self.fields,
                    options=self.options,
                    bases=self.bases,
                    managers=self.managers,
                ***REMOVED***,
            ***REMOVED***
        elif isinstance(operation, FieldOperation***REMOVED*** and self.name_lower == operation.model_name_lower:
            if isinstance(operation, AddField***REMOVED***:
                # Don't allow optimizations of FKs through models they reference
                if hasattr(operation.field, "remote_field"***REMOVED*** and operation.field.remote_field:
                    for between in in_between:
                        # Check that it doesn't point to the model
                        app_label, object_name = self.model_to_key(operation.field.remote_field.model***REMOVED***
                        if between.references_model(object_name, app_label***REMOVED***:
                            return False
                        # Check that it's not through the model
                        if getattr(operation.field.remote_field, "through", None***REMOVED***:
                            app_label, object_name = self.model_to_key(operation.field.remote_field.through***REMOVED***
                            if between.references_model(object_name, app_label***REMOVED***:
                                return False
                return [
                    CreateModel(
                        self.name,
                        fields=self.fields + [(operation.name, operation.field***REMOVED******REMOVED***,
                        options=self.options,
                        bases=self.bases,
                        managers=self.managers,
                    ***REMOVED***,
                ***REMOVED***
            elif isinstance(operation, AlterField***REMOVED***:
                return [
                    CreateModel(
                        self.name,
                        fields=[
                            (n, operation.field if n == operation.name else v***REMOVED***
                            for n, v in self.fields
                        ***REMOVED***,
                        options=self.options,
                        bases=self.bases,
                        managers=self.managers,
                    ***REMOVED***,
                ***REMOVED***
            elif isinstance(operation, RemoveField***REMOVED***:
                return [
                    CreateModel(
                        self.name,
                        fields=[
                            (n, v***REMOVED***
                            for n, v in self.fields
                            if n.lower(***REMOVED*** != operation.name_lower
                        ***REMOVED***,
                        options=self.options,
                        bases=self.bases,
                        managers=self.managers,
                    ***REMOVED***,
                ***REMOVED***
            elif isinstance(operation, RenameField***REMOVED***:
                return [
                    CreateModel(
                        self.name,
                        fields=[
                            (operation.new_name if n == operation.old_name else n, v***REMOVED***
                            for n, v in self.fields
                        ***REMOVED***,
                        options=self.options,
                        bases=self.bases,
                        managers=self.managers,
                    ***REMOVED***,
                ***REMOVED***
        return super(CreateModel, self***REMOVED***.reduce(operation, in_between, app_label=app_label***REMOVED***


class DeleteModel(ModelOperation***REMOVED***:
    ***REMOVED***
    Drops a model's table.
    ***REMOVED***

    def deconstruct(self***REMOVED***:
        kwargs = {
            'name': self.name,
    ***REMOVED***
        return (
            self.__class__.__name__,
            [***REMOVED***,
            kwargs
        ***REMOVED***

    def state_forwards(self, app_label, state***REMOVED***:
        state.remove_model(app_label, self.name_lower***REMOVED***

    def database_forwards(self, app_label, schema_editor, from_state, to_state***REMOVED***:
        model = from_state.apps.get_model(app_label, self.name***REMOVED***
        if self.allow_migrate_model(schema_editor.connection.alias, model***REMOVED***:
            schema_editor.delete_model(model***REMOVED***

    def database_backwards(self, app_label, schema_editor, from_state, to_state***REMOVED***:
        model = to_state.apps.get_model(app_label, self.name***REMOVED***
        if self.allow_migrate_model(schema_editor.connection.alias, model***REMOVED***:
            schema_editor.create_model(model***REMOVED***

    def describe(self***REMOVED***:
        return "Delete model %s" % (self.name, ***REMOVED***


class RenameModel(ModelOperation***REMOVED***:
    ***REMOVED***
    Renames a model.
    ***REMOVED***

    def __init__(self, old_name, new_name***REMOVED***:
        self.old_name = old_name
        self.new_name = new_name
        super(RenameModel, self***REMOVED***.__init__(old_name***REMOVED***

    @cached_property
    def old_name_lower(self***REMOVED***:
        return self.old_name.lower(***REMOVED***

    @cached_property
    def new_name_lower(self***REMOVED***:
        return self.new_name.lower(***REMOVED***

    def deconstruct(self***REMOVED***:
        kwargs = {
            'old_name': self.old_name,
            'new_name': self.new_name,
    ***REMOVED***
        return (
            self.__class__.__name__,
            [***REMOVED***,
            kwargs
        ***REMOVED***

    def state_forwards(self, app_label, state***REMOVED***:
        apps = state.apps
        model = apps.get_model(app_label, self.old_name***REMOVED***
        model._meta.apps = apps
        # Get all of the related objects we need to repoint
        all_related_objects = (
            f for f in model._meta.get_fields(include_hidden=True***REMOVED***
            if f.auto_created and not f.concrete and (not f.hidden or f.many_to_many***REMOVED***
        ***REMOVED***
        # Rename the model
        state.models[app_label, self.new_name_lower***REMOVED*** = state.models[app_label, self.old_name_lower***REMOVED***
        state.models[app_label, self.new_name_lower***REMOVED***.name = self.new_name
        state.remove_model(app_label, self.old_name_lower***REMOVED***
        # Repoint the FKs and M2Ms pointing to us
        for related_object in all_related_objects:
            if related_object.model is not model:
                # The model being renamed does not participate in this relation
                # directly. Rather, a superclass does.
                continue
            # Use the new related key for self referential related objects.
            if related_object.related_model == model:
                related_key = (app_label, self.new_name_lower***REMOVED***
            else:
                related_key = (
                    related_object.related_model._meta.app_label,
                    related_object.related_model._meta.model_name,
                ***REMOVED***
            new_fields = [***REMOVED***
            for name, field in state.models[related_key***REMOVED***.fields:
                if name == related_object.field.name:
                    field = field.clone(***REMOVED***
                    field.remote_field.model = "%s.%s" % (app_label, self.new_name***REMOVED***
                new_fields.append((name, field***REMOVED******REMOVED***
            state.models[related_key***REMOVED***.fields = new_fields
            state.reload_model(*related_key***REMOVED***
        # Repoint M2Ms with through pointing to us
        related_models = {
            f.remote_field.model for f in model._meta.fields
            if getattr(f.remote_field, 'model', None***REMOVED***
    ***REMOVED***
        model_name = '%s.%s' % (app_label, self.old_name***REMOVED***
        for related_model in related_models:
            if related_model == model:
                related_key = (app_label, self.new_name_lower***REMOVED***
            else:
                related_key = (related_model._meta.app_label, related_model._meta.model_name***REMOVED***
            new_fields = [***REMOVED***
            changed = False
            for name, field in state.models[related_key***REMOVED***.fields:
                if field.is_relation and field.many_to_many and field.remote_field.through == model_name:
                    field = field.clone(***REMOVED***
                    field.remote_field.through = '%s.%s' % (app_label, self.new_name***REMOVED***
                    changed = True
                new_fields.append((name, field***REMOVED******REMOVED***
            if changed:
                state.models[related_key***REMOVED***.fields = new_fields
                state.reload_model(*related_key***REMOVED***
        state.reload_model(app_label, self.new_name_lower***REMOVED***

    def database_forwards(self, app_label, schema_editor, from_state, to_state***REMOVED***:
        new_model = to_state.apps.get_model(app_label, self.new_name***REMOVED***
        if self.allow_migrate_model(schema_editor.connection.alias, new_model***REMOVED***:
            old_model = from_state.apps.get_model(app_label, self.old_name***REMOVED***
            # Move the main table
            schema_editor.alter_db_table(
                new_model,
                old_model._meta.db_table,
                new_model._meta.db_table,
            ***REMOVED***
            # Alter the fields pointing to us
            for related_object in old_model._meta.related_objects:
                if related_object.related_model == old_model:
                    model = new_model
                    related_key = (app_label, self.new_name_lower***REMOVED***
                else:
                    model = related_object.related_model
                    related_key = (
                        related_object.related_model._meta.app_label,
                        related_object.related_model._meta.model_name,
                    ***REMOVED***
                to_field = to_state.apps.get_model(
                    *related_key
                ***REMOVED***._meta.get_field(related_object.field.name***REMOVED***
                schema_editor.alter_field(
                    model,
                    related_object.field,
                    to_field,
                ***REMOVED***
            # Rename M2M fields whose name is based on this model's name.
            fields = zip(old_model._meta.local_many_to_many, new_model._meta.local_many_to_many***REMOVED***
            for (old_field, new_field***REMOVED*** in fields:
                # Skip self-referential fields as these are renamed above.
                if new_field.model == new_field.related_model or not new_field.remote_field.through._meta.auto_created:
                    continue
                # Rename the M2M table that's based on this model's name.
                old_m2m_model = old_field.remote_field.through
                new_m2m_model = new_field.remote_field.through
                schema_editor.alter_db_table(
                    new_m2m_model,
                    old_m2m_model._meta.db_table,
                    new_m2m_model._meta.db_table,
                ***REMOVED***
                # Rename the column in the M2M table that's based on this
                # model's name.
                schema_editor.alter_field(
                    new_m2m_model,
                    old_m2m_model._meta.get_field(old_model._meta.model_name***REMOVED***,
                    new_m2m_model._meta.get_field(new_model._meta.model_name***REMOVED***,
                ***REMOVED***

    def database_backwards(self, app_label, schema_editor, from_state, to_state***REMOVED***:
        self.new_name_lower, self.old_name_lower = self.old_name_lower, self.new_name_lower
        self.new_name, self.old_name = self.old_name, self.new_name

        self.database_forwards(app_label, schema_editor, from_state, to_state***REMOVED***

        self.new_name_lower, self.old_name_lower = self.old_name_lower, self.new_name_lower
        self.new_name, self.old_name = self.old_name, self.new_name

    def references_model(self, name, app_label=None***REMOVED***:
        return (
            name.lower(***REMOVED*** == self.old_name_lower or
            name.lower(***REMOVED*** == self.new_name_lower
        ***REMOVED***

    def describe(self***REMOVED***:
        return "Rename model %s to %s" % (self.old_name, self.new_name***REMOVED***

    def reduce(self, operation, in_between, app_label=None***REMOVED***:
        if (isinstance(operation, RenameModel***REMOVED*** and
                self.new_name_lower == operation.old_name_lower***REMOVED***:
            return [
                RenameModel(
                    self.old_name,
                    operation.new_name,
                ***REMOVED***,
            ***REMOVED***
        # Skip `ModelOperation.reduce` as we want to run `references_model`
        # against self.new_name.
        return (
            super(ModelOperation, self***REMOVED***.reduce(operation, in_between, app_label=app_label***REMOVED*** or
            not operation.references_model(self.new_name, app_label***REMOVED***
        ***REMOVED***


class AlterModelTable(ModelOperation***REMOVED***:
    ***REMOVED***
    Renames a model's table
    ***REMOVED***

    def __init__(self, name, table***REMOVED***:
        self.table = table
        super(AlterModelTable, self***REMOVED***.__init__(name***REMOVED***

    def deconstruct(self***REMOVED***:
        kwargs = {
            'name': self.name,
            'table': self.table,
    ***REMOVED***
        return (
            self.__class__.__name__,
            [***REMOVED***,
            kwargs
        ***REMOVED***

    def state_forwards(self, app_label, state***REMOVED***:
        state.models[app_label, self.name_lower***REMOVED***.options["db_table"***REMOVED*** = self.table
        state.reload_model(app_label, self.name_lower***REMOVED***

    def database_forwards(self, app_label, schema_editor, from_state, to_state***REMOVED***:
        new_model = to_state.apps.get_model(app_label, self.name***REMOVED***
        if self.allow_migrate_model(schema_editor.connection.alias, new_model***REMOVED***:
            old_model = from_state.apps.get_model(app_label, self.name***REMOVED***
            schema_editor.alter_db_table(
                new_model,
                old_model._meta.db_table,
                new_model._meta.db_table,
            ***REMOVED***
            # Rename M2M fields whose name is based on this model's db_table
            for (old_field, new_field***REMOVED*** in zip(old_model._meta.local_many_to_many, new_model._meta.local_many_to_many***REMOVED***:
                if new_field.remote_field.through._meta.auto_created:
                    schema_editor.alter_db_table(
                        new_field.remote_field.through,
                        old_field.remote_field.through._meta.db_table,
                        new_field.remote_field.through._meta.db_table,
                    ***REMOVED***

    def database_backwards(self, app_label, schema_editor, from_state, to_state***REMOVED***:
        return self.database_forwards(app_label, schema_editor, from_state, to_state***REMOVED***

    def describe(self***REMOVED***:
        return "Rename table for %s to %s" % (self.name, self.table***REMOVED***

    def reduce(self, operation, in_between, app_label=None***REMOVED***:
        if isinstance(operation, (AlterModelTable, DeleteModel***REMOVED******REMOVED*** and self.name_lower == operation.name_lower:
            return [operation***REMOVED***
        return super(AlterModelTable, self***REMOVED***.reduce(operation, in_between, app_label=app_label***REMOVED***


class ModelOptionOperation(ModelOperation***REMOVED***:
    def reduce(self, operation, in_between, app_label=None***REMOVED***:
        if isinstance(operation, (self.__class__, DeleteModel***REMOVED******REMOVED*** and self.name_lower == operation.name_lower:
            return [operation***REMOVED***
        return super(ModelOptionOperation, self***REMOVED***.reduce(operation, in_between, app_label=app_label***REMOVED***


class FieldRelatedOptionOperation(ModelOptionOperation***REMOVED***:
    def reduce(self, operation, in_between, app_label=None***REMOVED***:
        if (isinstance(operation, FieldOperation***REMOVED*** and
                self.name_lower == operation.model_name_lower and
                not self.references_field(operation.model_name, operation.name***REMOVED******REMOVED***:
            return [operation, self***REMOVED***
        return super(FieldRelatedOptionOperation, self***REMOVED***.reduce(operation, in_between, app_label=app_label***REMOVED***


class AlterUniqueTogether(FieldRelatedOptionOperation***REMOVED***:
    ***REMOVED***
    Changes the value of unique_together to the target one.
    Input value of unique_together must be a set of tuples.
    ***REMOVED***
    option_name = "unique_together"

    def __init__(self, name, unique_together***REMOVED***:
        unique_together = normalize_together(unique_together***REMOVED***
        self.unique_together = set(tuple(cons***REMOVED*** for cons in unique_together***REMOVED***
        super(AlterUniqueTogether, self***REMOVED***.__init__(name***REMOVED***

    def deconstruct(self***REMOVED***:
        kwargs = {
            'name': self.name,
            'unique_together': self.unique_together,
    ***REMOVED***
        return (
            self.__class__.__name__,
            [***REMOVED***,
            kwargs
        ***REMOVED***

    def state_forwards(self, app_label, state***REMOVED***:
        model_state = state.models[app_label, self.name_lower***REMOVED***
        model_state.options[self.option_name***REMOVED*** = self.unique_together
        state.reload_model(app_label, self.name_lower***REMOVED***

    def database_forwards(self, app_label, schema_editor, from_state, to_state***REMOVED***:
        new_model = to_state.apps.get_model(app_label, self.name***REMOVED***
        if self.allow_migrate_model(schema_editor.connection.alias, new_model***REMOVED***:
            old_model = from_state.apps.get_model(app_label, self.name***REMOVED***
            schema_editor.alter_unique_together(
                new_model,
                getattr(old_model._meta, self.option_name, set(***REMOVED******REMOVED***,
                getattr(new_model._meta, self.option_name, set(***REMOVED******REMOVED***,
            ***REMOVED***

    def database_backwards(self, app_label, schema_editor, from_state, to_state***REMOVED***:
        return self.database_forwards(app_label, schema_editor, from_state, to_state***REMOVED***

    def references_field(self, model_name, name, app_label=None***REMOVED***:
        return (
            self.references_model(model_name, app_label***REMOVED*** and
            (
                not self.unique_together or
                any((name in together***REMOVED*** for together in self.unique_together***REMOVED***
            ***REMOVED***
        ***REMOVED***

    def describe(self***REMOVED***:
        return "Alter %s for %s (%s constraint(s***REMOVED******REMOVED***" % (self.option_name, self.name, len(self.unique_together or ''***REMOVED******REMOVED***


class AlterIndexTogether(FieldRelatedOptionOperation***REMOVED***:
    ***REMOVED***
    Changes the value of index_together to the target one.
    Input value of index_together must be a set of tuples.
    ***REMOVED***
    option_name = "index_together"

    def __init__(self, name, index_together***REMOVED***:
        index_together = normalize_together(index_together***REMOVED***
        self.index_together = set(tuple(cons***REMOVED*** for cons in index_together***REMOVED***
        super(AlterIndexTogether, self***REMOVED***.__init__(name***REMOVED***

    def deconstruct(self***REMOVED***:
        kwargs = {
            'name': self.name,
            'index_together': self.index_together,
    ***REMOVED***
        return (
            self.__class__.__name__,
            [***REMOVED***,
            kwargs
        ***REMOVED***

    def state_forwards(self, app_label, state***REMOVED***:
        model_state = state.models[app_label, self.name_lower***REMOVED***
        model_state.options[self.option_name***REMOVED*** = self.index_together
        state.reload_model(app_label, self.name_lower***REMOVED***

    def database_forwards(self, app_label, schema_editor, from_state, to_state***REMOVED***:
        new_model = to_state.apps.get_model(app_label, self.name***REMOVED***
        if self.allow_migrate_model(schema_editor.connection.alias, new_model***REMOVED***:
            old_model = from_state.apps.get_model(app_label, self.name***REMOVED***
            schema_editor.alter_index_together(
                new_model,
                getattr(old_model._meta, self.option_name, set(***REMOVED******REMOVED***,
                getattr(new_model._meta, self.option_name, set(***REMOVED******REMOVED***,
            ***REMOVED***

    def database_backwards(self, app_label, schema_editor, from_state, to_state***REMOVED***:
        return self.database_forwards(app_label, schema_editor, from_state, to_state***REMOVED***

    def references_field(self, model_name, name, app_label=None***REMOVED***:
        return (
            self.references_model(model_name, app_label***REMOVED*** and
            (
                not self.index_together or
                any((name in together***REMOVED*** for together in self.index_together***REMOVED***
            ***REMOVED***
        ***REMOVED***

    def describe(self***REMOVED***:
        return "Alter %s for %s (%s constraint(s***REMOVED******REMOVED***" % (self.option_name, self.name, len(self.index_together or ''***REMOVED******REMOVED***


class AlterOrderWithRespectTo(FieldRelatedOptionOperation***REMOVED***:
    ***REMOVED***
    Represents a change with the order_with_respect_to option.
    ***REMOVED***

    def __init__(self, name, order_with_respect_to***REMOVED***:
        self.order_with_respect_to = order_with_respect_to
        super(AlterOrderWithRespectTo, self***REMOVED***.__init__(name***REMOVED***

    def deconstruct(self***REMOVED***:
        kwargs = {
            'name': self.name,
            'order_with_respect_to': self.order_with_respect_to,
    ***REMOVED***
        return (
            self.__class__.__name__,
            [***REMOVED***,
            kwargs
        ***REMOVED***

    def state_forwards(self, app_label, state***REMOVED***:
        model_state = state.models[app_label, self.name_lower***REMOVED***
        model_state.options['order_with_respect_to'***REMOVED*** = self.order_with_respect_to
        state.reload_model(app_label, self.name_lower***REMOVED***

    def database_forwards(self, app_label, schema_editor, from_state, to_state***REMOVED***:
        to_model = to_state.apps.get_model(app_label, self.name***REMOVED***
        if self.allow_migrate_model(schema_editor.connection.alias, to_model***REMOVED***:
            from_model = from_state.apps.get_model(app_label, self.name***REMOVED***
            # Remove a field if we need to
            if from_model._meta.order_with_respect_to and not to_model._meta.order_with_respect_to:
                schema_editor.remove_field(from_model, from_model._meta.get_field("_order"***REMOVED******REMOVED***
            # Add a field if we need to (altering the column is untouched as
            # it's likely a rename***REMOVED***
            elif to_model._meta.order_with_respect_to and not from_model._meta.order_with_respect_to:
                field = to_model._meta.get_field("_order"***REMOVED***
                if not field.has_default(***REMOVED***:
                    field.default = 0
                schema_editor.add_field(
                    from_model,
                    field,
                ***REMOVED***

    def database_backwards(self, app_label, schema_editor, from_state, to_state***REMOVED***:
        self.database_forwards(app_label, schema_editor, from_state, to_state***REMOVED***

    def references_field(self, model_name, name, app_label=None***REMOVED***:
        return (
            self.references_model(model_name, app_label***REMOVED*** and
            (
                self.order_with_respect_to is None or
                name == self.order_with_respect_to
            ***REMOVED***
        ***REMOVED***

    def describe(self***REMOVED***:
        return "Set order_with_respect_to on %s to %s" % (self.name, self.order_with_respect_to***REMOVED***


class AlterModelOptions(ModelOptionOperation***REMOVED***:
    ***REMOVED***
    Sets new model options that don't directly affect the database schema
    (like verbose_name, permissions, ordering***REMOVED***. Python code in migrations
    may still need them.
    ***REMOVED***

    # Model options we want to compare and preserve in an AlterModelOptions op
    ALTER_OPTION_KEYS = [
        "base_manager_name",
        "default_manager_name",
        "get_latest_by",
        "managed",
        "ordering",
        "permissions",
        "default_permissions",
        "select_on_save",
        "verbose_name",
        "verbose_name_plural",
    ***REMOVED***

    def __init__(self, name, options***REMOVED***:
        self.options = options
        super(AlterModelOptions, self***REMOVED***.__init__(name***REMOVED***

    def deconstruct(self***REMOVED***:
        kwargs = {
            'name': self.name,
            'options': self.options,
    ***REMOVED***
        return (
            self.__class__.__name__,
            [***REMOVED***,
            kwargs
        ***REMOVED***

    def state_forwards(self, app_label, state***REMOVED***:
        model_state = state.models[app_label, self.name_lower***REMOVED***
        model_state.options = dict(model_state.options***REMOVED***
        model_state.options.update(self.options***REMOVED***
        for key in self.ALTER_OPTION_KEYS:
            if key not in self.options and key in model_state.options:
                del model_state.options[key***REMOVED***
        state.reload_model(app_label, self.name_lower***REMOVED***

    def database_forwards(self, app_label, schema_editor, from_state, to_state***REMOVED***:
        pass

    def database_backwards(self, app_label, schema_editor, from_state, to_state***REMOVED***:
        pass

    def describe(self***REMOVED***:
        return "Change Meta options on %s" % (self.name, ***REMOVED***


class AlterModelManagers(ModelOptionOperation***REMOVED***:
    ***REMOVED***
    Alters the model's managers
    ***REMOVED***

    serialization_expand_args = ['managers'***REMOVED***

    def __init__(self, name, managers***REMOVED***:
        self.managers = managers
        super(AlterModelManagers, self***REMOVED***.__init__(name***REMOVED***

    def deconstruct(self***REMOVED***:
        return (
            self.__class__.__name__,
            [self.name, self.managers***REMOVED***,
        ***REMOVED******REMOVED***
        ***REMOVED***

    def state_forwards(self, app_label, state***REMOVED***:
        model_state = state.models[app_label, self.name_lower***REMOVED***
        model_state.managers = list(self.managers***REMOVED***
        state.reload_model(app_label, self.name_lower***REMOVED***

    def database_forwards(self, app_label, schema_editor, from_state, to_state***REMOVED***:
        pass

    def database_backwards(self, app_label, schema_editor, from_state, to_state***REMOVED***:
        pass

    def describe(self***REMOVED***:
        return "Change managers on %s" % (self.name, ***REMOVED***
