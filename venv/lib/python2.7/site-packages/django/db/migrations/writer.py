from __future__ import unicode_literals

***REMOVED***
import re
from importlib import import_module

from django import get_version
from django.apps import apps
from django.db import migrations
from django.db.migrations.loader import MigrationLoader
from django.db.migrations.serializer import serializer_factory
from django.utils._os import upath
from django.utils.encoding import force_text
from django.utils.inspect import get_func_args
from django.utils.module_loading import module_dir
from django.utils.timezone import now

***REMOVED***
    import enum
except ImportError:
    # No support on Python 2 if enum34 isn't installed.
    enum = None


class SettingsReference(str***REMOVED***:
    ***REMOVED***
    Special subclass of string which actually references a current settings
    value. It's treated as the value in memory, but serializes out to a
    settings.NAME attribute reference.
    ***REMOVED***

    def __new__(self, value, setting_name***REMOVED***:
        return str.__new__(self, value***REMOVED***

    def __init__(self, value, setting_name***REMOVED***:
        self.setting_name = setting_name


class OperationWriter(object***REMOVED***:
    def __init__(self, operation, indentation=2***REMOVED***:
        self.operation = operation
        self.buff = [***REMOVED***
        self.indentation = indentation

    def serialize(self***REMOVED***:

        def _write(_arg_name, _arg_value***REMOVED***:
            if (_arg_name in self.operation.serialization_expand_args and
                    isinstance(_arg_value, (list, tuple, dict***REMOVED******REMOVED******REMOVED***:
                if isinstance(_arg_value, dict***REMOVED***:
                    self.feed('%s={' % _arg_name***REMOVED***
                    self.indent(***REMOVED***
                    for key, value in _arg_value.items(***REMOVED***:
                        key_string, key_imports = MigrationWriter.serialize(key***REMOVED***
                        arg_string, arg_imports = MigrationWriter.serialize(value***REMOVED***
                        args = arg_string.splitlines(***REMOVED***
                        if len(args***REMOVED*** > 1:
                            self.feed('%s: %s' % (key_string, args[0***REMOVED******REMOVED******REMOVED***
                            for arg in args[1:-1***REMOVED***:
                                self.feed(arg***REMOVED***
                            self.feed('%s,' % args[-1***REMOVED******REMOVED***
                        else:
                            self.feed('%s: %s,' % (key_string, arg_string***REMOVED******REMOVED***
                        imports.update(key_imports***REMOVED***
                        imports.update(arg_imports***REMOVED***
                    self.unindent(***REMOVED***
                    self.feed('***REMOVED***,'***REMOVED***
                else:
                    self.feed('%s=[' % _arg_name***REMOVED***
                    self.indent(***REMOVED***
                    for item in _arg_value:
                        arg_string, arg_imports = MigrationWriter.serialize(item***REMOVED***
                        args = arg_string.splitlines(***REMOVED***
                        if len(args***REMOVED*** > 1:
                            for arg in args[:-1***REMOVED***:
                                self.feed(arg***REMOVED***
                            self.feed('%s,' % args[-1***REMOVED******REMOVED***
                        else:
                            self.feed('%s,' % arg_string***REMOVED***
                        imports.update(arg_imports***REMOVED***
                    self.unindent(***REMOVED***
                    self.feed('***REMOVED***,'***REMOVED***
            else:
                arg_string, arg_imports = MigrationWriter.serialize(_arg_value***REMOVED***
                args = arg_string.splitlines(***REMOVED***
                if len(args***REMOVED*** > 1:
                    self.feed('%s=%s' % (_arg_name, args[0***REMOVED******REMOVED******REMOVED***
                    for arg in args[1:-1***REMOVED***:
                        self.feed(arg***REMOVED***
                    self.feed('%s,' % args[-1***REMOVED******REMOVED***
                else:
                    self.feed('%s=%s,' % (_arg_name, arg_string***REMOVED******REMOVED***
                imports.update(arg_imports***REMOVED***

        imports = set(***REMOVED***
        name, args, kwargs = self.operation.deconstruct(***REMOVED***
        operation_args = get_func_args(self.operation.__init__***REMOVED***

        # See if this operation is in django.db.migrations. If it is,
        # We can just use the fact we already have that imported,
        # otherwise, we need to add an import for the operation class.
        if getattr(migrations, name, None***REMOVED*** == self.operation.__class__:
            self.feed('migrations.%s(' % name***REMOVED***
        else:
            imports.add('import %s' % (self.operation.__class__.__module__***REMOVED******REMOVED***
            self.feed('%s.%s(' % (self.operation.__class__.__module__, name***REMOVED******REMOVED***

        self.indent(***REMOVED***

        for i, arg in enumerate(args***REMOVED***:
            arg_value = arg
            arg_name = operation_args[i***REMOVED***
            _write(arg_name, arg_value***REMOVED***

        i = len(args***REMOVED***
        # Only iterate over remaining arguments
        for arg_name in operation_args[i:***REMOVED***:
            if arg_name in kwargs:  # Don't sort to maintain signature order
                arg_value = kwargs[arg_name***REMOVED***
                _write(arg_name, arg_value***REMOVED***

        self.unindent(***REMOVED***
        self.feed('***REMOVED***,'***REMOVED***
        return self.render(***REMOVED***, imports

    def indent(self***REMOVED***:
        self.indentation += 1

    def unindent(self***REMOVED***:
        self.indentation -= 1

    def feed(self, line***REMOVED***:
        self.buff.append(' ' * (self.indentation * 4***REMOVED*** + line***REMOVED***

    def render(self***REMOVED***:
        return '\n'.join(self.buff***REMOVED***


class MigrationWriter(object***REMOVED***:
    ***REMOVED***
    Takes a Migration instance and is able to produce the contents
    of the migration file from it.
    ***REMOVED***

    def __init__(self, migration***REMOVED***:
        self.migration = migration
        self.needs_manual_porting = False

    def as_string(self***REMOVED***:
        ***REMOVED***
        Returns a string of the file contents.
        ***REMOVED***
        items = {
            "replaces_str": "",
            "initial_str": "",
    ***REMOVED***

        imports = set(***REMOVED***

        # Deconstruct operations
        operations = [***REMOVED***
        for operation in self.migration.operations:
            operation_string, operation_imports = OperationWriter(operation***REMOVED***.serialize(***REMOVED***
            imports.update(operation_imports***REMOVED***
            operations.append(operation_string***REMOVED***
        items["operations"***REMOVED*** = "\n".join(operations***REMOVED*** + "\n" if operations else ""

        # Format dependencies and write out swappable dependencies right
        dependencies = [***REMOVED***
        for dependency in self.migration.dependencies:
            if dependency[0***REMOVED*** == "__setting__":
                dependencies.append("        migrations.swappable_dependency(settings.%s***REMOVED***," % dependency[1***REMOVED******REMOVED***
                imports.add("from django.conf import settings"***REMOVED***
            else:
                # No need to output bytestrings for dependencies
                dependency = tuple(force_text(s***REMOVED*** for s in dependency***REMOVED***
                dependencies.append("        %s," % self.serialize(dependency***REMOVED***[0***REMOVED******REMOVED***
        items["dependencies"***REMOVED*** = "\n".join(dependencies***REMOVED*** + "\n" if dependencies else ""

        # Format imports nicely, swapping imports of functions from migration files
        # for comments
        migration_imports = set(***REMOVED***
        for line in list(imports***REMOVED***:
            if re.match("^import (.****REMOVED***\.\d+[^\s***REMOVED****$", line***REMOVED***:
                migration_imports.add(line.split("import"***REMOVED***[1***REMOVED***.strip(***REMOVED******REMOVED***
                imports.remove(line***REMOVED***
                self.needs_manual_porting = True

        # django.db.migrations is always used, but models import may not be.
        # If models import exists, merge it with migrations import.
        if "from django.db import models" in imports:
            imports.discard("from django.db import models"***REMOVED***
            imports.add("from django.db import migrations, models"***REMOVED***
        else:
            imports.add("from django.db import migrations"***REMOVED***

        # Sort imports by the package / module to be imported (the part after
        # "from" in "from ... import ..." or after "import" in "import ..."***REMOVED***.
        sorted_imports = sorted(imports, key=lambda i: i.split(***REMOVED***[1***REMOVED******REMOVED***
        items["imports"***REMOVED*** = "\n".join(sorted_imports***REMOVED*** + "\n" if imports else ""
        if migration_imports:
            items["imports"***REMOVED*** += (
                "\n\n# Functions from the following migrations need manual "
                "copying.\n# Move them and any dependencies into this file, "
                "then update the\n# RunPython operations to refer to the local "
                "versions:\n# %s"
            ***REMOVED*** % "\n# ".join(sorted(migration_imports***REMOVED******REMOVED***
        # If there's a replaces, make a string for it
        if self.migration.replaces:
            items['replaces_str'***REMOVED*** = "\n    replaces = %s\n" % self.serialize(self.migration.replaces***REMOVED***[0***REMOVED***
        # Hinting that goes into comment
        items.update(
            version=get_version(***REMOVED***,
            timestamp=now(***REMOVED***.strftime("%Y-%m-%d %H:%M"***REMOVED***,
        ***REMOVED***

        if self.migration.initial:
            items['initial_str'***REMOVED*** = "\n    initial = True\n"

        return (MIGRATION_TEMPLATE % items***REMOVED***.encode("utf8"***REMOVED***

    @property
    def basedir(self***REMOVED***:
        migrations_package_name = MigrationLoader.migrations_module(self.migration.app_label***REMOVED***

        if migrations_package_name is None:
            raise ValueError(
                "Django can't create migrations for app '%s' because "
                "migrations have been disabled via the MIGRATION_MODULES "
                "setting." % self.migration.app_label
            ***REMOVED***

        # See if we can import the migrations module directly
        ***REMOVED***
            migrations_module = import_module(migrations_package_name***REMOVED***
        except ImportError:
            pass
        else:
            ***REMOVED***
                return upath(module_dir(migrations_module***REMOVED******REMOVED***
            except ValueError:
                pass

        # Alright, see if it's a direct submodule of the app
        app_config = apps.get_app_config(self.migration.app_label***REMOVED***
        maybe_app_name, _, migrations_package_basename = migrations_package_name.rpartition("."***REMOVED***
        if app_config.name == maybe_app_name:
            return os.path.join(app_config.path, migrations_package_basename***REMOVED***

        # In case of using MIGRATION_MODULES setting and the custom package
        # doesn't exist, create one, starting from an existing package
        existing_dirs, missing_dirs = migrations_package_name.split("."***REMOVED***, [***REMOVED***
        while existing_dirs:
            missing_dirs.insert(0, existing_dirs.pop(-1***REMOVED******REMOVED***
            ***REMOVED***
                base_module = import_module(".".join(existing_dirs***REMOVED******REMOVED***
            except ImportError:
                continue
            else:
                ***REMOVED***
                    base_dir = upath(module_dir(base_module***REMOVED******REMOVED***
                except ValueError:
                    continue
                else:
                    break
        else:
            raise ValueError(
                "Could not locate an appropriate location to create "
                "migrations package %s. Make sure the toplevel "
                "package exists and can be imported." %
                migrations_package_name***REMOVED***

        final_dir = os.path.join(base_dir, *missing_dirs***REMOVED***
        if not os.path.isdir(final_dir***REMOVED***:
            os.makedirs(final_dir***REMOVED***
        for missing_dir in missing_dirs:
            base_dir = os.path.join(base_dir, missing_dir***REMOVED***
            with open(os.path.join(base_dir, "__init__.py"***REMOVED***, "w"***REMOVED***:
                pass

        return final_dir

    @property
    def filename(self***REMOVED***:
        return "%s.py" % self.migration.name

    @property
    def path(self***REMOVED***:
        return os.path.join(self.basedir, self.filename***REMOVED***

    @classmethod
    def serialize(cls, value***REMOVED***:
        return serializer_factory(value***REMOVED***.serialize(***REMOVED***


MIGRATION_TEMPLATE = ***REMOVED***\
# -*- coding: utf-8 -*-
# Generated by Django %(version***REMOVED***s on %(timestamp***REMOVED***s
from __future__ import unicode_literals

%(imports***REMOVED***s

class Migration(migrations.Migration***REMOVED***:
%(replaces_str***REMOVED***s%(initial_str***REMOVED***s
    dependencies = [
%(dependencies***REMOVED***s\
    ***REMOVED***

    operations = [
%(operations***REMOVED***s\
    ***REMOVED***
***REMOVED***
