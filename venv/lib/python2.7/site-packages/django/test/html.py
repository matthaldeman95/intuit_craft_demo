***REMOVED***
Comparing two html documents.
***REMOVED***

from __future__ import unicode_literals

import re

from django.utils import six
from django.utils.encoding import force_text, python_2_unicode_compatible
from django.utils.html_parser import HTMLParseError, HTMLParser

WHITESPACE = re.compile('\s+'***REMOVED***


def normalize_whitespace(string***REMOVED***:
    return WHITESPACE.sub(' ', string***REMOVED***


@python_2_unicode_compatible
class Element(object***REMOVED***:
    def __init__(self, name, attributes***REMOVED***:
        self.name = name
        self.attributes = sorted(attributes***REMOVED***
        self.children = [***REMOVED***

    def append(self, element***REMOVED***:
        if isinstance(element, six.string_types***REMOVED***:
            element = force_text(element***REMOVED***
            element = normalize_whitespace(element***REMOVED***
            if self.children:
                if isinstance(self.children[-1***REMOVED***, six.string_types***REMOVED***:
                    self.children[-1***REMOVED*** += element
                    self.children[-1***REMOVED*** = normalize_whitespace(self.children[-1***REMOVED******REMOVED***
                    return
        elif self.children:
            # removing last children if it is only whitespace
            # this can result in incorrect dom representations since
            # whitespace between inline tags like <span> is significant
            if isinstance(self.children[-1***REMOVED***, six.string_types***REMOVED***:
                if self.children[-1***REMOVED***.isspace(***REMOVED***:
                    self.children.pop(***REMOVED***
        if element:
            self.children.append(element***REMOVED***

    def finalize(self***REMOVED***:
        def rstrip_last_element(children***REMOVED***:
            if children:
                if isinstance(children[-1***REMOVED***, six.string_types***REMOVED***:
                    children[-1***REMOVED*** = children[-1***REMOVED***.rstrip(***REMOVED***
                    if not children[-1***REMOVED***:
                        children.pop(***REMOVED***
                        children = rstrip_last_element(children***REMOVED***
            return children

        rstrip_last_element(self.children***REMOVED***
        for i, child in enumerate(self.children***REMOVED***:
            if isinstance(child, six.string_types***REMOVED***:
                self.children[i***REMOVED*** = child.strip(***REMOVED***
            elif hasattr(child, 'finalize'***REMOVED***:
                child.finalize(***REMOVED***

    def __eq__(self, element***REMOVED***:
        if not hasattr(element, 'name'***REMOVED***:
            return False
        if hasattr(element, 'name'***REMOVED*** and self.name != element.name:
            return False
        if len(self.attributes***REMOVED*** != len(element.attributes***REMOVED***:
            return False
        if self.attributes != element.attributes:
            # attributes without a value is same as attribute with value that
            # equals the attributes name:
            # <input checked> == <input checked="checked">
            for i in range(len(self.attributes***REMOVED******REMOVED***:
                attr, value = self.attributes[i***REMOVED***
                other_attr, other_value = element.attributes[i***REMOVED***
                if value is None:
                    value = attr
                if other_value is None:
                    other_value = other_attr
                if attr != other_attr or value != other_value:
                    return False
        if self.children != element.children:
            return False
        return True

    def __hash__(self***REMOVED***:
        return hash((self.name,***REMOVED*** + tuple(a for a in self.attributes***REMOVED******REMOVED***

    def __ne__(self, element***REMOVED***:
        return not self.__eq__(element***REMOVED***

    def _count(self, element, count=True***REMOVED***:
        if not isinstance(element, six.string_types***REMOVED***:
            if self == element:
                return 1
        i = 0
        for child in self.children:
            # child is text content and element is also text content, then
            # make a simple "text" in "text"
            if isinstance(child, six.string_types***REMOVED***:
                if isinstance(element, six.string_types***REMOVED***:
                    if count:
                        i += child.count(element***REMOVED***
                    elif element in child:
                        return 1
            else:
                i += child._count(element, count=count***REMOVED***
                if not count and i:
                    return i
        return i

    def __contains__(self, element***REMOVED***:
        return self._count(element, count=False***REMOVED*** > 0

    def count(self, element***REMOVED***:
        return self._count(element, count=True***REMOVED***

    def __getitem__(self, key***REMOVED***:
        return self.children[key***REMOVED***

    def __str__(self***REMOVED***:
        output = '<%s' % self.name
        for key, value in self.attributes:
            if value:
                output += ' %s="%s"' % (key, value***REMOVED***
            else:
                output += ' %s' % key
        if self.children:
            output += '>\n'
            output += ''.join(six.text_type(c***REMOVED*** for c in self.children***REMOVED***
            output += '\n</%s>' % self.name
        else:
            output += ' />'
        return output

    def __repr__(self***REMOVED***:
        return six.text_type(self***REMOVED***


@python_2_unicode_compatible
class RootElement(Element***REMOVED***:
    def __init__(self***REMOVED***:
        super(RootElement, self***REMOVED***.__init__(None, (***REMOVED******REMOVED***

    def __str__(self***REMOVED***:
        return ''.join(six.text_type(c***REMOVED*** for c in self.children***REMOVED***


class Parser(HTMLParser***REMOVED***:
    SELF_CLOSING_TAGS = (
        'br', 'hr', 'input', 'img', 'meta', 'spacer', 'link', 'frame', 'base',
        'col',
    ***REMOVED***

    def __init__(self***REMOVED***:
        HTMLParser.__init__(self***REMOVED***
        self.root = RootElement(***REMOVED***
        self.open_tags = [***REMOVED***
        self.element_positions = {***REMOVED***

    def error(self, msg***REMOVED***:
        raise HTMLParseError(msg, self.getpos(***REMOVED******REMOVED***

    def format_position(self, position=None, element=None***REMOVED***:
        if not position and element:
            position = self.element_positions[element***REMOVED***
        if position is None:
            position = self.getpos(***REMOVED***
        if hasattr(position, 'lineno'***REMOVED***:
            position = position.lineno, position.offset
        return 'Line %d, Column %d' % position

    @property
    def current(self***REMOVED***:
        if self.open_tags:
            return self.open_tags[-1***REMOVED***
        else:
            return self.root

    def handle_startendtag(self, tag, attrs***REMOVED***:
        self.handle_starttag(tag, attrs***REMOVED***
        if tag not in self.SELF_CLOSING_TAGS:
            self.handle_endtag(tag***REMOVED***

    def handle_starttag(self, tag, attrs***REMOVED***:
        # Special case handling of 'class' attribute, so that comparisons of DOM
        # instances are not sensitive to ordering of classes.
        attrs = [
            (name, " ".join(sorted(value.split(" "***REMOVED******REMOVED******REMOVED******REMOVED***
            if name == "class"
            else (name, value***REMOVED***
            for name, value in attrs
        ***REMOVED***
        element = Element(tag, attrs***REMOVED***
        self.current.append(element***REMOVED***
        if tag not in self.SELF_CLOSING_TAGS:
            self.open_tags.append(element***REMOVED***
        self.element_positions[element***REMOVED*** = self.getpos(***REMOVED***

    def handle_endtag(self, tag***REMOVED***:
        if not self.open_tags:
            self.error("Unexpected end tag `%s` (%s***REMOVED***" % (
                tag, self.format_position(***REMOVED******REMOVED******REMOVED***
        element = self.open_tags.pop(***REMOVED***
        while element.name != tag:
            if not self.open_tags:
                self.error("Unexpected end tag `%s` (%s***REMOVED***" % (
                    tag, self.format_position(***REMOVED******REMOVED******REMOVED***
            element = self.open_tags.pop(***REMOVED***

    def handle_data(self, data***REMOVED***:
        self.current.append(data***REMOVED***

    def handle_charref(self, name***REMOVED***:
        self.current.append('&%s;' % name***REMOVED***

    def handle_entityref(self, name***REMOVED***:
        self.current.append('&%s;' % name***REMOVED***


def parse_html(html***REMOVED***:
    ***REMOVED***
    Takes a string that contains *valid* HTML and turns it into a Python object
    structure that can be easily compared against other HTML on semantic
    equivalence. Syntactical differences like which quotation is used on
    arguments will be ignored.
    ***REMOVED***
    parser = Parser(***REMOVED***
    parser.feed(html***REMOVED***
    parser.close(***REMOVED***
    document = parser.root
    document.finalize(***REMOVED***
    # Removing ROOT element if it's not necessary
    if len(document.children***REMOVED*** == 1:
        if not isinstance(document.children[0***REMOVED***, six.string_types***REMOVED***:
            document = document.children[0***REMOVED***
    return document
