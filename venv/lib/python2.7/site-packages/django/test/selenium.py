from __future__ import unicode_literals

import sys
import unittest
from contextlib import contextmanager

from django.test import LiveServerTestCase, tag
from django.utils.module_loading import import_string
from django.utils.six import with_metaclass
from django.utils.text import capfirst


class SeleniumTestCaseBase(type(LiveServerTestCase***REMOVED******REMOVED***:
    # List of browsers to dynamically create test classes for.
    browsers = [***REMOVED***
    # Sentinel value to differentiate browser-specific instances.
    browser = None

    def __new__(cls, name, bases, attrs***REMOVED***:
        ***REMOVED***
        Dynamically create new classes and add them to the test module when
        multiple browsers specs are provided (e.g. --selenium=firefox,chrome***REMOVED***.
        ***REMOVED***
        test_class = super(SeleniumTestCaseBase, cls***REMOVED***.__new__(cls, name, bases, attrs***REMOVED***
        # If the test class is either browser-specific or a test base, return it.
        if test_class.browser or not any(name.startswith('test'***REMOVED*** and callable(value***REMOVED*** for name, value in attrs.items(***REMOVED******REMOVED***:
            return test_class
        elif test_class.browsers:
            # Reuse the created test class to make it browser-specific.
            # We can't rename it to include the browser name or create a
            # subclass like we do with the remaining browsers as it would
            # either duplicate tests or prevent pickling of its instances.
            first_browser = test_class.browsers[0***REMOVED***
            test_class.browser = first_browser
            # Create subclasses for each of the remaining browsers and expose
            # them through the test's module namespace.
            module = sys.modules[test_class.__module__***REMOVED***
            for browser in test_class.browsers[1:***REMOVED***:
                browser_test_class = cls.__new__(
                    cls,
                    str("%s%s" % (capfirst(browser***REMOVED***, name***REMOVED******REMOVED***,
                    (test_class,***REMOVED***,
                ***REMOVED***'browser': browser, '__module__': test_class.__module__***REMOVED***
                ***REMOVED***
                setattr(module, browser_test_class.__name__, browser_test_class***REMOVED***
            return test_class
        # If no browsers were specified, skip this class (it'll still be discovered***REMOVED***.
        return unittest.skip('No browsers specified.'***REMOVED***(test_class***REMOVED***

    @classmethod
    def import_webdriver(cls, browser***REMOVED***:
        return import_string("selenium.webdriver.%s.webdriver.WebDriver" % browser***REMOVED***

    def create_webdriver(self***REMOVED***:
        return self.import_webdriver(self.browser***REMOVED***(***REMOVED***


@tag('selenium'***REMOVED***
class SeleniumTestCase(with_metaclass(SeleniumTestCaseBase, LiveServerTestCase***REMOVED******REMOVED***:
    implicit_wait = 10

    @classmethod
    def setUpClass(cls***REMOVED***:
        cls.selenium = cls.create_webdriver(***REMOVED***
        cls.selenium.implicitly_wait(cls.implicit_wait***REMOVED***
        super(SeleniumTestCase, cls***REMOVED***.setUpClass(***REMOVED***

    @classmethod
    def _tearDownClassInternal(cls***REMOVED***:
        # quit(***REMOVED*** the WebDriver before attempting to terminate and join the
        # single-threaded LiveServerThread to avoid a dead lock if the browser
        # kept a connection alive.
        if hasattr(cls, 'selenium'***REMOVED***:
            cls.selenium.quit(***REMOVED***
        super(SeleniumTestCase, cls***REMOVED***._tearDownClassInternal(***REMOVED***

    @contextmanager
    def disable_implicit_wait(self***REMOVED***:
        ***REMOVED***Context manager that disables the default implicit wait.***REMOVED***
        self.selenium.implicitly_wait(0***REMOVED***
        ***REMOVED***
            yield
        finally:
            self.selenium.implicitly_wait(self.implicit_wait***REMOVED***
