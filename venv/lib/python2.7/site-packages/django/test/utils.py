import logging
import re
import sys
import time
import warnings
from contextlib import contextmanager
from functools import wraps
from unittest import TestCase, skipIf, skipUnless
from xml.dom.minidom import Node, parseString

from django.apps import apps
from django.apps.registry import Apps
from django.conf import UserSettingsHolder, settings
from django.core import mail
from django.core.signals import request_started
from django.db import reset_queries
from django.db.models.options import Options
from django.http import request
from django.template import Template
from django.test.signals import setting_changed, template_rendered
from django.urls import get_script_prefix, set_script_prefix
from django.utils import six
from django.utils.decorators import available_attrs
from django.utils.encoding import force_str
from django.utils.translation import deactivate

***REMOVED***
    import jinja2
except ImportError:
    jinja2 = None


__all__ = (
    'Approximate', 'ContextList', 'isolate_lru_cache', 'get_runner',
    'modify_settings', 'override_settings',
    'requires_tz_support',
    'setup_test_environment', 'teardown_test_environment',
***REMOVED***

TZ_SUPPORT = hasattr(time, 'tzset'***REMOVED***


class Approximate(object***REMOVED***:
    def __init__(self, val, places=7***REMOVED***:
        self.val = val
        self.places = places

    def __repr__(self***REMOVED***:
        return repr(self.val***REMOVED***

    def __eq__(self, other***REMOVED***:
        if self.val == other:
            return True
        return round(abs(self.val - other***REMOVED***, self.places***REMOVED*** == 0


class ContextList(list***REMOVED***:
    ***REMOVED***A wrapper that provides direct key access to context items contained
    in a list of context objects.
    ***REMOVED***
    def __getitem__(self, key***REMOVED***:
        if isinstance(key, six.string_types***REMOVED***:
            for subcontext in self:
                if key in subcontext:
                    return subcontext[key***REMOVED***
            raise KeyError(key***REMOVED***
        else:
            return super(ContextList, self***REMOVED***.__getitem__(key***REMOVED***

    def __contains__(self, key***REMOVED***:
        ***REMOVED***
            self[key***REMOVED***
        except KeyError:
            return False
        return True

    def keys(self***REMOVED***:
        ***REMOVED***
        Flattened keys of subcontexts.
        ***REMOVED***
        keys = set(***REMOVED***
        for subcontext in self:
            for dict in subcontext:
                keys |= set(dict.keys(***REMOVED******REMOVED***
        return keys


def instrumented_test_render(self, context***REMOVED***:
    ***REMOVED***
    An instrumented Template render method, providing a signal
    that can be intercepted by the test system Client
    ***REMOVED***
    template_rendered.send(sender=self, template=self, context=context***REMOVED***
    return self.nodelist.render(context***REMOVED***


def setup_test_environment(***REMOVED***:
    ***REMOVED***
    Perform global pre-test setup, such as installing the instrumented template
    renderer and setting the email backend to the locmem email backend.
    ***REMOVED***
    Template._original_render = Template._render
    Template._render = instrumented_test_render

    # Storing previous values in the settings module itself is problematic.
    # Store them in arbitrary (but related***REMOVED*** modules instead. See #20636.

    mail._original_email_backend = settings.EMAIL_BACKEND
    settings.EMAIL_BACKEND = 'django.core.mail.backends.locmem.EmailBackend'

    request._original_allowed_hosts = settings.ALLOWED_HOSTS
    settings.ALLOWED_HOSTS = ['*'***REMOVED***

    mail.outbox = [***REMOVED***

    deactivate(***REMOVED***


def teardown_test_environment(***REMOVED***:
    ***REMOVED***
    Perform any global post-test teardown, such as restoring the original
    template renderer and restoring the email sending functions.
    ***REMOVED***
    Template._render = Template._original_render
    del Template._original_render

    settings.EMAIL_BACKEND = mail._original_email_backend
    del mail._original_email_backend

    settings.ALLOWED_HOSTS = request._original_allowed_hosts
    del request._original_allowed_hosts

    del mail.outbox


def get_runner(settings, test_runner_class=None***REMOVED***:
    if not test_runner_class:
        test_runner_class = settings.TEST_RUNNER

    test_path = test_runner_class.split('.'***REMOVED***
    # Allow for Python 2.5 relative paths
    if len(test_path***REMOVED*** > 1:
        test_module_name = '.'.join(test_path[:-1***REMOVED******REMOVED***
    else:
        test_module_name = '.'
    test_module = __import__(test_module_name, {***REMOVED***, {***REMOVED***, force_str(test_path[-1***REMOVED******REMOVED******REMOVED***
    test_runner = getattr(test_module, test_path[-1***REMOVED******REMOVED***
    return test_runner


class TestContextDecorator(object***REMOVED***:
    ***REMOVED***
    A base class that can either be used as a context manager during tests
    or as a test function or unittest.TestCase subclass decorator to perform
    temporary alterations.

    `attr_name`: attribute assigned the return value of enable(***REMOVED*** if used as
                 a class decorator.

    `kwarg_name`: keyword argument passing the return value of enable(***REMOVED*** if
                  used as a function decorator.
    ***REMOVED***
    def __init__(self, attr_name=None, kwarg_name=None***REMOVED***:
        self.attr_name = attr_name
        self.kwarg_name = kwarg_name

    def enable(self***REMOVED***:
        raise NotImplementedError

    def disable(self***REMOVED***:
        raise NotImplementedError

    def __enter__(self***REMOVED***:
        return self.enable(***REMOVED***

    def __exit__(self, exc_type, exc_value, traceback***REMOVED***:
        self.disable(***REMOVED***

    def decorate_class(self, cls***REMOVED***:
        if issubclass(cls, TestCase***REMOVED***:
            decorated_setUp = cls.setUp
            decorated_tearDown = cls.tearDown

            def setUp(inner_self***REMOVED***:
                context = self.enable(***REMOVED***
                if self.attr_name:
                    setattr(inner_self, self.attr_name, context***REMOVED***
                decorated_setUp(inner_self***REMOVED***

            def tearDown(inner_self***REMOVED***:
                decorated_tearDown(inner_self***REMOVED***
                self.disable(***REMOVED***

            cls.setUp = setUp
            cls.tearDown = tearDown
            return cls
        raise TypeError('Can only decorate subclasses of unittest.TestCase'***REMOVED***

    def decorate_callable(self, func***REMOVED***:
        @wraps(func, assigned=available_attrs(func***REMOVED******REMOVED***
        def inner(*args, **kwargs***REMOVED***:
            with self as context:
                if self.kwarg_name:
                    kwargs[self.kwarg_name***REMOVED*** = context
                return func(*args, **kwargs***REMOVED***
        return inner

    def __call__(self, decorated***REMOVED***:
        if isinstance(decorated, type***REMOVED***:
            return self.decorate_class(decorated***REMOVED***
        elif callable(decorated***REMOVED***:
            return self.decorate_callable(decorated***REMOVED***
        raise TypeError('Cannot decorate object of type %s' % type(decorated***REMOVED******REMOVED***


class override_settings(TestContextDecorator***REMOVED***:
    ***REMOVED***
    Acts as either a decorator or a context manager. If it's a decorator it
    takes a function and returns a wrapped function. If it's a contextmanager
    it's used with the ``with`` statement. In either event entering/exiting
    are called before and after, respectively, the function/block is executed.
    ***REMOVED***
    def __init__(self, **kwargs***REMOVED***:
        self.options = kwargs
        super(override_settings, self***REMOVED***.__init__(***REMOVED***

    def enable(self***REMOVED***:
        # Keep this code at the beginning to leave the settings unchanged
        # in case it raises an exception because INSTALLED_APPS is invalid.
        if 'INSTALLED_APPS' in self.options:
            ***REMOVED***
                apps.set_installed_apps(self.options['INSTALLED_APPS'***REMOVED******REMOVED***
            except Exception:
                apps.unset_installed_apps(***REMOVED***
                raise
        override = UserSettingsHolder(settings._wrapped***REMOVED***
        for key, new_value in self.options.items(***REMOVED***:
            setattr(override, key, new_value***REMOVED***
        self.wrapped = settings._wrapped
        settings._wrapped = override
        for key, new_value in self.options.items(***REMOVED***:
            setting_changed.send(sender=settings._wrapped.__class__,
                                 setting=key, value=new_value, enter=True***REMOVED***

    def disable(self***REMOVED***:
        if 'INSTALLED_APPS' in self.options:
            apps.unset_installed_apps(***REMOVED***
        settings._wrapped = self.wrapped
        del self.wrapped
        for key in self.options:
            new_value = getattr(settings, key, None***REMOVED***
            setting_changed.send(sender=settings._wrapped.__class__,
                                 setting=key, value=new_value, enter=False***REMOVED***

    def save_options(self, test_func***REMOVED***:
        if test_func._overridden_settings is None:
            test_func._overridden_settings = self.options
        else:
            # Duplicate dict to prevent subclasses from altering their parent.
            test_func._overridden_settings = dict(
                test_func._overridden_settings, **self.options***REMOVED***

    def decorate_class(self, cls***REMOVED***:
        from django.test import SimpleTestCase
        if not issubclass(cls, SimpleTestCase***REMOVED***:
            raise ValueError(
                "Only subclasses of Django SimpleTestCase can be decorated "
                "with override_settings"***REMOVED***
        self.save_options(cls***REMOVED***
        return cls


class modify_settings(override_settings***REMOVED***:
    ***REMOVED***
    Like override_settings, but makes it possible to append, prepend or remove
    items instead of redefining the entire list.
    ***REMOVED***
    def __init__(self, *args, **kwargs***REMOVED***:
        if args:
            # Hack used when instantiating from SimpleTestCase.setUpClass.
            assert not kwargs
            self.operations = args[0***REMOVED***
        else:
            assert not args
            self.operations = list(kwargs.items(***REMOVED******REMOVED***
        super(override_settings, self***REMOVED***.__init__(***REMOVED***

    def save_options(self, test_func***REMOVED***:
        if test_func._modified_settings is None:
            test_func._modified_settings = self.operations
        else:
            # Duplicate list to prevent subclasses from altering their parent.
            test_func._modified_settings = list(
                test_func._modified_settings***REMOVED*** + self.operations

    def enable(self***REMOVED***:
        self.options = {***REMOVED***
        for name, operations in self.operations:
            ***REMOVED***
                # When called from SimpleTestCase.setUpClass, values may be
                # overridden several times; cumulate changes.
                value = self.options[name***REMOVED***
            except KeyError:
                value = list(getattr(settings, name, [***REMOVED******REMOVED******REMOVED***
            for action, items in operations.items(***REMOVED***:
                # items my be a single value or an iterable.
                if isinstance(items, six.string_types***REMOVED***:
                    items = [items***REMOVED***
                if action == 'append':
                    value = value + [item for item in items if item not in value***REMOVED***
                elif action == 'prepend':
                    value = [item for item in items if item not in value***REMOVED*** + value
                elif action == 'remove':
                    value = [item for item in value if item not in items***REMOVED***
                else:
                    raise ValueError("Unsupported action: %s" % action***REMOVED***
            self.options[name***REMOVED*** = value
        super(modify_settings, self***REMOVED***.enable(***REMOVED***


class override_system_checks(TestContextDecorator***REMOVED***:
    ***REMOVED***
    Acts as a decorator. Overrides list of registered system checks.
    Useful when you override `INSTALLED_APPS`, e.g. if you exclude `auth` app,
    you also need to exclude its system checks.
    ***REMOVED***
    def __init__(self, new_checks, deployment_checks=None***REMOVED***:
        from django.core.checks.registry import registry
        self.registry = registry
        self.new_checks = new_checks
        self.deployment_checks = deployment_checks
        super(override_system_checks, self***REMOVED***.__init__(***REMOVED***

    def enable(self***REMOVED***:
        self.old_checks = self.registry.registered_checks
        self.registry.registered_checks = self.new_checks
        self.old_deployment_checks = self.registry.deployment_checks
        if self.deployment_checks is not None:
            self.registry.deployment_checks = self.deployment_checks

    def disable(self***REMOVED***:
        self.registry.registered_checks = self.old_checks
        self.registry.deployment_checks = self.old_deployment_checks


def compare_xml(want, got***REMOVED***:
    ***REMOVED***Tries to do a 'xml-comparison' of want and got.  Plain string
    comparison doesn't always work because, for example, attribute
    ordering should not be important. Comment nodes are not considered in the
    comparison. Leading and trailing whitespace is ignored on both chunks.

    Based on https://github.com/lxml/lxml/blob/master/src/lxml/doctestcompare.py
    ***REMOVED***
    _norm_whitespace_re = re.compile(r'[ \t\n***REMOVED***[ \t\n***REMOVED***+'***REMOVED***

    def norm_whitespace(v***REMOVED***:
        return _norm_whitespace_re.sub(' ', v***REMOVED***

    def child_text(element***REMOVED***:
        return ''.join(c.data for c in element.childNodes
                       if c.nodeType == Node.TEXT_NODE***REMOVED***

    def children(element***REMOVED***:
        return [c for c in element.childNodes
                if c.nodeType == Node.ELEMENT_NODE***REMOVED***

    def norm_child_text(element***REMOVED***:
        return norm_whitespace(child_text(element***REMOVED******REMOVED***

    def attrs_dict(element***REMOVED***:
        return dict(element.attributes.items(***REMOVED******REMOVED***

    def check_element(want_element, got_element***REMOVED***:
        if want_element.tagName != got_element.tagName:
            return False
        if norm_child_text(want_element***REMOVED*** != norm_child_text(got_element***REMOVED***:
            return False
        if attrs_dict(want_element***REMOVED*** != attrs_dict(got_element***REMOVED***:
            return False
        want_children = children(want_element***REMOVED***
        got_children = children(got_element***REMOVED***
        if len(want_children***REMOVED*** != len(got_children***REMOVED***:
            return False
        for want, got in zip(want_children, got_children***REMOVED***:
            if not check_element(want, got***REMOVED***:
                return False
        return True

    def first_node(document***REMOVED***:
        for node in document.childNodes:
            if node.nodeType != Node.COMMENT_NODE:
                return node

    want, got = strip_quotes(want, got***REMOVED***
    want = want.strip(***REMOVED***.replace('\\n', '\n'***REMOVED***
    got = got.strip(***REMOVED***.replace('\\n', '\n'***REMOVED***

    # If the string is not a complete xml document, we may need to add a
    # root element. This allow us to compare fragments, like "<foo/><bar/>"
    if not want.startswith('<?xml'***REMOVED***:
        wrapper = '<root>%s</root>'
        want = wrapper % want
        got = wrapper % got

    # Parse the want and got strings, and compare the parsings.
    want_root = first_node(parseString(want***REMOVED******REMOVED***
    got_root = first_node(parseString(got***REMOVED******REMOVED***

    return check_element(want_root, got_root***REMOVED***


def strip_quotes(want, got***REMOVED***:
    ***REMOVED***
    Strip quotes of doctests output values:

    >>> strip_quotes("'foo'"***REMOVED***
    "foo"
    >>> strip_quotes('"foo"'***REMOVED***
    "foo"
    ***REMOVED***
    def is_quoted_string(s***REMOVED***:
        s = s.strip(***REMOVED***
        return len(s***REMOVED*** >= 2 and s[0***REMOVED*** == s[-1***REMOVED*** and s[0***REMOVED*** in ('"', "'"***REMOVED***

    def is_quoted_unicode(s***REMOVED***:
        s = s.strip(***REMOVED***
        return len(s***REMOVED*** >= 3 and s[0***REMOVED*** == 'u' and s[1***REMOVED*** == s[-1***REMOVED*** and s[1***REMOVED*** in ('"', "'"***REMOVED***

    if is_quoted_string(want***REMOVED*** and is_quoted_string(got***REMOVED***:
        want = want.strip(***REMOVED***[1:-1***REMOVED***
        got = got.strip(***REMOVED***[1:-1***REMOVED***
    elif is_quoted_unicode(want***REMOVED*** and is_quoted_unicode(got***REMOVED***:
        want = want.strip(***REMOVED***[2:-1***REMOVED***
        got = got.strip(***REMOVED***[2:-1***REMOVED***
    return want, got


def str_prefix(s***REMOVED***:
    return s % {'_': '' if six.PY3 else 'u'***REMOVED***


class CaptureQueriesContext(object***REMOVED***:
    ***REMOVED***
    Context manager that captures queries executed by the specified connection.
    ***REMOVED***
    def __init__(self, connection***REMOVED***:
        self.connection = connection

    def __iter__(self***REMOVED***:
        return iter(self.captured_queries***REMOVED***

    def __getitem__(self, index***REMOVED***:
        return self.captured_queries[index***REMOVED***

    def __len__(self***REMOVED***:
        return len(self.captured_queries***REMOVED***

    @property
    def captured_queries(self***REMOVED***:
        return self.connection.queries[self.initial_queries:self.final_queries***REMOVED***

    def __enter__(self***REMOVED***:
        self.force_debug_cursor = self.connection.force_debug_cursor
        self.connection.force_debug_cursor = True
        self.initial_queries = len(self.connection.queries_log***REMOVED***
        self.final_queries = None
        request_started.disconnect(reset_queries***REMOVED***
        return self

    def __exit__(self, exc_type, exc_value, traceback***REMOVED***:
        self.connection.force_debug_cursor = self.force_debug_cursor
        request_started.connect(reset_queries***REMOVED***
        if exc_type is not None:
            return
        self.final_queries = len(self.connection.queries_log***REMOVED***


class ignore_warnings(TestContextDecorator***REMOVED***:
    def __init__(self, **kwargs***REMOVED***:
        self.ignore_kwargs = kwargs
        if 'message' in self.ignore_kwargs or 'module' in self.ignore_kwargs:
            self.filter_func = warnings.filterwarnings
        else:
            self.filter_func = warnings.simplefilter
        super(ignore_warnings, self***REMOVED***.__init__(***REMOVED***

    def enable(self***REMOVED***:
        self.catch_warnings = warnings.catch_warnings(***REMOVED***
        self.catch_warnings.__enter__(***REMOVED***
        self.filter_func('ignore', **self.ignore_kwargs***REMOVED***

    def disable(self***REMOVED***:
        self.catch_warnings.__exit__(*sys.exc_info(***REMOVED******REMOVED***


@contextmanager
def patch_logger(logger_name, log_level, log_kwargs=False***REMOVED***:
    ***REMOVED***
    Context manager that takes a named logger and the logging level
    and provides a simple mock-like list of messages received
    ***REMOVED***
    calls = [***REMOVED***

    def replacement(msg, *args, **kwargs***REMOVED***:
        call = msg % args
        calls.append((call, kwargs***REMOVED*** if log_kwargs else call***REMOVED***
    logger = logging.getLogger(logger_name***REMOVED***
    orig = getattr(logger, log_level***REMOVED***
    setattr(logger, log_level, replacement***REMOVED***
    ***REMOVED***
        yield calls
    finally:
        setattr(logger, log_level, orig***REMOVED***


# On OSes that don't provide tzset (Windows***REMOVED***, we can't set the timezone
# in which the program runs. As a consequence, we must skip tests that
# don't enforce a specific timezone (with timezone.override or equivalent***REMOVED***,
# or attempt to interpret naive datetimes in the default timezone.

requires_tz_support = skipUnless(
    TZ_SUPPORT,
    "This test relies on the ability to run a program in an arbitrary "
    "time zone, but your operating system isn't able to do that."
***REMOVED***


@contextmanager
def extend_sys_path(*paths***REMOVED***:
    ***REMOVED***Context manager to temporarily add paths to sys.path.***REMOVED***
    _orig_sys_path = sys.path[:***REMOVED***
    sys.path.extend(paths***REMOVED***
    ***REMOVED***
        yield
    finally:
        sys.path = _orig_sys_path


@contextmanager
def isolate_lru_cache(lru_cache_object***REMOVED***:
    ***REMOVED***Clear the cache of an LRU cache object on entering and exiting.***REMOVED***
    lru_cache_object.cache_clear(***REMOVED***
    ***REMOVED***
        yield
    finally:
        lru_cache_object.cache_clear(***REMOVED***


@contextmanager
def captured_output(stream_name***REMOVED***:
    ***REMOVED***Return a context manager used by captured_stdout/stdin/stderr
    that temporarily replaces the sys stream *stream_name* with a StringIO.

    Note: This function and the following ``captured_std*`` are copied
          from CPython's ``test.support`` module.***REMOVED***
    orig_stdout = getattr(sys, stream_name***REMOVED***
    setattr(sys, stream_name, six.StringIO(***REMOVED******REMOVED***
    ***REMOVED***
        yield getattr(sys, stream_name***REMOVED***
    finally:
        setattr(sys, stream_name, orig_stdout***REMOVED***


def captured_stdout(***REMOVED***:
    ***REMOVED***Capture the output of sys.stdout:

       with captured_stdout(***REMOVED*** as stdout:
           print("hello"***REMOVED***
       self.assertEqual(stdout.getvalue(***REMOVED***, "hello\n"***REMOVED***
    ***REMOVED***
    return captured_output("stdout"***REMOVED***


def captured_stderr(***REMOVED***:
    ***REMOVED***Capture the output of sys.stderr:

       with captured_stderr(***REMOVED*** as stderr:
           print("hello", file=sys.stderr***REMOVED***
       self.assertEqual(stderr.getvalue(***REMOVED***, "hello\n"***REMOVED***
    ***REMOVED***
    return captured_output("stderr"***REMOVED***


def captured_stdin(***REMOVED***:
    ***REMOVED***Capture the input to sys.stdin:

       with captured_stdin(***REMOVED*** as stdin:
           stdin.write('hello\n'***REMOVED***
           stdin.seek(0***REMOVED***
           # call test code that consumes from sys.stdin
           captured = input(***REMOVED***
       self.assertEqual(captured, "hello"***REMOVED***
    ***REMOVED***
    return captured_output("stdin"***REMOVED***


def reset_warning_registry(***REMOVED***:
    ***REMOVED***
    Clear warning registry for all modules. This is required in some tests
    because of a bug in Python that prevents warnings.simplefilter("always"***REMOVED***
    from always making warnings appear: http://bugs.python.org/issue4180

    The bug was fixed in Python 3.4.2.
    ***REMOVED***
    key = "__warningregistry__"
    for mod in sys.modules.values(***REMOVED***:
        if hasattr(mod, key***REMOVED***:
            getattr(mod, key***REMOVED***.clear(***REMOVED***


@contextmanager
def freeze_time(t***REMOVED***:
    ***REMOVED***
    Context manager to temporarily freeze time.time(***REMOVED***. This temporarily
    modifies the time function of the time module. Modules which import the
    time function directly (e.g. `from time import time`***REMOVED*** won't be affected
    This isn't meant as a public API, but helps reduce some repetitive code in
    Django's test suite.
    ***REMOVED***
    _real_time = time.time
    time.time = lambda: t
    ***REMOVED***
        yield
    finally:
        time.time = _real_time


def require_jinja2(test_func***REMOVED***:
    ***REMOVED***
    Decorator to enable a Jinja2 template engine in addition to the regular
    Django template engine for a test or skip it if Jinja2 isn't available.
    ***REMOVED***
    test_func = skipIf(jinja2 is None, "this test requires jinja2"***REMOVED***(test_func***REMOVED***
    test_func = override_settings(TEMPLATES=[{
***REMOVED***
***REMOVED***
***REMOVED*** {
        'BACKEND': 'django.template.backends.jinja2.Jinja2',
***REMOVED***
***REMOVED***'keep_trailing_newline': True***REMOVED***,
***REMOVED******REMOVED******REMOVED***(test_func***REMOVED***
    return test_func


class override_script_prefix(TestContextDecorator***REMOVED***:
    ***REMOVED***
    Decorator or context manager to temporary override the script prefix.
    ***REMOVED***
    def __init__(self, prefix***REMOVED***:
        self.prefix = prefix
        super(override_script_prefix, self***REMOVED***.__init__(***REMOVED***

    def enable(self***REMOVED***:
        self.old_prefix = get_script_prefix(***REMOVED***
        set_script_prefix(self.prefix***REMOVED***

    def disable(self***REMOVED***:
        set_script_prefix(self.old_prefix***REMOVED***


class LoggingCaptureMixin(object***REMOVED***:
    ***REMOVED***
    Capture the output from the 'django' logger and store it on the class's
    logger_output attribute.
    ***REMOVED***
    def setUp(self***REMOVED***:
        self.logger = logging.getLogger('django'***REMOVED***
        self.old_stream = self.logger.handlers[0***REMOVED***.stream
        self.logger_output = six.StringIO(***REMOVED***
        self.logger.handlers[0***REMOVED***.stream = self.logger_output

    def tearDown(self***REMOVED***:
        self.logger.handlers[0***REMOVED***.stream = self.old_stream


class isolate_apps(TestContextDecorator***REMOVED***:
    ***REMOVED***
    Act as either a decorator or a context manager to register models defined
    in its wrapped context to an isolated registry.

    The list of installed apps the isolated registry should contain must be
    passed as arguments.

    Two optional keyword arguments can be specified:

    `attr_name`: attribute assigned the isolated registry if used as a class
                 decorator.

    `kwarg_name`: keyword argument passing the isolated registry if used as a
                  function decorator.
    ***REMOVED***

    def __init__(self, *installed_apps, **kwargs***REMOVED***:
        self.installed_apps = installed_apps
        super(isolate_apps, self***REMOVED***.__init__(**kwargs***REMOVED***

    def enable(self***REMOVED***:
        self.old_apps = Options.default_apps
        apps = Apps(self.installed_apps***REMOVED***
        setattr(Options, 'default_apps', apps***REMOVED***
        return apps

    def disable(self***REMOVED***:
        setattr(Options, 'default_apps', self.old_apps***REMOVED***


def tag(*tags***REMOVED***:
    ***REMOVED***
    Decorator to add tags to a test class or method.
    ***REMOVED***
    def decorator(obj***REMOVED***:
        setattr(obj, 'tags', set(tags***REMOVED******REMOVED***
        return obj
    return decorator
