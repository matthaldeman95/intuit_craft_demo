***REMOVED***Default variable filters.***REMOVED***
from __future__ import unicode_literals

import random as random_module
import re
import warnings
from decimal import ROUND_HALF_UP, Context, Decimal, InvalidOperation
from functools import wraps
from operator import itemgetter
from pprint import pformat

from django.utils import formats, six
from django.utils.dateformat import format, time_format
from django.utils.deprecation import RemovedInDjango20Warning
from django.utils.encoding import force_text, iri_to_uri
from django.utils.html import (
    avoid_wrapping, conditional_escape, escape, escapejs, linebreaks,
    strip_tags, urlize as _urlize,
***REMOVED***
from django.utils.http import urlquote
from django.utils.safestring import SafeData, mark_for_escaping, mark_safe
from django.utils.text import (
    Truncator, normalize_newlines, phone2numeric, slugify as _slugify, wrap,
***REMOVED***
from django.utils.timesince import timesince, timeuntil
from django.utils.translation import ugettext, ungettext

from .base import Variable, VariableDoesNotExist
from .library import Library

register = Library(***REMOVED***


#######################
# STRING DECORATOR    #
#######################

def stringfilter(func***REMOVED***:
    ***REMOVED***
    Decorator for filters which should only receive unicode objects. The object
    passed as the first positional argument will be converted to a unicode
    object.
    ***REMOVED***
    def _dec(*args, **kwargs***REMOVED***:
        if args:
            args = list(args***REMOVED***
            args[0***REMOVED*** = force_text(args[0***REMOVED******REMOVED***
            if (isinstance(args[0***REMOVED***, SafeData***REMOVED*** and
                    getattr(_dec._decorated_function, 'is_safe', False***REMOVED******REMOVED***:
                return mark_safe(func(*args, **kwargs***REMOVED******REMOVED***
        return func(*args, **kwargs***REMOVED***

    # Include a reference to the real function (used to check original
    # arguments by the template parser, and to bear the 'is_safe' attribute
    # when multiple decorators are applied***REMOVED***.
    _dec._decorated_function = getattr(func, '_decorated_function', func***REMOVED***

    return wraps(func***REMOVED***(_dec***REMOVED***


###################
# STRINGS         #
###################

@register.filter(is_safe=True***REMOVED***
@stringfilter
def addslashes(value***REMOVED***:
    ***REMOVED***
    Adds slashes before quotes. Useful for escaping strings in CSV, for
    example. Less useful for escaping JavaScript; use the ``escapejs``
    filter instead.
    ***REMOVED***
    return value.replace('\\', '\\\\'***REMOVED***.replace('"', '\\"'***REMOVED***.replace("'", "\\'"***REMOVED***


@register.filter(is_safe=True***REMOVED***
@stringfilter
def capfirst(value***REMOVED***:
    ***REMOVED***Capitalizes the first character of the value.***REMOVED***
    return value and value[0***REMOVED***.upper(***REMOVED*** + value[1:***REMOVED***


@register.filter("escapejs"***REMOVED***
@stringfilter
def escapejs_filter(value***REMOVED***:
    ***REMOVED***Hex encodes characters for use in JavaScript strings.***REMOVED***
    return escapejs(value***REMOVED***


# Values for testing floatformat input against infinity and NaN representations,
# which differ across platforms and Python versions.  Some (i.e. old Windows
# ones***REMOVED*** are not recognized by Decimal but we want to return them unchanged vs.
# returning an empty string as we do for completely invalid input.  Note these
# need to be built up from values that are not inf/nan, since inf/nan values do
# not reload properly from .pyc files on Windows prior to some level of Python 2.5
# (see Python Issue757815 and Issue1080440***REMOVED***.
pos_inf = 1e200 * 1e200
neg_inf = -1e200 * 1e200
nan = (1e200 * 1e200***REMOVED*** // (1e200 * 1e200***REMOVED***
special_floats = [str(pos_inf***REMOVED***, str(neg_inf***REMOVED***, str(nan***REMOVED******REMOVED***


@register.filter(is_safe=True***REMOVED***
def floatformat(text, arg=-1***REMOVED***:
    ***REMOVED***
    Displays a float to a specified number of decimal places.

    If called without an argument, it displays the floating point number with
    one decimal place -- but only if there's a decimal place to be displayed:

    * num1 = 34.23234
    * num2 = 34.00000
    * num3 = 34.26000
    * {{ num1|floatformat ***REMOVED******REMOVED*** displays "34.2"
    * {{ num2|floatformat ***REMOVED******REMOVED*** displays "34"
    * {{ num3|floatformat ***REMOVED******REMOVED*** displays "34.3"

    If arg is positive, it will always display exactly arg number of decimal
    places:

    * {{ num1|floatformat:3 ***REMOVED******REMOVED*** displays "34.232"
    * {{ num2|floatformat:3 ***REMOVED******REMOVED*** displays "34.000"
    * {{ num3|floatformat:3 ***REMOVED******REMOVED*** displays "34.260"

    If arg is negative, it will display arg number of decimal places -- but
    only if there are places to be displayed:

    * {{ num1|floatformat:"-3" ***REMOVED******REMOVED*** displays "34.232"
    * {{ num2|floatformat:"-3" ***REMOVED******REMOVED*** displays "34"
    * {{ num3|floatformat:"-3" ***REMOVED******REMOVED*** displays "34.260"

    If the input float is infinity or NaN, the (platform-dependent***REMOVED*** string
    representation of that value will be displayed.
    ***REMOVED***

    ***REMOVED***
        input_val = force_text(text***REMOVED***
        d = Decimal(input_val***REMOVED***
    except UnicodeEncodeError:
        return ''
    except InvalidOperation:
        if input_val in special_floats:
            return input_val
        ***REMOVED***
            d = Decimal(force_text(float(text***REMOVED******REMOVED******REMOVED***
        except (ValueError, InvalidOperation, TypeError, UnicodeEncodeError***REMOVED***:
            return ''
    ***REMOVED***
        p = int(arg***REMOVED***
    except ValueError:
        return input_val

    ***REMOVED***
        m = int(d***REMOVED*** - d
    except (ValueError, OverflowError, InvalidOperation***REMOVED***:
        return input_val

    if not m and p < 0:
        return mark_safe(formats.number_format('%d' % (int(d***REMOVED******REMOVED***, 0***REMOVED******REMOVED***

    if p == 0:
        exp = Decimal(1***REMOVED***
    else:
        exp = Decimal('1.0'***REMOVED*** / (Decimal(10***REMOVED*** ** abs(p***REMOVED******REMOVED***
    ***REMOVED***
        # Set the precision high enough to avoid an exception, see #15789.
        tupl = d.as_tuple(***REMOVED***
        units = len(tupl[1***REMOVED******REMOVED*** - tupl[2***REMOVED***
        prec = abs(p***REMOVED*** + units + 1

        # Avoid conversion to scientific notation by accessing `sign`, `digits`
        # and `exponent` from `Decimal.as_tuple(***REMOVED***` directly.
        sign, digits, exponent = d.quantize(exp, ROUND_HALF_UP, Context(prec=prec***REMOVED******REMOVED***.as_tuple(***REMOVED***
        digits = [six.text_type(digit***REMOVED*** for digit in reversed(digits***REMOVED******REMOVED***
        while len(digits***REMOVED*** <= abs(exponent***REMOVED***:
            digits.append('0'***REMOVED***
        digits.insert(-exponent, '.'***REMOVED***
        if sign:
            digits.append('-'***REMOVED***
        number = ''.join(reversed(digits***REMOVED******REMOVED***
        return mark_safe(formats.number_format(number, abs(p***REMOVED******REMOVED******REMOVED***
    except InvalidOperation:
        return input_val


@register.filter(is_safe=True***REMOVED***
@stringfilter
def iriencode(value***REMOVED***:
    ***REMOVED***Escapes an IRI value for use in a URL.***REMOVED***
    return force_text(iri_to_uri(value***REMOVED******REMOVED***


@register.filter(is_safe=True, needs_autoescape=True***REMOVED***
@stringfilter
def linenumbers(value, autoescape=True***REMOVED***:
    ***REMOVED***Displays text with line numbers.***REMOVED***
    lines = value.split('\n'***REMOVED***
    # Find the maximum width of the line count, for use with zero padding
    # string format command
    width = six.text_type(len(six.text_type(len(lines***REMOVED******REMOVED******REMOVED******REMOVED***
    if not autoescape or isinstance(value, SafeData***REMOVED***:
        for i, line in enumerate(lines***REMOVED***:
            lines[i***REMOVED*** = ("%0" + width + "d. %s"***REMOVED*** % (i + 1, line***REMOVED***
    else:
        for i, line in enumerate(lines***REMOVED***:
            lines[i***REMOVED*** = ("%0" + width + "d. %s"***REMOVED*** % (i + 1, escape(line***REMOVED******REMOVED***
    return mark_safe('\n'.join(lines***REMOVED******REMOVED***


@register.filter(is_safe=True***REMOVED***
@stringfilter
def lower(value***REMOVED***:
    ***REMOVED***Converts a string into all lowercase.***REMOVED***
    return value.lower(***REMOVED***


@register.filter(is_safe=False***REMOVED***
@stringfilter
def make_list(value***REMOVED***:
    ***REMOVED***
    Returns the value turned into a list.

    For an integer, it's a list of digits.
    For a string, it's a list of characters.
    ***REMOVED***
    return list(value***REMOVED***


@register.filter(is_safe=True***REMOVED***
@stringfilter
def slugify(value***REMOVED***:
    ***REMOVED***
    Converts to ASCII. Converts spaces to hyphens. Removes characters that
    aren't alphanumerics, underscores, or hyphens. Converts to lowercase.
    Also strips leading and trailing whitespace.
    ***REMOVED***
    return _slugify(value***REMOVED***


@register.filter(is_safe=True***REMOVED***
def stringformat(value, arg***REMOVED***:
    ***REMOVED***
    Formats the variable according to the arg, a string formatting specifier.

    This specifier uses Python string formating syntax, with the exception that
    the leading "%" is dropped.

    See https://docs.python.org/3/library/stdtypes.html#printf-style-string-formatting
    for documentation of Python string formatting.
    ***REMOVED***
    ***REMOVED***
        return ("%" + six.text_type(arg***REMOVED******REMOVED*** % value
    except (ValueError, TypeError***REMOVED***:
        return ""


@register.filter(is_safe=True***REMOVED***
@stringfilter
def title(value***REMOVED***:
    ***REMOVED***Converts a string into titlecase.***REMOVED***
    t = re.sub("([a-z***REMOVED******REMOVED***'([A-Z***REMOVED******REMOVED***", lambda m: m.group(0***REMOVED***.lower(***REMOVED***, value.title(***REMOVED******REMOVED***
    return re.sub("\d([A-Z***REMOVED******REMOVED***", lambda m: m.group(0***REMOVED***.lower(***REMOVED***, t***REMOVED***


@register.filter(is_safe=True***REMOVED***
@stringfilter
def truncatechars(value, arg***REMOVED***:
    ***REMOVED***
    Truncates a string after a certain number of characters.

    Argument: Number of characters to truncate after.
    ***REMOVED***
    ***REMOVED***
        length = int(arg***REMOVED***
    except ValueError:  # Invalid literal for int(***REMOVED***.
        return value  # Fail silently.
    return Truncator(value***REMOVED***.chars(length***REMOVED***


@register.filter(is_safe=True***REMOVED***
@stringfilter
def truncatechars_html(value, arg***REMOVED***:
    ***REMOVED***
    Truncates HTML after a certain number of chars.

    Argument: Number of chars to truncate after.

    Newlines in the HTML are preserved.
    ***REMOVED***
    ***REMOVED***
        length = int(arg***REMOVED***
    except ValueError:  # invalid literal for int(***REMOVED***
        return value  # Fail silently.
    return Truncator(value***REMOVED***.chars(length, html=True***REMOVED***


@register.filter(is_safe=True***REMOVED***
@stringfilter
def truncatewords(value, arg***REMOVED***:
    ***REMOVED***
    Truncates a string after a certain number of words.

    Argument: Number of words to truncate after.

    Newlines within the string are removed.
    ***REMOVED***
    ***REMOVED***
        length = int(arg***REMOVED***
    except ValueError:  # Invalid literal for int(***REMOVED***.
        return value  # Fail silently.
    return Truncator(value***REMOVED***.words(length, truncate=' ...'***REMOVED***


@register.filter(is_safe=True***REMOVED***
@stringfilter
def truncatewords_html(value, arg***REMOVED***:
    ***REMOVED***
    Truncates HTML after a certain number of words.

    Argument: Number of words to truncate after.

    Newlines in the HTML are preserved.
    ***REMOVED***
    ***REMOVED***
        length = int(arg***REMOVED***
    except ValueError:  # invalid literal for int(***REMOVED***
        return value  # Fail silently.
    return Truncator(value***REMOVED***.words(length, html=True, truncate=' ...'***REMOVED***


@register.filter(is_safe=False***REMOVED***
@stringfilter
def upper(value***REMOVED***:
    ***REMOVED***Converts a string into all uppercase.***REMOVED***
    return value.upper(***REMOVED***


@register.filter(is_safe=False***REMOVED***
@stringfilter
def urlencode(value, safe=None***REMOVED***:
    ***REMOVED***
    Escapes a value for use in a URL.

    Takes an optional ``safe`` parameter used to determine the characters which
    should not be escaped by Django's ``urlquote`` method. If not provided, the
    default safe characters will be used (but an empty string can be provided
    when *all* characters should be escaped***REMOVED***.
    ***REMOVED***
    kwargs = {***REMOVED***
    if safe is not None:
        kwargs['safe'***REMOVED*** = safe
    return urlquote(value, **kwargs***REMOVED***


@register.filter(is_safe=True, needs_autoescape=True***REMOVED***
@stringfilter
def urlize(value, autoescape=True***REMOVED***:
    ***REMOVED***Converts URLs in plain text into clickable links.***REMOVED***
    return mark_safe(_urlize(value, nofollow=True, autoescape=autoescape***REMOVED******REMOVED***


@register.filter(is_safe=True, needs_autoescape=True***REMOVED***
@stringfilter
def urlizetrunc(value, limit, autoescape=True***REMOVED***:
    ***REMOVED***
    Converts URLs into clickable links, truncating URLs to the given character
    limit, and adding 'rel=nofollow' attribute to discourage spamming.

    Argument: Length to truncate URLs to.
    ***REMOVED***
    return mark_safe(_urlize(value, trim_url_limit=int(limit***REMOVED***, nofollow=True, autoescape=autoescape***REMOVED******REMOVED***


@register.filter(is_safe=False***REMOVED***
@stringfilter
def wordcount(value***REMOVED***:
    ***REMOVED***Returns the number of words.***REMOVED***
    return len(value.split(***REMOVED******REMOVED***


@register.filter(is_safe=True***REMOVED***
@stringfilter
def wordwrap(value, arg***REMOVED***:
    ***REMOVED***
    Wraps words at specified line length.

    Argument: number of characters to wrap the text at.
    ***REMOVED***
    return wrap(value, int(arg***REMOVED******REMOVED***


@register.filter(is_safe=True***REMOVED***
@stringfilter
def ljust(value, arg***REMOVED***:
    ***REMOVED***
    Left-aligns the value in a field of a given width.

    Argument: field size.
    ***REMOVED***
    return value.ljust(int(arg***REMOVED******REMOVED***


@register.filter(is_safe=True***REMOVED***
@stringfilter
def rjust(value, arg***REMOVED***:
    ***REMOVED***
    Right-aligns the value in a field of a given width.

    Argument: field size.
    ***REMOVED***
    return value.rjust(int(arg***REMOVED******REMOVED***


@register.filter(is_safe=True***REMOVED***
@stringfilter
def center(value, arg***REMOVED***:
    ***REMOVED***Centers the value in a field of a given width.***REMOVED***
    return value.center(int(arg***REMOVED******REMOVED***


@register.filter
@stringfilter
def cut(value, arg***REMOVED***:
    ***REMOVED***
    Removes all values of arg from the given string.
    ***REMOVED***
    safe = isinstance(value, SafeData***REMOVED***
    value = value.replace(arg, ''***REMOVED***
    if safe and arg != ';':
        return mark_safe(value***REMOVED***
    return value


###################
# HTML STRINGS    #
###################

@register.filter("escape", is_safe=True***REMOVED***
@stringfilter
def escape_filter(value***REMOVED***:
    ***REMOVED***
    Marks the value as a string that should be auto-escaped.
    ***REMOVED***
    with warnings.catch_warnings(***REMOVED***:
        # Ignore mark_for_escaping deprecation -- this will use
        # conditional_escape(***REMOVED*** in Django 2.0.
        warnings.simplefilter('ignore', category=RemovedInDjango20Warning***REMOVED***
        return mark_for_escaping(value***REMOVED***


@register.filter(is_safe=True***REMOVED***
@stringfilter
def force_escape(value***REMOVED***:
    ***REMOVED***
    Escapes a string's HTML. This returns a new string containing the escaped
    characters (as opposed to "escape", which marks the content for later
    possible escaping***REMOVED***.
    ***REMOVED***
    return escape(value***REMOVED***


@register.filter("linebreaks", is_safe=True, needs_autoescape=True***REMOVED***
@stringfilter
def linebreaks_filter(value, autoescape=True***REMOVED***:
    ***REMOVED***
    Replaces line breaks in plain text with appropriate HTML; a single
    newline becomes an HTML line break (``<br />``***REMOVED*** and a new line
    followed by a blank line becomes a paragraph break (``</p>``***REMOVED***.
    ***REMOVED***
    autoescape = autoescape and not isinstance(value, SafeData***REMOVED***
    return mark_safe(linebreaks(value, autoescape***REMOVED******REMOVED***


@register.filter(is_safe=True, needs_autoescape=True***REMOVED***
@stringfilter
def linebreaksbr(value, autoescape=True***REMOVED***:
    ***REMOVED***
    Converts all newlines in a piece of plain text to HTML line breaks
    (``<br />``***REMOVED***.
    ***REMOVED***
    autoescape = autoescape and not isinstance(value, SafeData***REMOVED***
    value = normalize_newlines(value***REMOVED***
    if autoescape:
        value = escape(value***REMOVED***
    return mark_safe(value.replace('\n', '<br />'***REMOVED******REMOVED***


@register.filter(is_safe=True***REMOVED***
@stringfilter
def safe(value***REMOVED***:
    ***REMOVED***
    Marks the value as a string that should not be auto-escaped.
    ***REMOVED***
    return mark_safe(value***REMOVED***


@register.filter(is_safe=True***REMOVED***
def safeseq(value***REMOVED***:
    ***REMOVED***
    A "safe" filter for sequences. Marks each element in the sequence,
    individually, as safe, after converting them to unicode. Returns a list
    with the results.
    ***REMOVED***
    return [mark_safe(force_text(obj***REMOVED******REMOVED*** for obj in value***REMOVED***


@register.filter(is_safe=True***REMOVED***
@stringfilter
def striptags(value***REMOVED***:
    ***REMOVED***Strips all [X***REMOVED***HTML tags.***REMOVED***
    return strip_tags(value***REMOVED***


###################
# LISTS           #
###################

def _property_resolver(arg***REMOVED***:
    ***REMOVED***
    When arg is convertible to float, behave like operator.itemgetter(arg***REMOVED***
    Otherwise, behave like Variable(arg***REMOVED***.resolve

    >>> _property_resolver(1***REMOVED***('abc'***REMOVED***
    'b'
    >>> _property_resolver('1'***REMOVED***('abc'***REMOVED***
    Traceback (most recent call last***REMOVED***:
    ...
    TypeError: string indices must be integers
    >>> class Foo:
    ...     a = 42
    ...     b = 3.14
    ...     c = 'Hey!'
    >>> _property_resolver('b'***REMOVED***(Foo(***REMOVED******REMOVED***
    3.14
    ***REMOVED***
    ***REMOVED***
        float(arg***REMOVED***
    except ValueError:
        return Variable(arg***REMOVED***.resolve
    else:
        return itemgetter(arg***REMOVED***


@register.filter(is_safe=False***REMOVED***
def dictsort(value, arg***REMOVED***:
    ***REMOVED***
    Takes a list of dicts, returns that list sorted by the property given in
    the argument.
    ***REMOVED***
    ***REMOVED***
        return sorted(value, key=_property_resolver(arg***REMOVED******REMOVED***
    except (TypeError, VariableDoesNotExist***REMOVED***:
        return ''


@register.filter(is_safe=False***REMOVED***
def dictsortreversed(value, arg***REMOVED***:
    ***REMOVED***
    Takes a list of dicts, returns that list sorted in reverse order by the
    property given in the argument.
    ***REMOVED***
    ***REMOVED***
        return sorted(value, key=_property_resolver(arg***REMOVED***, reverse=True***REMOVED***
    except (TypeError, VariableDoesNotExist***REMOVED***:
        return ''


@register.filter(is_safe=False***REMOVED***
def first(value***REMOVED***:
    ***REMOVED***Returns the first item in a list.***REMOVED***
    ***REMOVED***
        return value[0***REMOVED***
    except IndexError:
        return ''


@register.filter(is_safe=True, needs_autoescape=True***REMOVED***
def join(value, arg, autoescape=True***REMOVED***:
    ***REMOVED***
    Joins a list with a string, like Python's ``str.join(list***REMOVED***``.
    ***REMOVED***
    value = map(force_text, value***REMOVED***
    if autoescape:
        value = [conditional_escape(v***REMOVED*** for v in value***REMOVED***
    ***REMOVED***
        data = conditional_escape(arg***REMOVED***.join(value***REMOVED***
    except AttributeError:  # fail silently but nicely
        return value
    return mark_safe(data***REMOVED***


@register.filter(is_safe=True***REMOVED***
def last(value***REMOVED***:
    "Returns the last item in a list"
    ***REMOVED***
        return value[-1***REMOVED***
    except IndexError:
        return ''


@register.filter(is_safe=False***REMOVED***
def length(value***REMOVED***:
    ***REMOVED***Returns the length of the value - useful for lists.***REMOVED***
    ***REMOVED***
        return len(value***REMOVED***
    except (ValueError, TypeError***REMOVED***:
        return 0


@register.filter(is_safe=False***REMOVED***
def length_is(value, arg***REMOVED***:
    ***REMOVED***Returns a boolean of whether the value's length is the argument.***REMOVED***
    ***REMOVED***
        return len(value***REMOVED*** == int(arg***REMOVED***
    except (ValueError, TypeError***REMOVED***:
        return ''


@register.filter(is_safe=True***REMOVED***
def random(value***REMOVED***:
    ***REMOVED***Returns a random item from the list.***REMOVED***
    return random_module.choice(value***REMOVED***


@register.filter("slice", is_safe=True***REMOVED***
def slice_filter(value, arg***REMOVED***:
    ***REMOVED***
    Returns a slice of the list.

    Uses the same syntax as Python's list slicing; see
    http://www.diveintopython3.net/native-datatypes.html#slicinglists
    for an introduction.
    ***REMOVED***
    ***REMOVED***
        bits = [***REMOVED***
        for x in arg.split(':'***REMOVED***:
            if len(x***REMOVED*** == 0:
                bits.append(None***REMOVED***
            else:
                bits.append(int(x***REMOVED******REMOVED***
        return value[slice(*bits***REMOVED******REMOVED***

    except (ValueError, TypeError***REMOVED***:
        return value  # Fail silently.


@register.filter(is_safe=True, needs_autoescape=True***REMOVED***
def unordered_list(value, autoescape=True***REMOVED***:
    ***REMOVED***
    Recursively takes a self-nested list and returns an HTML unordered list --
    WITHOUT opening and closing <ul> tags.

    The list is assumed to be in the proper format. For example, if ``var``
    contains: ``['States', ['Kansas', ['Lawrence', 'Topeka'***REMOVED***, 'Illinois'***REMOVED******REMOVED***``,
    then ``{{ var|unordered_list ***REMOVED******REMOVED***`` would return::

        <li>States
        <ul>
                <li>Kansas
                <ul>
                        <li>Lawrence</li>
                        <li>Topeka</li>
                </ul>
                </li>
                <li>Illinois</li>
        </ul>
        </li>
    ***REMOVED***
    if autoescape:
        escaper = conditional_escape
    else:
        def escaper(x***REMOVED***:
            return x

    def walk_items(item_list***REMOVED***:
        item_iterator = iter(item_list***REMOVED***
        ***REMOVED***
            item = next(item_iterator***REMOVED***
            while True:
                ***REMOVED***
                    next_item = next(item_iterator***REMOVED***
                except StopIteration:
                    yield item, None
                    break
                if not isinstance(next_item, six.string_types***REMOVED***:
                    ***REMOVED***
                        iter(next_item***REMOVED***
                    except TypeError:
                        pass
                    else:
                        yield item, next_item
                        item = next(item_iterator***REMOVED***
                        continue
                yield item, None
                item = next_item
        except StopIteration:
            pass

    def list_formatter(item_list, tabs=1***REMOVED***:
        indent = '\t' * tabs
        output = [***REMOVED***
        for item, children in walk_items(item_list***REMOVED***:
            sublist = ''
            if children:
                sublist = '\n%s<ul>\n%s\n%s</ul>\n%s' % (
                    indent, list_formatter(children, tabs + 1***REMOVED***, indent, indent***REMOVED***
            output.append('%s<li>%s%s</li>' % (
                indent, escaper(force_text(item***REMOVED******REMOVED***, sublist***REMOVED******REMOVED***
        return '\n'.join(output***REMOVED***

    return mark_safe(list_formatter(value***REMOVED******REMOVED***


###################
# INTEGERS        #
###################

@register.filter(is_safe=False***REMOVED***
def add(value, arg***REMOVED***:
    ***REMOVED***Adds the arg to the value.***REMOVED***
    ***REMOVED***
        return int(value***REMOVED*** + int(arg***REMOVED***
    except (ValueError, TypeError***REMOVED***:
        ***REMOVED***
            return value + arg
        except Exception:
            return ''


@register.filter(is_safe=False***REMOVED***
def get_digit(value, arg***REMOVED***:
    ***REMOVED***
    Given a whole number, returns the requested digit of it, where 1 is the
    right-most digit, 2 is the second-right-most digit, etc. Returns the
    original value for invalid input (if input or argument is not an integer,
    or if argument is less than 1***REMOVED***. Otherwise, output is always an integer.
    ***REMOVED***
    ***REMOVED***
        arg = int(arg***REMOVED***
        value = int(value***REMOVED***
    except ValueError:
        return value  # Fail silently for an invalid argument
    if arg < 1:
        return value
    ***REMOVED***
        return int(str(value***REMOVED***[-arg***REMOVED******REMOVED***
    except IndexError:
        return 0


###################
# DATES           #
###################

@register.filter(expects_localtime=True, is_safe=False***REMOVED***
def date(value, arg=None***REMOVED***:
    ***REMOVED***Formats a date according to the given format.***REMOVED***
    if value in (None, ''***REMOVED***:
        return ''
    ***REMOVED***
        return formats.date_format(value, arg***REMOVED***
    except AttributeError:
        ***REMOVED***
            return format(value, arg***REMOVED***
        except AttributeError:
            return ''


@register.filter(expects_localtime=True, is_safe=False***REMOVED***
def time(value, arg=None***REMOVED***:
    ***REMOVED***Formats a time according to the given format.***REMOVED***
    if value in (None, ''***REMOVED***:
        return ''
    ***REMOVED***
        return formats.time_format(value, arg***REMOVED***
    except (AttributeError, TypeError***REMOVED***:
        ***REMOVED***
            return time_format(value, arg***REMOVED***
        except (AttributeError, TypeError***REMOVED***:
            return ''


@register.filter("timesince", is_safe=False***REMOVED***
def timesince_filter(value, arg=None***REMOVED***:
    ***REMOVED***Formats a date as the time since that date (i.e. "4 days, 6 hours"***REMOVED***.***REMOVED***
    if not value:
        return ''
    ***REMOVED***
        if arg:
            return timesince(value, arg***REMOVED***
        return timesince(value***REMOVED***
    except (ValueError, TypeError***REMOVED***:
        return ''


@register.filter("timeuntil", is_safe=False***REMOVED***
def timeuntil_filter(value, arg=None***REMOVED***:
    ***REMOVED***Formats a date as the time until that date (i.e. "4 days, 6 hours"***REMOVED***.***REMOVED***
    if not value:
        return ''
    ***REMOVED***
        return timeuntil(value, arg***REMOVED***
    except (ValueError, TypeError***REMOVED***:
        return ''


###################
# LOGIC           #
###################

@register.filter(is_safe=False***REMOVED***
def default(value, arg***REMOVED***:
    ***REMOVED***If value is unavailable, use given default.***REMOVED***
    return value or arg


@register.filter(is_safe=False***REMOVED***
def default_if_none(value, arg***REMOVED***:
    ***REMOVED***If value is None, use given default.***REMOVED***
    if value is None:
        return arg
    return value


@register.filter(is_safe=False***REMOVED***
def divisibleby(value, arg***REMOVED***:
    ***REMOVED***Returns True if the value is divisible by the argument.***REMOVED***
    return int(value***REMOVED*** % int(arg***REMOVED*** == 0


@register.filter(is_safe=False***REMOVED***
def yesno(value, arg=None***REMOVED***:
    ***REMOVED***
    Given a string mapping values for true, false and (optionally***REMOVED*** None,
    returns one of those strings according to the value:

    ==========  ======================  ==================================
    Value       Argument                Outputs
    ==========  ======================  ==================================
    ``True``    ``"yeah,no,maybe"``     ``yeah``
    ``False``   ``"yeah,no,maybe"``     ``no``
    ``None``    ``"yeah,no,maybe"``     ``maybe``
    ``None``    ``"yeah,no"``           ``"no"`` (converts None to False
                                        if no mapping for None is given.
    ==========  ======================  ==================================
    ***REMOVED***
    if arg is None:
        arg = ugettext('yes,no,maybe'***REMOVED***
    bits = arg.split(','***REMOVED***
    if len(bits***REMOVED*** < 2:
        return value  # Invalid arg.
    ***REMOVED***
        yes, no, maybe = bits
    except ValueError:
        # Unpack list of wrong size (no "maybe" value provided***REMOVED***.
        yes, no, maybe = bits[0***REMOVED***, bits[1***REMOVED***, bits[1***REMOVED***
    if value is None:
        return maybe
    if value:
        return yes
    return no


###################
# MISC            #
###################

@register.filter(is_safe=True***REMOVED***
def filesizeformat(bytes_***REMOVED***:
    ***REMOVED***
    Formats the value like a 'human-readable' file size (i.e. 13 KB, 4.1 MB,
    102 bytes, etc.***REMOVED***.
    ***REMOVED***
    ***REMOVED***
        bytes_ = float(bytes_***REMOVED***
    except (TypeError, ValueError, UnicodeDecodeError***REMOVED***:
        value = ungettext("%(size***REMOVED***d byte", "%(size***REMOVED***d bytes", 0***REMOVED*** % {'size': 0***REMOVED***
        return avoid_wrapping(value***REMOVED***

    def filesize_number_format(value***REMOVED***:
        return formats.number_format(round(value, 1***REMOVED***, 1***REMOVED***

    KB = 1 << 10
    MB = 1 << 20
    GB = 1 << 30
    TB = 1 << 40
    PB = 1 << 50

    negative = bytes_ < 0
    if negative:
        bytes_ = -bytes_  # Allow formatting of negative numbers.

    if bytes_ < KB:
        value = ungettext("%(size***REMOVED***d byte", "%(size***REMOVED***d bytes", bytes_***REMOVED*** % {'size': bytes_***REMOVED***
    elif bytes_ < MB:
        value = ugettext("%s KB"***REMOVED*** % filesize_number_format(bytes_ / KB***REMOVED***
    elif bytes_ < GB:
        value = ugettext("%s MB"***REMOVED*** % filesize_number_format(bytes_ / MB***REMOVED***
    elif bytes_ < TB:
        value = ugettext("%s GB"***REMOVED*** % filesize_number_format(bytes_ / GB***REMOVED***
    elif bytes_ < PB:
        value = ugettext("%s TB"***REMOVED*** % filesize_number_format(bytes_ / TB***REMOVED***
    else:
        value = ugettext("%s PB"***REMOVED*** % filesize_number_format(bytes_ / PB***REMOVED***

    if negative:
        value = "-%s" % value
    return avoid_wrapping(value***REMOVED***


@register.filter(is_safe=False***REMOVED***
def pluralize(value, arg='s'***REMOVED***:
    ***REMOVED***
    Returns a plural suffix if the value is not 1. By default, 's' is used as
    the suffix:

    * If value is 0, vote{{ value|pluralize ***REMOVED******REMOVED*** displays "0 votes".
    * If value is 1, vote{{ value|pluralize ***REMOVED******REMOVED*** displays "1 vote".
    * If value is 2, vote{{ value|pluralize ***REMOVED******REMOVED*** displays "2 votes".

    If an argument is provided, that string is used instead:

    * If value is 0, class{{ value|pluralize:"es" ***REMOVED******REMOVED*** displays "0 classes".
    * If value is 1, class{{ value|pluralize:"es" ***REMOVED******REMOVED*** displays "1 class".
    * If value is 2, class{{ value|pluralize:"es" ***REMOVED******REMOVED*** displays "2 classes".

    If the provided argument contains a comma, the text before the comma is
    used for the singular case and the text after the comma is used for the
    plural case:

    * If value is 0, cand{{ value|pluralize:"y,ies" ***REMOVED******REMOVED*** displays "0 candies".
    * If value is 1, cand{{ value|pluralize:"y,ies" ***REMOVED******REMOVED*** displays "1 candy".
    * If value is 2, cand{{ value|pluralize:"y,ies" ***REMOVED******REMOVED*** displays "2 candies".
    ***REMOVED***
    if ',' not in arg:
        arg = ',' + arg
    bits = arg.split(','***REMOVED***
    if len(bits***REMOVED*** > 2:
        return ''
    singular_suffix, plural_suffix = bits[:2***REMOVED***

    ***REMOVED***
        if float(value***REMOVED*** != 1:
            return plural_suffix
    except ValueError:  # Invalid string that's not a number.
        pass
    except TypeError:  # Value isn't a string or a number; maybe it's a list?
        ***REMOVED***
            if len(value***REMOVED*** != 1:
                return plural_suffix
        except TypeError:  # len(***REMOVED*** of unsized object.
            pass
    return singular_suffix


@register.filter("phone2numeric", is_safe=True***REMOVED***
def phone2numeric_filter(value***REMOVED***:
    ***REMOVED***Takes a phone number and converts it in to its numerical equivalent.***REMOVED***
    return phone2numeric(value***REMOVED***


@register.filter(is_safe=True***REMOVED***
def pprint(value***REMOVED***:
    ***REMOVED***A wrapper around pprint.pprint -- for debugging, really.***REMOVED***
    ***REMOVED***
        return pformat(value***REMOVED***
    except Exception as e:
        return "Error in formatting: %s: %s" % (e.__class__.__name__, force_text(e, errors="replace"***REMOVED******REMOVED***
