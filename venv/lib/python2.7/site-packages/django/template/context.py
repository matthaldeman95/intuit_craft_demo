import warnings
from contextlib import contextmanager
from copy import copy

from django.utils.deprecation import RemovedInDjango20Warning

# Hard-coded processor for easier use of CSRF protection.
_builtin_context_processors = ('django.template.context_processors.csrf',***REMOVED***


class ContextPopException(Exception***REMOVED***:
    "pop(***REMOVED*** has been called more times than push(***REMOVED***"
    pass


class ContextDict(dict***REMOVED***:
    def __init__(self, context, *args, **kwargs***REMOVED***:
        super(ContextDict, self***REMOVED***.__init__(*args, **kwargs***REMOVED***

        context.dicts.append(self***REMOVED***
        self.context = context

    def __enter__(self***REMOVED***:
        return self

    def __exit__(self, *args, **kwargs***REMOVED***:
        self.context.pop(***REMOVED***


class BaseContext(object***REMOVED***:
    def __init__(self, dict_=None***REMOVED***:
        self._reset_dicts(dict_***REMOVED***

    def _reset_dicts(self, value=None***REMOVED***:
        builtins = {'True': True, 'False': False, 'None': None***REMOVED***
        self.dicts = [builtins***REMOVED***
        if value is not None:
            self.dicts.append(value***REMOVED***

    def __copy__(self***REMOVED***:
        duplicate = copy(super(BaseContext, self***REMOVED******REMOVED***
        duplicate.dicts = self.dicts[:***REMOVED***
        return duplicate

    def __repr__(self***REMOVED***:
        return repr(self.dicts***REMOVED***

    def __iter__(self***REMOVED***:
        for d in reversed(self.dicts***REMOVED***:
            yield d

    def push(self, *args, **kwargs***REMOVED***:
        dicts = [***REMOVED***
        for d in args:
            if isinstance(d, BaseContext***REMOVED***:
                dicts += d.dicts[1:***REMOVED***
            else:
                dicts.append(d***REMOVED***
        return ContextDict(self, *dicts, **kwargs***REMOVED***

    def pop(self***REMOVED***:
        if len(self.dicts***REMOVED*** == 1:
            raise ContextPopException
        return self.dicts.pop(***REMOVED***

    def __setitem__(self, key, value***REMOVED***:
        "Set a variable in the current context"
        self.dicts[-1***REMOVED***[key***REMOVED*** = value

    def __getitem__(self, key***REMOVED***:
        "Get a variable's value, starting at the current context and going upward"
        for d in reversed(self.dicts***REMOVED***:
            if key in d:
                return d[key***REMOVED***
        raise KeyError(key***REMOVED***

    def __delitem__(self, key***REMOVED***:
        "Delete a variable from the current context"
        del self.dicts[-1***REMOVED***[key***REMOVED***

    def has_key(self, key***REMOVED***:
        warnings.warn(
            "%s.has_key(***REMOVED*** is deprecated in favor of the 'in' operator." % self.__class__.__name__,
            RemovedInDjango20Warning
        ***REMOVED***
        return key in self

    def __contains__(self, key***REMOVED***:
        for d in self.dicts:
            if key in d:
                return True
        return False

    def get(self, key, otherwise=None***REMOVED***:
        for d in reversed(self.dicts***REMOVED***:
            if key in d:
                return d[key***REMOVED***
        return otherwise

    def setdefault(self, key, default=None***REMOVED***:
        ***REMOVED***
            return self[key***REMOVED***
        except KeyError:
            self[key***REMOVED*** = default
        return default

    def new(self, values=None***REMOVED***:
        ***REMOVED***
        Returns a new context with the same properties, but with only the
        values given in 'values' stored.
        ***REMOVED***
        new_context = copy(self***REMOVED***
        new_context._reset_dicts(values***REMOVED***
        return new_context

    def flatten(self***REMOVED***:
        ***REMOVED***
        Returns self.dicts as one dictionary
        ***REMOVED***
        flat = {***REMOVED***
        for d in self.dicts:
            flat.update(d***REMOVED***
        return flat

    def __eq__(self, other***REMOVED***:
        ***REMOVED***
        Compares two contexts by comparing theirs 'dicts' attributes.
        ***REMOVED***
        if isinstance(other, BaseContext***REMOVED***:
            # because dictionaries can be put in different order
            # we have to flatten them like in templates
            return self.flatten(***REMOVED*** == other.flatten(***REMOVED***

        # if it's not comparable return false
        return False


class Context(BaseContext***REMOVED***:
    "A stack container for variable context"
    def __init__(self, dict_=None, autoescape=True, use_l10n=None, use_tz=None***REMOVED***:
        self.autoescape = autoescape
        self.use_l10n = use_l10n
        self.use_tz = use_tz
        self.template_name = "unknown"
        self.render_context = RenderContext(***REMOVED***
        # Set to the original template -- as opposed to extended or included
        # templates -- during rendering, see bind_template.
        self.template = None
        super(Context, self***REMOVED***.__init__(dict_***REMOVED***

    @contextmanager
    def bind_template(self, template***REMOVED***:
        if self.template is not None:
            raise RuntimeError("Context is already bound to a template"***REMOVED***
        self.template = template
        ***REMOVED***
            yield
        finally:
            self.template = None

    def __copy__(self***REMOVED***:
        duplicate = super(Context, self***REMOVED***.__copy__(***REMOVED***
        duplicate.render_context = copy(self.render_context***REMOVED***
        return duplicate

    def update(self, other_dict***REMOVED***:
        "Pushes other_dict to the stack of dictionaries in the Context"
        if not hasattr(other_dict, '__getitem__'***REMOVED***:
            raise TypeError('other_dict must be a mapping (dictionary-like***REMOVED*** object.'***REMOVED***
        if isinstance(other_dict, BaseContext***REMOVED***:
            other_dict = other_dict.dicts[1:***REMOVED***.pop(***REMOVED***
        return ContextDict(self, other_dict***REMOVED***


class RenderContext(BaseContext***REMOVED***:
    ***REMOVED***
    A stack container for storing Template state.

    RenderContext simplifies the implementation of template Nodes by providing a
    safe place to store state between invocations of a node's `render` method.

    The RenderContext also provides scoping rules that are more sensible for
    'template local' variables. The render context stack is pushed before each
    template is rendered, creating a fresh scope with nothing in it. Name
    resolution fails if a variable is not found at the top of the RequestContext
    stack. Thus, variables are local to a specific template and don't affect the
    rendering of other templates as they would if they were stored in the normal
    template context.
    ***REMOVED***
    def __iter__(self***REMOVED***:
        for d in self.dicts[-1***REMOVED***:
            yield d

    def __contains__(self, key***REMOVED***:
        return key in self.dicts[-1***REMOVED***

    def get(self, key, otherwise=None***REMOVED***:
        return self.dicts[-1***REMOVED***.get(key, otherwise***REMOVED***

    def __getitem__(self, key***REMOVED***:
        return self.dicts[-1***REMOVED***[key***REMOVED***


class RequestContext(Context***REMOVED***:
    ***REMOVED***
    This subclass of template.Context automatically populates itself using
    the processors defined in the engine's configuration.
    Additional processors can be specified as a list of callables
    using the "processors" keyword argument.
    ***REMOVED***
    def __init__(self, request, dict_=None, processors=None, use_l10n=None, use_tz=None, autoescape=True***REMOVED***:
        super(RequestContext, self***REMOVED***.__init__(
            dict_, use_l10n=use_l10n, use_tz=use_tz, autoescape=autoescape***REMOVED***
        self.request = request
        self._processors = (***REMOVED*** if processors is None else tuple(processors***REMOVED***
        self._processors_index = len(self.dicts***REMOVED***

        # placeholder for context processors output
        self.update({***REMOVED******REMOVED***

        # empty dict for any new modifications
        # (so that context processors don't overwrite them***REMOVED***
        self.update({***REMOVED******REMOVED***

    @contextmanager
    def bind_template(self, template***REMOVED***:
        if self.template is not None:
            raise RuntimeError("Context is already bound to a template"***REMOVED***

        self.template = template
        # Set context processors according to the template engine's settings.
        processors = (template.engine.template_context_processors +
                      self._processors***REMOVED***
        updates = {***REMOVED***
        for processor in processors:
            updates.update(processor(self.request***REMOVED******REMOVED***
        self.dicts[self._processors_index***REMOVED*** = updates

        ***REMOVED***
            yield
        finally:
            self.template = None
            # Unset context processors.
            self.dicts[self._processors_index***REMOVED*** = {***REMOVED***

    def new(self, values=None***REMOVED***:
        new_context = super(RequestContext, self***REMOVED***.new(values***REMOVED***
        # This is for backwards-compatibility: RequestContexts created via
        # Context.new don't include values from context processors.
        if hasattr(new_context, '_processors_index'***REMOVED***:
            del new_context._processors_index
        return new_context


def make_context(context, request=None, **kwargs***REMOVED***:
    ***REMOVED***
    Create a suitable Context from a plain dict and optionally an HttpRequest.
    ***REMOVED***
    if request is None:
        context = Context(context, **kwargs***REMOVED***
    else:
        # The following pattern is required to ensure values from
        # context override those from template context processors.
        original_context = context
        context = RequestContext(request, **kwargs***REMOVED***
        if original_context:
            context.push(original_context***REMOVED***
    return context
