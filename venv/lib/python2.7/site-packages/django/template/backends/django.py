# Since this package contains a "django" module, this is required on Python 2.
from __future__ import absolute_import

import sys
from importlib import import_module
from pkgutil import walk_packages

from django.apps import apps
from django.conf import settings
from django.template import TemplateDoesNotExist
from django.template.context import make_context
from django.template.engine import Engine
from django.template.library import InvalidTemplateLibrary
from django.utils import six

from .base import BaseEngine


class DjangoTemplates(BaseEngine***REMOVED***:

    app_dirname = 'templates'

    def __init__(self, params***REMOVED***:
        params = params.copy(***REMOVED***
        options = params.pop('OPTIONS'***REMOVED***.copy(***REMOVED***
        options.setdefault('autoescape', True***REMOVED***
        options.setdefault('debug', settings.DEBUG***REMOVED***
        options.setdefault('file_charset', settings.FILE_CHARSET***REMOVED***
        libraries = options.get('libraries', {***REMOVED******REMOVED***
        options['libraries'***REMOVED*** = self.get_templatetag_libraries(libraries***REMOVED***
        super(DjangoTemplates, self***REMOVED***.__init__(params***REMOVED***
        self.engine = Engine(self.dirs, self.app_dirs, **options***REMOVED***

    def from_string(self, template_code***REMOVED***:
        return Template(self.engine.from_string(template_code***REMOVED***, self***REMOVED***

    def get_template(self, template_name***REMOVED***:
        ***REMOVED***
            return Template(self.engine.get_template(template_name***REMOVED***, self***REMOVED***
        except TemplateDoesNotExist as exc:
            reraise(exc, self***REMOVED***

    def get_templatetag_libraries(self, custom_libraries***REMOVED***:
        ***REMOVED***
        Return a collation of template tag libraries from installed
        applications and the supplied custom_libraries argument.
        ***REMOVED***
        libraries = get_installed_libraries(***REMOVED***
        libraries.update(custom_libraries***REMOVED***
        return libraries


class Template(object***REMOVED***:

    def __init__(self, template, backend***REMOVED***:
        self.template = template
        self.backend = backend

    @property
    def origin(self***REMOVED***:
        return self.template.origin

    def render(self, context=None, request=None***REMOVED***:
        context = make_context(context, request, autoescape=self.backend.engine.autoescape***REMOVED***
        ***REMOVED***
            return self.template.render(context***REMOVED***
        except TemplateDoesNotExist as exc:
            reraise(exc, self.backend***REMOVED***


def copy_exception(exc, backend=None***REMOVED***:
    ***REMOVED***
    Create a new TemplateDoesNotExist. Preserve its declared attributes and
    template debug data but discard __traceback__, __context__, and __cause__
    to make this object suitable for keeping around (in a cache, for example***REMOVED***.
    ***REMOVED***
    backend = backend or exc.backend
    new = exc.__class__(*exc.args, tried=exc.tried, backend=backend, chain=exc.chain***REMOVED***
    if hasattr(exc, 'template_debug'***REMOVED***:
        new.template_debug = exc.template_debug
    return new


def reraise(exc, backend***REMOVED***:
    ***REMOVED***
    Reraise TemplateDoesNotExist while maintaining template debug information.
    ***REMOVED***
    new = copy_exception(exc, backend***REMOVED***
    six.reraise(exc.__class__, new, sys.exc_info(***REMOVED***[2***REMOVED******REMOVED***


def get_installed_libraries(***REMOVED***:
    ***REMOVED***
    Return the built-in template tag libraries and those from installed
    applications. Libraries are stored in a dictionary where keys are the
    individual module names, not the full module paths. Example:
    django.templatetags.i18n is stored as i18n.
    ***REMOVED***
    libraries = {***REMOVED***
    candidates = ['django.templatetags'***REMOVED***
    candidates.extend(
        '%s.templatetags' % app_config.name
        for app_config in apps.get_app_configs(***REMOVED******REMOVED***

    for candidate in candidates:
        ***REMOVED***
            pkg = import_module(candidate***REMOVED***
        except ImportError:
            # No templatetags package defined. This is safe to ignore.
            continue

        if hasattr(pkg, '__path__'***REMOVED***:
            for name in get_package_libraries(pkg***REMOVED***:
                libraries[name[len(candidate***REMOVED*** + 1:***REMOVED******REMOVED*** = name

    return libraries


def get_package_libraries(pkg***REMOVED***:
    ***REMOVED***
    Recursively yield template tag libraries defined in submodules of a
    package.
    ***REMOVED***
    for entry in walk_packages(pkg.__path__, pkg.__name__ + '.'***REMOVED***:
        ***REMOVED***
            module = import_module(entry[1***REMOVED******REMOVED***
        except ImportError as e:
            raise InvalidTemplateLibrary(
                "Invalid template library specified. ImportError raised when "
                "trying to load '%s': %s" % (entry[1***REMOVED***, e***REMOVED***
            ***REMOVED***

        if hasattr(module, 'register'***REMOVED***:
            yield entry[1***REMOVED***
