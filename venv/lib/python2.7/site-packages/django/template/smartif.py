***REMOVED***
Parser and utilities for the smart 'if' tag
***REMOVED***
# Using a simple top down parser, as described here:
#    http://effbot.org/zone/simple-top-down-parsing.htm.
# 'led' = left denotation
# 'nud' = null denotation
# 'bp' = binding power (left = lbp, right = rbp***REMOVED***


class TokenBase(object***REMOVED***:
    ***REMOVED***
    Base class for operators and literals, mainly for debugging and for throwing
    syntax errors.
    ***REMOVED***
    id = None  # node/token type name
    value = None  # used by literals
    first = second = None  # used by tree nodes

    def nud(self, parser***REMOVED***:
        # Null denotation - called in prefix context
        raise parser.error_class(
            "Not expecting '%s' in this position in if tag." % self.id
        ***REMOVED***

    def led(self, left, parser***REMOVED***:
        # Left denotation - called in infix context
        raise parser.error_class(
            "Not expecting '%s' as infix operator in if tag." % self.id
        ***REMOVED***

    def display(self***REMOVED***:
        ***REMOVED***
        Returns what to display in error messages for this node
        ***REMOVED***
        return self.id

    def __repr__(self***REMOVED***:
        out = [str(x***REMOVED*** for x in [self.id, self.first, self.second***REMOVED*** if x is not None***REMOVED***
        return "(" + " ".join(out***REMOVED*** + "***REMOVED***"


def infix(bp, func***REMOVED***:
    ***REMOVED***
    Creates an infix operator, given a binding power and a function that
    evaluates the node
    ***REMOVED***
    class Operator(TokenBase***REMOVED***:
        lbp = bp

        def led(self, left, parser***REMOVED***:
            self.first = left
            self.second = parser.expression(bp***REMOVED***
            return self

        def eval(self, context***REMOVED***:
            ***REMOVED***
                return func(context, self.first, self.second***REMOVED***
            except Exception:
                # Templates shouldn't throw exceptions when rendering.  We are
                # most likely to get exceptions for things like {% if foo in bar
                # %***REMOVED*** where 'bar' does not support 'in', so default to False
                return False

    return Operator


def prefix(bp, func***REMOVED***:
    ***REMOVED***
    Creates a prefix operator, given a binding power and a function that
    evaluates the node.
    ***REMOVED***
    class Operator(TokenBase***REMOVED***:
        lbp = bp

        def nud(self, parser***REMOVED***:
            self.first = parser.expression(bp***REMOVED***
            self.second = None
            return self

        def eval(self, context***REMOVED***:
            ***REMOVED***
                return func(context, self.first***REMOVED***
            except Exception:
                return False

    return Operator


# Operator precedence follows Python.
# We defer variable evaluation to the lambda to ensure that terms are
# lazily evaluated using Python's boolean parsing logic.
OPERATORS = {
    'or': infix(6, lambda context, x, y: x.eval(context***REMOVED*** or y.eval(context***REMOVED******REMOVED***,
    'and': infix(7, lambda context, x, y: x.eval(context***REMOVED*** and y.eval(context***REMOVED******REMOVED***,
    'not': prefix(8, lambda context, x: not x.eval(context***REMOVED******REMOVED***,
    'in': infix(9, lambda context, x, y: x.eval(context***REMOVED*** in y.eval(context***REMOVED******REMOVED***,
    'not in': infix(9, lambda context, x, y: x.eval(context***REMOVED*** not in y.eval(context***REMOVED******REMOVED***,
    'is': infix(10, lambda context, x, y: x.eval(context***REMOVED*** is y.eval(context***REMOVED******REMOVED***,
    'is not': infix(10, lambda context, x, y: x.eval(context***REMOVED*** is not y.eval(context***REMOVED******REMOVED***,
    '==': infix(10, lambda context, x, y: x.eval(context***REMOVED*** == y.eval(context***REMOVED******REMOVED***,
    '!=': infix(10, lambda context, x, y: x.eval(context***REMOVED*** != y.eval(context***REMOVED******REMOVED***,
    '>': infix(10, lambda context, x, y: x.eval(context***REMOVED*** > y.eval(context***REMOVED******REMOVED***,
    '>=': infix(10, lambda context, x, y: x.eval(context***REMOVED*** >= y.eval(context***REMOVED******REMOVED***,
    '<': infix(10, lambda context, x, y: x.eval(context***REMOVED*** < y.eval(context***REMOVED******REMOVED***,
    '<=': infix(10, lambda context, x, y: x.eval(context***REMOVED*** <= y.eval(context***REMOVED******REMOVED***,
***REMOVED***

# Assign 'id' to each:
for key, op in OPERATORS.items(***REMOVED***:
    op.id = key


class Literal(TokenBase***REMOVED***:
    ***REMOVED***
    A basic self-resolvable object similar to a Django template variable.
    ***REMOVED***
    # IfParser uses Literal in create_var, but TemplateIfParser overrides
    # create_var so that a proper implementation that actually resolves
    # variables, filters etc. is used.
    id = "literal"
    lbp = 0

    def __init__(self, value***REMOVED***:
        self.value = value

    def display(self***REMOVED***:
        return repr(self.value***REMOVED***

    def nud(self, parser***REMOVED***:
        return self

    def eval(self, context***REMOVED***:
        return self.value

    def __repr__(self***REMOVED***:
        return "(%s %r***REMOVED***" % (self.id, self.value***REMOVED***


class EndToken(TokenBase***REMOVED***:
    lbp = 0

    def nud(self, parser***REMOVED***:
        raise parser.error_class("Unexpected end of expression in if tag."***REMOVED***

EndToken = EndToken(***REMOVED***


class IfParser(object***REMOVED***:
    error_class = ValueError

    def __init__(self, tokens***REMOVED***:
        # Turn 'is','not' and 'not','in' into single tokens.
        l = len(tokens***REMOVED***
        mapped_tokens = [***REMOVED***
        i = 0
        while i < l:
            token = tokens[i***REMOVED***
            if token == "is" and i + 1 < l and tokens[i + 1***REMOVED*** == "not":
                token = "is not"
                i += 1  # skip 'not'
            elif token == "not" and i + 1 < l and tokens[i + 1***REMOVED*** == "in":
                token = "not in"
                i += 1  # skip 'in'
            mapped_tokens.append(self.translate_token(token***REMOVED******REMOVED***
            i += 1

        self.tokens = mapped_tokens
        self.pos = 0
        self.current_token = self.next_token(***REMOVED***

    def translate_token(self, token***REMOVED***:
        ***REMOVED***
            op = OPERATORS[token***REMOVED***
        except (KeyError, TypeError***REMOVED***:
            return self.create_var(token***REMOVED***
        else:
            return op(***REMOVED***

    def next_token(self***REMOVED***:
        if self.pos >= len(self.tokens***REMOVED***:
            return EndToken
        else:
            retval = self.tokens[self.pos***REMOVED***
            self.pos += 1
            return retval

    def parse(self***REMOVED***:
        retval = self.expression(***REMOVED***
        # Check that we have exhausted all the tokens
        if self.current_token is not EndToken:
            raise self.error_class("Unused '%s' at end of if expression." %
                                   self.current_token.display(***REMOVED******REMOVED***
        return retval

    def expression(self, rbp=0***REMOVED***:
        t = self.current_token
        self.current_token = self.next_token(***REMOVED***
        left = t.nud(self***REMOVED***
        while rbp < self.current_token.lbp:
            t = self.current_token
            self.current_token = self.next_token(***REMOVED***
            left = t.led(left, self***REMOVED***
        return left

    def create_var(self, value***REMOVED***:
        return Literal(value***REMOVED***
