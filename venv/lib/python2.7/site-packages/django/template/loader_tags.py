import logging
import posixpath
from collections import defaultdict

from django.utils import six
from django.utils.safestring import mark_safe

from .base import (
    Node, Template, TemplateSyntaxError, TextNode, Variable, token_kwargs,
***REMOVED***
from .library import Library

register = Library(***REMOVED***

BLOCK_CONTEXT_KEY = 'block_context'

logger = logging.getLogger('django.template'***REMOVED***


class ExtendsError(Exception***REMOVED***:
    pass


class BlockContext(object***REMOVED***:
    def __init__(self***REMOVED***:
        # Dictionary of FIFO queues.
        self.blocks = defaultdict(list***REMOVED***

    def add_blocks(self, blocks***REMOVED***:
        for name, block in six.iteritems(blocks***REMOVED***:
            self.blocks[name***REMOVED***.insert(0, block***REMOVED***

    def pop(self, name***REMOVED***:
        ***REMOVED***
            return self.blocks[name***REMOVED***.pop(***REMOVED***
        except IndexError:
            return None

    def push(self, name, block***REMOVED***:
        self.blocks[name***REMOVED***.append(block***REMOVED***

    def get_block(self, name***REMOVED***:
        ***REMOVED***
            return self.blocks[name***REMOVED***[-1***REMOVED***
        except IndexError:
            return None


class BlockNode(Node***REMOVED***:
    def __init__(self, name, nodelist, parent=None***REMOVED***:
        self.name, self.nodelist, self.parent = name, nodelist, parent

    def __repr__(self***REMOVED***:
        return "<Block Node: %s. Contents: %r>" % (self.name, self.nodelist***REMOVED***

    def render(self, context***REMOVED***:
        block_context = context.render_context.get(BLOCK_CONTEXT_KEY***REMOVED***
        with context.push(***REMOVED***:
            if block_context is None:
                context['block'***REMOVED*** = self
                result = self.nodelist.render(context***REMOVED***
            else:
                push = block = block_context.pop(self.name***REMOVED***
                if block is None:
                    block = self
                # Create new block so we can store context without thread-safety issues.
                block = type(self***REMOVED***(block.name, block.nodelist***REMOVED***
                block.context = context
                context['block'***REMOVED*** = block
                result = block.nodelist.render(context***REMOVED***
                if push is not None:
                    block_context.push(self.name, push***REMOVED***
        return result

    def super(self***REMOVED***:
        if not hasattr(self, 'context'***REMOVED***:
            raise TemplateSyntaxError(
                "'%s' object has no attribute 'context'. Did you use "
                "{{ block.super ***REMOVED******REMOVED*** in a base template?" % self.__class__.__name__
            ***REMOVED***
        render_context = self.context.render_context
        if (BLOCK_CONTEXT_KEY in render_context and
                render_context[BLOCK_CONTEXT_KEY***REMOVED***.get_block(self.name***REMOVED*** is not None***REMOVED***:
            return mark_safe(self.render(self.context***REMOVED******REMOVED***
        return ''


class ExtendsNode(Node***REMOVED***:
    must_be_first = True
    context_key = 'extends_context'

    def __init__(self, nodelist, parent_name, template_dirs=None***REMOVED***:
        self.nodelist = nodelist
        self.parent_name = parent_name
        self.template_dirs = template_dirs
        self.blocks = {n.name: n for n in nodelist.get_nodes_by_type(BlockNode***REMOVED******REMOVED***

    def __repr__(self***REMOVED***:
        return '<ExtendsNode: extends %s>' % self.parent_name.token

    def find_template(self, template_name, context***REMOVED***:
        ***REMOVED***
        This is a wrapper around engine.find_template(***REMOVED***. A history is kept in
        the render_context attribute between successive extends calls and
        passed as the skip argument. This enables extends to work recursively
        without extending the same template twice.
        ***REMOVED***
        # RemovedInDjango20Warning: If any non-recursive loaders are installed
        # do a direct template lookup. If the same template name appears twice,
        # raise an exception to avoid system recursion.
        for loader in context.template.engine.template_loaders:
            if not loader.supports_recursion:
                history = context.render_context.setdefault(
                    self.context_key, [context.template.origin.template_name***REMOVED***,
                ***REMOVED***
                if template_name in history:
                    raise ExtendsError(
                        "Cannot extend templates recursively when using "
                        "non-recursive template loaders",
                    ***REMOVED***
                template = context.template.engine.get_template(template_name***REMOVED***
                history.append(template_name***REMOVED***
                return template

        history = context.render_context.setdefault(
            self.context_key, [context.template.origin***REMOVED***,
        ***REMOVED***
        template, origin = context.template.engine.find_template(
            template_name, skip=history,
        ***REMOVED***
        history.append(origin***REMOVED***
        return template

    def get_parent(self, context***REMOVED***:
        parent = self.parent_name.resolve(context***REMOVED***
        if not parent:
            error_msg = "Invalid template name in 'extends' tag: %r." % parent
            if self.parent_name.filters or\
                    isinstance(self.parent_name.var, Variable***REMOVED***:
                error_msg += " Got this from the '%s' variable." %\
                    self.parent_name.token
            raise TemplateSyntaxError(error_msg***REMOVED***
        if isinstance(parent, Template***REMOVED***:
            # parent is a django.template.Template
            return parent
        if isinstance(getattr(parent, 'template', None***REMOVED***, Template***REMOVED***:
            # parent is a django.template.backends.django.Template
            return parent.template
        return self.find_template(parent, context***REMOVED***

    def render(self, context***REMOVED***:
        compiled_parent = self.get_parent(context***REMOVED***

        if BLOCK_CONTEXT_KEY not in context.render_context:
            context.render_context[BLOCK_CONTEXT_KEY***REMOVED*** = BlockContext(***REMOVED***
        block_context = context.render_context[BLOCK_CONTEXT_KEY***REMOVED***

        # Add the block nodes from this node to the block context
        block_context.add_blocks(self.blocks***REMOVED***

        # If this block's parent doesn't have an extends node it is the root,
        # and its block nodes also need to be added to the block context.
        for node in compiled_parent.nodelist:
            # The ExtendsNode has to be the first non-text node.
            if not isinstance(node, TextNode***REMOVED***:
                if not isinstance(node, ExtendsNode***REMOVED***:
                    blocks = {n.name: n for n in
                              compiled_parent.nodelist.get_nodes_by_type(BlockNode***REMOVED******REMOVED***
                    block_context.add_blocks(blocks***REMOVED***
                break

        # Call Template._render explicitly so the parser context stays
        # the same.
        return compiled_parent._render(context***REMOVED***


class IncludeNode(Node***REMOVED***:
    context_key = '__include_context'

    def __init__(self, template, *args, **kwargs***REMOVED***:
        self.template = template
        self.extra_context = kwargs.pop('extra_context', {***REMOVED******REMOVED***
        self.isolated_context = kwargs.pop('isolated_context', False***REMOVED***
        super(IncludeNode, self***REMOVED***.__init__(*args, **kwargs***REMOVED***

    def render(self, context***REMOVED***:
        ***REMOVED***
        Render the specified template and context. Cache the template object
        in render_context to avoid reparsing and loading when used in a for
        loop.
        ***REMOVED***
        ***REMOVED***
            template = self.template.resolve(context***REMOVED***
            # Does this quack like a Template?
            if not callable(getattr(template, 'render', None***REMOVED******REMOVED***:
                # If not, we'll try our cache, and get_template(***REMOVED***
                template_name = template
                cache = context.render_context.setdefault(self.context_key, {***REMOVED******REMOVED***
                template = cache.get(template_name***REMOVED***
                if template is None:
                    template = context.template.engine.get_template(template_name***REMOVED***
                    cache[template_name***REMOVED*** = template
            values = {
                name: var.resolve(context***REMOVED***
                for name, var in six.iteritems(self.extra_context***REMOVED***
        ***REMOVED***
            if self.isolated_context:
                return template.render(context.new(values***REMOVED******REMOVED***
            with context.push(**values***REMOVED***:
                return template.render(context***REMOVED***
        except Exception:
            if context.template.engine.debug:
                raise
            template_name = getattr(context, 'template_name', None***REMOVED*** or 'unknown'
            logger.warning(
                "Exception raised while rendering {%% include %%***REMOVED*** for "
                "template '%s'. Empty string rendered instead.",
                template_name,
                exc_info=True,
            ***REMOVED***
            return ''


@register.tag('block'***REMOVED***
def do_block(parser, token***REMOVED***:
    ***REMOVED***
    Define a block that can be overridden by child templates.
    ***REMOVED***
    # token.split_contents(***REMOVED*** isn't useful here because this tag doesn't accept variable as arguments
    bits = token.contents.split(***REMOVED***
    if len(bits***REMOVED*** != 2:
        raise TemplateSyntaxError("'%s' tag takes only one argument" % bits[0***REMOVED******REMOVED***
    block_name = bits[1***REMOVED***
    # Keep track of the names of BlockNodes found in this template, so we can
    # check for duplication.
    ***REMOVED***
        if block_name in parser.__loaded_blocks:
            raise TemplateSyntaxError("'%s' tag with name '%s' appears more than once" % (bits[0***REMOVED***, block_name***REMOVED******REMOVED***
        parser.__loaded_blocks.append(block_name***REMOVED***
    except AttributeError:  # parser.__loaded_blocks isn't a list yet
        parser.__loaded_blocks = [block_name***REMOVED***
    nodelist = parser.parse(('endblock',***REMOVED******REMOVED***

    # This check is kept for backwards-compatibility. See #3100.
    endblock = parser.next_token(***REMOVED***
    acceptable_endblocks = ('endblock', 'endblock %s' % block_name***REMOVED***
    if endblock.contents not in acceptable_endblocks:
        parser.invalid_block_tag(endblock, 'endblock', acceptable_endblocks***REMOVED***

    return BlockNode(block_name, nodelist***REMOVED***


def construct_relative_path(current_template_name, relative_name***REMOVED***:
    ***REMOVED***
    Convert a relative path (starting with './' or '../'***REMOVED*** to the full template
    name based on the current_template_name.
    ***REMOVED***
    if not any(relative_name.startswith(x***REMOVED*** for x in ["'./", "'../", '"./', '"../'***REMOVED******REMOVED***:
        # relative_name is a variable or a literal that doesn't contain a
        # relative path.
        return relative_name

    new_name = posixpath.normpath(
        posixpath.join(
            posixpath.dirname(current_template_name.lstrip('/'***REMOVED******REMOVED***,
            relative_name.strip('\'"'***REMOVED***
        ***REMOVED***
    ***REMOVED***
    if new_name.startswith('../'***REMOVED***:
        raise TemplateSyntaxError(
            "The relative path '%s' points outside the file hierarchy that "
            "template '%s' is in." % (relative_name, current_template_name***REMOVED***
        ***REMOVED***
    if current_template_name.lstrip('/'***REMOVED*** == new_name:
        raise TemplateSyntaxError(
            "The relative path '%s' was translated to template name '%s', the "
            "same template in which the tag appears."
            % (relative_name, current_template_name***REMOVED***
        ***REMOVED***
    return '"%s"' % new_name


@register.tag('extends'***REMOVED***
def do_extends(parser, token***REMOVED***:
    ***REMOVED***
    Signal that this template extends a parent template.

    This tag may be used in two ways: ``{% extends "base" %***REMOVED***`` (with quotes***REMOVED***
    uses the literal value "base" as the name of the parent template to extend,
    or ``{% extends variable %***REMOVED***`` uses the value of ``variable`` as either the
    name of the parent template to extend (if it evaluates to a string***REMOVED*** or as
    the parent template itself (if it evaluates to a Template object***REMOVED***.
    ***REMOVED***
    bits = token.split_contents(***REMOVED***
    if len(bits***REMOVED*** != 2:
        raise TemplateSyntaxError("'%s' takes one argument" % bits[0***REMOVED******REMOVED***
    bits[1***REMOVED*** = construct_relative_path(parser.origin.template_name, bits[1***REMOVED******REMOVED***
    parent_name = parser.compile_filter(bits[1***REMOVED******REMOVED***
    nodelist = parser.parse(***REMOVED***
    if nodelist.get_nodes_by_type(ExtendsNode***REMOVED***:
        raise TemplateSyntaxError("'%s' cannot appear more than once in the same template" % bits[0***REMOVED******REMOVED***
    return ExtendsNode(nodelist, parent_name***REMOVED***


@register.tag('include'***REMOVED***
def do_include(parser, token***REMOVED***:
    ***REMOVED***
    Loads a template and renders it with the current context. You can pass
    additional context using keyword arguments.

    Example::

    ***REMOVED***% include "foo/some_include" %***REMOVED***
    ***REMOVED***% include "foo/some_include" with bar="BAZZ!" baz="BING!" %***REMOVED***

    Use the ``only`` argument to exclude the current context when rendering
    the included template::

    ***REMOVED***% include "foo/some_include" only %***REMOVED***
    ***REMOVED***% include "foo/some_include" with bar="1" only %***REMOVED***
    ***REMOVED***
    bits = token.split_contents(***REMOVED***
    if len(bits***REMOVED*** < 2:
        raise TemplateSyntaxError(
            "%r tag takes at least one argument: the name of the template to "
            "be included." % bits[0***REMOVED***
        ***REMOVED***
    options = {***REMOVED***
    remaining_bits = bits[2:***REMOVED***
    while remaining_bits:
        option = remaining_bits.pop(0***REMOVED***
        if option in options:
            raise TemplateSyntaxError('The %r option was specified more '
                                      'than once.' % option***REMOVED***
        if option == 'with':
            value = token_kwargs(remaining_bits, parser, support_legacy=False***REMOVED***
            if not value:
                raise TemplateSyntaxError('"with" in %r tag needs at least '
                                          'one keyword argument.' % bits[0***REMOVED******REMOVED***
        elif option == 'only':
            value = True
        else:
            raise TemplateSyntaxError('Unknown argument for %r tag: %r.' %
                                      (bits[0***REMOVED***, option***REMOVED******REMOVED***
        options[option***REMOVED*** = value
    isolated_context = options.get('only', False***REMOVED***
    namemap = options.get('with', {***REMOVED******REMOVED***
    bits[1***REMOVED*** = construct_relative_path(parser.origin.template_name, bits[1***REMOVED******REMOVED***
    return IncludeNode(parser.compile_filter(bits[1***REMOVED******REMOVED***, extra_context=namemap,
                       isolated_context=isolated_context***REMOVED***
