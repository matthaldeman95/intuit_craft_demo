from django.core.exceptions import ImproperlyConfigured
from django.utils import lru_cache, six
from django.utils.functional import cached_property
from django.utils.module_loading import import_string

from .base import Context, Template
from .context import _builtin_context_processors
from .exceptions import TemplateDoesNotExist
from .library import import_library


class Engine(object***REMOVED***:
    default_builtins = [
        'django.template.defaulttags',
        'django.template.defaultfilters',
        'django.template.loader_tags',
    ***REMOVED***

    def __init__(self, dirs=None, app_dirs=False, context_processors=None,
                 debug=False, loaders=None, string_if_invalid='',
                 file_charset='utf-8', libraries=None, builtins=None, autoescape=True***REMOVED***:
        if dirs is None:
            dirs = [***REMOVED***
        if context_processors is None:
            context_processors = [***REMOVED***
        if loaders is None:
            loaders = ['django.template.loaders.filesystem.Loader'***REMOVED***
            if app_dirs:
                loaders += ['django.template.loaders.app_directories.Loader'***REMOVED***
        else:
            if app_dirs:
                raise ImproperlyConfigured(
                    "app_dirs must not be set when loaders is defined."***REMOVED***
        if libraries is None:
            libraries = {***REMOVED***
        if builtins is None:
            builtins = [***REMOVED***

        self.dirs = dirs
        self.app_dirs = app_dirs
        self.autoescape = autoescape
        self.context_processors = context_processors
        self.debug = debug
        self.loaders = loaders
        self.string_if_invalid = string_if_invalid
        self.file_charset = file_charset
        self.libraries = libraries
        self.template_libraries = self.get_template_libraries(libraries***REMOVED***
        self.builtins = self.default_builtins + builtins
        self.template_builtins = self.get_template_builtins(self.builtins***REMOVED***

    @staticmethod
    @lru_cache.lru_cache(***REMOVED***
    def get_default(***REMOVED***:
        ***REMOVED***
        When only one DjangoTemplates backend is configured, returns it.

        Raises ImproperlyConfigured otherwise.

        This is required for preserving historical APIs that rely on a
        globally available, implicitly configured engine such as:

        >>> from django.template import Context, Template
        >>> template = Template("Hello {{ name ***REMOVED******REMOVED***!"***REMOVED***
        >>> context = Context({'name': "world"***REMOVED******REMOVED***
        >>> template.render(context***REMOVED***
        'Hello world!'
        ***REMOVED***
        # Since Engine is imported in django.template and since
        # DjangoTemplates is a wrapper around this Engine class,
        # local imports are required to avoid import loops.
        from django.template import engines
        from django.template.backends.django import DjangoTemplates
        django_engines = [engine for engine in engines.all(***REMOVED***
                          if isinstance(engine, DjangoTemplates***REMOVED******REMOVED***
        if len(django_engines***REMOVED*** == 1:
            # Unwrap the Engine instance inside DjangoTemplates
            return django_engines[0***REMOVED***.engine
        elif len(django_engines***REMOVED*** == 0:
            raise ImproperlyConfigured(
                "No DjangoTemplates backend is configured."***REMOVED***
        else:
            raise ImproperlyConfigured(
                "Several DjangoTemplates backends are configured. "
                "You must select one explicitly."***REMOVED***

    @cached_property
    def template_context_processors(self***REMOVED***:
        context_processors = _builtin_context_processors
        context_processors += tuple(self.context_processors***REMOVED***
        return tuple(import_string(path***REMOVED*** for path in context_processors***REMOVED***

    def get_template_builtins(self, builtins***REMOVED***:
        return [import_library(x***REMOVED*** for x in builtins***REMOVED***

    def get_template_libraries(self, libraries***REMOVED***:
        loaded = {***REMOVED***
        for name, path in libraries.items(***REMOVED***:
            loaded[name***REMOVED*** = import_library(path***REMOVED***
        return loaded

    @cached_property
    def template_loaders(self***REMOVED***:
        return self.get_template_loaders(self.loaders***REMOVED***

    def get_template_loaders(self, template_loaders***REMOVED***:
        loaders = [***REMOVED***
        for template_loader in template_loaders:
            loader = self.find_template_loader(template_loader***REMOVED***
            if loader is not None:
                loaders.append(loader***REMOVED***
        return loaders

    def find_template_loader(self, loader***REMOVED***:
        if isinstance(loader, (tuple, list***REMOVED******REMOVED***:
            args = list(loader[1:***REMOVED******REMOVED***
            loader = loader[0***REMOVED***
        else:
            args = [***REMOVED***

        if isinstance(loader, six.string_types***REMOVED***:
            loader_class = import_string(loader***REMOVED***
            return loader_class(self, *args***REMOVED***
        else:
            raise ImproperlyConfigured(
                "Invalid value in template loaders configuration: %r" % loader***REMOVED***

    def find_template(self, name, dirs=None, skip=None***REMOVED***:
        tried = [***REMOVED***
        for loader in self.template_loaders:
            if loader.supports_recursion:
                ***REMOVED***
                    template = loader.get_template(
                        name, template_dirs=dirs, skip=skip,
                    ***REMOVED***
                    return template, template.origin
                except TemplateDoesNotExist as e:
                    tried.extend(e.tried***REMOVED***
            else:
                # RemovedInDjango20Warning: Use old api for non-recursive
                # loaders.
                ***REMOVED***
                    return loader(name, dirs***REMOVED***
                except TemplateDoesNotExist:
                    pass
        raise TemplateDoesNotExist(name, tried=tried***REMOVED***

    def from_string(self, template_code***REMOVED***:
        ***REMOVED***
        Returns a compiled Template object for the given template code,
        handling template inheritance recursively.
        ***REMOVED***
        return Template(template_code, engine=self***REMOVED***

    def get_template(self, template_name***REMOVED***:
        ***REMOVED***
        Returns a compiled Template object for the given template name,
        handling template inheritance recursively.
        ***REMOVED***
        template, origin = self.find_template(template_name***REMOVED***
        if not hasattr(template, 'render'***REMOVED***:
            # template needs to be compiled
            template = Template(template, origin, template_name, engine=self***REMOVED***
        return template

    def render_to_string(self, template_name, context=None***REMOVED***:
        ***REMOVED***
        Render the template specified by template_name with the given context.
        For use in Django's test suite.
        ***REMOVED***
        if isinstance(template_name, (list, tuple***REMOVED******REMOVED***:
            t = self.select_template(template_name***REMOVED***
        else:
            t = self.get_template(template_name***REMOVED***
        # Django < 1.8 accepted a Context in `context` even though that's
        # unintended. Preserve this ability but don't rewrap `context`.
        if isinstance(context, Context***REMOVED***:
            return t.render(context***REMOVED***
        else:
            return t.render(Context(context***REMOVED******REMOVED***

    def select_template(self, template_name_list***REMOVED***:
        ***REMOVED***
        Given a list of template names, returns the first that can be loaded.
        ***REMOVED***
        if not template_name_list:
            raise TemplateDoesNotExist("No template names provided"***REMOVED***
        not_found = [***REMOVED***
        for template_name in template_name_list:
            ***REMOVED***
                return self.get_template(template_name***REMOVED***
            except TemplateDoesNotExist as exc:
                if exc.args[0***REMOVED*** not in not_found:
                    not_found.append(exc.args[0***REMOVED******REMOVED***
                continue
        # If we get here, none of the templates could be loaded
        raise TemplateDoesNotExist(', '.join(not_found***REMOVED******REMOVED***
