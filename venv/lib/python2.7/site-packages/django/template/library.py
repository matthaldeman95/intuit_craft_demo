import functools
import warnings
from importlib import import_module

from django.utils import six
from django.utils.deprecation import RemovedInDjango20Warning
from django.utils.html import conditional_escape
from django.utils.inspect import getargspec
from django.utils.itercompat import is_iterable

from .base import Node, Template, token_kwargs
from .exceptions import TemplateSyntaxError


class InvalidTemplateLibrary(Exception***REMOVED***:
    pass


class Library(object***REMOVED***:
    ***REMOVED***
    A class for registering template tags and filters. Compiled filter and
    template tag functions are stored in the filters and tags attributes.
    The filter, simple_tag, and inclusion_tag methods provide a convenient
    way to register callables as tags.
    ***REMOVED***
    def __init__(self***REMOVED***:
        self.filters = {***REMOVED***
        self.tags = {***REMOVED***

    def tag(self, name=None, compile_function=None***REMOVED***:
        if name is None and compile_function is None:
            # @register.tag(***REMOVED***
            return self.tag_function
        elif name is not None and compile_function is None:
            if callable(name***REMOVED***:
                # @register.tag
                return self.tag_function(name***REMOVED***
            else:
                # @register.tag('somename'***REMOVED*** or @register.tag(name='somename'***REMOVED***
                def dec(func***REMOVED***:
                    return self.tag(name, func***REMOVED***
                return dec
        elif name is not None and compile_function is not None:
            # register.tag('somename', somefunc***REMOVED***
            self.tags[name***REMOVED*** = compile_function
            return compile_function
        else:
            raise ValueError(
                "Unsupported arguments to Library.tag: (%r, %r***REMOVED***" %
                (name, compile_function***REMOVED***,
            ***REMOVED***

    def tag_function(self, func***REMOVED***:
        self.tags[getattr(func, "_decorated_function", func***REMOVED***.__name__***REMOVED*** = func
        return func

    def filter(self, name=None, filter_func=None, **flags***REMOVED***:
        ***REMOVED***
        Register a callable as a template filter. Example:

        @register.filter
        def lower(value***REMOVED***:
            return value.lower(***REMOVED***
        ***REMOVED***
        if name is None and filter_func is None:
            # @register.filter(***REMOVED***
            def dec(func***REMOVED***:
                return self.filter_function(func, **flags***REMOVED***
            return dec
        elif name is not None and filter_func is None:
            if callable(name***REMOVED***:
                # @register.filter
                return self.filter_function(name, **flags***REMOVED***
            else:
                # @register.filter('somename'***REMOVED*** or @register.filter(name='somename'***REMOVED***
                def dec(func***REMOVED***:
                    return self.filter(name, func, **flags***REMOVED***
                return dec
        elif name is not None and filter_func is not None:
            # register.filter('somename', somefunc***REMOVED***
            self.filters[name***REMOVED*** = filter_func
            for attr in ('expects_localtime', 'is_safe', 'needs_autoescape'***REMOVED***:
                if attr in flags:
                    value = flags[attr***REMOVED***
                    # set the flag on the filter for FilterExpression.resolve
                    setattr(filter_func, attr, value***REMOVED***
                    # set the flag on the innermost decorated function
                    # for decorators that need it, e.g. stringfilter
                    if hasattr(filter_func, "_decorated_function"***REMOVED***:
                        setattr(filter_func._decorated_function, attr, value***REMOVED***
            filter_func._filter_name = name
            return filter_func
        else:
            raise ValueError(
                "Unsupported arguments to Library.filter: (%r, %r***REMOVED***" %
                (name, filter_func***REMOVED***,
            ***REMOVED***

    def filter_function(self, func, **flags***REMOVED***:
        name = getattr(func, "_decorated_function", func***REMOVED***.__name__
        return self.filter(name, func, **flags***REMOVED***

    def simple_tag(self, func=None, takes_context=None, name=None***REMOVED***:
        ***REMOVED***
        Register a callable as a compiled template tag. Example:

        @register.simple_tag
        def hello(*args, **kwargs***REMOVED***:
            return 'world'
        ***REMOVED***
        def dec(func***REMOVED***:
            params, varargs, varkw, defaults = getargspec(func***REMOVED***
            function_name = (name or getattr(func, '_decorated_function', func***REMOVED***.__name__***REMOVED***

            @functools.wraps(func***REMOVED***
            def compile_func(parser, token***REMOVED***:
                bits = token.split_contents(***REMOVED***[1:***REMOVED***
                target_var = None
                if len(bits***REMOVED*** >= 2 and bits[-2***REMOVED*** == 'as':
                    target_var = bits[-1***REMOVED***
                    bits = bits[:-2***REMOVED***
                args, kwargs = parse_bits(
                    parser, bits, params, varargs, varkw, defaults,
                    takes_context, function_name
                ***REMOVED***
                return SimpleNode(func, takes_context, args, kwargs, target_var***REMOVED***
            self.tag(function_name, compile_func***REMOVED***
            return func

        if func is None:
            # @register.simple_tag(...***REMOVED***
            return dec
        elif callable(func***REMOVED***:
            # @register.simple_tag
            return dec(func***REMOVED***
        else:
            raise ValueError("Invalid arguments provided to simple_tag"***REMOVED***

    def assignment_tag(self, func=None, takes_context=None, name=None***REMOVED***:
        warnings.warn(
            "assignment_tag(***REMOVED*** is deprecated. Use simple_tag(***REMOVED*** instead",
            RemovedInDjango20Warning,
            stacklevel=2,
        ***REMOVED***
        return self.simple_tag(func, takes_context, name***REMOVED***

    def inclusion_tag(self, filename, func=None, takes_context=None, name=None***REMOVED***:
        ***REMOVED***
        Register a callable as an inclusion tag:

        @register.inclusion_tag('results.html'***REMOVED***
        def show_results(poll***REMOVED***:
            choices = poll.choice_set.all(***REMOVED***
            return {'choices': choices***REMOVED***
        ***REMOVED***
        def dec(func***REMOVED***:
            params, varargs, varkw, defaults = getargspec(func***REMOVED***
            function_name = (name or getattr(func, '_decorated_function', func***REMOVED***.__name__***REMOVED***

            @functools.wraps(func***REMOVED***
            def compile_func(parser, token***REMOVED***:
                bits = token.split_contents(***REMOVED***[1:***REMOVED***
                args, kwargs = parse_bits(
                    parser, bits, params, varargs, varkw, defaults,
                    takes_context, function_name,
                ***REMOVED***
                return InclusionNode(
                    func, takes_context, args, kwargs, filename,
                ***REMOVED***
            self.tag(function_name, compile_func***REMOVED***
            return func
        return dec


class TagHelperNode(Node***REMOVED***:
    ***REMOVED***
    Base class for tag helper nodes such as SimpleNode and InclusionNode.
    Manages the positional and keyword arguments to be passed to the decorated
    function.
    ***REMOVED***
    def __init__(self, func, takes_context, args, kwargs***REMOVED***:
        self.func = func
        self.takes_context = takes_context
        self.args = args
        self.kwargs = kwargs

    def get_resolved_arguments(self, context***REMOVED***:
        resolved_args = [var.resolve(context***REMOVED*** for var in self.args***REMOVED***
        if self.takes_context:
            resolved_args = [context***REMOVED*** + resolved_args
        resolved_kwargs = {k: v.resolve(context***REMOVED*** for k, v in self.kwargs.items(***REMOVED******REMOVED***
        return resolved_args, resolved_kwargs


class SimpleNode(TagHelperNode***REMOVED***:

    def __init__(self, func, takes_context, args, kwargs, target_var***REMOVED***:
        super(SimpleNode, self***REMOVED***.__init__(func, takes_context, args, kwargs***REMOVED***
        self.target_var = target_var

    def render(self, context***REMOVED***:
        resolved_args, resolved_kwargs = self.get_resolved_arguments(context***REMOVED***
        output = self.func(*resolved_args, **resolved_kwargs***REMOVED***
        if self.target_var is not None:
            context[self.target_var***REMOVED*** = output
            return ''
        if context.autoescape:
            output = conditional_escape(output***REMOVED***
        return output


class InclusionNode(TagHelperNode***REMOVED***:

    def __init__(self, func, takes_context, args, kwargs, filename***REMOVED***:
        super(InclusionNode, self***REMOVED***.__init__(func, takes_context, args, kwargs***REMOVED***
        self.filename = filename

    def render(self, context***REMOVED***:
        ***REMOVED***
        Render the specified template and context. Cache the template object
        in render_context to avoid reparsing and loading when used in a for
        loop.
        ***REMOVED***
        resolved_args, resolved_kwargs = self.get_resolved_arguments(context***REMOVED***
        _dict = self.func(*resolved_args, **resolved_kwargs***REMOVED***

        t = context.render_context.get(self***REMOVED***
        if t is None:
            if isinstance(self.filename, Template***REMOVED***:
                t = self.filename
            elif isinstance(getattr(self.filename, 'template', None***REMOVED***, Template***REMOVED***:
                t = self.filename.template
            elif not isinstance(self.filename, six.string_types***REMOVED*** and is_iterable(self.filename***REMOVED***:
                t = context.template.engine.select_template(self.filename***REMOVED***
            else:
                t = context.template.engine.get_template(self.filename***REMOVED***
            context.render_context[self***REMOVED*** = t
        new_context = context.new(_dict***REMOVED***
        # Copy across the CSRF token, if present, because inclusion tags are
        # often used for forms, and we need instructions for using CSRF
        # protection to be as simple as possible.
        csrf_token = context.get('csrf_token'***REMOVED***
        if csrf_token is not None:
            new_context['csrf_token'***REMOVED*** = csrf_token
        return t.render(new_context***REMOVED***


def parse_bits(parser, bits, params, varargs, varkw, defaults,
               takes_context, name***REMOVED***:
    ***REMOVED***
    Parse bits for template tag helpers simple_tag and inclusion_tag, in
    particular by detecting syntax errors and by extracting positional and
    keyword arguments.
    ***REMOVED***
    if takes_context:
        if params[0***REMOVED*** == 'context':
            params = params[1:***REMOVED***
        else:
            raise TemplateSyntaxError(
                "'%s' is decorated with takes_context=True so it must "
                "have a first argument of 'context'" % name***REMOVED***
    args = [***REMOVED***
    kwargs = {***REMOVED***
    unhandled_params = list(params***REMOVED***
    for bit in bits:
        # First we try to extract a potential kwarg from the bit
        kwarg = token_kwargs([bit***REMOVED***, parser***REMOVED***
        if kwarg:
            # The kwarg was successfully extracted
            param, value = kwarg.popitem(***REMOVED***
            if param not in params and varkw is None:
                # An unexpected keyword argument was supplied
                raise TemplateSyntaxError(
                    "'%s' received unexpected keyword argument '%s'" %
                    (name, param***REMOVED******REMOVED***
            elif param in kwargs:
                # The keyword argument has already been supplied once
                raise TemplateSyntaxError(
                    "'%s' received multiple values for keyword argument '%s'" %
                    (name, param***REMOVED******REMOVED***
            else:
                # All good, record the keyword argument
                kwargs[str(param***REMOVED******REMOVED*** = value
                if param in unhandled_params:
                    # If using the keyword syntax for a positional arg, then
                    # consume it.
                    unhandled_params.remove(param***REMOVED***
        else:
            if kwargs:
                raise TemplateSyntaxError(
                    "'%s' received some positional argument(s***REMOVED*** after some "
                    "keyword argument(s***REMOVED***" % name***REMOVED***
            else:
                # Record the positional argument
                args.append(parser.compile_filter(bit***REMOVED******REMOVED***
                ***REMOVED***
                    # Consume from the list of expected positional arguments
                    unhandled_params.pop(0***REMOVED***
                except IndexError:
                    if varargs is None:
                        raise TemplateSyntaxError(
                            "'%s' received too many positional arguments" %
                            name***REMOVED***
    if defaults is not None:
        # Consider the last n params handled, where n is the
        # number of defaults.
        unhandled_params = unhandled_params[:-len(defaults***REMOVED******REMOVED***
    if unhandled_params:
        # Some positional arguments were not supplied
        raise TemplateSyntaxError(
            "'%s' did not receive value(s***REMOVED*** for the argument(s***REMOVED***: %s" %
            (name, ", ".join("'%s'" % p for p in unhandled_params***REMOVED******REMOVED******REMOVED***
    return args, kwargs


def import_library(name***REMOVED***:
    ***REMOVED***
    Load a Library object from a template tag module.
    ***REMOVED***
    ***REMOVED***
        module = import_module(name***REMOVED***
    except ImportError as e:
        raise InvalidTemplateLibrary(
            "Invalid template library specified. ImportError raised when "
            "trying to load '%s': %s" % (name, e***REMOVED***
        ***REMOVED***
    ***REMOVED***
        return module.register
    except AttributeError:
        raise InvalidTemplateLibrary(
            "Module  %s does not have a variable named 'register'" % name,
        ***REMOVED***
