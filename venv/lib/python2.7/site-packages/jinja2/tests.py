# -*- coding: utf-8 -*-
***REMOVED***
    jinja2.tests
    ~~~~~~~~~~~~

    Jinja test functions. Used with the "is" operator.

    :copyright: (c***REMOVED*** 2010 by the Jinja Team.
    :license: BSD, see LICENSE for more details.
***REMOVED***
import re
from collections import Mapping
from jinja2.runtime import Undefined
from jinja2._compat import text_type, string_types, integer_types
import decimal

number_re = re.compile(r'^-?\d+(\.\d+***REMOVED***?$'***REMOVED***
regex_type = type(number_re***REMOVED***


test_callable = callable


def test_odd(value***REMOVED***:
    ***REMOVED***Return true if the variable is odd.***REMOVED***
    return value % 2 == 1


def test_even(value***REMOVED***:
    ***REMOVED***Return true if the variable is even.***REMOVED***
    return value % 2 == 0


def test_divisibleby(value, num***REMOVED***:
    ***REMOVED***Check if a variable is divisible by a number.***REMOVED***
    return value % num == 0


def test_defined(value***REMOVED***:
    ***REMOVED***Return true if the variable is defined:

    .. sourcecode:: jinja

    ***REMOVED***% if variable is defined %***REMOVED***
            value of variable: {{ variable ***REMOVED******REMOVED***
    ***REMOVED***% else %***REMOVED***
            variable is not defined
    ***REMOVED***% endif %***REMOVED***

    See the :func:`default` filter for a simple way to set undefined
    variables.
    ***REMOVED***
    return not isinstance(value, Undefined***REMOVED***


def test_undefined(value***REMOVED***:
    ***REMOVED***Like :func:`defined` but the other way round.***REMOVED***
    return isinstance(value, Undefined***REMOVED***


def test_none(value***REMOVED***:
    ***REMOVED***Return true if the variable is none.***REMOVED***
    return value is None


def test_lower(value***REMOVED***:
    ***REMOVED***Return true if the variable is lowercased.***REMOVED***
    return text_type(value***REMOVED***.islower(***REMOVED***


def test_upper(value***REMOVED***:
    ***REMOVED***Return true if the variable is uppercased.***REMOVED***
    return text_type(value***REMOVED***.isupper(***REMOVED***


def test_string(value***REMOVED***:
    ***REMOVED***Return true if the object is a string.***REMOVED***
    return isinstance(value, string_types***REMOVED***


def test_mapping(value***REMOVED***:
    ***REMOVED***Return true if the object is a mapping (dict etc.***REMOVED***.

    .. versionadded:: 2.6
    ***REMOVED***
    return isinstance(value, Mapping***REMOVED***


def test_number(value***REMOVED***:
    ***REMOVED***Return true if the variable is a number.***REMOVED***
    return isinstance(value, integer_types + (float, complex, decimal.Decimal***REMOVED******REMOVED***


def test_sequence(value***REMOVED***:
    ***REMOVED***Return true if the variable is a sequence. Sequences are variables
    that are iterable.
    ***REMOVED***
    ***REMOVED***
        len(value***REMOVED***
        value.__getitem__
    ***REMOVED***
        return False
    return True


def test_equalto(value, other***REMOVED***:
    ***REMOVED***Check if an object has the same value as another object:

    .. sourcecode:: jinja

    ***REMOVED***% if foo.expression is equalto 42 %***REMOVED***
            the foo attribute evaluates to the constant 42
    ***REMOVED***% endif %***REMOVED***

    This appears to be a useless test as it does exactly the same as the
    ``==`` operator, but it can be useful when used together with the
    `selectattr` function:

    .. sourcecode:: jinja

    ***REMOVED***{ users|selectattr("email", "equalto", "foo@bar.invalid"***REMOVED*** ***REMOVED******REMOVED***

    .. versionadded:: 2.8
    ***REMOVED***
    return value == other


def test_sameas(value, other***REMOVED***:
    ***REMOVED***Check if an object points to the same memory address than another
    object:

    .. sourcecode:: jinja

    ***REMOVED***% if foo.attribute is sameas false %***REMOVED***
            the foo attribute really is the `False` singleton
    ***REMOVED***% endif %***REMOVED***
    ***REMOVED***
    return value is other


def test_iterable(value***REMOVED***:
    ***REMOVED***Check if it's possible to iterate over an object.***REMOVED***
    ***REMOVED***
        iter(value***REMOVED***
    except TypeError:
        return False
    return True


def test_escaped(value***REMOVED***:
    ***REMOVED***Check if the value is escaped.***REMOVED***
    return hasattr(value, '__html__'***REMOVED***


TESTS = {
    'odd':              test_odd,
    'even':             test_even,
    'divisibleby':      test_divisibleby,
    'defined':          test_defined,
    'undefined':        test_undefined,
    'none':             test_none,
    'lower':            test_lower,
    'upper':            test_upper,
    'string':           test_string,
    'mapping':          test_mapping,
    'number':           test_number,
    'sequence':         test_sequence,
    'iterable':         test_iterable,
    'callable':         test_callable,
    'sameas':           test_sameas,
    'equalto':          test_equalto,
    'escaped':          test_escaped
***REMOVED***
