from io import BytesIO


class CallbackFileWrapper(object***REMOVED***:
    ***REMOVED***
    Small wrapper around a fp object which will tee everything read into a
    buffer, and when that file is closed it will execute a callback with the
    contents of that buffer.

    All attributes are proxied to the underlying file object.

    This class uses members with a double underscore (__***REMOVED*** leading prefix so as
    not to accidentally shadow an attribute.
    ***REMOVED***

    def __init__(self, fp, callback***REMOVED***:
        self.__buf = BytesIO(***REMOVED***
        self.__fp = fp
        self.__callback = callback

    def __getattr__(self, name***REMOVED***:
        # The vaguaries of garbage collection means that self.__fp is
        # not always set.  By using __getattribute__ and the private
        # name[0***REMOVED*** allows looking up the attribute value and raising an
        # AttributeError when it doesn't exist. This stop thigns from
        # infinitely recursing calls to getattr in the case where
        # self.__fp hasn't been set.
        #
        # [0***REMOVED*** https://docs.python.org/2/reference/expressions.html#atom-identifiers
        fp = self.__getattribute__('_CallbackFileWrapper__fp'***REMOVED***
        return getattr(fp, name***REMOVED***

    def __is_fp_closed(self***REMOVED***:
        ***REMOVED***
            return self.__fp.fp is None
        except AttributeError:
            pass

        ***REMOVED***
            return self.__fp.closed
        except AttributeError:
            pass

        # We just don't cache it then.
        # TODO: Add some logging here...
        return False

    def read(self, amt=None***REMOVED***:
        data = self.__fp.read(amt***REMOVED***
        self.__buf.write(data***REMOVED***

        if self.__is_fp_closed(***REMOVED***:
            if self.__callback:
                self.__callback(self.__buf.getvalue(***REMOVED******REMOVED***

            # We assign this to None here, because otherwise we can get into
            # really tricky problems where the CPython interpreter dead locks
            # because the callback is holding a reference to something which
            # has a __del__ method. Setting this to None breaks the cycle
            # and allows the garbage collector to do it's thing normally.
            self.__callback = None

        return data
