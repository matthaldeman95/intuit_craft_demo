***REMOVED***
The httplib2 algorithms ported for use with requests.
***REMOVED***
import logging
import re
import calendar
import time
from email.utils import parsedate_tz

from pip._vendor.requests.structures import CaseInsensitiveDict

from .cache import DictCache
from .serialize import Serializer


logger = logging.getLogger(__name__***REMOVED***

URI = re.compile(r"^(([^:/?#***REMOVED***+***REMOVED***:***REMOVED***?(//([^/?#***REMOVED*******REMOVED******REMOVED***?([^?#***REMOVED*******REMOVED***(\?([^#***REMOVED*******REMOVED******REMOVED***?(#(.****REMOVED******REMOVED***?"***REMOVED***


def parse_uri(uri***REMOVED***:
    ***REMOVED***Parses a URI using the regex given in Appendix B of RFC 3986.

        (scheme, authority, path, query, fragment***REMOVED*** = parse_uri(uri***REMOVED***
    ***REMOVED***
    groups = URI.match(uri***REMOVED***.groups(***REMOVED***
    return (groups[1***REMOVED***, groups[3***REMOVED***, groups[4***REMOVED***, groups[6***REMOVED***, groups[8***REMOVED******REMOVED***


class CacheController(object***REMOVED***:
    ***REMOVED***An interface to see if request should cached or not.
    ***REMOVED***
    def __init__(self, cache=None, cache_etags=True, serializer=None***REMOVED***:
        self.cache = cache or DictCache(***REMOVED***
        self.cache_etags = cache_etags
        self.serializer = serializer or Serializer(***REMOVED***

    @classmethod
    def _urlnorm(cls, uri***REMOVED***:
        ***REMOVED***Normalize the URL to create a safe key for the cache***REMOVED***
        (scheme, authority, path, query, fragment***REMOVED*** = parse_uri(uri***REMOVED***
        if not scheme or not authority:
            raise Exception("Only absolute URIs are allowed. uri = %s" % uri***REMOVED***

        scheme = scheme.lower(***REMOVED***
        authority = authority.lower(***REMOVED***

        if not path:
            path = "/"

        # Could do syntax based normalization of the URI before
        # computing the digest. See Section 6.2.2 of Std 66.
        request_uri = query and "?".join([path, query***REMOVED******REMOVED*** or path
        defrag_uri = scheme + "://" + authority + request_uri

        return defrag_uri

    @classmethod
    def cache_url(cls, uri***REMOVED***:
        return cls._urlnorm(uri***REMOVED***

    def parse_cache_control(self, headers***REMOVED***:
        ***REMOVED***
        Parse the cache control headers returning a dictionary with values
        for the different directives.
        ***REMOVED***
        retval = {***REMOVED***

        cc_header = 'cache-control'
        if 'Cache-Control' in headers:
            cc_header = 'Cache-Control'

        if cc_header in headers:
            parts = headers[cc_header***REMOVED***.split(','***REMOVED***
            parts_with_args = [
                tuple([x.strip(***REMOVED***.lower(***REMOVED*** for x in part.split("=", 1***REMOVED******REMOVED******REMOVED***
                for part in parts if -1 != part.find("="***REMOVED***
            ***REMOVED***
            parts_wo_args = [
                (name.strip(***REMOVED***.lower(***REMOVED***, 1***REMOVED***
                for name in parts if -1 == name.find("="***REMOVED***
            ***REMOVED***
            retval = dict(parts_with_args + parts_wo_args***REMOVED***
        return retval

    def cached_request(self, request***REMOVED***:
        ***REMOVED***
        Return a cached response if it exists in the cache, otherwise
        return False.
        ***REMOVED***
        cache_url = self.cache_url(request.url***REMOVED***
        logger.debug('Looking up "%s" in the cache', cache_url***REMOVED***
        cc = self.parse_cache_control(request.headers***REMOVED***

        # Bail out if the request insists on fresh data
        if 'no-cache' in cc:
            logger.debug('Request header has "no-cache", cache bypassed'***REMOVED***
            return False

        if 'max-age' in cc and cc['max-age'***REMOVED*** == 0:
            logger.debug('Request header has "max_age" as 0, cache bypassed'***REMOVED***
            return False

        # Request allows serving from the cache, let's see if we find something
        cache_data = self.cache.get(cache_url***REMOVED***
        if cache_data is None:
            logger.debug('No cache entry available'***REMOVED***
            return False

        # Check whether it can be deserialized
        resp = self.serializer.loads(request, cache_data***REMOVED***
        if not resp:
            logger.warning('Cache entry deserialization failed, entry ignored'***REMOVED***
            return False

        # If we have a cached 301, return it immediately. We don't
        # need to test our response for other headers b/c it is
        # intrinsically "cacheable" as it is Permanent.
        # See:
        #   https://tools.ietf.org/html/rfc7231#section-6.4.2
        #
        # Client can try to refresh the value by repeating the request
        # with cache busting headers as usual (ie no-cache***REMOVED***.
        if resp.status == 301:
            msg = ('Returning cached "301 Moved Permanently" response '
                   '(ignoring date and etag information***REMOVED***'***REMOVED***
            logger.debug(msg***REMOVED***
            return resp

        headers = CaseInsensitiveDict(resp.headers***REMOVED***
        if not headers or 'date' not in headers:
            if 'etag' not in headers:
                # Without date or etag, the cached response can never be used
                # and should be deleted.
                logger.debug('Purging cached response: no date or etag'***REMOVED***
                self.cache.delete(cache_url***REMOVED***
            logger.debug('Ignoring cached response: no date'***REMOVED***
            return False

        now = time.time(***REMOVED***
        date = calendar.timegm(
            parsedate_tz(headers['date'***REMOVED******REMOVED***
        ***REMOVED***
        current_age = max(0, now - date***REMOVED***
        logger.debug('Current age based on date: %i', current_age***REMOVED***

        # TODO: There is an assumption that the result will be a
        #       urllib3 response object. This may not be best since we
        #       could probably avoid instantiating or constructing the
        #       response until we know we need it.
        resp_cc = self.parse_cache_control(headers***REMOVED***

        # determine freshness
        freshness_lifetime = 0

        # Check the max-age pragma in the cache control header
        if 'max-age' in resp_cc and resp_cc['max-age'***REMOVED***.isdigit(***REMOVED***:
            freshness_lifetime = int(resp_cc['max-age'***REMOVED******REMOVED***
            logger.debug('Freshness lifetime from max-age: %i',
                         freshness_lifetime***REMOVED***

        # If there isn't a max-age, check for an expires header
        elif 'expires' in headers:
            expires = parsedate_tz(headers['expires'***REMOVED******REMOVED***
            if expires is not None:
                expire_time = calendar.timegm(expires***REMOVED*** - date
                freshness_lifetime = max(0, expire_time***REMOVED***
                logger.debug("Freshness lifetime from expires: %i",
                             freshness_lifetime***REMOVED***

        # Determine if we are setting freshness limit in the
        # request. Note, this overrides what was in the response.
        if 'max-age' in cc:
            ***REMOVED***
                freshness_lifetime = int(cc['max-age'***REMOVED******REMOVED***
                logger.debug('Freshness lifetime from request max-age: %i',
                             freshness_lifetime***REMOVED***
            except ValueError:
                freshness_lifetime = 0

        if 'min-fresh' in cc:
            ***REMOVED***
                min_fresh = int(cc['min-fresh'***REMOVED******REMOVED***
            except ValueError:
                min_fresh = 0
            # adjust our current age by our min fresh
            current_age += min_fresh
            logger.debug('Adjusted current age from min-fresh: %i',
                         current_age***REMOVED***

        # Return entry if it is fresh enough
        if freshness_lifetime > current_age:
            logger.debug('The response is "fresh", returning cached response'***REMOVED***
            logger.debug('%i > %i', freshness_lifetime, current_age***REMOVED***
            return resp

        # we're not fresh. If we don't have an Etag, clear it out
        if 'etag' not in headers:
            logger.debug(
                'The cached response is "stale" with no etag, purging'
            ***REMOVED***
            self.cache.delete(cache_url***REMOVED***

        # return the original handler
        return False

    def conditional_headers(self, request***REMOVED***:
        cache_url = self.cache_url(request.url***REMOVED***
        resp = self.serializer.loads(request, self.cache.get(cache_url***REMOVED******REMOVED***
        new_headers = {***REMOVED***

        if resp:
            headers = CaseInsensitiveDict(resp.headers***REMOVED***

            if 'etag' in headers:
                new_headers['If-None-Match'***REMOVED*** = headers['ETag'***REMOVED***

            if 'last-modified' in headers:
                new_headers['If-Modified-Since'***REMOVED*** = headers['Last-Modified'***REMOVED***

        return new_headers

    def cache_response(self, request, response, body=None***REMOVED***:
        ***REMOVED***
        Algorithm for caching requests.

        This assumes a requests Response object.
        ***REMOVED***
        # From httplib2: Don't cache 206's since we aren't going to
        #                handle byte range requests
        cacheable_status_codes = [200, 203, 300, 301***REMOVED***
        if response.status not in cacheable_status_codes:
            logger.debug(
                'Status code %s not in %s',
                response.status,
                cacheable_status_codes
            ***REMOVED***
            return

        response_headers = CaseInsensitiveDict(response.headers***REMOVED***

        # If we've been given a body, our response has a Content-Length, that
        # Content-Length is valid then we can check to see if the body we've
        # been given matches the expected size, and if it doesn't we'll just
        # skip trying to cache it.
        if (body is not None and
                "content-length" in response_headers and
                response_headers["content-length"***REMOVED***.isdigit(***REMOVED*** and
                int(response_headers["content-length"***REMOVED******REMOVED*** != len(body***REMOVED******REMOVED***:
            return

        cc_req = self.parse_cache_control(request.headers***REMOVED***
        cc = self.parse_cache_control(response_headers***REMOVED***

        cache_url = self.cache_url(request.url***REMOVED***
        logger.debug('Updating cache with response from "%s"', cache_url***REMOVED***

        # Delete it from the cache if we happen to have it stored there
        no_store = False
        if cc.get('no-store'***REMOVED***:
            no_store = True
            logger.debug('Response header has "no-store"'***REMOVED***
        if cc_req.get('no-store'***REMOVED***:
            no_store = True
            logger.debug('Request header has "no-store"'***REMOVED***
        if no_store and self.cache.get(cache_url***REMOVED***:
            logger.debug('Purging existing cache entry to honor "no-store"'***REMOVED***
            self.cache.delete(cache_url***REMOVED***

        # If we've been given an etag, then keep the response
        if self.cache_etags and 'etag' in response_headers:
            logger.debug('Caching due to etag'***REMOVED***
            self.cache.set(
                cache_url,
                self.serializer.dumps(request, response, body=body***REMOVED***,
            ***REMOVED***

        # Add to the cache any 301s. We do this before looking that
        # the Date headers.
        elif response.status == 301:
            logger.debug('Caching permanant redirect'***REMOVED***
            self.cache.set(
                cache_url,
                self.serializer.dumps(request, response***REMOVED***
            ***REMOVED***

        # Add to the cache if the response headers demand it. If there
        # is no date header then we can't do anything about expiring
        # the cache.
        elif 'date' in response_headers:
            # cache when there is a max-age > 0
            if cc and cc.get('max-age'***REMOVED***:
                if int(cc['max-age'***REMOVED******REMOVED*** > 0:
                    logger.debug('Caching b/c date exists and max-age > 0'***REMOVED***
                    self.cache.set(
                        cache_url,
                        self.serializer.dumps(request, response, body=body***REMOVED***,
                    ***REMOVED***

            # If the request can expire, it means we should cache it
            # in the meantime.
            elif 'expires' in response_headers:
                if response_headers['expires'***REMOVED***:
                    logger.debug('Caching b/c of expires header'***REMOVED***
                    self.cache.set(
                        cache_url,
                        self.serializer.dumps(request, response, body=body***REMOVED***,
                    ***REMOVED***

    def update_cached_response(self, request, response***REMOVED***:
        ***REMOVED***On a 304 we will get a new set of headers that we want to
        update our cached value with, assuming we have one.

        This should only ever be called when we've sent an ETag and
        gotten a 304 as the response.
        ***REMOVED***
        cache_url = self.cache_url(request.url***REMOVED***

        cached_response = self.serializer.loads(
            request,
            self.cache.get(cache_url***REMOVED***
        ***REMOVED***

        if not cached_response:
            # we didn't have a cached response
            return response

        # Lets update our headers with the headers from the new request:
        # http://tools.ietf.org/html/draft-ietf-httpbis-p4-conditional-26#section-4.1
        #
        # The server isn't supposed to send headers that would make
        # the cached body invalid. But... just in case, we'll be sure
        # to strip out ones we know that might be problmatic due to
        # typical assumptions.
        excluded_headers = [
            "content-length",
        ***REMOVED***

        cached_response.headers.update(
            dict((k, v***REMOVED*** for k, v in response.headers.items(***REMOVED***
                 if k.lower(***REMOVED*** not in excluded_headers***REMOVED***
        ***REMOVED***

        # we want a 200 b/c we have content via the cache
        cached_response.status = 200

        # update our cache
        self.cache.set(
            cache_url,
            self.serializer.dumps(request, cached_response***REMOVED***,
        ***REMOVED***

        return cached_response
