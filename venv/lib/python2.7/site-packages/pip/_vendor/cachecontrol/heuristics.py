import calendar
import time

from email.utils import formatdate, parsedate, parsedate_tz

from datetime import datetime, timedelta

TIME_FMT = "%a, %d %b %Y %H:%M:%S GMT"


def expire_after(delta, date=None***REMOVED***:
    date = date or datetime.now(***REMOVED***
    return date + delta


def datetime_to_header(dt***REMOVED***:
    return formatdate(calendar.timegm(dt.timetuple(***REMOVED******REMOVED******REMOVED***


class BaseHeuristic(object***REMOVED***:

    def warning(self, response***REMOVED***:
        ***REMOVED***
        Return a valid 1xx warning header value describing the cache
        adjustments.

        The response is provided too allow warnings like 113
        http://tools.ietf.org/html/rfc7234#section-5.5.4 where we need
        to explicitly say response is over 24 hours old.
        ***REMOVED***
        return '110 - "Response is Stale"'

    def update_headers(self, response***REMOVED***:
        ***REMOVED***Update the response headers with any new headers.

        NOTE: This SHOULD always include some Warning header to
              signify that the response was cached by the client, not
              by way of the provided headers.
        ***REMOVED***
        return {***REMOVED***

    def apply(self, response***REMOVED***:
        updated_headers = self.update_headers(response***REMOVED***

        if updated_headers:
            response.headers.update(updated_headers***REMOVED***
            warning_header_value = self.warning(response***REMOVED***
            if warning_header_value is not None:
                response.headers.update({'Warning': warning_header_value***REMOVED******REMOVED***

        return response


class OneDayCache(BaseHeuristic***REMOVED***:
    ***REMOVED***
    Cache the response by providing an expires 1 day in the
    future.
    ***REMOVED***
    def update_headers(self, response***REMOVED***:
        headers = {***REMOVED***

        if 'expires' not in response.headers:
            date = parsedate(response.headers['date'***REMOVED******REMOVED***
            expires = expire_after(timedelta(days=1***REMOVED***,
                                   date=datetime(*date[:6***REMOVED******REMOVED******REMOVED***
            headers['expires'***REMOVED*** = datetime_to_header(expires***REMOVED***
            headers['cache-control'***REMOVED*** = 'public'
        return headers


class ExpiresAfter(BaseHeuristic***REMOVED***:
    ***REMOVED***
    Cache **all** requests for a defined time period.
    ***REMOVED***

    def __init__(self, **kw***REMOVED***:
        self.delta = timedelta(**kw***REMOVED***

    def update_headers(self, response***REMOVED***:
        expires = expire_after(self.delta***REMOVED***
        return {
            'expires': datetime_to_header(expires***REMOVED***,
            'cache-control': 'public',
    ***REMOVED***

    def warning(self, response***REMOVED***:
        tmpl = '110 - Automatically cached for %s. Response might be stale'
        return tmpl % self.delta


class LastModified(BaseHeuristic***REMOVED***:
    ***REMOVED***
    If there is no Expires header already, fall back on Last-Modified
    using the heuristic from
    http://tools.ietf.org/html/rfc7234#section-4.2.2
    to calculate a reasonable value.

    Firefox also does something like this per
    https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching_FAQ
    http://lxr.mozilla.org/mozilla-release/source/netwerk/protocol/http/nsHttpResponseHead.cpp#397
    Unlike mozilla we limit this to 24-hr.
    ***REMOVED***
    cacheable_by_default_statuses = set([
        200, 203, 204, 206, 300, 301, 404, 405, 410, 414, 501
    ***REMOVED******REMOVED***

    def update_headers(self, resp***REMOVED***:
        headers = resp.headers

        if 'expires' in headers:
            return {***REMOVED***

        if 'cache-control' in headers and headers['cache-control'***REMOVED*** != 'public':
            return {***REMOVED***

        if resp.status not in self.cacheable_by_default_statuses:
            return {***REMOVED***

        if 'date' not in headers or 'last-modified' not in headers:
            return {***REMOVED***

        date = calendar.timegm(parsedate_tz(headers['date'***REMOVED******REMOVED******REMOVED***
        last_modified = parsedate(headers['last-modified'***REMOVED******REMOVED***
        if date is None or last_modified is None:
            return {***REMOVED***

        now = time.time(***REMOVED***
        current_age = max(0, now - date***REMOVED***
        delta = date - calendar.timegm(last_modified***REMOVED***
        freshness_lifetime = max(0, min(delta / 10, 24 * 3600***REMOVED******REMOVED***
        if freshness_lifetime <= current_age:
            return {***REMOVED***

        expires = date + freshness_lifetime
        return {'expires': time.strftime(TIME_FMT, time.gmtime(expires***REMOVED******REMOVED******REMOVED***

    def warning(self, resp***REMOVED***:
        return None
