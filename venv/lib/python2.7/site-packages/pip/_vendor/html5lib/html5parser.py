from __future__ import absolute_import, division, unicode_literals
from pip._vendor.six import with_metaclass

import types

from . import inputstream
from . import tokenizer

from . import treebuilders
from .treebuilders._base import Marker

from . import utils
from . import constants
from .constants import spaceCharacters, asciiUpper2Lower
from .constants import specialElements
from .constants import headingElements
from .constants import cdataElements, rcdataElements
from .constants import tokenTypes, ReparseException, namespaces
from .constants import htmlIntegrationPointElements, mathmlTextIntegrationPointElements
from .constants import adjustForeignAttributes as adjustForeignAttributesMap
from .constants import E


def parse(doc, treebuilder="etree", encoding=None,
          namespaceHTMLElements=True***REMOVED***:
    ***REMOVED***Parse a string or file-like object into a tree***REMOVED***
    tb = treebuilders.getTreeBuilder(treebuilder***REMOVED***
    p = HTMLParser(tb, namespaceHTMLElements=namespaceHTMLElements***REMOVED***
    return p.parse(doc, encoding=encoding***REMOVED***


def parseFragment(doc, container="div", treebuilder="etree", encoding=None,
                  namespaceHTMLElements=True***REMOVED***:
    tb = treebuilders.getTreeBuilder(treebuilder***REMOVED***
    p = HTMLParser(tb, namespaceHTMLElements=namespaceHTMLElements***REMOVED***
    return p.parseFragment(doc, container=container, encoding=encoding***REMOVED***


def method_decorator_metaclass(function***REMOVED***:
    class Decorated(type***REMOVED***:
        def __new__(meta, classname, bases, classDict***REMOVED***:
            for attributeName, attribute in classDict.items(***REMOVED***:
                if isinstance(attribute, types.FunctionType***REMOVED***:
                    attribute = function(attribute***REMOVED***

                classDict[attributeName***REMOVED*** = attribute
            return type.__new__(meta, classname, bases, classDict***REMOVED***
    return Decorated


class HTMLParser(object***REMOVED***:
    ***REMOVED***HTML parser. Generates a tree structure from a stream of (possibly
        malformed***REMOVED*** HTML***REMOVED***

    def __init__(self, tree=None, tokenizer=tokenizer.HTMLTokenizer,
                 strict=False, namespaceHTMLElements=True, debug=False***REMOVED***:
        ***REMOVED***
        strict - raise an exception when a parse error is encountered

        tree - a treebuilder class controlling the type of tree that will be
        returned. Built in treebuilders can be accessed through
        html5lib.treebuilders.getTreeBuilder(treeType***REMOVED***

        tokenizer - a class that provides a stream of tokens to the treebuilder.
        This may be replaced for e.g. a sanitizer which converts some tags to
        text
        ***REMOVED***

        # Raise an exception on the first error encountered
        self.strict = strict

        if tree is None:
            tree = treebuilders.getTreeBuilder("etree"***REMOVED***
        self.tree = tree(namespaceHTMLElements***REMOVED***
        self.tokenizer_class = tokenizer
        self.errors = [***REMOVED***

        self.phases = dict([(name, cls(self, self.tree***REMOVED******REMOVED*** for name, cls in
                            getPhases(debug***REMOVED***.items(***REMOVED******REMOVED******REMOVED***

    def _parse(self, stream, innerHTML=False, container="div",
               encoding=None, parseMeta=True, useChardet=True, **kwargs***REMOVED***:

        self.innerHTMLMode = innerHTML
        self.container = container
        self.tokenizer = self.tokenizer_class(stream, encoding=encoding,
                                              parseMeta=parseMeta,
                                              useChardet=useChardet,
                                              parser=self, **kwargs***REMOVED***
        self.reset(***REMOVED***

        while True:
            ***REMOVED***
                self.mainLoop(***REMOVED***
                break
            except ReparseException:
                self.reset(***REMOVED***

    def reset(self***REMOVED***:
        self.tree.reset(***REMOVED***
        self.firstStartTag = False
        self.errors = [***REMOVED***
        self.log = [***REMOVED***  # only used with debug mode
        # "quirks" / "limited quirks" / "no quirks"
        self.compatMode = "no quirks"

        if self.innerHTMLMode:
            self.innerHTML = self.container.lower(***REMOVED***

            if self.innerHTML in cdataElements:
                self.tokenizer.state = self.tokenizer.rcdataState
            elif self.innerHTML in rcdataElements:
                self.tokenizer.state = self.tokenizer.rawtextState
            elif self.innerHTML == 'plaintext':
                self.tokenizer.state = self.tokenizer.plaintextState
            else:
                # state already is data state
                # self.tokenizer.state = self.tokenizer.dataState
                pass
            self.phase = self.phases["beforeHtml"***REMOVED***
            self.phase.insertHtmlElement(***REMOVED***
            self.resetInsertionMode(***REMOVED***
        else:
            self.innerHTML = False
            self.phase = self.phases["initial"***REMOVED***

        self.lastPhase = None

        self.beforeRCDataPhase = None

        self.framesetOK = True

    @property
    def documentEncoding(self***REMOVED***:
        ***REMOVED***The name of the character encoding
        that was used to decode the input stream,
        or :obj:`None` if that is not determined yet.

        ***REMOVED***
        if not hasattr(self, 'tokenizer'***REMOVED***:
            return None
        return self.tokenizer.stream.charEncoding[0***REMOVED***

    def isHTMLIntegrationPoint(self, element***REMOVED***:
        if (element.name == "annotation-xml" and
                element.namespace == namespaces["mathml"***REMOVED******REMOVED***:
            return ("encoding" in element.attributes and
                    element.attributes["encoding"***REMOVED***.translate(
                        asciiUpper2Lower***REMOVED*** in
                    ("text/html", "application/xhtml+xml"***REMOVED******REMOVED***
        else:
            return (element.namespace, element.name***REMOVED*** in htmlIntegrationPointElements

    def isMathMLTextIntegrationPoint(self, element***REMOVED***:
        return (element.namespace, element.name***REMOVED*** in mathmlTextIntegrationPointElements

    def mainLoop(self***REMOVED***:
        CharactersToken = tokenTypes["Characters"***REMOVED***
        SpaceCharactersToken = tokenTypes["SpaceCharacters"***REMOVED***
        StartTagToken = tokenTypes["StartTag"***REMOVED***
        EndTagToken = tokenTypes["EndTag"***REMOVED***
        CommentToken = tokenTypes["Comment"***REMOVED***
        DoctypeToken = tokenTypes["Doctype"***REMOVED***
        ParseErrorToken = tokenTypes["ParseError"***REMOVED***

        for token in self.normalizedTokens(***REMOVED***:
            new_token = token
            while new_token is not None:
                currentNode = self.tree.openElements[-1***REMOVED*** if self.tree.openElements else None
                currentNodeNamespace = currentNode.namespace if currentNode else None
                currentNodeName = currentNode.name if currentNode else None

                type = new_token["type"***REMOVED***

                if type == ParseErrorToken:
                    self.parseError(new_token["data"***REMOVED***, new_token.get("datavars", {***REMOVED******REMOVED******REMOVED***
                    new_token = None
                else:
                    if (len(self.tree.openElements***REMOVED*** == 0 or
                        currentNodeNamespace == self.tree.defaultNamespace or
                        (self.isMathMLTextIntegrationPoint(currentNode***REMOVED*** and
                         ((type == StartTagToken and
                           token["name"***REMOVED*** not in frozenset(["mglyph", "malignmark"***REMOVED******REMOVED******REMOVED*** or
                          type in (CharactersToken, SpaceCharactersToken***REMOVED******REMOVED******REMOVED*** or
                        (currentNodeNamespace == namespaces["mathml"***REMOVED*** and
                         currentNodeName == "annotation-xml" and
                         token["name"***REMOVED*** == "svg"***REMOVED*** or
                        (self.isHTMLIntegrationPoint(currentNode***REMOVED*** and
                         type in (StartTagToken, CharactersToken, SpaceCharactersToken***REMOVED******REMOVED******REMOVED***:
                        phase = self.phase
                    else:
                        phase = self.phases["inForeignContent"***REMOVED***

                    if type == CharactersToken:
                        new_token = phase.processCharacters(new_token***REMOVED***
                    elif type == SpaceCharactersToken:
                        new_token = phase.processSpaceCharacters(new_token***REMOVED***
                    elif type == StartTagToken:
                        new_token = phase.processStartTag(new_token***REMOVED***
                    elif type == EndTagToken:
                        new_token = phase.processEndTag(new_token***REMOVED***
                    elif type == CommentToken:
                        new_token = phase.processComment(new_token***REMOVED***
                    elif type == DoctypeToken:
                        new_token = phase.processDoctype(new_token***REMOVED***

            if (type == StartTagToken and token["selfClosing"***REMOVED***
                    and not token["selfClosingAcknowledged"***REMOVED******REMOVED***:
                self.parseError("non-void-element-with-trailing-solidus",
                            ***REMOVED***"name": token["name"***REMOVED******REMOVED******REMOVED***

        # When the loop finishes it's EOF
        reprocess = True
        phases = [***REMOVED***
        while reprocess:
            phases.append(self.phase***REMOVED***
            reprocess = self.phase.processEOF(***REMOVED***
            if reprocess:
                assert self.phase not in phases

    def normalizedTokens(self***REMOVED***:
        for token in self.tokenizer:
            yield self.normalizeToken(token***REMOVED***

    def parse(self, stream, encoding=None, parseMeta=True, useChardet=True***REMOVED***:
        ***REMOVED***Parse a HTML document into a well-formed tree

        stream - a filelike object or string containing the HTML to be parsed

        The optional encoding parameter must be a string that indicates
        the encoding.  If specified, that encoding will be used,
        regardless of any BOM or later declaration (such as in a meta
        element***REMOVED***
        ***REMOVED***
        self._parse(stream, innerHTML=False, encoding=encoding,
                    parseMeta=parseMeta, useChardet=useChardet***REMOVED***
        return self.tree.getDocument(***REMOVED***

    def parseFragment(self, stream, container="div", encoding=None,
                      parseMeta=False, useChardet=True***REMOVED***:
        ***REMOVED***Parse a HTML fragment into a well-formed tree fragment

        container - name of the element we're setting the innerHTML property
        if set to None, default to 'div'

        stream - a filelike object or string containing the HTML to be parsed

        The optional encoding parameter must be a string that indicates
        the encoding.  If specified, that encoding will be used,
        regardless of any BOM or later declaration (such as in a meta
        element***REMOVED***
        ***REMOVED***
        self._parse(stream, True, container=container, encoding=encoding***REMOVED***
        return self.tree.getFragment(***REMOVED***

    def parseError(self, errorcode="XXX-undefined-error", datavars={***REMOVED******REMOVED***:
        # XXX The idea is to make errorcode mandatory.
        self.errors.append((self.tokenizer.stream.position(***REMOVED***, errorcode, datavars***REMOVED******REMOVED***
        if self.strict:
            raise ParseError(E[errorcode***REMOVED*** % datavars***REMOVED***

    def normalizeToken(self, token***REMOVED***:
        ***REMOVED*** HTML5 specific normalizations to the token stream ***REMOVED***

        if token["type"***REMOVED*** == tokenTypes["StartTag"***REMOVED***:
            token["data"***REMOVED*** = dict(token["data"***REMOVED***[::-1***REMOVED******REMOVED***

        return token

    def adjustMathMLAttributes(self, token***REMOVED***:
        replacements = {"definitionurl": "definitionURL"***REMOVED***
        for k, v in replacements.items(***REMOVED***:
            if k in token["data"***REMOVED***:
                token["data"***REMOVED***[v***REMOVED*** = token["data"***REMOVED***[k***REMOVED***
                del token["data"***REMOVED***[k***REMOVED***

    def adjustSVGAttributes(self, token***REMOVED***:
        replacements = {
            "attributename": "attributeName",
            "attributetype": "attributeType",
            "basefrequency": "baseFrequency",
            "baseprofile": "baseProfile",
            "calcmode": "calcMode",
            "clippathunits": "clipPathUnits",
            "contentscripttype": "contentScriptType",
            "contentstyletype": "contentStyleType",
            "diffuseconstant": "diffuseConstant",
            "edgemode": "edgeMode",
            "externalresourcesrequired": "externalResourcesRequired",
            "filterres": "filterRes",
            "filterunits": "filterUnits",
            "glyphref": "glyphRef",
            "gradienttransform": "gradientTransform",
            "gradientunits": "gradientUnits",
            "kernelmatrix": "kernelMatrix",
            "kernelunitlength": "kernelUnitLength",
            "keypoints": "keyPoints",
            "keysplines": "keySplines",
            "keytimes": "keyTimes",
            "lengthadjust": "lengthAdjust",
            "limitingconeangle": "limitingConeAngle",
            "markerheight": "markerHeight",
            "markerunits": "markerUnits",
            "markerwidth": "markerWidth",
            "maskcontentunits": "maskContentUnits",
            "maskunits": "maskUnits",
            "numoctaves": "numOctaves",
            "pathlength": "pathLength",
            "patterncontentunits": "patternContentUnits",
            "patterntransform": "patternTransform",
            "patternunits": "patternUnits",
            "pointsatx": "pointsAtX",
            "pointsaty": "pointsAtY",
            "pointsatz": "pointsAtZ",
            "preservealpha": "preserveAlpha",
            "preserveaspectratio": "preserveAspectRatio",
            "primitiveunits": "primitiveUnits",
            "refx": "refX",
            "refy": "refY",
            "repeatcount": "repeatCount",
            "repeatdur": "repeatDur",
            "requiredextensions": "requiredExtensions",
            "requiredfeatures": "requiredFeatures",
            "specularconstant": "specularConstant",
            "specularexponent": "specularExponent",
            "spreadmethod": "spreadMethod",
            "startoffset": "startOffset",
            "stddeviation": "stdDeviation",
            "stitchtiles": "stitchTiles",
            "surfacescale": "surfaceScale",
            "systemlanguage": "systemLanguage",
            "tablevalues": "tableValues",
            "targetx": "targetX",
            "targety": "targetY",
            "textlength": "textLength",
            "viewbox": "viewBox",
            "viewtarget": "viewTarget",
            "xchannelselector": "xChannelSelector",
            "ychannelselector": "yChannelSelector",
            "zoomandpan": "zoomAndPan"
    ***REMOVED***
        for originalName in list(token["data"***REMOVED***.keys(***REMOVED******REMOVED***:
            if originalName in replacements:
                svgName = replacements[originalName***REMOVED***
                token["data"***REMOVED***[svgName***REMOVED*** = token["data"***REMOVED***[originalName***REMOVED***
                del token["data"***REMOVED***[originalName***REMOVED***

    def adjustForeignAttributes(self, token***REMOVED***:
        replacements = adjustForeignAttributesMap

        for originalName in token["data"***REMOVED***.keys(***REMOVED***:
            if originalName in replacements:
                foreignName = replacements[originalName***REMOVED***
                token["data"***REMOVED***[foreignName***REMOVED*** = token["data"***REMOVED***[originalName***REMOVED***
                del token["data"***REMOVED***[originalName***REMOVED***

    def reparseTokenNormal(self, token***REMOVED***:
        self.parser.phase(***REMOVED***

    def resetInsertionMode(self***REMOVED***:
        # The name of this method is mostly historical. (It's also used in the
        # specification.***REMOVED***
        last = False
        newModes = {
            "select": "inSelect",
            "td": "inCell",
            "th": "inCell",
            "tr": "inRow",
            "tbody": "inTableBody",
            "thead": "inTableBody",
            "tfoot": "inTableBody",
            "caption": "inCaption",
            "colgroup": "inColumnGroup",
            "table": "inTable",
            "head": "inBody",
            "body": "inBody",
            "frameset": "inFrameset",
            "html": "beforeHead"
    ***REMOVED***
        for node in self.tree.openElements[::-1***REMOVED***:
            nodeName = node.name
            new_phase = None
            if node == self.tree.openElements[0***REMOVED***:
                assert self.innerHTML
                last = True
                nodeName = self.innerHTML
            # Check for conditions that should only happen in the innerHTML
            # case
            if nodeName in ("select", "colgroup", "head", "html"***REMOVED***:
                assert self.innerHTML

            if not last and node.namespace != self.tree.defaultNamespace:
                continue

            if nodeName in newModes:
                new_phase = self.phases[newModes[nodeName***REMOVED******REMOVED***
                break
            elif last:
                new_phase = self.phases["inBody"***REMOVED***
                break

        self.phase = new_phase

    def parseRCDataRawtext(self, token, contentType***REMOVED***:
        ***REMOVED***Generic RCDATA/RAWTEXT Parsing algorithm
        contentType - RCDATA or RAWTEXT
        ***REMOVED***
        assert contentType in ("RAWTEXT", "RCDATA"***REMOVED***

        self.tree.insertElement(token***REMOVED***

        if contentType == "RAWTEXT":
            self.tokenizer.state = self.tokenizer.rawtextState
        else:
            self.tokenizer.state = self.tokenizer.rcdataState

        self.originalPhase = self.phase

        self.phase = self.phases["text"***REMOVED***


def getPhases(debug***REMOVED***:
    def log(function***REMOVED***:
        ***REMOVED***Logger that records which phase processes each token***REMOVED***
        type_names = dict((value, key***REMOVED*** for key, value in
                          constants.tokenTypes.items(***REMOVED******REMOVED***

        def wrapped(self, *args, **kwargs***REMOVED***:
            if function.__name__.startswith("process"***REMOVED*** and len(args***REMOVED*** > 0:
                token = args[0***REMOVED***
                ***REMOVED***
                    info = {"type": type_names[token['type'***REMOVED******REMOVED******REMOVED***
                ***REMOVED***
                    raise
                if token['type'***REMOVED*** in constants.tagTokenTypes:
                    info["name"***REMOVED*** = token['name'***REMOVED***

                self.parser.log.append((self.parser.tokenizer.state.__name__,
                                        self.parser.phase.__class__.__name__,
                                        self.__class__.__name__,
                                        function.__name__,
                                        info***REMOVED******REMOVED***
                return function(self, *args, **kwargs***REMOVED***
            else:
                return function(self, *args, **kwargs***REMOVED***
        return wrapped

    def getMetaclass(use_metaclass, metaclass_func***REMOVED***:
        if use_metaclass:
            return method_decorator_metaclass(metaclass_func***REMOVED***
        else:
            return type

    class Phase(with_metaclass(getMetaclass(debug, log***REMOVED******REMOVED******REMOVED***:
        ***REMOVED***Base class for helper object that implements each phase of processing
        ***REMOVED***

        def __init__(self, parser, tree***REMOVED***:
            self.parser = parser
            self.tree = tree

        def processEOF(self***REMOVED***:
            raise NotImplementedError

        def processComment(self, token***REMOVED***:
            # For most phases the following is correct. Where it's not it will be
            # overridden.
            self.tree.insertComment(token, self.tree.openElements[-1***REMOVED******REMOVED***

        def processDoctype(self, token***REMOVED***:
            self.parser.parseError("unexpected-doctype"***REMOVED***

        def processCharacters(self, token***REMOVED***:
            self.tree.insertText(token["data"***REMOVED******REMOVED***

        def processSpaceCharacters(self, token***REMOVED***:
            self.tree.insertText(token["data"***REMOVED******REMOVED***

        def processStartTag(self, token***REMOVED***:
            return self.startTagHandler[token["name"***REMOVED******REMOVED***(token***REMOVED***

        def startTagHtml(self, token***REMOVED***:
            if not self.parser.firstStartTag and token["name"***REMOVED*** == "html":
                self.parser.parseError("non-html-root"***REMOVED***
            # XXX Need a check here to see if the first start tag token emitted is
            # this token... If it's not, invoke self.parser.parseError(***REMOVED***.
            for attr, value in token["data"***REMOVED***.items(***REMOVED***:
                if attr not in self.tree.openElements[0***REMOVED***.attributes:
                    self.tree.openElements[0***REMOVED***.attributes[attr***REMOVED*** = value
            self.parser.firstStartTag = False

        def processEndTag(self, token***REMOVED***:
            return self.endTagHandler[token["name"***REMOVED******REMOVED***(token***REMOVED***

    class InitialPhase(Phase***REMOVED***:
        def processSpaceCharacters(self, token***REMOVED***:
            pass

        def processComment(self, token***REMOVED***:
            self.tree.insertComment(token, self.tree.document***REMOVED***

        def processDoctype(self, token***REMOVED***:
            name = token["name"***REMOVED***
            publicId = token["publicId"***REMOVED***
            systemId = token["systemId"***REMOVED***
            correct = token["correct"***REMOVED***

            if (name != "html" or publicId is not None or
                    systemId is not None and systemId != "about:legacy-compat"***REMOVED***:
                self.parser.parseError("unknown-doctype"***REMOVED***

            if publicId is None:
                publicId = ""

            self.tree.insertDoctype(token***REMOVED***

            if publicId != "":
                publicId = publicId.translate(asciiUpper2Lower***REMOVED***

            if (not correct or token["name"***REMOVED*** != "html"
                or publicId.startswith(
                    ("+//silmaril//dtd html pro v0r11 19970101//",
                     "-//advasoft ltd//dtd html 3.0 aswedit + extensions//",
                     "-//as//dtd html 3.0 aswedit + extensions//",
                     "-//ietf//dtd html 2.0 level 1//",
                     "-//ietf//dtd html 2.0 level 2//",
                     "-//ietf//dtd html 2.0 strict level 1//",
                     "-//ietf//dtd html 2.0 strict level 2//",
                     "-//ietf//dtd html 2.0 strict//",
                     "-//ietf//dtd html 2.0//",
                     "-//ietf//dtd html 2.1e//",
                     "-//ietf//dtd html 3.0//",
                     "-//ietf//dtd html 3.2 final//",
                     "-//ietf//dtd html 3.2//",
                     "-//ietf//dtd html 3//",
                     "-//ietf//dtd html level 0//",
                     "-//ietf//dtd html level 1//",
                     "-//ietf//dtd html level 2//",
                     "-//ietf//dtd html level 3//",
                     "-//ietf//dtd html strict level 0//",
                     "-//ietf//dtd html strict level 1//",
                     "-//ietf//dtd html strict level 2//",
                     "-//ietf//dtd html strict level 3//",
                     "-//ietf//dtd html strict//",
                     "-//ietf//dtd html//",
                     "-//metrius//dtd metrius presentational//",
                     "-//microsoft//dtd internet explorer 2.0 html strict//",
                     "-//microsoft//dtd internet explorer 2.0 html//",
                     "-//microsoft//dtd internet explorer 2.0 tables//",
                     "-//microsoft//dtd internet explorer 3.0 html strict//",
                     "-//microsoft//dtd internet explorer 3.0 html//",
                     "-//microsoft//dtd internet explorer 3.0 tables//",
                     "-//netscape comm. corp.//dtd html//",
                     "-//netscape comm. corp.//dtd strict html//",
                     "-//o'reilly and associates//dtd html 2.0//",
                     "-//o'reilly and associates//dtd html extended 1.0//",
                     "-//o'reilly and associates//dtd html extended relaxed 1.0//",
                     "-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//",
                     "-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//",
                     "-//spyglass//dtd html 2.0 extended//",
                     "-//sq//dtd html 2.0 hotmetal + extensions//",
                     "-//sun microsystems corp.//dtd hotjava html//",
                     "-//sun microsystems corp.//dtd hotjava strict html//",
                     "-//w3c//dtd html 3 1995-03-24//",
                     "-//w3c//dtd html 3.2 draft//",
                     "-//w3c//dtd html 3.2 final//",
                     "-//w3c//dtd html 3.2//",
                     "-//w3c//dtd html 3.2s draft//",
                     "-//w3c//dtd html 4.0 frameset//",
                     "-//w3c//dtd html 4.0 transitional//",
                     "-//w3c//dtd html experimental 19960712//",
                     "-//w3c//dtd html experimental 970421//",
                     "-//w3c//dtd w3 html//",
                     "-//w3o//dtd w3 html 3.0//",
                     "-//webtechs//dtd mozilla html 2.0//",
                     "-//webtechs//dtd mozilla html//"***REMOVED******REMOVED***
                or publicId in
                    ("-//w3o//dtd w3 html strict 3.0//en//",
                     "-/w3c/dtd html 4.0 transitional/en",
                     "html"***REMOVED***
                or publicId.startswith(
                    ("-//w3c//dtd html 4.01 frameset//",
                     "-//w3c//dtd html 4.01 transitional//"***REMOVED******REMOVED*** and
                    systemId is None
                    or systemId and systemId.lower(***REMOVED*** == "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd"***REMOVED***:
                self.parser.compatMode = "quirks"
            elif (publicId.startswith(
                    ("-//w3c//dtd xhtml 1.0 frameset//",
                     "-//w3c//dtd xhtml 1.0 transitional//"***REMOVED******REMOVED***
                  or publicId.startswith(
                      ("-//w3c//dtd html 4.01 frameset//",
                       "-//w3c//dtd html 4.01 transitional//"***REMOVED******REMOVED*** and
                  systemId is not None***REMOVED***:
                self.parser.compatMode = "limited quirks"

            self.parser.phase = self.parser.phases["beforeHtml"***REMOVED***

        def anythingElse(self***REMOVED***:
            self.parser.compatMode = "quirks"
            self.parser.phase = self.parser.phases["beforeHtml"***REMOVED***

        def processCharacters(self, token***REMOVED***:
            self.parser.parseError("expected-doctype-but-got-chars"***REMOVED***
            self.anythingElse(***REMOVED***
            return token

        def processStartTag(self, token***REMOVED***:
            self.parser.parseError("expected-doctype-but-got-start-tag",
                               ***REMOVED***"name": token["name"***REMOVED******REMOVED******REMOVED***
            self.anythingElse(***REMOVED***
            return token

        def processEndTag(self, token***REMOVED***:
            self.parser.parseError("expected-doctype-but-got-end-tag",
                               ***REMOVED***"name": token["name"***REMOVED******REMOVED******REMOVED***
            self.anythingElse(***REMOVED***
            return token

        def processEOF(self***REMOVED***:
            self.parser.parseError("expected-doctype-but-got-eof"***REMOVED***
            self.anythingElse(***REMOVED***
            return True

    class BeforeHtmlPhase(Phase***REMOVED***:
        # helper methods
        def insertHtmlElement(self***REMOVED***:
            self.tree.insertRoot(impliedTagToken("html", "StartTag"***REMOVED******REMOVED***
            self.parser.phase = self.parser.phases["beforeHead"***REMOVED***

        # other
        def processEOF(self***REMOVED***:
            self.insertHtmlElement(***REMOVED***
            return True

        def processComment(self, token***REMOVED***:
            self.tree.insertComment(token, self.tree.document***REMOVED***

        def processSpaceCharacters(self, token***REMOVED***:
            pass

        def processCharacters(self, token***REMOVED***:
            self.insertHtmlElement(***REMOVED***
            return token

        def processStartTag(self, token***REMOVED***:
            if token["name"***REMOVED*** == "html":
                self.parser.firstStartTag = True
            self.insertHtmlElement(***REMOVED***
            return token

        def processEndTag(self, token***REMOVED***:
            if token["name"***REMOVED*** not in ("head", "body", "html", "br"***REMOVED***:
                self.parser.parseError("unexpected-end-tag-before-html",
                                   ***REMOVED***"name": token["name"***REMOVED******REMOVED******REMOVED***
            else:
                self.insertHtmlElement(***REMOVED***
                return token

    class BeforeHeadPhase(Phase***REMOVED***:
        def __init__(self, parser, tree***REMOVED***:
            Phase.__init__(self, parser, tree***REMOVED***

            self.startTagHandler = utils.MethodDispatcher([
                ("html", self.startTagHtml***REMOVED***,
                ("head", self.startTagHead***REMOVED***
            ***REMOVED******REMOVED***
            self.startTagHandler.default = self.startTagOther

            self.endTagHandler = utils.MethodDispatcher([
                (("head", "body", "html", "br"***REMOVED***, self.endTagImplyHead***REMOVED***
            ***REMOVED******REMOVED***
            self.endTagHandler.default = self.endTagOther

        def processEOF(self***REMOVED***:
            self.startTagHead(impliedTagToken("head", "StartTag"***REMOVED******REMOVED***
            return True

        def processSpaceCharacters(self, token***REMOVED***:
            pass

        def processCharacters(self, token***REMOVED***:
            self.startTagHead(impliedTagToken("head", "StartTag"***REMOVED******REMOVED***
            return token

        def startTagHtml(self, token***REMOVED***:
            return self.parser.phases["inBody"***REMOVED***.processStartTag(token***REMOVED***

        def startTagHead(self, token***REMOVED***:
            self.tree.insertElement(token***REMOVED***
            self.tree.headPointer = self.tree.openElements[-1***REMOVED***
            self.parser.phase = self.parser.phases["inHead"***REMOVED***

        def startTagOther(self, token***REMOVED***:
            self.startTagHead(impliedTagToken("head", "StartTag"***REMOVED******REMOVED***
            return token

        def endTagImplyHead(self, token***REMOVED***:
            self.startTagHead(impliedTagToken("head", "StartTag"***REMOVED******REMOVED***
            return token

        def endTagOther(self, token***REMOVED***:
            self.parser.parseError("end-tag-after-implied-root",
                               ***REMOVED***"name": token["name"***REMOVED******REMOVED******REMOVED***

    class InHeadPhase(Phase***REMOVED***:
        def __init__(self, parser, tree***REMOVED***:
            Phase.__init__(self, parser, tree***REMOVED***

            self.startTagHandler = utils.MethodDispatcher([
                ("html", self.startTagHtml***REMOVED***,
                ("title", self.startTagTitle***REMOVED***,
                (("noscript", "noframes", "style"***REMOVED***, self.startTagNoScriptNoFramesStyle***REMOVED***,
                ("script", self.startTagScript***REMOVED***,
                (("base", "basefont", "bgsound", "command", "link"***REMOVED***,
                 self.startTagBaseLinkCommand***REMOVED***,
                ("meta", self.startTagMeta***REMOVED***,
                ("head", self.startTagHead***REMOVED***
            ***REMOVED******REMOVED***
            self.startTagHandler.default = self.startTagOther

            self. endTagHandler = utils.MethodDispatcher([
                ("head", self.endTagHead***REMOVED***,
                (("br", "html", "body"***REMOVED***, self.endTagHtmlBodyBr***REMOVED***
            ***REMOVED******REMOVED***
            self.endTagHandler.default = self.endTagOther

        # the real thing
        def processEOF(self***REMOVED***:
            self.anythingElse(***REMOVED***
            return True

        def processCharacters(self, token***REMOVED***:
            self.anythingElse(***REMOVED***
            return token

        def startTagHtml(self, token***REMOVED***:
            return self.parser.phases["inBody"***REMOVED***.processStartTag(token***REMOVED***

        def startTagHead(self, token***REMOVED***:
            self.parser.parseError("two-heads-are-not-better-than-one"***REMOVED***

        def startTagBaseLinkCommand(self, token***REMOVED***:
            self.tree.insertElement(token***REMOVED***
            self.tree.openElements.pop(***REMOVED***
            token["selfClosingAcknowledged"***REMOVED*** = True

        def startTagMeta(self, token***REMOVED***:
            self.tree.insertElement(token***REMOVED***
            self.tree.openElements.pop(***REMOVED***
            token["selfClosingAcknowledged"***REMOVED*** = True

            attributes = token["data"***REMOVED***
            if self.parser.tokenizer.stream.charEncoding[1***REMOVED*** == "tentative":
                if "charset" in attributes:
                    self.parser.tokenizer.stream.changeEncoding(attributes["charset"***REMOVED******REMOVED***
                elif ("content" in attributes and
                      "http-equiv" in attributes and
                      attributes["http-equiv"***REMOVED***.lower(***REMOVED*** == "content-type"***REMOVED***:
                    # Encoding it as UTF-8 here is a hack, as really we should pass
                    # the abstract Unicode string, and just use the
                    # ContentAttrParser on that, but using UTF-8 allows all chars
                    # to be encoded and as a ASCII-superset works.
                    data = inputstream.EncodingBytes(attributes["content"***REMOVED***.encode("utf-8"***REMOVED******REMOVED***
                    parser = inputstream.ContentAttrParser(data***REMOVED***
                    codec = parser.parse(***REMOVED***
                    self.parser.tokenizer.stream.changeEncoding(codec***REMOVED***

        def startTagTitle(self, token***REMOVED***:
            self.parser.parseRCDataRawtext(token, "RCDATA"***REMOVED***

        def startTagNoScriptNoFramesStyle(self, token***REMOVED***:
            # Need to decide whether to implement the scripting-disabled case
            self.parser.parseRCDataRawtext(token, "RAWTEXT"***REMOVED***

        def startTagScript(self, token***REMOVED***:
            self.tree.insertElement(token***REMOVED***
            self.parser.tokenizer.state = self.parser.tokenizer.scriptDataState
            self.parser.originalPhase = self.parser.phase
            self.parser.phase = self.parser.phases["text"***REMOVED***

        def startTagOther(self, token***REMOVED***:
            self.anythingElse(***REMOVED***
            return token

        def endTagHead(self, token***REMOVED***:
            node = self.parser.tree.openElements.pop(***REMOVED***
            assert node.name == "head", "Expected head got %s" % node.name
            self.parser.phase = self.parser.phases["afterHead"***REMOVED***

        def endTagHtmlBodyBr(self, token***REMOVED***:
            self.anythingElse(***REMOVED***
            return token

        def endTagOther(self, token***REMOVED***:
            self.parser.parseError("unexpected-end-tag", {"name": token["name"***REMOVED******REMOVED******REMOVED***

        def anythingElse(self***REMOVED***:
            self.endTagHead(impliedTagToken("head"***REMOVED******REMOVED***

    # XXX If we implement a parser for which scripting is disabled we need to
    # implement this phase.
    #
    # class InHeadNoScriptPhase(Phase***REMOVED***:
    class AfterHeadPhase(Phase***REMOVED***:
        def __init__(self, parser, tree***REMOVED***:
            Phase.__init__(self, parser, tree***REMOVED***

            self.startTagHandler = utils.MethodDispatcher([
                ("html", self.startTagHtml***REMOVED***,
                ("body", self.startTagBody***REMOVED***,
                ("frameset", self.startTagFrameset***REMOVED***,
                (("base", "basefont", "bgsound", "link", "meta", "noframes", "script",
                  "style", "title"***REMOVED***,
                 self.startTagFromHead***REMOVED***,
                ("head", self.startTagHead***REMOVED***
            ***REMOVED******REMOVED***
            self.startTagHandler.default = self.startTagOther
            self.endTagHandler = utils.MethodDispatcher([(("body", "html", "br"***REMOVED***,
                                                          self.endTagHtmlBodyBr***REMOVED******REMOVED******REMOVED***
            self.endTagHandler.default = self.endTagOther

        def processEOF(self***REMOVED***:
            self.anythingElse(***REMOVED***
            return True

        def processCharacters(self, token***REMOVED***:
            self.anythingElse(***REMOVED***
            return token

        def startTagHtml(self, token***REMOVED***:
            return self.parser.phases["inBody"***REMOVED***.processStartTag(token***REMOVED***

        def startTagBody(self, token***REMOVED***:
            self.parser.framesetOK = False
            self.tree.insertElement(token***REMOVED***
            self.parser.phase = self.parser.phases["inBody"***REMOVED***

        def startTagFrameset(self, token***REMOVED***:
            self.tree.insertElement(token***REMOVED***
            self.parser.phase = self.parser.phases["inFrameset"***REMOVED***

        def startTagFromHead(self, token***REMOVED***:
            self.parser.parseError("unexpected-start-tag-out-of-my-head",
                               ***REMOVED***"name": token["name"***REMOVED******REMOVED******REMOVED***
            self.tree.openElements.append(self.tree.headPointer***REMOVED***
            self.parser.phases["inHead"***REMOVED***.processStartTag(token***REMOVED***
            for node in self.tree.openElements[::-1***REMOVED***:
                if node.name == "head":
                    self.tree.openElements.remove(node***REMOVED***
                    break

        def startTagHead(self, token***REMOVED***:
            self.parser.parseError("unexpected-start-tag", {"name": token["name"***REMOVED******REMOVED******REMOVED***

        def startTagOther(self, token***REMOVED***:
            self.anythingElse(***REMOVED***
            return token

        def endTagHtmlBodyBr(self, token***REMOVED***:
            self.anythingElse(***REMOVED***
            return token

        def endTagOther(self, token***REMOVED***:
            self.parser.parseError("unexpected-end-tag", {"name": token["name"***REMOVED******REMOVED******REMOVED***

        def anythingElse(self***REMOVED***:
            self.tree.insertElement(impliedTagToken("body", "StartTag"***REMOVED******REMOVED***
            self.parser.phase = self.parser.phases["inBody"***REMOVED***
            self.parser.framesetOK = True

    class InBodyPhase(Phase***REMOVED***:
        # http://www.whatwg.org/specs/web-apps/current-work/#parsing-main-inbody
        # the really-really-really-very crazy mode
        def __init__(self, parser, tree***REMOVED***:
            Phase.__init__(self, parser, tree***REMOVED***

            # Keep a ref to this for special handling of whitespace in <pre>
            self.processSpaceCharactersNonPre = self.processSpaceCharacters

            self.startTagHandler = utils.MethodDispatcher([
                ("html", self.startTagHtml***REMOVED***,
                (("base", "basefont", "bgsound", "command", "link", "meta",
                  "script", "style", "title"***REMOVED***,
                 self.startTagProcessInHead***REMOVED***,
                ("body", self.startTagBody***REMOVED***,
                ("frameset", self.startTagFrameset***REMOVED***,
                (("address", "article", "aside", "blockquote", "center", "details",
                  "details", "dir", "div", "dl", "fieldset", "figcaption", "figure",
                  "footer", "header", "hgroup", "main", "menu", "nav", "ol", "p",
                  "section", "summary", "ul"***REMOVED***,
                 self.startTagCloseP***REMOVED***,
                (headingElements, self.startTagHeading***REMOVED***,
                (("pre", "listing"***REMOVED***, self.startTagPreListing***REMOVED***,
                ("form", self.startTagForm***REMOVED***,
                (("li", "dd", "dt"***REMOVED***, self.startTagListItem***REMOVED***,
                ("plaintext", self.startTagPlaintext***REMOVED***,
                ("a", self.startTagA***REMOVED***,
                (("b", "big", "code", "em", "font", "i", "s", "small", "strike",
                  "strong", "tt", "u"***REMOVED***, self.startTagFormatting***REMOVED***,
                ("nobr", self.startTagNobr***REMOVED***,
                ("button", self.startTagButton***REMOVED***,
                (("applet", "marquee", "object"***REMOVED***, self.startTagAppletMarqueeObject***REMOVED***,
                ("xmp", self.startTagXmp***REMOVED***,
                ("table", self.startTagTable***REMOVED***,
                (("area", "br", "embed", "img", "keygen", "wbr"***REMOVED***,
                 self.startTagVoidFormatting***REMOVED***,
                (("param", "source", "track"***REMOVED***, self.startTagParamSource***REMOVED***,
                ("input", self.startTagInput***REMOVED***,
                ("hr", self.startTagHr***REMOVED***,
                ("image", self.startTagImage***REMOVED***,
                ("isindex", self.startTagIsIndex***REMOVED***,
                ("textarea", self.startTagTextarea***REMOVED***,
                ("iframe", self.startTagIFrame***REMOVED***,
                (("noembed", "noframes", "noscript"***REMOVED***, self.startTagRawtext***REMOVED***,
                ("select", self.startTagSelect***REMOVED***,
                (("rp", "rt"***REMOVED***, self.startTagRpRt***REMOVED***,
                (("option", "optgroup"***REMOVED***, self.startTagOpt***REMOVED***,
                (("math"***REMOVED***, self.startTagMath***REMOVED***,
                (("svg"***REMOVED***, self.startTagSvg***REMOVED***,
                (("caption", "col", "colgroup", "frame", "head",
                  "tbody", "td", "tfoot", "th", "thead",
                  "tr"***REMOVED***, self.startTagMisplaced***REMOVED***
            ***REMOVED******REMOVED***
            self.startTagHandler.default = self.startTagOther

            self.endTagHandler = utils.MethodDispatcher([
                ("body", self.endTagBody***REMOVED***,
                ("html", self.endTagHtml***REMOVED***,
                (("address", "article", "aside", "blockquote", "button", "center",
                  "details", "dialog", "dir", "div", "dl", "fieldset", "figcaption", "figure",
                  "footer", "header", "hgroup", "listing", "main", "menu", "nav", "ol", "pre",
                  "section", "summary", "ul"***REMOVED***, self.endTagBlock***REMOVED***,
                ("form", self.endTagForm***REMOVED***,
                ("p", self.endTagP***REMOVED***,
                (("dd", "dt", "li"***REMOVED***, self.endTagListItem***REMOVED***,
                (headingElements, self.endTagHeading***REMOVED***,
                (("a", "b", "big", "code", "em", "font", "i", "nobr", "s", "small",
                  "strike", "strong", "tt", "u"***REMOVED***, self.endTagFormatting***REMOVED***,
                (("applet", "marquee", "object"***REMOVED***, self.endTagAppletMarqueeObject***REMOVED***,
                ("br", self.endTagBr***REMOVED***,
            ***REMOVED******REMOVED***
            self.endTagHandler.default = self.endTagOther

        def isMatchingFormattingElement(self, node1, node2***REMOVED***:
            if node1.name != node2.name or node1.namespace != node2.namespace:
                return False
            elif len(node1.attributes***REMOVED*** != len(node2.attributes***REMOVED***:
                return False
            else:
                attributes1 = sorted(node1.attributes.items(***REMOVED******REMOVED***
                attributes2 = sorted(node2.attributes.items(***REMOVED******REMOVED***
                for attr1, attr2 in zip(attributes1, attributes2***REMOVED***:
                    if attr1 != attr2:
                        return False
            return True

        # helper
        def addFormattingElement(self, token***REMOVED***:
            self.tree.insertElement(token***REMOVED***
            element = self.tree.openElements[-1***REMOVED***

            matchingElements = [***REMOVED***
            for node in self.tree.activeFormattingElements[::-1***REMOVED***:
                if node is Marker:
                    break
                elif self.isMatchingFormattingElement(node, element***REMOVED***:
                    matchingElements.append(node***REMOVED***

            assert len(matchingElements***REMOVED*** <= 3
            if len(matchingElements***REMOVED*** == 3:
                self.tree.activeFormattingElements.remove(matchingElements[-1***REMOVED******REMOVED***
            self.tree.activeFormattingElements.append(element***REMOVED***

        # the real deal
        def processEOF(self***REMOVED***:
            allowed_elements = frozenset(("dd", "dt", "li", "p", "tbody", "td",
                                          "tfoot", "th", "thead", "tr", "body",
                                          "html"***REMOVED******REMOVED***
            for node in self.tree.openElements[::-1***REMOVED***:
                if node.name not in allowed_elements:
                    self.parser.parseError("expected-closing-tag-but-got-eof"***REMOVED***
                    break
            # Stop parsing

        def processSpaceCharactersDropNewline(self, token***REMOVED***:
            # Sometimes (start of <pre>, <listing>, and <textarea> blocks***REMOVED*** we
            # want to drop leading newlines
            data = token["data"***REMOVED***
            self.processSpaceCharacters = self.processSpaceCharactersNonPre
            if (data.startswith("\n"***REMOVED*** and
                self.tree.openElements[-1***REMOVED***.name in ("pre", "listing", "textarea"***REMOVED***
                    and not self.tree.openElements[-1***REMOVED***.hasContent(***REMOVED******REMOVED***:
                data = data[1:***REMOVED***
            if data:
                self.tree.reconstructActiveFormattingElements(***REMOVED***
                self.tree.insertText(data***REMOVED***

        def processCharacters(self, token***REMOVED***:
            if token["data"***REMOVED*** == "\u0000":
                # The tokenizer should always emit null on its own
                return
            self.tree.reconstructActiveFormattingElements(***REMOVED***
            self.tree.insertText(token["data"***REMOVED******REMOVED***
            # This must be bad for performance
            if (self.parser.framesetOK and
                any([char not in spaceCharacters
                     for char in token["data"***REMOVED******REMOVED******REMOVED******REMOVED***:
                self.parser.framesetOK = False

        def processSpaceCharacters(self, token***REMOVED***:
            self.tree.reconstructActiveFormattingElements(***REMOVED***
            self.tree.insertText(token["data"***REMOVED******REMOVED***

        def startTagProcessInHead(self, token***REMOVED***:
            return self.parser.phases["inHead"***REMOVED***.processStartTag(token***REMOVED***

        def startTagBody(self, token***REMOVED***:
            self.parser.parseError("unexpected-start-tag", {"name": "body"***REMOVED******REMOVED***
            if (len(self.tree.openElements***REMOVED*** == 1
                    or self.tree.openElements[1***REMOVED***.name != "body"***REMOVED***:
                assert self.parser.innerHTML
            else:
                self.parser.framesetOK = False
                for attr, value in token["data"***REMOVED***.items(***REMOVED***:
                    if attr not in self.tree.openElements[1***REMOVED***.attributes:
                        self.tree.openElements[1***REMOVED***.attributes[attr***REMOVED*** = value

        def startTagFrameset(self, token***REMOVED***:
            self.parser.parseError("unexpected-start-tag", {"name": "frameset"***REMOVED******REMOVED***
            if (len(self.tree.openElements***REMOVED*** == 1 or self.tree.openElements[1***REMOVED***.name != "body"***REMOVED***:
                assert self.parser.innerHTML
            elif not self.parser.framesetOK:
                pass
            else:
                if self.tree.openElements[1***REMOVED***.parent:
                    self.tree.openElements[1***REMOVED***.parent.removeChild(self.tree.openElements[1***REMOVED******REMOVED***
                while self.tree.openElements[-1***REMOVED***.name != "html":
                    self.tree.openElements.pop(***REMOVED***
                self.tree.insertElement(token***REMOVED***
                self.parser.phase = self.parser.phases["inFrameset"***REMOVED***

        def startTagCloseP(self, token***REMOVED***:
            if self.tree.elementInScope("p", variant="button"***REMOVED***:
                self.endTagP(impliedTagToken("p"***REMOVED******REMOVED***
            self.tree.insertElement(token***REMOVED***

        def startTagPreListing(self, token***REMOVED***:
            if self.tree.elementInScope("p", variant="button"***REMOVED***:
                self.endTagP(impliedTagToken("p"***REMOVED******REMOVED***
            self.tree.insertElement(token***REMOVED***
            self.parser.framesetOK = False
            self.processSpaceCharacters = self.processSpaceCharactersDropNewline

        def startTagForm(self, token***REMOVED***:
            if self.tree.formPointer:
                self.parser.parseError("unexpected-start-tag", {"name": "form"***REMOVED******REMOVED***
            else:
                if self.tree.elementInScope("p", variant="button"***REMOVED***:
                    self.endTagP(impliedTagToken("p"***REMOVED******REMOVED***
                self.tree.insertElement(token***REMOVED***
                self.tree.formPointer = self.tree.openElements[-1***REMOVED***

        def startTagListItem(self, token***REMOVED***:
            self.parser.framesetOK = False

            stopNamesMap = {"li": ["li"***REMOVED***,
                            "dt": ["dt", "dd"***REMOVED***,
                            "dd": ["dt", "dd"***REMOVED******REMOVED***
            stopNames = stopNamesMap[token["name"***REMOVED******REMOVED***
            for node in reversed(self.tree.openElements***REMOVED***:
                if node.name in stopNames:
                    self.parser.phase.processEndTag(
                        impliedTagToken(node.name, "EndTag"***REMOVED******REMOVED***
                    break
                if (node.nameTuple in specialElements and
                        node.name not in ("address", "div", "p"***REMOVED******REMOVED***:
                    break

            if self.tree.elementInScope("p", variant="button"***REMOVED***:
                self.parser.phase.processEndTag(
                    impliedTagToken("p", "EndTag"***REMOVED******REMOVED***

            self.tree.insertElement(token***REMOVED***

        def startTagPlaintext(self, token***REMOVED***:
            if self.tree.elementInScope("p", variant="button"***REMOVED***:
                self.endTagP(impliedTagToken("p"***REMOVED******REMOVED***
            self.tree.insertElement(token***REMOVED***
            self.parser.tokenizer.state = self.parser.tokenizer.plaintextState

        def startTagHeading(self, token***REMOVED***:
            if self.tree.elementInScope("p", variant="button"***REMOVED***:
                self.endTagP(impliedTagToken("p"***REMOVED******REMOVED***
            if self.tree.openElements[-1***REMOVED***.name in headingElements:
                self.parser.parseError("unexpected-start-tag", {"name": token["name"***REMOVED******REMOVED******REMOVED***
                self.tree.openElements.pop(***REMOVED***
            self.tree.insertElement(token***REMOVED***

        def startTagA(self, token***REMOVED***:
            afeAElement = self.tree.elementInActiveFormattingElements("a"***REMOVED***
            if afeAElement:
                self.parser.parseError("unexpected-start-tag-implies-end-tag",
                                   ***REMOVED***"startName": "a", "endName": "a"***REMOVED******REMOVED***
                self.endTagFormatting(impliedTagToken("a"***REMOVED******REMOVED***
                if afeAElement in self.tree.openElements:
                    self.tree.openElements.remove(afeAElement***REMOVED***
                if afeAElement in self.tree.activeFormattingElements:
                    self.tree.activeFormattingElements.remove(afeAElement***REMOVED***
            self.tree.reconstructActiveFormattingElements(***REMOVED***
            self.addFormattingElement(token***REMOVED***

        def startTagFormatting(self, token***REMOVED***:
            self.tree.reconstructActiveFormattingElements(***REMOVED***
            self.addFormattingElement(token***REMOVED***

        def startTagNobr(self, token***REMOVED***:
            self.tree.reconstructActiveFormattingElements(***REMOVED***
            if self.tree.elementInScope("nobr"***REMOVED***:
                self.parser.parseError("unexpected-start-tag-implies-end-tag",
                                   ***REMOVED***"startName": "nobr", "endName": "nobr"***REMOVED******REMOVED***
                self.processEndTag(impliedTagToken("nobr"***REMOVED******REMOVED***
                # XXX Need tests that trigger the following
                self.tree.reconstructActiveFormattingElements(***REMOVED***
            self.addFormattingElement(token***REMOVED***

        def startTagButton(self, token***REMOVED***:
            if self.tree.elementInScope("button"***REMOVED***:
                self.parser.parseError("unexpected-start-tag-implies-end-tag",
                                   ***REMOVED***"startName": "button", "endName": "button"***REMOVED******REMOVED***
                self.processEndTag(impliedTagToken("button"***REMOVED******REMOVED***
                return token
            else:
                self.tree.reconstructActiveFormattingElements(***REMOVED***
                self.tree.insertElement(token***REMOVED***
                self.parser.framesetOK = False

        def startTagAppletMarqueeObject(self, token***REMOVED***:
            self.tree.reconstructActiveFormattingElements(***REMOVED***
            self.tree.insertElement(token***REMOVED***
            self.tree.activeFormattingElements.append(Marker***REMOVED***
            self.parser.framesetOK = False

        def startTagXmp(self, token***REMOVED***:
            if self.tree.elementInScope("p", variant="button"***REMOVED***:
                self.endTagP(impliedTagToken("p"***REMOVED******REMOVED***
            self.tree.reconstructActiveFormattingElements(***REMOVED***
            self.parser.framesetOK = False
            self.parser.parseRCDataRawtext(token, "RAWTEXT"***REMOVED***

        def startTagTable(self, token***REMOVED***:
            if self.parser.compatMode != "quirks":
                if self.tree.elementInScope("p", variant="button"***REMOVED***:
                    self.processEndTag(impliedTagToken("p"***REMOVED******REMOVED***
            self.tree.insertElement(token***REMOVED***
            self.parser.framesetOK = False
            self.parser.phase = self.parser.phases["inTable"***REMOVED***

        def startTagVoidFormatting(self, token***REMOVED***:
            self.tree.reconstructActiveFormattingElements(***REMOVED***
            self.tree.insertElement(token***REMOVED***
            self.tree.openElements.pop(***REMOVED***
            token["selfClosingAcknowledged"***REMOVED*** = True
            self.parser.framesetOK = False

        def startTagInput(self, token***REMOVED***:
            framesetOK = self.parser.framesetOK
            self.startTagVoidFormatting(token***REMOVED***
            if ("type" in token["data"***REMOVED*** and
                    token["data"***REMOVED***["type"***REMOVED***.translate(asciiUpper2Lower***REMOVED*** == "hidden"***REMOVED***:
                # input type=hidden doesn't change framesetOK
                self.parser.framesetOK = framesetOK

        def startTagParamSource(self, token***REMOVED***:
            self.tree.insertElement(token***REMOVED***
            self.tree.openElements.pop(***REMOVED***
            token["selfClosingAcknowledged"***REMOVED*** = True

        def startTagHr(self, token***REMOVED***:
            if self.tree.elementInScope("p", variant="button"***REMOVED***:
                self.endTagP(impliedTagToken("p"***REMOVED******REMOVED***
            self.tree.insertElement(token***REMOVED***
            self.tree.openElements.pop(***REMOVED***
            token["selfClosingAcknowledged"***REMOVED*** = True
            self.parser.framesetOK = False

        def startTagImage(self, token***REMOVED***:
            # No really...
            self.parser.parseError("unexpected-start-tag-treated-as",
                               ***REMOVED***"originalName": "image", "newName": "img"***REMOVED******REMOVED***
            self.processStartTag(impliedTagToken("img", "StartTag",
                                                 attributes=token["data"***REMOVED***,
                                                 selfClosing=token["selfClosing"***REMOVED******REMOVED******REMOVED***

        def startTagIsIndex(self, token***REMOVED***:
            self.parser.parseError("deprecated-tag", {"name": "isindex"***REMOVED******REMOVED***
            if self.tree.formPointer:
                return
            form_attrs = {***REMOVED***
            if "action" in token["data"***REMOVED***:
                form_attrs["action"***REMOVED*** = token["data"***REMOVED***["action"***REMOVED***
            self.processStartTag(impliedTagToken("form", "StartTag",
                                                 attributes=form_attrs***REMOVED******REMOVED***
            self.processStartTag(impliedTagToken("hr", "StartTag"***REMOVED******REMOVED***
            self.processStartTag(impliedTagToken("label", "StartTag"***REMOVED******REMOVED***
            # XXX Localization ...
            if "prompt" in token["data"***REMOVED***:
                prompt = token["data"***REMOVED***["prompt"***REMOVED***
            else:
                prompt = "This is a searchable index. Enter search keywords: "
            self.processCharacters(
            ***REMOVED***"type": tokenTypes["Characters"***REMOVED***, "data": prompt***REMOVED******REMOVED***
            attributes = token["data"***REMOVED***.copy(***REMOVED***
            if "action" in attributes:
                del attributes["action"***REMOVED***
            if "prompt" in attributes:
                del attributes["prompt"***REMOVED***
            attributes["name"***REMOVED*** = "isindex"
            self.processStartTag(impliedTagToken("input", "StartTag",
                                                 attributes=attributes,
                                                 selfClosing=token["selfClosing"***REMOVED******REMOVED******REMOVED***
            self.processEndTag(impliedTagToken("label"***REMOVED******REMOVED***
            self.processStartTag(impliedTagToken("hr", "StartTag"***REMOVED******REMOVED***
            self.processEndTag(impliedTagToken("form"***REMOVED******REMOVED***

        def startTagTextarea(self, token***REMOVED***:
            self.tree.insertElement(token***REMOVED***
            self.parser.tokenizer.state = self.parser.tokenizer.rcdataState
            self.processSpaceCharacters = self.processSpaceCharactersDropNewline
            self.parser.framesetOK = False

        def startTagIFrame(self, token***REMOVED***:
            self.parser.framesetOK = False
            self.startTagRawtext(token***REMOVED***

        def startTagRawtext(self, token***REMOVED***:
            ***REMOVED***iframe, noembed noframes, noscript(if scripting enabled***REMOVED******REMOVED***
            self.parser.parseRCDataRawtext(token, "RAWTEXT"***REMOVED***

        def startTagOpt(self, token***REMOVED***:
            if self.tree.openElements[-1***REMOVED***.name == "option":
                self.parser.phase.processEndTag(impliedTagToken("option"***REMOVED******REMOVED***
            self.tree.reconstructActiveFormattingElements(***REMOVED***
            self.parser.tree.insertElement(token***REMOVED***

        def startTagSelect(self, token***REMOVED***:
            self.tree.reconstructActiveFormattingElements(***REMOVED***
            self.tree.insertElement(token***REMOVED***
            self.parser.framesetOK = False
            if self.parser.phase in (self.parser.phases["inTable"***REMOVED***,
                                     self.parser.phases["inCaption"***REMOVED***,
                                     self.parser.phases["inColumnGroup"***REMOVED***,
                                     self.parser.phases["inTableBody"***REMOVED***,
                                     self.parser.phases["inRow"***REMOVED***,
                                     self.parser.phases["inCell"***REMOVED******REMOVED***:
                self.parser.phase = self.parser.phases["inSelectInTable"***REMOVED***
            else:
                self.parser.phase = self.parser.phases["inSelect"***REMOVED***

        def startTagRpRt(self, token***REMOVED***:
            if self.tree.elementInScope("ruby"***REMOVED***:
                self.tree.generateImpliedEndTags(***REMOVED***
                if self.tree.openElements[-1***REMOVED***.name != "ruby":
                    self.parser.parseError(***REMOVED***
            self.tree.insertElement(token***REMOVED***

        def startTagMath(self, token***REMOVED***:
            self.tree.reconstructActiveFormattingElements(***REMOVED***
            self.parser.adjustMathMLAttributes(token***REMOVED***
            self.parser.adjustForeignAttributes(token***REMOVED***
            token["namespace"***REMOVED*** = namespaces["mathml"***REMOVED***
            self.tree.insertElement(token***REMOVED***
            # Need to get the parse error right for the case where the token
            # has a namespace not equal to the xmlns attribute
            if token["selfClosing"***REMOVED***:
                self.tree.openElements.pop(***REMOVED***
                token["selfClosingAcknowledged"***REMOVED*** = True

        def startTagSvg(self, token***REMOVED***:
            self.tree.reconstructActiveFormattingElements(***REMOVED***
            self.parser.adjustSVGAttributes(token***REMOVED***
            self.parser.adjustForeignAttributes(token***REMOVED***
            token["namespace"***REMOVED*** = namespaces["svg"***REMOVED***
            self.tree.insertElement(token***REMOVED***
            # Need to get the parse error right for the case where the token
            # has a namespace not equal to the xmlns attribute
            if token["selfClosing"***REMOVED***:
                self.tree.openElements.pop(***REMOVED***
                token["selfClosingAcknowledged"***REMOVED*** = True

        def startTagMisplaced(self, token***REMOVED***:
            ***REMOVED*** Elements that should be children of other elements that have a
            different insertion mode; here they are ignored
            "caption", "col", "colgroup", "frame", "frameset", "head",
            "option", "optgroup", "tbody", "td", "tfoot", "th", "thead",
            "tr", "noscript"
            ***REMOVED***
            self.parser.parseError("unexpected-start-tag-ignored", {"name": token["name"***REMOVED******REMOVED******REMOVED***

        def startTagOther(self, token***REMOVED***:
            self.tree.reconstructActiveFormattingElements(***REMOVED***
            self.tree.insertElement(token***REMOVED***

        def endTagP(self, token***REMOVED***:
            if not self.tree.elementInScope("p", variant="button"***REMOVED***:
                self.startTagCloseP(impliedTagToken("p", "StartTag"***REMOVED******REMOVED***
                self.parser.parseError("unexpected-end-tag", {"name": "p"***REMOVED******REMOVED***
                self.endTagP(impliedTagToken("p", "EndTag"***REMOVED******REMOVED***
            else:
                self.tree.generateImpliedEndTags("p"***REMOVED***
                if self.tree.openElements[-1***REMOVED***.name != "p":
                    self.parser.parseError("unexpected-end-tag", {"name": "p"***REMOVED******REMOVED***
                node = self.tree.openElements.pop(***REMOVED***
                while node.name != "p":
                    node = self.tree.openElements.pop(***REMOVED***

        def endTagBody(self, token***REMOVED***:
            if not self.tree.elementInScope("body"***REMOVED***:
                self.parser.parseError(***REMOVED***
                return
            elif self.tree.openElements[-1***REMOVED***.name != "body":
                for node in self.tree.openElements[2:***REMOVED***:
                    if node.name not in frozenset(("dd", "dt", "li", "optgroup",
                                                   "option", "p", "rp", "rt",
                                                   "tbody", "td", "tfoot",
                                                   "th", "thead", "tr", "body",
                                                   "html"***REMOVED******REMOVED***:
                        # Not sure this is the correct name for the parse error
                        self.parser.parseError(
                            "expected-one-end-tag-but-got-another",
                        ***REMOVED***"expectedName": "body", "gotName": node.name***REMOVED******REMOVED***
                        break
            self.parser.phase = self.parser.phases["afterBody"***REMOVED***

        def endTagHtml(self, token***REMOVED***:
            # We repeat the test for the body end tag token being ignored here
            if self.tree.elementInScope("body"***REMOVED***:
                self.endTagBody(impliedTagToken("body"***REMOVED******REMOVED***
                return token

        def endTagBlock(self, token***REMOVED***:
            # Put us back in the right whitespace handling mode
            if token["name"***REMOVED*** == "pre":
                self.processSpaceCharacters = self.processSpaceCharactersNonPre
            inScope = self.tree.elementInScope(token["name"***REMOVED******REMOVED***
            if inScope:
                self.tree.generateImpliedEndTags(***REMOVED***
            if self.tree.openElements[-1***REMOVED***.name != token["name"***REMOVED***:
                self.parser.parseError("end-tag-too-early", {"name": token["name"***REMOVED******REMOVED******REMOVED***
            if inScope:
                node = self.tree.openElements.pop(***REMOVED***
                while node.name != token["name"***REMOVED***:
                    node = self.tree.openElements.pop(***REMOVED***

        def endTagForm(self, token***REMOVED***:
            node = self.tree.formPointer
            self.tree.formPointer = None
            if node is None or not self.tree.elementInScope(node***REMOVED***:
                self.parser.parseError("unexpected-end-tag",
                                   ***REMOVED***"name": "form"***REMOVED******REMOVED***
            else:
                self.tree.generateImpliedEndTags(***REMOVED***
                if self.tree.openElements[-1***REMOVED*** != node:
                    self.parser.parseError("end-tag-too-early-ignored",
                                       ***REMOVED***"name": "form"***REMOVED******REMOVED***
                self.tree.openElements.remove(node***REMOVED***

        def endTagListItem(self, token***REMOVED***:
            if token["name"***REMOVED*** == "li":
                variant = "list"
            else:
                variant = None
            if not self.tree.elementInScope(token["name"***REMOVED***, variant=variant***REMOVED***:
                self.parser.parseError("unexpected-end-tag", {"name": token["name"***REMOVED******REMOVED******REMOVED***
            else:
                self.tree.generateImpliedEndTags(exclude=token["name"***REMOVED******REMOVED***
                if self.tree.openElements[-1***REMOVED***.name != token["name"***REMOVED***:
                    self.parser.parseError(
                        "end-tag-too-early",
                    ***REMOVED***"name": token["name"***REMOVED******REMOVED******REMOVED***
                node = self.tree.openElements.pop(***REMOVED***
                while node.name != token["name"***REMOVED***:
                    node = self.tree.openElements.pop(***REMOVED***

        def endTagHeading(self, token***REMOVED***:
            for item in headingElements:
                if self.tree.elementInScope(item***REMOVED***:
                    self.tree.generateImpliedEndTags(***REMOVED***
                    break
            if self.tree.openElements[-1***REMOVED***.name != token["name"***REMOVED***:
                self.parser.parseError("end-tag-too-early", {"name": token["name"***REMOVED******REMOVED******REMOVED***

            for item in headingElements:
                if self.tree.elementInScope(item***REMOVED***:
                    item = self.tree.openElements.pop(***REMOVED***
                    while item.name not in headingElements:
                        item = self.tree.openElements.pop(***REMOVED***
                    break

        def endTagFormatting(self, token***REMOVED***:
            ***REMOVED***The much-feared adoption agency algorithm***REMOVED***
            # http://svn.whatwg.org/webapps/complete.html#adoptionAgency revision 7867
            # XXX Better parseError messages appreciated.

            # Step 1
            outerLoopCounter = 0

            # Step 2
            while outerLoopCounter < 8:

                # Step 3
                outerLoopCounter += 1

                # Step 4:

                # Let the formatting element be the last element in
                # the list of active formatting elements that:
                # - is between the end of the list and the last scope
                # marker in the list, if any, or the start of the list
                # otherwise, and
                # - has the same tag name as the token.
                formattingElement = self.tree.elementInActiveFormattingElements(
                    token["name"***REMOVED******REMOVED***
                if (not formattingElement or
                    (formattingElement in self.tree.openElements and
                     not self.tree.elementInScope(formattingElement.name***REMOVED******REMOVED******REMOVED***:
                    # If there is no such node, then abort these steps
                    # and instead act as described in the "any other
                    # end tag" entry below.
                    self.endTagOther(token***REMOVED***
                    return

                # Otherwise, if there is such a node, but that node is
                # not in the stack of open elements, then this is a
                # parse error; remove the element from the list, and
                # abort these steps.
                elif formattingElement not in self.tree.openElements:
                    self.parser.parseError("adoption-agency-1.2", {"name": token["name"***REMOVED******REMOVED******REMOVED***
                    self.tree.activeFormattingElements.remove(formattingElement***REMOVED***
                    return

                # Otherwise, if there is such a node, and that node is
                # also in the stack of open elements, but the element
                # is not in scope, then this is a parse error; ignore
                # the token, and abort these steps.
                elif not self.tree.elementInScope(formattingElement.name***REMOVED***:
                    self.parser.parseError("adoption-agency-4.4", {"name": token["name"***REMOVED******REMOVED******REMOVED***
                    return

                # Otherwise, there is a formatting element and that
                # element is in the stack and is in scope. If the
                # element is not the current node, this is a parse
                # error. In any case, proceed with the algorithm as
                # written in the following steps.
                else:
                    if formattingElement != self.tree.openElements[-1***REMOVED***:
                        self.parser.parseError("adoption-agency-1.3", {"name": token["name"***REMOVED******REMOVED******REMOVED***

                # Step 5:

                # Let the furthest block be the topmost node in the
                # stack of open elements that is lower in the stack
                # than the formatting element, and is an element in
                # the special category. There might not be one.
                afeIndex = self.tree.openElements.index(formattingElement***REMOVED***
                furthestBlock = None
                for element in self.tree.openElements[afeIndex:***REMOVED***:
                    if element.nameTuple in specialElements:
                        furthestBlock = element
                        break

                # Step 6:

                # If there is no furthest block, then the UA must
                # first pop all the nodes from the bottom of the stack
                # of open elements, from the current node up to and
                # including the formatting element, then remove the
                # formatting element from the list of active
                # formatting elements, and finally abort these steps.
                if furthestBlock is None:
                    element = self.tree.openElements.pop(***REMOVED***
                    while element != formattingElement:
                        element = self.tree.openElements.pop(***REMOVED***
                    self.tree.activeFormattingElements.remove(element***REMOVED***
                    return

                # Step 7
                commonAncestor = self.tree.openElements[afeIndex - 1***REMOVED***

                # Step 8:
                # The bookmark is supposed to help us identify where to reinsert
                # nodes in step 15. We have to ensure that we reinsert nodes after
                # the node before the active formatting element. Note the bookmark
                # can move in step 9.7
                bookmark = self.tree.activeFormattingElements.index(formattingElement***REMOVED***

                # Step 9
                lastNode = node = furthestBlock
                innerLoopCounter = 0

                index = self.tree.openElements.index(node***REMOVED***
                while innerLoopCounter < 3:
                    innerLoopCounter += 1
                    # Node is element before node in open elements
                    index -= 1
                    node = self.tree.openElements[index***REMOVED***
                    if node not in self.tree.activeFormattingElements:
                        self.tree.openElements.remove(node***REMOVED***
                        continue
                    # Step 9.6
                    if node == formattingElement:
                        break
                    # Step 9.7
                    if lastNode == furthestBlock:
                        bookmark = self.tree.activeFormattingElements.index(node***REMOVED*** + 1
                    # Step 9.8
                    clone = node.cloneNode(***REMOVED***
                    # Replace node with clone
                    self.tree.activeFormattingElements[
                        self.tree.activeFormattingElements.index(node***REMOVED******REMOVED*** = clone
                    self.tree.openElements[
                        self.tree.openElements.index(node***REMOVED******REMOVED*** = clone
                    node = clone
                    # Step 9.9
                    # Remove lastNode from its parents, if any
                    if lastNode.parent:
                        lastNode.parent.removeChild(lastNode***REMOVED***
                    node.appendChild(lastNode***REMOVED***
                    # Step 9.10
                    lastNode = node

                # Step 10
                # Foster parent lastNode if commonAncestor is a
                # table, tbody, tfoot, thead, or tr we need to foster
                # parent the lastNode
                if lastNode.parent:
                    lastNode.parent.removeChild(lastNode***REMOVED***

                if commonAncestor.name in frozenset(("table", "tbody", "tfoot", "thead", "tr"***REMOVED******REMOVED***:
                    parent, insertBefore = self.tree.getTableMisnestedNodePosition(***REMOVED***
                    parent.insertBefore(lastNode, insertBefore***REMOVED***
                else:
                    commonAncestor.appendChild(lastNode***REMOVED***

                # Step 11
                clone = formattingElement.cloneNode(***REMOVED***

                # Step 12
                furthestBlock.reparentChildren(clone***REMOVED***

                # Step 13
                furthestBlock.appendChild(clone***REMOVED***

                # Step 14
                self.tree.activeFormattingElements.remove(formattingElement***REMOVED***
                self.tree.activeFormattingElements.insert(bookmark, clone***REMOVED***

                # Step 15
                self.tree.openElements.remove(formattingElement***REMOVED***
                self.tree.openElements.insert(
                    self.tree.openElements.index(furthestBlock***REMOVED*** + 1, clone***REMOVED***

        def endTagAppletMarqueeObject(self, token***REMOVED***:
            if self.tree.elementInScope(token["name"***REMOVED******REMOVED***:
                self.tree.generateImpliedEndTags(***REMOVED***
            if self.tree.openElements[-1***REMOVED***.name != token["name"***REMOVED***:
                self.parser.parseError("end-tag-too-early", {"name": token["name"***REMOVED******REMOVED******REMOVED***

            if self.tree.elementInScope(token["name"***REMOVED******REMOVED***:
                element = self.tree.openElements.pop(***REMOVED***
                while element.name != token["name"***REMOVED***:
                    element = self.tree.openElements.pop(***REMOVED***
                self.tree.clearActiveFormattingElements(***REMOVED***

        def endTagBr(self, token***REMOVED***:
            self.parser.parseError("unexpected-end-tag-treated-as",
                               ***REMOVED***"originalName": "br", "newName": "br element"***REMOVED******REMOVED***
            self.tree.reconstructActiveFormattingElements(***REMOVED***
            self.tree.insertElement(impliedTagToken("br", "StartTag"***REMOVED******REMOVED***
            self.tree.openElements.pop(***REMOVED***

        def endTagOther(self, token***REMOVED***:
            for node in self.tree.openElements[::-1***REMOVED***:
                if node.name == token["name"***REMOVED***:
                    self.tree.generateImpliedEndTags(exclude=token["name"***REMOVED******REMOVED***
                    if self.tree.openElements[-1***REMOVED***.name != token["name"***REMOVED***:
                        self.parser.parseError("unexpected-end-tag", {"name": token["name"***REMOVED******REMOVED******REMOVED***
                    while self.tree.openElements.pop(***REMOVED*** != node:
                        pass
                    break
                else:
                    if node.nameTuple in specialElements:
                        self.parser.parseError("unexpected-end-tag", {"name": token["name"***REMOVED******REMOVED******REMOVED***
                        break

    class TextPhase(Phase***REMOVED***:
        def __init__(self, parser, tree***REMOVED***:
            Phase.__init__(self, parser, tree***REMOVED***
            self.startTagHandler = utils.MethodDispatcher([***REMOVED******REMOVED***
            self.startTagHandler.default = self.startTagOther
            self.endTagHandler = utils.MethodDispatcher([
                ("script", self.endTagScript***REMOVED******REMOVED******REMOVED***
            self.endTagHandler.default = self.endTagOther

        def processCharacters(self, token***REMOVED***:
            self.tree.insertText(token["data"***REMOVED******REMOVED***

        def processEOF(self***REMOVED***:
            self.parser.parseError("expected-named-closing-tag-but-got-eof",
                               ***REMOVED***"name": self.tree.openElements[-1***REMOVED***.name***REMOVED******REMOVED***
            self.tree.openElements.pop(***REMOVED***
            self.parser.phase = self.parser.originalPhase
            return True

        def startTagOther(self, token***REMOVED***:
            assert False, "Tried to process start tag %s in RCDATA/RAWTEXT mode" % token['name'***REMOVED***

        def endTagScript(self, token***REMOVED***:
            node = self.tree.openElements.pop(***REMOVED***
            assert node.name == "script"
            self.parser.phase = self.parser.originalPhase
            # The rest of this method is all stuff that only happens if
            # document.write works

        def endTagOther(self, token***REMOVED***:
            self.tree.openElements.pop(***REMOVED***
            self.parser.phase = self.parser.originalPhase

    class InTablePhase(Phase***REMOVED***:
        # http://www.whatwg.org/specs/web-apps/current-work/#in-table
        def __init__(self, parser, tree***REMOVED***:
            Phase.__init__(self, parser, tree***REMOVED***
            self.startTagHandler = utils.MethodDispatcher([
                ("html", self.startTagHtml***REMOVED***,
                ("caption", self.startTagCaption***REMOVED***,
                ("colgroup", self.startTagColgroup***REMOVED***,
                ("col", self.startTagCol***REMOVED***,
                (("tbody", "tfoot", "thead"***REMOVED***, self.startTagRowGroup***REMOVED***,
                (("td", "th", "tr"***REMOVED***, self.startTagImplyTbody***REMOVED***,
                ("table", self.startTagTable***REMOVED***,
                (("style", "script"***REMOVED***, self.startTagStyleScript***REMOVED***,
                ("input", self.startTagInput***REMOVED***,
                ("form", self.startTagForm***REMOVED***
            ***REMOVED******REMOVED***
            self.startTagHandler.default = self.startTagOther

            self.endTagHandler = utils.MethodDispatcher([
                ("table", self.endTagTable***REMOVED***,
                (("body", "caption", "col", "colgroup", "html", "tbody", "td",
                  "tfoot", "th", "thead", "tr"***REMOVED***, self.endTagIgnore***REMOVED***
            ***REMOVED******REMOVED***
            self.endTagHandler.default = self.endTagOther

        # helper methods
        def clearStackToTableContext(self***REMOVED***:
            # "clear the stack back to a table context"
            while self.tree.openElements[-1***REMOVED***.name not in ("table", "html"***REMOVED***:
                # self.parser.parseError("unexpected-implied-end-tag-in-table",
                #  {"name":  self.tree.openElements[-1***REMOVED***.name***REMOVED******REMOVED***
                self.tree.openElements.pop(***REMOVED***
            # When the current node is <html> it's an innerHTML case

        # processing methods
        def processEOF(self***REMOVED***:
            if self.tree.openElements[-1***REMOVED***.name != "html":
                self.parser.parseError("eof-in-table"***REMOVED***
            else:
                assert self.parser.innerHTML
            # Stop parsing

        def processSpaceCharacters(self, token***REMOVED***:
            originalPhase = self.parser.phase
            self.parser.phase = self.parser.phases["inTableText"***REMOVED***
            self.parser.phase.originalPhase = originalPhase
            self.parser.phase.processSpaceCharacters(token***REMOVED***

        def processCharacters(self, token***REMOVED***:
            originalPhase = self.parser.phase
            self.parser.phase = self.parser.phases["inTableText"***REMOVED***
            self.parser.phase.originalPhase = originalPhase
            self.parser.phase.processCharacters(token***REMOVED***

        def insertText(self, token***REMOVED***:
            # If we get here there must be at least one non-whitespace character
            # Do the table magic!
            self.tree.insertFromTable = True
            self.parser.phases["inBody"***REMOVED***.processCharacters(token***REMOVED***
            self.tree.insertFromTable = False

        def startTagCaption(self, token***REMOVED***:
            self.clearStackToTableContext(***REMOVED***
            self.tree.activeFormattingElements.append(Marker***REMOVED***
            self.tree.insertElement(token***REMOVED***
            self.parser.phase = self.parser.phases["inCaption"***REMOVED***

        def startTagColgroup(self, token***REMOVED***:
            self.clearStackToTableContext(***REMOVED***
            self.tree.insertElement(token***REMOVED***
            self.parser.phase = self.parser.phases["inColumnGroup"***REMOVED***

        def startTagCol(self, token***REMOVED***:
            self.startTagColgroup(impliedTagToken("colgroup", "StartTag"***REMOVED******REMOVED***
            return token

        def startTagRowGroup(self, token***REMOVED***:
            self.clearStackToTableContext(***REMOVED***
            self.tree.insertElement(token***REMOVED***
            self.parser.phase = self.parser.phases["inTableBody"***REMOVED***

        def startTagImplyTbody(self, token***REMOVED***:
            self.startTagRowGroup(impliedTagToken("tbody", "StartTag"***REMOVED******REMOVED***
            return token

        def startTagTable(self, token***REMOVED***:
            self.parser.parseError("unexpected-start-tag-implies-end-tag",
                               ***REMOVED***"startName": "table", "endName": "table"***REMOVED******REMOVED***
            self.parser.phase.processEndTag(impliedTagToken("table"***REMOVED******REMOVED***
            if not self.parser.innerHTML:
                return token

        def startTagStyleScript(self, token***REMOVED***:
            return self.parser.phases["inHead"***REMOVED***.processStartTag(token***REMOVED***

        def startTagInput(self, token***REMOVED***:
            if ("type" in token["data"***REMOVED*** and
                    token["data"***REMOVED***["type"***REMOVED***.translate(asciiUpper2Lower***REMOVED*** == "hidden"***REMOVED***:
                self.parser.parseError("unexpected-hidden-input-in-table"***REMOVED***
                self.tree.insertElement(token***REMOVED***
                # XXX associate with form
                self.tree.openElements.pop(***REMOVED***
            else:
                self.startTagOther(token***REMOVED***

        def startTagForm(self, token***REMOVED***:
            self.parser.parseError("unexpected-form-in-table"***REMOVED***
            if self.tree.formPointer is None:
                self.tree.insertElement(token***REMOVED***
                self.tree.formPointer = self.tree.openElements[-1***REMOVED***
                self.tree.openElements.pop(***REMOVED***

        def startTagOther(self, token***REMOVED***:
            self.parser.parseError("unexpected-start-tag-implies-table-voodoo", {"name": token["name"***REMOVED******REMOVED******REMOVED***
            # Do the table magic!
            self.tree.insertFromTable = True
            self.parser.phases["inBody"***REMOVED***.processStartTag(token***REMOVED***
            self.tree.insertFromTable = False

        def endTagTable(self, token***REMOVED***:
            if self.tree.elementInScope("table", variant="table"***REMOVED***:
                self.tree.generateImpliedEndTags(***REMOVED***
                if self.tree.openElements[-1***REMOVED***.name != "table":
                    self.parser.parseError("end-tag-too-early-named",
                                       ***REMOVED***"gotName": "table",
                                            "expectedName": self.tree.openElements[-1***REMOVED***.name***REMOVED******REMOVED***
                while self.tree.openElements[-1***REMOVED***.name != "table":
                    self.tree.openElements.pop(***REMOVED***
                self.tree.openElements.pop(***REMOVED***
                self.parser.resetInsertionMode(***REMOVED***
            else:
                # innerHTML case
                assert self.parser.innerHTML
                self.parser.parseError(***REMOVED***

        def endTagIgnore(self, token***REMOVED***:
            self.parser.parseError("unexpected-end-tag", {"name": token["name"***REMOVED******REMOVED******REMOVED***

        def endTagOther(self, token***REMOVED***:
            self.parser.parseError("unexpected-end-tag-implies-table-voodoo", {"name": token["name"***REMOVED******REMOVED******REMOVED***
            # Do the table magic!
            self.tree.insertFromTable = True
            self.parser.phases["inBody"***REMOVED***.processEndTag(token***REMOVED***
            self.tree.insertFromTable = False

    class InTableTextPhase(Phase***REMOVED***:
        def __init__(self, parser, tree***REMOVED***:
            Phase.__init__(self, parser, tree***REMOVED***
            self.originalPhase = None
            self.characterTokens = [***REMOVED***

        def flushCharacters(self***REMOVED***:
            data = "".join([item["data"***REMOVED*** for item in self.characterTokens***REMOVED******REMOVED***
            if any([item not in spaceCharacters for item in data***REMOVED******REMOVED***:
                token = {"type": tokenTypes["Characters"***REMOVED***, "data": data***REMOVED***
                self.parser.phases["inTable"***REMOVED***.insertText(token***REMOVED***
            elif data:
                self.tree.insertText(data***REMOVED***
            self.characterTokens = [***REMOVED***

        def processComment(self, token***REMOVED***:
            self.flushCharacters(***REMOVED***
            self.parser.phase = self.originalPhase
            return token

        def processEOF(self***REMOVED***:
            self.flushCharacters(***REMOVED***
            self.parser.phase = self.originalPhase
            return True

        def processCharacters(self, token***REMOVED***:
            if token["data"***REMOVED*** == "\u0000":
                return
            self.characterTokens.append(token***REMOVED***

        def processSpaceCharacters(self, token***REMOVED***:
            # pretty sure we should never reach here
            self.characterTokens.append(token***REMOVED***
    #        assert False

        def processStartTag(self, token***REMOVED***:
            self.flushCharacters(***REMOVED***
            self.parser.phase = self.originalPhase
            return token

        def processEndTag(self, token***REMOVED***:
            self.flushCharacters(***REMOVED***
            self.parser.phase = self.originalPhase
            return token

    class InCaptionPhase(Phase***REMOVED***:
        # http://www.whatwg.org/specs/web-apps/current-work/#in-caption
        def __init__(self, parser, tree***REMOVED***:
            Phase.__init__(self, parser, tree***REMOVED***

            self.startTagHandler = utils.MethodDispatcher([
                ("html", self.startTagHtml***REMOVED***,
                (("caption", "col", "colgroup", "tbody", "td", "tfoot", "th",
                  "thead", "tr"***REMOVED***, self.startTagTableElement***REMOVED***
            ***REMOVED******REMOVED***
            self.startTagHandler.default = self.startTagOther

            self.endTagHandler = utils.MethodDispatcher([
                ("caption", self.endTagCaption***REMOVED***,
                ("table", self.endTagTable***REMOVED***,
                (("body", "col", "colgroup", "html", "tbody", "td", "tfoot", "th",
                  "thead", "tr"***REMOVED***, self.endTagIgnore***REMOVED***
            ***REMOVED******REMOVED***
            self.endTagHandler.default = self.endTagOther

        def ignoreEndTagCaption(self***REMOVED***:
            return not self.tree.elementInScope("caption", variant="table"***REMOVED***

        def processEOF(self***REMOVED***:
            self.parser.phases["inBody"***REMOVED***.processEOF(***REMOVED***

        def processCharacters(self, token***REMOVED***:
            return self.parser.phases["inBody"***REMOVED***.processCharacters(token***REMOVED***

        def startTagTableElement(self, token***REMOVED***:
            self.parser.parseError(***REMOVED***
            # XXX Have to duplicate logic here to find out if the tag is ignored
            ignoreEndTag = self.ignoreEndTagCaption(***REMOVED***
            self.parser.phase.processEndTag(impliedTagToken("caption"***REMOVED******REMOVED***
            if not ignoreEndTag:
                return token

        def startTagOther(self, token***REMOVED***:
            return self.parser.phases["inBody"***REMOVED***.processStartTag(token***REMOVED***

        def endTagCaption(self, token***REMOVED***:
            if not self.ignoreEndTagCaption(***REMOVED***:
                # AT this code is quite similar to endTagTable in "InTable"
                self.tree.generateImpliedEndTags(***REMOVED***
                if self.tree.openElements[-1***REMOVED***.name != "caption":
                    self.parser.parseError("expected-one-end-tag-but-got-another",
                                       ***REMOVED***"gotName": "caption",
                                            "expectedName": self.tree.openElements[-1***REMOVED***.name***REMOVED******REMOVED***
                while self.tree.openElements[-1***REMOVED***.name != "caption":
                    self.tree.openElements.pop(***REMOVED***
                self.tree.openElements.pop(***REMOVED***
                self.tree.clearActiveFormattingElements(***REMOVED***
                self.parser.phase = self.parser.phases["inTable"***REMOVED***
            else:
                # innerHTML case
                assert self.parser.innerHTML
                self.parser.parseError(***REMOVED***

        def endTagTable(self, token***REMOVED***:
            self.parser.parseError(***REMOVED***
            ignoreEndTag = self.ignoreEndTagCaption(***REMOVED***
            self.parser.phase.processEndTag(impliedTagToken("caption"***REMOVED******REMOVED***
            if not ignoreEndTag:
                return token

        def endTagIgnore(self, token***REMOVED***:
            self.parser.parseError("unexpected-end-tag", {"name": token["name"***REMOVED******REMOVED******REMOVED***

        def endTagOther(self, token***REMOVED***:
            return self.parser.phases["inBody"***REMOVED***.processEndTag(token***REMOVED***

    class InColumnGroupPhase(Phase***REMOVED***:
        # http://www.whatwg.org/specs/web-apps/current-work/#in-column

        def __init__(self, parser, tree***REMOVED***:
            Phase.__init__(self, parser, tree***REMOVED***

            self.startTagHandler = utils.MethodDispatcher([
                ("html", self.startTagHtml***REMOVED***,
                ("col", self.startTagCol***REMOVED***
            ***REMOVED******REMOVED***
            self.startTagHandler.default = self.startTagOther

            self.endTagHandler = utils.MethodDispatcher([
                ("colgroup", self.endTagColgroup***REMOVED***,
                ("col", self.endTagCol***REMOVED***
            ***REMOVED******REMOVED***
            self.endTagHandler.default = self.endTagOther

        def ignoreEndTagColgroup(self***REMOVED***:
            return self.tree.openElements[-1***REMOVED***.name == "html"

        def processEOF(self***REMOVED***:
            if self.tree.openElements[-1***REMOVED***.name == "html":
                assert self.parser.innerHTML
                return
            else:
                ignoreEndTag = self.ignoreEndTagColgroup(***REMOVED***
                self.endTagColgroup(impliedTagToken("colgroup"***REMOVED******REMOVED***
                if not ignoreEndTag:
                    return True

        def processCharacters(self, token***REMOVED***:
            ignoreEndTag = self.ignoreEndTagColgroup(***REMOVED***
            self.endTagColgroup(impliedTagToken("colgroup"***REMOVED******REMOVED***
            if not ignoreEndTag:
                return token

        def startTagCol(self, token***REMOVED***:
            self.tree.insertElement(token***REMOVED***
            self.tree.openElements.pop(***REMOVED***

        def startTagOther(self, token***REMOVED***:
            ignoreEndTag = self.ignoreEndTagColgroup(***REMOVED***
            self.endTagColgroup(impliedTagToken("colgroup"***REMOVED******REMOVED***
            if not ignoreEndTag:
                return token

        def endTagColgroup(self, token***REMOVED***:
            if self.ignoreEndTagColgroup(***REMOVED***:
                # innerHTML case
                assert self.parser.innerHTML
                self.parser.parseError(***REMOVED***
            else:
                self.tree.openElements.pop(***REMOVED***
                self.parser.phase = self.parser.phases["inTable"***REMOVED***

        def endTagCol(self, token***REMOVED***:
            self.parser.parseError("no-end-tag", {"name": "col"***REMOVED******REMOVED***

        def endTagOther(self, token***REMOVED***:
            ignoreEndTag = self.ignoreEndTagColgroup(***REMOVED***
            self.endTagColgroup(impliedTagToken("colgroup"***REMOVED******REMOVED***
            if not ignoreEndTag:
                return token

    class InTableBodyPhase(Phase***REMOVED***:
        # http://www.whatwg.org/specs/web-apps/current-work/#in-table0
        def __init__(self, parser, tree***REMOVED***:
            Phase.__init__(self, parser, tree***REMOVED***
            self.startTagHandler = utils.MethodDispatcher([
                ("html", self.startTagHtml***REMOVED***,
                ("tr", self.startTagTr***REMOVED***,
                (("td", "th"***REMOVED***, self.startTagTableCell***REMOVED***,
                (("caption", "col", "colgroup", "tbody", "tfoot", "thead"***REMOVED***,
                 self.startTagTableOther***REMOVED***
            ***REMOVED******REMOVED***
            self.startTagHandler.default = self.startTagOther

            self.endTagHandler = utils.MethodDispatcher([
                (("tbody", "tfoot", "thead"***REMOVED***, self.endTagTableRowGroup***REMOVED***,
                ("table", self.endTagTable***REMOVED***,
                (("body", "caption", "col", "colgroup", "html", "td", "th",
                  "tr"***REMOVED***, self.endTagIgnore***REMOVED***
            ***REMOVED******REMOVED***
            self.endTagHandler.default = self.endTagOther

        # helper methods
        def clearStackToTableBodyContext(self***REMOVED***:
            while self.tree.openElements[-1***REMOVED***.name not in ("tbody", "tfoot",
                                                          "thead", "html"***REMOVED***:
                # self.parser.parseError("unexpected-implied-end-tag-in-table",
                #  {"name": self.tree.openElements[-1***REMOVED***.name***REMOVED******REMOVED***
                self.tree.openElements.pop(***REMOVED***
            if self.tree.openElements[-1***REMOVED***.name == "html":
                assert self.parser.innerHTML

        # the rest
        def processEOF(self***REMOVED***:
            self.parser.phases["inTable"***REMOVED***.processEOF(***REMOVED***

        def processSpaceCharacters(self, token***REMOVED***:
            return self.parser.phases["inTable"***REMOVED***.processSpaceCharacters(token***REMOVED***

        def processCharacters(self, token***REMOVED***:
            return self.parser.phases["inTable"***REMOVED***.processCharacters(token***REMOVED***

        def startTagTr(self, token***REMOVED***:
            self.clearStackToTableBodyContext(***REMOVED***
            self.tree.insertElement(token***REMOVED***
            self.parser.phase = self.parser.phases["inRow"***REMOVED***

        def startTagTableCell(self, token***REMOVED***:
            self.parser.parseError("unexpected-cell-in-table-body",
                               ***REMOVED***"name": token["name"***REMOVED******REMOVED******REMOVED***
            self.startTagTr(impliedTagToken("tr", "StartTag"***REMOVED******REMOVED***
            return token

        def startTagTableOther(self, token***REMOVED***:
            # XXX AT Any ideas on how to share this with endTagTable?
            if (self.tree.elementInScope("tbody", variant="table"***REMOVED*** or
                self.tree.elementInScope("thead", variant="table"***REMOVED*** or
                    self.tree.elementInScope("tfoot", variant="table"***REMOVED******REMOVED***:
                self.clearStackToTableBodyContext(***REMOVED***
                self.endTagTableRowGroup(
                    impliedTagToken(self.tree.openElements[-1***REMOVED***.name***REMOVED******REMOVED***
                return token
            else:
                # innerHTML case
                assert self.parser.innerHTML
                self.parser.parseError(***REMOVED***

        def startTagOther(self, token***REMOVED***:
            return self.parser.phases["inTable"***REMOVED***.processStartTag(token***REMOVED***

        def endTagTableRowGroup(self, token***REMOVED***:
            if self.tree.elementInScope(token["name"***REMOVED***, variant="table"***REMOVED***:
                self.clearStackToTableBodyContext(***REMOVED***
                self.tree.openElements.pop(***REMOVED***
                self.parser.phase = self.parser.phases["inTable"***REMOVED***
            else:
                self.parser.parseError("unexpected-end-tag-in-table-body",
                                   ***REMOVED***"name": token["name"***REMOVED******REMOVED******REMOVED***

        def endTagTable(self, token***REMOVED***:
            if (self.tree.elementInScope("tbody", variant="table"***REMOVED*** or
                self.tree.elementInScope("thead", variant="table"***REMOVED*** or
                    self.tree.elementInScope("tfoot", variant="table"***REMOVED******REMOVED***:
                self.clearStackToTableBodyContext(***REMOVED***
                self.endTagTableRowGroup(
                    impliedTagToken(self.tree.openElements[-1***REMOVED***.name***REMOVED******REMOVED***
                return token
            else:
                # innerHTML case
                assert self.parser.innerHTML
                self.parser.parseError(***REMOVED***

        def endTagIgnore(self, token***REMOVED***:
            self.parser.parseError("unexpected-end-tag-in-table-body",
                               ***REMOVED***"name": token["name"***REMOVED******REMOVED******REMOVED***

        def endTagOther(self, token***REMOVED***:
            return self.parser.phases["inTable"***REMOVED***.processEndTag(token***REMOVED***

    class InRowPhase(Phase***REMOVED***:
        # http://www.whatwg.org/specs/web-apps/current-work/#in-row
        def __init__(self, parser, tree***REMOVED***:
            Phase.__init__(self, parser, tree***REMOVED***
            self.startTagHandler = utils.MethodDispatcher([
                ("html", self.startTagHtml***REMOVED***,
                (("td", "th"***REMOVED***, self.startTagTableCell***REMOVED***,
                (("caption", "col", "colgroup", "tbody", "tfoot", "thead",
                  "tr"***REMOVED***, self.startTagTableOther***REMOVED***
            ***REMOVED******REMOVED***
            self.startTagHandler.default = self.startTagOther

            self.endTagHandler = utils.MethodDispatcher([
                ("tr", self.endTagTr***REMOVED***,
                ("table", self.endTagTable***REMOVED***,
                (("tbody", "tfoot", "thead"***REMOVED***, self.endTagTableRowGroup***REMOVED***,
                (("body", "caption", "col", "colgroup", "html", "td", "th"***REMOVED***,
                 self.endTagIgnore***REMOVED***
            ***REMOVED******REMOVED***
            self.endTagHandler.default = self.endTagOther

        # helper methods (XXX unify this with other table helper methods***REMOVED***
        def clearStackToTableRowContext(self***REMOVED***:
            while self.tree.openElements[-1***REMOVED***.name not in ("tr", "html"***REMOVED***:
                self.parser.parseError("unexpected-implied-end-tag-in-table-row",
                                   ***REMOVED***"name": self.tree.openElements[-1***REMOVED***.name***REMOVED******REMOVED***
                self.tree.openElements.pop(***REMOVED***

        def ignoreEndTagTr(self***REMOVED***:
            return not self.tree.elementInScope("tr", variant="table"***REMOVED***

        # the rest
        def processEOF(self***REMOVED***:
            self.parser.phases["inTable"***REMOVED***.processEOF(***REMOVED***

        def processSpaceCharacters(self, token***REMOVED***:
            return self.parser.phases["inTable"***REMOVED***.processSpaceCharacters(token***REMOVED***

        def processCharacters(self, token***REMOVED***:
            return self.parser.phases["inTable"***REMOVED***.processCharacters(token***REMOVED***

        def startTagTableCell(self, token***REMOVED***:
            self.clearStackToTableRowContext(***REMOVED***
            self.tree.insertElement(token***REMOVED***
            self.parser.phase = self.parser.phases["inCell"***REMOVED***
            self.tree.activeFormattingElements.append(Marker***REMOVED***

        def startTagTableOther(self, token***REMOVED***:
            ignoreEndTag = self.ignoreEndTagTr(***REMOVED***
            self.endTagTr(impliedTagToken("tr"***REMOVED******REMOVED***
            # XXX how are we sure it's always ignored in the innerHTML case?
            if not ignoreEndTag:
                return token

        def startTagOther(self, token***REMOVED***:
            return self.parser.phases["inTable"***REMOVED***.processStartTag(token***REMOVED***

        def endTagTr(self, token***REMOVED***:
            if not self.ignoreEndTagTr(***REMOVED***:
                self.clearStackToTableRowContext(***REMOVED***
                self.tree.openElements.pop(***REMOVED***
                self.parser.phase = self.parser.phases["inTableBody"***REMOVED***
            else:
                # innerHTML case
                assert self.parser.innerHTML
                self.parser.parseError(***REMOVED***

        def endTagTable(self, token***REMOVED***:
            ignoreEndTag = self.ignoreEndTagTr(***REMOVED***
            self.endTagTr(impliedTagToken("tr"***REMOVED******REMOVED***
            # Reprocess the current tag if the tr end tag was not ignored
            # XXX how are we sure it's always ignored in the innerHTML case?
            if not ignoreEndTag:
                return token

        def endTagTableRowGroup(self, token***REMOVED***:
            if self.tree.elementInScope(token["name"***REMOVED***, variant="table"***REMOVED***:
                self.endTagTr(impliedTagToken("tr"***REMOVED******REMOVED***
                return token
            else:
                self.parser.parseError(***REMOVED***

        def endTagIgnore(self, token***REMOVED***:
            self.parser.parseError("unexpected-end-tag-in-table-row",
                               ***REMOVED***"name": token["name"***REMOVED******REMOVED******REMOVED***

        def endTagOther(self, token***REMOVED***:
            return self.parser.phases["inTable"***REMOVED***.processEndTag(token***REMOVED***

    class InCellPhase(Phase***REMOVED***:
        # http://www.whatwg.org/specs/web-apps/current-work/#in-cell
        def __init__(self, parser, tree***REMOVED***:
            Phase.__init__(self, parser, tree***REMOVED***
            self.startTagHandler = utils.MethodDispatcher([
                ("html", self.startTagHtml***REMOVED***,
                (("caption", "col", "colgroup", "tbody", "td", "tfoot", "th",
                  "thead", "tr"***REMOVED***, self.startTagTableOther***REMOVED***
            ***REMOVED******REMOVED***
            self.startTagHandler.default = self.startTagOther

            self.endTagHandler = utils.MethodDispatcher([
                (("td", "th"***REMOVED***, self.endTagTableCell***REMOVED***,
                (("body", "caption", "col", "colgroup", "html"***REMOVED***, self.endTagIgnore***REMOVED***,
                (("table", "tbody", "tfoot", "thead", "tr"***REMOVED***, self.endTagImply***REMOVED***
            ***REMOVED******REMOVED***
            self.endTagHandler.default = self.endTagOther

        # helper
        def closeCell(self***REMOVED***:
            if self.tree.elementInScope("td", variant="table"***REMOVED***:
                self.endTagTableCell(impliedTagToken("td"***REMOVED******REMOVED***
            elif self.tree.elementInScope("th", variant="table"***REMOVED***:
                self.endTagTableCell(impliedTagToken("th"***REMOVED******REMOVED***

        # the rest
        def processEOF(self***REMOVED***:
            self.parser.phases["inBody"***REMOVED***.processEOF(***REMOVED***

        def processCharacters(self, token***REMOVED***:
            return self.parser.phases["inBody"***REMOVED***.processCharacters(token***REMOVED***

        def startTagTableOther(self, token***REMOVED***:
            if (self.tree.elementInScope("td", variant="table"***REMOVED*** or
                    self.tree.elementInScope("th", variant="table"***REMOVED******REMOVED***:
                self.closeCell(***REMOVED***
                return token
            else:
                # innerHTML case
                assert self.parser.innerHTML
                self.parser.parseError(***REMOVED***

        def startTagOther(self, token***REMOVED***:
            return self.parser.phases["inBody"***REMOVED***.processStartTag(token***REMOVED***

        def endTagTableCell(self, token***REMOVED***:
            if self.tree.elementInScope(token["name"***REMOVED***, variant="table"***REMOVED***:
                self.tree.generateImpliedEndTags(token["name"***REMOVED******REMOVED***
                if self.tree.openElements[-1***REMOVED***.name != token["name"***REMOVED***:
                    self.parser.parseError("unexpected-cell-end-tag",
                                       ***REMOVED***"name": token["name"***REMOVED******REMOVED******REMOVED***
                    while True:
                        node = self.tree.openElements.pop(***REMOVED***
                        if node.name == token["name"***REMOVED***:
                            break
                else:
                    self.tree.openElements.pop(***REMOVED***
                self.tree.clearActiveFormattingElements(***REMOVED***
                self.parser.phase = self.parser.phases["inRow"***REMOVED***
            else:
                self.parser.parseError("unexpected-end-tag", {"name": token["name"***REMOVED******REMOVED******REMOVED***

        def endTagIgnore(self, token***REMOVED***:
            self.parser.parseError("unexpected-end-tag", {"name": token["name"***REMOVED******REMOVED******REMOVED***

        def endTagImply(self, token***REMOVED***:
            if self.tree.elementInScope(token["name"***REMOVED***, variant="table"***REMOVED***:
                self.closeCell(***REMOVED***
                return token
            else:
                # sometimes innerHTML case
                self.parser.parseError(***REMOVED***

        def endTagOther(self, token***REMOVED***:
            return self.parser.phases["inBody"***REMOVED***.processEndTag(token***REMOVED***

    class InSelectPhase(Phase***REMOVED***:
        def __init__(self, parser, tree***REMOVED***:
            Phase.__init__(self, parser, tree***REMOVED***

            self.startTagHandler = utils.MethodDispatcher([
                ("html", self.startTagHtml***REMOVED***,
                ("option", self.startTagOption***REMOVED***,
                ("optgroup", self.startTagOptgroup***REMOVED***,
                ("select", self.startTagSelect***REMOVED***,
                (("input", "keygen", "textarea"***REMOVED***, self.startTagInput***REMOVED***,
                ("script", self.startTagScript***REMOVED***
            ***REMOVED******REMOVED***
            self.startTagHandler.default = self.startTagOther

            self.endTagHandler = utils.MethodDispatcher([
                ("option", self.endTagOption***REMOVED***,
                ("optgroup", self.endTagOptgroup***REMOVED***,
                ("select", self.endTagSelect***REMOVED***
            ***REMOVED******REMOVED***
            self.endTagHandler.default = self.endTagOther

        # http://www.whatwg.org/specs/web-apps/current-work/#in-select
        def processEOF(self***REMOVED***:
            if self.tree.openElements[-1***REMOVED***.name != "html":
                self.parser.parseError("eof-in-select"***REMOVED***
            else:
                assert self.parser.innerHTML

        def processCharacters(self, token***REMOVED***:
            if token["data"***REMOVED*** == "\u0000":
                return
            self.tree.insertText(token["data"***REMOVED******REMOVED***

        def startTagOption(self, token***REMOVED***:
            # We need to imply </option> if <option> is the current node.
            if self.tree.openElements[-1***REMOVED***.name == "option":
                self.tree.openElements.pop(***REMOVED***
            self.tree.insertElement(token***REMOVED***

        def startTagOptgroup(self, token***REMOVED***:
            if self.tree.openElements[-1***REMOVED***.name == "option":
                self.tree.openElements.pop(***REMOVED***
            if self.tree.openElements[-1***REMOVED***.name == "optgroup":
                self.tree.openElements.pop(***REMOVED***
            self.tree.insertElement(token***REMOVED***

        def startTagSelect(self, token***REMOVED***:
            self.parser.parseError("unexpected-select-in-select"***REMOVED***
            self.endTagSelect(impliedTagToken("select"***REMOVED******REMOVED***

        def startTagInput(self, token***REMOVED***:
            self.parser.parseError("unexpected-input-in-select"***REMOVED***
            if self.tree.elementInScope("select", variant="select"***REMOVED***:
                self.endTagSelect(impliedTagToken("select"***REMOVED******REMOVED***
                return token
            else:
                assert self.parser.innerHTML

        def startTagScript(self, token***REMOVED***:
            return self.parser.phases["inHead"***REMOVED***.processStartTag(token***REMOVED***

        def startTagOther(self, token***REMOVED***:
            self.parser.parseError("unexpected-start-tag-in-select",
                               ***REMOVED***"name": token["name"***REMOVED******REMOVED******REMOVED***

        def endTagOption(self, token***REMOVED***:
            if self.tree.openElements[-1***REMOVED***.name == "option":
                self.tree.openElements.pop(***REMOVED***
            else:
                self.parser.parseError("unexpected-end-tag-in-select",
                                   ***REMOVED***"name": "option"***REMOVED******REMOVED***

        def endTagOptgroup(self, token***REMOVED***:
            # </optgroup> implicitly closes <option>
            if (self.tree.openElements[-1***REMOVED***.name == "option" and
                    self.tree.openElements[-2***REMOVED***.name == "optgroup"***REMOVED***:
                self.tree.openElements.pop(***REMOVED***
            # It also closes </optgroup>
            if self.tree.openElements[-1***REMOVED***.name == "optgroup":
                self.tree.openElements.pop(***REMOVED***
            # But nothing else
            else:
                self.parser.parseError("unexpected-end-tag-in-select",
                                   ***REMOVED***"name": "optgroup"***REMOVED******REMOVED***

        def endTagSelect(self, token***REMOVED***:
            if self.tree.elementInScope("select", variant="select"***REMOVED***:
                node = self.tree.openElements.pop(***REMOVED***
                while node.name != "select":
                    node = self.tree.openElements.pop(***REMOVED***
                self.parser.resetInsertionMode(***REMOVED***
            else:
                # innerHTML case
                assert self.parser.innerHTML
                self.parser.parseError(***REMOVED***

        def endTagOther(self, token***REMOVED***:
            self.parser.parseError("unexpected-end-tag-in-select",
                               ***REMOVED***"name": token["name"***REMOVED******REMOVED******REMOVED***

    class InSelectInTablePhase(Phase***REMOVED***:
        def __init__(self, parser, tree***REMOVED***:
            Phase.__init__(self, parser, tree***REMOVED***

            self.startTagHandler = utils.MethodDispatcher([
                (("caption", "table", "tbody", "tfoot", "thead", "tr", "td", "th"***REMOVED***,
                 self.startTagTable***REMOVED***
            ***REMOVED******REMOVED***
            self.startTagHandler.default = self.startTagOther

            self.endTagHandler = utils.MethodDispatcher([
                (("caption", "table", "tbody", "tfoot", "thead", "tr", "td", "th"***REMOVED***,
                 self.endTagTable***REMOVED***
            ***REMOVED******REMOVED***
            self.endTagHandler.default = self.endTagOther

        def processEOF(self***REMOVED***:
            self.parser.phases["inSelect"***REMOVED***.processEOF(***REMOVED***

        def processCharacters(self, token***REMOVED***:
            return self.parser.phases["inSelect"***REMOVED***.processCharacters(token***REMOVED***

        def startTagTable(self, token***REMOVED***:
            self.parser.parseError("unexpected-table-element-start-tag-in-select-in-table", {"name": token["name"***REMOVED******REMOVED******REMOVED***
            self.endTagOther(impliedTagToken("select"***REMOVED******REMOVED***
            return token

        def startTagOther(self, token***REMOVED***:
            return self.parser.phases["inSelect"***REMOVED***.processStartTag(token***REMOVED***

        def endTagTable(self, token***REMOVED***:
            self.parser.parseError("unexpected-table-element-end-tag-in-select-in-table", {"name": token["name"***REMOVED******REMOVED******REMOVED***
            if self.tree.elementInScope(token["name"***REMOVED***, variant="table"***REMOVED***:
                self.endTagOther(impliedTagToken("select"***REMOVED******REMOVED***
                return token

        def endTagOther(self, token***REMOVED***:
            return self.parser.phases["inSelect"***REMOVED***.processEndTag(token***REMOVED***

    class InForeignContentPhase(Phase***REMOVED***:
        breakoutElements = frozenset(["b", "big", "blockquote", "body", "br",
                                      "center", "code", "dd", "div", "dl", "dt",
                                      "em", "embed", "h1", "h2", "h3",
                                      "h4", "h5", "h6", "head", "hr", "i", "img",
                                      "li", "listing", "menu", "meta", "nobr",
                                      "ol", "p", "pre", "ruby", "s", "small",
                                      "span", "strong", "strike", "sub", "sup",
                                      "table", "tt", "u", "ul", "var"***REMOVED******REMOVED***

        def __init__(self, parser, tree***REMOVED***:
            Phase.__init__(self, parser, tree***REMOVED***

        def adjustSVGTagNames(self, token***REMOVED***:
            replacements = {"altglyph": "altGlyph",
                            "altglyphdef": "altGlyphDef",
                            "altglyphitem": "altGlyphItem",
                            "animatecolor": "animateColor",
                            "animatemotion": "animateMotion",
                            "animatetransform": "animateTransform",
                            "clippath": "clipPath",
                            "feblend": "feBlend",
                            "fecolormatrix": "feColorMatrix",
                            "fecomponenttransfer": "feComponentTransfer",
                            "fecomposite": "feComposite",
                            "feconvolvematrix": "feConvolveMatrix",
                            "fediffuselighting": "feDiffuseLighting",
                            "fedisplacementmap": "feDisplacementMap",
                            "fedistantlight": "feDistantLight",
                            "feflood": "feFlood",
                            "fefunca": "feFuncA",
                            "fefuncb": "feFuncB",
                            "fefuncg": "feFuncG",
                            "fefuncr": "feFuncR",
                            "fegaussianblur": "feGaussianBlur",
                            "feimage": "feImage",
                            "femerge": "feMerge",
                            "femergenode": "feMergeNode",
                            "femorphology": "feMorphology",
                            "feoffset": "feOffset",
                            "fepointlight": "fePointLight",
                            "fespecularlighting": "feSpecularLighting",
                            "fespotlight": "feSpotLight",
                            "fetile": "feTile",
                            "feturbulence": "feTurbulence",
                            "foreignobject": "foreignObject",
                            "glyphref": "glyphRef",
                            "lineargradient": "linearGradient",
                            "radialgradient": "radialGradient",
                            "textpath": "textPath"***REMOVED***

            if token["name"***REMOVED*** in replacements:
                token["name"***REMOVED*** = replacements[token["name"***REMOVED******REMOVED***

        def processCharacters(self, token***REMOVED***:
            if token["data"***REMOVED*** == "\u0000":
                token["data"***REMOVED*** = "\uFFFD"
            elif (self.parser.framesetOK and
                  any(char not in spaceCharacters for char in token["data"***REMOVED******REMOVED******REMOVED***:
                self.parser.framesetOK = False
            Phase.processCharacters(self, token***REMOVED***

        def processStartTag(self, token***REMOVED***:
            currentNode = self.tree.openElements[-1***REMOVED***
            if (token["name"***REMOVED*** in self.breakoutElements or
                (token["name"***REMOVED*** == "font" and
                 set(token["data"***REMOVED***.keys(***REMOVED******REMOVED*** & set(["color", "face", "size"***REMOVED******REMOVED******REMOVED******REMOVED***:
                self.parser.parseError("unexpected-html-element-in-foreign-content",
                                   ***REMOVED***"name": token["name"***REMOVED******REMOVED******REMOVED***
                while (self.tree.openElements[-1***REMOVED***.namespace !=
                       self.tree.defaultNamespace and
                       not self.parser.isHTMLIntegrationPoint(self.tree.openElements[-1***REMOVED******REMOVED*** and
                       not self.parser.isMathMLTextIntegrationPoint(self.tree.openElements[-1***REMOVED******REMOVED******REMOVED***:
                    self.tree.openElements.pop(***REMOVED***
                return token

            else:
                if currentNode.namespace == namespaces["mathml"***REMOVED***:
                    self.parser.adjustMathMLAttributes(token***REMOVED***
                elif currentNode.namespace == namespaces["svg"***REMOVED***:
                    self.adjustSVGTagNames(token***REMOVED***
                    self.parser.adjustSVGAttributes(token***REMOVED***
                self.parser.adjustForeignAttributes(token***REMOVED***
                token["namespace"***REMOVED*** = currentNode.namespace
                self.tree.insertElement(token***REMOVED***
                if token["selfClosing"***REMOVED***:
                    self.tree.openElements.pop(***REMOVED***
                    token["selfClosingAcknowledged"***REMOVED*** = True

        def processEndTag(self, token***REMOVED***:
            nodeIndex = len(self.tree.openElements***REMOVED*** - 1
            node = self.tree.openElements[-1***REMOVED***
            if node.name != token["name"***REMOVED***:
                self.parser.parseError("unexpected-end-tag", {"name": token["name"***REMOVED******REMOVED******REMOVED***

            while True:
                if node.name.translate(asciiUpper2Lower***REMOVED*** == token["name"***REMOVED***:
                    # XXX this isn't in the spec but it seems necessary
                    if self.parser.phase == self.parser.phases["inTableText"***REMOVED***:
                        self.parser.phase.flushCharacters(***REMOVED***
                        self.parser.phase = self.parser.phase.originalPhase
                    while self.tree.openElements.pop(***REMOVED*** != node:
                        assert self.tree.openElements
                    new_token = None
                    break
                nodeIndex -= 1

                node = self.tree.openElements[nodeIndex***REMOVED***
                if node.namespace != self.tree.defaultNamespace:
                    continue
                else:
                    new_token = self.parser.phase.processEndTag(token***REMOVED***
                    break
            return new_token

    class AfterBodyPhase(Phase***REMOVED***:
        def __init__(self, parser, tree***REMOVED***:
            Phase.__init__(self, parser, tree***REMOVED***

            self.startTagHandler = utils.MethodDispatcher([
                ("html", self.startTagHtml***REMOVED***
            ***REMOVED******REMOVED***
            self.startTagHandler.default = self.startTagOther

            self.endTagHandler = utils.MethodDispatcher([("html", self.endTagHtml***REMOVED******REMOVED******REMOVED***
            self.endTagHandler.default = self.endTagOther

        def processEOF(self***REMOVED***:
            # Stop parsing
            pass

        def processComment(self, token***REMOVED***:
            # This is needed because data is to be appended to the <html> element
            # here and not to whatever is currently open.
            self.tree.insertComment(token, self.tree.openElements[0***REMOVED******REMOVED***

        def processCharacters(self, token***REMOVED***:
            self.parser.parseError("unexpected-char-after-body"***REMOVED***
            self.parser.phase = self.parser.phases["inBody"***REMOVED***
            return token

        def startTagHtml(self, token***REMOVED***:
            return self.parser.phases["inBody"***REMOVED***.processStartTag(token***REMOVED***

        def startTagOther(self, token***REMOVED***:
            self.parser.parseError("unexpected-start-tag-after-body",
                               ***REMOVED***"name": token["name"***REMOVED******REMOVED******REMOVED***
            self.parser.phase = self.parser.phases["inBody"***REMOVED***
            return token

        def endTagHtml(self, name***REMOVED***:
            if self.parser.innerHTML:
                self.parser.parseError("unexpected-end-tag-after-body-innerhtml"***REMOVED***
            else:
                self.parser.phase = self.parser.phases["afterAfterBody"***REMOVED***

        def endTagOther(self, token***REMOVED***:
            self.parser.parseError("unexpected-end-tag-after-body",
                               ***REMOVED***"name": token["name"***REMOVED******REMOVED******REMOVED***
            self.parser.phase = self.parser.phases["inBody"***REMOVED***
            return token

    class InFramesetPhase(Phase***REMOVED***:
        # http://www.whatwg.org/specs/web-apps/current-work/#in-frameset
        def __init__(self, parser, tree***REMOVED***:
            Phase.__init__(self, parser, tree***REMOVED***

            self.startTagHandler = utils.MethodDispatcher([
                ("html", self.startTagHtml***REMOVED***,
                ("frameset", self.startTagFrameset***REMOVED***,
                ("frame", self.startTagFrame***REMOVED***,
                ("noframes", self.startTagNoframes***REMOVED***
            ***REMOVED******REMOVED***
            self.startTagHandler.default = self.startTagOther

            self.endTagHandler = utils.MethodDispatcher([
                ("frameset", self.endTagFrameset***REMOVED***
            ***REMOVED******REMOVED***
            self.endTagHandler.default = self.endTagOther

        def processEOF(self***REMOVED***:
            if self.tree.openElements[-1***REMOVED***.name != "html":
                self.parser.parseError("eof-in-frameset"***REMOVED***
            else:
                assert self.parser.innerHTML

        def processCharacters(self, token***REMOVED***:
            self.parser.parseError("unexpected-char-in-frameset"***REMOVED***

        def startTagFrameset(self, token***REMOVED***:
            self.tree.insertElement(token***REMOVED***

        def startTagFrame(self, token***REMOVED***:
            self.tree.insertElement(token***REMOVED***
            self.tree.openElements.pop(***REMOVED***

        def startTagNoframes(self, token***REMOVED***:
            return self.parser.phases["inBody"***REMOVED***.processStartTag(token***REMOVED***

        def startTagOther(self, token***REMOVED***:
            self.parser.parseError("unexpected-start-tag-in-frameset",
                               ***REMOVED***"name": token["name"***REMOVED******REMOVED******REMOVED***

        def endTagFrameset(self, token***REMOVED***:
            if self.tree.openElements[-1***REMOVED***.name == "html":
                # innerHTML case
                self.parser.parseError("unexpected-frameset-in-frameset-innerhtml"***REMOVED***
            else:
                self.tree.openElements.pop(***REMOVED***
            if (not self.parser.innerHTML and
                    self.tree.openElements[-1***REMOVED***.name != "frameset"***REMOVED***:
                # If we're not in innerHTML mode and the the current node is not a
                # "frameset" element (anymore***REMOVED*** then switch.
                self.parser.phase = self.parser.phases["afterFrameset"***REMOVED***

        def endTagOther(self, token***REMOVED***:
            self.parser.parseError("unexpected-end-tag-in-frameset",
                               ***REMOVED***"name": token["name"***REMOVED******REMOVED******REMOVED***

    class AfterFramesetPhase(Phase***REMOVED***:
        # http://www.whatwg.org/specs/web-apps/current-work/#after3
        def __init__(self, parser, tree***REMOVED***:
            Phase.__init__(self, parser, tree***REMOVED***

            self.startTagHandler = utils.MethodDispatcher([
                ("html", self.startTagHtml***REMOVED***,
                ("noframes", self.startTagNoframes***REMOVED***
            ***REMOVED******REMOVED***
            self.startTagHandler.default = self.startTagOther

            self.endTagHandler = utils.MethodDispatcher([
                ("html", self.endTagHtml***REMOVED***
            ***REMOVED******REMOVED***
            self.endTagHandler.default = self.endTagOther

        def processEOF(self***REMOVED***:
            # Stop parsing
            pass

        def processCharacters(self, token***REMOVED***:
            self.parser.parseError("unexpected-char-after-frameset"***REMOVED***

        def startTagNoframes(self, token***REMOVED***:
            return self.parser.phases["inHead"***REMOVED***.processStartTag(token***REMOVED***

        def startTagOther(self, token***REMOVED***:
            self.parser.parseError("unexpected-start-tag-after-frameset",
                               ***REMOVED***"name": token["name"***REMOVED******REMOVED******REMOVED***

        def endTagHtml(self, token***REMOVED***:
            self.parser.phase = self.parser.phases["afterAfterFrameset"***REMOVED***

        def endTagOther(self, token***REMOVED***:
            self.parser.parseError("unexpected-end-tag-after-frameset",
                               ***REMOVED***"name": token["name"***REMOVED******REMOVED******REMOVED***

    class AfterAfterBodyPhase(Phase***REMOVED***:
        def __init__(self, parser, tree***REMOVED***:
            Phase.__init__(self, parser, tree***REMOVED***

            self.startTagHandler = utils.MethodDispatcher([
                ("html", self.startTagHtml***REMOVED***
            ***REMOVED******REMOVED***
            self.startTagHandler.default = self.startTagOther

        def processEOF(self***REMOVED***:
            pass

        def processComment(self, token***REMOVED***:
            self.tree.insertComment(token, self.tree.document***REMOVED***

        def processSpaceCharacters(self, token***REMOVED***:
            return self.parser.phases["inBody"***REMOVED***.processSpaceCharacters(token***REMOVED***

        def processCharacters(self, token***REMOVED***:
            self.parser.parseError("expected-eof-but-got-char"***REMOVED***
            self.parser.phase = self.parser.phases["inBody"***REMOVED***
            return token

        def startTagHtml(self, token***REMOVED***:
            return self.parser.phases["inBody"***REMOVED***.processStartTag(token***REMOVED***

        def startTagOther(self, token***REMOVED***:
            self.parser.parseError("expected-eof-but-got-start-tag",
                               ***REMOVED***"name": token["name"***REMOVED******REMOVED******REMOVED***
            self.parser.phase = self.parser.phases["inBody"***REMOVED***
            return token

        def processEndTag(self, token***REMOVED***:
            self.parser.parseError("expected-eof-but-got-end-tag",
                               ***REMOVED***"name": token["name"***REMOVED******REMOVED******REMOVED***
            self.parser.phase = self.parser.phases["inBody"***REMOVED***
            return token

    class AfterAfterFramesetPhase(Phase***REMOVED***:
        def __init__(self, parser, tree***REMOVED***:
            Phase.__init__(self, parser, tree***REMOVED***

            self.startTagHandler = utils.MethodDispatcher([
                ("html", self.startTagHtml***REMOVED***,
                ("noframes", self.startTagNoFrames***REMOVED***
            ***REMOVED******REMOVED***
            self.startTagHandler.default = self.startTagOther

        def processEOF(self***REMOVED***:
            pass

        def processComment(self, token***REMOVED***:
            self.tree.insertComment(token, self.tree.document***REMOVED***

        def processSpaceCharacters(self, token***REMOVED***:
            return self.parser.phases["inBody"***REMOVED***.processSpaceCharacters(token***REMOVED***

        def processCharacters(self, token***REMOVED***:
            self.parser.parseError("expected-eof-but-got-char"***REMOVED***

        def startTagHtml(self, token***REMOVED***:
            return self.parser.phases["inBody"***REMOVED***.processStartTag(token***REMOVED***

        def startTagNoFrames(self, token***REMOVED***:
            return self.parser.phases["inHead"***REMOVED***.processStartTag(token***REMOVED***

        def startTagOther(self, token***REMOVED***:
            self.parser.parseError("expected-eof-but-got-start-tag",
                               ***REMOVED***"name": token["name"***REMOVED******REMOVED******REMOVED***

        def processEndTag(self, token***REMOVED***:
            self.parser.parseError("expected-eof-but-got-end-tag",
                               ***REMOVED***"name": token["name"***REMOVED******REMOVED******REMOVED***

    return {
        "initial": InitialPhase,
        "beforeHtml": BeforeHtmlPhase,
        "beforeHead": BeforeHeadPhase,
        "inHead": InHeadPhase,
        # XXX "inHeadNoscript": InHeadNoScriptPhase,
        "afterHead": AfterHeadPhase,
        "inBody": InBodyPhase,
        "text": TextPhase,
        "inTable": InTablePhase,
        "inTableText": InTableTextPhase,
        "inCaption": InCaptionPhase,
        "inColumnGroup": InColumnGroupPhase,
        "inTableBody": InTableBodyPhase,
        "inRow": InRowPhase,
        "inCell": InCellPhase,
        "inSelect": InSelectPhase,
        "inSelectInTable": InSelectInTablePhase,
        "inForeignContent": InForeignContentPhase,
        "afterBody": AfterBodyPhase,
        "inFrameset": InFramesetPhase,
        "afterFrameset": AfterFramesetPhase,
        "afterAfterBody": AfterAfterBodyPhase,
        "afterAfterFrameset": AfterAfterFramesetPhase,
        # XXX after after frameset
***REMOVED***


def impliedTagToken(name, type="EndTag", attributes=None,
                    selfClosing=False***REMOVED***:
    if attributes is None:
        attributes = {***REMOVED***
    return {"type": tokenTypes[type***REMOVED***, "name": name, "data": attributes,
            "selfClosing": selfClosing***REMOVED***


class ParseError(Exception***REMOVED***:
    ***REMOVED***Error in parsed document***REMOVED***
    pass
