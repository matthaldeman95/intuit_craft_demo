from __future__ import absolute_import, division, unicode_literals

from types import ModuleType

from pip._vendor.six import text_type

***REMOVED***
    import xml.etree.cElementTree as default_etree
except ImportError:
    import xml.etree.ElementTree as default_etree


__all__ = ["default_etree", "MethodDispatcher", "isSurrogatePair",
           "surrogatePairToCodepoint", "moduleFactoryFactory",
           "supports_lone_surrogates"***REMOVED***


# Platforms not supporting lone surrogates (\uD800-\uDFFF***REMOVED*** should be
# caught by the below test. In general this would be any platform
# using UTF-16 as its encoding of unicode strings, such as
# Jython. This is because UTF-16 itself is based on the use of such
# surrogates, and there is no mechanism to further escape such
# escapes.
***REMOVED***
    _x = eval('"\\uD800"'***REMOVED***
    if not isinstance(_x, text_type***REMOVED***:
        # We need this with u"" because of http://bugs.jython.org/issue2039
        _x = eval('u"\\uD800"'***REMOVED***
        assert isinstance(_x, text_type***REMOVED***
***REMOVED***
    supports_lone_surrogates = False
else:
    supports_lone_surrogates = True


class MethodDispatcher(dict***REMOVED***:
    ***REMOVED***Dict with 2 special properties:

    On initiation, keys that are lists, sets or tuples are converted to
    multiple keys so accessing any one of the items in the original
    list-like object returns the matching value

    md = MethodDispatcher({("foo", "bar"***REMOVED***:"baz"***REMOVED******REMOVED***
    md["foo"***REMOVED*** == "baz"

    A default value which can be set through the default attribute.
    ***REMOVED***

    def __init__(self, items=(***REMOVED******REMOVED***:
        # Using _dictEntries instead of directly assigning to self is about
        # twice as fast. Please do careful performance testing before changing
        # anything here.
        _dictEntries = [***REMOVED***
        for name, value in items:
            if type(name***REMOVED*** in (list, tuple, frozenset, set***REMOVED***:
                for item in name:
                    _dictEntries.append((item, value***REMOVED******REMOVED***
            else:
                _dictEntries.append((name, value***REMOVED******REMOVED***
        dict.__init__(self, _dictEntries***REMOVED***
        self.default = None

    def __getitem__(self, key***REMOVED***:
        return dict.get(self, key, self.default***REMOVED***


# Some utility functions to dal with weirdness around UCS2 vs UCS4
# python builds

def isSurrogatePair(data***REMOVED***:
    return (len(data***REMOVED*** == 2 and
            ord(data[0***REMOVED******REMOVED*** >= 0xD800 and ord(data[0***REMOVED******REMOVED*** <= 0xDBFF and
            ord(data[1***REMOVED******REMOVED*** >= 0xDC00 and ord(data[1***REMOVED******REMOVED*** <= 0xDFFF***REMOVED***


def surrogatePairToCodepoint(data***REMOVED***:
    char_val = (0x10000 + (ord(data[0***REMOVED******REMOVED*** - 0xD800***REMOVED*** * 0x400 +
                (ord(data[1***REMOVED******REMOVED*** - 0xDC00***REMOVED******REMOVED***
    return char_val

# Module Factory Factory (no, this isn't Java, I know***REMOVED***
# Here to stop this being duplicated all over the place.


def moduleFactoryFactory(factory***REMOVED***:
    moduleCache = {***REMOVED***

    def moduleFactory(baseModule, *args, **kwargs***REMOVED***:
        if isinstance(ModuleType.__name__, type(""***REMOVED******REMOVED***:
            name = "_%s_factory" % baseModule.__name__
        else:
            name = b"_%s_factory" % baseModule.__name__

        if name in moduleCache:
            return moduleCache[name***REMOVED***
        else:
            mod = ModuleType(name***REMOVED***
            objs = factory(baseModule, *args, **kwargs***REMOVED***
            mod.__dict__.update(objs***REMOVED***
            moduleCache[name***REMOVED*** = mod
            return mod

    return moduleFactory
