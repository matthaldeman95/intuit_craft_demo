from __future__ import absolute_import, division, unicode_literals
from pip._vendor.six import text_type

from lxml import etree
from ..treebuilders.etree import tag_regexp

from . import _base

from .. import ihatexml


def ensure_str(s***REMOVED***:
    if s is None:
        return None
    elif isinstance(s, text_type***REMOVED***:
        return s
    else:
        return s.decode("utf-8", "strict"***REMOVED***


class Root(object***REMOVED***:
    def __init__(self, et***REMOVED***:
        self.elementtree = et
        self.children = [***REMOVED***
        if et.docinfo.internalDTD:
            self.children.append(Doctype(self,
                                         ensure_str(et.docinfo.root_name***REMOVED***,
                                         ensure_str(et.docinfo.public_id***REMOVED***,
                                         ensure_str(et.docinfo.system_url***REMOVED******REMOVED******REMOVED***
        root = et.getroot(***REMOVED***
        node = root

        while node.getprevious(***REMOVED*** is not None:
            node = node.getprevious(***REMOVED***
        while node is not None:
            self.children.append(node***REMOVED***
            node = node.getnext(***REMOVED***

        self.text = None
        self.tail = None

    def __getitem__(self, key***REMOVED***:
        return self.children[key***REMOVED***

    def getnext(self***REMOVED***:
        return None

    def __len__(self***REMOVED***:
        return 1


class Doctype(object***REMOVED***:
    def __init__(self, root_node, name, public_id, system_id***REMOVED***:
        self.root_node = root_node
        self.name = name
        self.public_id = public_id
        self.system_id = system_id

        self.text = None
        self.tail = None

    def getnext(self***REMOVED***:
        return self.root_node.children[1***REMOVED***


class FragmentRoot(Root***REMOVED***:
    def __init__(self, children***REMOVED***:
        self.children = [FragmentWrapper(self, child***REMOVED*** for child in children***REMOVED***
        self.text = self.tail = None

    def getnext(self***REMOVED***:
        return None


class FragmentWrapper(object***REMOVED***:
    def __init__(self, fragment_root, obj***REMOVED***:
        self.root_node = fragment_root
        self.obj = obj
        if hasattr(self.obj, 'text'***REMOVED***:
            self.text = ensure_str(self.obj.text***REMOVED***
        else:
            self.text = None
        if hasattr(self.obj, 'tail'***REMOVED***:
            self.tail = ensure_str(self.obj.tail***REMOVED***
        else:
            self.tail = None

    def __getattr__(self, name***REMOVED***:
        return getattr(self.obj, name***REMOVED***

    def getnext(self***REMOVED***:
        siblings = self.root_node.children
        idx = siblings.index(self***REMOVED***
        if idx < len(siblings***REMOVED*** - 1:
            return siblings[idx + 1***REMOVED***
        else:
            return None

    def __getitem__(self, key***REMOVED***:
        return self.obj[key***REMOVED***

    def __bool__(self***REMOVED***:
        return bool(self.obj***REMOVED***

    def getparent(self***REMOVED***:
        return None

    def __str__(self***REMOVED***:
        return str(self.obj***REMOVED***

    def __unicode__(self***REMOVED***:
        return str(self.obj***REMOVED***

    def __len__(self***REMOVED***:
        return len(self.obj***REMOVED***


class TreeWalker(_base.NonRecursiveTreeWalker***REMOVED***:
    def __init__(self, tree***REMOVED***:
        if hasattr(tree, "getroot"***REMOVED***:
            tree = Root(tree***REMOVED***
        elif isinstance(tree, list***REMOVED***:
            tree = FragmentRoot(tree***REMOVED***
        _base.NonRecursiveTreeWalker.__init__(self, tree***REMOVED***
        self.filter = ihatexml.InfosetFilter(***REMOVED***

    def getNodeDetails(self, node***REMOVED***:
        if isinstance(node, tuple***REMOVED***:  # Text node
            node, key = node
            assert key in ("text", "tail"***REMOVED***, "Text nodes are text or tail, found %s" % key
            return _base.TEXT, ensure_str(getattr(node, key***REMOVED******REMOVED***

        elif isinstance(node, Root***REMOVED***:
            return (_base.DOCUMENT,***REMOVED***

        elif isinstance(node, Doctype***REMOVED***:
            return _base.DOCTYPE, node.name, node.public_id, node.system_id

        elif isinstance(node, FragmentWrapper***REMOVED*** and not hasattr(node, "tag"***REMOVED***:
            return _base.TEXT, node.obj

        elif node.tag == etree.Comment:
            return _base.COMMENT, ensure_str(node.text***REMOVED***

        elif node.tag == etree.Entity:
            return _base.ENTITY, ensure_str(node.text***REMOVED***[1:-1***REMOVED***  # strip &;

        else:
            # This is assumed to be an ordinary element
            match = tag_regexp.match(ensure_str(node.tag***REMOVED******REMOVED***
            if match:
                namespace, tag = match.groups(***REMOVED***
            else:
                namespace = None
                tag = ensure_str(node.tag***REMOVED***
            attrs = {***REMOVED***
            for name, value in list(node.attrib.items(***REMOVED******REMOVED***:
                name = ensure_str(name***REMOVED***
                value = ensure_str(value***REMOVED***
                match = tag_regexp.match(name***REMOVED***
                if match:
                    attrs[(match.group(1***REMOVED***, match.group(2***REMOVED******REMOVED******REMOVED*** = value
                else:
                    attrs[(None, name***REMOVED******REMOVED*** = value
            return (_base.ELEMENT, namespace, self.filter.fromXmlName(tag***REMOVED***,
                    attrs, len(node***REMOVED*** > 0 or node.text***REMOVED***

    def getFirstChild(self, node***REMOVED***:
        assert not isinstance(node, tuple***REMOVED***, "Text nodes have no children"

        assert len(node***REMOVED*** or node.text, "Node has no children"
        if node.text:
            return (node, "text"***REMOVED***
        else:
            return node[0***REMOVED***

    def getNextSibling(self, node***REMOVED***:
        if isinstance(node, tuple***REMOVED***:  # Text node
            node, key = node
            assert key in ("text", "tail"***REMOVED***, "Text nodes are text or tail, found %s" % key
            if key == "text":
                # XXX: we cannot use a "bool(node***REMOVED*** and node[0***REMOVED*** or None" construct here
                # because node[0***REMOVED*** might evaluate to False if it has no child element
                if len(node***REMOVED***:
                    return node[0***REMOVED***
                else:
                    return None
            else:  # tail
                return node.getnext(***REMOVED***

        return (node, "tail"***REMOVED*** if node.tail else node.getnext(***REMOVED***

    def getParentNode(self, node***REMOVED***:
        if isinstance(node, tuple***REMOVED***:  # Text node
            node, key = node
            assert key in ("text", "tail"***REMOVED***, "Text nodes are text or tail, found %s" % key
            if key == "text":
                return node
            # else: fallback to "normal" processing

        return node.getparent(***REMOVED***
