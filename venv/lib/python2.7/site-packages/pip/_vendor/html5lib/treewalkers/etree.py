from __future__ import absolute_import, division, unicode_literals

***REMOVED***
    from collections import OrderedDict
except ImportError:
    ***REMOVED***
        from ordereddict import OrderedDict
    except ImportError:
        OrderedDict = dict

import re

from pip._vendor.six import text_type

from . import _base
from ..utils import moduleFactoryFactory

tag_regexp = re.compile("{([^***REMOVED******REMOVED*******REMOVED******REMOVED***(.****REMOVED***"***REMOVED***


def getETreeBuilder(ElementTreeImplementation***REMOVED***:
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment("asd"***REMOVED***.tag

    class TreeWalker(_base.NonRecursiveTreeWalker***REMOVED***:
        ***REMOVED***Given the particular ElementTree representation, this implementation,
        to avoid using recursion, returns "nodes" as tuples with the following
        content:

        1. The current element

        2. The index of the element relative to its parent

        3. A stack of ancestor elements

        4. A flag "text", "tail" or None to indicate if the current node is a
           text node; either the text or tail of the current element (1***REMOVED***
        ***REMOVED***
        def getNodeDetails(self, node***REMOVED***:
            if isinstance(node, tuple***REMOVED***:  # It might be the root Element
                elt, key, parents, flag = node
                if flag in ("text", "tail"***REMOVED***:
                    return _base.TEXT, getattr(elt, flag***REMOVED***
                else:
                    node = elt

            if not(hasattr(node, "tag"***REMOVED******REMOVED***:
                node = node.getroot(***REMOVED***

            if node.tag in ("DOCUMENT_ROOT", "DOCUMENT_FRAGMENT"***REMOVED***:
                return (_base.DOCUMENT,***REMOVED***

            elif node.tag == "<!DOCTYPE>":
                return (_base.DOCTYPE, node.text,
                        node.get("publicId"***REMOVED***, node.get("systemId"***REMOVED******REMOVED***

            elif node.tag == ElementTreeCommentType:
                return _base.COMMENT, node.text

            else:
                assert isinstance(node.tag, string_types***REMOVED***, type(node.tag***REMOVED***
                # This is assumed to be an ordinary element
                match = tag_regexp.match(node.tag***REMOVED***
                if match:
                    namespace, tag = match.groups(***REMOVED***
                else:
                    namespace = None
                    tag = node.tag
                attrs = OrderedDict(***REMOVED***
                for name, value in list(node.attrib.items(***REMOVED******REMOVED***:
                    match = tag_regexp.match(name***REMOVED***
                    if match:
                        attrs[(match.group(1***REMOVED***, match.group(2***REMOVED******REMOVED******REMOVED*** = value
                    else:
                        attrs[(None, name***REMOVED******REMOVED*** = value
                return (_base.ELEMENT, namespace, tag,
                        attrs, len(node***REMOVED*** or node.text***REMOVED***

        def getFirstChild(self, node***REMOVED***:
            if isinstance(node, tuple***REMOVED***:
                element, key, parents, flag = node
            else:
                element, key, parents, flag = node, None, [***REMOVED***, None

            if flag in ("text", "tail"***REMOVED***:
                return None
            else:
                if element.text:
                    return element, key, parents, "text"
                elif len(element***REMOVED***:
                    parents.append(element***REMOVED***
                    return element[0***REMOVED***, 0, parents, None
                else:
                    return None

        def getNextSibling(self, node***REMOVED***:
            if isinstance(node, tuple***REMOVED***:
                element, key, parents, flag = node
            else:
                return None

            if flag == "text":
                if len(element***REMOVED***:
                    parents.append(element***REMOVED***
                    return element[0***REMOVED***, 0, parents, None
                else:
                    return None
            else:
                if element.tail and flag != "tail":
                    return element, key, parents, "tail"
                elif key < len(parents[-1***REMOVED******REMOVED*** - 1:
                    return parents[-1***REMOVED***[key + 1***REMOVED***, key + 1, parents, None
                else:
                    return None

        def getParentNode(self, node***REMOVED***:
            if isinstance(node, tuple***REMOVED***:
                element, key, parents, flag = node
            else:
                return None

            if flag == "text":
                if not parents:
                    return element
                else:
                    return element, key, parents, None
            else:
                parent = parents.pop(***REMOVED***
                if not parents:
                    return parent
                else:
                    return parent, list(parents[-1***REMOVED******REMOVED***.index(parent***REMOVED***, parents, None

    return locals(***REMOVED***

getETreeModule = moduleFactoryFactory(getETreeBuilder***REMOVED***
