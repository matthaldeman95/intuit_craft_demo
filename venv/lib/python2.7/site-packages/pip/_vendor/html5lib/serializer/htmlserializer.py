from __future__ import absolute_import, division, unicode_literals
from pip._vendor.six import text_type

***REMOVED***
    from functools import reduce
except ImportError:
    pass

from ..constants import voidElements, booleanAttributes, spaceCharacters
from ..constants import rcdataElements, entities, xmlEntities
from .. import utils
from xml.sax.saxutils import escape

spaceCharacters = "".join(spaceCharacters***REMOVED***

***REMOVED***
    from codecs import register_error, xmlcharrefreplace_errors
except ImportError:
    unicode_encode_errors = "strict"
else:
    unicode_encode_errors = "htmlentityreplace"

    encode_entity_map = {***REMOVED***
    is_ucs4 = len("\U0010FFFF"***REMOVED*** == 1
    for k, v in list(entities.items(***REMOVED******REMOVED***:
        # skip multi-character entities
        if ((is_ucs4 and len(v***REMOVED*** > 1***REMOVED*** or
                (not is_ucs4 and len(v***REMOVED*** > 2***REMOVED******REMOVED***:
            continue
        if v != "&":
            if len(v***REMOVED*** == 2:
                v = utils.surrogatePairToCodepoint(v***REMOVED***
            else:
                v = ord(v***REMOVED***
            if v not in encode_entity_map or k.islower(***REMOVED***:
                # prefer &lt; over &LT; and similarly for &amp;, &gt;, etc.
                encode_entity_map[v***REMOVED*** = k

    def htmlentityreplace_errors(exc***REMOVED***:
        if isinstance(exc, (UnicodeEncodeError, UnicodeTranslateError***REMOVED******REMOVED***:
            res = [***REMOVED***
            codepoints = [***REMOVED***
            skip = False
            for i, c in enumerate(exc.object[exc.start:exc.end***REMOVED******REMOVED***:
                if skip:
                    skip = False
                    continue
                index = i + exc.start
                if utils.isSurrogatePair(exc.object[index:min([exc.end, index + 2***REMOVED******REMOVED******REMOVED******REMOVED***:
                    codepoint = utils.surrogatePairToCodepoint(exc.object[index:index + 2***REMOVED******REMOVED***
                    skip = True
                else:
                    codepoint = ord(c***REMOVED***
                codepoints.append(codepoint***REMOVED***
            for cp in codepoints:
                e = encode_entity_map.get(cp***REMOVED***
                if e:
                    res.append("&"***REMOVED***
                    res.append(e***REMOVED***
                    if not e.endswith(";"***REMOVED***:
                        res.append(";"***REMOVED***
                else:
                    res.append("&#x%s;" % (hex(cp***REMOVED***[2:***REMOVED******REMOVED******REMOVED***
            return ("".join(res***REMOVED***, exc.end***REMOVED***
        else:
            return xmlcharrefreplace_errors(exc***REMOVED***

    register_error(unicode_encode_errors, htmlentityreplace_errors***REMOVED***

    del register_error


class HTMLSerializer(object***REMOVED***:

    # attribute quoting options
    quote_attr_values = False
    quote_char = '"'
    use_best_quote_char = True

    # tag syntax options
    omit_optional_tags = True
    minimize_boolean_attributes = True
    use_trailing_solidus = False
    space_before_trailing_solidus = True

    # escaping options
    escape_lt_in_attrs = False
    escape_rcdata = False
    resolve_entities = True

    # miscellaneous options
    alphabetical_attributes = False
    inject_meta_charset = True
    strip_whitespace = False
    sanitize = False

    options = ("quote_attr_values", "quote_char", "use_best_quote_char",
               "omit_optional_tags", "minimize_boolean_attributes",
               "use_trailing_solidus", "space_before_trailing_solidus",
               "escape_lt_in_attrs", "escape_rcdata", "resolve_entities",
               "alphabetical_attributes", "inject_meta_charset",
               "strip_whitespace", "sanitize"***REMOVED***

    def __init__(self, **kwargs***REMOVED***:
        ***REMOVED***Initialize HTMLSerializer.

        Keyword options (default given first unless specified***REMOVED*** include:

        inject_meta_charset=True|False
          Whether it insert a meta element to define the character set of the
          document.
        quote_attr_values=True|False
          Whether to quote attribute values that don't require quoting
          per HTML5 parsing rules.
        quote_char=u'"'|u"'"
          Use given quote character for attribute quoting. Default is to
          use double quote unless attribute value contains a double quote,
          in which case single quotes are used instead.
        escape_lt_in_attrs=False|True
          Whether to escape < in attribute values.
        escape_rcdata=False|True
          Whether to escape characters that need to be escaped within normal
          elements within rcdata elements such as style.
        resolve_entities=True|False
          Whether to resolve named character entities that appear in the
          source tree. The XML predefined entities &lt; &gt; &amp; &quot; &apos;
          are unaffected by this setting.
        strip_whitespace=False|True
          Whether to remove semantically meaningless whitespace. (This
          compresses all whitespace to a single space except within pre.***REMOVED***
        minimize_boolean_attributes=True|False
          Shortens boolean attributes to give just the attribute value,
          for example <input disabled="disabled"> becomes <input disabled>.
        use_trailing_solidus=False|True
          Includes a close-tag slash at the end of the start tag of void
          elements (empty elements whose end tag is forbidden***REMOVED***. E.g. <hr/>.
        space_before_trailing_solidus=True|False
          Places a space immediately before the closing slash in a tag
          using a trailing solidus. E.g. <hr />. Requires use_trailing_solidus.
        sanitize=False|True
          Strip all unsafe or unknown constructs from output.
          See `html5lib user documentation`_
        omit_optional_tags=True|False
          Omit start/end tags that are optional.
        alphabetical_attributes=False|True
          Reorder attributes to be in alphabetical order.

        .. _html5lib user documentation: http://code.google.com/p/html5lib/wiki/UserDocumentation
        ***REMOVED***
        if 'quote_char' in kwargs:
            self.use_best_quote_char = False
        for attr in self.options:
            setattr(self, attr, kwargs.get(attr, getattr(self, attr***REMOVED******REMOVED******REMOVED***
        self.errors = [***REMOVED***
        self.strict = False

    def encode(self, string***REMOVED***:
        assert(isinstance(string, text_type***REMOVED******REMOVED***
        if self.encoding:
            return string.encode(self.encoding, unicode_encode_errors***REMOVED***
        else:
            return string

    def encodeStrict(self, string***REMOVED***:
        assert(isinstance(string, text_type***REMOVED******REMOVED***
        if self.encoding:
            return string.encode(self.encoding, "strict"***REMOVED***
        else:
            return string

    def serialize(self, treewalker, encoding=None***REMOVED***:
        self.encoding = encoding
        in_cdata = False
        self.errors = [***REMOVED***

        if encoding and self.inject_meta_charset:
            from ..filters.inject_meta_charset import Filter
            treewalker = Filter(treewalker, encoding***REMOVED***
        # WhitespaceFilter should be used before OptionalTagFilter
        # for maximum efficiently of this latter filter
        if self.strip_whitespace:
            from ..filters.whitespace import Filter
            treewalker = Filter(treewalker***REMOVED***
        if self.sanitize:
            from ..filters.sanitizer import Filter
            treewalker = Filter(treewalker***REMOVED***
        if self.omit_optional_tags:
            from ..filters.optionaltags import Filter
            treewalker = Filter(treewalker***REMOVED***
        # Alphabetical attributes must be last, as other filters
        # could add attributes and alter the order
        if self.alphabetical_attributes:
            from ..filters.alphabeticalattributes import Filter
            treewalker = Filter(treewalker***REMOVED***

        for token in treewalker:
            type = token["type"***REMOVED***
            if type == "Doctype":
                doctype = "<!DOCTYPE %s" % token["name"***REMOVED***

                if token["publicId"***REMOVED***:
                    doctype += ' PUBLIC "%s"' % token["publicId"***REMOVED***
                elif token["systemId"***REMOVED***:
                    doctype += " SYSTEM"
                if token["systemId"***REMOVED***:
                    if token["systemId"***REMOVED***.find('"'***REMOVED*** >= 0:
                        if token["systemId"***REMOVED***.find("'"***REMOVED*** >= 0:
                            self.serializeError("System identifer contains both single and double quote characters"***REMOVED***
                        quote_char = "'"
                    else:
                        quote_char = '"'
                    doctype += " %s%s%s" % (quote_char, token["systemId"***REMOVED***, quote_char***REMOVED***

                doctype += ">"
                yield self.encodeStrict(doctype***REMOVED***

            elif type in ("Characters", "SpaceCharacters"***REMOVED***:
                if type == "SpaceCharacters" or in_cdata:
                    if in_cdata and token["data"***REMOVED***.find("</"***REMOVED*** >= 0:
                        self.serializeError("Unexpected </ in CDATA"***REMOVED***
                    yield self.encode(token["data"***REMOVED******REMOVED***
                else:
                    yield self.encode(escape(token["data"***REMOVED******REMOVED******REMOVED***

            elif type in ("StartTag", "EmptyTag"***REMOVED***:
                name = token["name"***REMOVED***
                yield self.encodeStrict("<%s" % name***REMOVED***
                if name in rcdataElements and not self.escape_rcdata:
                    in_cdata = True
                elif in_cdata:
                    self.serializeError("Unexpected child element of a CDATA element"***REMOVED***
                for (attr_namespace, attr_name***REMOVED***, attr_value in token["data"***REMOVED***.items(***REMOVED***:
                    # TODO: Add namespace support here
                    k = attr_name
                    v = attr_value
                    yield self.encodeStrict(' '***REMOVED***

                    yield self.encodeStrict(k***REMOVED***
                    if not self.minimize_boolean_attributes or \
                        (k not in booleanAttributes.get(name, tuple(***REMOVED******REMOVED***
                         and k not in booleanAttributes.get("", tuple(***REMOVED******REMOVED******REMOVED***:
                        yield self.encodeStrict("="***REMOVED***
                        if self.quote_attr_values or not v:
                            quote_attr = True
                        else:
                            quote_attr = reduce(lambda x, y: x or (y in v***REMOVED***,
                                                spaceCharacters + ">\"'=", False***REMOVED***
                        v = v.replace("&", "&amp;"***REMOVED***
                        if self.escape_lt_in_attrs:
                            v = v.replace("<", "&lt;"***REMOVED***
                        if quote_attr:
                            quote_char = self.quote_char
                            if self.use_best_quote_char:
                                if "'" in v and '"' not in v:
                                    quote_char = '"'
                                elif '"' in v and "'" not in v:
                                    quote_char = "'"
                            if quote_char == "'":
                                v = v.replace("'", "&#39;"***REMOVED***
                            else:
                                v = v.replace('"', "&quot;"***REMOVED***
                            yield self.encodeStrict(quote_char***REMOVED***
                            yield self.encode(v***REMOVED***
                            yield self.encodeStrict(quote_char***REMOVED***
                        else:
                            yield self.encode(v***REMOVED***
                if name in voidElements and self.use_trailing_solidus:
                    if self.space_before_trailing_solidus:
                        yield self.encodeStrict(" /"***REMOVED***
                    else:
                        yield self.encodeStrict("/"***REMOVED***
                yield self.encode(">"***REMOVED***

            elif type == "EndTag":
                name = token["name"***REMOVED***
                if name in rcdataElements:
                    in_cdata = False
                elif in_cdata:
                    self.serializeError("Unexpected child element of a CDATA element"***REMOVED***
                yield self.encodeStrict("</%s>" % name***REMOVED***

            elif type == "Comment":
                data = token["data"***REMOVED***
                if data.find("--"***REMOVED*** >= 0:
                    self.serializeError("Comment contains --"***REMOVED***
                yield self.encodeStrict("<!--%s-->" % token["data"***REMOVED******REMOVED***

            elif type == "Entity":
                name = token["name"***REMOVED***
                key = name + ";"
                if key not in entities:
                    self.serializeError("Entity %s not recognized" % name***REMOVED***
                if self.resolve_entities and key not in xmlEntities:
                    data = entities[key***REMOVED***
                else:
                    data = "&%s;" % name
                yield self.encodeStrict(data***REMOVED***

            else:
                self.serializeError(token["data"***REMOVED******REMOVED***

    def render(self, treewalker, encoding=None***REMOVED***:
        if encoding:
            return b"".join(list(self.serialize(treewalker, encoding***REMOVED******REMOVED******REMOVED***
        else:
            return "".join(list(self.serialize(treewalker***REMOVED******REMOVED******REMOVED***

    def serializeError(self, data="XXX ERROR MESSAGE NEEDED"***REMOVED***:
        # XXX The idea is to make data mandatory.
        self.errors.append(data***REMOVED***
        if self.strict:
            raise SerializeError


def SerializeError(Exception***REMOVED***:
    ***REMOVED***Error in serialized tree***REMOVED***
    pass
