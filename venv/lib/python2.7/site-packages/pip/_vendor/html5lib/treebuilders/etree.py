from __future__ import absolute_import, division, unicode_literals
from pip._vendor.six import text_type

import re

from . import _base
from .. import ihatexml
from .. import constants
from ..constants import namespaces
from ..utils import moduleFactoryFactory

tag_regexp = re.compile("{([^***REMOVED******REMOVED*******REMOVED******REMOVED***(.****REMOVED***"***REMOVED***


def getETreeBuilder(ElementTreeImplementation, fullTree=False***REMOVED***:
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment("asd"***REMOVED***.tag

    class Element(_base.Node***REMOVED***:
        def __init__(self, name, namespace=None***REMOVED***:
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name,
                                                                  namespace***REMOVED******REMOVED***
            if namespace is None:
                self.nameTuple = namespaces["html"***REMOVED***, self._name
            else:
                self.nameTuple = self._namespace, self._name
            self.parent = None
            self._childNodes = [***REMOVED***
            self._flags = [***REMOVED***

        def _getETreeTag(self, name, namespace***REMOVED***:
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = "{%s***REMOVED***%s" % (namespace, name***REMOVED***
            return etree_tag

        def _setName(self, name***REMOVED***:
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace***REMOVED***

        def _getName(self***REMOVED***:
            return self._name

        name = property(_getName, _setName***REMOVED***

        def _setNamespace(self, namespace***REMOVED***:
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace***REMOVED***

        def _getNamespace(self***REMOVED***:
            return self._namespace

        namespace = property(_getNamespace, _setNamespace***REMOVED***

        def _getAttributes(self***REMOVED***:
            return self._element.attrib

        def _setAttributes(self, attributes***REMOVED***:
            # Delete existing attributes first
            # XXX - there may be a better way to do this...
            for key in list(self._element.attrib.keys(***REMOVED******REMOVED***:
                del self._element.attrib[key***REMOVED***
            for key, value in attributes.items(***REMOVED***:
                if isinstance(key, tuple***REMOVED***:
                    name = "{%s***REMOVED***%s" % (key[2***REMOVED***, key[1***REMOVED******REMOVED***
                else:
                    name = key
                self._element.set(name, value***REMOVED***

        attributes = property(_getAttributes, _setAttributes***REMOVED***

        def _getChildNodes(self***REMOVED***:
            return self._childNodes

        def _setChildNodes(self, value***REMOVED***:
            del self._element[:***REMOVED***
            self._childNodes = [***REMOVED***
            for element in value:
                self.insertChild(element***REMOVED***

        childNodes = property(_getChildNodes, _setChildNodes***REMOVED***

        def hasContent(self***REMOVED***:
            ***REMOVED***Return true if the node has children or text***REMOVED***
            return bool(self._element.text or len(self._element***REMOVED******REMOVED***

        def appendChild(self, node***REMOVED***:
            self._childNodes.append(node***REMOVED***
            self._element.append(node._element***REMOVED***
            node.parent = self

        def insertBefore(self, node, refNode***REMOVED***:
            index = list(self._element***REMOVED***.index(refNode._element***REMOVED***
            self._element.insert(index, node._element***REMOVED***
            node.parent = self

        def removeChild(self, node***REMOVED***:
            self._element.remove(node._element***REMOVED***
            node.parent = None

        def insertText(self, data, insertBefore=None***REMOVED***:
            if not(len(self._element***REMOVED******REMOVED***:
                if not self._element.text:
                    self._element.text = ""
                self._element.text += data
            elif insertBefore is None:
                # Insert the text as the tail of the last child element
                if not self._element[-1***REMOVED***.tail:
                    self._element[-1***REMOVED***.tail = ""
                self._element[-1***REMOVED***.tail += data
            else:
                # Insert the text before the specified node
                children = list(self._element***REMOVED***
                index = children.index(insertBefore._element***REMOVED***
                if index > 0:
                    if not self._element[index - 1***REMOVED***.tail:
                        self._element[index - 1***REMOVED***.tail = ""
                    self._element[index - 1***REMOVED***.tail += data
                else:
                    if not self._element.text:
                        self._element.text = ""
                    self._element.text += data

        def cloneNode(self***REMOVED***:
            element = type(self***REMOVED***(self.name, self.namespace***REMOVED***
            for name, value in self.attributes.items(***REMOVED***:
                element.attributes[name***REMOVED*** = value
            return element

        def reparentChildren(self, newParent***REMOVED***:
            if newParent.childNodes:
                newParent.childNodes[-1***REMOVED***._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ""
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ""
            _base.Node.reparentChildren(self, newParent***REMOVED***

    class Comment(Element***REMOVED***:
        def __init__(self, data***REMOVED***:
            # Use the superclass constructor to set all properties on the
            # wrapper element
            self._element = ElementTree.Comment(data***REMOVED***
            self.parent = None
            self._childNodes = [***REMOVED***
            self._flags = [***REMOVED***

        def _getData(self***REMOVED***:
            return self._element.text

        def _setData(self, value***REMOVED***:
            self._element.text = value

        data = property(_getData, _setData***REMOVED***

    class DocumentType(Element***REMOVED***:
        def __init__(self, name, publicId, systemId***REMOVED***:
            Element.__init__(self, "<!DOCTYPE>"***REMOVED***
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self***REMOVED***:
            return self._element.get("publicId", ""***REMOVED***

        def _setPublicId(self, value***REMOVED***:
            if value is not None:
                self._element.set("publicId", value***REMOVED***

        publicId = property(_getPublicId, _setPublicId***REMOVED***

        def _getSystemId(self***REMOVED***:
            return self._element.get("systemId", ""***REMOVED***

        def _setSystemId(self, value***REMOVED***:
            if value is not None:
                self._element.set("systemId", value***REMOVED***

        systemId = property(_getSystemId, _setSystemId***REMOVED***

    class Document(Element***REMOVED***:
        def __init__(self***REMOVED***:
            Element.__init__(self, "DOCUMENT_ROOT"***REMOVED***

    class DocumentFragment(Element***REMOVED***:
        def __init__(self***REMOVED***:
            Element.__init__(self, "DOCUMENT_FRAGMENT"***REMOVED***

    def testSerializer(element***REMOVED***:
        rv = [***REMOVED***

        def serializeElement(element, indent=0***REMOVED***:
            if not(hasattr(element, "tag"***REMOVED******REMOVED***:
                element = element.getroot(***REMOVED***
            if element.tag == "<!DOCTYPE>":
                if element.get("publicId"***REMOVED*** or element.get("systemId"***REMOVED***:
                    publicId = element.get("publicId"***REMOVED*** or ""
                    systemId = element.get("systemId"***REMOVED*** or ""
                    rv.append(***REMOVED***<!DOCTYPE %s "%s" "%s">***REMOVED*** %
                              (element.text, publicId, systemId***REMOVED******REMOVED***
                else:
                    rv.append("<!DOCTYPE %s>" % (element.text,***REMOVED******REMOVED***
            elif element.tag == "DOCUMENT_ROOT":
                rv.append("#document"***REMOVED***
                if element.text is not None:
                    rv.append("|%s\"%s\"" % (' ' * (indent + 2***REMOVED***, element.text***REMOVED******REMOVED***
                if element.tail is not None:
                    raise TypeError("Document node cannot have tail"***REMOVED***
                if hasattr(element, "attrib"***REMOVED*** and len(element.attrib***REMOVED***:
                    raise TypeError("Document node cannot have attributes"***REMOVED***
            elif element.tag == ElementTreeCommentType:
                rv.append("|%s<!-- %s -->" % (' ' * indent, element.text***REMOVED******REMOVED***
            else:
                assert isinstance(element.tag, text_type***REMOVED***, \
                    "Expected unicode, got %s, %s" % (type(element.tag***REMOVED***, element.tag***REMOVED***
                nsmatch = tag_regexp.match(element.tag***REMOVED***

                if nsmatch is None:
                    name = element.tag
                else:
                    ns, name = nsmatch.groups(***REMOVED***
                    prefix = constants.prefixes[ns***REMOVED***
                    name = "%s %s" % (prefix, name***REMOVED***
                rv.append("|%s<%s>" % (' ' * indent, name***REMOVED******REMOVED***

                if hasattr(element, "attrib"***REMOVED***:
                    attributes = [***REMOVED***
                    for name, value in element.attrib.items(***REMOVED***:
                        nsmatch = tag_regexp.match(name***REMOVED***
                        if nsmatch is not None:
                            ns, name = nsmatch.groups(***REMOVED***
                            prefix = constants.prefixes[ns***REMOVED***
                            attr_string = "%s %s" % (prefix, name***REMOVED***
                        else:
                            attr_string = name
                        attributes.append((attr_string, value***REMOVED******REMOVED***

                    for name, value in sorted(attributes***REMOVED***:
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2***REMOVED***, name, value***REMOVED******REMOVED***
                if element.text:
                    rv.append("|%s\"%s\"" % (' ' * (indent + 2***REMOVED***, element.text***REMOVED******REMOVED***
            indent += 2
            for child in element:
                serializeElement(child, indent***REMOVED***
            if element.tail:
                rv.append("|%s\"%s\"" % (' ' * (indent - 2***REMOVED***, element.tail***REMOVED******REMOVED***
        serializeElement(element, 0***REMOVED***

        return "\n".join(rv***REMOVED***

    def tostring(element***REMOVED***:
        ***REMOVED***Serialize an element and its child nodes to a string***REMOVED***
        rv = [***REMOVED***
        filter = ihatexml.InfosetFilter(***REMOVED***

        def serializeElement(element***REMOVED***:
            if isinstance(element, ElementTree.ElementTree***REMOVED***:
                element = element.getroot(***REMOVED***

            if element.tag == "<!DOCTYPE>":
                if element.get("publicId"***REMOVED*** or element.get("systemId"***REMOVED***:
                    publicId = element.get("publicId"***REMOVED*** or ""
                    systemId = element.get("systemId"***REMOVED*** or ""
                    rv.append(***REMOVED***<!DOCTYPE %s PUBLIC "%s" "%s">***REMOVED*** %
                              (element.text, publicId, systemId***REMOVED******REMOVED***
                else:
                    rv.append("<!DOCTYPE %s>" % (element.text,***REMOVED******REMOVED***
            elif element.tag == "DOCUMENT_ROOT":
                if element.text is not None:
                    rv.append(element.text***REMOVED***
                if element.tail is not None:
                    raise TypeError("Document node cannot have tail"***REMOVED***
                if hasattr(element, "attrib"***REMOVED*** and len(element.attrib***REMOVED***:
                    raise TypeError("Document node cannot have attributes"***REMOVED***

                for child in element:
                    serializeElement(child***REMOVED***

            elif element.tag == ElementTreeCommentType:
                rv.append("<!--%s-->" % (element.text,***REMOVED******REMOVED***
            else:
                # This is assumed to be an ordinary element
                if not element.attrib:
                    rv.append("<%s>" % (filter.fromXmlName(element.tag***REMOVED***,***REMOVED******REMOVED***
                else:
                    attr = " ".join(["%s=\"%s\"" % (
                        filter.fromXmlName(name***REMOVED***, value***REMOVED***
                        for name, value in element.attrib.items(***REMOVED******REMOVED******REMOVED***
                    rv.append("<%s %s>" % (element.tag, attr***REMOVED******REMOVED***
                if element.text:
                    rv.append(element.text***REMOVED***

                for child in element:
                    serializeElement(child***REMOVED***

                rv.append("</%s>" % (element.tag,***REMOVED******REMOVED***

            if element.tail:
                rv.append(element.tail***REMOVED***

        serializeElement(element***REMOVED***

        return "".join(rv***REMOVED***

    class TreeBuilder(_base.TreeBuilder***REMOVED***:
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element***REMOVED***:
            return testSerializer(element***REMOVED***

        def getDocument(self***REMOVED***:
            if fullTree:
                return self.document._element
            else:
                if self.defaultNamespace is not None:
                    return self.document._element.find(
                        "{%s***REMOVED***html" % self.defaultNamespace***REMOVED***
                else:
                    return self.document._element.find("html"***REMOVED***

        def getFragment(self***REMOVED***:
            return _base.TreeBuilder.getFragment(self***REMOVED***._element

    return locals(***REMOVED***


getETreeModule = moduleFactoryFactory(getETreeBuilder***REMOVED***
