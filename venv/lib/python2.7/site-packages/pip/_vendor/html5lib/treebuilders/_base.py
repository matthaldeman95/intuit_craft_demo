from __future__ import absolute_import, division, unicode_literals
from pip._vendor.six import text_type

from ..constants import scopingElements, tableInsertModeElements, namespaces

# The scope markers are inserted when entering object elements,
# marquees, table cells, and table captions, and are used to prevent formatting
# from "leaking" into tables, object elements, and marquees.
Marker = None

listElementsMap = {
    None: (frozenset(scopingElements***REMOVED***, False***REMOVED***,
    "button": (frozenset(scopingElements | set([(namespaces["html"***REMOVED***, "button"***REMOVED******REMOVED******REMOVED******REMOVED***, False***REMOVED***,
    "list": (frozenset(scopingElements | set([(namespaces["html"***REMOVED***, "ol"***REMOVED***,
                                              (namespaces["html"***REMOVED***, "ul"***REMOVED******REMOVED******REMOVED******REMOVED***, False***REMOVED***,
    "table": (frozenset([(namespaces["html"***REMOVED***, "html"***REMOVED***,
                         (namespaces["html"***REMOVED***, "table"***REMOVED******REMOVED******REMOVED***, False***REMOVED***,
    "select": (frozenset([(namespaces["html"***REMOVED***, "optgroup"***REMOVED***,
                          (namespaces["html"***REMOVED***, "option"***REMOVED******REMOVED******REMOVED***, True***REMOVED***
***REMOVED***


class Node(object***REMOVED***:
    def __init__(self, name***REMOVED***:
        ***REMOVED***Node representing an item in the tree.
        name - The tag name associated with the node
        parent - The parent of the current node (or None for the document node***REMOVED***
        value - The value of the current node (applies to text nodes and
        comments
        attributes - a dict holding name, value pairs for attributes of the node
        childNodes - a list of child nodes of the current node. This must
        include all elements but not necessarily other node types
        _flags - A list of miscellaneous flags that can be set on the node
        ***REMOVED***
        self.name = name
        self.parent = None
        self.value = None
        self.attributes = {***REMOVED***
        self.childNodes = [***REMOVED***
        self._flags = [***REMOVED***

    def __str__(self***REMOVED***:
        attributesStr = " ".join(["%s=\"%s\"" % (name, value***REMOVED***
                                  for name, value in
                                  self.attributes.items(***REMOVED******REMOVED******REMOVED***
        if attributesStr:
            return "<%s %s>" % (self.name, attributesStr***REMOVED***
        else:
            return "<%s>" % (self.name***REMOVED***

    def __repr__(self***REMOVED***:
        return "<%s>" % (self.name***REMOVED***

    def appendChild(self, node***REMOVED***:
        ***REMOVED***Insert node as a child of the current node
        ***REMOVED***
        raise NotImplementedError

    def insertText(self, data, insertBefore=None***REMOVED***:
        ***REMOVED***Insert data as text in the current node, positioned before the
        start of node insertBefore or to the end of the node's text.
        ***REMOVED***
        raise NotImplementedError

    def insertBefore(self, node, refNode***REMOVED***:
        ***REMOVED***Insert node as a child of the current node, before refNode in the
        list of child nodes. Raises ValueError if refNode is not a child of
        the current node***REMOVED***
        raise NotImplementedError

    def removeChild(self, node***REMOVED***:
        ***REMOVED***Remove node from the children of the current node
        ***REMOVED***
        raise NotImplementedError

    def reparentChildren(self, newParent***REMOVED***:
        ***REMOVED***Move all the children of the current node to newParent.
        This is needed so that trees that don't store text as nodes move the
        text in the correct way
        ***REMOVED***
        # XXX - should this method be made more general?
        for child in self.childNodes:
            newParent.appendChild(child***REMOVED***
        self.childNodes = [***REMOVED***

    def cloneNode(self***REMOVED***:
        ***REMOVED***Return a shallow copy of the current node i.e. a node with the same
        name and attributes but with no parent or child nodes
        ***REMOVED***
        raise NotImplementedError

    def hasContent(self***REMOVED***:
        ***REMOVED***Return true if the node has children or text, false otherwise
        ***REMOVED***
        raise NotImplementedError


class ActiveFormattingElements(list***REMOVED***:
    def append(self, node***REMOVED***:
        equalCount = 0
        if node != Marker:
            for element in self[::-1***REMOVED***:
                if element == Marker:
                    break
                if self.nodesEqual(element, node***REMOVED***:
                    equalCount += 1
                if equalCount == 3:
                    self.remove(element***REMOVED***
                    break
        list.append(self, node***REMOVED***

    def nodesEqual(self, node1, node2***REMOVED***:
        if not node1.nameTuple == node2.nameTuple:
            return False

        if not node1.attributes == node2.attributes:
            return False

        return True


class TreeBuilder(object***REMOVED***:
    ***REMOVED***Base treebuilder implementation
    documentClass - the class to use for the bottommost node of a document
    elementClass - the class to use for HTML Elements
    commentClass - the class to use for comments
    doctypeClass - the class to use for doctypes
    ***REMOVED***

    # Document class
    documentClass = None

    # The class to use for creating a node
    elementClass = None

    # The class to use for creating comments
    commentClass = None

    # The class to use for creating doctypes
    doctypeClass = None

    # Fragment class
    fragmentClass = None

    def __init__(self, namespaceHTMLElements***REMOVED***:
        if namespaceHTMLElements:
            self.defaultNamespace = "http://www.w3.org/1999/xhtml"
        else:
            self.defaultNamespace = None
        self.reset(***REMOVED***

    def reset(self***REMOVED***:
        self.openElements = [***REMOVED***
        self.activeFormattingElements = ActiveFormattingElements(***REMOVED***

        # XXX - rename these to headElement, formElement
        self.headPointer = None
        self.formPointer = None

        self.insertFromTable = False

        self.document = self.documentClass(***REMOVED***

    def elementInScope(self, target, variant=None***REMOVED***:

        # If we pass a node in we match that. if we pass a string
        # match any node with that name
        exactNode = hasattr(target, "nameTuple"***REMOVED***

        listElements, invert = listElementsMap[variant***REMOVED***

        for node in reversed(self.openElements***REMOVED***:
            if (node.name == target and not exactNode or
                    node == target and exactNode***REMOVED***:
                return True
            elif (invert ^ (node.nameTuple in listElements***REMOVED******REMOVED***:
                return False

        assert False  # We should never reach this point

    def reconstructActiveFormattingElements(self***REMOVED***:
        # Within this algorithm the order of steps described in the
        # specification is not quite the same as the order of steps in the
        # code. It should still do the same though.

        # Step 1: stop the algorithm when there's nothing to do.
        if not self.activeFormattingElements:
            return

        # Step 2 and step 3: we start with the last element. So i is -1.
        i = len(self.activeFormattingElements***REMOVED*** - 1
        entry = self.activeFormattingElements[i***REMOVED***
        if entry == Marker or entry in self.openElements:
            return

        # Step 6
        while entry != Marker and entry not in self.openElements:
            if i == 0:
                # This will be reset to 0 below
                i = -1
                break
            i -= 1
            # Step 5: let entry be one earlier in the list.
            entry = self.activeFormattingElements[i***REMOVED***

        while True:
            # Step 7
            i += 1

            # Step 8
            entry = self.activeFormattingElements[i***REMOVED***
            clone = entry.cloneNode(***REMOVED***  # Mainly to get a new copy of the attributes

            # Step 9
            element = self.insertElement({"type": "StartTag",
                                          "name": clone.name,
                                          "namespace": clone.namespace,
                                          "data": clone.attributes***REMOVED******REMOVED***

            # Step 10
            self.activeFormattingElements[i***REMOVED*** = element

            # Step 11
            if element == self.activeFormattingElements[-1***REMOVED***:
                break

    def clearActiveFormattingElements(self***REMOVED***:
        entry = self.activeFormattingElements.pop(***REMOVED***
        while self.activeFormattingElements and entry != Marker:
            entry = self.activeFormattingElements.pop(***REMOVED***

    def elementInActiveFormattingElements(self, name***REMOVED***:
        ***REMOVED***Check if an element exists between the end of the active
        formatting elements and the last marker. If it does, return it, else
        return false***REMOVED***

        for item in self.activeFormattingElements[::-1***REMOVED***:
            # Check for Marker first because if it's a Marker it doesn't have a
            # name attribute.
            if item == Marker:
                break
            elif item.name == name:
                return item
        return False

    def insertRoot(self, token***REMOVED***:
        element = self.createElement(token***REMOVED***
        self.openElements.append(element***REMOVED***
        self.document.appendChild(element***REMOVED***

    def insertDoctype(self, token***REMOVED***:
        name = token["name"***REMOVED***
        publicId = token["publicId"***REMOVED***
        systemId = token["systemId"***REMOVED***

        doctype = self.doctypeClass(name, publicId, systemId***REMOVED***
        self.document.appendChild(doctype***REMOVED***

    def insertComment(self, token, parent=None***REMOVED***:
        if parent is None:
            parent = self.openElements[-1***REMOVED***
        parent.appendChild(self.commentClass(token["data"***REMOVED******REMOVED******REMOVED***

    def createElement(self, token***REMOVED***:
        ***REMOVED***Create an element but don't insert it anywhere***REMOVED***
        name = token["name"***REMOVED***
        namespace = token.get("namespace", self.defaultNamespace***REMOVED***
        element = self.elementClass(name, namespace***REMOVED***
        element.attributes = token["data"***REMOVED***
        return element

    def _getInsertFromTable(self***REMOVED***:
        return self._insertFromTable

    def _setInsertFromTable(self, value***REMOVED***:
        ***REMOVED***Switch the function used to insert an element from the
        normal one to the misnested table one and back again***REMOVED***
        self._insertFromTable = value
        if value:
            self.insertElement = self.insertElementTable
        else:
            self.insertElement = self.insertElementNormal

    insertFromTable = property(_getInsertFromTable, _setInsertFromTable***REMOVED***

    def insertElementNormal(self, token***REMOVED***:
        name = token["name"***REMOVED***
        assert isinstance(name, text_type***REMOVED***, "Element %s not unicode" % name
        namespace = token.get("namespace", self.defaultNamespace***REMOVED***
        element = self.elementClass(name, namespace***REMOVED***
        element.attributes = token["data"***REMOVED***
        self.openElements[-1***REMOVED***.appendChild(element***REMOVED***
        self.openElements.append(element***REMOVED***
        return element

    def insertElementTable(self, token***REMOVED***:
        ***REMOVED***Create an element and insert it into the tree***REMOVED***
        element = self.createElement(token***REMOVED***
        if self.openElements[-1***REMOVED***.name not in tableInsertModeElements:
            return self.insertElementNormal(token***REMOVED***
        else:
            # We should be in the InTable mode. This means we want to do
            # special magic element rearranging
            parent, insertBefore = self.getTableMisnestedNodePosition(***REMOVED***
            if insertBefore is None:
                parent.appendChild(element***REMOVED***
            else:
                parent.insertBefore(element, insertBefore***REMOVED***
            self.openElements.append(element***REMOVED***
        return element

    def insertText(self, data, parent=None***REMOVED***:
        ***REMOVED***Insert text data.***REMOVED***
        if parent is None:
            parent = self.openElements[-1***REMOVED***

        if (not self.insertFromTable or (self.insertFromTable and
                                         self.openElements[-1***REMOVED***.name
                                         not in tableInsertModeElements***REMOVED******REMOVED***:
            parent.insertText(data***REMOVED***
        else:
            # We should be in the InTable mode. This means we want to do
            # special magic element rearranging
            parent, insertBefore = self.getTableMisnestedNodePosition(***REMOVED***
            parent.insertText(data, insertBefore***REMOVED***

    def getTableMisnestedNodePosition(self***REMOVED***:
        ***REMOVED***Get the foster parent element, and sibling to insert before
        (or None***REMOVED*** when inserting a misnested table node***REMOVED***
        # The foster parent element is the one which comes before the most
        # recently opened table element
        # XXX - this is really inelegant
        lastTable = None
        fosterParent = None
        insertBefore = None
        for elm in self.openElements[::-1***REMOVED***:
            if elm.name == "table":
                lastTable = elm
                break
        if lastTable:
            # XXX - we should really check that this parent is actually a
            # node here
            if lastTable.parent:
                fosterParent = lastTable.parent
                insertBefore = lastTable
            else:
                fosterParent = self.openElements[
                    self.openElements.index(lastTable***REMOVED*** - 1***REMOVED***
        else:
            fosterParent = self.openElements[0***REMOVED***
        return fosterParent, insertBefore

    def generateImpliedEndTags(self, exclude=None***REMOVED***:
        name = self.openElements[-1***REMOVED***.name
        # XXX td, th and tr are not actually needed
        if (name in frozenset(("dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"***REMOVED******REMOVED***
                and name != exclude***REMOVED***:
            self.openElements.pop(***REMOVED***
            # XXX This is not entirely what the specification says. We should
            # investigate it more closely.
            self.generateImpliedEndTags(exclude***REMOVED***

    def getDocument(self***REMOVED***:
        "Return the final tree"
        return self.document

    def getFragment(self***REMOVED***:
        "Return the final fragment"
        # assert self.innerHTML
        fragment = self.fragmentClass(***REMOVED***
        self.openElements[0***REMOVED***.reparentChildren(fragment***REMOVED***
        return fragment

    def testSerializer(self, node***REMOVED***:
        ***REMOVED***Serialize the subtree of node in the format required by unit tests
        node - the node from which to start serializing***REMOVED***
        raise NotImplementedError
