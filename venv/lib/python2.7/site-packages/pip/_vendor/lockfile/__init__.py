# -*- coding: utf-8 -*-

***REMOVED***
lockfile.py - Platform-independent advisory file locks.

Requires Python 2.5 unless you apply 2.4.diff
Locking is done on a per-thread basis instead of a per-process basis.

Usage:

>>> lock = LockFile('somefile'***REMOVED***
>>> ***REMOVED***
...     lock.acquire(***REMOVED***
... except AlreadyLocked:
...     print 'somefile', 'is locked already.'
... except LockFailed:
...     print 'somefile', 'can\\'t be locked.'
... else:
...     print 'got lock'
got lock
>>> print lock.is_locked(***REMOVED***
True
>>> lock.release(***REMOVED***

>>> lock = LockFile('somefile'***REMOVED***
>>> print lock.is_locked(***REMOVED***
False
>>> with lock:
...    print lock.is_locked(***REMOVED***
True
>>> print lock.is_locked(***REMOVED***
False

>>> lock = LockFile('somefile'***REMOVED***
>>> # It is okay to lock twice from the same thread...
>>> with lock:
...     lock.acquire(***REMOVED***
...
>>> # Though no counter is kept, so you can't unlock multiple times...
>>> print lock.is_locked(***REMOVED***
False

Exceptions:

    Error - base class for other exceptions
        LockError - base class for all locking exceptions
            AlreadyLocked - Another thread or process already holds the lock
            LockFailed - Lock failed for some other reason
        UnlockError - base class for all unlocking exceptions
            AlreadyUnlocked - File was not locked.
            NotMyLock - File was locked but not by the current thread/process
***REMOVED***

from __future__ import absolute_import

import functools
***REMOVED***
import socket
import threading
import warnings

# Work with PEP8 and non-PEP8 versions of threading module.
if not hasattr(threading, "current_thread"***REMOVED***:
    threading.current_thread = threading.currentThread
if not hasattr(threading.Thread, "get_name"***REMOVED***:
    threading.Thread.get_name = threading.Thread.getName

__all__ = ['Error', 'LockError', 'LockTimeout', 'AlreadyLocked',
           'LockFailed', 'UnlockError', 'NotLocked', 'NotMyLock',
           'LinkFileLock', 'MkdirFileLock', 'SQLiteFileLock',
           'LockBase', 'locked'***REMOVED***


class Error(Exception***REMOVED***:
    ***REMOVED***
    Base class for other exceptions.

    >>> ***REMOVED***
    ...   raise Error
    ... except Exception:
    ...   pass
    ***REMOVED***
    pass


class LockError(Error***REMOVED***:
    ***REMOVED***
    Base class for error arising from attempts to acquire the lock.

    >>> ***REMOVED***
    ...   raise LockError
    ... except Error:
    ...   pass
    ***REMOVED***
    pass


class LockTimeout(LockError***REMOVED***:
    ***REMOVED***Raised when lock creation fails within a user-defined period of time.

    >>> ***REMOVED***
    ...   raise LockTimeout
    ... except LockError:
    ...   pass
    ***REMOVED***
    pass


class AlreadyLocked(LockError***REMOVED***:
    ***REMOVED***Some other thread/process is locking the file.

    >>> ***REMOVED***
    ...   raise AlreadyLocked
    ... except LockError:
    ...   pass
    ***REMOVED***
    pass


class LockFailed(LockError***REMOVED***:
    ***REMOVED***Lock file creation failed for some other reason.

    >>> ***REMOVED***
    ...   raise LockFailed
    ... except LockError:
    ...   pass
    ***REMOVED***
    pass


class UnlockError(Error***REMOVED***:
    ***REMOVED***
    Base class for errors arising from attempts to release the lock.

    >>> ***REMOVED***
    ...   raise UnlockError
    ... except Error:
    ...   pass
    ***REMOVED***
    pass


class NotLocked(UnlockError***REMOVED***:
    ***REMOVED***Raised when an attempt is made to unlock an unlocked file.

    >>> ***REMOVED***
    ...   raise NotLocked
    ... except UnlockError:
    ...   pass
    ***REMOVED***
    pass


class NotMyLock(UnlockError***REMOVED***:
    ***REMOVED***Raised when an attempt is made to unlock a file someone else locked.

    >>> ***REMOVED***
    ...   raise NotMyLock
    ... except UnlockError:
    ...   pass
    ***REMOVED***
    pass


class _SharedBase(object***REMOVED***:
    def __init__(self, path***REMOVED***:
        self.path = path

    def acquire(self, timeout=None***REMOVED***:
        ***REMOVED***
        Acquire the lock.

        * If timeout is omitted (or None***REMOVED***, wait forever trying to lock the
          file.

        * If timeout > 0, try to acquire the lock for that many seconds.  If
          the lock period expires and the file is still locked, raise
          LockTimeout.

        * If timeout <= 0, raise AlreadyLocked immediately if the file is
          already locked.
        ***REMOVED***
        raise NotImplemented("implement in subclass"***REMOVED***

    def release(self***REMOVED***:
        ***REMOVED***
        Release the lock.

        If the file is not locked, raise NotLocked.
        ***REMOVED***
        raise NotImplemented("implement in subclass"***REMOVED***

    def __enter__(self***REMOVED***:
        ***REMOVED***
        Context manager support.
        ***REMOVED***
        self.acquire(***REMOVED***
        return self

    def __exit__(self, *_exc***REMOVED***:
        ***REMOVED***
        Context manager support.
        ***REMOVED***
        self.release(***REMOVED***

    def __repr__(self***REMOVED***:
        return "<%s: %r>" % (self.__class__.__name__, self.path***REMOVED***


class LockBase(_SharedBase***REMOVED***:
    ***REMOVED***Base class for platform-specific lock classes.***REMOVED***
    def __init__(self, path, threaded=True, timeout=None***REMOVED***:
        ***REMOVED***
        >>> lock = LockBase('somefile'***REMOVED***
        >>> lock = LockBase('somefile', threaded=False***REMOVED***
        ***REMOVED***
        super(LockBase, self***REMOVED***.__init__(path***REMOVED***
        self.lock_file = os.path.abspath(path***REMOVED*** + ".lock"
        self.hostname = socket.gethostname(***REMOVED***
        self.pid = os.getpid(***REMOVED***
        if threaded:
            t = threading.current_thread(***REMOVED***
            # Thread objects in Python 2.4 and earlier do not have ident
            # attrs.  Worm around that.
            ident = getattr(t, "ident", hash(t***REMOVED******REMOVED***
            self.tname = "-%x" % (ident & 0xffffffff***REMOVED***
        else:
            self.tname = ""
        dirname = os.path.dirname(self.lock_file***REMOVED***

        # unique name is mostly about the current process, but must
        # also contain the path -- otherwise, two adjacent locked
        # files conflict (one file gets locked, creating lock-file and
        # unique file, the other one gets locked, creating lock-file
        # and overwriting the already existing lock-file, then one
        # gets unlocked, deleting both lock-file and unique file,
        # finally the last lock errors out upon releasing.
        self.unique_name = os.path.join(dirname,
                                        "%s%s.%s%s" % (self.hostname,
                                                       self.tname,
                                                       self.pid,
                                                       hash(self.path***REMOVED******REMOVED******REMOVED***
        self.timeout = timeout

    def is_locked(self***REMOVED***:
        ***REMOVED***
        Tell whether or not the file is locked.
        ***REMOVED***
        raise NotImplemented("implement in subclass"***REMOVED***

    def i_am_locking(self***REMOVED***:
        ***REMOVED***
        Return True if this object is locking the file.
        ***REMOVED***
        raise NotImplemented("implement in subclass"***REMOVED***

    def break_lock(self***REMOVED***:
        ***REMOVED***
        Remove a lock.  Useful if a locking thread failed to unlock.
        ***REMOVED***
        raise NotImplemented("implement in subclass"***REMOVED***

    def __repr__(self***REMOVED***:
        return "<%s: %r -- %r>" % (self.__class__.__name__, self.unique_name,
                                   self.path***REMOVED***


def _fl_helper(cls, mod, *args, **kwds***REMOVED***:
    warnings.warn("Import from %s module instead of lockfile package" % mod,
                  DeprecationWarning, stacklevel=2***REMOVED***
    # This is a bit funky, but it's only for awhile.  The way the unit tests
    # are constructed this function winds up as an unbound method, so it
    # actually takes three args, not two.  We want to toss out self.
    if not isinstance(args[0***REMOVED***, str***REMOVED***:
        # We are testing, avoid the first arg
        args = args[1:***REMOVED***
    if len(args***REMOVED*** == 1 and not kwds:
        kwds["threaded"***REMOVED*** = True
    return cls(*args, **kwds***REMOVED***


def LinkFileLock(*args, **kwds***REMOVED***:
    ***REMOVED***Factory function provided for backwards compatibility.

    Do not use in new code.  Instead, import LinkLockFile from the
    lockfile.linklockfile module.
    ***REMOVED***
    from . import linklockfile
    return _fl_helper(linklockfile.LinkLockFile, "lockfile.linklockfile",
                      *args, **kwds***REMOVED***


def MkdirFileLock(*args, **kwds***REMOVED***:
    ***REMOVED***Factory function provided for backwards compatibility.

    Do not use in new code.  Instead, import MkdirLockFile from the
    lockfile.mkdirlockfile module.
    ***REMOVED***
    from . import mkdirlockfile
    return _fl_helper(mkdirlockfile.MkdirLockFile, "lockfile.mkdirlockfile",
                      *args, **kwds***REMOVED***


def SQLiteFileLock(*args, **kwds***REMOVED***:
    ***REMOVED***Factory function provided for backwards compatibility.

    Do not use in new code.  Instead, import SQLiteLockFile from the
    lockfile.mkdirlockfile module.
    ***REMOVED***
    from . import sqlitelockfile
    return _fl_helper(sqlitelockfile.SQLiteLockFile, "lockfile.sqlitelockfile",
                      *args, **kwds***REMOVED***


def locked(path, timeout=None***REMOVED***:
    ***REMOVED***Decorator which enables locks for decorated function.

    Arguments:
     - path: path for lockfile.
     - timeout (optional***REMOVED***: Timeout for acquiring lock.

     Usage:
         @locked('/var/run/myname', timeout=0***REMOVED***
         def myname(...***REMOVED***:
             ...
    ***REMOVED***
    def decor(func***REMOVED***:
        @functools.wraps(func***REMOVED***
        def wrapper(*args, **kwargs***REMOVED***:
            lock = FileLock(path, timeout=timeout***REMOVED***
            lock.acquire(***REMOVED***
            ***REMOVED***
                return func(*args, **kwargs***REMOVED***
            finally:
                lock.release(***REMOVED***
        return wrapper
    return decor


if hasattr(os, "link"***REMOVED***:
    from . import linklockfile as _llf
    LockFile = _llf.LinkLockFile
else:
    from . import mkdirlockfile as _mlf
    LockFile = _mlf.MkdirLockFile

FileLock = LockFile
