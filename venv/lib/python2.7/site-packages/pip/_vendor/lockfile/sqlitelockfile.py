from __future__ import absolute_import, division

import time
***REMOVED***

***REMOVED***
    unicode
except NameError:
    unicode = str

from . import LockBase, NotLocked, NotMyLock, LockTimeout, AlreadyLocked


class SQLiteLockFile(LockBase***REMOVED***:
    "Demonstrate SQL-based locking."

    testdb = None

    def __init__(self, path, threaded=True, timeout=None***REMOVED***:
        ***REMOVED***
        >>> lock = SQLiteLockFile('somefile'***REMOVED***
        >>> lock = SQLiteLockFile('somefile', threaded=False***REMOVED***
        ***REMOVED***
        LockBase.__init__(self, path, threaded, timeout***REMOVED***
        self.lock_file = unicode(self.lock_file***REMOVED***
        self.unique_name = unicode(self.unique_name***REMOVED***

        if SQLiteLockFile.testdb is None:
            import tempfile
            _fd, testdb = tempfile.mkstemp(***REMOVED***
            os.close(_fd***REMOVED***
            os.unlink(testdb***REMOVED***
            del _fd, tempfile
            SQLiteLockFile.testdb = testdb

        import sqlite3
        self.connection = sqlite3.connect(SQLiteLockFile.testdb***REMOVED***

        c = self.connection.cursor(***REMOVED***
        ***REMOVED***
            c.execute("create table locks"
                      "("
                      "   lock_file varchar(32***REMOVED***,"
                      "   unique_name varchar(32***REMOVED***"
                      "***REMOVED***"***REMOVED***
        except sqlite3.OperationalError:
            pass
        else:
            self.connection.commit(***REMOVED***
            import atexit
            atexit.register(os.unlink, SQLiteLockFile.testdb***REMOVED***

    def acquire(self, timeout=None***REMOVED***:
        timeout = timeout if timeout is not None else self.timeout
        end_time = time.time(***REMOVED***
        if timeout is not None and timeout > 0:
            end_time += timeout

        if timeout is None:
            wait = 0.1
        elif timeout <= 0:
            wait = 0
        else:
            wait = timeout / 10

        cursor = self.connection.cursor(***REMOVED***

        while True:
            if not self.is_locked(***REMOVED***:
                # Not locked.  Try to lock it.
                cursor.execute("insert into locks"
                               "  (lock_file, unique_name***REMOVED***"
                               "  values"
                               "  (?, ?***REMOVED***",
                               (self.lock_file, self.unique_name***REMOVED******REMOVED***
                self.connection.commit(***REMOVED***

                # Check to see if we are the only lock holder.
                cursor.execute("select * from locks"
                               "  where unique_name = ?",
                               (self.unique_name,***REMOVED******REMOVED***
                rows = cursor.fetchall(***REMOVED***
                if len(rows***REMOVED*** > 1:
                    # Nope.  Someone else got there.  Remove our lock.
                    cursor.execute("delete from locks"
                                   "  where unique_name = ?",
                                   (self.unique_name,***REMOVED******REMOVED***
                    self.connection.commit(***REMOVED***
                else:
                    # Yup.  We're done, so go home.
                    return
            else:
                # Check to see if we are the only lock holder.
                cursor.execute("select * from locks"
                               "  where unique_name = ?",
                               (self.unique_name,***REMOVED******REMOVED***
                rows = cursor.fetchall(***REMOVED***
                if len(rows***REMOVED*** == 1:
                    # We're the locker, so go home.
                    return

            # Maybe we should wait a bit longer.
            if timeout is not None and time.time(***REMOVED*** > end_time:
                if timeout > 0:
                    # No more waiting.
                    raise LockTimeout("Timeout waiting to acquire"
                                      " lock for %s" %
                                      self.path***REMOVED***
                else:
                    # Someone else has the lock and we are impatient..
                    raise AlreadyLocked("%s is already locked" % self.path***REMOVED***

            # Well, okay.  We'll give it a bit longer.
            time.sleep(wait***REMOVED***

    def release(self***REMOVED***:
        if not self.is_locked(***REMOVED***:
            raise NotLocked("%s is not locked" % self.path***REMOVED***
        if not self.i_am_locking(***REMOVED***:
            raise NotMyLock("%s is locked, but not by me (by %s***REMOVED***" %
                            (self.unique_name, self._who_is_locking(***REMOVED******REMOVED******REMOVED***
        cursor = self.connection.cursor(***REMOVED***
        cursor.execute("delete from locks"
                       "  where unique_name = ?",
                       (self.unique_name,***REMOVED******REMOVED***
        self.connection.commit(***REMOVED***

    def _who_is_locking(self***REMOVED***:
        cursor = self.connection.cursor(***REMOVED***
        cursor.execute("select unique_name from locks"
                       "  where lock_file = ?",
                       (self.lock_file,***REMOVED******REMOVED***
        return cursor.fetchone(***REMOVED***[0***REMOVED***

    def is_locked(self***REMOVED***:
        cursor = self.connection.cursor(***REMOVED***
        cursor.execute("select * from locks"
                       "  where lock_file = ?",
                       (self.lock_file,***REMOVED******REMOVED***
        rows = cursor.fetchall(***REMOVED***
        return not not rows

    def i_am_locking(self***REMOVED***:
        cursor = self.connection.cursor(***REMOVED***
        cursor.execute("select * from locks"
                       "  where lock_file = ?"
                       "    and unique_name = ?",
                       (self.lock_file, self.unique_name***REMOVED******REMOVED***
        return not not cursor.fetchall(***REMOVED***

    def break_lock(self***REMOVED***:
        cursor = self.connection.cursor(***REMOVED***
        cursor.execute("delete from locks"
                       "  where lock_file = ?",
                       (self.lock_file,***REMOVED******REMOVED***
        self.connection.commit(***REMOVED***
