from __future__ import absolute_import

***REMOVED***
import time

from . import (LockBase, NotLocked, NotMyLock, LockTimeout,
               AlreadyLocked***REMOVED***


class SymlinkLockFile(LockBase***REMOVED***:
    ***REMOVED***Lock access to a file using symlink(2***REMOVED***.***REMOVED***

    def __init__(self, path, threaded=True, timeout=None***REMOVED***:
        # super(SymlinkLockFile***REMOVED***.__init(...***REMOVED***
        LockBase.__init__(self, path, threaded, timeout***REMOVED***
        # split it back!
        self.unique_name = os.path.split(self.unique_name***REMOVED***[1***REMOVED***

    def acquire(self, timeout=None***REMOVED***:
        # Hopefully unnecessary for symlink.
        # ***REMOVED***
        #     open(self.unique_name, "wb"***REMOVED***.close(***REMOVED***
        # except IOError:
        #     raise LockFailed("failed to create %s" % self.unique_name***REMOVED***
        timeout = timeout if timeout is not None else self.timeout
        end_time = time.time(***REMOVED***
        if timeout is not None and timeout > 0:
            end_time += timeout

        while True:
            # Try and create a symbolic link to it.
            ***REMOVED***
                os.symlink(self.unique_name, self.lock_file***REMOVED***
            except OSError:
                # Link creation failed.  Maybe we've double-locked?
                if self.i_am_locking(***REMOVED***:
                    # Linked to out unique name. Proceed.
                    return
                else:
                    # Otherwise the lock creation failed.
                    if timeout is not None and time.time(***REMOVED*** > end_time:
                        if timeout > 0:
                            raise LockTimeout("Timeout waiting to acquire"
                                              " lock for %s" %
                                              self.path***REMOVED***
                        else:
                            raise AlreadyLocked("%s is already locked" %
                                                self.path***REMOVED***
                    time.sleep(timeout / 10 if timeout is not None else 0.1***REMOVED***
            else:
                # Link creation succeeded.  We're good to go.
                return

    def release(self***REMOVED***:
        if not self.is_locked(***REMOVED***:
            raise NotLocked("%s is not locked" % self.path***REMOVED***
        elif not self.i_am_locking(***REMOVED***:
            raise NotMyLock("%s is locked, but not by me" % self.path***REMOVED***
        os.unlink(self.lock_file***REMOVED***

    def is_locked(self***REMOVED***:
        return os.path.islink(self.lock_file***REMOVED***

    def i_am_locking(self***REMOVED***:
        return (os.path.islink(self.lock_file***REMOVED***
                and os.readlink(self.lock_file***REMOVED*** == self.unique_name***REMOVED***

    def break_lock(self***REMOVED***:
        if os.path.islink(self.lock_file***REMOVED***:  # exists && link
            os.unlink(self.lock_file***REMOVED***
