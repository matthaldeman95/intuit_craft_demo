# This file is dual licensed under the terms of the Apache License, Version
# 2.0, and the BSD License. See the LICENSE file in the root of this repository
# for complete details.
from __future__ import absolute_import, division, print_function

import collections
import itertools
import re

from ._structures import Infinity


__all__ = [
    "parse", "Version", "LegacyVersion", "InvalidVersion", "VERSION_PATTERN"
***REMOVED***


_Version = collections.namedtuple(
    "_Version",
    ["epoch", "release", "dev", "pre", "post", "local"***REMOVED***,
***REMOVED***


def parse(version***REMOVED***:
    ***REMOVED***
    Parse the given version string and return either a :class:`Version` object
    or a :class:`LegacyVersion` object depending on if the given version is
    a valid PEP 440 version or a legacy version.
    ***REMOVED***
    ***REMOVED***
        return Version(version***REMOVED***
    except InvalidVersion:
        return LegacyVersion(version***REMOVED***


class InvalidVersion(ValueError***REMOVED***:
    ***REMOVED***
    An invalid version was found, users should refer to PEP 440.
    ***REMOVED***


class _BaseVersion(object***REMOVED***:

    def __hash__(self***REMOVED***:
        return hash(self._key***REMOVED***

    def __lt__(self, other***REMOVED***:
        return self._compare(other, lambda s, o: s < o***REMOVED***

    def __le__(self, other***REMOVED***:
        return self._compare(other, lambda s, o: s <= o***REMOVED***

    def __eq__(self, other***REMOVED***:
        return self._compare(other, lambda s, o: s == o***REMOVED***

    def __ge__(self, other***REMOVED***:
        return self._compare(other, lambda s, o: s >= o***REMOVED***

    def __gt__(self, other***REMOVED***:
        return self._compare(other, lambda s, o: s > o***REMOVED***

    def __ne__(self, other***REMOVED***:
        return self._compare(other, lambda s, o: s != o***REMOVED***

    def _compare(self, other, method***REMOVED***:
        if not isinstance(other, _BaseVersion***REMOVED***:
            return NotImplemented

        return method(self._key, other._key***REMOVED***


class LegacyVersion(_BaseVersion***REMOVED***:

    def __init__(self, version***REMOVED***:
        self._version = str(version***REMOVED***
        self._key = _legacy_cmpkey(self._version***REMOVED***

    def __str__(self***REMOVED***:
        return self._version

    def __repr__(self***REMOVED***:
        return "<LegacyVersion({0***REMOVED******REMOVED***>".format(repr(str(self***REMOVED******REMOVED******REMOVED***

    @property
    def public(self***REMOVED***:
        return self._version

    @property
    def base_version(self***REMOVED***:
        return self._version

    @property
    def local(self***REMOVED***:
        return None

    @property
    def is_prerelease(self***REMOVED***:
        return False

    @property
    def is_postrelease(self***REMOVED***:
        return False


_legacy_version_component_re = re.compile(
    r"(\d+ | [a-z***REMOVED***+ | \.| -***REMOVED***", re.VERBOSE,
***REMOVED***

_legacy_version_replacement_map = {
    "pre": "c", "preview": "c", "-": "final-", "rc": "c", "dev": "@",
***REMOVED***


def _parse_version_parts(s***REMOVED***:
    for part in _legacy_version_component_re.split(s***REMOVED***:
        part = _legacy_version_replacement_map.get(part, part***REMOVED***

        if not part or part == ".":
            continue

        if part[:1***REMOVED*** in "0123456789":
            # pad for numeric comparison
            yield part.zfill(8***REMOVED***
        else:
            yield "*" + part

    # ensure that alpha/beta/candidate are before final
    yield "*final"


def _legacy_cmpkey(version***REMOVED***:
    # We hardcode an epoch of -1 here. A PEP 440 version can only have a epoch
    # greater than or equal to 0. This will effectively put the LegacyVersion,
    # which uses the defacto standard originally implemented by setuptools,
    # as before all PEP 440 versions.
    epoch = -1

    # This scheme is taken from pkg_resources.parse_version setuptools prior to
    # it's adoption of the packaging library.
    parts = [***REMOVED***
    for part in _parse_version_parts(version.lower(***REMOVED******REMOVED***:
        if part.startswith("*"***REMOVED***:
            # remove "-" before a prerelease tag
            if part < "*final":
                while parts and parts[-1***REMOVED*** == "*final-":
                    parts.pop(***REMOVED***

            # remove trailing zeros from each series of numeric parts
            while parts and parts[-1***REMOVED*** == "00000000":
                parts.pop(***REMOVED***

        parts.append(part***REMOVED***
    parts = tuple(parts***REMOVED***

    return epoch, parts

# Deliberately not anchored to the start and end of the string, to make it
# easier for 3rd party code to reuse
VERSION_PATTERN = r***REMOVED***
    v?
    (?:
        (?:(?P<epoch>[0-9***REMOVED***+***REMOVED***!***REMOVED***?                           # epoch
        (?P<release>[0-9***REMOVED***+(?:\.[0-9***REMOVED***+***REMOVED*******REMOVED***                  # release segment
        (?P<pre>                                          # pre-release
            [-_\.***REMOVED***?
            (?P<pre_l>(a|b|c|rc|alpha|beta|pre|preview***REMOVED******REMOVED***
            [-_\.***REMOVED***?
            (?P<pre_n>[0-9***REMOVED***+***REMOVED***?
        ***REMOVED***?
        (?P<post>                                         # post release
            (?:-(?P<post_n1>[0-9***REMOVED***+***REMOVED******REMOVED***
            |
            (?:
                [-_\.***REMOVED***?
                (?P<post_l>post|rev|r***REMOVED***
                [-_\.***REMOVED***?
                (?P<post_n2>[0-9***REMOVED***+***REMOVED***?
            ***REMOVED***
        ***REMOVED***?
        (?P<dev>                                          # dev release
            [-_\.***REMOVED***?
            (?P<dev_l>dev***REMOVED***
            [-_\.***REMOVED***?
            (?P<dev_n>[0-9***REMOVED***+***REMOVED***?
        ***REMOVED***?
    ***REMOVED***
    (?:\+(?P<local>[a-z0-9***REMOVED***+(?:[-_\.***REMOVED***[a-z0-9***REMOVED***+***REMOVED*******REMOVED******REMOVED***?       # local version
***REMOVED***


class Version(_BaseVersion***REMOVED***:

    _regex = re.compile(
        r"^\s*" + VERSION_PATTERN + r"\s*$",
        re.VERBOSE | re.IGNORECASE,
    ***REMOVED***

    def __init__(self, version***REMOVED***:
        # Validate the version and parse it into pieces
        match = self._regex.search(version***REMOVED***
        if not match:
            raise InvalidVersion("Invalid version: '{0***REMOVED***'".format(version***REMOVED******REMOVED***

        # Store the parsed out pieces of the version
        self._version = _Version(
            epoch=int(match.group("epoch"***REMOVED******REMOVED*** if match.group("epoch"***REMOVED*** else 0,
            release=tuple(int(i***REMOVED*** for i in match.group("release"***REMOVED***.split("."***REMOVED******REMOVED***,
            pre=_parse_letter_version(
                match.group("pre_l"***REMOVED***,
                match.group("pre_n"***REMOVED***,
            ***REMOVED***,
            post=_parse_letter_version(
                match.group("post_l"***REMOVED***,
                match.group("post_n1"***REMOVED*** or match.group("post_n2"***REMOVED***,
            ***REMOVED***,
            dev=_parse_letter_version(
                match.group("dev_l"***REMOVED***,
                match.group("dev_n"***REMOVED***,
            ***REMOVED***,
            local=_parse_local_version(match.group("local"***REMOVED******REMOVED***,
        ***REMOVED***

        # Generate a key which will be used for sorting
        self._key = _cmpkey(
            self._version.epoch,
            self._version.release,
            self._version.pre,
            self._version.post,
            self._version.dev,
            self._version.local,
        ***REMOVED***

    def __repr__(self***REMOVED***:
        return "<Version({0***REMOVED******REMOVED***>".format(repr(str(self***REMOVED******REMOVED******REMOVED***

    def __str__(self***REMOVED***:
        parts = [***REMOVED***

        # Epoch
        if self._version.epoch != 0:
            parts.append("{0***REMOVED***!".format(self._version.epoch***REMOVED******REMOVED***

        # Release segment
        parts.append(".".join(str(x***REMOVED*** for x in self._version.release***REMOVED******REMOVED***

        # Pre-release
        if self._version.pre is not None:
            parts.append("".join(str(x***REMOVED*** for x in self._version.pre***REMOVED******REMOVED***

        # Post-release
        if self._version.post is not None:
            parts.append(".post{0***REMOVED***".format(self._version.post[1***REMOVED******REMOVED******REMOVED***

        # Development release
        if self._version.dev is not None:
            parts.append(".dev{0***REMOVED***".format(self._version.dev[1***REMOVED******REMOVED******REMOVED***

        # Local version segment
        if self._version.local is not None:
            parts.append(
                "+{0***REMOVED***".format(".".join(str(x***REMOVED*** for x in self._version.local***REMOVED******REMOVED***
            ***REMOVED***

        return "".join(parts***REMOVED***

    @property
    def public(self***REMOVED***:
        return str(self***REMOVED***.split("+", 1***REMOVED***[0***REMOVED***

    @property
    def base_version(self***REMOVED***:
        parts = [***REMOVED***

        # Epoch
        if self._version.epoch != 0:
            parts.append("{0***REMOVED***!".format(self._version.epoch***REMOVED******REMOVED***

        # Release segment
        parts.append(".".join(str(x***REMOVED*** for x in self._version.release***REMOVED******REMOVED***

        return "".join(parts***REMOVED***

    @property
    def local(self***REMOVED***:
        version_string = str(self***REMOVED***
        if "+" in version_string:
            return version_string.split("+", 1***REMOVED***[1***REMOVED***

    @property
    def is_prerelease(self***REMOVED***:
        return bool(self._version.dev or self._version.pre***REMOVED***

    @property
    def is_postrelease(self***REMOVED***:
        return bool(self._version.post***REMOVED***


def _parse_letter_version(letter, number***REMOVED***:
    if letter:
        # We consider there to be an implicit 0 in a pre-release if there is
        # not a numeral associated with it.
        if number is None:
            number = 0

        # We normalize any letters to their lower case form
        letter = letter.lower(***REMOVED***

        # We consider some words to be alternate spellings of other words and
        # in those cases we want to normalize the spellings to our preferred
        # spelling.
        if letter == "alpha":
            letter = "a"
        elif letter == "beta":
            letter = "b"
        elif letter in ["c", "pre", "preview"***REMOVED***:
            letter = "rc"
        elif letter in ["rev", "r"***REMOVED***:
            letter = "post"

        return letter, int(number***REMOVED***
    if not letter and number:
        # We assume if we are given a number, but we are not given a letter
        # then this is using the implicit post release syntax (e.g. 1.0-1***REMOVED***
        letter = "post"

        return letter, int(number***REMOVED***


_local_version_seperators = re.compile(r"[\._-***REMOVED***"***REMOVED***


def _parse_local_version(local***REMOVED***:
    ***REMOVED***
    Takes a string like abc.1.twelve and turns it into ("abc", 1, "twelve"***REMOVED***.
    ***REMOVED***
    if local is not None:
        return tuple(
            part.lower(***REMOVED*** if not part.isdigit(***REMOVED*** else int(part***REMOVED***
            for part in _local_version_seperators.split(local***REMOVED***
        ***REMOVED***


def _cmpkey(epoch, release, pre, post, dev, local***REMOVED***:
    # When we compare a release version, we want to compare it with all of the
    # trailing zeros removed. So we'll use a reverse the list, drop all the now
    # leading zeros until we come to something non zero, then take the rest
    # re-reverse it back into the correct order and make it a tuple and use
    # that for our sorting key.
    release = tuple(
        reversed(list(
            itertools.dropwhile(
                lambda x: x == 0,
                reversed(release***REMOVED***,
            ***REMOVED***
        ***REMOVED******REMOVED***
    ***REMOVED***

    # We need to "trick" the sorting algorithm to put 1.0.dev0 before 1.0a0.
    # We'll do this by abusing the pre segment, but we _only_ want to do this
    # if there is not a pre or a post segment. If we have one of those then
    # the normal sorting rules will handle this case correctly.
    if pre is None and post is None and dev is not None:
        pre = -Infinity
    # Versions without a pre-release (except as noted above***REMOVED*** should sort after
    # those with one.
    elif pre is None:
        pre = Infinity

    # Versions without a post segment should sort before those with one.
    if post is None:
        post = -Infinity

    # Versions without a development segment should sort after those with one.
    if dev is None:
        dev = Infinity

    if local is None:
        # Versions without a local segment should sort before those with one.
        local = -Infinity
    else:
        # Versions with a local segment need that segment parsed to implement
        # the sorting rules in PEP440.
        # - Alpha numeric segments sort before numeric segments
        # - Alpha numeric segments sort lexicographically
        # - Numeric segments sort numerically
        # - Shorter versions sort before longer versions when the prefixes
        #   match exactly
        local = tuple(
            (i, ""***REMOVED*** if isinstance(i, int***REMOVED*** else (-Infinity, i***REMOVED***
            for i in local
        ***REMOVED***

    return epoch, release, pre, post, dev, local
