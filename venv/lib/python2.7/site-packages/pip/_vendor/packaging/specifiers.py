# This file is dual licensed under the terms of the Apache License, Version
# 2.0, and the BSD License. See the LICENSE file in the root of this repository
# for complete details.
from __future__ import absolute_import, division, print_function

import abc
import functools
import itertools
import re

from ._compat import string_types, with_metaclass
from .version import Version, LegacyVersion, parse


class InvalidSpecifier(ValueError***REMOVED***:
    ***REMOVED***
    An invalid specifier was found, users should refer to PEP 440.
    ***REMOVED***


class BaseSpecifier(with_metaclass(abc.ABCMeta, object***REMOVED******REMOVED***:

    @abc.abstractmethod
    def __str__(self***REMOVED***:
        ***REMOVED***
        Returns the str representation of this Specifier like object. This
        should be representative of the Specifier itself.
        ***REMOVED***

    @abc.abstractmethod
    def __hash__(self***REMOVED***:
        ***REMOVED***
        Returns a hash value for this Specifier like object.
        ***REMOVED***

    @abc.abstractmethod
    def __eq__(self, other***REMOVED***:
        ***REMOVED***
        Returns a boolean representing whether or not the two Specifier like
        objects are equal.
        ***REMOVED***

    @abc.abstractmethod
    def __ne__(self, other***REMOVED***:
        ***REMOVED***
        Returns a boolean representing whether or not the two Specifier like
        objects are not equal.
        ***REMOVED***

    @abc.abstractproperty
    def prereleases(self***REMOVED***:
        ***REMOVED***
        Returns whether or not pre-releases as a whole are allowed by this
        specifier.
        ***REMOVED***

    @prereleases.setter
    def prereleases(self, value***REMOVED***:
        ***REMOVED***
        Sets whether or not pre-releases as a whole are allowed by this
        specifier.
        ***REMOVED***

    @abc.abstractmethod
    def contains(self, item, prereleases=None***REMOVED***:
        ***REMOVED***
        Determines if the given item is contained within this specifier.
        ***REMOVED***

    @abc.abstractmethod
    def filter(self, iterable, prereleases=None***REMOVED***:
        ***REMOVED***
        Takes an iterable of items and filters them so that only items which
        are contained within this specifier are allowed in it.
        ***REMOVED***


class _IndividualSpecifier(BaseSpecifier***REMOVED***:

    _operators = {***REMOVED***

    def __init__(self, spec="", prereleases=None***REMOVED***:
        match = self._regex.search(spec***REMOVED***
        if not match:
            raise InvalidSpecifier("Invalid specifier: '{0***REMOVED***'".format(spec***REMOVED******REMOVED***

        self._spec = (
            match.group("operator"***REMOVED***.strip(***REMOVED***,
            match.group("version"***REMOVED***.strip(***REMOVED***,
        ***REMOVED***

        # Store whether or not this Specifier should accept prereleases
        self._prereleases = prereleases

    def __repr__(self***REMOVED***:
        pre = (
            ", prereleases={0!r***REMOVED***".format(self.prereleases***REMOVED***
            if self._prereleases is not None
            else ""
        ***REMOVED***

        return "<{0***REMOVED***({1!r***REMOVED***{2***REMOVED******REMOVED***>".format(
            self.__class__.__name__,
            str(self***REMOVED***,
            pre,
        ***REMOVED***

    def __str__(self***REMOVED***:
        return "{0***REMOVED***{1***REMOVED***".format(*self._spec***REMOVED***

    def __hash__(self***REMOVED***:
        return hash(self._spec***REMOVED***

    def __eq__(self, other***REMOVED***:
        if isinstance(other, string_types***REMOVED***:
            ***REMOVED***
                other = self.__class__(other***REMOVED***
            except InvalidSpecifier:
                return NotImplemented
        elif not isinstance(other, self.__class__***REMOVED***:
            return NotImplemented

        return self._spec == other._spec

    def __ne__(self, other***REMOVED***:
        if isinstance(other, string_types***REMOVED***:
            ***REMOVED***
                other = self.__class__(other***REMOVED***
            except InvalidSpecifier:
                return NotImplemented
        elif not isinstance(other, self.__class__***REMOVED***:
            return NotImplemented

        return self._spec != other._spec

    def _get_operator(self, op***REMOVED***:
        return getattr(self, "_compare_{0***REMOVED***".format(self._operators[op***REMOVED******REMOVED******REMOVED***

    def _coerce_version(self, version***REMOVED***:
        if not isinstance(version, (LegacyVersion, Version***REMOVED******REMOVED***:
            version = parse(version***REMOVED***
        return version

    @property
    def operator(self***REMOVED***:
        return self._spec[0***REMOVED***

    @property
    def version(self***REMOVED***:
        return self._spec[1***REMOVED***

    @property
    def prereleases(self***REMOVED***:
        return self._prereleases

    @prereleases.setter
    def prereleases(self, value***REMOVED***:
        self._prereleases = value

    def __contains__(self, item***REMOVED***:
        return self.contains(item***REMOVED***

    def contains(self, item, prereleases=None***REMOVED***:
        # Determine if prereleases are to be allowed or not.
        if prereleases is None:
            prereleases = self.prereleases

        # Normalize item to a Version or LegacyVersion, this allows us to have
        # a shortcut for ``"2.0" in Specifier(">=2"***REMOVED***
        item = self._coerce_version(item***REMOVED***

        # Determine if we should be supporting prereleases in this specifier
        # or not, if we do not support prereleases than we can short circuit
        # logic if this version is a prereleases.
        if item.is_prerelease and not prereleases:
            return False

        # Actually do the comparison to determine if this item is contained
        # within this Specifier or not.
        return self._get_operator(self.operator***REMOVED***(item, self.version***REMOVED***

    def filter(self, iterable, prereleases=None***REMOVED***:
        yielded = False
        found_prereleases = [***REMOVED***

        kw = {"prereleases": prereleases if prereleases is not None else True***REMOVED***

        # Attempt to iterate over all the values in the iterable and if any of
        # them match, yield them.
        for version in iterable:
            parsed_version = self._coerce_version(version***REMOVED***

            if self.contains(parsed_version, **kw***REMOVED***:
                # If our version is a prerelease, and we were not set to allow
                # prereleases, then we'll store it for later incase nothing
                # else matches this specifier.
                if (parsed_version.is_prerelease and not
                        (prereleases or self.prereleases***REMOVED******REMOVED***:
                    found_prereleases.append(version***REMOVED***
                # Either this is not a prerelease, or we should have been
                # accepting prereleases from the begining.
                else:
                    yielded = True
                    yield version

        # Now that we've iterated over everything, determine if we've yielded
        # any values, and if we have not and we have any prereleases stored up
        # then we will go ahead and yield the prereleases.
        if not yielded and found_prereleases:
            for version in found_prereleases:
                yield version


class LegacySpecifier(_IndividualSpecifier***REMOVED***:

    _regex_str = (
        r***REMOVED***
        (?P<operator>(==|!=|<=|>=|<|>***REMOVED******REMOVED***
        \s*
        (?P<version>
            [^,;\s***REMOVED******REMOVED**** # Since this is a "legacy" specifier, and the version
                      # string can be just about anything, we match everything
                      # except for whitespace, a semi-colon for marker support,
                      # a closing paren since versions can be enclosed in
                      # them, and a comma since it's a version separator.
        ***REMOVED***
        ***REMOVED***
    ***REMOVED***

    _regex = re.compile(
        r"^\s*" + _regex_str + r"\s*$", re.VERBOSE | re.IGNORECASE***REMOVED***

    _operators = {
        "==": "equal",
        "!=": "not_equal",
        "<=": "less_than_equal",
        ">=": "greater_than_equal",
        "<": "less_than",
        ">": "greater_than",
***REMOVED***

    def _coerce_version(self, version***REMOVED***:
        if not isinstance(version, LegacyVersion***REMOVED***:
            version = LegacyVersion(str(version***REMOVED******REMOVED***
        return version

    def _compare_equal(self, prospective, spec***REMOVED***:
        return prospective == self._coerce_version(spec***REMOVED***

    def _compare_not_equal(self, prospective, spec***REMOVED***:
        return prospective != self._coerce_version(spec***REMOVED***

    def _compare_less_than_equal(self, prospective, spec***REMOVED***:
        return prospective <= self._coerce_version(spec***REMOVED***

    def _compare_greater_than_equal(self, prospective, spec***REMOVED***:
        return prospective >= self._coerce_version(spec***REMOVED***

    def _compare_less_than(self, prospective, spec***REMOVED***:
        return prospective < self._coerce_version(spec***REMOVED***

    def _compare_greater_than(self, prospective, spec***REMOVED***:
        return prospective > self._coerce_version(spec***REMOVED***


def _require_version_compare(fn***REMOVED***:
    @functools.wraps(fn***REMOVED***
    def wrapped(self, prospective, spec***REMOVED***:
        if not isinstance(prospective, Version***REMOVED***:
            return False
        return fn(self, prospective, spec***REMOVED***
    return wrapped


class Specifier(_IndividualSpecifier***REMOVED***:

    _regex_str = (
        r***REMOVED***
        (?P<operator>(~=|==|!=|<=|>=|<|>|===***REMOVED******REMOVED***
        (?P<version>
            (?:
                # The identity operators allow for an escape hatch that will
                # do an exact string match of the version you wish to install.
                # This will not be parsed by PEP 440 and we cannot determine
                # any semantic meaning from it. This operator is discouraged
                # but included entirely as an escape hatch.
                (?<====***REMOVED***  # Only match for the identity operator
                \s*
                [^\s***REMOVED****    # We just match everything, except for whitespace
                          # since we are only testing for strict identity.
            ***REMOVED***
            |
            (?:
                # The (non***REMOVED***equality operators allow for wild card and local
                # versions to be specified so we have to define these two
                # operators separately to enable that.
                (?<===|!=***REMOVED***            # Only match for equals and not equals

                \s*
                v?
                (?:[0-9***REMOVED***+!***REMOVED***?          # epoch
                [0-9***REMOVED***+(?:\.[0-9***REMOVED***+***REMOVED****   # release
                (?:                   # pre release
                    [-_\.***REMOVED***?
                    (a|b|c|rc|alpha|beta|pre|preview***REMOVED***
                    [-_\.***REMOVED***?
                    [0-9***REMOVED****
                ***REMOVED***?
                (?:                   # post release
                    (?:-[0-9***REMOVED***+***REMOVED***|(?:[-_\.***REMOVED***?(post|rev|r***REMOVED***[-_\.***REMOVED***?[0-9***REMOVED*******REMOVED***
                ***REMOVED***?

                # You cannot use a wild card and a dev or local version
                # together so group them with a | and make them optional.
                (?:
                    (?:[-_\.***REMOVED***?dev[-_\.***REMOVED***?[0-9***REMOVED*******REMOVED***?         # dev release
                    (?:\+[a-z0-9***REMOVED***+(?:[-_\.***REMOVED***[a-z0-9***REMOVED***+***REMOVED*******REMOVED***? # local
                    |
                    \.\*  # Wild card syntax of .*
                ***REMOVED***?
            ***REMOVED***
            |
            (?:
                # The compatible operator requires at least two digits in the
                # release segment.
                (?<=~=***REMOVED***               # Only match for the compatible operator

                \s*
                v?
                (?:[0-9***REMOVED***+!***REMOVED***?          # epoch
                [0-9***REMOVED***+(?:\.[0-9***REMOVED***+***REMOVED***+   # release  (We have a + instead of a ****REMOVED***
                (?:                   # pre release
                    [-_\.***REMOVED***?
                    (a|b|c|rc|alpha|beta|pre|preview***REMOVED***
                    [-_\.***REMOVED***?
                    [0-9***REMOVED****
                ***REMOVED***?
                (?:                                   # post release
                    (?:-[0-9***REMOVED***+***REMOVED***|(?:[-_\.***REMOVED***?(post|rev|r***REMOVED***[-_\.***REMOVED***?[0-9***REMOVED*******REMOVED***
                ***REMOVED***?
                (?:[-_\.***REMOVED***?dev[-_\.***REMOVED***?[0-9***REMOVED*******REMOVED***?          # dev release
            ***REMOVED***
            |
            (?:
                # All other operators only allow a sub set of what the
                # (non***REMOVED***equality operators do. Specifically they do not allow
                # local versions to be specified nor do they allow the prefix
                # matching wild cards.
                (?<!==|!=|~=***REMOVED***         # We have special cases for these
                                      # operators so we want to make sure they
                                      # don't match here.

                \s*
                v?
                (?:[0-9***REMOVED***+!***REMOVED***?          # epoch
                [0-9***REMOVED***+(?:\.[0-9***REMOVED***+***REMOVED****   # release
                (?:                   # pre release
                    [-_\.***REMOVED***?
                    (a|b|c|rc|alpha|beta|pre|preview***REMOVED***
                    [-_\.***REMOVED***?
                    [0-9***REMOVED****
                ***REMOVED***?
                (?:                                   # post release
                    (?:-[0-9***REMOVED***+***REMOVED***|(?:[-_\.***REMOVED***?(post|rev|r***REMOVED***[-_\.***REMOVED***?[0-9***REMOVED*******REMOVED***
                ***REMOVED***?
                (?:[-_\.***REMOVED***?dev[-_\.***REMOVED***?[0-9***REMOVED*******REMOVED***?          # dev release
            ***REMOVED***
        ***REMOVED***
        ***REMOVED***
    ***REMOVED***

    _regex = re.compile(
        r"^\s*" + _regex_str + r"\s*$", re.VERBOSE | re.IGNORECASE***REMOVED***

    _operators = {
        "~=": "compatible",
        "==": "equal",
        "!=": "not_equal",
        "<=": "less_than_equal",
        ">=": "greater_than_equal",
        "<": "less_than",
        ">": "greater_than",
        "===": "arbitrary",
***REMOVED***

    @_require_version_compare
    def _compare_compatible(self, prospective, spec***REMOVED***:
        # Compatible releases have an equivalent combination of >= and ==. That
        # is that ~=2.2 is equivalent to >=2.2,==2.*. This allows us to
        # implement this in terms of the other specifiers instead of
        # implementing it ourselves. The only thing we need to do is construct
        # the other specifiers.

        # We want everything but the last item in the version, but we want to
        # ignore post and dev releases and we want to treat the pre-release as
        # it's own separate segment.
        prefix = ".".join(
            list(
                itertools.takewhile(
                    lambda x: (not x.startswith("post"***REMOVED*** and not
                               x.startswith("dev"***REMOVED******REMOVED***,
                    _version_split(spec***REMOVED***,
                ***REMOVED***
            ***REMOVED***[:-1***REMOVED***
        ***REMOVED***

        # Add the prefix notation to the end of our string
        prefix += ".*"

        return (self._get_operator(">="***REMOVED***(prospective, spec***REMOVED*** and
                self._get_operator("=="***REMOVED***(prospective, prefix***REMOVED******REMOVED***

    @_require_version_compare
    def _compare_equal(self, prospective, spec***REMOVED***:
        # We need special logic to handle prefix matching
        if spec.endswith(".*"***REMOVED***:
            # In the case of prefix matching we want to ignore local segment.
            prospective = Version(prospective.public***REMOVED***
            # Split the spec out by dots, and pretend that there is an implicit
            # dot in between a release segment and a pre-release segment.
            spec = _version_split(spec[:-2***REMOVED******REMOVED***  # Remove the trailing .*

            # Split the prospective version out by dots, and pretend that there
            # is an implicit dot in between a release segment and a pre-release
            # segment.
            prospective = _version_split(str(prospective***REMOVED******REMOVED***

            # Shorten the prospective version to be the same length as the spec
            # so that we can determine if the specifier is a prefix of the
            # prospective version or not.
            prospective = prospective[:len(spec***REMOVED******REMOVED***

            # Pad out our two sides with zeros so that they both equal the same
            # length.
            spec, prospective = _pad_version(spec, prospective***REMOVED***
        else:
            # Convert our spec string into a Version
            spec = Version(spec***REMOVED***

            # If the specifier does not have a local segment, then we want to
            # act as if the prospective version also does not have a local
            # segment.
            if not spec.local:
                prospective = Version(prospective.public***REMOVED***

        return prospective == spec

    @_require_version_compare
    def _compare_not_equal(self, prospective, spec***REMOVED***:
        return not self._compare_equal(prospective, spec***REMOVED***

    @_require_version_compare
    def _compare_less_than_equal(self, prospective, spec***REMOVED***:
        return prospective <= Version(spec***REMOVED***

    @_require_version_compare
    def _compare_greater_than_equal(self, prospective, spec***REMOVED***:
        return prospective >= Version(spec***REMOVED***

    @_require_version_compare
    def _compare_less_than(self, prospective, spec***REMOVED***:
        # Convert our spec to a Version instance, since we'll want to work with
        # it as a version.
        spec = Version(spec***REMOVED***

        # Check to see if the prospective version is less than the spec
        # version. If it's not we can short circuit and just return False now
        # instead of doing extra unneeded work.
        if not prospective < spec:
            return False

        # This special case is here so that, unless the specifier itself
        # includes is a pre-release version, that we do not accept pre-release
        # versions for the version mentioned in the specifier (e.g. <3.1 should
        # not match 3.1.dev0, but should match 3.0.dev0***REMOVED***.
        if not spec.is_prerelease and prospective.is_prerelease:
            if Version(prospective.base_version***REMOVED*** == Version(spec.base_version***REMOVED***:
                return False

        # If we've gotten to here, it means that prospective version is both
        # less than the spec version *and* it's not a pre-release of the same
        # version in the spec.
        return True

    @_require_version_compare
    def _compare_greater_than(self, prospective, spec***REMOVED***:
        # Convert our spec to a Version instance, since we'll want to work with
        # it as a version.
        spec = Version(spec***REMOVED***

        # Check to see if the prospective version is greater than the spec
        # version. If it's not we can short circuit and just return False now
        # instead of doing extra unneeded work.
        if not prospective > spec:
            return False

        # This special case is here so that, unless the specifier itself
        # includes is a post-release version, that we do not accept
        # post-release versions for the version mentioned in the specifier
        # (e.g. >3.1 should not match 3.0.post0, but should match 3.2.post0***REMOVED***.
        if not spec.is_postrelease and prospective.is_postrelease:
            if Version(prospective.base_version***REMOVED*** == Version(spec.base_version***REMOVED***:
                return False

        # Ensure that we do not allow a local version of the version mentioned
        # in the specifier, which is techincally greater than, to match.
        if prospective.local is not None:
            if Version(prospective.base_version***REMOVED*** == Version(spec.base_version***REMOVED***:
                return False

        # If we've gotten to here, it means that prospective version is both
        # greater than the spec version *and* it's not a pre-release of the
        # same version in the spec.
        return True

    def _compare_arbitrary(self, prospective, spec***REMOVED***:
        return str(prospective***REMOVED***.lower(***REMOVED*** == str(spec***REMOVED***.lower(***REMOVED***

    @property
    def prereleases(self***REMOVED***:
        # If there is an explicit prereleases set for this, then we'll just
        # blindly use that.
        if self._prereleases is not None:
            return self._prereleases

        # Look at all of our specifiers and determine if they are inclusive
        # operators, and if they are if they are including an explicit
        # prerelease.
        operator, version = self._spec
        if operator in ["==", ">=", "<=", "~=", "==="***REMOVED***:
            # The == specifier can include a trailing .*, if it does we
            # want to remove before parsing.
            if operator == "==" and version.endswith(".*"***REMOVED***:
                version = version[:-2***REMOVED***

            # Parse the version, and if it is a pre-release than this
            # specifier allows pre-releases.
            if parse(version***REMOVED***.is_prerelease:
                return True

        return False

    @prereleases.setter
    def prereleases(self, value***REMOVED***:
        self._prereleases = value


_prefix_regex = re.compile(r"^([0-9***REMOVED***+***REMOVED***((?:a|b|c|rc***REMOVED***[0-9***REMOVED***+***REMOVED***$"***REMOVED***


def _version_split(version***REMOVED***:
    result = [***REMOVED***
    for item in version.split("."***REMOVED***:
        match = _prefix_regex.search(item***REMOVED***
        if match:
            result.extend(match.groups(***REMOVED******REMOVED***
        else:
            result.append(item***REMOVED***
    return result


def _pad_version(left, right***REMOVED***:
    left_split, right_split = [***REMOVED***, [***REMOVED***

    # Get the release segment of our versions
    left_split.append(list(itertools.takewhile(lambda x: x.isdigit(***REMOVED***, left***REMOVED******REMOVED******REMOVED***
    right_split.append(list(itertools.takewhile(lambda x: x.isdigit(***REMOVED***, right***REMOVED******REMOVED******REMOVED***

    # Get the rest of our versions
    left_split.append(left[len(left_split[0***REMOVED******REMOVED***:***REMOVED******REMOVED***
    right_split.append(right[len(right_split[0***REMOVED******REMOVED***:***REMOVED******REMOVED***

    # Insert our padding
    left_split.insert(
        1,
        ["0"***REMOVED*** * max(0, len(right_split[0***REMOVED******REMOVED*** - len(left_split[0***REMOVED******REMOVED******REMOVED***,
    ***REMOVED***
    right_split.insert(
        1,
        ["0"***REMOVED*** * max(0, len(left_split[0***REMOVED******REMOVED*** - len(right_split[0***REMOVED******REMOVED******REMOVED***,
    ***REMOVED***

    return (
        list(itertools.chain(*left_split***REMOVED******REMOVED***,
        list(itertools.chain(*right_split***REMOVED******REMOVED***,
    ***REMOVED***


class SpecifierSet(BaseSpecifier***REMOVED***:

    def __init__(self, specifiers="", prereleases=None***REMOVED***:
        # Split on , to break each indidivual specifier into it's own item, and
        # strip each item to remove leading/trailing whitespace.
        specifiers = [s.strip(***REMOVED*** for s in specifiers.split(","***REMOVED*** if s.strip(***REMOVED******REMOVED***

        # Parsed each individual specifier, attempting first to make it a
        # Specifier and falling back to a LegacySpecifier.
        parsed = set(***REMOVED***
        for specifier in specifiers:
            ***REMOVED***
                parsed.add(Specifier(specifier***REMOVED******REMOVED***
            except InvalidSpecifier:
                parsed.add(LegacySpecifier(specifier***REMOVED******REMOVED***

        # Turn our parsed specifiers into a frozen set and save them for later.
        self._specs = frozenset(parsed***REMOVED***

        # Store our prereleases value so we can use it later to determine if
        # we accept prereleases or not.
        self._prereleases = prereleases

    def __repr__(self***REMOVED***:
        pre = (
            ", prereleases={0!r***REMOVED***".format(self.prereleases***REMOVED***
            if self._prereleases is not None
            else ""
        ***REMOVED***

        return "<SpecifierSet({0!r***REMOVED***{1***REMOVED******REMOVED***>".format(str(self***REMOVED***, pre***REMOVED***

    def __str__(self***REMOVED***:
        return ",".join(sorted(str(s***REMOVED*** for s in self._specs***REMOVED******REMOVED***

    def __hash__(self***REMOVED***:
        return hash(self._specs***REMOVED***

    def __and__(self, other***REMOVED***:
        if isinstance(other, string_types***REMOVED***:
            other = SpecifierSet(other***REMOVED***
        elif not isinstance(other, SpecifierSet***REMOVED***:
            return NotImplemented

        specifier = SpecifierSet(***REMOVED***
        specifier._specs = frozenset(self._specs | other._specs***REMOVED***

        if self._prereleases is None and other._prereleases is not None:
            specifier._prereleases = other._prereleases
        elif self._prereleases is not None and other._prereleases is None:
            specifier._prereleases = self._prereleases
        elif self._prereleases == other._prereleases:
            specifier._prereleases = self._prereleases
        else:
            raise ValueError(
                "Cannot combine SpecifierSets with True and False prerelease "
                "overrides."
            ***REMOVED***

        return specifier

    def __eq__(self, other***REMOVED***:
        if isinstance(other, string_types***REMOVED***:
            other = SpecifierSet(other***REMOVED***
        elif isinstance(other, _IndividualSpecifier***REMOVED***:
            other = SpecifierSet(str(other***REMOVED******REMOVED***
        elif not isinstance(other, SpecifierSet***REMOVED***:
            return NotImplemented

        return self._specs == other._specs

    def __ne__(self, other***REMOVED***:
        if isinstance(other, string_types***REMOVED***:
            other = SpecifierSet(other***REMOVED***
        elif isinstance(other, _IndividualSpecifier***REMOVED***:
            other = SpecifierSet(str(other***REMOVED******REMOVED***
        elif not isinstance(other, SpecifierSet***REMOVED***:
            return NotImplemented

        return self._specs != other._specs

    def __len__(self***REMOVED***:
        return len(self._specs***REMOVED***

    def __iter__(self***REMOVED***:
        return iter(self._specs***REMOVED***

    @property
    def prereleases(self***REMOVED***:
        # If we have been given an explicit prerelease modifier, then we'll
        # pass that through here.
        if self._prereleases is not None:
            return self._prereleases

        # If we don't have any specifiers, and we don't have a forced value,
        # then we'll just return None since we don't know if this should have
        # pre-releases or not.
        if not self._specs:
            return None

        # Otherwise we'll see if any of the given specifiers accept
        # prereleases, if any of them do we'll return True, otherwise False.
        return any(s.prereleases for s in self._specs***REMOVED***

    @prereleases.setter
    def prereleases(self, value***REMOVED***:
        self._prereleases = value

    def __contains__(self, item***REMOVED***:
        return self.contains(item***REMOVED***

    def contains(self, item, prereleases=None***REMOVED***:
        # Ensure that our item is a Version or LegacyVersion instance.
        if not isinstance(item, (LegacyVersion, Version***REMOVED******REMOVED***:
            item = parse(item***REMOVED***

        # Determine if we're forcing a prerelease or not, if we're not forcing
        # one for this particular filter call, then we'll use whatever the
        # SpecifierSet thinks for whether or not we should support prereleases.
        if prereleases is None:
            prereleases = self.prereleases

        # We can determine if we're going to allow pre-releases by looking to
        # see if any of the underlying items supports them. If none of them do
        # and this item is a pre-release then we do not allow it and we can
        # short circuit that here.
        # Note: This means that 1.0.dev1 would not be contained in something
        #       like >=1.0.devabc however it would be in >=1.0.debabc,>0.0.dev0
        if not prereleases and item.is_prerelease:
            return False

        # We simply dispatch to the underlying specs here to make sure that the
        # given version is contained within all of them.
        # Note: This use of all(***REMOVED*** here means that an empty set of specifiers
        #       will always return True, this is an explicit design decision.
        return all(
            s.contains(item, prereleases=prereleases***REMOVED***
            for s in self._specs
        ***REMOVED***

    def filter(self, iterable, prereleases=None***REMOVED***:
        # Determine if we're forcing a prerelease or not, if we're not forcing
        # one for this particular filter call, then we'll use whatever the
        # SpecifierSet thinks for whether or not we should support prereleases.
        if prereleases is None:
            prereleases = self.prereleases

        # If we have any specifiers, then we want to wrap our iterable in the
        # filter method for each one, this will act as a logical AND amongst
        # each specifier.
        if self._specs:
            for spec in self._specs:
                iterable = spec.filter(iterable, prereleases=bool(prereleases***REMOVED******REMOVED***
            return iterable
        # If we do not have any specifiers, then we need to have a rough filter
        # which will filter out any pre-releases, unless there are no final
        # releases, and which will filter out LegacyVersion in general.
        else:
            filtered = [***REMOVED***
            found_prereleases = [***REMOVED***

            for item in iterable:
                # Ensure that we some kind of Version class for this item.
                if not isinstance(item, (LegacyVersion, Version***REMOVED******REMOVED***:
                    parsed_version = parse(item***REMOVED***
                else:
                    parsed_version = item

                # Filter out any item which is parsed as a LegacyVersion
                if isinstance(parsed_version, LegacyVersion***REMOVED***:
                    continue

                # Store any item which is a pre-release for later unless we've
                # already found a final version or we are accepting prereleases
                if parsed_version.is_prerelease and not prereleases:
                    if not filtered:
                        found_prereleases.append(item***REMOVED***
                else:
                    filtered.append(item***REMOVED***

            # If we've found no items except for pre-releases, then we'll go
            # ahead and use the pre-releases
            if not filtered and found_prereleases and prereleases is None:
                return found_prereleases

            return filtered
