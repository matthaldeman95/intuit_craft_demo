'''SSL with SNI_-support for Python 2. Follow these instructions if you would
like to verify SSL certificates in Python 2. Note, the default libraries do
*not* do certificate checking; you need to do additional work to validate
certificates yourself.

This needs the following packages installed:

* pyOpenSSL (tested with 0.13***REMOVED***
* ndg-httpsclient (tested with 0.3.2***REMOVED***
* pyasn1 (tested with 0.1.6***REMOVED***

You can install them with the following command:

    pip install pyopenssl ndg-httpsclient pyasn1

To activate certificate checking, call
:func:`~urllib3.contrib.pyopenssl.inject_into_urllib3` from your Python code
before you begin making HTTP requests. This can be done in a ``sitecustomize``
module, or at any other time before your application begins using ``urllib3``,
like this::

    ***REMOVED***
        import urllib3.contrib.pyopenssl
        urllib3.contrib.pyopenssl.inject_into_urllib3(***REMOVED***
    except ImportError:
        pass

Now you can use :mod:`urllib3` as you normally would, and it will support SNI
when the required modules are installed.

Activating this module also has the positive side effect of disabling SSL/TLS
compression in Python 2 (see `CRIME attack`_***REMOVED***.

If you want to configure the default list of supported cipher suites, you can
set the ``urllib3.contrib.pyopenssl.DEFAULT_SSL_CIPHER_LIST`` variable.

Module Variables
----------------

:var DEFAULT_SSL_CIPHER_LIST: The list of supported SSL/TLS cipher suites.

.. _sni: https://en.wikipedia.org/wiki/Server_Name_Indication
.. _crime attack: https://en.wikipedia.org/wiki/CRIME_(security_exploit***REMOVED***

'''
from __future__ import absolute_import

***REMOVED***
    from ndg.httpsclient.ssl_peer_verification import SUBJ_ALT_NAME_SUPPORT
    from ndg.httpsclient.subj_alt_name import SubjectAltName as BaseSubjectAltName
except SyntaxError as e:
    raise ImportError(e***REMOVED***

import OpenSSL.SSL
from pyasn1.codec.der import decoder as der_decoder
from pyasn1.type import univ, constraint
from socket import timeout, error as SocketError

***REMOVED***  # Platform-specific: Python 2
    from socket import _fileobject
except ImportError:  # Platform-specific: Python 3
    _fileobject = None
    from urllib3.packages.backports.makefile import backport_makefile

import ssl
import select
import six

from .. import connection
from .. import util

__all__ = ['inject_into_urllib3', 'extract_from_urllib3'***REMOVED***

# SNI only *really* works if we can read the subjectAltName of certificates.
HAS_SNI = SUBJ_ALT_NAME_SUPPORT

# Map from urllib3 to PyOpenSSL compatible parameter-values.
_openssl_versions = {
    ssl.PROTOCOL_SSLv23: OpenSSL.SSL.SSLv23_METHOD,
    ssl.PROTOCOL_TLSv1: OpenSSL.SSL.TLSv1_METHOD,
***REMOVED***

if hasattr(ssl, 'PROTOCOL_TLSv1_1'***REMOVED*** and hasattr(OpenSSL.SSL, 'TLSv1_1_METHOD'***REMOVED***:
    _openssl_versions[ssl.PROTOCOL_TLSv1_1***REMOVED*** = OpenSSL.SSL.TLSv1_1_METHOD

if hasattr(ssl, 'PROTOCOL_TLSv1_2'***REMOVED*** and hasattr(OpenSSL.SSL, 'TLSv1_2_METHOD'***REMOVED***:
    _openssl_versions[ssl.PROTOCOL_TLSv1_2***REMOVED*** = OpenSSL.SSL.TLSv1_2_METHOD

***REMOVED***
    _openssl_versions.update({ssl.PROTOCOL_SSLv3: OpenSSL.SSL.SSLv3_METHOD***REMOVED******REMOVED***
except AttributeError:
    pass

_openssl_verify = {
    ssl.CERT_NONE: OpenSSL.SSL.VERIFY_NONE,
    ssl.CERT_OPTIONAL: OpenSSL.SSL.VERIFY_PEER,
    ssl.CERT_REQUIRED:
        OpenSSL.SSL.VERIFY_PEER + OpenSSL.SSL.VERIFY_FAIL_IF_NO_PEER_CERT,
***REMOVED***

DEFAULT_SSL_CIPHER_LIST = util.ssl_.DEFAULT_CIPHERS.encode('ascii'***REMOVED***

# OpenSSL will only write 16K at a time
SSL_WRITE_BLOCKSIZE = 16384

orig_util_HAS_SNI = util.HAS_SNI
orig_connection_ssl_wrap_socket = connection.ssl_wrap_socket


def inject_into_urllib3(***REMOVED***:
    'Monkey-patch urllib3 with PyOpenSSL-backed SSL-support.'

    connection.ssl_wrap_socket = ssl_wrap_socket
    util.HAS_SNI = HAS_SNI
    util.IS_PYOPENSSL = True


def extract_from_urllib3(***REMOVED***:
    'Undo monkey-patching by :func:`inject_into_urllib3`.'

    connection.ssl_wrap_socket = orig_connection_ssl_wrap_socket
    util.HAS_SNI = orig_util_HAS_SNI
    util.IS_PYOPENSSL = False


# Note: This is a slightly bug-fixed version of same from ndg-httpsclient.
class SubjectAltName(BaseSubjectAltName***REMOVED***:
    '''ASN.1 implementation for subjectAltNames support'''

    # There is no limit to how many SAN certificates a certificate may have,
    #   however this needs to have some limit so we'll set an arbitrarily high
    #   limit.
    sizeSpec = univ.SequenceOf.sizeSpec + \
        constraint.ValueSizeConstraint(1, 1024***REMOVED***


# Note: This is a slightly bug-fixed version of same from ndg-httpsclient.
def get_subj_alt_name(peer_cert***REMOVED***:
    # Search through extensions
    dns_name = [***REMOVED***
    if not SUBJ_ALT_NAME_SUPPORT:
        return dns_name

    general_names = SubjectAltName(***REMOVED***
    for i in range(peer_cert.get_extension_count(***REMOVED******REMOVED***:
        ext = peer_cert.get_extension(i***REMOVED***
        ext_name = ext.get_short_name(***REMOVED***
        if ext_name != b'subjectAltName':
            continue

        # PyOpenSSL returns extension data in ASN.1 encoded form
        ext_dat = ext.get_data(***REMOVED***
        decoded_dat = der_decoder.decode(ext_dat,
                                         asn1Spec=general_names***REMOVED***

        for name in decoded_dat:
            if not isinstance(name, SubjectAltName***REMOVED***:
                continue
            for entry in range(len(name***REMOVED******REMOVED***:
                component = name.getComponentByPosition(entry***REMOVED***
                if component.getName(***REMOVED*** != 'dNSName':
                    continue
                dns_name.append(str(component.getComponent(***REMOVED******REMOVED******REMOVED***

    return dns_name


class WrappedSocket(object***REMOVED***:
    '''API-compatibility wrapper for Python OpenSSL's Connection-class.

    Note: _makefile_refs, _drop(***REMOVED*** and _reuse(***REMOVED*** are needed for the garbage
    collector of pypy.
    '''

    def __init__(self, connection, socket, suppress_ragged_eofs=True***REMOVED***:
        self.connection = connection
        self.socket = socket
        self.suppress_ragged_eofs = suppress_ragged_eofs
        self._makefile_refs = 0
        self._closed = False

    def fileno(self***REMOVED***:
        return self.socket.fileno(***REMOVED***

    # Copy-pasted from Python 3.5 source code
    def _decref_socketios(self***REMOVED***:
        if self._makefile_refs > 0:
            self._makefile_refs -= 1
        if self._closed:
            self.close(***REMOVED***

    def recv(self, *args, **kwargs***REMOVED***:
        ***REMOVED***
            data = self.connection.recv(*args, **kwargs***REMOVED***
        except OpenSSL.SSL.SysCallError as e:
            if self.suppress_ragged_eofs and e.args == (-1, 'Unexpected EOF'***REMOVED***:
                return b''
            else:
                raise SocketError(str(e***REMOVED******REMOVED***
        except OpenSSL.SSL.ZeroReturnError as e:
            if self.connection.get_shutdown(***REMOVED*** == OpenSSL.SSL.RECEIVED_SHUTDOWN:
                return b''
            else:
                raise
        except OpenSSL.SSL.WantReadError:
            rd, wd, ed = select.select(
                [self.socket***REMOVED***, [***REMOVED***, [***REMOVED***, self.socket.gettimeout(***REMOVED******REMOVED***
            if not rd:
                raise timeout('The read operation timed out'***REMOVED***
            else:
                return self.recv(*args, **kwargs***REMOVED***
        else:
            return data

    def recv_into(self, *args, **kwargs***REMOVED***:
        ***REMOVED***
            return self.connection.recv_into(*args, **kwargs***REMOVED***
        except OpenSSL.SSL.SysCallError as e:
            if self.suppress_ragged_eofs and e.args == (-1, 'Unexpected EOF'***REMOVED***:
                return 0
            else:
                raise SocketError(str(e***REMOVED******REMOVED***
        except OpenSSL.SSL.ZeroReturnError as e:
            if self.connection.get_shutdown(***REMOVED*** == OpenSSL.SSL.RECEIVED_SHUTDOWN:
                return 0
            else:
                raise
        except OpenSSL.SSL.WantReadError:
            rd, wd, ed = select.select(
                [self.socket***REMOVED***, [***REMOVED***, [***REMOVED***, self.socket.gettimeout(***REMOVED******REMOVED***
            if not rd:
                raise timeout('The read operation timed out'***REMOVED***
            else:
                return self.recv_into(*args, **kwargs***REMOVED***

    def settimeout(self, timeout***REMOVED***:
        return self.socket.settimeout(timeout***REMOVED***

    def _send_until_done(self, data***REMOVED***:
        while True:
            ***REMOVED***
                return self.connection.send(data***REMOVED***
            except OpenSSL.SSL.WantWriteError:
                _, wlist, _ = select.select([***REMOVED***, [self.socket***REMOVED***, [***REMOVED***,
                                            self.socket.gettimeout(***REMOVED******REMOVED***
                if not wlist:
                    raise timeout(***REMOVED***
                continue

    def sendall(self, data***REMOVED***:
        total_sent = 0
        while total_sent < len(data***REMOVED***:
            sent = self._send_until_done(data[total_sent:total_sent + SSL_WRITE_BLOCKSIZE***REMOVED******REMOVED***
            total_sent += sent

    def shutdown(self***REMOVED***:
        # FIXME rethrow compatible exceptions should we ever use this
        self.connection.shutdown(***REMOVED***

    def close(self***REMOVED***:
        if self._makefile_refs < 1:
            ***REMOVED***
                self._closed = True
                return self.connection.close(***REMOVED***
            except OpenSSL.SSL.Error:
                return
        else:
            self._makefile_refs -= 1

    def getpeercert(self, binary_form=False***REMOVED***:
        x509 = self.connection.get_peer_certificate(***REMOVED***

        if not x509:
            return x509

        if binary_form:
            return OpenSSL.crypto.dump_certificate(
                OpenSSL.crypto.FILETYPE_ASN1,
                x509***REMOVED***

        return {
            'subject': (
                (('commonName', x509.get_subject(***REMOVED***.CN***REMOVED***,***REMOVED***,
            ***REMOVED***,
            'subjectAltName': [
                ('DNS', value***REMOVED***
                for value in get_subj_alt_name(x509***REMOVED***
            ***REMOVED***
    ***REMOVED***

    def _reuse(self***REMOVED***:
        self._makefile_refs += 1

    def _drop(self***REMOVED***:
        if self._makefile_refs < 1:
            self.close(***REMOVED***
        else:
            self._makefile_refs -= 1


if _fileobject:  # Platform-specific: Python 2
    def makefile(self, mode, bufsize=-1***REMOVED***:
        self._makefile_refs += 1
        return _fileobject(self, mode, bufsize, close=True***REMOVED***
else:  # Platform-specific: Python 3
    makefile = backport_makefile

WrappedSocket.makefile = makefile


def _verify_callback(cnx, x509, err_no, err_depth, return_code***REMOVED***:
    return err_no == 0


def ssl_wrap_socket(sock, keyfile=None, certfile=None, cert_reqs=None,
                    ca_certs=None, server_hostname=None,
                    ssl_version=None, ca_cert_dir=None***REMOVED***:
    ctx = OpenSSL.SSL.Context(_openssl_versions[ssl_version***REMOVED******REMOVED***
    if certfile:
        keyfile = keyfile or certfile  # Match behaviour of the normal python ssl library
        ctx.use_certificate_file(certfile***REMOVED***
    if keyfile:
        ctx.use_privatekey_file(keyfile***REMOVED***
    if cert_reqs != ssl.CERT_NONE:
        ctx.set_verify(_openssl_verify[cert_reqs***REMOVED***, _verify_callback***REMOVED***
    if ca_certs or ca_cert_dir:
        ***REMOVED***
            ctx.load_verify_locations(ca_certs, ca_cert_dir***REMOVED***
        except OpenSSL.SSL.Error as e:
            raise ssl.SSLError('bad ca_certs: %r' % ca_certs, e***REMOVED***
    else:
        ctx.set_default_verify_paths(***REMOVED***

    # Disable TLS compression to mitigate CRIME attack (issue #309***REMOVED***
    OP_NO_COMPRESSION = 0x20000
    ctx.set_options(OP_NO_COMPRESSION***REMOVED***

    # Set list of supported ciphersuites.
    ctx.set_cipher_list(DEFAULT_SSL_CIPHER_LIST***REMOVED***

    cnx = OpenSSL.SSL.Connection(ctx, sock***REMOVED***
    if isinstance(server_hostname, six.text_type***REMOVED***:  # Platform-specific: Python 3
        server_hostname = server_hostname.encode('utf-8'***REMOVED***
    cnx.set_tlsext_host_name(server_hostname***REMOVED***
    cnx.set_connect_state(***REMOVED***
    while True:
        ***REMOVED***
            cnx.do_handshake(***REMOVED***
        except OpenSSL.SSL.WantReadError:
            rd, _, _ = select.select([sock***REMOVED***, [***REMOVED***, [***REMOVED***, sock.gettimeout(***REMOVED******REMOVED***
            if not rd:
                raise timeout('select timed out'***REMOVED***
            continue
        except OpenSSL.SSL.Error as e:
            raise ssl.SSLError('bad handshake: %r' % e***REMOVED***
        break

    return WrappedSocket(cnx, sock***REMOVED***
