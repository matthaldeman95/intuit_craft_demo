from __future__ import absolute_import
from ..packages.six.moves import http_client as httplib

from ..exceptions import HeaderParsingError


def is_fp_closed(obj***REMOVED***:
    ***REMOVED***
    Checks whether a given file-like object is closed.

    :param obj:
        The file-like object to check.
    ***REMOVED***

    ***REMOVED***
        # Check via the official file-like-object way.
        return obj.closed
    except AttributeError:
        pass

    ***REMOVED***
        # Check if the object is a container for another file-like object that
        # gets released on exhaustion (e.g. HTTPResponse***REMOVED***.
        return obj.fp is None
    except AttributeError:
        pass

    raise ValueError("Unable to determine whether fp is closed."***REMOVED***


def assert_header_parsing(headers***REMOVED***:
    ***REMOVED***
    Asserts whether all headers have been successfully parsed.
    Extracts encountered errors from the result of parsing headers.

    Only works on Python 3.

    :param headers: Headers to verify.
    :type headers: `httplib.HTTPMessage`.

    :raises urllib3.exceptions.HeaderParsingError:
        If parsing errors are found.
    ***REMOVED***

    # This will fail silently if we pass in the wrong kind of parameter.
    # To make debugging easier add an explicit check.
    if not isinstance(headers, httplib.HTTPMessage***REMOVED***:
        raise TypeError('expected httplib.Message, got {0***REMOVED***.'.format(
            type(headers***REMOVED******REMOVED******REMOVED***

    defects = getattr(headers, 'defects', None***REMOVED***
    get_payload = getattr(headers, 'get_payload', None***REMOVED***

    unparsed_data = None
    if get_payload:  # Platform-specific: Python 3.
        unparsed_data = get_payload(***REMOVED***

    if defects or unparsed_data:
        raise HeaderParsingError(defects=defects, unparsed_data=unparsed_data***REMOVED***


def is_response_to_head(response***REMOVED***:
    ***REMOVED***
    Checks whether the request of a response has been a HEAD-request.
    Handles the quirks of AppEngine.

    :param conn:
    :type conn: :class:`httplib.HTTPResponse`
    ***REMOVED***
    # FIXME: Can we do this somehow without accessing private httplib _method?
    method = response._method
    if isinstance(method, int***REMOVED***:  # Platform-specific: Appengine
        return method == 3
    return method.upper(***REMOVED*** == 'HEAD'
