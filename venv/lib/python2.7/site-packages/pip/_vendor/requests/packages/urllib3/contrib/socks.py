# -*- coding: utf-8 -*-
***REMOVED***
SOCKS support for urllib3
~~~~~~~~~~~~~~~~~~~~~~~~~

This contrib module contains provisional support for SOCKS proxies from within
urllib3. This module supports SOCKS4 (specifically the SOCKS4A variant***REMOVED*** and
SOCKS5. To enable its functionality, either install PySocks or install this
module with the ``socks`` extra.

Known Limitations:

- Currently PySocks does not support contacting remote websites via literal
  IPv6 addresses. Any such connection attempt will fail.
- Currently PySocks does not support IPv6 connections to the SOCKS proxy. Any
  such connection attempt will fail.
***REMOVED***
from __future__ import absolute_import

***REMOVED***
    import socks
except ImportError:
    import warnings
    from ..exceptions import DependencyWarning

    warnings.warn((
        'SOCKS support in urllib3 requires the installation of optional '
        'dependencies: specifically, PySocks.  For more information, see '
        'https://urllib3.readthedocs.org/en/latest/contrib.html#socks-proxies'
        ***REMOVED***,
        DependencyWarning
    ***REMOVED***
    raise

from socket import error as SocketError, timeout as SocketTimeout

from ..connection import (
    HTTPConnection, HTTPSConnection
***REMOVED***
from ..connectionpool import (
    HTTPConnectionPool, HTTPSConnectionPool
***REMOVED***
from ..exceptions import ConnectTimeoutError, NewConnectionError
from ..poolmanager import PoolManager
from ..util.url import parse_url

***REMOVED***
    import ssl
except ImportError:
    ssl = None


class SOCKSConnection(HTTPConnection***REMOVED***:
    ***REMOVED***
    A plain-text HTTP connection that connects via a SOCKS proxy.
    ***REMOVED***
    def __init__(self, *args, **kwargs***REMOVED***:
        self._socks_options = kwargs.pop('_socks_options'***REMOVED***
        super(SOCKSConnection, self***REMOVED***.__init__(*args, **kwargs***REMOVED***

    def _new_conn(self***REMOVED***:
        ***REMOVED***
        Establish a new connection via the SOCKS proxy.
        ***REMOVED***
        extra_kw = {***REMOVED***
        if self.source_address:
            extra_kw['source_address'***REMOVED*** = self.source_address

        if self.socket_options:
            extra_kw['socket_options'***REMOVED*** = self.socket_options

        ***REMOVED***
            conn = socks.create_connection(
                (self.host, self.port***REMOVED***,
                proxy_type=self._socks_options['socks_version'***REMOVED***,
                proxy_addr=self._socks_options['proxy_host'***REMOVED***,
                proxy_port=self._socks_options['proxy_port'***REMOVED***,
                proxy_username=self._socks_options['username'***REMOVED***,
                proxy_password=self._socks_options['password'***REMOVED***,
                timeout=self.timeout,
                **extra_kw
            ***REMOVED***

        except SocketTimeout as e:
            raise ConnectTimeoutError(
                self, "Connection to %s timed out. (connect timeout=%s***REMOVED***" %
                (self.host, self.timeout***REMOVED******REMOVED***

        except socks.ProxyError as e:
            # This is fragile as hell, but it seems to be the only way to raise
            # useful errors here.
            if e.socket_err:
                error = e.socket_err
                if isinstance(error, SocketTimeout***REMOVED***:
                    raise ConnectTimeoutError(
                        self,
                        "Connection to %s timed out. (connect timeout=%s***REMOVED***" %
                        (self.host, self.timeout***REMOVED***
                    ***REMOVED***
                else:
                    raise NewConnectionError(
                        self,
                        "Failed to establish a new connection: %s" % error
                    ***REMOVED***
            else:
                raise NewConnectionError(
                    self,
                    "Failed to establish a new connection: %s" % e
                ***REMOVED***

        except SocketError as e:  # Defensive: PySocks should catch all these.
            raise NewConnectionError(
                self, "Failed to establish a new connection: %s" % e***REMOVED***

        return conn


# We don't need to duplicate the Verified/Unverified distinction from
# urllib3/connection.py here because the HTTPSConnection will already have been
# correctly set to either the Verified or Unverified form by that module. This
# means the SOCKSHTTPSConnection will automatically be the correct type.
class SOCKSHTTPSConnection(SOCKSConnection, HTTPSConnection***REMOVED***:
    pass


class SOCKSHTTPConnectionPool(HTTPConnectionPool***REMOVED***:
    ConnectionCls = SOCKSConnection


class SOCKSHTTPSConnectionPool(HTTPSConnectionPool***REMOVED***:
    ConnectionCls = SOCKSHTTPSConnection


class SOCKSProxyManager(PoolManager***REMOVED***:
    ***REMOVED***
    A version of the urllib3 ProxyManager that routes connections via the
    defined SOCKS proxy.
    ***REMOVED***
    pool_classes_by_scheme = {
        'http': SOCKSHTTPConnectionPool,
        'https': SOCKSHTTPSConnectionPool,
***REMOVED***

    def __init__(self, proxy_url, username=None, password=None,
                 num_pools=10, headers=None, **connection_pool_kw***REMOVED***:
        parsed = parse_url(proxy_url***REMOVED***

        if parsed.scheme == 'socks5':
            socks_version = socks.PROXY_TYPE_SOCKS5
        elif parsed.scheme == 'socks4':
            socks_version = socks.PROXY_TYPE_SOCKS4
        else:
            raise ValueError(
                "Unable to determine SOCKS version from %s" % proxy_url
            ***REMOVED***

        self.proxy_url = proxy_url

        socks_options = {
            'socks_version': socks_version,
            'proxy_host': parsed.host,
            'proxy_port': parsed.port,
            'username': username,
            'password': password,
    ***REMOVED***
        connection_pool_kw['_socks_options'***REMOVED*** = socks_options

        super(SOCKSProxyManager, self***REMOVED***.__init__(
            num_pools, headers, **connection_pool_kw
        ***REMOVED***

        self.pool_classes_by_scheme = SOCKSProxyManager.pool_classes_by_scheme
