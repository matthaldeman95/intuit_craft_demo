***REMOVED***Utilities for writing code that runs on Python 2 and 3***REMOVED***

#Copyright (c***REMOVED*** 2010-2011 Benjamin Peterson

#Permission is hereby granted, free of charge, to any person obtaining a copy of
#this software and associated documentation files (the "Software"***REMOVED***, to deal in
#the Software without restriction, including without limitation the rights to
#use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
#the Software, and to permit persons to whom the Software is furnished to do so,
#subject to the following conditions:

#The above copyright notice and this permission notice shall be included in all
#copies or substantial portions of the Software.

#THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
#FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
#COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
#IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
#CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

import operator
import sys
import types

__author__ = "Benjamin Peterson <benjamin@python.org>"
__version__ = "1.2.0"  # Revision 41c74fef2ded


# True if we are running on Python 3.
PY3 = sys.version_info[0***REMOVED*** == 3

if PY3:
    string_types = str,
    integer_types = int,
    class_types = type,
    text_type = str
    binary_type = bytes

    MAXSIZE = sys.maxsize
else:
    string_types = basestring,
    integer_types = (int, long***REMOVED***
    class_types = (type, types.ClassType***REMOVED***
    text_type = unicode
    binary_type = str

    if sys.platform.startswith("java"***REMOVED***:
        # Jython always uses 32 bits.
        MAXSIZE = int((1 << 31***REMOVED*** - 1***REMOVED***
    else:
        # It's possible to have sizeof(long***REMOVED*** != sizeof(Py_ssize_t***REMOVED***.
        class X(object***REMOVED***:
            def __len__(self***REMOVED***:
                return 1 << 31
        ***REMOVED***
            len(X(***REMOVED******REMOVED***
        except OverflowError:
            # 32-bit
            MAXSIZE = int((1 << 31***REMOVED*** - 1***REMOVED***
        else:
            # 64-bit
            MAXSIZE = int((1 << 63***REMOVED*** - 1***REMOVED***
            del X


def _add_doc(func, doc***REMOVED***:
    ***REMOVED***Add documentation to a function.***REMOVED***
    func.__doc__ = doc


def _import_module(name***REMOVED***:
    ***REMOVED***Import module, returning the module after the last dot.***REMOVED***
    __import__(name***REMOVED***
    return sys.modules[name***REMOVED***


class _LazyDescr(object***REMOVED***:

    def __init__(self, name***REMOVED***:
        self.name = name

    def __get__(self, obj, tp***REMOVED***:
        result = self._resolve(***REMOVED***
        setattr(obj, self.name, result***REMOVED***
        # This is a bit ugly, but it avoids running this again.
        delattr(tp, self.name***REMOVED***
        return result


class MovedModule(_LazyDescr***REMOVED***:

    def __init__(self, name, old, new=None***REMOVED***:
        super(MovedModule, self***REMOVED***.__init__(name***REMOVED***
        if PY3:
            if new is None:
                new = name
            self.mod = new
        else:
            self.mod = old

    def _resolve(self***REMOVED***:
        return _import_module(self.mod***REMOVED***


class MovedAttribute(_LazyDescr***REMOVED***:

    def __init__(self, name, old_mod, new_mod, old_attr=None, new_attr=None***REMOVED***:
        super(MovedAttribute, self***REMOVED***.__init__(name***REMOVED***
        if PY3:
            if new_mod is None:
                new_mod = name
            self.mod = new_mod
            if new_attr is None:
                if old_attr is None:
                    new_attr = name
                else:
                    new_attr = old_attr
            self.attr = new_attr
        else:
            self.mod = old_mod
            if old_attr is None:
                old_attr = name
            self.attr = old_attr

    def _resolve(self***REMOVED***:
        module = _import_module(self.mod***REMOVED***
        return getattr(module, self.attr***REMOVED***



class _MovedItems(types.ModuleType***REMOVED***:
    ***REMOVED***Lazy loading of moved objects***REMOVED***


_moved_attributes = [
    MovedAttribute("cStringIO", "cStringIO", "io", "StringIO"***REMOVED***,
    MovedAttribute("filter", "itertools", "builtins", "ifilter", "filter"***REMOVED***,
    MovedAttribute("input", "__builtin__", "builtins", "raw_input", "input"***REMOVED***,
    MovedAttribute("map", "itertools", "builtins", "imap", "map"***REMOVED***,
    MovedAttribute("reload_module", "__builtin__", "imp", "reload"***REMOVED***,
    MovedAttribute("reduce", "__builtin__", "functools"***REMOVED***,
    MovedAttribute("StringIO", "StringIO", "io"***REMOVED***,
    MovedAttribute("xrange", "__builtin__", "builtins", "xrange", "range"***REMOVED***,
    MovedAttribute("zip", "itertools", "builtins", "izip", "zip"***REMOVED***,

    MovedModule("builtins", "__builtin__"***REMOVED***,
    MovedModule("configparser", "ConfigParser"***REMOVED***,
    MovedModule("copyreg", "copy_reg"***REMOVED***,
    MovedModule("http_cookiejar", "cookielib", "http.cookiejar"***REMOVED***,
    MovedModule("http_cookies", "Cookie", "http.cookies"***REMOVED***,
    MovedModule("html_entities", "htmlentitydefs", "html.entities"***REMOVED***,
    MovedModule("html_parser", "HTMLParser", "html.parser"***REMOVED***,
    MovedModule("http_client", "httplib", "http.client"***REMOVED***,
    MovedModule("BaseHTTPServer", "BaseHTTPServer", "http.server"***REMOVED***,
    MovedModule("CGIHTTPServer", "CGIHTTPServer", "http.server"***REMOVED***,
    MovedModule("SimpleHTTPServer", "SimpleHTTPServer", "http.server"***REMOVED***,
    MovedModule("cPickle", "cPickle", "pickle"***REMOVED***,
    MovedModule("queue", "Queue"***REMOVED***,
    MovedModule("reprlib", "repr"***REMOVED***,
    MovedModule("socketserver", "SocketServer"***REMOVED***,
    MovedModule("tkinter", "Tkinter"***REMOVED***,
    MovedModule("tkinter_dialog", "Dialog", "tkinter.dialog"***REMOVED***,
    MovedModule("tkinter_filedialog", "FileDialog", "tkinter.filedialog"***REMOVED***,
    MovedModule("tkinter_scrolledtext", "ScrolledText", "tkinter.scrolledtext"***REMOVED***,
    MovedModule("tkinter_simpledialog", "SimpleDialog", "tkinter.simpledialog"***REMOVED***,
    MovedModule("tkinter_tix", "Tix", "tkinter.tix"***REMOVED***,
    MovedModule("tkinter_constants", "Tkconstants", "tkinter.constants"***REMOVED***,
    MovedModule("tkinter_dnd", "Tkdnd", "tkinter.dnd"***REMOVED***,
    MovedModule("tkinter_colorchooser", "tkColorChooser",
                "tkinter.colorchooser"***REMOVED***,
    MovedModule("tkinter_commondialog", "tkCommonDialog",
                "tkinter.commondialog"***REMOVED***,
    MovedModule("tkinter_tkfiledialog", "tkFileDialog", "tkinter.filedialog"***REMOVED***,
    MovedModule("tkinter_font", "tkFont", "tkinter.font"***REMOVED***,
    MovedModule("tkinter_messagebox", "tkMessageBox", "tkinter.messagebox"***REMOVED***,
    MovedModule("tkinter_tksimpledialog", "tkSimpleDialog",
                "tkinter.simpledialog"***REMOVED***,
    MovedModule("urllib_robotparser", "robotparser", "urllib.robotparser"***REMOVED***,
    MovedModule("winreg", "_winreg"***REMOVED***,
***REMOVED***
for attr in _moved_attributes:
    setattr(_MovedItems, attr.name, attr***REMOVED***
del attr

moves = sys.modules[__name__ + ".moves"***REMOVED*** = _MovedItems("moves"***REMOVED***


def add_move(move***REMOVED***:
    ***REMOVED***Add an item to six.moves.***REMOVED***
    setattr(_MovedItems, move.name, move***REMOVED***


def remove_move(name***REMOVED***:
    ***REMOVED***Remove item from six.moves.***REMOVED***
    ***REMOVED***
        delattr(_MovedItems, name***REMOVED***
    except AttributeError:
        ***REMOVED***
            del moves.__dict__[name***REMOVED***
        except KeyError:
            raise AttributeError("no such move, %r" % (name,***REMOVED******REMOVED***


if PY3:
    _meth_func = "__func__"
    _meth_self = "__self__"

    _func_code = "__code__"
    _func_defaults = "__defaults__"

    _iterkeys = "keys"
    _itervalues = "values"
    _iteritems = "items"
else:
    _meth_func = "im_func"
    _meth_self = "im_self"

    _func_code = "func_code"
    _func_defaults = "func_defaults"

    _iterkeys = "iterkeys"
    _itervalues = "itervalues"
    _iteritems = "iteritems"


***REMOVED***
    advance_iterator = next
except NameError:
    def advance_iterator(it***REMOVED***:
        return it.next(***REMOVED***
next = advance_iterator


if PY3:
    def get_unbound_function(unbound***REMOVED***:
        return unbound

    Iterator = object

    def callable(obj***REMOVED***:
        return any("__call__" in klass.__dict__ for klass in type(obj***REMOVED***.__mro__***REMOVED***
else:
    def get_unbound_function(unbound***REMOVED***:
        return unbound.im_func

    class Iterator(object***REMOVED***:

        def next(self***REMOVED***:
            return type(self***REMOVED***.__next__(self***REMOVED***

    callable = callable
_add_doc(get_unbound_function,
         ***REMOVED***Get the function out of a possibly unbound function***REMOVED******REMOVED***


get_method_function = operator.attrgetter(_meth_func***REMOVED***
get_method_self = operator.attrgetter(_meth_self***REMOVED***
get_function_code = operator.attrgetter(_func_code***REMOVED***
get_function_defaults = operator.attrgetter(_func_defaults***REMOVED***


def iterkeys(d***REMOVED***:
    ***REMOVED***Return an iterator over the keys of a dictionary.***REMOVED***
    return iter(getattr(d, _iterkeys***REMOVED***(***REMOVED******REMOVED***

def itervalues(d***REMOVED***:
    ***REMOVED***Return an iterator over the values of a dictionary.***REMOVED***
    return iter(getattr(d, _itervalues***REMOVED***(***REMOVED******REMOVED***

def iteritems(d***REMOVED***:
    ***REMOVED***Return an iterator over the (key, value***REMOVED*** pairs of a dictionary.***REMOVED***
    return iter(getattr(d, _iteritems***REMOVED***(***REMOVED******REMOVED***


if PY3:
    def b(s***REMOVED***:
        return s.encode("latin-1"***REMOVED***
    def u(s***REMOVED***:
        return s
    if sys.version_info[1***REMOVED*** <= 1:
        def int2byte(i***REMOVED***:
            return bytes((i,***REMOVED******REMOVED***
    else:
        # This is about 2x faster than the implementation above on 3.2+
        int2byte = operator.methodcaller("to_bytes", 1, "big"***REMOVED***
    import io
    StringIO = io.StringIO
    BytesIO = io.BytesIO
else:
    def b(s***REMOVED***:
        return s
    def u(s***REMOVED***:
        return unicode(s, "unicode_escape"***REMOVED***
    int2byte = chr
    import StringIO
    StringIO = BytesIO = StringIO.StringIO
_add_doc(b, ***REMOVED***Byte literal***REMOVED******REMOVED***
_add_doc(u, ***REMOVED***Text literal***REMOVED******REMOVED***


if PY3:
    import builtins
    exec_ = getattr(builtins, "exec"***REMOVED***


    def reraise(tp, value, tb=None***REMOVED***:
        if value.__traceback__ is not tb:
            raise value.with_traceback(tb***REMOVED***
        raise value


    print_ = getattr(builtins, "print"***REMOVED***
    del builtins

else:
    def exec_(code, globs=None, locs=None***REMOVED***:
        ***REMOVED***Execute code in a namespace.***REMOVED***
        if globs is None:
            frame = sys._getframe(1***REMOVED***
            globs = frame.f_globals
            if locs is None:
                locs = frame.f_locals
            del frame
        elif locs is None:
            locs = globs
        exec(***REMOVED***exec code in globs, locs***REMOVED******REMOVED***


    exec_(***REMOVED***def reraise(tp, value, tb=None***REMOVED***:
    raise tp, value, tb
***REMOVED******REMOVED***


    def print_(*args, **kwargs***REMOVED***:
        ***REMOVED***The new-style print function.***REMOVED***
        fp = kwargs.pop("file", sys.stdout***REMOVED***
        if fp is None:
            return
        def write(data***REMOVED***:
            if not isinstance(data, basestring***REMOVED***:
                data = str(data***REMOVED***
            fp.write(data***REMOVED***
        want_unicode = False
        sep = kwargs.pop("sep", None***REMOVED***
        if sep is not None:
            if isinstance(sep, unicode***REMOVED***:
                want_unicode = True
            elif not isinstance(sep, str***REMOVED***:
                raise TypeError("sep must be None or a string"***REMOVED***
        end = kwargs.pop("end", None***REMOVED***
        if end is not None:
            if isinstance(end, unicode***REMOVED***:
                want_unicode = True
            elif not isinstance(end, str***REMOVED***:
                raise TypeError("end must be None or a string"***REMOVED***
        if kwargs:
            raise TypeError("invalid keyword arguments to print(***REMOVED***"***REMOVED***
        if not want_unicode:
            for arg in args:
                if isinstance(arg, unicode***REMOVED***:
                    want_unicode = True
                    break
        if want_unicode:
            newline = unicode("\n"***REMOVED***
            space = unicode(" "***REMOVED***
        else:
            newline = "\n"
            space = " "
        if sep is None:
            sep = space
        if end is None:
            end = newline
        for i, arg in enumerate(args***REMOVED***:
            if i:
                write(sep***REMOVED***
            write(arg***REMOVED***
        write(end***REMOVED***

_add_doc(reraise, ***REMOVED***Reraise an exception.***REMOVED******REMOVED***


def with_metaclass(meta, base=object***REMOVED***:
    ***REMOVED***Create a base class with a metaclass.***REMOVED***
    return meta("NewBase", (base,***REMOVED***, {***REMOVED******REMOVED***
