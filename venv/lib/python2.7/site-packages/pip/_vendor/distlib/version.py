# -*- coding: utf-8 -*-
#
# Copyright (C***REMOVED*** 2012-2016 The Python Software Foundation.
# See LICENSE.txt and CONTRIBUTORS.txt.
#
***REMOVED***
Implementation of a flexible versioning scheme providing support for PEP-440,
setuptools-compatible and semantic versioning.
***REMOVED***

import logging
import re

from .compat import string_types

__all__ = ['NormalizedVersion', 'NormalizedMatcher',
           'LegacyVersion', 'LegacyMatcher',
           'SemanticVersion', 'SemanticMatcher',
           'UnsupportedVersionError', 'get_scheme'***REMOVED***

logger = logging.getLogger(__name__***REMOVED***


class UnsupportedVersionError(ValueError***REMOVED***:
    ***REMOVED***This is an unsupported version.***REMOVED***
    pass


class Version(object***REMOVED***:
    def __init__(self, s***REMOVED***:
        self._string = s = s.strip(***REMOVED***
        self._parts = parts = self.parse(s***REMOVED***
        assert isinstance(parts, tuple***REMOVED***
        assert len(parts***REMOVED*** > 0

    def parse(self, s***REMOVED***:
        raise NotImplementedError('please implement in a subclass'***REMOVED***

    def _check_compatible(self, other***REMOVED***:
        if type(self***REMOVED*** != type(other***REMOVED***:
            raise TypeError('cannot compare %r and %r' % (self, other***REMOVED******REMOVED***

    def __eq__(self, other***REMOVED***:
        self._check_compatible(other***REMOVED***
        return self._parts == other._parts

    def __ne__(self, other***REMOVED***:
        return not self.__eq__(other***REMOVED***

    def __lt__(self, other***REMOVED***:
        self._check_compatible(other***REMOVED***
        return self._parts < other._parts

    def __gt__(self, other***REMOVED***:
        return not (self.__lt__(other***REMOVED*** or self.__eq__(other***REMOVED******REMOVED***

    def __le__(self, other***REMOVED***:
        return self.__lt__(other***REMOVED*** or self.__eq__(other***REMOVED***

    def __ge__(self, other***REMOVED***:
        return self.__gt__(other***REMOVED*** or self.__eq__(other***REMOVED***

    # See http://docs.python.org/reference/datamodel#object.__hash__
    def __hash__(self***REMOVED***:
        return hash(self._parts***REMOVED***

    def __repr__(self***REMOVED***:
        return "%s('%s'***REMOVED***" % (self.__class__.__name__, self._string***REMOVED***

    def __str__(self***REMOVED***:
        return self._string

    @property
    def is_prerelease(self***REMOVED***:
        raise NotImplementedError('Please implement in subclasses.'***REMOVED***


class Matcher(object***REMOVED***:
    version_class = None

    dist_re = re.compile(r"^(\w[\s\w'.-***REMOVED*******REMOVED***(\((.****REMOVED***\***REMOVED******REMOVED***?"***REMOVED***
    comp_re = re.compile(r'^(<=|>=|<|>|!=|={2,3***REMOVED***|~=***REMOVED***?\s*([^\s,***REMOVED***+***REMOVED***$'***REMOVED***
    num_re = re.compile(r'^\d+(\.\d+***REMOVED****$'***REMOVED***

    # value is either a callable or the name of a method
    _operators = {
        '<': lambda v, c, p: v < c,
        '>': lambda v, c, p: v > c,
        '<=': lambda v, c, p: v == c or v < c,
        '>=': lambda v, c, p: v == c or v > c,
        '==': lambda v, c, p: v == c,
        '===': lambda v, c, p: v == c,
        # by default, compatible => >=.
        '~=': lambda v, c, p: v == c or v > c,
        '!=': lambda v, c, p: v != c,
***REMOVED***

    def __init__(self, s***REMOVED***:
        if self.version_class is None:
            raise ValueError('Please specify a version class'***REMOVED***
        self._string = s = s.strip(***REMOVED***
        m = self.dist_re.match(s***REMOVED***
        if not m:
            raise ValueError('Not valid: %r' % s***REMOVED***
        groups = m.groups(''***REMOVED***
        self.name = groups[0***REMOVED***.strip(***REMOVED***
        self.key = self.name.lower(***REMOVED***    # for case-insensitive comparisons
        clist = [***REMOVED***
        if groups[2***REMOVED***:
            constraints = [c.strip(***REMOVED*** for c in groups[2***REMOVED***.split(','***REMOVED******REMOVED***
            for c in constraints:
                m = self.comp_re.match(c***REMOVED***
                if not m:
                    raise ValueError('Invalid %r in %r' % (c, s***REMOVED******REMOVED***
                groups = m.groups(***REMOVED***
                op = groups[0***REMOVED*** or '~='
                s = groups[1***REMOVED***
                if s.endswith('.*'***REMOVED***:
                    if op not in ('==', '!='***REMOVED***:
                        raise ValueError('\'.*\' not allowed for '
                                         '%r constraints' % op***REMOVED***
                    # Could be a partial version (e.g. for '2.*'***REMOVED*** which
                    # won't parse as a version, so keep it as a string
                    vn, prefix = s[:-2***REMOVED***, True
                    if not self.num_re.match(vn***REMOVED***:
                        # Just to check that vn is a valid version
                        self.version_class(vn***REMOVED***
                else:
                    # Should parse as a version, so we can create an
                    # instance for the comparison
                    vn, prefix = self.version_class(s***REMOVED***, False
                clist.append((op, vn, prefix***REMOVED******REMOVED***
        self._parts = tuple(clist***REMOVED***

    def match(self, version***REMOVED***:
        ***REMOVED***
        Check if the provided version matches the constraints.

        :param version: The version to match against this instance.
        :type version: Strring or :class:`Version` instance.
        ***REMOVED***
        if isinstance(version, string_types***REMOVED***:
            version = self.version_class(version***REMOVED***
        for operator, constraint, prefix in self._parts:
            f = self._operators.get(operator***REMOVED***
            if isinstance(f, string_types***REMOVED***:
                f = getattr(self, f***REMOVED***
            if not f:
                msg = ('%r not implemented '
                       'for %s' % (operator, self.__class__.__name__***REMOVED******REMOVED***
                raise NotImplementedError(msg***REMOVED***
            if not f(version, constraint, prefix***REMOVED***:
                return False
        return True

    @property
    def exact_version(self***REMOVED***:
        result = None
        if len(self._parts***REMOVED*** == 1 and self._parts[0***REMOVED***[0***REMOVED*** in ('==', '==='***REMOVED***:
            result = self._parts[0***REMOVED***[1***REMOVED***
        return result

    def _check_compatible(self, other***REMOVED***:
        if type(self***REMOVED*** != type(other***REMOVED*** or self.name != other.name:
            raise TypeError('cannot compare %s and %s' % (self, other***REMOVED******REMOVED***

    def __eq__(self, other***REMOVED***:
        self._check_compatible(other***REMOVED***
        return self.key == other.key and self._parts == other._parts

    def __ne__(self, other***REMOVED***:
        return not self.__eq__(other***REMOVED***

    # See http://docs.python.org/reference/datamodel#object.__hash__
    def __hash__(self***REMOVED***:
        return hash(self.key***REMOVED*** + hash(self._parts***REMOVED***

    def __repr__(self***REMOVED***:
        return "%s(%r***REMOVED***" % (self.__class__.__name__, self._string***REMOVED***

    def __str__(self***REMOVED***:
        return self._string


PEP440_VERSION_RE = re.compile(r'^v?(\d+!***REMOVED***?(\d+(\.\d+***REMOVED*******REMOVED***((a|b|c|rc***REMOVED***(\d+***REMOVED******REMOVED***?'
                               r'(\.(post***REMOVED***(\d+***REMOVED******REMOVED***?(\.(dev***REMOVED***(\d+***REMOVED******REMOVED***?'
                               r'(\+([a-zA-Z\d***REMOVED***+(\.[a-zA-Z\d***REMOVED***+***REMOVED***?***REMOVED******REMOVED***?$'***REMOVED***


def _pep_440_key(s***REMOVED***:
    s = s.strip(***REMOVED***
    m = PEP440_VERSION_RE.match(s***REMOVED***
    if not m:
        raise UnsupportedVersionError('Not a valid version: %s' % s***REMOVED***
    groups = m.groups(***REMOVED***
    nums = tuple(int(v***REMOVED*** for v in groups[1***REMOVED***.split('.'***REMOVED******REMOVED***
    while len(nums***REMOVED*** > 1 and nums[-1***REMOVED*** == 0:
        nums = nums[:-1***REMOVED***

    if not groups[0***REMOVED***:
        epoch = 0
    else:
        epoch = int(groups[0***REMOVED******REMOVED***
    pre = groups[4:6***REMOVED***
    post = groups[7:9***REMOVED***
    dev = groups[10:12***REMOVED***
    local = groups[13***REMOVED***
    if pre == (None, None***REMOVED***:
        pre = (***REMOVED***
    else:
        pre = pre[0***REMOVED***, int(pre[1***REMOVED******REMOVED***
    if post == (None, None***REMOVED***:
        post = (***REMOVED***
    else:
        post = post[0***REMOVED***, int(post[1***REMOVED******REMOVED***
    if dev == (None, None***REMOVED***:
        dev = (***REMOVED***
    else:
        dev = dev[0***REMOVED***, int(dev[1***REMOVED******REMOVED***
    if local is None:
        local = (***REMOVED***
    else:
        parts = [***REMOVED***
        for part in local.split('.'***REMOVED***:
            # to ensure that numeric compares as > lexicographic, avoid
            # comparing them directly, but encode a tuple which ensures
            # correct sorting
            if part.isdigit(***REMOVED***:
                part = (1, int(part***REMOVED******REMOVED***
            else:
                part = (0, part***REMOVED***
            parts.append(part***REMOVED***
        local = tuple(parts***REMOVED***
    if not pre:
        # either before pre-release, or final release and after
        if not post and dev:
            # before pre-release
            pre = ('a', -1***REMOVED***     # to sort before a0
        else:
            pre = ('z',***REMOVED***        # to sort after all pre-releases
    # now look at the state of post and dev.
    if not post:
        post = ('_',***REMOVED***   # sort before 'a'
    if not dev:
        dev = ('final',***REMOVED***

    #print('%s -> %s' % (s, m.groups(***REMOVED******REMOVED******REMOVED***
    return epoch, nums, pre, post, dev, local


_normalized_key = _pep_440_key


class NormalizedVersion(Version***REMOVED***:
    ***REMOVED***A rational version.

    Good:
        1.2         # equivalent to "1.2.0"
        1.2.0
        1.2a1
        1.2.3a2
        1.2.3b1
        1.2.3c1
        1.2.3.4
        TODO: fill this out

    Bad:
        1           # mininum two numbers
        1.2a        # release level must have a release serial
        1.2.3b
    ***REMOVED***
    def parse(self, s***REMOVED***:
        result = _normalized_key(s***REMOVED***
        # _normalized_key loses trailing zeroes in the release
        # clause, since that's needed to ensure that X.Y == X.Y.0 == X.Y.0.0
        # However, PEP 440 prefix matching needs it: for example,
        # (~= 1.4.5.0***REMOVED*** matches differently to (~= 1.4.5.0.0***REMOVED***.
        m = PEP440_VERSION_RE.match(s***REMOVED***      # must succeed
        groups = m.groups(***REMOVED***
        self._release_clause = tuple(int(v***REMOVED*** for v in groups[1***REMOVED***.split('.'***REMOVED******REMOVED***
        return result

    PREREL_TAGS = set(['a', 'b', 'c', 'rc', 'dev'***REMOVED******REMOVED***

    @property
    def is_prerelease(self***REMOVED***:
        return any(t[0***REMOVED*** in self.PREREL_TAGS for t in self._parts if t***REMOVED***


def _match_prefix(x, y***REMOVED***:
    x = str(x***REMOVED***
    y = str(y***REMOVED***
    if x == y:
        return True
    if not x.startswith(y***REMOVED***:
        return False
    n = len(y***REMOVED***
    return x[n***REMOVED*** == '.'


class NormalizedMatcher(Matcher***REMOVED***:
    version_class = NormalizedVersion

    # value is either a callable or the name of a method
    _operators = {
        '~=': '_match_compatible',
        '<': '_match_lt',
        '>': '_match_gt',
        '<=': '_match_le',
        '>=': '_match_ge',
        '==': '_match_eq',
        '===': '_match_arbitrary',
        '!=': '_match_ne',
***REMOVED***

    def _adjust_local(self, version, constraint, prefix***REMOVED***:
        if prefix:
            strip_local = '+' not in constraint and version._parts[-1***REMOVED***
        else:
            # both constraint and version are
            # NormalizedVersion instances.
            # If constraint does not have a local component,
            # ensure the version doesn't, either.
            strip_local = not constraint._parts[-1***REMOVED*** and version._parts[-1***REMOVED***
        if strip_local:
            s = version._string.split('+', 1***REMOVED***[0***REMOVED***
            version = self.version_class(s***REMOVED***
        return version, constraint

    def _match_lt(self, version, constraint, prefix***REMOVED***:
        version, constraint = self._adjust_local(version, constraint, prefix***REMOVED***
        if version >= constraint:
            return False
        release_clause = constraint._release_clause
        pfx = '.'.join([str(i***REMOVED*** for i in release_clause***REMOVED******REMOVED***
        return not _match_prefix(version, pfx***REMOVED***

    def _match_gt(self, version, constraint, prefix***REMOVED***:
        version, constraint = self._adjust_local(version, constraint, prefix***REMOVED***
        if version <= constraint:
            return False
        release_clause = constraint._release_clause
        pfx = '.'.join([str(i***REMOVED*** for i in release_clause***REMOVED******REMOVED***
        return not _match_prefix(version, pfx***REMOVED***

    def _match_le(self, version, constraint, prefix***REMOVED***:
        version, constraint = self._adjust_local(version, constraint, prefix***REMOVED***
        return version <= constraint

    def _match_ge(self, version, constraint, prefix***REMOVED***:
        version, constraint = self._adjust_local(version, constraint, prefix***REMOVED***
        return version >= constraint

    def _match_eq(self, version, constraint, prefix***REMOVED***:
        version, constraint = self._adjust_local(version, constraint, prefix***REMOVED***
        if not prefix:
            result = (version == constraint***REMOVED***
        else:
            result = _match_prefix(version, constraint***REMOVED***
        return result

    def _match_arbitrary(self, version, constraint, prefix***REMOVED***:
        return str(version***REMOVED*** == str(constraint***REMOVED***

    def _match_ne(self, version, constraint, prefix***REMOVED***:
        version, constraint = self._adjust_local(version, constraint, prefix***REMOVED***
        if not prefix:
            result = (version != constraint***REMOVED***
        else:
            result = not _match_prefix(version, constraint***REMOVED***
        return result

    def _match_compatible(self, version, constraint, prefix***REMOVED***:
        version, constraint = self._adjust_local(version, constraint, prefix***REMOVED***
        if version == constraint:
            return True
        if version < constraint:
            return False
#        if not prefix:
#            return True
        release_clause = constraint._release_clause
        if len(release_clause***REMOVED*** > 1:
            release_clause = release_clause[:-1***REMOVED***
        pfx = '.'.join([str(i***REMOVED*** for i in release_clause***REMOVED******REMOVED***
        return _match_prefix(version, pfx***REMOVED***

_REPLACEMENTS = (
    (re.compile('[.+-***REMOVED***$'***REMOVED***, ''***REMOVED***,                     # remove trailing puncts
    (re.compile(r'^[.***REMOVED***(\d***REMOVED***'***REMOVED***, r'0.\1'***REMOVED***,             # .N -> 0.N at start
    (re.compile('^[.-***REMOVED***'***REMOVED***, ''***REMOVED***,                      # remove leading puncts
    (re.compile(r'^\((.****REMOVED***\***REMOVED***$'***REMOVED***, r'\1'***REMOVED***,             # remove parentheses
    (re.compile(r'^v(ersion***REMOVED***?\s*(\d+***REMOVED***'***REMOVED***, r'\2'***REMOVED***,    # remove leading v(ersion***REMOVED***
    (re.compile(r'^r(ev***REMOVED***?\s*(\d+***REMOVED***'***REMOVED***, r'\2'***REMOVED***,        # remove leading v(ersion***REMOVED***
    (re.compile('[.***REMOVED***{2,***REMOVED***'***REMOVED***, '.'***REMOVED***,                   # multiple runs of '.'
    (re.compile(r'\b(alfa|apha***REMOVED***\b'***REMOVED***, 'alpha'***REMOVED***,      # misspelt alpha
    (re.compile(r'\b(pre-alpha|prealpha***REMOVED***\b'***REMOVED***,
                'pre.alpha'***REMOVED***,                       # standardise
    (re.compile(r'\(beta\***REMOVED***$'***REMOVED***, 'beta'***REMOVED***,             # remove parentheses
***REMOVED***

_SUFFIX_REPLACEMENTS = (
    (re.compile('^[:~._+-***REMOVED***+'***REMOVED***, ''***REMOVED***,                   # remove leading puncts
    (re.compile('[,*"***REMOVED***([\***REMOVED******REMOVED***'***REMOVED***, ''***REMOVED***,                   # remove unwanted chars
    (re.compile('[~:+_ -***REMOVED***'***REMOVED***, '.'***REMOVED***,                    # replace illegal chars
    (re.compile('[.***REMOVED***{2,***REMOVED***'***REMOVED***, '.'***REMOVED***,                   # multiple runs of '.'
    (re.compile(r'\.$'***REMOVED***, ''***REMOVED***,                       # trailing '.'
***REMOVED***

_NUMERIC_PREFIX = re.compile(r'(\d+(\.\d+***REMOVED*******REMOVED***'***REMOVED***


def _suggest_semantic_version(s***REMOVED***:
    ***REMOVED***
    Try to suggest a semantic form for a version for which
    _suggest_normalized_version couldn't come up with anything.
    ***REMOVED***
    result = s.strip(***REMOVED***.lower(***REMOVED***
    for pat, repl in _REPLACEMENTS:
        result = pat.sub(repl, result***REMOVED***
    if not result:
        result = '0.0.0'

    # Now look for numeric prefix, and separate it out from
    # the rest.
    #import pdb; pdb.set_trace(***REMOVED***
    m = _NUMERIC_PREFIX.match(result***REMOVED***
    if not m:
        prefix = '0.0.0'
        suffix = result
    else:
        prefix = m.groups(***REMOVED***[0***REMOVED***.split('.'***REMOVED***
        prefix = [int(i***REMOVED*** for i in prefix***REMOVED***
        while len(prefix***REMOVED*** < 3:
            prefix.append(0***REMOVED***
        if len(prefix***REMOVED*** == 3:
            suffix = result[m.end(***REMOVED***:***REMOVED***
        else:
            suffix = '.'.join([str(i***REMOVED*** for i in prefix[3:***REMOVED******REMOVED******REMOVED*** + result[m.end(***REMOVED***:***REMOVED***
            prefix = prefix[:3***REMOVED***
        prefix = '.'.join([str(i***REMOVED*** for i in prefix***REMOVED******REMOVED***
        suffix = suffix.strip(***REMOVED***
    if suffix:
        #import pdb; pdb.set_trace(***REMOVED***
        # massage the suffix.
        for pat, repl in _SUFFIX_REPLACEMENTS:
            suffix = pat.sub(repl, suffix***REMOVED***

    if not suffix:
        result = prefix
    else:
        sep = '-' if 'dev' in suffix else '+'
        result = prefix + sep + suffix
    if not is_semver(result***REMOVED***:
        result = None
    return result


def _suggest_normalized_version(s***REMOVED***:
    ***REMOVED***Suggest a normalized version close to the given version string.

    If you have a version string that isn't rational (i.e. NormalizedVersion
    doesn't like it***REMOVED*** then you might be able to get an equivalent (or close***REMOVED***
    rational version from this function.

    This does a number of simple normalizations to the given string, based
    on observation of versions currently in use on PyPI. Given a dump of
    those version during PyCon 2009, 4287 of them:
    - 2312 (53.93%***REMOVED*** match NormalizedVersion without change
      with the automatic suggestion
    - 3474 (81.04%***REMOVED*** match when using this suggestion method

    @param s {str***REMOVED*** An irrational version string.
    @returns A rational version string, or None, if couldn't determine one.
    ***REMOVED***
    ***REMOVED***
        _normalized_key(s***REMOVED***
        return s   # already rational
    except UnsupportedVersionError:
        pass

    rs = s.lower(***REMOVED***

    # part of this could use maketrans
    for orig, repl in (('-alpha', 'a'***REMOVED***, ('-beta', 'b'***REMOVED***, ('alpha', 'a'***REMOVED***,
                       ('beta', 'b'***REMOVED***, ('rc', 'c'***REMOVED***, ('-final', ''***REMOVED***,
                       ('-pre', 'c'***REMOVED***,
                       ('-release', ''***REMOVED***, ('.release', ''***REMOVED***, ('-stable', ''***REMOVED***,
                       ('+', '.'***REMOVED***, ('_', '.'***REMOVED***, (' ', ''***REMOVED***, ('.final', ''***REMOVED***,
                       ('final', ''***REMOVED******REMOVED***:
        rs = rs.replace(orig, repl***REMOVED***

    # if something ends with dev or pre, we add a 0
    rs = re.sub(r"pre$", r"pre0", rs***REMOVED***
    rs = re.sub(r"dev$", r"dev0", rs***REMOVED***

    # if we have something like "b-2" or "a.2" at the end of the
    # version, that is pobably beta, alpha, etc
    # let's remove the dash or dot
    rs = re.sub(r"([abc***REMOVED***|rc***REMOVED***[\-\.***REMOVED***(\d+***REMOVED***$", r"\1\2", rs***REMOVED***

    # 1.0-dev-r371 -> 1.0.dev371
    # 0.1-dev-r79 -> 0.1.dev79
    rs = re.sub(r"[\-\.***REMOVED***(dev***REMOVED***[\-\.***REMOVED***?r?(\d+***REMOVED***$", r".\1\2", rs***REMOVED***

    # Clean: 2.0.a.3, 2.0.b1, 0.9.0~c1
    rs = re.sub(r"[.~***REMOVED***?([abc***REMOVED******REMOVED***\.?", r"\1", rs***REMOVED***

    # Clean: v0.3, v1.0
    if rs.startswith('v'***REMOVED***:
        rs = rs[1:***REMOVED***

    # Clean leading '0's on numbers.
    #TODO: unintended side-effect on, e.g., "2003.05.09"
    # PyPI stats: 77 (~2%***REMOVED*** better
    rs = re.sub(r"\b0+(\d+***REMOVED***(?!\d***REMOVED***", r"\1", rs***REMOVED***

    # Clean a/b/c with no version. E.g. "1.0a" -> "1.0a0". Setuptools infers
    # zero.
    # PyPI stats: 245 (7.56%***REMOVED*** better
    rs = re.sub(r"(\d+[abc***REMOVED******REMOVED***$", r"\g<1>0", rs***REMOVED***

    # the 'dev-rNNN' tag is a dev tag
    rs = re.sub(r"\.?(dev-r|dev\.r***REMOVED***\.?(\d+***REMOVED***$", r".dev\2", rs***REMOVED***

    # clean the - when used as a pre delimiter
    rs = re.sub(r"-(a|b|c***REMOVED***(\d+***REMOVED***$", r"\1\2", rs***REMOVED***

    # a terminal "dev" or "devel" can be changed into ".dev0"
    rs = re.sub(r"[\.\-***REMOVED***(dev|devel***REMOVED***$", r".dev0", rs***REMOVED***

    # a terminal "dev" can be changed into ".dev0"
    rs = re.sub(r"(?![\.\-***REMOVED******REMOVED***dev$", r".dev0", rs***REMOVED***

    # a terminal "final" or "stable" can be removed
    rs = re.sub(r"(final|stable***REMOVED***$", "", rs***REMOVED***

    # The 'r' and the '-' tags are post release tags
    #   0.4a1.r10       ->  0.4a1.post10
    #   0.9.33-17222    ->  0.9.33.post17222
    #   0.9.33-r17222   ->  0.9.33.post17222
    rs = re.sub(r"\.?(r|-|-r***REMOVED***\.?(\d+***REMOVED***$", r".post\2", rs***REMOVED***

    # Clean 'r' instead of 'dev' usage:
    #   0.9.33+r17222   ->  0.9.33.dev17222
    #   1.0dev123       ->  1.0.dev123
    #   1.0.git123      ->  1.0.dev123
    #   1.0.bzr123      ->  1.0.dev123
    #   0.1a0dev.123    ->  0.1a0.dev123
    # PyPI stats:  ~150 (~4%***REMOVED*** better
    rs = re.sub(r"\.?(dev|git|bzr***REMOVED***\.?(\d+***REMOVED***$", r".dev\2", rs***REMOVED***

    # Clean '.pre' (normalized from '-pre' above***REMOVED*** instead of 'c' usage:
    #   0.2.pre1        ->  0.2c1
    #   0.2-c1         ->  0.2c1
    #   1.0preview123   ->  1.0c123
    # PyPI stats: ~21 (0.62%***REMOVED*** better
    rs = re.sub(r"\.?(pre|preview|-c***REMOVED***(\d+***REMOVED***$", r"c\g<2>", rs***REMOVED***

    # Tcl/Tk uses "px" for their post release markers
    rs = re.sub(r"p(\d+***REMOVED***$", r".post\1", rs***REMOVED***

    ***REMOVED***
        _normalized_key(rs***REMOVED***
    except UnsupportedVersionError:
        rs = None
    return rs

#
#   Legacy version processing (distribute-compatible***REMOVED***
#

_VERSION_PART = re.compile(r'([a-z***REMOVED***+|\d+|[\.-***REMOVED******REMOVED***', re.I***REMOVED***
_VERSION_REPLACE = {
    'pre': 'c',
    'preview': 'c',
    '-': 'final-',
    'rc': 'c',
    'dev': '@',
    '': None,
    '.': None,
***REMOVED***


def _legacy_key(s***REMOVED***:
    def get_parts(s***REMOVED***:
        result = [***REMOVED***
        for p in _VERSION_PART.split(s.lower(***REMOVED******REMOVED***:
            p = _VERSION_REPLACE.get(p, p***REMOVED***
            if p:
                if '0' <= p[:1***REMOVED*** <= '9':
                    p = p.zfill(8***REMOVED***
                else:
                    p = '*' + p
                result.append(p***REMOVED***
        result.append('*final'***REMOVED***
        return result

    result = [***REMOVED***
    for p in get_parts(s***REMOVED***:
        if p.startswith('*'***REMOVED***:
            if p < '*final':
                while result and result[-1***REMOVED*** == '*final-':
                    result.pop(***REMOVED***
            while result and result[-1***REMOVED*** == '00000000':
                result.pop(***REMOVED***
        result.append(p***REMOVED***
    return tuple(result***REMOVED***


class LegacyVersion(Version***REMOVED***:
    def parse(self, s***REMOVED***:
        return _legacy_key(s***REMOVED***

    @property
    def is_prerelease(self***REMOVED***:
        result = False
        for x in self._parts:
            if (isinstance(x, string_types***REMOVED*** and x.startswith('*'***REMOVED*** and
                x < '*final'***REMOVED***:
                result = True
                break
        return result


class LegacyMatcher(Matcher***REMOVED***:
    version_class = LegacyVersion

    _operators = dict(Matcher._operators***REMOVED***
    _operators['~='***REMOVED*** = '_match_compatible'

    numeric_re = re.compile('^(\d+(\.\d+***REMOVED*******REMOVED***'***REMOVED***

    def _match_compatible(self, version, constraint, prefix***REMOVED***:
        if version < constraint:
            return False
        m = self.numeric_re.match(str(constraint***REMOVED******REMOVED***
        if not m:
            logger.warning('Cannot compute compatible match for version %s '
                           ' and constraint %s', version, constraint***REMOVED***
            return True
        s = m.groups(***REMOVED***[0***REMOVED***
        if '.' in s:
            s = s.rsplit('.', 1***REMOVED***[0***REMOVED***
        return _match_prefix(version, s***REMOVED***

#
#   Semantic versioning
#

_SEMVER_RE = re.compile(r'^(\d+***REMOVED***\.(\d+***REMOVED***\.(\d+***REMOVED***'
                        r'(-[a-z0-9***REMOVED***+(\.[a-z0-9-***REMOVED***+***REMOVED*******REMOVED***?'
                        r'(\+[a-z0-9***REMOVED***+(\.[a-z0-9-***REMOVED***+***REMOVED*******REMOVED***?$', re.I***REMOVED***


def is_semver(s***REMOVED***:
    return _SEMVER_RE.match(s***REMOVED***


def _semantic_key(s***REMOVED***:
    def make_tuple(s, absent***REMOVED***:
        if s is None:
            result = (absent,***REMOVED***
        else:
            parts = s[1:***REMOVED***.split('.'***REMOVED***
            # We can't compare ints and strings on Python 3, so fudge it
            # by zero-filling numeric values so simulate a numeric comparison
            result = tuple([p.zfill(8***REMOVED*** if p.isdigit(***REMOVED*** else p for p in parts***REMOVED******REMOVED***
        return result

    m = is_semver(s***REMOVED***
    if not m:
        raise UnsupportedVersionError(s***REMOVED***
    groups = m.groups(***REMOVED***
    major, minor, patch = [int(i***REMOVED*** for i in groups[:3***REMOVED******REMOVED***
    # choose the '|' and '*' so that versions sort correctly
    pre, build = make_tuple(groups[3***REMOVED***, '|'***REMOVED***, make_tuple(groups[5***REMOVED***, '*'***REMOVED***
    return (major, minor, patch***REMOVED***, pre, build


class SemanticVersion(Version***REMOVED***:
    def parse(self, s***REMOVED***:
        return _semantic_key(s***REMOVED***

    @property
    def is_prerelease(self***REMOVED***:
        return self._parts[1***REMOVED***[0***REMOVED*** != '|'


class SemanticMatcher(Matcher***REMOVED***:
    version_class = SemanticVersion


class VersionScheme(object***REMOVED***:
    def __init__(self, key, matcher, suggester=None***REMOVED***:
        self.key = key
        self.matcher = matcher
        self.suggester = suggester

    def is_valid_version(self, s***REMOVED***:
        ***REMOVED***
            self.matcher.version_class(s***REMOVED***
            result = True
        except UnsupportedVersionError:
            result = False
        return result

    def is_valid_matcher(self, s***REMOVED***:
        ***REMOVED***
            self.matcher(s***REMOVED***
            result = True
        except UnsupportedVersionError:
            result = False
        return result

    def is_valid_constraint_list(self, s***REMOVED***:
        ***REMOVED***
        Used for processing some metadata fields
        ***REMOVED***
        return self.is_valid_matcher('dummy_name (%s***REMOVED***' % s***REMOVED***

    def suggest(self, s***REMOVED***:
        if self.suggester is None:
            result = None
        else:
            result = self.suggester(s***REMOVED***
        return result

_SCHEMES = {
    'normalized': VersionScheme(_normalized_key, NormalizedMatcher,
                                _suggest_normalized_version***REMOVED***,
    'legacy': VersionScheme(_legacy_key, LegacyMatcher, lambda self, s: s***REMOVED***,
    'semantic': VersionScheme(_semantic_key, SemanticMatcher,
                              _suggest_semantic_version***REMOVED***,
***REMOVED***

_SCHEMES['default'***REMOVED*** = _SCHEMES['normalized'***REMOVED***


def get_scheme(name***REMOVED***:
    if name not in _SCHEMES:
        raise ValueError('unknown scheme name: %r' % name***REMOVED***
    return _SCHEMES[name***REMOVED***
