# -*- coding: utf-8 -*-
#
# Copyright (C***REMOVED*** 2012 The Python Software Foundation.
# See LICENSE.txt and CONTRIBUTORS.txt.
#
***REMOVED***Access to Python's configuration information.***REMOVED***

import codecs
***REMOVED***
import re
import sys
from os.path import pardir, realpath
***REMOVED***
    import configparser
except ImportError:
    import ConfigParser as configparser


__all__ = [
    'get_config_h_filename',
    'get_config_var',
    'get_config_vars',
    'get_makefile_filename',
    'get_path',
    'get_path_names',
    'get_paths',
    'get_platform',
    'get_python_version',
    'get_scheme_names',
    'parse_config_h',
***REMOVED***


def _safe_realpath(path***REMOVED***:
    ***REMOVED***
        return realpath(path***REMOVED***
    except OSError:
        return path


if sys.executable:
    _PROJECT_BASE = os.path.dirname(_safe_realpath(sys.executable***REMOVED******REMOVED***
else:
    # sys.executable can be empty if argv[0***REMOVED*** has been changed and Python is
    # unable to retrieve the real program name
    _PROJECT_BASE = _safe_realpath(os.getcwd(***REMOVED******REMOVED***

if os.name == "nt" and "pcbuild" in _PROJECT_BASE[-8:***REMOVED***.lower(***REMOVED***:
    _PROJECT_BASE = _safe_realpath(os.path.join(_PROJECT_BASE, pardir***REMOVED******REMOVED***
# PC/VS7.1
if os.name == "nt" and "\\pc\\v" in _PROJECT_BASE[-10:***REMOVED***.lower(***REMOVED***:
    _PROJECT_BASE = _safe_realpath(os.path.join(_PROJECT_BASE, pardir, pardir***REMOVED******REMOVED***
# PC/AMD64
if os.name == "nt" and "\\pcbuild\\amd64" in _PROJECT_BASE[-14:***REMOVED***.lower(***REMOVED***:
    _PROJECT_BASE = _safe_realpath(os.path.join(_PROJECT_BASE, pardir, pardir***REMOVED******REMOVED***


def is_python_build(***REMOVED***:
    for fn in ("Setup.dist", "Setup.local"***REMOVED***:
        if os.path.isfile(os.path.join(_PROJECT_BASE, "Modules", fn***REMOVED******REMOVED***:
            return True
    return False

_PYTHON_BUILD = is_python_build(***REMOVED***

_cfg_read = False

def _ensure_cfg_read(***REMOVED***:
    global _cfg_read
    if not _cfg_read:
        from ..resources import finder
        backport_package = __name__.rsplit('.', 1***REMOVED***[0***REMOVED***
        _finder = finder(backport_package***REMOVED***
        _cfgfile = _finder.find('sysconfig.cfg'***REMOVED***
        assert _cfgfile, 'sysconfig.cfg exists'
        with _cfgfile.as_stream(***REMOVED*** as s:
            _SCHEMES.readfp(s***REMOVED***
        if _PYTHON_BUILD:
            for scheme in ('posix_prefix', 'posix_home'***REMOVED***:
                _SCHEMES.set(scheme, 'include', '{srcdir***REMOVED***/Include'***REMOVED***
                _SCHEMES.set(scheme, 'platinclude', '{projectbase***REMOVED***/.'***REMOVED***

        _cfg_read = True


_SCHEMES = configparser.RawConfigParser(***REMOVED***
_VAR_REPL = re.compile(r'\{([^{***REMOVED****?***REMOVED***\***REMOVED***'***REMOVED***

def _expand_globals(config***REMOVED***:
    _ensure_cfg_read(***REMOVED***
    if config.has_section('globals'***REMOVED***:
        globals = config.items('globals'***REMOVED***
    else:
        globals = tuple(***REMOVED***

    sections = config.sections(***REMOVED***
    for section in sections:
        if section == 'globals':
            continue
        for option, value in globals:
            if config.has_option(section, option***REMOVED***:
                continue
            config.set(section, option, value***REMOVED***
    config.remove_section('globals'***REMOVED***

    # now expanding local variables defined in the cfg file
    #
    for section in config.sections(***REMOVED***:
        variables = dict(config.items(section***REMOVED******REMOVED***

        def _replacer(matchobj***REMOVED***:
            name = matchobj.group(1***REMOVED***
            if name in variables:
                return variables[name***REMOVED***
            return matchobj.group(0***REMOVED***

        for option, value in config.items(section***REMOVED***:
            config.set(section, option, _VAR_REPL.sub(_replacer, value***REMOVED******REMOVED***

#_expand_globals(_SCHEMES***REMOVED***

 # FIXME don't rely on sys.version here, its format is an implementation detail
 # of CPython, use sys.version_info or sys.hexversion
_PY_VERSION = sys.version.split(***REMOVED***[0***REMOVED***
_PY_VERSION_SHORT = sys.version[:3***REMOVED***
_PY_VERSION_SHORT_NO_DOT = _PY_VERSION[0***REMOVED*** + _PY_VERSION[2***REMOVED***
_PREFIX = os.path.normpath(sys.prefix***REMOVED***
_EXEC_PREFIX = os.path.normpath(sys.exec_prefix***REMOVED***
_CONFIG_VARS = None
_USER_BASE = None


def _subst_vars(path, local_vars***REMOVED***:
    ***REMOVED***In the string `path`, replace tokens like {some.thing***REMOVED*** with the
    corresponding value from the map `local_vars`.

    If there is no corresponding value, leave the token unchanged.
    ***REMOVED***
    def _replacer(matchobj***REMOVED***:
        name = matchobj.group(1***REMOVED***
        if name in local_vars:
            return local_vars[name***REMOVED***
        elif name in os.environ:
            return os.environ[name***REMOVED***
        return matchobj.group(0***REMOVED***
    return _VAR_REPL.sub(_replacer, path***REMOVED***


def _extend_dict(target_dict, other_dict***REMOVED***:
    target_keys = target_dict.keys(***REMOVED***
    for key, value in other_dict.items(***REMOVED***:
        if key in target_keys:
            continue
        target_dict[key***REMOVED*** = value


def _expand_vars(scheme, vars***REMOVED***:
    res = {***REMOVED***
    if vars is None:
        vars = {***REMOVED***
    _extend_dict(vars, get_config_vars(***REMOVED******REMOVED***

    for key, value in _SCHEMES.items(scheme***REMOVED***:
        if os.name in ('posix', 'nt'***REMOVED***:
            value = os.path.expanduser(value***REMOVED***
        res[key***REMOVED*** = os.path.normpath(_subst_vars(value, vars***REMOVED******REMOVED***
    return res


def format_value(value, vars***REMOVED***:
    def _replacer(matchobj***REMOVED***:
        name = matchobj.group(1***REMOVED***
        if name in vars:
            return vars[name***REMOVED***
        return matchobj.group(0***REMOVED***
    return _VAR_REPL.sub(_replacer, value***REMOVED***


def _get_default_scheme(***REMOVED***:
    if os.name == 'posix':
        # the default scheme for posix is posix_prefix
        return 'posix_prefix'
    return os.name


def _getuserbase(***REMOVED***:
    env_base = os.environ.get("PYTHONUSERBASE", None***REMOVED***

    def joinuser(*args***REMOVED***:
        return os.path.expanduser(os.path.join(*args***REMOVED******REMOVED***

    # what about 'os2emx', 'riscos' ?
    if os.name == "nt":
        base = os.environ.get("APPDATA"***REMOVED*** or "~"
        if env_base:
            return env_base
        else:
            return joinuser(base, "Python"***REMOVED***

    if sys.platform == "darwin":
        framework = get_config_var("PYTHONFRAMEWORK"***REMOVED***
        if framework:
            if env_base:
                return env_base
            else:
                return joinuser("~", "Library", framework, "%d.%d" %
                                sys.version_info[:2***REMOVED******REMOVED***

    if env_base:
        return env_base
    else:
        return joinuser("~", ".local"***REMOVED***


def _parse_makefile(filename, vars=None***REMOVED***:
    ***REMOVED***Parse a Makefile-style file.

    A dictionary containing name/value pairs is returned.  If an
    optional dictionary is passed in as the second argument, it is
    used instead of a new dictionary.
    ***REMOVED***
    # Regexes needed for parsing Makefile (and similar syntaxes,
    # like old-style Setup files***REMOVED***.
    _variable_rx = re.compile("([a-zA-Z***REMOVED***[a-zA-Z0-9_***REMOVED***+***REMOVED***\s*=\s*(.****REMOVED***"***REMOVED***
    _findvar1_rx = re.compile(r"\$\(([A-Za-z***REMOVED***[A-Za-z0-9_***REMOVED*******REMOVED***\***REMOVED***"***REMOVED***
    _findvar2_rx = re.compile(r"\${([A-Za-z***REMOVED***[A-Za-z0-9_***REMOVED*******REMOVED******REMOVED***"***REMOVED***

    if vars is None:
        vars = {***REMOVED***
    done = {***REMOVED***
    notdone = {***REMOVED***

    with codecs.open(filename, encoding='utf-8', errors="surrogateescape"***REMOVED*** as f:
        lines = f.readlines(***REMOVED***

    for line in lines:
        if line.startswith('#'***REMOVED*** or line.strip(***REMOVED*** == '':
            continue
        m = _variable_rx.match(line***REMOVED***
        if m:
            n, v = m.group(1, 2***REMOVED***
            v = v.strip(***REMOVED***
            # `$$' is a literal `$' in make
            tmpv = v.replace('$$', ''***REMOVED***

            if "$" in tmpv:
                notdone[n***REMOVED*** = v
            else:
                ***REMOVED***
                    v = int(v***REMOVED***
                except ValueError:
                    # insert literal `$'
                    done[n***REMOVED*** = v.replace('$$', '$'***REMOVED***
                else:
                    done[n***REMOVED*** = v

    # do variable interpolation here
    variables = list(notdone.keys(***REMOVED******REMOVED***

    # Variables with a 'PY_' prefix in the makefile. These need to
    # be made available without that prefix through sysconfig.
    # Special care is needed to ensure that variable expansion works, even
    # if the expansion uses the name without a prefix.
    renamed_variables = ('CFLAGS', 'LDFLAGS', 'CPPFLAGS'***REMOVED***

    while len(variables***REMOVED*** > 0:
        for name in tuple(variables***REMOVED***:
            value = notdone[name***REMOVED***
            m = _findvar1_rx.search(value***REMOVED*** or _findvar2_rx.search(value***REMOVED***
            if m is not None:
                n = m.group(1***REMOVED***
                found = True
                if n in done:
                    item = str(done[n***REMOVED******REMOVED***
                elif n in notdone:
                    # get it on a subsequent round
                    found = False
                elif n in os.environ:
                    # do it like make: fall back to environment
                    item = os.environ[n***REMOVED***

                elif n in renamed_variables:
                    if (name.startswith('PY_'***REMOVED*** and
                        name[3:***REMOVED*** in renamed_variables***REMOVED***:
                        item = ""

                    elif 'PY_' + n in notdone:
                        found = False

                    else:
                        item = str(done['PY_' + n***REMOVED******REMOVED***

                else:
                    done[n***REMOVED*** = item = ""

                if found:
                    after = value[m.end(***REMOVED***:***REMOVED***
                    value = value[:m.start(***REMOVED******REMOVED*** + item + after
                    if "$" in after:
                        notdone[name***REMOVED*** = value
                    else:
                        ***REMOVED***
                            value = int(value***REMOVED***
                        except ValueError:
                            done[name***REMOVED*** = value.strip(***REMOVED***
                        else:
                            done[name***REMOVED*** = value
                        variables.remove(name***REMOVED***

                        if (name.startswith('PY_'***REMOVED*** and
                            name[3:***REMOVED*** in renamed_variables***REMOVED***:

                            name = name[3:***REMOVED***
                            if name not in done:
                                done[name***REMOVED*** = value

            else:
                # bogus variable reference (e.g. "prefix=$/opt/python"***REMOVED***;
                # just drop it since we can't deal
                done[name***REMOVED*** = value
                variables.remove(name***REMOVED***

    # strip spurious spaces
    for k, v in done.items(***REMOVED***:
        if isinstance(v, str***REMOVED***:
            done[k***REMOVED*** = v.strip(***REMOVED***

    # save the results in the global dictionary
    vars.update(done***REMOVED***
    return vars


def get_makefile_filename(***REMOVED***:
    ***REMOVED***Return the path of the Makefile.***REMOVED***
    if _PYTHON_BUILD:
        return os.path.join(_PROJECT_BASE, "Makefile"***REMOVED***
    if hasattr(sys, 'abiflags'***REMOVED***:
        config_dir_name = 'config-%s%s' % (_PY_VERSION_SHORT, sys.abiflags***REMOVED***
    else:
        config_dir_name = 'config'
    return os.path.join(get_path('stdlib'***REMOVED***, config_dir_name, 'Makefile'***REMOVED***


def _init_posix(vars***REMOVED***:
    ***REMOVED***Initialize the module as appropriate for POSIX systems.***REMOVED***
    # load the installed Makefile:
    makefile = get_makefile_filename(***REMOVED***
    ***REMOVED***
        _parse_makefile(makefile, vars***REMOVED***
    except IOError as e:
        msg = "invalid Python installation: unable to open %s" % makefile
        if hasattr(e, "strerror"***REMOVED***:
            msg = msg + " (%s***REMOVED***" % e.strerror
        raise IOError(msg***REMOVED***
    # load the installed pyconfig.h:
    config_h = get_config_h_filename(***REMOVED***
    ***REMOVED***
        with open(config_h***REMOVED*** as f:
            parse_config_h(f, vars***REMOVED***
    except IOError as e:
        msg = "invalid Python installation: unable to open %s" % config_h
        if hasattr(e, "strerror"***REMOVED***:
            msg = msg + " (%s***REMOVED***" % e.strerror
        raise IOError(msg***REMOVED***
    # On AIX, there are wrong paths to the linker scripts in the Makefile
    # -- these paths are relative to the Python source, but when installed
    # the scripts are in another directory.
    if _PYTHON_BUILD:
        vars['LDSHARED'***REMOVED*** = vars['BLDSHARED'***REMOVED***


def _init_non_posix(vars***REMOVED***:
    ***REMOVED***Initialize the module as appropriate for NT***REMOVED***
    # set basic install directories
    vars['LIBDEST'***REMOVED*** = get_path('stdlib'***REMOVED***
    vars['BINLIBDEST'***REMOVED*** = get_path('platstdlib'***REMOVED***
    vars['INCLUDEPY'***REMOVED*** = get_path('include'***REMOVED***
    vars['SO'***REMOVED*** = '.pyd'
    vars['EXE'***REMOVED*** = '.exe'
    vars['VERSION'***REMOVED*** = _PY_VERSION_SHORT_NO_DOT
    vars['BINDIR'***REMOVED*** = os.path.dirname(_safe_realpath(sys.executable***REMOVED******REMOVED***

#
# public APIs
#


def parse_config_h(fp, vars=None***REMOVED***:
    ***REMOVED***Parse a config.h-style file.

    A dictionary containing name/value pairs is returned.  If an
    optional dictionary is passed in as the second argument, it is
    used instead of a new dictionary.
    ***REMOVED***
    if vars is None:
        vars = {***REMOVED***
    define_rx = re.compile("#define ([A-Z***REMOVED***[A-Za-z0-9_***REMOVED***+***REMOVED*** (.****REMOVED***\n"***REMOVED***
    undef_rx = re.compile("/[****REMOVED*** #undef ([A-Z***REMOVED***[A-Za-z0-9_***REMOVED***+***REMOVED*** [****REMOVED***/\n"***REMOVED***

    while True:
        line = fp.readline(***REMOVED***
        if not line:
            break
        m = define_rx.match(line***REMOVED***
        if m:
            n, v = m.group(1, 2***REMOVED***
            ***REMOVED***
                v = int(v***REMOVED***
            except ValueError:
                pass
            vars[n***REMOVED*** = v
        else:
            m = undef_rx.match(line***REMOVED***
            if m:
                vars[m.group(1***REMOVED******REMOVED*** = 0
    return vars


def get_config_h_filename(***REMOVED***:
    ***REMOVED***Return the path of pyconfig.h.***REMOVED***
    if _PYTHON_BUILD:
        if os.name == "nt":
            inc_dir = os.path.join(_PROJECT_BASE, "PC"***REMOVED***
        else:
            inc_dir = _PROJECT_BASE
    else:
        inc_dir = get_path('platinclude'***REMOVED***
    return os.path.join(inc_dir, 'pyconfig.h'***REMOVED***


def get_scheme_names(***REMOVED***:
    ***REMOVED***Return a tuple containing the schemes names.***REMOVED***
    return tuple(sorted(_SCHEMES.sections(***REMOVED******REMOVED******REMOVED***


def get_path_names(***REMOVED***:
    ***REMOVED***Return a tuple containing the paths names.***REMOVED***
    # xxx see if we want a static list
    return _SCHEMES.options('posix_prefix'***REMOVED***


def get_paths(scheme=_get_default_scheme(***REMOVED***, vars=None, expand=True***REMOVED***:
    ***REMOVED***Return a mapping containing an install scheme.

    ``scheme`` is the install scheme name. If not provided, it will
    return the default scheme for the current platform.
    ***REMOVED***
    _ensure_cfg_read(***REMOVED***
    if expand:
        return _expand_vars(scheme, vars***REMOVED***
    else:
        return dict(_SCHEMES.items(scheme***REMOVED******REMOVED***


def get_path(name, scheme=_get_default_scheme(***REMOVED***, vars=None, expand=True***REMOVED***:
    ***REMOVED***Return a path corresponding to the scheme.

    ``scheme`` is the install scheme name.
    ***REMOVED***
    return get_paths(scheme, vars, expand***REMOVED***[name***REMOVED***


def get_config_vars(*args***REMOVED***:
    ***REMOVED***With no arguments, return a dictionary of all configuration
    variables relevant for the current platform.

    On Unix, this means every variable defined in Python's installed Makefile;
    On Windows and Mac OS it's a much smaller set.

    With arguments, return a list of values that result from looking up
    each argument in the configuration variable dictionary.
    ***REMOVED***
    global _CONFIG_VARS
    if _CONFIG_VARS is None:
        _CONFIG_VARS = {***REMOVED***
        # Normalized versions of prefix and exec_prefix are handy to have;
        # in fact, these are the standard versions used most places in the
        # distutils2 module.
        _CONFIG_VARS['prefix'***REMOVED*** = _PREFIX
        _CONFIG_VARS['exec_prefix'***REMOVED*** = _EXEC_PREFIX
        _CONFIG_VARS['py_version'***REMOVED*** = _PY_VERSION
        _CONFIG_VARS['py_version_short'***REMOVED*** = _PY_VERSION_SHORT
        _CONFIG_VARS['py_version_nodot'***REMOVED*** = _PY_VERSION[0***REMOVED*** + _PY_VERSION[2***REMOVED***
        _CONFIG_VARS['base'***REMOVED*** = _PREFIX
        _CONFIG_VARS['platbase'***REMOVED*** = _EXEC_PREFIX
        _CONFIG_VARS['projectbase'***REMOVED*** = _PROJECT_BASE
        ***REMOVED***
            _CONFIG_VARS['abiflags'***REMOVED*** = sys.abiflags
        except AttributeError:
            # sys.abiflags may not be defined on all platforms.
            _CONFIG_VARS['abiflags'***REMOVED*** = ''

        if os.name in ('nt', 'os2'***REMOVED***:
            _init_non_posix(_CONFIG_VARS***REMOVED***
        if os.name == 'posix':
            _init_posix(_CONFIG_VARS***REMOVED***
        # Setting 'userbase' is done below the call to the
        # init function to enable using 'get_config_var' in
        # the init-function.
        if sys.version >= '2.6':
            _CONFIG_VARS['userbase'***REMOVED*** = _getuserbase(***REMOVED***

        if 'srcdir' not in _CONFIG_VARS:
            _CONFIG_VARS['srcdir'***REMOVED*** = _PROJECT_BASE
        else:
            _CONFIG_VARS['srcdir'***REMOVED*** = _safe_realpath(_CONFIG_VARS['srcdir'***REMOVED******REMOVED***

        # Convert srcdir into an absolute path if it appears necessary.
        # Normally it is relative to the build directory.  However, during
        # testing, for example, we might be running a non-installed python
        # from a different directory.
        if _PYTHON_BUILD and os.name == "posix":
            base = _PROJECT_BASE
            ***REMOVED***
                cwd = os.getcwd(***REMOVED***
            except OSError:
                cwd = None
            if (not os.path.isabs(_CONFIG_VARS['srcdir'***REMOVED******REMOVED*** and
                base != cwd***REMOVED***:
                # srcdir is relative and we are not in the same directory
                # as the executable. Assume executable is in the build
                # directory and make srcdir absolute.
                srcdir = os.path.join(base, _CONFIG_VARS['srcdir'***REMOVED******REMOVED***
                _CONFIG_VARS['srcdir'***REMOVED*** = os.path.normpath(srcdir***REMOVED***

        if sys.platform == 'darwin':
            kernel_version = os.uname(***REMOVED***[2***REMOVED***  # Kernel version (8.4.3***REMOVED***
            major_version = int(kernel_version.split('.'***REMOVED***[0***REMOVED******REMOVED***

            if major_version < 8:
                # On Mac OS X before 10.4, check if -arch and -isysroot
                # are in CFLAGS or LDFLAGS and remove them if they are.
                # This is needed when building extensions on a 10.3 system
                # using a universal build of python.
                for key in ('LDFLAGS', 'BASECFLAGS',
                        # a number of derived variables. These need to be
                        # patched up as well.
                        'CFLAGS', 'PY_CFLAGS', 'BLDSHARED'***REMOVED***:
                    flags = _CONFIG_VARS[key***REMOVED***
                    flags = re.sub('-arch\s+\w+\s', ' ', flags***REMOVED***
                    flags = re.sub('-isysroot [^ \t***REMOVED****', ' ', flags***REMOVED***
                    _CONFIG_VARS[key***REMOVED*** = flags
            else:
                # Allow the user to override the architecture flags using
                # an environment variable.
                # NOTE: This name was introduced by Apple in OSX 10.5 and
                # is used by several scripting languages distributed with
                # that OS release.
                if 'ARCHFLAGS' in os.environ:
                    arch = os.environ['ARCHFLAGS'***REMOVED***
                    for key in ('LDFLAGS', 'BASECFLAGS',
                        # a number of derived variables. These need to be
                        # patched up as well.
                        'CFLAGS', 'PY_CFLAGS', 'BLDSHARED'***REMOVED***:

                        flags = _CONFIG_VARS[key***REMOVED***
                        flags = re.sub('-arch\s+\w+\s', ' ', flags***REMOVED***
                        flags = flags + ' ' + arch
                        _CONFIG_VARS[key***REMOVED*** = flags

                # If we're on OSX 10.5 or later and the user tries to
                # compiles an extension using an SDK that is not present
                # on the current machine it is better to not use an SDK
                # than to fail.
                #
                # The major usecase for this is users using a Python.org
                # binary installer  on OSX 10.6: that installer uses
                # the 10.4u SDK, but that SDK is not installed by default
                # when you install Xcode.
                #
                CFLAGS = _CONFIG_VARS.get('CFLAGS', ''***REMOVED***
                m = re.search('-isysroot\s+(\S+***REMOVED***', CFLAGS***REMOVED***
                if m is not None:
                    sdk = m.group(1***REMOVED***
                    if not os.path.exists(sdk***REMOVED***:
                        for key in ('LDFLAGS', 'BASECFLAGS',
                             # a number of derived variables. These need to be
                             # patched up as well.
                            'CFLAGS', 'PY_CFLAGS', 'BLDSHARED'***REMOVED***:

                            flags = _CONFIG_VARS[key***REMOVED***
                            flags = re.sub('-isysroot\s+\S+(\s|$***REMOVED***', ' ', flags***REMOVED***
                            _CONFIG_VARS[key***REMOVED*** = flags

    if args:
        vals = [***REMOVED***
        for name in args:
            vals.append(_CONFIG_VARS.get(name***REMOVED******REMOVED***
        return vals
    else:
        return _CONFIG_VARS


def get_config_var(name***REMOVED***:
    ***REMOVED***Return the value of a single variable using the dictionary returned by
    'get_config_vars(***REMOVED***'.

    Equivalent to get_config_vars(***REMOVED***.get(name***REMOVED***
    ***REMOVED***
    return get_config_vars(***REMOVED***.get(name***REMOVED***


def get_platform(***REMOVED***:
    ***REMOVED***Return a string that identifies the current platform.

    This is used mainly to distinguish platform-specific build directories and
    platform-specific built distributions.  Typically includes the OS name
    and version and the architecture (as supplied by 'os.uname(***REMOVED***'***REMOVED***,
    although the exact information included depends on the OS; eg. for IRIX
    the architecture isn't particularly important (IRIX only runs on SGI
    hardware***REMOVED***, but for Linux the kernel version isn't particularly
    important.

    Examples of returned values:
       linux-i586
       linux-alpha (?***REMOVED***
       solaris-2.6-sun4u
       irix-5.3
       irix64-6.2

    Windows will return one of:
       win-amd64 (64bit Windows on AMD64 (aka x86_64, Intel64, EM64T, etc***REMOVED***
       win-ia64 (64bit Windows on Itanium***REMOVED***
       win32 (all others - specifically, sys.platform is returned***REMOVED***

    For other non-POSIX platforms, currently just returns 'sys.platform'.
    ***REMOVED***
    if os.name == 'nt':
        # sniff sys.version for architecture.
        prefix = " bit ("
        i = sys.version.find(prefix***REMOVED***
        if i == -1:
            return sys.platform
        j = sys.version.find("***REMOVED***", i***REMOVED***
        look = sys.version[i+len(prefix***REMOVED***:j***REMOVED***.lower(***REMOVED***
        if look == 'amd64':
            return 'win-amd64'
        if look == 'itanium':
            return 'win-ia64'
        return sys.platform

    if os.name != "posix" or not hasattr(os, 'uname'***REMOVED***:
        # XXX what about the architecture? NT is Intel or Alpha,
        # Mac OS is M68k or PPC, etc.
        return sys.platform

    # Try to distinguish various flavours of Unix
    osname, host, release, version, machine = os.uname(***REMOVED***

    # Convert the OS name to lowercase, remove '/' characters
    # (to accommodate BSD/OS***REMOVED***, and translate spaces (for "Power Macintosh"***REMOVED***
    osname = osname.lower(***REMOVED***.replace('/', ''***REMOVED***
    machine = machine.replace(' ', '_'***REMOVED***
    machine = machine.replace('/', '-'***REMOVED***

    if osname[:5***REMOVED*** == "linux":
        # At least on Linux/Intel, 'machine' is the processor --
        # i386, etc.
        # XXX what about Alpha, SPARC, etc?
        return  "%s-%s" % (osname, machine***REMOVED***
    elif osname[:5***REMOVED*** == "sunos":
        if release[0***REMOVED*** >= "5":           # SunOS 5 == Solaris 2
            osname = "solaris"
            release = "%d.%s" % (int(release[0***REMOVED******REMOVED*** - 3, release[2:***REMOVED******REMOVED***
        # fall through to standard osname-release-machine representation
    elif osname[:4***REMOVED*** == "irix":              # could be "irix64"!
        return "%s-%s" % (osname, release***REMOVED***
    elif osname[:3***REMOVED*** == "aix":
        return "%s-%s.%s" % (osname, version, release***REMOVED***
    elif osname[:6***REMOVED*** == "cygwin":
        osname = "cygwin"
        rel_re = re.compile(r'[\d.***REMOVED***+'***REMOVED***
        m = rel_re.match(release***REMOVED***
        if m:
            release = m.group(***REMOVED***
    elif osname[:6***REMOVED*** == "darwin":
        #
        # For our purposes, we'll assume that the system version from
        # distutils' perspective is what MACOSX_DEPLOYMENT_TARGET is set
        # to. This makes the compatibility story a bit more sane because the
        # machine is going to compile and link as if it were
        # MACOSX_DEPLOYMENT_TARGET.
        cfgvars = get_config_vars(***REMOVED***
        macver = cfgvars.get('MACOSX_DEPLOYMENT_TARGET'***REMOVED***

        if True:
            # Always calculate the release of the running machine,
            # needed to determine if we can build fat binaries or not.

            macrelease = macver
            # Get the system version. Reading this plist is a documented
            # way to get the system version (see the documentation for
            # the Gestalt Manager***REMOVED***
            ***REMOVED***
                f = open('/System/Library/CoreServices/SystemVersion.plist'***REMOVED***
            except IOError:
                # We're on a plain darwin box, fall back to the default
                # behaviour.
                pass
            else:
                ***REMOVED***
                    m = re.search(r'<key>ProductUserVisibleVersion</key>\s*'
                                  r'<string>(.*?***REMOVED***</string>', f.read(***REMOVED******REMOVED***
                finally:
                    f.close(***REMOVED***
                if m is not None:
                    macrelease = '.'.join(m.group(1***REMOVED***.split('.'***REMOVED***[:2***REMOVED******REMOVED***
                # else: fall back to the default behaviour

        if not macver:
            macver = macrelease

        if macver:
            release = macver
            osname = "macosx"

            if ((macrelease + '.'***REMOVED*** >= '10.4.' and
                '-arch' in get_config_vars(***REMOVED***.get('CFLAGS', ''***REMOVED***.strip(***REMOVED******REMOVED***:
                # The universal build will build fat binaries, but not on
                # systems before 10.4
                #
                # Try to detect 4-way universal builds, those have machine-type
                # 'universal' instead of 'fat'.

                machine = 'fat'
                cflags = get_config_vars(***REMOVED***.get('CFLAGS'***REMOVED***

                archs = re.findall('-arch\s+(\S+***REMOVED***', cflags***REMOVED***
                archs = tuple(sorted(set(archs***REMOVED******REMOVED******REMOVED***

                if len(archs***REMOVED*** == 1:
                    machine = archs[0***REMOVED***
                elif archs == ('i386', 'ppc'***REMOVED***:
                    machine = 'fat'
                elif archs == ('i386', 'x86_64'***REMOVED***:
                    machine = 'intel'
                elif archs == ('i386', 'ppc', 'x86_64'***REMOVED***:
                    machine = 'fat3'
                elif archs == ('ppc64', 'x86_64'***REMOVED***:
                    machine = 'fat64'
                elif archs == ('i386', 'ppc', 'ppc64', 'x86_64'***REMOVED***:
                    machine = 'universal'
                else:
                    raise ValueError(
                       "Don't know machine value for archs=%r" % (archs,***REMOVED******REMOVED***

            elif machine == 'i386':
                # On OSX the machine type returned by uname is always the
                # 32-bit variant, even if the executable architecture is
                # the 64-bit variant
                if sys.maxsize >= 2**32:
                    machine = 'x86_64'

            elif machine in ('PowerPC', 'Power_Macintosh'***REMOVED***:
                # Pick a sane name for the PPC architecture.
                # See 'i386' case
                if sys.maxsize >= 2**32:
                    machine = 'ppc64'
                else:
                    machine = 'ppc'

    return "%s-%s-%s" % (osname, release, machine***REMOVED***


def get_python_version(***REMOVED***:
    return _PY_VERSION_SHORT


def _print_dict(title, data***REMOVED***:
    for index, (key, value***REMOVED*** in enumerate(sorted(data.items(***REMOVED******REMOVED******REMOVED***:
        if index == 0:
            print('%s: ' % (title***REMOVED******REMOVED***
        print('\t%s = "%s"' % (key, value***REMOVED******REMOVED***


def _main(***REMOVED***:
    ***REMOVED***Display all information sysconfig detains.***REMOVED***
    print('Platform: "%s"' % get_platform(***REMOVED******REMOVED***
    print('Python version: "%s"' % get_python_version(***REMOVED******REMOVED***
    print('Current installation scheme: "%s"' % _get_default_scheme(***REMOVED******REMOVED***
    print(***REMOVED***
    _print_dict('Paths', get_paths(***REMOVED******REMOVED***
    print(***REMOVED***
    _print_dict('Variables', get_config_vars(***REMOVED******REMOVED***


if __name__ == '__main__':
    _main(***REMOVED***
