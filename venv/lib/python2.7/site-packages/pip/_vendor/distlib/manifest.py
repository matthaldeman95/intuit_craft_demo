# -*- coding: utf-8 -*-
#
# Copyright (C***REMOVED*** 2012-2013 Python Software Foundation.
# See LICENSE.txt and CONTRIBUTORS.txt.
#
***REMOVED***
Class representing the list of files in a distribution.

Equivalent to distutils.filelist, but fixes some problems.
***REMOVED***
import fnmatch
import logging
***REMOVED***
import re

from . import DistlibException
from .compat import fsdecode
from .util import convert_path


__all__ = ['Manifest'***REMOVED***

logger = logging.getLogger(__name__***REMOVED***

# a \ followed by some spaces + EOL
_COLLAPSE_PATTERN = re.compile('\\\w*\n', re.M***REMOVED***
_COMMENTED_LINE = re.compile('#.*?(?=\n***REMOVED***|\n(?=$***REMOVED***', re.M | re.S***REMOVED***


class Manifest(object***REMOVED***:
    ***REMOVED***A list of files built by on exploring the filesystem and filtered by
    applying various patterns to what we find there.
    ***REMOVED***

    def __init__(self, base=None***REMOVED***:
        ***REMOVED***
        Initialise an instance.

        :param base: The base directory to explore under.
        ***REMOVED***
        self.base = os.path.abspath(os.path.normpath(base or os.getcwd(***REMOVED******REMOVED******REMOVED***
        self.prefix = self.base + os.sep
        self.allfiles = None
        self.files = set(***REMOVED***

    #
    # Public API
    #

    def findall(self***REMOVED***:
        ***REMOVED***Find all files under the base and set ``allfiles`` to the absolute
        pathnames of files found.
        ***REMOVED***
        from stat import S_ISREG, S_ISDIR, S_ISLNK

        self.allfiles = allfiles = [***REMOVED***
        root = self.base
        stack = [root***REMOVED***
        pop = stack.pop
        push = stack.append

        while stack:
            root = pop(***REMOVED***
            names = os.listdir(root***REMOVED***

            for name in names:
                fullname = os.path.join(root, name***REMOVED***

                # Avoid excess stat calls -- just one will do, thank you!
                stat = os.stat(fullname***REMOVED***
                mode = stat.st_mode
                if S_ISREG(mode***REMOVED***:
                    allfiles.append(fsdecode(fullname***REMOVED******REMOVED***
                elif S_ISDIR(mode***REMOVED*** and not S_ISLNK(mode***REMOVED***:
                    push(fullname***REMOVED***

    def add(self, item***REMOVED***:
        ***REMOVED***
        Add a file to the manifest.

        :param item: The pathname to add. This can be relative to the base.
        ***REMOVED***
        if not item.startswith(self.prefix***REMOVED***:
            item = os.path.join(self.base, item***REMOVED***
        self.files.add(os.path.normpath(item***REMOVED******REMOVED***

    def add_many(self, items***REMOVED***:
        ***REMOVED***
        Add a list of files to the manifest.

        :param items: The pathnames to add. These can be relative to the base.
        ***REMOVED***
        for item in items:
            self.add(item***REMOVED***

    def sorted(self, wantdirs=False***REMOVED***:
        ***REMOVED***
        Return sorted files in directory order
        ***REMOVED***

        def add_dir(dirs, d***REMOVED***:
            dirs.add(d***REMOVED***
            logger.debug('add_dir added %s', d***REMOVED***
            if d != self.base:
                parent, _ = os.path.split(d***REMOVED***
                assert parent not in ('', '/'***REMOVED***
                add_dir(dirs, parent***REMOVED***

        result = set(self.files***REMOVED***    # make a copy!
        if wantdirs:
            dirs = set(***REMOVED***
            for f in result:
                add_dir(dirs, os.path.dirname(f***REMOVED******REMOVED***
            result |= dirs
        return [os.path.join(*path_tuple***REMOVED*** for path_tuple in
                sorted(os.path.split(path***REMOVED*** for path in result***REMOVED******REMOVED***

    def clear(self***REMOVED***:
        ***REMOVED***Clear all collected files.***REMOVED***
        self.files = set(***REMOVED***
        self.allfiles = [***REMOVED***

    def process_directive(self, directive***REMOVED***:
        ***REMOVED***
        Process a directive which either adds some files from ``allfiles`` to
        ``files``, or removes some files from ``files``.

        :param directive: The directive to process. This should be in a format
                     compatible with distutils ``MANIFEST.in`` files:

                     http://docs.python.org/distutils/sourcedist.html#commands
        ***REMOVED***
        # Parse the line: split it up, make sure the right number of words
        # is there, and return the relevant words.  'action' is always
        # defined: it's the first word of the line.  Which of the other
        # three are defined depends on the action; it'll be either
        # patterns, (dir and patterns***REMOVED***, or (dirpattern***REMOVED***.
        action, patterns, thedir, dirpattern = self._parse_directive(directive***REMOVED***

        # OK, now we know that the action is valid and we have the
        # right number of words on the line for that action -- so we
        # can proceed with minimal error-checking.
        if action == 'include':
            for pattern in patterns:
                if not self._include_pattern(pattern, anchor=True***REMOVED***:
                    logger.warning('no files found matching %r', pattern***REMOVED***

        elif action == 'exclude':
            for pattern in patterns:
                found = self._exclude_pattern(pattern, anchor=True***REMOVED***
                #if not found:
                #    logger.warning('no previously-included files '
                #                   'found matching %r', pattern***REMOVED***

        elif action == 'global-include':
            for pattern in patterns:
                if not self._include_pattern(pattern, anchor=False***REMOVED***:
                    logger.warning('no files found matching %r '
                                   'anywhere in distribution', pattern***REMOVED***

        elif action == 'global-exclude':
            for pattern in patterns:
                found = self._exclude_pattern(pattern, anchor=False***REMOVED***
                #if not found:
                #    logger.warning('no previously-included files '
                #                   'matching %r found anywhere in '
                #                   'distribution', pattern***REMOVED***

        elif action == 'recursive-include':
            for pattern in patterns:
                if not self._include_pattern(pattern, prefix=thedir***REMOVED***:
                    logger.warning('no files found matching %r '
                                   'under directory %r', pattern, thedir***REMOVED***

        elif action == 'recursive-exclude':
            for pattern in patterns:
                found = self._exclude_pattern(pattern, prefix=thedir***REMOVED***
                #if not found:
                #    logger.warning('no previously-included files '
                #                   'matching %r found under directory %r',
                #                   pattern, thedir***REMOVED***

        elif action == 'graft':
            if not self._include_pattern(None, prefix=dirpattern***REMOVED***:
                logger.warning('no directories found matching %r',
                               dirpattern***REMOVED***

        elif action == 'prune':
            if not self._exclude_pattern(None, prefix=dirpattern***REMOVED***:
                logger.warning('no previously-included directories found '
                               'matching %r', dirpattern***REMOVED***
        else:   # pragma: no cover
            # This should never happen, as it should be caught in
            # _parse_template_line
            raise DistlibException(
                'invalid action %r' % action***REMOVED***

    #
    # Private API
    #

    def _parse_directive(self, directive***REMOVED***:
        ***REMOVED***
        Validate a directive.
        :param directive: The directive to validate.
        :return: A tuple of action, patterns, thedir, dir_patterns
        ***REMOVED***
        words = directive.split(***REMOVED***
        if len(words***REMOVED*** == 1 and words[0***REMOVED*** not in ('include', 'exclude',
                                                'global-include',
                                                'global-exclude',
                                                'recursive-include',
                                                'recursive-exclude',
                                                'graft', 'prune'***REMOVED***:
            # no action given, let's use the default 'include'
            words.insert(0, 'include'***REMOVED***

        action = words[0***REMOVED***
        patterns = thedir = dir_pattern = None

        if action in ('include', 'exclude',
                      'global-include', 'global-exclude'***REMOVED***:
            if len(words***REMOVED*** < 2:
                raise DistlibException(
                    '%r expects <pattern1> <pattern2> ...' % action***REMOVED***

            patterns = [convert_path(word***REMOVED*** for word in words[1:***REMOVED******REMOVED***

        elif action in ('recursive-include', 'recursive-exclude'***REMOVED***:
            if len(words***REMOVED*** < 3:
                raise DistlibException(
                    '%r expects <dir> <pattern1> <pattern2> ...' % action***REMOVED***

            thedir = convert_path(words[1***REMOVED******REMOVED***
            patterns = [convert_path(word***REMOVED*** for word in words[2:***REMOVED******REMOVED***

        elif action in ('graft', 'prune'***REMOVED***:
            if len(words***REMOVED*** != 2:
                raise DistlibException(
                    '%r expects a single <dir_pattern>' % action***REMOVED***

            dir_pattern = convert_path(words[1***REMOVED******REMOVED***

        else:
            raise DistlibException('unknown action %r' % action***REMOVED***

        return action, patterns, thedir, dir_pattern

    def _include_pattern(self, pattern, anchor=True, prefix=None,
                         is_regex=False***REMOVED***:
        ***REMOVED***Select strings (presumably filenames***REMOVED*** from 'self.files' that
        match 'pattern', a Unix-style wildcard (glob***REMOVED*** pattern.

        Patterns are not quite the same as implemented by the 'fnmatch'
        module: '*' and '?'  match non-special characters, where "special"
        is platform-dependent: slash on Unix; colon, slash, and backslash on
        DOS/Windows; and colon on Mac OS.

        If 'anchor' is true (the default***REMOVED***, then the pattern match is more
        stringent: "*.py" will match "foo.py" but not "foo/bar.py".  If
        'anchor' is false, both of these will match.

        If 'prefix' is supplied, then only filenames starting with 'prefix'
        (itself a pattern***REMOVED*** and ending with 'pattern', with anything in between
        them, will match.  'anchor' is ignored in this case.

        If 'is_regex' is true, 'anchor' and 'prefix' are ignored, and
        'pattern' is assumed to be either a string containing a regex or a
        regex object -- no translation is done, the regex is just compiled
        and used as-is.

        Selected strings will be added to self.files.

        Return True if files are found.
        ***REMOVED***
        # XXX docstring lying about what the special chars are?
        found = False
        pattern_re = self._translate_pattern(pattern, anchor, prefix, is_regex***REMOVED***

        # delayed loading of allfiles list
        if self.allfiles is None:
            self.findall(***REMOVED***

        for name in self.allfiles:
            if pattern_re.search(name***REMOVED***:
                self.files.add(name***REMOVED***
                found = True
        return found

    def _exclude_pattern(self, pattern, anchor=True, prefix=None,
                         is_regex=False***REMOVED***:
        ***REMOVED***Remove strings (presumably filenames***REMOVED*** from 'files' that match
        'pattern'.

        Other parameters are the same as for 'include_pattern(***REMOVED***', above.
        The list 'self.files' is modified in place. Return True if files are
        found.

        This API is public to allow e.g. exclusion of SCM subdirs, e.g. when
        packaging source distributions
        ***REMOVED***
        found = False
        pattern_re = self._translate_pattern(pattern, anchor, prefix, is_regex***REMOVED***
        for f in list(self.files***REMOVED***:
            if pattern_re.search(f***REMOVED***:
                self.files.remove(f***REMOVED***
                found = True
        return found

    def _translate_pattern(self, pattern, anchor=True, prefix=None,
                           is_regex=False***REMOVED***:
        ***REMOVED***Translate a shell-like wildcard pattern to a compiled regular
        expression.

        Return the compiled regex.  If 'is_regex' true,
        then 'pattern' is directly compiled to a regex (if it's a string***REMOVED***
        or just returned as-is (assumes it's a regex object***REMOVED***.
        ***REMOVED***
        if is_regex:
            if isinstance(pattern, str***REMOVED***:
                return re.compile(pattern***REMOVED***
            else:
                return pattern

        if pattern:
            pattern_re = self._glob_to_re(pattern***REMOVED***
        else:
            pattern_re = ''

        base = re.escape(os.path.join(self.base, ''***REMOVED******REMOVED***
        if prefix is not None:
            # ditch end of pattern character
            empty_pattern = self._glob_to_re(''***REMOVED***
            prefix_re = self._glob_to_re(prefix***REMOVED***[:-len(empty_pattern***REMOVED******REMOVED***
            sep = os.sep
            if os.sep == '\\':
                sep = r'\\'
            pattern_re = '^' + base + sep.join((prefix_re,
                                                '.*' + pattern_re***REMOVED******REMOVED***
        else:                               # no prefix -- respect anchor flag
            if anchor:
                pattern_re = '^' + base + pattern_re

        return re.compile(pattern_re***REMOVED***

    def _glob_to_re(self, pattern***REMOVED***:
        ***REMOVED***Translate a shell-like glob pattern to a regular expression.

        Return a string containing the regex.  Differs from
        'fnmatch.translate(***REMOVED***' in that '*' does not match "special characters"
        (which are platform-specific***REMOVED***.
        ***REMOVED***
        pattern_re = fnmatch.translate(pattern***REMOVED***

        # '?' and '*' in the glob pattern become '.' and '.*' in the RE, which
        # IMHO is wrong -- '?' and '*' aren't supposed to match slash in Unix,
        # and by extension they shouldn't match such "special characters" under
        # any OS.  So change all non-escaped dots in the RE to match any
        # character except the special characters (currently: just os.sep***REMOVED***.
        sep = os.sep
        if os.sep == '\\':
            # we're using a regex to manipulate a regex, so we need
            # to escape the backslash twice
            sep = r'\\\\'
        escaped = r'\1[^%s***REMOVED***' % sep
        pattern_re = re.sub(r'((?<!\\***REMOVED***(\\\\***REMOVED*******REMOVED***\.', escaped, pattern_re***REMOVED***
        return pattern_re
