# -*- coding: utf-8 -*-
#
# Copyright (C***REMOVED*** 2013 Vinay Sajip.
# Licensed to the Python Software Foundation under a contributor agreement.
# See LICENSE.txt and CONTRIBUTORS.txt.
#
import hashlib
import logging
***REMOVED***
import shutil
import subprocess
import tempfile
***REMOVED***
    from threading import Thread
except ImportError:
    from dummy_threading import Thread

from . import DistlibException
from .compat import (HTTPBasicAuthHandler, Request, HTTPPasswordMgr,
                     urlparse, build_opener, string_types***REMOVED***
from .util import cached_property, zip_dir, ServerProxy

logger = logging.getLogger(__name__***REMOVED***

DEFAULT_INDEX = 'https://pypi.python.org/pypi'
DEFAULT_REALM = 'pypi'

class PackageIndex(object***REMOVED***:
    ***REMOVED***
    This class represents a package index compatible with PyPI, the Python
    Package Index.
    ***REMOVED***

    boundary = b'----------ThIs_Is_tHe_distlib_index_bouNdaRY_$'

    def __init__(self, url=None***REMOVED***:
        ***REMOVED***
        Initialise an instance.

        :param url: The URL of the index. If not specified, the URL for PyPI is
                    used.
        ***REMOVED***
        self.url = url or DEFAULT_INDEX
        self.read_configuration(***REMOVED***
        scheme, netloc, path, params, query, frag = urlparse(self.url***REMOVED***
        if params or query or frag or scheme not in ('http', 'https'***REMOVED***:
            raise DistlibException('invalid repository: %s' % self.url***REMOVED***
        self.password_handler = None
        self.ssl_verifier = None
        self.gpg = None
        self.gpg_home = None
        self.rpc_proxy = None
        with open(os.devnull, 'w'***REMOVED*** as sink:
            for s in ('gpg2', 'gpg'***REMOVED***:
                ***REMOVED***
                    rc = subprocess.check_call([s, '--version'***REMOVED***, stdout=sink,
                                               stderr=sink***REMOVED***
                    if rc == 0:
                        self.gpg = s
                        break
                except OSError:
                    pass

    def _get_pypirc_command(self***REMOVED***:
        ***REMOVED***
        Get the distutils command for interacting with PyPI configurations.
        :return: the command.
        ***REMOVED***
        from distutils.core import Distribution
        from distutils.config import PyPIRCCommand
        d = Distribution(***REMOVED***
        return PyPIRCCommand(d***REMOVED***

    def read_configuration(self***REMOVED***:
        ***REMOVED***
        Read the PyPI access configuration as supported by distutils, getting
        PyPI to do the acutal work. This populates ``username``, ``password``,
        ``realm`` and ``url`` attributes from the configuration.
        ***REMOVED***
        # get distutils to do the work
        c = self._get_pypirc_command(***REMOVED***
        c.repository = self.url
        cfg = c._read_pypirc(***REMOVED***
        self.username = cfg.get('username'***REMOVED***
        self.password = cfg.get('password'***REMOVED***
        self.realm = cfg.get('realm', 'pypi'***REMOVED***
        self.url = cfg.get('repository', self.url***REMOVED***

    def save_configuration(self***REMOVED***:
        ***REMOVED***
        Save the PyPI access configuration. You must have set ``username`` and
        ``password`` attributes before calling this method.

        Again, distutils is used to do the actual work.
        ***REMOVED***
        self.check_credentials(***REMOVED***
        # get distutils to do the work
        c = self._get_pypirc_command(***REMOVED***
        c._store_pypirc(self.username, self.password***REMOVED***

    def check_credentials(self***REMOVED***:
        ***REMOVED***
        Check that ``username`` and ``password`` have been set, and raise an
        exception if not.
        ***REMOVED***
        if self.username is None or self.password is None:
            raise DistlibException('username and password must be set'***REMOVED***
        pm = HTTPPasswordMgr(***REMOVED***
        _, netloc, _, _, _, _ = urlparse(self.url***REMOVED***
        pm.add_password(self.realm, netloc, self.username, self.password***REMOVED***
        self.password_handler = HTTPBasicAuthHandler(pm***REMOVED***

    def register(self, metadata***REMOVED***:
        ***REMOVED***
        Register a distribution on PyPI, using the provided metadata.

        :param metadata: A :class:`Metadata` instance defining at least a name
                         and version number for the distribution to be
                         registered.
        :return: The HTTP response received from PyPI upon submission of the
                request.
        ***REMOVED***
        self.check_credentials(***REMOVED***
        metadata.validate(***REMOVED***
        d = metadata.todict(***REMOVED***
        d[':action'***REMOVED*** = 'verify'
        request = self.encode_request(d.items(***REMOVED***, [***REMOVED******REMOVED***
        response = self.send_request(request***REMOVED***
        d[':action'***REMOVED*** = 'submit'
        request = self.encode_request(d.items(***REMOVED***, [***REMOVED******REMOVED***
        return self.send_request(request***REMOVED***

    def _reader(self, name, stream, outbuf***REMOVED***:
        ***REMOVED***
        Thread runner for reading lines of from a subprocess into a buffer.

        :param name: The logical name of the stream (used for logging only***REMOVED***.
        :param stream: The stream to read from. This will typically a pipe
                       connected to the output stream of a subprocess.
        :param outbuf: The list to append the read lines to.
        ***REMOVED***
        while True:
            s = stream.readline(***REMOVED***
            if not s:
                break
            s = s.decode('utf-8'***REMOVED***.rstrip(***REMOVED***
            outbuf.append(s***REMOVED***
            logger.debug('%s: %s' % (name, s***REMOVED******REMOVED***
        stream.close(***REMOVED***

    def get_sign_command(self, filename, signer, sign_password,
                         keystore=None***REMOVED***:
        ***REMOVED***
        Return a suitable command for signing a file.

        :param filename: The pathname to the file to be signed.
        :param signer: The identifier of the signer of the file.
        :param sign_password: The passphrase for the signer's
                              private key used for signing.
        :param keystore: The path to a directory which contains the keys
                         used in verification. If not specified, the
                         instance's ``gpg_home`` attribute is used instead.
        :return: The signing command as a list suitable to be
                 passed to :class:`subprocess.Popen`.
        ***REMOVED***
        cmd = [self.gpg, '--status-fd', '2', '--no-tty'***REMOVED***
        if keystore is None:
            keystore = self.gpg_home
        if keystore:
            cmd.extend(['--homedir', keystore***REMOVED******REMOVED***
        if sign_password is not None:
            cmd.extend(['--batch', '--passphrase-fd', '0'***REMOVED******REMOVED***
        td = tempfile.mkdtemp(***REMOVED***
        sf = os.path.join(td, os.path.basename(filename***REMOVED*** + '.asc'***REMOVED***
        cmd.extend(['--detach-sign', '--armor', '--local-user',
                    signer, '--output', sf, filename***REMOVED******REMOVED***
        logger.debug('invoking: %s', ' '.join(cmd***REMOVED******REMOVED***
        return cmd, sf

    def run_command(self, cmd, input_data=None***REMOVED***:
        ***REMOVED***
        Run a command in a child process , passing it any input data specified.

        :param cmd: The command to run.
        :param input_data: If specified, this must be a byte string containing
                           data to be sent to the child process.
        :return: A tuple consisting of the subprocess' exit code, a list of
                 lines read from the subprocess' ``stdout``, and a list of
                 lines read from the subprocess' ``stderr``.
        ***REMOVED***
        kwargs = {
            'stdout': subprocess.PIPE,
            'stderr': subprocess.PIPE,
    ***REMOVED***
        if input_data is not None:
            kwargs['stdin'***REMOVED*** = subprocess.PIPE
        stdout = [***REMOVED***
        stderr = [***REMOVED***
        p = subprocess.Popen(cmd, **kwargs***REMOVED***
        # We don't use communicate(***REMOVED*** here because we may need to
        # get clever with interacting with the command
        t1 = Thread(target=self._reader, args=('stdout', p.stdout, stdout***REMOVED******REMOVED***
        t1.start(***REMOVED***
        t2 = Thread(target=self._reader, args=('stderr', p.stderr, stderr***REMOVED******REMOVED***
        t2.start(***REMOVED***
        if input_data is not None:
            p.stdin.write(input_data***REMOVED***
            p.stdin.close(***REMOVED***

        p.wait(***REMOVED***
        t1.join(***REMOVED***
        t2.join(***REMOVED***
        return p.returncode, stdout, stderr

    def sign_file(self, filename, signer, sign_password, keystore=None***REMOVED***:
        ***REMOVED***
        Sign a file.

        :param filename: The pathname to the file to be signed.
        :param signer: The identifier of the signer of the file.
        :param sign_password: The passphrase for the signer's
                              private key used for signing.
        :param keystore: The path to a directory which contains the keys
                         used in signing. If not specified, the instance's
                         ``gpg_home`` attribute is used instead.
        :return: The absolute pathname of the file where the signature is
                 stored.
        ***REMOVED***
        cmd, sig_file = self.get_sign_command(filename, signer, sign_password,
                                              keystore***REMOVED***
        rc, stdout, stderr = self.run_command(cmd,
                                              sign_password.encode('utf-8'***REMOVED******REMOVED***
        if rc != 0:
            raise DistlibException('sign command failed with error '
                                   'code %s' % rc***REMOVED***
        return sig_file

    def upload_file(self, metadata, filename, signer=None, sign_password=None,
                    filetype='sdist', pyversion='source', keystore=None***REMOVED***:
        ***REMOVED***
        Upload a release file to the index.

        :param metadata: A :class:`Metadata` instance defining at least a name
                         and version number for the file to be uploaded.
        :param filename: The pathname of the file to be uploaded.
        :param signer: The identifier of the signer of the file.
        :param sign_password: The passphrase for the signer's
                              private key used for signing.
        :param filetype: The type of the file being uploaded. This is the
                        distutils command which produced that file, e.g.
                        ``sdist`` or ``bdist_wheel``.
        :param pyversion: The version of Python which the release relates
                          to. For code compatible with any Python, this would
                          be ``source``, otherwise it would be e.g. ``3.2``.
        :param keystore: The path to a directory which contains the keys
                         used in signing. If not specified, the instance's
                         ``gpg_home`` attribute is used instead.
        :return: The HTTP response received from PyPI upon submission of the
                request.
        ***REMOVED***
        self.check_credentials(***REMOVED***
        if not os.path.exists(filename***REMOVED***:
            raise DistlibException('not found: %s' % filename***REMOVED***
        metadata.validate(***REMOVED***
        d = metadata.todict(***REMOVED***
        sig_file = None
        if signer:
            if not self.gpg:
                logger.warning('no signing program available - not signed'***REMOVED***
            else:
                sig_file = self.sign_file(filename, signer, sign_password,
                                          keystore***REMOVED***
        with open(filename, 'rb'***REMOVED*** as f:
            file_data = f.read(***REMOVED***
        md5_digest = hashlib.md5(file_data***REMOVED***.hexdigest(***REMOVED***
        sha256_digest = hashlib.sha256(file_data***REMOVED***.hexdigest(***REMOVED***
        d.update({
            ':action': 'file_upload',
            'protcol_version': '1',
            'filetype': filetype,
            'pyversion': pyversion,
            'md5_digest': md5_digest,
            'sha256_digest': sha256_digest,
    ***REMOVED******REMOVED***
        files = [('content', os.path.basename(filename***REMOVED***, file_data***REMOVED******REMOVED***
        if sig_file:
            with open(sig_file, 'rb'***REMOVED*** as f:
                sig_data = f.read(***REMOVED***
            files.append(('gpg_signature', os.path.basename(sig_file***REMOVED***,
                         sig_data***REMOVED******REMOVED***
            shutil.rmtree(os.path.dirname(sig_file***REMOVED******REMOVED***
        request = self.encode_request(d.items(***REMOVED***, files***REMOVED***
        return self.send_request(request***REMOVED***

    def upload_documentation(self, metadata, doc_dir***REMOVED***:
        ***REMOVED***
        Upload documentation to the index.

        :param metadata: A :class:`Metadata` instance defining at least a name
                         and version number for the documentation to be
                         uploaded.
        :param doc_dir: The pathname of the directory which contains the
                        documentation. This should be the directory that
                        contains the ``index.html`` for the documentation.
        :return: The HTTP response received from PyPI upon submission of the
                request.
        ***REMOVED***
        self.check_credentials(***REMOVED***
        if not os.path.isdir(doc_dir***REMOVED***:
            raise DistlibException('not a directory: %r' % doc_dir***REMOVED***
        fn = os.path.join(doc_dir, 'index.html'***REMOVED***
        if not os.path.exists(fn***REMOVED***:
            raise DistlibException('not found: %r' % fn***REMOVED***
        metadata.validate(***REMOVED***
        name, version = metadata.name, metadata.version
        zip_data = zip_dir(doc_dir***REMOVED***.getvalue(***REMOVED***
        fields = [(':action', 'doc_upload'***REMOVED***,
                  ('name', name***REMOVED***, ('version', version***REMOVED******REMOVED***
        files = [('content', name, zip_data***REMOVED******REMOVED***
        request = self.encode_request(fields, files***REMOVED***
        return self.send_request(request***REMOVED***

    def get_verify_command(self, signature_filename, data_filename,
                           keystore=None***REMOVED***:
        ***REMOVED***
        Return a suitable command for verifying a file.

        :param signature_filename: The pathname to the file containing the
                                   signature.
        :param data_filename: The pathname to the file containing the
                              signed data.
        :param keystore: The path to a directory which contains the keys
                         used in verification. If not specified, the
                         instance's ``gpg_home`` attribute is used instead.
        :return: The verifying command as a list suitable to be
                 passed to :class:`subprocess.Popen`.
        ***REMOVED***
        cmd = [self.gpg, '--status-fd', '2', '--no-tty'***REMOVED***
        if keystore is None:
            keystore = self.gpg_home
        if keystore:
            cmd.extend(['--homedir', keystore***REMOVED******REMOVED***
        cmd.extend(['--verify', signature_filename, data_filename***REMOVED******REMOVED***
        logger.debug('invoking: %s', ' '.join(cmd***REMOVED******REMOVED***
        return cmd

    def verify_signature(self, signature_filename, data_filename,
                         keystore=None***REMOVED***:
        ***REMOVED***
        Verify a signature for a file.

        :param signature_filename: The pathname to the file containing the
                                   signature.
        :param data_filename: The pathname to the file containing the
                              signed data.
        :param keystore: The path to a directory which contains the keys
                         used in verification. If not specified, the
                         instance's ``gpg_home`` attribute is used instead.
        :return: True if the signature was verified, else False.
        ***REMOVED***
        if not self.gpg:
            raise DistlibException('verification unavailable because gpg '
                                   'unavailable'***REMOVED***
        cmd = self.get_verify_command(signature_filename, data_filename,
                                      keystore***REMOVED***
        rc, stdout, stderr = self.run_command(cmd***REMOVED***
        if rc not in (0, 1***REMOVED***:
            raise DistlibException('verify command failed with error '
                             'code %s' % rc***REMOVED***
        return rc == 0

    def download_file(self, url, destfile, digest=None, reporthook=None***REMOVED***:
        ***REMOVED***
        This is a convenience method for downloading a file from an URL.
        Normally, this will be a file from the index, though currently
        no check is made for this (i.e. a file can be downloaded from
        anywhere***REMOVED***.

        The method is just like the :func:`urlretrieve` function in the
        standard library, except that it allows digest computation to be
        done during download and checking that the downloaded data
        matched any expected value.

        :param url: The URL of the file to be downloaded (assumed to be
                    available via an HTTP GET request***REMOVED***.
        :param destfile: The pathname where the downloaded file is to be
                         saved.
        :param digest: If specified, this must be a (hasher, value***REMOVED***
                       tuple, where hasher is the algorithm used (e.g.
                       ``'md5'``***REMOVED*** and ``value`` is the expected value.
        :param reporthook: The same as for :func:`urlretrieve` in the
                           standard library.
        ***REMOVED***
        if digest is None:
            digester = None
            logger.debug('No digest specified'***REMOVED***
        else:
            if isinstance(digest, (list, tuple***REMOVED******REMOVED***:
                hasher, digest = digest
            else:
                hasher = 'md5'
            digester = getattr(hashlib, hasher***REMOVED***(***REMOVED***
            logger.debug('Digest specified: %s' % digest***REMOVED***
        # The following code is equivalent to urlretrieve.
        # We need to do it this way so that we can compute the
        # digest of the file as we go.
        with open(destfile, 'wb'***REMOVED*** as dfp:
            # addinfourl is not a context manager on 2.x
            # so we have to use try/finally
            sfp = self.send_request(Request(url***REMOVED******REMOVED***
            ***REMOVED***
                headers = sfp.info(***REMOVED***
                blocksize = 8192
                size = -1
                read = 0
                blocknum = 0
                if "content-length" in headers:
                    size = int(headers["Content-Length"***REMOVED******REMOVED***
                if reporthook:
                    reporthook(blocknum, blocksize, size***REMOVED***
                while True:
                    block = sfp.read(blocksize***REMOVED***
                    if not block:
                        break
                    read += len(block***REMOVED***
                    dfp.write(block***REMOVED***
                    if digester:
                        digester.update(block***REMOVED***
                    blocknum += 1
                    if reporthook:
                        reporthook(blocknum, blocksize, size***REMOVED***
            finally:
                sfp.close(***REMOVED***

        # check that we got the whole file, if we can
        if size >= 0 and read < size:
            raise DistlibException(
                'retrieval incomplete: got only %d out of %d bytes'
                % (read, size***REMOVED******REMOVED***
        # if we have a digest, it must match.
        if digester:
            actual = digester.hexdigest(***REMOVED***
            if digest != actual:
                raise DistlibException('%s digest mismatch for %s: expected '
                                       '%s, got %s' % (hasher, destfile,
                                                       digest, actual***REMOVED******REMOVED***
            logger.debug('Digest verified: %s', digest***REMOVED***

    def send_request(self, req***REMOVED***:
        ***REMOVED***
        Send a standard library :class:`Request` to PyPI and return its
        response.

        :param req: The request to send.
        :return: The HTTP response from PyPI (a standard library HTTPResponse***REMOVED***.
        ***REMOVED***
        handlers = [***REMOVED***
        if self.password_handler:
            handlers.append(self.password_handler***REMOVED***
        if self.ssl_verifier:
            handlers.append(self.ssl_verifier***REMOVED***
        opener = build_opener(*handlers***REMOVED***
        return opener.open(req***REMOVED***

    def encode_request(self, fields, files***REMOVED***:
        ***REMOVED***
        Encode fields and files for posting to an HTTP server.

        :param fields: The fields to send as a list of (fieldname, value***REMOVED***
                       tuples.
        :param files: The files to send as a list of (fieldname, filename,
                      file_bytes***REMOVED*** tuple.
        ***REMOVED***
        # Adapted from packaging, which in turn was adapted from
        # http://code.activestate.com/recipes/146306

        parts = [***REMOVED***
        boundary = self.boundary
        for k, values in fields:
            if not isinstance(values, (list, tuple***REMOVED******REMOVED***:
                values = [values***REMOVED***

            for v in values:
                parts.extend((
                    b'--' + boundary,
                    ('Content-Disposition: form-data; name="%s"' %
                     k***REMOVED***.encode('utf-8'***REMOVED***,
                    b'',
                    v.encode('utf-8'***REMOVED******REMOVED******REMOVED***
        for key, filename, value in files:
            parts.extend((
                b'--' + boundary,
                ('Content-Disposition: form-data; name="%s"; filename="%s"' %
                 (key, filename***REMOVED******REMOVED***.encode('utf-8'***REMOVED***,
                b'',
                value***REMOVED******REMOVED***

        parts.extend((b'--' + boundary + b'--', b''***REMOVED******REMOVED***

        body = b'\r\n'.join(parts***REMOVED***
        ct = b'multipart/form-data; boundary=' + boundary
        headers = {
            'Content-type': ct,
            'Content-length': str(len(body***REMOVED******REMOVED***
    ***REMOVED***
        return Request(self.url, body, headers***REMOVED***

    def search(self, terms, operator=None***REMOVED***:
        if isinstance(terms, string_types***REMOVED***:
            terms = {'name': terms***REMOVED***
        if self.rpc_proxy is None:
            self.rpc_proxy = ServerProxy(self.url, timeout=3.0***REMOVED***
        return self.rpc_proxy.search(terms, operator or 'and'***REMOVED***
