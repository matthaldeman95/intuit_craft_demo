# -*- coding: utf-8 -*-
#
# Copyright (C***REMOVED*** 2013-2016 Vinay Sajip.
# Licensed to the Python Software Foundation under a contributor agreement.
# See LICENSE.txt and CONTRIBUTORS.txt.
#
from __future__ import absolute_import

***REMOVED***
import re
import sys

if sys.version_info[0***REMOVED*** < 3:  # pragma: no cover
    from StringIO import StringIO
    string_types = basestring,
    text_type = unicode
    from types import FileType as file_type
    import __builtin__ as builtins
    import ConfigParser as configparser
    from ._backport import shutil
    from urlparse import urlparse, urlunparse, urljoin, urlsplit, urlunsplit
    from urllib import (urlretrieve, quote as _quote, unquote, url2pathname,
                        pathname2url, ContentTooShortError, splittype***REMOVED***

    def quote(s***REMOVED***:
        if isinstance(s, unicode***REMOVED***:
            s = s.encode('utf-8'***REMOVED***
        return _quote(s***REMOVED***

    import urllib2
    from urllib2 import (Request, urlopen, URLError, HTTPError,
                         HTTPBasicAuthHandler, HTTPPasswordMgr,
                         HTTPSHandler, HTTPHandler, HTTPRedirectHandler,
                         build_opener***REMOVED***
    import httplib
    import xmlrpclib
    import Queue as queue
    from HTMLParser import HTMLParser
    import htmlentitydefs
    raw_input = raw_input
    from itertools import ifilter as filter
    from itertools import ifilterfalse as filterfalse

    _userprog = None
    def splituser(host***REMOVED***:
        ***REMOVED***splituser('user[:passwd***REMOVED***@host[:port***REMOVED***'***REMOVED*** --> 'user[:passwd***REMOVED***', 'host[:port***REMOVED***'.***REMOVED***
        global _userprog
        if _userprog is None:
            import re
            _userprog = re.compile('^(.****REMOVED***@(.****REMOVED***$'***REMOVED***

        match = _userprog.match(host***REMOVED***
        if match: return match.group(1, 2***REMOVED***
        return None, host

else:  # pragma: no cover
    from io import StringIO
    string_types = str,
    text_type = str
    from io import TextIOWrapper as file_type
    import builtins
    import configparser
    import shutil
    from urllib.parse import (urlparse, urlunparse, urljoin, splituser, quote,
                              unquote, urlsplit, urlunsplit, splittype***REMOVED***
    from urllib.request import (urlopen, urlretrieve, Request, url2pathname,
                                pathname2url,
                                HTTPBasicAuthHandler, HTTPPasswordMgr,
                                HTTPSHandler, HTTPHandler, HTTPRedirectHandler,
                                build_opener***REMOVED***
    from urllib.error import HTTPError, URLError, ContentTooShortError
    import http.client as httplib
    import urllib.request as urllib2
    import xmlrpc.client as xmlrpclib
    import queue
    from html.parser import HTMLParser
    import html.entities as htmlentitydefs
    raw_input = input
    from itertools import filterfalse
    filter = filter

***REMOVED***
    from ssl import match_hostname, CertificateError
except ImportError: # pragma: no cover
    class CertificateError(ValueError***REMOVED***:
        pass


    def _dnsname_match(dn, hostname, max_wildcards=1***REMOVED***:
        ***REMOVED***Matching according to RFC 6125, section 6.4.3

        http://tools.ietf.org/html/rfc6125#section-6.4.3
        ***REMOVED***
        pats = [***REMOVED***
        if not dn:
            return False

        parts = dn.split('.'***REMOVED***
        leftmost, remainder = parts[0***REMOVED***, parts[1:***REMOVED***

        wildcards = leftmost.count('*'***REMOVED***
        if wildcards > max_wildcards:
            # Issue #17980: avoid denials of service by refusing more
            # than one wildcard per fragment.  A survery of established
            # policy among SSL implementations showed it to be a
            # reasonable choice.
            raise CertificateError(
                "too many wildcards in certificate DNS name: " + repr(dn***REMOVED******REMOVED***

        # speed up common case w/o wildcards
        if not wildcards:
            return dn.lower(***REMOVED*** == hostname.lower(***REMOVED***

        # RFC 6125, section 6.4.3, subitem 1.
        # The client SHOULD NOT attempt to match a presented identifier in which
        # the wildcard character comprises a label other than the left-most label.
        if leftmost == '*':
            # When '*' is a fragment by itself, it matches a non-empty dotless
            # fragment.
            pats.append('[^.***REMOVED***+'***REMOVED***
        elif leftmost.startswith('xn--'***REMOVED*** or hostname.startswith('xn--'***REMOVED***:
            # RFC 6125, section 6.4.3, subitem 3.
            # The client SHOULD NOT attempt to match a presented identifier
            # where the wildcard character is embedded within an A-label or
            # U-label of an internationalized domain name.
            pats.append(re.escape(leftmost***REMOVED******REMOVED***
        else:
            # Otherwise, '*' matches any dotless string, e.g. www*
            pats.append(re.escape(leftmost***REMOVED***.replace(r'\*', '[^.***REMOVED****'***REMOVED******REMOVED***

        # add the remaining fragments, ignore any wildcards
        for frag in remainder:
            pats.append(re.escape(frag***REMOVED******REMOVED***

        pat = re.compile(r'\A' + r'\.'.join(pats***REMOVED*** + r'\Z', re.IGNORECASE***REMOVED***
        return pat.match(hostname***REMOVED***


    def match_hostname(cert, hostname***REMOVED***:
        ***REMOVED***Verify that *cert* (in decoded format as returned by
        SSLSocket.getpeercert(***REMOVED******REMOVED*** matches the *hostname*.  RFC 2818 and RFC 6125
        rules are followed, but IP addresses are not accepted for *hostname*.

        CertificateError is raised on failure. On success, the function
        returns nothing.
        ***REMOVED***
        if not cert:
            raise ValueError("empty or no certificate, match_hostname needs a "
                             "SSL socket or SSL context with either "
                             "CERT_OPTIONAL or CERT_REQUIRED"***REMOVED***
        dnsnames = [***REMOVED***
        san = cert.get('subjectAltName', (***REMOVED******REMOVED***
        for key, value in san:
            if key == 'DNS':
                if _dnsname_match(value, hostname***REMOVED***:
                    return
                dnsnames.append(value***REMOVED***
        if not dnsnames:
            # The subject is only checked when there is no dNSName entry
            # in subjectAltName
            for sub in cert.get('subject', (***REMOVED******REMOVED***:
                for key, value in sub:
                    # XXX according to RFC 2818, the most specific Common Name
                    # must be used.
                    if key == 'commonName':
                        if _dnsname_match(value, hostname***REMOVED***:
                            return
                        dnsnames.append(value***REMOVED***
        if len(dnsnames***REMOVED*** > 1:
            raise CertificateError("hostname %r "
                "doesn't match either of %s"
                % (hostname, ', '.join(map(repr, dnsnames***REMOVED******REMOVED******REMOVED******REMOVED***
        elif len(dnsnames***REMOVED*** == 1:
            raise CertificateError("hostname %r "
                "doesn't match %r"
                % (hostname, dnsnames[0***REMOVED******REMOVED******REMOVED***
        else:
            raise CertificateError("no appropriate commonName or "
                "subjectAltName fields were found"***REMOVED***


***REMOVED***
    from types import SimpleNamespace as Container
except ImportError:  # pragma: no cover
    class Container(object***REMOVED***:
        ***REMOVED***
        A generic container for when multiple values need to be returned
        ***REMOVED***
        def __init__(self, **kwargs***REMOVED***:
            self.__dict__.update(kwargs***REMOVED***


***REMOVED***
    from shutil import which
except ImportError:  # pragma: no cover
    # Implementation from Python 3.3
    def which(cmd, mode=os.F_OK | os.X_OK, path=None***REMOVED***:
        ***REMOVED***Given a command, mode, and a PATH string, return the path which
        conforms to the given mode on the PATH, or None if there is no such
        file.

        `mode` defaults to os.F_OK | os.X_OK. `path` defaults to the result
        of os.environ.get("PATH"***REMOVED***, or can be overridden with a custom search
        path.

        ***REMOVED***
        # Check that a given file can be accessed with the correct mode.
        # Additionally check that `file` is not a directory, as on Windows
        # directories pass the os.access check.
        def _access_check(fn, mode***REMOVED***:
            return (os.path.exists(fn***REMOVED*** and os.access(fn, mode***REMOVED***
                    and not os.path.isdir(fn***REMOVED******REMOVED***

        # If we're given a path with a directory part, look it up directly rather
        # than referring to PATH directories. This includes checking relative to the
        # current directory, e.g. ./script
        if os.path.dirname(cmd***REMOVED***:
            if _access_check(cmd, mode***REMOVED***:
                return cmd
            return None

        if path is None:
            path = os.environ.get("PATH", os.defpath***REMOVED***
        if not path:
            return None
        path = path.split(os.pathsep***REMOVED***

        if sys.platform == "win32":
            # The current directory takes precedence on Windows.
            if not os.curdir in path:
                path.insert(0, os.curdir***REMOVED***

            # PATHEXT is necessary to check on Windows.
            pathext = os.environ.get("PATHEXT", ""***REMOVED***.split(os.pathsep***REMOVED***
            # See if the given file matches any of the expected path extensions.
            # This will allow us to short circuit when given "python.exe".
            # If it does match, only test that one, otherwise we have to try
            # others.
            if any(cmd.lower(***REMOVED***.endswith(ext.lower(***REMOVED******REMOVED*** for ext in pathext***REMOVED***:
                files = [cmd***REMOVED***
            else:
                files = [cmd + ext for ext in pathext***REMOVED***
        else:
            # On other platforms you don't have things like PATHEXT to tell you
            # what file suffixes are executable, so just pass on cmd as-is.
            files = [cmd***REMOVED***

        seen = set(***REMOVED***
        for dir in path:
            normdir = os.path.normcase(dir***REMOVED***
            if not normdir in seen:
                seen.add(normdir***REMOVED***
                for thefile in files:
                    name = os.path.join(dir, thefile***REMOVED***
                    if _access_check(name, mode***REMOVED***:
                        return name
        return None


# ZipFile is a context manager in 2.7, but not in 2.6

from zipfile import ZipFile as BaseZipFile

if hasattr(BaseZipFile, '__enter__'***REMOVED***:  # pragma: no cover
    ZipFile = BaseZipFile
else:
    from zipfile import ZipExtFile as BaseZipExtFile

    class ZipExtFile(BaseZipExtFile***REMOVED***:
        def __init__(self, base***REMOVED***:
            self.__dict__.update(base.__dict__***REMOVED***

        def __enter__(self***REMOVED***:
            return self

        def __exit__(self, *exc_info***REMOVED***:
            self.close(***REMOVED***
            # return None, so if an exception occurred, it will propagate

    class ZipFile(BaseZipFile***REMOVED***:
        def __enter__(self***REMOVED***:
            return self

        def __exit__(self, *exc_info***REMOVED***:
            self.close(***REMOVED***
            # return None, so if an exception occurred, it will propagate

        def open(self, *args, **kwargs***REMOVED***:
            base = BaseZipFile.open(self, *args, **kwargs***REMOVED***
            return ZipExtFile(base***REMOVED***

***REMOVED***
    from platform import python_implementation
except ImportError: # pragma: no cover
    def python_implementation(***REMOVED***:
        ***REMOVED***Return a string identifying the Python implementation.***REMOVED***
        if 'PyPy' in sys.version:
            return 'PyPy'
        if os.name == 'java':
            return 'Jython'
        if sys.version.startswith('IronPython'***REMOVED***:
            return 'IronPython'
        return 'CPython'

***REMOVED***
    import sysconfig
except ImportError: # pragma: no cover
    from ._backport import sysconfig

***REMOVED***
    callable = callable
except NameError:   # pragma: no cover
    from collections import Callable

    def callable(obj***REMOVED***:
        return isinstance(obj, Callable***REMOVED***


***REMOVED***
    fsencode = os.fsencode
    fsdecode = os.fsdecode
except AttributeError:  # pragma: no cover
    _fsencoding = sys.getfilesystemencoding(***REMOVED***
    if _fsencoding == 'mbcs':
        _fserrors = 'strict'
    else:
        _fserrors = 'surrogateescape'

    def fsencode(filename***REMOVED***:
        if isinstance(filename, bytes***REMOVED***:
            return filename
        elif isinstance(filename, text_type***REMOVED***:
            return filename.encode(_fsencoding, _fserrors***REMOVED***
        else:
            raise TypeError("expect bytes or str, not %s" %
                            type(filename***REMOVED***.__name__***REMOVED***

    def fsdecode(filename***REMOVED***:
        if isinstance(filename, text_type***REMOVED***:
            return filename
        elif isinstance(filename, bytes***REMOVED***:
            return filename.decode(_fsencoding, _fserrors***REMOVED***
        else:
            raise TypeError("expect bytes or str, not %s" %
                            type(filename***REMOVED***.__name__***REMOVED***

***REMOVED***
    from tokenize import detect_encoding
except ImportError: # pragma: no cover
    from codecs import BOM_UTF8, lookup
    import re

    cookie_re = re.compile("coding[:=***REMOVED***\s*([-\w.***REMOVED***+***REMOVED***"***REMOVED***

    def _get_normal_name(orig_enc***REMOVED***:
        ***REMOVED***Imitates get_normal_name in tokenizer.c.***REMOVED***
        # Only care about the first 12 characters.
        enc = orig_enc[:12***REMOVED***.lower(***REMOVED***.replace("_", "-"***REMOVED***
        if enc == "utf-8" or enc.startswith("utf-8-"***REMOVED***:
            return "utf-8"
        if enc in ("latin-1", "iso-8859-1", "iso-latin-1"***REMOVED*** or \
           enc.startswith(("latin-1-", "iso-8859-1-", "iso-latin-1-"***REMOVED******REMOVED***:
            return "iso-8859-1"
        return orig_enc

    def detect_encoding(readline***REMOVED***:
        ***REMOVED***
        The detect_encoding(***REMOVED*** function is used to detect the encoding that should
        be used to decode a Python source file.  It requires one argment, readline,
        in the same way as the tokenize(***REMOVED*** generator.

        It will call readline a maximum of twice, and return the encoding used
        (as a string***REMOVED*** and a list of any lines (left as bytes***REMOVED*** it has read in.

        It detects the encoding from the presence of a utf-8 bom or an encoding
        cookie as specified in pep-0263.  If both a bom and a cookie are present,
        but disagree, a SyntaxError will be raised.  If the encoding cookie is an
        invalid charset, raise a SyntaxError.  Note that if a utf-8 bom is found,
        'utf-8-sig' is returned.

        If no encoding is specified, then the default of 'utf-8' will be returned.
        ***REMOVED***
        ***REMOVED***
            filename = readline.__self__.name
        except AttributeError:
            filename = None
        bom_found = False
        encoding = None
        default = 'utf-8'
        def read_or_stop(***REMOVED***:
            ***REMOVED***
                return readline(***REMOVED***
            except StopIteration:
                return b''

        def find_cookie(line***REMOVED***:
            ***REMOVED***
                # Decode as UTF-8. Either the line is an encoding declaration,
                # in which case it should be pure ASCII, or it must be UTF-8
                # per default encoding.
                line_string = line.decode('utf-8'***REMOVED***
            except UnicodeDecodeError:
                msg = "invalid or missing encoding declaration"
                if filename is not None:
                    msg = '{***REMOVED*** for {!r***REMOVED***'.format(msg, filename***REMOVED***
                raise SyntaxError(msg***REMOVED***

            matches = cookie_re.findall(line_string***REMOVED***
            if not matches:
                return None
            encoding = _get_normal_name(matches[0***REMOVED******REMOVED***
            ***REMOVED***
                codec = lookup(encoding***REMOVED***
            except LookupError:
                # This behaviour mimics the Python interpreter
                if filename is None:
                    msg = "unknown encoding: " + encoding
                else:
                    msg = "unknown encoding for {!r***REMOVED***: {***REMOVED***".format(filename,
                            encoding***REMOVED***
                raise SyntaxError(msg***REMOVED***

            if bom_found:
                if codec.name != 'utf-8':
                    # This behaviour mimics the Python interpreter
                    if filename is None:
                        msg = 'encoding problem: utf-8'
                    else:
                        msg = 'encoding problem for {!r***REMOVED***: utf-8'.format(filename***REMOVED***
                    raise SyntaxError(msg***REMOVED***
                encoding += '-sig'
            return encoding

        first = read_or_stop(***REMOVED***
        if first.startswith(BOM_UTF8***REMOVED***:
            bom_found = True
            first = first[3:***REMOVED***
            default = 'utf-8-sig'
        if not first:
            return default, [***REMOVED***

        encoding = find_cookie(first***REMOVED***
        if encoding:
            return encoding, [first***REMOVED***

        second = read_or_stop(***REMOVED***
        if not second:
            return default, [first***REMOVED***

        encoding = find_cookie(second***REMOVED***
        if encoding:
            return encoding, [first, second***REMOVED***

        return default, [first, second***REMOVED***

# For converting & <-> &amp; etc.
***REMOVED***
    from html import escape
except ImportError:
    from cgi import escape
if sys.version_info[:2***REMOVED*** < (3, 4***REMOVED***:
    unescape = HTMLParser(***REMOVED***.unescape
else:
    from html import unescape

***REMOVED***
    from collections import ChainMap
except ImportError: # pragma: no cover
    from collections import MutableMapping

    ***REMOVED***
        from reprlib import recursive_repr as _recursive_repr
    except ImportError:
        def _recursive_repr(fillvalue='...'***REMOVED***:
            '''
            Decorator to make a repr function return fillvalue for a recursive
            call
            '''

            def decorating_function(user_function***REMOVED***:
                repr_running = set(***REMOVED***

                def wrapper(self***REMOVED***:
                    key = id(self***REMOVED***, get_ident(***REMOVED***
                    if key in repr_running:
                        return fillvalue
                    repr_running.add(key***REMOVED***
                    ***REMOVED***
                        result = user_function(self***REMOVED***
                    finally:
                        repr_running.discard(key***REMOVED***
                    return result

                # Can't use functools.wraps(***REMOVED*** here because of bootstrap issues
                wrapper.__module__ = getattr(user_function, '__module__'***REMOVED***
                wrapper.__doc__ = getattr(user_function, '__doc__'***REMOVED***
                wrapper.__name__ = getattr(user_function, '__name__'***REMOVED***
                wrapper.__annotations__ = getattr(user_function, '__annotations__', {***REMOVED******REMOVED***
                return wrapper

            return decorating_function

    class ChainMap(MutableMapping***REMOVED***:
        ''' A ChainMap groups multiple dicts (or other mappings***REMOVED*** together
        to create a single, updateable view.

        The underlying mappings are stored in a list.  That list is public and can
        accessed or updated using the *maps* attribute.  There is no other state.

        Lookups search the underlying mappings successively until a key is found.
        In contrast, writes, updates, and deletions only operate on the first
        mapping.

        '''

        def __init__(self, *maps***REMOVED***:
            '''Initialize a ChainMap by setting *maps* to the given mappings.
            If no mappings are provided, a single empty dictionary is used.

            '''
            self.maps = list(maps***REMOVED*** or [{***REMOVED******REMOVED***          # always at least one map

        def __missing__(self, key***REMOVED***:
            raise KeyError(key***REMOVED***

        def __getitem__(self, key***REMOVED***:
            for mapping in self.maps:
                ***REMOVED***
                    return mapping[key***REMOVED***             # can't use 'key in mapping' with defaultdict
                except KeyError:
                    pass
            return self.__missing__(key***REMOVED***            # support subclasses that define __missing__

        def get(self, key, default=None***REMOVED***:
            return self[key***REMOVED*** if key in self else default

        def __len__(self***REMOVED***:
            return len(set(***REMOVED***.union(*self.maps***REMOVED******REMOVED***     # reuses stored hash values if possible

        def __iter__(self***REMOVED***:
            return iter(set(***REMOVED***.union(*self.maps***REMOVED******REMOVED***

        def __contains__(self, key***REMOVED***:
            return any(key in m for m in self.maps***REMOVED***

        def __bool__(self***REMOVED***:
            return any(self.maps***REMOVED***

        @_recursive_repr(***REMOVED***
        def __repr__(self***REMOVED***:
            return '{0.__class__.__name__***REMOVED***({1***REMOVED******REMOVED***'.format(
                self, ', '.join(map(repr, self.maps***REMOVED******REMOVED******REMOVED***

        @classmethod
        def fromkeys(cls, iterable, *args***REMOVED***:
            'Create a ChainMap with a single dict created from the iterable.'
            return cls(dict.fromkeys(iterable, *args***REMOVED******REMOVED***

        def copy(self***REMOVED***:
            'New ChainMap or subclass with a new copy of maps[0***REMOVED*** and refs to maps[1:***REMOVED***'
            return self.__class__(self.maps[0***REMOVED***.copy(***REMOVED***, *self.maps[1:***REMOVED******REMOVED***

        __copy__ = copy

        def new_child(self***REMOVED***:                        # like Django's Context.push(***REMOVED***
            'New ChainMap with a new dict followed by all previous maps.'
            return self.__class__({***REMOVED***, *self.maps***REMOVED***

        @property
        def parents(self***REMOVED***:                          # like Django's Context.pop(***REMOVED***
            'New ChainMap from maps[1:***REMOVED***.'
            return self.__class__(*self.maps[1:***REMOVED******REMOVED***

        def __setitem__(self, key, value***REMOVED***:
            self.maps[0***REMOVED***[key***REMOVED*** = value

        def __delitem__(self, key***REMOVED***:
            ***REMOVED***
                del self.maps[0***REMOVED***[key***REMOVED***
            except KeyError:
                raise KeyError('Key not found in the first mapping: {!r***REMOVED***'.format(key***REMOVED******REMOVED***

        def popitem(self***REMOVED***:
            'Remove and return an item pair from maps[0***REMOVED***. Raise KeyError is maps[0***REMOVED*** is empty.'
            ***REMOVED***
                return self.maps[0***REMOVED***.popitem(***REMOVED***
            except KeyError:
                raise KeyError('No keys found in the first mapping.'***REMOVED***

        def pop(self, key, *args***REMOVED***:
            'Remove *key* from maps[0***REMOVED*** and return its value. Raise KeyError if *key* not in maps[0***REMOVED***.'
            ***REMOVED***
                return self.maps[0***REMOVED***.pop(key, *args***REMOVED***
            except KeyError:
                raise KeyError('Key not found in the first mapping: {!r***REMOVED***'.format(key***REMOVED******REMOVED***

        def clear(self***REMOVED***:
            'Clear maps[0***REMOVED***, leaving maps[1:***REMOVED*** intact.'
            self.maps[0***REMOVED***.clear(***REMOVED***

***REMOVED***
    from imp import cache_from_source
except ImportError: # pragma: no cover
    def cache_from_source(path, debug_override=None***REMOVED***:
        assert path.endswith('.py'***REMOVED***
        if debug_override is None:
            debug_override = __debug__
        if debug_override:
            suffix = 'c'
        else:
            suffix = 'o'
        return path + suffix

***REMOVED***
    from collections import OrderedDict
except ImportError: # pragma: no cover
## {{{ http://code.activestate.com/recipes/576693/ (r9***REMOVED***
# Backport of OrderedDict(***REMOVED*** class that runs on Python 2.4, 2.5, 2.6, 2.7 and pypy.
# Passes Python2.7's test suite and incorporates all the latest updates.
    ***REMOVED***
        from thread import get_ident as _get_ident
    except ImportError:
        from dummy_thread import get_ident as _get_ident

    ***REMOVED***
        from _abcoll import KeysView, ValuesView, ItemsView
    except ImportError:
        pass


    class OrderedDict(dict***REMOVED***:
        'Dictionary that remembers insertion order'
        # An inherited dict maps keys to values.
        # The inherited dict provides __getitem__, __len__, __contains__, and get.
        # The remaining methods are order-aware.
        # Big-O running times for all methods are the same as for regular dictionaries.

        # The internal self.__map dictionary maps keys to links in a doubly linked list.
        # The circular doubly linked list starts and ends with a sentinel element.
        # The sentinel element never gets deleted (this simplifies the algorithm***REMOVED***.
        # Each link is stored as a list of length three:  [PREV, NEXT, KEY***REMOVED***.

        def __init__(self, *args, **kwds***REMOVED***:
            '''Initialize an ordered dictionary.  Signature is the same as for
            regular dictionaries, but keyword arguments are not recommended
            because their insertion order is arbitrary.

            '''
            if len(args***REMOVED*** > 1:
                raise TypeError('expected at most 1 arguments, got %d' % len(args***REMOVED******REMOVED***
            ***REMOVED***
                self.__root
            except AttributeError:
                self.__root = root = [***REMOVED***                     # sentinel node
                root[:***REMOVED*** = [root, root, None***REMOVED***
                self.__map = {***REMOVED***
            self.__update(*args, **kwds***REMOVED***

        def __setitem__(self, key, value, dict_setitem=dict.__setitem__***REMOVED***:
            'od.__setitem__(i, y***REMOVED*** <==> od[i***REMOVED***=y'
            # Setting a new item creates a new link which goes at the end of the linked
            # list, and the inherited dictionary is updated with the new key/value pair.
            if key not in self:
                root = self.__root
                last = root[0***REMOVED***
                last[1***REMOVED*** = root[0***REMOVED*** = self.__map[key***REMOVED*** = [last, root, key***REMOVED***
            dict_setitem(self, key, value***REMOVED***

        def __delitem__(self, key, dict_delitem=dict.__delitem__***REMOVED***:
            'od.__delitem__(y***REMOVED*** <==> del od[y***REMOVED***'
            # Deleting an existing item uses self.__map to find the link which is
            # then removed by updating the links in the predecessor and successor nodes.
            dict_delitem(self, key***REMOVED***
            link_prev, link_next, key = self.__map.pop(key***REMOVED***
            link_prev[1***REMOVED*** = link_next
            link_next[0***REMOVED*** = link_prev

        def __iter__(self***REMOVED***:
            'od.__iter__(***REMOVED*** <==> iter(od***REMOVED***'
            root = self.__root
            curr = root[1***REMOVED***
            while curr is not root:
                yield curr[2***REMOVED***
                curr = curr[1***REMOVED***

        def __reversed__(self***REMOVED***:
            'od.__reversed__(***REMOVED*** <==> reversed(od***REMOVED***'
            root = self.__root
            curr = root[0***REMOVED***
            while curr is not root:
                yield curr[2***REMOVED***
                curr = curr[0***REMOVED***

        def clear(self***REMOVED***:
            'od.clear(***REMOVED*** -> None.  Remove all items from od.'
            ***REMOVED***
                for node in self.__map.itervalues(***REMOVED***:
                    del node[:***REMOVED***
                root = self.__root
                root[:***REMOVED*** = [root, root, None***REMOVED***
                self.__map.clear(***REMOVED***
            except AttributeError:
                pass
            dict.clear(self***REMOVED***

        def popitem(self, last=True***REMOVED***:
            '''od.popitem(***REMOVED*** -> (k, v***REMOVED***, return and remove a (key, value***REMOVED*** pair.
            Pairs are returned in LIFO order if last is true or FIFO order if false.

            '''
            if not self:
                raise KeyError('dictionary is empty'***REMOVED***
            root = self.__root
            if last:
                link = root[0***REMOVED***
                link_prev = link[0***REMOVED***
                link_prev[1***REMOVED*** = root
                root[0***REMOVED*** = link_prev
            else:
                link = root[1***REMOVED***
                link_next = link[1***REMOVED***
                root[1***REMOVED*** = link_next
                link_next[0***REMOVED*** = root
            key = link[2***REMOVED***
            del self.__map[key***REMOVED***
            value = dict.pop(self, key***REMOVED***
            return key, value

        # -- the following methods do not depend on the internal structure --

        def keys(self***REMOVED***:
            'od.keys(***REMOVED*** -> list of keys in od'
            return list(self***REMOVED***

        def values(self***REMOVED***:
            'od.values(***REMOVED*** -> list of values in od'
            return [self[key***REMOVED*** for key in self***REMOVED***

        def items(self***REMOVED***:
            'od.items(***REMOVED*** -> list of (key, value***REMOVED*** pairs in od'
            return [(key, self[key***REMOVED******REMOVED*** for key in self***REMOVED***

        def iterkeys(self***REMOVED***:
            'od.iterkeys(***REMOVED*** -> an iterator over the keys in od'
            return iter(self***REMOVED***

        def itervalues(self***REMOVED***:
            'od.itervalues -> an iterator over the values in od'
            for k in self:
                yield self[k***REMOVED***

        def iteritems(self***REMOVED***:
            'od.iteritems -> an iterator over the (key, value***REMOVED*** items in od'
            for k in self:
                yield (k, self[k***REMOVED******REMOVED***

        def update(*args, **kwds***REMOVED***:
            '''od.update(E, **F***REMOVED*** -> None.  Update od from dict/iterable E and F.

            If E is a dict instance, does:           for k in E: od[k***REMOVED*** = E[k***REMOVED***
            If E has a .keys(***REMOVED*** method, does:         for k in E.keys(***REMOVED***: od[k***REMOVED*** = E[k***REMOVED***
            Or if E is an iterable of items, does:   for k, v in E: od[k***REMOVED*** = v
            In either case, this is followed by:     for k, v in F.items(***REMOVED***: od[k***REMOVED*** = v

            '''
            if len(args***REMOVED*** > 2:
                raise TypeError('update(***REMOVED*** takes at most 2 positional '
                                'arguments (%d given***REMOVED***' % (len(args***REMOVED***,***REMOVED******REMOVED***
            elif not args:
                raise TypeError('update(***REMOVED*** takes at least 1 argument (0 given***REMOVED***'***REMOVED***
            self = args[0***REMOVED***
            # Make progressively weaker assumptions about "other"
            other = (***REMOVED***
            if len(args***REMOVED*** == 2:
                other = args[1***REMOVED***
            if isinstance(other, dict***REMOVED***:
                for key in other:
                    self[key***REMOVED*** = other[key***REMOVED***
            elif hasattr(other, 'keys'***REMOVED***:
                for key in other.keys(***REMOVED***:
                    self[key***REMOVED*** = other[key***REMOVED***
            else:
                for key, value in other:
                    self[key***REMOVED*** = value
            for key, value in kwds.items(***REMOVED***:
                self[key***REMOVED*** = value

        __update = update  # let subclasses override update without breaking __init__

        __marker = object(***REMOVED***

        def pop(self, key, default=__marker***REMOVED***:
            '''od.pop(k[,d***REMOVED******REMOVED*** -> v, remove specified key and return the corresponding value.
            If key is not found, d is returned if given, otherwise KeyError is raised.

            '''
            if key in self:
                result = self[key***REMOVED***
                del self[key***REMOVED***
                return result
            if default is self.__marker:
                raise KeyError(key***REMOVED***
            return default

        def setdefault(self, key, default=None***REMOVED***:
            'od.setdefault(k[,d***REMOVED******REMOVED*** -> od.get(k,d***REMOVED***, also set od[k***REMOVED***=d if k not in od'
            if key in self:
                return self[key***REMOVED***
            self[key***REMOVED*** = default
            return default

        def __repr__(self, _repr_running=None***REMOVED***:
            'od.__repr__(***REMOVED*** <==> repr(od***REMOVED***'
            if not _repr_running: _repr_running = {***REMOVED***
            call_key = id(self***REMOVED***, _get_ident(***REMOVED***
            if call_key in _repr_running:
                return '...'
            _repr_running[call_key***REMOVED*** = 1
            ***REMOVED***
                if not self:
                    return '%s(***REMOVED***' % (self.__class__.__name__,***REMOVED***
                return '%s(%r***REMOVED***' % (self.__class__.__name__, self.items(***REMOVED******REMOVED***
            finally:
                del _repr_running[call_key***REMOVED***

        def __reduce__(self***REMOVED***:
            'Return state information for pickling'
            items = [[k, self[k***REMOVED******REMOVED*** for k in self***REMOVED***
            inst_dict = vars(self***REMOVED***.copy(***REMOVED***
            for k in vars(OrderedDict(***REMOVED******REMOVED***:
                inst_dict.pop(k, None***REMOVED***
            if inst_dict:
                return (self.__class__, (items,***REMOVED***, inst_dict***REMOVED***
            return self.__class__, (items,***REMOVED***

        def copy(self***REMOVED***:
            'od.copy(***REMOVED*** -> a shallow copy of od'
            return self.__class__(self***REMOVED***

        @classmethod
        def fromkeys(cls, iterable, value=None***REMOVED***:
            '''OD.fromkeys(S[, v***REMOVED******REMOVED*** -> New ordered dictionary with keys from S
            and values equal to v (which defaults to None***REMOVED***.

            '''
            d = cls(***REMOVED***
            for key in iterable:
                d[key***REMOVED*** = value
            return d

        def __eq__(self, other***REMOVED***:
            '''od.__eq__(y***REMOVED*** <==> od==y.  Comparison to another OD is order-sensitive
            while comparison to a regular mapping is order-insensitive.

            '''
            if isinstance(other, OrderedDict***REMOVED***:
                return len(self***REMOVED***==len(other***REMOVED*** and self.items(***REMOVED*** == other.items(***REMOVED***
            return dict.__eq__(self, other***REMOVED***

        def __ne__(self, other***REMOVED***:
            return not self == other

        # -- the following methods are only used in Python 2.7 --

        def viewkeys(self***REMOVED***:
            "od.viewkeys(***REMOVED*** -> a set-like object providing a view on od's keys"
            return KeysView(self***REMOVED***

        def viewvalues(self***REMOVED***:
            "od.viewvalues(***REMOVED*** -> an object providing a view on od's values"
            return ValuesView(self***REMOVED***

        def viewitems(self***REMOVED***:
            "od.viewitems(***REMOVED*** -> a set-like object providing a view on od's items"
            return ItemsView(self***REMOVED***

***REMOVED***
    from logging.config import BaseConfigurator, valid_ident
except ImportError: # pragma: no cover
    IDENTIFIER = re.compile('^[a-z_***REMOVED***[a-z0-9_***REMOVED****$', re.I***REMOVED***


    def valid_ident(s***REMOVED***:
        m = IDENTIFIER.match(s***REMOVED***
        if not m:
            raise ValueError('Not a valid Python identifier: %r' % s***REMOVED***
        return True


    # The ConvertingXXX classes are wrappers around standard Python containers,
    # and they serve to convert any suitable values in the container. The
    # conversion converts base dicts, lists and tuples to their wrapped
    # equivalents, whereas strings which match a conversion format are converted
    # appropriately.
    #
    # Each wrapper should have a configurator attribute holding the actual
    # configurator to use for conversion.

    class ConvertingDict(dict***REMOVED***:
        ***REMOVED***A converting dictionary wrapper.***REMOVED***

        def __getitem__(self, key***REMOVED***:
            value = dict.__getitem__(self, key***REMOVED***
            result = self.configurator.convert(value***REMOVED***
            #If the converted value is different, save for next time
            if value is not result:
                self[key***REMOVED*** = result
                if type(result***REMOVED*** in (ConvertingDict, ConvertingList,
                                    ConvertingTuple***REMOVED***:
                    result.parent = self
                    result.key = key
            return result

        def get(self, key, default=None***REMOVED***:
            value = dict.get(self, key, default***REMOVED***
            result = self.configurator.convert(value***REMOVED***
            #If the converted value is different, save for next time
            if value is not result:
                self[key***REMOVED*** = result
                if type(result***REMOVED*** in (ConvertingDict, ConvertingList,
                                    ConvertingTuple***REMOVED***:
                    result.parent = self
                    result.key = key
            return result

    def pop(self, key, default=None***REMOVED***:
        value = dict.pop(self, key, default***REMOVED***
        result = self.configurator.convert(value***REMOVED***
        if value is not result:
            if type(result***REMOVED*** in (ConvertingDict, ConvertingList,
                                ConvertingTuple***REMOVED***:
                result.parent = self
                result.key = key
        return result

    class ConvertingList(list***REMOVED***:
        ***REMOVED***A converting list wrapper.***REMOVED***
        def __getitem__(self, key***REMOVED***:
            value = list.__getitem__(self, key***REMOVED***
            result = self.configurator.convert(value***REMOVED***
            #If the converted value is different, save for next time
            if value is not result:
                self[key***REMOVED*** = result
                if type(result***REMOVED*** in (ConvertingDict, ConvertingList,
                                    ConvertingTuple***REMOVED***:
                    result.parent = self
                    result.key = key
            return result

        def pop(self, idx=-1***REMOVED***:
            value = list.pop(self, idx***REMOVED***
            result = self.configurator.convert(value***REMOVED***
            if value is not result:
                if type(result***REMOVED*** in (ConvertingDict, ConvertingList,
                                    ConvertingTuple***REMOVED***:
                    result.parent = self
            return result

    class ConvertingTuple(tuple***REMOVED***:
        ***REMOVED***A converting tuple wrapper.***REMOVED***
        def __getitem__(self, key***REMOVED***:
            value = tuple.__getitem__(self, key***REMOVED***
            result = self.configurator.convert(value***REMOVED***
            if value is not result:
                if type(result***REMOVED*** in (ConvertingDict, ConvertingList,
                                    ConvertingTuple***REMOVED***:
                    result.parent = self
                    result.key = key
            return result

    class BaseConfigurator(object***REMOVED***:
        ***REMOVED***
        The configurator base class which defines some useful defaults.
        ***REMOVED***

        CONVERT_PATTERN = re.compile(r'^(?P<prefix>[a-z***REMOVED***+***REMOVED***://(?P<suffix>.****REMOVED***$'***REMOVED***

        WORD_PATTERN = re.compile(r'^\s*(\w+***REMOVED***\s*'***REMOVED***
        DOT_PATTERN = re.compile(r'^\.\s*(\w+***REMOVED***\s*'***REMOVED***
        INDEX_PATTERN = re.compile(r'^\[\s*(\w+***REMOVED***\s*\***REMOVED***\s*'***REMOVED***
        DIGIT_PATTERN = re.compile(r'^\d+$'***REMOVED***

        value_converters = {
            'ext' : 'ext_convert',
            'cfg' : 'cfg_convert',
    ***REMOVED***

        # We might want to use a different one, e.g. importlib
        importer = staticmethod(__import__***REMOVED***

        def __init__(self, config***REMOVED***:
            self.config = ConvertingDict(config***REMOVED***
            self.config.configurator = self

        def resolve(self, s***REMOVED***:
            ***REMOVED***
            Resolve strings to objects using standard import and attribute
            syntax.
            ***REMOVED***
            name = s.split('.'***REMOVED***
            used = name.pop(0***REMOVED***
            ***REMOVED***
                found = self.importer(used***REMOVED***
                for frag in name:
                    used += '.' + frag
                    ***REMOVED***
                        found = getattr(found, frag***REMOVED***
                    except AttributeError:
                        self.importer(used***REMOVED***
                        found = getattr(found, frag***REMOVED***
                return found
            except ImportError:
                e, tb = sys.exc_info(***REMOVED***[1:***REMOVED***
                v = ValueError('Cannot resolve %r: %s' % (s, e***REMOVED******REMOVED***
                v.__cause__, v.__traceback__ = e, tb
                raise v

        def ext_convert(self, value***REMOVED***:
            ***REMOVED***Default converter for the ext:// protocol.***REMOVED***
            return self.resolve(value***REMOVED***

        def cfg_convert(self, value***REMOVED***:
            ***REMOVED***Default converter for the cfg:// protocol.***REMOVED***
            rest = value
            m = self.WORD_PATTERN.match(rest***REMOVED***
            if m is None:
                raise ValueError("Unable to convert %r" % value***REMOVED***
            else:
                rest = rest[m.end(***REMOVED***:***REMOVED***
                d = self.config[m.groups(***REMOVED***[0***REMOVED******REMOVED***
                #print d, rest
                while rest:
                    m = self.DOT_PATTERN.match(rest***REMOVED***
                    if m:
                        d = d[m.groups(***REMOVED***[0***REMOVED******REMOVED***
                    else:
                        m = self.INDEX_PATTERN.match(rest***REMOVED***
                        if m:
                            idx = m.groups(***REMOVED***[0***REMOVED***
                            if not self.DIGIT_PATTERN.match(idx***REMOVED***:
                                d = d[idx***REMOVED***
                            else:
                                ***REMOVED***
                                    n = int(idx***REMOVED*** # try as number first (most likely***REMOVED***
                                    d = d[n***REMOVED***
                                except TypeError:
                                    d = d[idx***REMOVED***
                    if m:
                        rest = rest[m.end(***REMOVED***:***REMOVED***
                    else:
                        raise ValueError('Unable to convert '
                                         '%r at %r' % (value, rest***REMOVED******REMOVED***
            #rest should be empty
            return d

        def convert(self, value***REMOVED***:
            ***REMOVED***
            Convert values to an appropriate type. dicts, lists and tuples are
            replaced by their converting alternatives. Strings are checked to
            see if they have a conversion format and are converted if they do.
            ***REMOVED***
            if not isinstance(value, ConvertingDict***REMOVED*** and isinstance(value, dict***REMOVED***:
                value = ConvertingDict(value***REMOVED***
                value.configurator = self
            elif not isinstance(value, ConvertingList***REMOVED*** and isinstance(value, list***REMOVED***:
                value = ConvertingList(value***REMOVED***
                value.configurator = self
            elif not isinstance(value, ConvertingTuple***REMOVED*** and\
                     isinstance(value, tuple***REMOVED***:
                value = ConvertingTuple(value***REMOVED***
                value.configurator = self
            elif isinstance(value, string_types***REMOVED***:
                m = self.CONVERT_PATTERN.match(value***REMOVED***
                if m:
                    d = m.groupdict(***REMOVED***
                    prefix = d['prefix'***REMOVED***
                    converter = self.value_converters.get(prefix, None***REMOVED***
                    if converter:
                        suffix = d['suffix'***REMOVED***
                        converter = getattr(self, converter***REMOVED***
                        value = converter(suffix***REMOVED***
            return value

        def configure_custom(self, config***REMOVED***:
            ***REMOVED***Configure an object with a user-supplied factory.***REMOVED***
            c = config.pop('(***REMOVED***'***REMOVED***
            if not callable(c***REMOVED***:
                c = self.resolve(c***REMOVED***
            props = config.pop('.', None***REMOVED***
            # Check for valid identifiers
            kwargs = dict([(k, config[k***REMOVED******REMOVED*** for k in config if valid_ident(k***REMOVED******REMOVED******REMOVED***
            result = c(**kwargs***REMOVED***
            if props:
                for name, value in props.items(***REMOVED***:
                    setattr(result, name, value***REMOVED***
            return result

        def as_tuple(self, value***REMOVED***:
            ***REMOVED***Utility function which converts lists to tuples.***REMOVED***
            if isinstance(value, list***REMOVED***:
                value = tuple(value***REMOVED***
            return value
