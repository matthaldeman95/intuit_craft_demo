# -*- coding: utf-8 -*-
#
# Copyright (C***REMOVED*** 2012-2013 Vinay Sajip.
# Licensed to the Python Software Foundation under a contributor agreement.
# See LICENSE.txt and CONTRIBUTORS.txt.
#
***REMOVED***Parser for the environment markers micro-language defined in PEP 345.***REMOVED***

import ast
***REMOVED***
import sys
import platform

from .compat import python_implementation, string_types
from .util import in_venv

__all__ = ['interpret'***REMOVED***


class Evaluator(object***REMOVED***:
    ***REMOVED***
    A limited evaluator for Python expressions.
    ***REMOVED***

    operators = {
        'eq': lambda x, y: x == y,
        'gt': lambda x, y: x > y,
        'gte': lambda x, y: x >= y,
        'in': lambda x, y: x in y,
        'lt': lambda x, y: x < y,
        'lte': lambda x, y: x <= y,
        'not': lambda x: not x,
        'noteq': lambda x, y: x != y,
        'notin': lambda x, y: x not in y,
***REMOVED***

    allowed_values = {
        'sys_platform': sys.platform,
        'python_version': '%s.%s' % sys.version_info[:2***REMOVED***,
        # parsing sys.platform is not reliable, but there is no other
        # way to get e.g. 2.7.2+, and the PEP is defined with sys.version
        'python_full_version': sys.version.split(' ', 1***REMOVED***[0***REMOVED***,
        'os_name': os.name,
        'platform_in_venv': str(in_venv(***REMOVED******REMOVED***,
        'platform_release': platform.release(***REMOVED***,
        'platform_version': platform.version(***REMOVED***,
        'platform_machine': platform.machine(***REMOVED***,
        'platform_python_implementation': python_implementation(***REMOVED***,
***REMOVED***

    def __init__(self, context=None***REMOVED***:
        ***REMOVED***
        Initialise an instance.

        :param context: If specified, names are looked up in this mapping.
        ***REMOVED***
        self.context = context or {***REMOVED***
        self.source = None

    def get_fragment(self, offset***REMOVED***:
        ***REMOVED***
        Get the part of the source which is causing a problem.
        ***REMOVED***
        fragment_len = 10
        s = '%r' % (self.source[offset:offset + fragment_len***REMOVED******REMOVED***
        if offset + fragment_len < len(self.source***REMOVED***:
            s += '...'
        return s

    def get_handler(self, node_type***REMOVED***:
        ***REMOVED***
        Get a handler for the specified AST node type.
        ***REMOVED***
        return getattr(self, 'do_%s' % node_type, None***REMOVED***

    def evaluate(self, node, filename=None***REMOVED***:
        ***REMOVED***
        Evaluate a source string or node, using ``filename`` when
        displaying errors.
        ***REMOVED***
        if isinstance(node, string_types***REMOVED***:
            self.source = node
            kwargs = {'mode': 'eval'***REMOVED***
            if filename:
                kwargs['filename'***REMOVED*** = filename
            ***REMOVED***
                node = ast.parse(node, **kwargs***REMOVED***
            except SyntaxError as e:
                s = self.get_fragment(e.offset***REMOVED***
                raise SyntaxError('syntax error %s' % s***REMOVED***
        node_type = node.__class__.__name__.lower(***REMOVED***
        handler = self.get_handler(node_type***REMOVED***
        if handler is None:
            if self.source is None:
                s = '(source not available***REMOVED***'
            else:
                s = self.get_fragment(node.col_offset***REMOVED***
            raise SyntaxError("don't know how to evaluate %r %s" % (
                node_type, s***REMOVED******REMOVED***
        return handler(node***REMOVED***

    def get_attr_key(self, node***REMOVED***:
        assert isinstance(node, ast.Attribute***REMOVED***, 'attribute node expected'
        return '%s.%s' % (node.value.id, node.attr***REMOVED***

    def do_attribute(self, node***REMOVED***:
        if not isinstance(node.value, ast.Name***REMOVED***:
            valid = False
        else:
            key = self.get_attr_key(node***REMOVED***
            valid = key in self.context or key in self.allowed_values
        if not valid:
            raise SyntaxError('invalid expression: %s' % key***REMOVED***
        if key in self.context:
            result = self.context[key***REMOVED***
        else:
            result = self.allowed_values[key***REMOVED***
        return result

    def do_boolop(self, node***REMOVED***:
        result = self.evaluate(node.values[0***REMOVED******REMOVED***
        is_or = node.op.__class__ is ast.Or
        is_and = node.op.__class__ is ast.And
        assert is_or or is_and
        if (is_and and result***REMOVED*** or (is_or and not result***REMOVED***:
            for n in node.values[1:***REMOVED***:
                result = self.evaluate(n***REMOVED***
                if (is_or and result***REMOVED*** or (is_and and not result***REMOVED***:
                    break
        return result

    def do_compare(self, node***REMOVED***:
        def sanity_check(lhsnode, rhsnode***REMOVED***:
            valid = True
            if isinstance(lhsnode, ast.Str***REMOVED*** and isinstance(rhsnode, ast.Str***REMOVED***:
                valid = False
            #elif (isinstance(lhsnode, ast.Attribute***REMOVED***
            #      and isinstance(rhsnode, ast.Attribute***REMOVED******REMOVED***:
            #    klhs = self.get_attr_key(lhsnode***REMOVED***
            #    krhs = self.get_attr_key(rhsnode***REMOVED***
            #    valid = klhs != krhs
            if not valid:
                s = self.get_fragment(node.col_offset***REMOVED***
                raise SyntaxError('Invalid comparison: %s' % s***REMOVED***

        lhsnode = node.left
        lhs = self.evaluate(lhsnode***REMOVED***
        result = True
        for op, rhsnode in zip(node.ops, node.comparators***REMOVED***:
            sanity_check(lhsnode, rhsnode***REMOVED***
            op = op.__class__.__name__.lower(***REMOVED***
            if op not in self.operators:
                raise SyntaxError('unsupported operation: %r' % op***REMOVED***
            rhs = self.evaluate(rhsnode***REMOVED***
            result = self.operators[op***REMOVED***(lhs, rhs***REMOVED***
            if not result:
                break
            lhs = rhs
            lhsnode = rhsnode
        return result

    def do_expression(self, node***REMOVED***:
        return self.evaluate(node.body***REMOVED***

    def do_name(self, node***REMOVED***:
        valid = False
        if node.id in self.context:
            valid = True
            result = self.context[node.id***REMOVED***
        elif node.id in self.allowed_values:
            valid = True
            result = self.allowed_values[node.id***REMOVED***
        if not valid:
            raise SyntaxError('invalid expression: %s' % node.id***REMOVED***
        return result

    def do_str(self, node***REMOVED***:
        return node.s


def interpret(marker, execution_context=None***REMOVED***:
    ***REMOVED***
    Interpret a marker and return a result depending on environment.

    :param marker: The marker to interpret.
    :type marker: str
    :param execution_context: The context used for name lookup.
    :type execution_context: mapping
    ***REMOVED***
    return Evaluator(execution_context***REMOVED***.evaluate(marker.strip(***REMOVED******REMOVED***
