# -*- coding: utf-8 -*-
#
# Copyright (C***REMOVED*** 2013-2016 Vinay Sajip.
# Licensed to the Python Software Foundation under a contributor agreement.
# See LICENSE.txt and CONTRIBUTORS.txt.
#
from __future__ import unicode_literals

import bisect
import io
import logging
***REMOVED***
import pkgutil
import shutil
import sys
import types
import zipimport

from . import DistlibException
from .util import cached_property, get_cache_base, path_to_cache_dir, Cache

logger = logging.getLogger(__name__***REMOVED***


cache = None    # created when needed


class ResourceCache(Cache***REMOVED***:
    def __init__(self, base=None***REMOVED***:
        if base is None:
            # Use native string to avoid issues on 2.x: see Python #20140.
            base = os.path.join(get_cache_base(***REMOVED***, str('resource-cache'***REMOVED******REMOVED***
        super(ResourceCache, self***REMOVED***.__init__(base***REMOVED***

    def is_stale(self, resource, path***REMOVED***:
        ***REMOVED***
        Is the cache stale for the given resource?

        :param resource: The :class:`Resource` being cached.
        :param path: The path of the resource in the cache.
        :return: True if the cache is stale.
        ***REMOVED***
        # Cache invalidation is a hard problem :-***REMOVED***
        return True

    def get(self, resource***REMOVED***:
        ***REMOVED***
        Get a resource into the cache,

        :param resource: A :class:`Resource` instance.
        :return: The pathname of the resource in the cache.
        ***REMOVED***
        prefix, path = resource.finder.get_cache_info(resource***REMOVED***
        if prefix is None:
            result = path
        else:
            result = os.path.join(self.base, self.prefix_to_dir(prefix***REMOVED***, path***REMOVED***
            dirname = os.path.dirname(result***REMOVED***
            if not os.path.isdir(dirname***REMOVED***:
                os.makedirs(dirname***REMOVED***
            if not os.path.exists(result***REMOVED***:
                stale = True
            else:
                stale = self.is_stale(resource, path***REMOVED***
            if stale:
                # write the bytes of the resource to the cache location
                with open(result, 'wb'***REMOVED*** as f:
                    f.write(resource.bytes***REMOVED***
        return result


class ResourceBase(object***REMOVED***:
    def __init__(self, finder, name***REMOVED***:
        self.finder = finder
        self.name = name


class Resource(ResourceBase***REMOVED***:
    ***REMOVED***
    A class representing an in-package resource, such as a data file. This is
    not normally instantiated by user code, but rather by a
    :class:`ResourceFinder` which manages the resource.
    ***REMOVED***
    is_container = False        # Backwards compatibility

    def as_stream(self***REMOVED***:
        ***REMOVED***
        Get the resource as a stream.

        This is not a property to make it obvious that it returns a new stream
        each time.
        ***REMOVED***
        return self.finder.get_stream(self***REMOVED***

    @cached_property
    def file_path(self***REMOVED***:
        global cache
        if cache is None:
            cache = ResourceCache(***REMOVED***
        return cache.get(self***REMOVED***

    @cached_property
    def bytes(self***REMOVED***:
        return self.finder.get_bytes(self***REMOVED***

    @cached_property
    def size(self***REMOVED***:
        return self.finder.get_size(self***REMOVED***


class ResourceContainer(ResourceBase***REMOVED***:
    is_container = True     # Backwards compatibility

    @cached_property
    def resources(self***REMOVED***:
        return self.finder.get_resources(self***REMOVED***


class ResourceFinder(object***REMOVED***:
    ***REMOVED***
    Resource finder for file system resources.
    ***REMOVED***

    if sys.platform.startswith('java'***REMOVED***:
        skipped_extensions = ('.pyc', '.pyo', '.class'***REMOVED***
    else:
        skipped_extensions = ('.pyc', '.pyo'***REMOVED***

    def __init__(self, module***REMOVED***:
        self.module = module
        self.loader = getattr(module, '__loader__', None***REMOVED***
        self.base = os.path.dirname(getattr(module, '__file__', ''***REMOVED******REMOVED***

    def _adjust_path(self, path***REMOVED***:
        return os.path.realpath(path***REMOVED***

    def _make_path(self, resource_name***REMOVED***:
        # Issue #50: need to preserve type of path on Python 2.x
        # like os.path._get_sep
        if isinstance(resource_name, bytes***REMOVED***:    # should only happen on 2.x
            sep = b'/'
        else:
            sep = '/'
        parts = resource_name.split(sep***REMOVED***
        parts.insert(0, self.base***REMOVED***
        result = os.path.join(*parts***REMOVED***
        return self._adjust_path(result***REMOVED***

    def _find(self, path***REMOVED***:
        return os.path.exists(path***REMOVED***

    def get_cache_info(self, resource***REMOVED***:
        return None, resource.path

    def find(self, resource_name***REMOVED***:
        path = self._make_path(resource_name***REMOVED***
        if not self._find(path***REMOVED***:
            result = None
        else:
            if self._is_directory(path***REMOVED***:
                result = ResourceContainer(self, resource_name***REMOVED***
            else:
                result = Resource(self, resource_name***REMOVED***
            result.path = path
        return result

    def get_stream(self, resource***REMOVED***:
        return open(resource.path, 'rb'***REMOVED***

    def get_bytes(self, resource***REMOVED***:
        with open(resource.path, 'rb'***REMOVED*** as f:
            return f.read(***REMOVED***

    def get_size(self, resource***REMOVED***:
        return os.path.getsize(resource.path***REMOVED***

    def get_resources(self, resource***REMOVED***:
        def allowed(f***REMOVED***:
            return (f != '__pycache__' and not
                    f.endswith(self.skipped_extensions***REMOVED******REMOVED***
        return set([f for f in os.listdir(resource.path***REMOVED*** if allowed(f***REMOVED******REMOVED******REMOVED***

    def is_container(self, resource***REMOVED***:
        return self._is_directory(resource.path***REMOVED***

    _is_directory = staticmethod(os.path.isdir***REMOVED***

    def iterator(self, resource_name***REMOVED***:
        resource = self.find(resource_name***REMOVED***
        if resource is not None:
            todo = [resource***REMOVED***
            while todo:
                resource = todo.pop(0***REMOVED***
                yield resource
                if resource.is_container:
                    rname = resource.name
                    for name in resource.resources:
                        if not rname:
                            new_name = name
                        else:
                            new_name = '/'.join([rname, name***REMOVED******REMOVED***
                        child = self.find(new_name***REMOVED***
                        if child.is_container:
                            todo.append(child***REMOVED***
                        else:
                            yield child


class ZipResourceFinder(ResourceFinder***REMOVED***:
    ***REMOVED***
    Resource finder for resources in .zip files.
    ***REMOVED***
    def __init__(self, module***REMOVED***:
        super(ZipResourceFinder, self***REMOVED***.__init__(module***REMOVED***
        archive = self.loader.archive
        self.prefix_len = 1 + len(archive***REMOVED***
        # PyPy doesn't have a _files attr on zipimporter, and you can't set one
        if hasattr(self.loader, '_files'***REMOVED***:
            self._files = self.loader._files
        else:
            self._files = zipimport._zip_directory_cache[archive***REMOVED***
        self.index = sorted(self._files***REMOVED***

    def _adjust_path(self, path***REMOVED***:
        return path

    def _find(self, path***REMOVED***:
        path = path[self.prefix_len:***REMOVED***
        if path in self._files:
            result = True
        else:
            if path and path[-1***REMOVED*** != os.sep:
                path = path + os.sep
            i = bisect.bisect(self.index, path***REMOVED***
            ***REMOVED***
                result = self.index[i***REMOVED***.startswith(path***REMOVED***
            except IndexError:
                result = False
        if not result:
            logger.debug('_find failed: %r %r', path, self.loader.prefix***REMOVED***
        else:
            logger.debug('_find worked: %r %r', path, self.loader.prefix***REMOVED***
        return result

    def get_cache_info(self, resource***REMOVED***:
        prefix = self.loader.archive
        path = resource.path[1 + len(prefix***REMOVED***:***REMOVED***
        return prefix, path

    def get_bytes(self, resource***REMOVED***:
        return self.loader.get_data(resource.path***REMOVED***

    def get_stream(self, resource***REMOVED***:
        return io.BytesIO(self.get_bytes(resource***REMOVED******REMOVED***

    def get_size(self, resource***REMOVED***:
        path = resource.path[self.prefix_len:***REMOVED***
        return self._files[path***REMOVED***[3***REMOVED***

    def get_resources(self, resource***REMOVED***:
        path = resource.path[self.prefix_len:***REMOVED***
        if path and path[-1***REMOVED*** != os.sep:
            path += os.sep
        plen = len(path***REMOVED***
        result = set(***REMOVED***
        i = bisect.bisect(self.index, path***REMOVED***
        while i < len(self.index***REMOVED***:
            if not self.index[i***REMOVED***.startswith(path***REMOVED***:
                break
            s = self.index[i***REMOVED***[plen:***REMOVED***
            result.add(s.split(os.sep, 1***REMOVED***[0***REMOVED******REMOVED***   # only immediate children
            i += 1
        return result

    def _is_directory(self, path***REMOVED***:
        path = path[self.prefix_len:***REMOVED***
        if path and path[-1***REMOVED*** != os.sep:
            path += os.sep
        i = bisect.bisect(self.index, path***REMOVED***
        ***REMOVED***
            result = self.index[i***REMOVED***.startswith(path***REMOVED***
        except IndexError:
            result = False
        return result

_finder_registry = {
    type(None***REMOVED***: ResourceFinder,
    zipimport.zipimporter: ZipResourceFinder
***REMOVED***

***REMOVED***
    import _frozen_importlib
    _finder_registry[_frozen_importlib.SourceFileLoader***REMOVED*** = ResourceFinder
    _finder_registry[_frozen_importlib.FileFinder***REMOVED*** = ResourceFinder
except (ImportError, AttributeError***REMOVED***:
    pass


def register_finder(loader, finder_maker***REMOVED***:
    _finder_registry[type(loader***REMOVED******REMOVED*** = finder_maker

_finder_cache = {***REMOVED***


def finder(package***REMOVED***:
    ***REMOVED***
    Return a resource finder for a package.
    :param package: The name of the package.
    :return: A :class:`ResourceFinder` instance for the package.
    ***REMOVED***
    if package in _finder_cache:
        result = _finder_cache[package***REMOVED***
    else:
        if package not in sys.modules:
            __import__(package***REMOVED***
        module = sys.modules[package***REMOVED***
        path = getattr(module, '__path__', None***REMOVED***
        if path is None:
            raise DistlibException('You cannot get a finder for a module, '
                                   'only for a package'***REMOVED***
        loader = getattr(module, '__loader__', None***REMOVED***
        finder_maker = _finder_registry.get(type(loader***REMOVED******REMOVED***
        if finder_maker is None:
            raise DistlibException('Unable to locate finder for %r' % package***REMOVED***
        result = finder_maker(module***REMOVED***
        _finder_cache[package***REMOVED*** = result
    return result


_dummy_module = types.ModuleType(str('__dummy__'***REMOVED******REMOVED***


def finder_for_path(path***REMOVED***:
    ***REMOVED***
    Return a resource finder for a path, which should represent a container.

    :param path: The path.
    :return: A :class:`ResourceFinder` instance for the path.
    ***REMOVED***
    result = None
    # calls any path hooks, gets importer into cache
    pkgutil.get_importer(path***REMOVED***
    loader = sys.path_importer_cache.get(path***REMOVED***
    finder = _finder_registry.get(type(loader***REMOVED******REMOVED***
    if finder:
        module = _dummy_module
        module.__file__ = os.path.join(path, ''***REMOVED***
        module.__loader__ = loader
        result = finder(module***REMOVED***
    return result
