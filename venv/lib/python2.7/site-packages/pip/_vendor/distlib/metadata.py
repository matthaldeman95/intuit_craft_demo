# -*- coding: utf-8 -*-
#
# Copyright (C***REMOVED*** 2012 The Python Software Foundation.
# See LICENSE.txt and CONTRIBUTORS.txt.
#
***REMOVED***Implementation of the Metadata for Python packages PEPs.

Supports all metadata formats (1.0, 1.1, 1.2, and 2.0 experimental***REMOVED***.
***REMOVED***
from __future__ import unicode_literals

import codecs
from email import message_from_file
import json
import logging
import re


from . import DistlibException, __version__
from .compat import StringIO, string_types, text_type
from .markers import interpret
from .util import extract_by_key, get_extras
from .version import get_scheme, PEP440_VERSION_RE

logger = logging.getLogger(__name__***REMOVED***


class MetadataMissingError(DistlibException***REMOVED***:
    ***REMOVED***A required metadata is missing***REMOVED***


class MetadataConflictError(DistlibException***REMOVED***:
    ***REMOVED***Attempt to read or write metadata fields that are conflictual.***REMOVED***


class MetadataUnrecognizedVersionError(DistlibException***REMOVED***:
    ***REMOVED***Unknown metadata version number.***REMOVED***


class MetadataInvalidError(DistlibException***REMOVED***:
    ***REMOVED***A metadata value is invalid***REMOVED***

# public API of this module
__all__ = ['Metadata', 'PKG_INFO_ENCODING', 'PKG_INFO_PREFERRED_VERSION'***REMOVED***

# Encoding used for the PKG-INFO files
PKG_INFO_ENCODING = 'utf-8'

# preferred version. Hopefully will be changed
# to 1.2 once PEP 345 is supported everywhere
PKG_INFO_PREFERRED_VERSION = '1.1'

_LINE_PREFIX_1_2 = re.compile('\n       \|'***REMOVED***
_LINE_PREFIX_PRE_1_2 = re.compile('\n        '***REMOVED***
_241_FIELDS = ('Metadata-Version', 'Name', 'Version', 'Platform',
               'Summary', 'Description',
               'Keywords', 'Home-page', 'Author', 'Author-email',
               'License'***REMOVED***

_314_FIELDS = ('Metadata-Version', 'Name', 'Version', 'Platform',
               'Supported-Platform', 'Summary', 'Description',
               'Keywords', 'Home-page', 'Author', 'Author-email',
               'License', 'Classifier', 'Download-URL', 'Obsoletes',
               'Provides', 'Requires'***REMOVED***

_314_MARKERS = ('Obsoletes', 'Provides', 'Requires', 'Classifier',
                'Download-URL'***REMOVED***

_345_FIELDS = ('Metadata-Version', 'Name', 'Version', 'Platform',
               'Supported-Platform', 'Summary', 'Description',
               'Keywords', 'Home-page', 'Author', 'Author-email',
               'Maintainer', 'Maintainer-email', 'License',
               'Classifier', 'Download-URL', 'Obsoletes-Dist',
               'Project-URL', 'Provides-Dist', 'Requires-Dist',
               'Requires-Python', 'Requires-External'***REMOVED***

_345_MARKERS = ('Provides-Dist', 'Requires-Dist', 'Requires-Python',
                'Obsoletes-Dist', 'Requires-External', 'Maintainer',
                'Maintainer-email', 'Project-URL'***REMOVED***

_426_FIELDS = ('Metadata-Version', 'Name', 'Version', 'Platform',
               'Supported-Platform', 'Summary', 'Description',
               'Keywords', 'Home-page', 'Author', 'Author-email',
               'Maintainer', 'Maintainer-email', 'License',
               'Classifier', 'Download-URL', 'Obsoletes-Dist',
               'Project-URL', 'Provides-Dist', 'Requires-Dist',
               'Requires-Python', 'Requires-External', 'Private-Version',
               'Obsoleted-By', 'Setup-Requires-Dist', 'Extension',
               'Provides-Extra'***REMOVED***

_426_MARKERS = ('Private-Version', 'Provides-Extra', 'Obsoleted-By',
                'Setup-Requires-Dist', 'Extension'***REMOVED***

_ALL_FIELDS = set(***REMOVED***
_ALL_FIELDS.update(_241_FIELDS***REMOVED***
_ALL_FIELDS.update(_314_FIELDS***REMOVED***
_ALL_FIELDS.update(_345_FIELDS***REMOVED***
_ALL_FIELDS.update(_426_FIELDS***REMOVED***

EXTRA_RE = re.compile(r'''extra\s*==\s*("([^"***REMOVED***+***REMOVED***"|'([^'***REMOVED***+***REMOVED***'***REMOVED***'''***REMOVED***


def _version2fieldlist(version***REMOVED***:
    if version == '1.0':
        return _241_FIELDS
    elif version == '1.1':
        return _314_FIELDS
    elif version == '1.2':
        return _345_FIELDS
    elif version == '2.0':
        return _426_FIELDS
    raise MetadataUnrecognizedVersionError(version***REMOVED***


def _best_version(fields***REMOVED***:
    ***REMOVED***Detect the best version depending on the fields used.***REMOVED***
    def _has_marker(keys, markers***REMOVED***:
        for marker in markers:
            if marker in keys:
                return True
        return False

    keys = [***REMOVED***
    for key, value in fields.items(***REMOVED***:
        if value in ([***REMOVED***, 'UNKNOWN', None***REMOVED***:
            continue
        keys.append(key***REMOVED***

    possible_versions = ['1.0', '1.1', '1.2', '2.0'***REMOVED***

    # first let's try to see if a field is not part of one of the version
    for key in keys:
        if key not in _241_FIELDS and '1.0' in possible_versions:
            possible_versions.remove('1.0'***REMOVED***
        if key not in _314_FIELDS and '1.1' in possible_versions:
            possible_versions.remove('1.1'***REMOVED***
        if key not in _345_FIELDS and '1.2' in possible_versions:
            possible_versions.remove('1.2'***REMOVED***
        if key not in _426_FIELDS and '2.0' in possible_versions:
            possible_versions.remove('2.0'***REMOVED***

    # possible_version contains qualified versions
    if len(possible_versions***REMOVED*** == 1:
        return possible_versions[0***REMOVED***   # found !
    elif len(possible_versions***REMOVED*** == 0:
        raise MetadataConflictError('Unknown metadata set'***REMOVED***

    # let's see if one unique marker is found
    is_1_1 = '1.1' in possible_versions and _has_marker(keys, _314_MARKERS***REMOVED***
    is_1_2 = '1.2' in possible_versions and _has_marker(keys, _345_MARKERS***REMOVED***
    is_2_0 = '2.0' in possible_versions and _has_marker(keys, _426_MARKERS***REMOVED***
    if int(is_1_1***REMOVED*** + int(is_1_2***REMOVED*** + int(is_2_0***REMOVED*** > 1:
        raise MetadataConflictError('You used incompatible 1.1/1.2/2.0 fields'***REMOVED***

    # we have the choice, 1.0, or 1.2, or 2.0
    #   - 1.0 has a broken Summary field but works with all tools
    #   - 1.1 is to avoid
    #   - 1.2 fixes Summary but has little adoption
    #   - 2.0 adds more features and is very new
    if not is_1_1 and not is_1_2 and not is_2_0:
        # we couldn't find any specific marker
        if PKG_INFO_PREFERRED_VERSION in possible_versions:
            return PKG_INFO_PREFERRED_VERSION
    if is_1_1:
        return '1.1'
    if is_1_2:
        return '1.2'

    return '2.0'

_ATTR2FIELD = {
    'metadata_version': 'Metadata-Version',
    'name': 'Name',
    'version': 'Version',
    'platform': 'Platform',
    'supported_platform': 'Supported-Platform',
    'summary': 'Summary',
    'description': 'Description',
    'keywords': 'Keywords',
    'home_page': 'Home-page',
    'author': 'Author',
    'author_email': 'Author-email',
    'maintainer': 'Maintainer',
    'maintainer_email': 'Maintainer-email',
    'license': 'License',
    'classifier': 'Classifier',
    'download_url': 'Download-URL',
    'obsoletes_dist': 'Obsoletes-Dist',
    'provides_dist': 'Provides-Dist',
    'requires_dist': 'Requires-Dist',
    'setup_requires_dist': 'Setup-Requires-Dist',
    'requires_python': 'Requires-Python',
    'requires_external': 'Requires-External',
    'requires': 'Requires',
    'provides': 'Provides',
    'obsoletes': 'Obsoletes',
    'project_url': 'Project-URL',
    'private_version': 'Private-Version',
    'obsoleted_by': 'Obsoleted-By',
    'extension': 'Extension',
    'provides_extra': 'Provides-Extra',
***REMOVED***

_PREDICATE_FIELDS = ('Requires-Dist', 'Obsoletes-Dist', 'Provides-Dist'***REMOVED***
_VERSIONS_FIELDS = ('Requires-Python',***REMOVED***
_VERSION_FIELDS = ('Version',***REMOVED***
_LISTFIELDS = ('Platform', 'Classifier', 'Obsoletes',
               'Requires', 'Provides', 'Obsoletes-Dist',
               'Provides-Dist', 'Requires-Dist', 'Requires-External',
               'Project-URL', 'Supported-Platform', 'Setup-Requires-Dist',
               'Provides-Extra', 'Extension'***REMOVED***
_LISTTUPLEFIELDS = ('Project-URL',***REMOVED***

_ELEMENTSFIELD = ('Keywords',***REMOVED***

_UNICODEFIELDS = ('Author', 'Maintainer', 'Summary', 'Description'***REMOVED***

_MISSING = object(***REMOVED***

_FILESAFE = re.compile('[^A-Za-z0-9.***REMOVED***+'***REMOVED***


def _get_name_and_version(name, version, for_filename=False***REMOVED***:
    ***REMOVED***Return the distribution name with version.

    If for_filename is true, return a filename-escaped form.***REMOVED***
    if for_filename:
        # For both name and version any runs of non-alphanumeric or '.'
        # characters are replaced with a single '-'.  Additionally any
        # spaces in the version string become '.'
        name = _FILESAFE.sub('-', name***REMOVED***
        version = _FILESAFE.sub('-', version.replace(' ', '.'***REMOVED******REMOVED***
    return '%s-%s' % (name, version***REMOVED***


class LegacyMetadata(object***REMOVED***:
    ***REMOVED***The legacy metadata of a release.

    Supports versions 1.0, 1.1 and 1.2 (auto-detected***REMOVED***. You can
    instantiate the class with one of these arguments (or none***REMOVED***:
    - *path*, the path to a metadata file
    - *fileobj* give a file-like object with metadata as content
    - *mapping* is a dict-like object
    - *scheme* is a version scheme name
    ***REMOVED***
    # TODO document the mapping API and UNKNOWN default key

    def __init__(self, path=None, fileobj=None, mapping=None,
                 scheme='default'***REMOVED***:
        if [path, fileobj, mapping***REMOVED***.count(None***REMOVED*** < 2:
            raise TypeError('path, fileobj and mapping are exclusive'***REMOVED***
        self._fields = {***REMOVED***
        self.requires_files = [***REMOVED***
        self._dependencies = None
        self.scheme = scheme
        if path is not None:
            self.read(path***REMOVED***
        elif fileobj is not None:
            self.read_file(fileobj***REMOVED***
        elif mapping is not None:
            self.update(mapping***REMOVED***
            self.set_metadata_version(***REMOVED***

    def set_metadata_version(self***REMOVED***:
        self._fields['Metadata-Version'***REMOVED*** = _best_version(self._fields***REMOVED***

    def _write_field(self, fileobj, name, value***REMOVED***:
        fileobj.write('%s: %s\n' % (name, value***REMOVED******REMOVED***

    def __getitem__(self, name***REMOVED***:
        return self.get(name***REMOVED***

    def __setitem__(self, name, value***REMOVED***:
        return self.set(name, value***REMOVED***

    def __delitem__(self, name***REMOVED***:
        field_name = self._convert_name(name***REMOVED***
        ***REMOVED***
            del self._fields[field_name***REMOVED***
        except KeyError:
            raise KeyError(name***REMOVED***

    def __contains__(self, name***REMOVED***:
        return (name in self._fields or
                self._convert_name(name***REMOVED*** in self._fields***REMOVED***

    def _convert_name(self, name***REMOVED***:
        if name in _ALL_FIELDS:
            return name
        name = name.replace('-', '_'***REMOVED***.lower(***REMOVED***
        return _ATTR2FIELD.get(name, name***REMOVED***

    def _default_value(self, name***REMOVED***:
        if name in _LISTFIELDS or name in _ELEMENTSFIELD:
            return [***REMOVED***
        return 'UNKNOWN'

    def _remove_line_prefix(self, value***REMOVED***:
        if self.metadata_version in ('1.0', '1.1'***REMOVED***:
            return _LINE_PREFIX_PRE_1_2.sub('\n', value***REMOVED***
        else:
            return _LINE_PREFIX_1_2.sub('\n', value***REMOVED***

    def __getattr__(self, name***REMOVED***:
        if name in _ATTR2FIELD:
            return self[name***REMOVED***
        raise AttributeError(name***REMOVED***

    #
    # Public API
    #

#    dependencies = property(_get_dependencies, _set_dependencies***REMOVED***

    def get_fullname(self, filesafe=False***REMOVED***:
        ***REMOVED***Return the distribution name with version.

        If filesafe is true, return a filename-escaped form.***REMOVED***
        return _get_name_and_version(self['Name'***REMOVED***, self['Version'***REMOVED***, filesafe***REMOVED***

    def is_field(self, name***REMOVED***:
        ***REMOVED***return True if name is a valid metadata key***REMOVED***
        name = self._convert_name(name***REMOVED***
        return name in _ALL_FIELDS

    def is_multi_field(self, name***REMOVED***:
        name = self._convert_name(name***REMOVED***
        return name in _LISTFIELDS

    def read(self, filepath***REMOVED***:
        ***REMOVED***Read the metadata values from a file path.***REMOVED***
        fp = codecs.open(filepath, 'r', encoding='utf-8'***REMOVED***
        ***REMOVED***
            self.read_file(fp***REMOVED***
        finally:
            fp.close(***REMOVED***

    def read_file(self, fileob***REMOVED***:
        ***REMOVED***Read the metadata values from a file object.***REMOVED***
        msg = message_from_file(fileob***REMOVED***
        self._fields['Metadata-Version'***REMOVED*** = msg['metadata-version'***REMOVED***

        # When reading, get all the fields we can
        for field in _ALL_FIELDS:
            if field not in msg:
                continue
            if field in _LISTFIELDS:
                # we can have multiple lines
                values = msg.get_all(field***REMOVED***
                if field in _LISTTUPLEFIELDS and values is not None:
                    values = [tuple(value.split(','***REMOVED******REMOVED*** for value in values***REMOVED***
                self.set(field, values***REMOVED***
            else:
                # single line
                value = msg[field***REMOVED***
                if value is not None and value != 'UNKNOWN':
                    self.set(field, value***REMOVED***
        self.set_metadata_version(***REMOVED***

    def write(self, filepath, skip_unknown=False***REMOVED***:
        ***REMOVED***Write the metadata fields to filepath.***REMOVED***
        fp = codecs.open(filepath, 'w', encoding='utf-8'***REMOVED***
        ***REMOVED***
            self.write_file(fp, skip_unknown***REMOVED***
        finally:
            fp.close(***REMOVED***

    def write_file(self, fileobject, skip_unknown=False***REMOVED***:
        ***REMOVED***Write the PKG-INFO format data to a file object.***REMOVED***
        self.set_metadata_version(***REMOVED***

        for field in _version2fieldlist(self['Metadata-Version'***REMOVED******REMOVED***:
            values = self.get(field***REMOVED***
            if skip_unknown and values in ('UNKNOWN', [***REMOVED***, ['UNKNOWN'***REMOVED******REMOVED***:
                continue
            if field in _ELEMENTSFIELD:
                self._write_field(fileobject, field, ','.join(values***REMOVED******REMOVED***
                continue
            if field not in _LISTFIELDS:
                if field == 'Description':
                    if self.metadata_version in ('1.0', '1.1'***REMOVED***:
                        values = values.replace('\n', '\n        '***REMOVED***
                    else:
                        values = values.replace('\n', '\n       |'***REMOVED***
                values = [values***REMOVED***

            if field in _LISTTUPLEFIELDS:
                values = [','.join(value***REMOVED*** for value in values***REMOVED***

            for value in values:
                self._write_field(fileobject, field, value***REMOVED***

    def update(self, other=None, **kwargs***REMOVED***:
        ***REMOVED***Set metadata values from the given iterable `other` and kwargs.

        Behavior is like `dict.update`: If `other` has a ``keys`` method,
        they are looped over and ``self[key***REMOVED***`` is assigned ``other[key***REMOVED***``.
        Else, ``other`` is an iterable of ``(key, value***REMOVED***`` iterables.

        Keys that don't match a metadata field or that have an empty value are
        dropped.
        ***REMOVED***
        def _set(key, value***REMOVED***:
            if key in _ATTR2FIELD and value:
                self.set(self._convert_name(key***REMOVED***, value***REMOVED***

        if not other:
            # other is None or empty container
            pass
        elif hasattr(other, 'keys'***REMOVED***:
            for k in other.keys(***REMOVED***:
                _set(k, other[k***REMOVED******REMOVED***
        else:
            for k, v in other:
                _set(k, v***REMOVED***

        if kwargs:
            for k, v in kwargs.items(***REMOVED***:
                _set(k, v***REMOVED***

    def set(self, name, value***REMOVED***:
        ***REMOVED***Control then set a metadata field.***REMOVED***
        name = self._convert_name(name***REMOVED***

        if ((name in _ELEMENTSFIELD or name == 'Platform'***REMOVED*** and
            not isinstance(value, (list, tuple***REMOVED******REMOVED******REMOVED***:
            if isinstance(value, string_types***REMOVED***:
                value = [v.strip(***REMOVED*** for v in value.split(','***REMOVED******REMOVED***
            else:
                value = [***REMOVED***
        elif (name in _LISTFIELDS and
              not isinstance(value, (list, tuple***REMOVED******REMOVED******REMOVED***:
            if isinstance(value, string_types***REMOVED***:
                value = [value***REMOVED***
            else:
                value = [***REMOVED***

        if logger.isEnabledFor(logging.WARNING***REMOVED***:
            project_name = self['Name'***REMOVED***

            scheme = get_scheme(self.scheme***REMOVED***
            if name in _PREDICATE_FIELDS and value is not None:
                for v in value:
                    # check that the values are valid
                    if not scheme.is_valid_matcher(v.split(';'***REMOVED***[0***REMOVED******REMOVED***:
                        logger.warning(
                            '%r: %r is not valid (field %r***REMOVED***',
                            project_name, v, name***REMOVED***
            # FIXME this rejects UNKNOWN, is that right?
            elif name in _VERSIONS_FIELDS and value is not None:
                if not scheme.is_valid_constraint_list(value***REMOVED***:
                    logger.warning('%r: %r is not a valid version (field %r***REMOVED***',
                                   project_name, value, name***REMOVED***
            elif name in _VERSION_FIELDS and value is not None:
                if not scheme.is_valid_version(value***REMOVED***:
                    logger.warning('%r: %r is not a valid version (field %r***REMOVED***',
                                   project_name, value, name***REMOVED***

        if name in _UNICODEFIELDS:
            if name == 'Description':
                value = self._remove_line_prefix(value***REMOVED***

        self._fields[name***REMOVED*** = value

    def get(self, name, default=_MISSING***REMOVED***:
        ***REMOVED***Get a metadata field.***REMOVED***
        name = self._convert_name(name***REMOVED***
        if name not in self._fields:
            if default is _MISSING:
                default = self._default_value(name***REMOVED***
            return default
        if name in _UNICODEFIELDS:
            value = self._fields[name***REMOVED***
            return value
        elif name in _LISTFIELDS:
            value = self._fields[name***REMOVED***
            if value is None:
                return [***REMOVED***
            res = [***REMOVED***
            for val in value:
                if name not in _LISTTUPLEFIELDS:
                    res.append(val***REMOVED***
                else:
                    # That's for Project-URL
                    res.append((val[0***REMOVED***, val[1***REMOVED******REMOVED******REMOVED***
            return res

        elif name in _ELEMENTSFIELD:
            value = self._fields[name***REMOVED***
            if isinstance(value, string_types***REMOVED***:
                return value.split(','***REMOVED***
        return self._fields[name***REMOVED***

    def check(self, strict=False***REMOVED***:
        ***REMOVED***Check if the metadata is compliant. If strict is True then raise if
        no Name or Version are provided***REMOVED***
        self.set_metadata_version(***REMOVED***

        # XXX should check the versions (if the file was loaded***REMOVED***
        missing, warnings = [***REMOVED***, [***REMOVED***

        for attr in ('Name', 'Version'***REMOVED***:  # required by PEP 345
            if attr not in self:
                missing.append(attr***REMOVED***

        if strict and missing != [***REMOVED***:
            msg = 'missing required metadata: %s' % ', '.join(missing***REMOVED***
            raise MetadataMissingError(msg***REMOVED***

        for attr in ('Home-page', 'Author'***REMOVED***:
            if attr not in self:
                missing.append(attr***REMOVED***

        # checking metadata 1.2 (XXX needs to check 1.1, 1.0***REMOVED***
        if self['Metadata-Version'***REMOVED*** != '1.2':
            return missing, warnings

        scheme = get_scheme(self.scheme***REMOVED***

        def are_valid_constraints(value***REMOVED***:
            for v in value:
                if not scheme.is_valid_matcher(v.split(';'***REMOVED***[0***REMOVED******REMOVED***:
                    return False
            return True

        for fields, controller in ((_PREDICATE_FIELDS, are_valid_constraints***REMOVED***,
                                   (_VERSIONS_FIELDS,
                                    scheme.is_valid_constraint_list***REMOVED***,
                                   (_VERSION_FIELDS,
                                    scheme.is_valid_version***REMOVED******REMOVED***:
            for field in fields:
                value = self.get(field, None***REMOVED***
                if value is not None and not controller(value***REMOVED***:
                    warnings.append('Wrong value for %r: %s' % (field, value***REMOVED******REMOVED***

        return missing, warnings

    def todict(self, skip_missing=False***REMOVED***:
        ***REMOVED***Return fields as a dict.

        Field names will be converted to use the underscore-lowercase style
        instead of hyphen-mixed case (i.e. home_page instead of Home-page***REMOVED***.
        ***REMOVED***
        self.set_metadata_version(***REMOVED***

        mapping_1_0 = (
            ('metadata_version', 'Metadata-Version'***REMOVED***,
            ('name', 'Name'***REMOVED***,
            ('version', 'Version'***REMOVED***,
            ('summary', 'Summary'***REMOVED***,
            ('home_page', 'Home-page'***REMOVED***,
            ('author', 'Author'***REMOVED***,
            ('author_email', 'Author-email'***REMOVED***,
            ('license', 'License'***REMOVED***,
            ('description', 'Description'***REMOVED***,
            ('keywords', 'Keywords'***REMOVED***,
            ('platform', 'Platform'***REMOVED***,
            ('classifiers', 'Classifier'***REMOVED***,
            ('download_url', 'Download-URL'***REMOVED***,
        ***REMOVED***

        data = {***REMOVED***
        for key, field_name in mapping_1_0:
            if not skip_missing or field_name in self._fields:
                data[key***REMOVED*** = self[field_name***REMOVED***

        if self['Metadata-Version'***REMOVED*** == '1.2':
            mapping_1_2 = (
                ('requires_dist', 'Requires-Dist'***REMOVED***,
                ('requires_python', 'Requires-Python'***REMOVED***,
                ('requires_external', 'Requires-External'***REMOVED***,
                ('provides_dist', 'Provides-Dist'***REMOVED***,
                ('obsoletes_dist', 'Obsoletes-Dist'***REMOVED***,
                ('project_url', 'Project-URL'***REMOVED***,
                ('maintainer', 'Maintainer'***REMOVED***,
                ('maintainer_email', 'Maintainer-email'***REMOVED***,
            ***REMOVED***
            for key, field_name in mapping_1_2:
                if not skip_missing or field_name in self._fields:
                    if key != 'project_url':
                        data[key***REMOVED*** = self[field_name***REMOVED***
                    else:
                        data[key***REMOVED*** = [','.join(u***REMOVED*** for u in self[field_name***REMOVED******REMOVED***

        elif self['Metadata-Version'***REMOVED*** == '1.1':
            mapping_1_1 = (
                ('provides', 'Provides'***REMOVED***,
                ('requires', 'Requires'***REMOVED***,
                ('obsoletes', 'Obsoletes'***REMOVED***,
            ***REMOVED***
            for key, field_name in mapping_1_1:
                if not skip_missing or field_name in self._fields:
                    data[key***REMOVED*** = self[field_name***REMOVED***

        return data

    def add_requirements(self, requirements***REMOVED***:
        if self['Metadata-Version'***REMOVED*** == '1.1':
            # we can't have 1.1 metadata *and* Setuptools requires
            for field in ('Obsoletes', 'Requires', 'Provides'***REMOVED***:
                if field in self:
                    del self[field***REMOVED***
        self['Requires-Dist'***REMOVED*** += requirements

    # Mapping API
    # TODO could add iter* variants

    def keys(self***REMOVED***:
        return list(_version2fieldlist(self['Metadata-Version'***REMOVED******REMOVED******REMOVED***

    def __iter__(self***REMOVED***:
        for key in self.keys(***REMOVED***:
            yield key

    def values(self***REMOVED***:
        return [self[key***REMOVED*** for key in self.keys(***REMOVED******REMOVED***

    def items(self***REMOVED***:
        return [(key, self[key***REMOVED******REMOVED*** for key in self.keys(***REMOVED******REMOVED***

    def __repr__(self***REMOVED***:
        return '<%s %s %s>' % (self.__class__.__name__, self.name,
                               self.version***REMOVED***


METADATA_FILENAME = 'pydist.json'
WHEEL_METADATA_FILENAME = 'metadata.json'


class Metadata(object***REMOVED***:
    ***REMOVED***
    The metadata of a release. This implementation uses 2.0 (JSON***REMOVED***
    metadata where possible. If not possible, it wraps a LegacyMetadata
    instance which handles the key-value metadata format.
    ***REMOVED***

    METADATA_VERSION_MATCHER = re.compile('^\d+(\.\d+***REMOVED****$'***REMOVED***

    NAME_MATCHER = re.compile('^[0-9A-Z***REMOVED***([0-9A-Z_.-***REMOVED****[0-9A-Z***REMOVED******REMOVED***?$', re.I***REMOVED***

    VERSION_MATCHER = PEP440_VERSION_RE

    SUMMARY_MATCHER = re.compile('.{1,2047***REMOVED***'***REMOVED***

    METADATA_VERSION = '2.0'

    GENERATOR = 'distlib (%s***REMOVED***' % __version__

    MANDATORY_KEYS = {
        'name': (***REMOVED***,
        'version': (***REMOVED***,
        'summary': ('legacy',***REMOVED***,
***REMOVED***

    INDEX_KEYS = ('name version license summary description author '
                  'author_email keywords platform home_page classifiers '
                  'download_url'***REMOVED***

    DEPENDENCY_KEYS = ('extras run_requires test_requires build_requires '
                       'dev_requires provides meta_requires obsoleted_by '
                       'supports_environments'***REMOVED***

    SYNTAX_VALIDATORS = {
        'metadata_version': (METADATA_VERSION_MATCHER, (***REMOVED******REMOVED***,
        'name': (NAME_MATCHER, ('legacy',***REMOVED******REMOVED***,
        'version': (VERSION_MATCHER, ('legacy',***REMOVED******REMOVED***,
        'summary': (SUMMARY_MATCHER, ('legacy',***REMOVED******REMOVED***,
***REMOVED***

    __slots__ = ('_legacy', '_data', 'scheme'***REMOVED***

    def __init__(self, path=None, fileobj=None, mapping=None,
                 scheme='default'***REMOVED***:
        if [path, fileobj, mapping***REMOVED***.count(None***REMOVED*** < 2:
            raise TypeError('path, fileobj and mapping are exclusive'***REMOVED***
        self._legacy = None
        self._data = None
        self.scheme = scheme
        #import pdb; pdb.set_trace(***REMOVED***
        if mapping is not None:
            ***REMOVED***
                self._validate_mapping(mapping, scheme***REMOVED***
                self._data = mapping
            except MetadataUnrecognizedVersionError:
                self._legacy = LegacyMetadata(mapping=mapping, scheme=scheme***REMOVED***
                self.validate(***REMOVED***
        else:
            data = None
            if path:
                with open(path, 'rb'***REMOVED*** as f:
                    data = f.read(***REMOVED***
            elif fileobj:
                data = fileobj.read(***REMOVED***
            if data is None:
                # Initialised with no args - to be added
                self._data = {
                    'metadata_version': self.METADATA_VERSION,
                    'generator': self.GENERATOR,
            ***REMOVED***
            else:
                if not isinstance(data, text_type***REMOVED***:
                    data = data.decode('utf-8'***REMOVED***
                ***REMOVED***
                    self._data = json.loads(data***REMOVED***
                    self._validate_mapping(self._data, scheme***REMOVED***
                except ValueError:
                    # Note: MetadataUnrecognizedVersionError does not
                    # inherit from ValueError (it's a DistlibException,
                    # which should not inherit from ValueError***REMOVED***.
                    # The ValueError comes from the json.load - if that
                    # succeeds and we get a validation error, we want
                    # that to propagate
                    self._legacy = LegacyMetadata(fileobj=StringIO(data***REMOVED***,
                                                  scheme=scheme***REMOVED***
                    self.validate(***REMOVED***

    common_keys = set(('name', 'version', 'license', 'keywords', 'summary'***REMOVED******REMOVED***

    none_list = (None, list***REMOVED***
    none_dict = (None, dict***REMOVED***

    mapped_keys = {
        'run_requires': ('Requires-Dist', list***REMOVED***,
        'build_requires': ('Setup-Requires-Dist', list***REMOVED***,
        'dev_requires': none_list,
        'test_requires': none_list,
        'meta_requires': none_list,
        'extras': ('Provides-Extra', list***REMOVED***,
        'modules': none_list,
        'namespaces': none_list,
        'exports': none_dict,
        'commands': none_dict,
        'classifiers': ('Classifier', list***REMOVED***,
        'source_url': ('Download-URL', None***REMOVED***,
        'metadata_version': ('Metadata-Version', None***REMOVED***,
***REMOVED***

    del none_list, none_dict

    def __getattribute__(self, key***REMOVED***:
        common = object.__getattribute__(self, 'common_keys'***REMOVED***
        mapped = object.__getattribute__(self, 'mapped_keys'***REMOVED***
        if key in mapped:
            lk, maker = mapped[key***REMOVED***
            if self._legacy:
                if lk is None:
                    result = None if maker is None else maker(***REMOVED***
                else:
                    result = self._legacy.get(lk***REMOVED***
            else:
                value = None if maker is None else maker(***REMOVED***
                if key not in ('commands', 'exports', 'modules', 'namespaces',
                               'classifiers'***REMOVED***:
                    result = self._data.get(key, value***REMOVED***
                else:
                    # special cases for PEP 459
                    sentinel = object(***REMOVED***
                    result = sentinel
                    d = self._data.get('extensions'***REMOVED***
                    if d:
                        if key == 'commands':
                            result = d.get('python.commands', value***REMOVED***
                        elif key == 'classifiers':
                            d = d.get('python.details'***REMOVED***
                            if d:
                                result = d.get(key, value***REMOVED***
                        else:
                            d = d.get('python.exports'***REMOVED***
                            if d:
                                result = d.get(key, value***REMOVED***
                    if result is sentinel:
                        result = value
        elif key not in common:
            result = object.__getattribute__(self, key***REMOVED***
        elif self._legacy:
            result = self._legacy.get(key***REMOVED***
        else:
            result = self._data.get(key***REMOVED***
        return result

    def _validate_value(self, key, value, scheme=None***REMOVED***:
        if key in self.SYNTAX_VALIDATORS:
            pattern, exclusions = self.SYNTAX_VALIDATORS[key***REMOVED***
            if (scheme or self.scheme***REMOVED*** not in exclusions:
                m = pattern.match(value***REMOVED***
                if not m:
                    raise MetadataInvalidError('%r is an invalid value for '
                                               'the %r property' % (value,
                                                                    key***REMOVED******REMOVED***

    def __setattr__(self, key, value***REMOVED***:
        self._validate_value(key, value***REMOVED***
        common = object.__getattribute__(self, 'common_keys'***REMOVED***
        mapped = object.__getattribute__(self, 'mapped_keys'***REMOVED***
        if key in mapped:
            lk, _ = mapped[key***REMOVED***
            if self._legacy:
                if lk is None:
                    raise NotImplementedError
                self._legacy[lk***REMOVED*** = value
            elif key not in ('commands', 'exports', 'modules', 'namespaces',
                             'classifiers'***REMOVED***:
                self._data[key***REMOVED*** = value
            else:
                # special cases for PEP 459
                d = self._data.setdefault('extensions', {***REMOVED******REMOVED***
                if key == 'commands':
                    d['python.commands'***REMOVED*** = value
                elif key == 'classifiers':
                    d = d.setdefault('python.details', {***REMOVED******REMOVED***
                    d[key***REMOVED*** = value
                else:
                    d = d.setdefault('python.exports', {***REMOVED******REMOVED***
                    d[key***REMOVED*** = value
        elif key not in common:
            object.__setattr__(self, key, value***REMOVED***
        else:
            if key == 'keywords':
                if isinstance(value, string_types***REMOVED***:
                    value = value.strip(***REMOVED***
                    if value:
                        value = value.split(***REMOVED***
                    else:
                        value = [***REMOVED***
            if self._legacy:
                self._legacy[key***REMOVED*** = value
            else:
                self._data[key***REMOVED*** = value

    @property
    def name_and_version(self***REMOVED***:
        return _get_name_and_version(self.name, self.version, True***REMOVED***

    @property
    def provides(self***REMOVED***:
        if self._legacy:
            result = self._legacy['Provides-Dist'***REMOVED***
        else:
            result = self._data.setdefault('provides', [***REMOVED******REMOVED***
        s = '%s (%s***REMOVED***' % (self.name, self.version***REMOVED***
        if s not in result:
            result.append(s***REMOVED***
        return result

    @provides.setter
    def provides(self, value***REMOVED***:
        if self._legacy:
            self._legacy['Provides-Dist'***REMOVED*** = value
        else:
            self._data['provides'***REMOVED*** = value

    def get_requirements(self, reqts, extras=None, env=None***REMOVED***:
        ***REMOVED***
        Base method to get dependencies, given a set of extras
        to satisfy and an optional environment context.
        :param reqts: A list of sometimes-wanted dependencies,
                      perhaps dependent on extras and environment.
        :param extras: A list of optional components being requested.
        :param env: An optional environment for marker evaluation.
        ***REMOVED***
        if self._legacy:
            result = reqts
        else:
            result = [***REMOVED***
            extras = get_extras(extras or [***REMOVED***, self.extras***REMOVED***
            for d in reqts:
                if 'extra' not in d and 'environment' not in d:
                    # unconditional
                    include = True
                else:
                    if 'extra' not in d:
                        # Not extra-dependent - only environment-dependent
                        include = True
                    else:
                        include = d.get('extra'***REMOVED*** in extras
                    if include:
                        # Not excluded because of extras, check environment
                        marker = d.get('environment'***REMOVED***
                        if marker:
                            include = interpret(marker, env***REMOVED***
                if include:
                    result.extend(d['requires'***REMOVED******REMOVED***
            for key in ('build', 'dev', 'test'***REMOVED***:
                e = ':%s:' % key
                if e in extras:
                    extras.remove(e***REMOVED***
                    # A recursive call, but it should terminate since 'test'
                    # has been removed from the extras
                    reqts = self._data.get('%s_requires' % key, [***REMOVED******REMOVED***
                    result.extend(self.get_requirements(reqts, extras=extras,
                                                        env=env***REMOVED******REMOVED***
        return result

    @property
    def dictionary(self***REMOVED***:
        if self._legacy:
            return self._from_legacy(***REMOVED***
        return self._data

    @property
    def dependencies(self***REMOVED***:
        if self._legacy:
            raise NotImplementedError
        else:
            return extract_by_key(self._data, self.DEPENDENCY_KEYS***REMOVED***

    @dependencies.setter
    def dependencies(self, value***REMOVED***:
        if self._legacy:
            raise NotImplementedError
        else:
            self._data.update(value***REMOVED***

    def _validate_mapping(self, mapping, scheme***REMOVED***:
        if mapping.get('metadata_version'***REMOVED*** != self.METADATA_VERSION:
            raise MetadataUnrecognizedVersionError(***REMOVED***
        missing = [***REMOVED***
        for key, exclusions in self.MANDATORY_KEYS.items(***REMOVED***:
            if key not in mapping:
                if scheme not in exclusions:
                    missing.append(key***REMOVED***
        if missing:
            msg = 'Missing metadata items: %s' % ', '.join(missing***REMOVED***
            raise MetadataMissingError(msg***REMOVED***
        for k, v in mapping.items(***REMOVED***:
            self._validate_value(k, v, scheme***REMOVED***

    def validate(self***REMOVED***:
        if self._legacy:
            missing, warnings = self._legacy.check(True***REMOVED***
            if missing or warnings:
                logger.warning('Metadata: missing: %s, warnings: %s',
                               missing, warnings***REMOVED***
        else:
            self._validate_mapping(self._data, self.scheme***REMOVED***

    def todict(self***REMOVED***:
        if self._legacy:
            return self._legacy.todict(True***REMOVED***
        else:
            result = extract_by_key(self._data, self.INDEX_KEYS***REMOVED***
            return result

    def _from_legacy(self***REMOVED***:
        assert self._legacy and not self._data
        result = {
            'metadata_version': self.METADATA_VERSION,
            'generator': self.GENERATOR,
    ***REMOVED***
        lmd = self._legacy.todict(True***REMOVED***     # skip missing ones
        for k in ('name', 'version', 'license', 'summary', 'description',
                  'classifier'***REMOVED***:
            if k in lmd:
                if k == 'classifier':
                    nk = 'classifiers'
                else:
                    nk = k
                result[nk***REMOVED*** = lmd[k***REMOVED***
        kw = lmd.get('Keywords', [***REMOVED******REMOVED***
        if kw == [''***REMOVED***:
            kw = [***REMOVED***
        result['keywords'***REMOVED*** = kw
        keys = (('requires_dist', 'run_requires'***REMOVED***,
                ('setup_requires_dist', 'build_requires'***REMOVED******REMOVED***
        for ok, nk in keys:
            if ok in lmd and lmd[ok***REMOVED***:
                result[nk***REMOVED*** = [{'requires': lmd[ok***REMOVED******REMOVED******REMOVED***
        result['provides'***REMOVED*** = self.provides
        author = {***REMOVED***
        maintainer = {***REMOVED***
        return result

    LEGACY_MAPPING = {
        'name': 'Name',
        'version': 'Version',
        'license': 'License',
        'summary': 'Summary',
        'description': 'Description',
        'classifiers': 'Classifier',
***REMOVED***

    def _to_legacy(self***REMOVED***:
        def process_entries(entries***REMOVED***:
            reqts = set(***REMOVED***
            for e in entries:
                extra = e.get('extra'***REMOVED***
                env = e.get('environment'***REMOVED***
                rlist = e['requires'***REMOVED***
                for r in rlist:
                    if not env and not extra:
                        reqts.add(r***REMOVED***
                    else:
                        marker = ''
                        if extra:
                            marker = 'extra == "%s"' % extra
                        if env:
                            if marker:
                                marker = '(%s***REMOVED*** and %s' % (env, marker***REMOVED***
                            else:
                                marker = env
                        reqts.add(';'.join((r, marker***REMOVED******REMOVED******REMOVED***
            return reqts

        assert self._data and not self._legacy
        result = LegacyMetadata(***REMOVED***
        nmd = self._data
        for nk, ok in self.LEGACY_MAPPING.items(***REMOVED***:
            if nk in nmd:
                result[ok***REMOVED*** = nmd[nk***REMOVED***
        r1 = process_entries(self.run_requires + self.meta_requires***REMOVED***
        r2 = process_entries(self.build_requires + self.dev_requires***REMOVED***
        if self.extras:
            result['Provides-Extra'***REMOVED*** = sorted(self.extras***REMOVED***
        result['Requires-Dist'***REMOVED*** = sorted(r1***REMOVED***
        result['Setup-Requires-Dist'***REMOVED*** = sorted(r2***REMOVED***
        # TODO: other fields such as contacts
        return result

    def write(self, path=None, fileobj=None, legacy=False, skip_unknown=True***REMOVED***:
        if [path, fileobj***REMOVED***.count(None***REMOVED*** != 1:
            raise ValueError('Exactly one of path and fileobj is needed'***REMOVED***
        self.validate(***REMOVED***
        if legacy:
            if self._legacy:
                legacy_md = self._legacy
            else:
                legacy_md = self._to_legacy(***REMOVED***
            if path:
                legacy_md.write(path, skip_unknown=skip_unknown***REMOVED***
            else:
                legacy_md.write_file(fileobj, skip_unknown=skip_unknown***REMOVED***
        else:
            if self._legacy:
                d = self._from_legacy(***REMOVED***
            else:
                d = self._data
            if fileobj:
                json.dump(d, fileobj, ensure_ascii=True, indent=2,
                          sort_keys=True***REMOVED***
            else:
                with codecs.open(path, 'w', 'utf-8'***REMOVED*** as f:
                    json.dump(d, f, ensure_ascii=True, indent=2,
                              sort_keys=True***REMOVED***

    def add_requirements(self, requirements***REMOVED***:
        if self._legacy:
            self._legacy.add_requirements(requirements***REMOVED***
        else:
            run_requires = self._data.setdefault('run_requires', [***REMOVED******REMOVED***
            always = None
            for entry in run_requires:
                if 'environment' not in entry and 'extra' not in en***REMOVED***
                    always = entry
                    break
            if always is None:
                always = { 'requires': requirements ***REMOVED***
                run_requires.insert(0, always***REMOVED***
            else:
                rset = set(always['requires'***REMOVED******REMOVED*** | set(requirements***REMOVED***
                always['requires'***REMOVED*** = sorted(rset***REMOVED***

    def __repr__(self***REMOVED***:
        name = self.name or '(no name***REMOVED***'
        version = self.version or 'no version'
        return '<%s %s %s (%s***REMOVED***>' % (self.__class__.__name__,
                                    self.metadata_version, name, version***REMOVED***
