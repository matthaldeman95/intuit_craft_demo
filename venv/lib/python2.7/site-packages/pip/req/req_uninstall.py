from __future__ import absolute_import

import logging
***REMOVED***
import tempfile

from pip.compat import uses_pycache, WINDOWS, cache_from_source
from pip.exceptions import UninstallationError
from pip.utils import rmtree, ask, is_local, renames, normalize_path
from pip.utils.logging import indent_log


logger = logging.getLogger(__name__***REMOVED***


class UninstallPathSet(object***REMOVED***:
    ***REMOVED***A set of file paths to be removed in the uninstallation of a
    requirement.***REMOVED***
    def __init__(self, dist***REMOVED***:
        self.paths = set(***REMOVED***
        self._refuse = set(***REMOVED***
        self.pth = {***REMOVED***
        self.dist = dist
        self.save_dir = None
        self._moved_paths = [***REMOVED***

    def _permitted(self, path***REMOVED***:
        ***REMOVED***
        Return True if the given path is one we are permitted to
        remove/modify, False otherwise.

        ***REMOVED***
        return is_local(path***REMOVED***

    def add(self, path***REMOVED***:
        head, tail = os.path.split(path***REMOVED***

        # we normalize the head to resolve parent directory symlinks, but not
        # the tail, since we only want to uninstall symlinks, not their targets
        path = os.path.join(normalize_path(head***REMOVED***, os.path.normcase(tail***REMOVED******REMOVED***

        if not os.path.exists(path***REMOVED***:
            return
        if self._permitted(path***REMOVED***:
            self.paths.add(path***REMOVED***
        else:
            self._refuse.add(path***REMOVED***

        # __pycache__ files can show up after 'installed-files.txt' is created,
        # due to imports
        if os.path.splitext(path***REMOVED***[1***REMOVED*** == '.py' and uses_pycache:
            self.add(cache_from_source(path***REMOVED******REMOVED***

    def add_pth(self, pth_file, entry***REMOVED***:
        pth_file = normalize_path(pth_file***REMOVED***
        if self._permitted(pth_file***REMOVED***:
            if pth_file not in self.pth:
                self.pth[pth_file***REMOVED*** = UninstallPthEntries(pth_file***REMOVED***
            self.pth[pth_file***REMOVED***.add(entry***REMOVED***
        else:
            self._refuse.add(pth_file***REMOVED***

    def compact(self, paths***REMOVED***:
        ***REMOVED***Compact a path set to contain the minimal number of paths
        necessary to contain all paths in the set. If /a/path/ and
        /a/path/to/a/file.txt are both in the set, leave only the
        shorter path.***REMOVED***
        short_paths = set(***REMOVED***
        for path in sorted(paths, key=len***REMOVED***:
            if not any([
                    (path.startswith(shortpath***REMOVED*** and
                     path[len(shortpath.rstrip(os.path.sep***REMOVED******REMOVED******REMOVED*** == os.path.sep***REMOVED***
                    for shortpath in short_paths***REMOVED******REMOVED***:
                short_paths.add(path***REMOVED***
        return short_paths

    def _stash(self, path***REMOVED***:
        return os.path.join(
            self.save_dir, os.path.splitdrive(path***REMOVED***[1***REMOVED***.lstrip(os.path.sep***REMOVED******REMOVED***

    def remove(self, auto_confirm=False***REMOVED***:
        ***REMOVED***Remove paths in ``self.paths`` with confirmation (unless
        ``auto_confirm`` is True***REMOVED***.***REMOVED***
        if not self.paths:
            logger.info(
                "Can't uninstall '%s'. No files were found to uninstall.",
                self.dist.project_name,
            ***REMOVED***
            return
        logger.info(
            'Uninstalling %s-%s:',
            self.dist.project_name, self.dist.version
        ***REMOVED***

        with indent_log(***REMOVED***:
            paths = sorted(self.compact(self.paths***REMOVED******REMOVED***

            if auto_confirm:
                response = 'y'
            else:
                for path in paths:
                    logger.info(path***REMOVED***
                response = ask('Proceed (y/n***REMOVED***? ', ('y', 'n'***REMOVED******REMOVED***
            if self._refuse:
                logger.info('Not removing or modifying (outside of prefix***REMOVED***:'***REMOVED***
                for path in self.compact(self._refuse***REMOVED***:
                    logger.info(path***REMOVED***
            if response == 'y':
                self.save_dir = tempfile.mkdtemp(suffix='-uninstall',
                                                 prefix='pip-'***REMOVED***
                for path in paths:
                    new_path = self._stash(path***REMOVED***
                    logger.debug('Removing file or directory %s', path***REMOVED***
                    self._moved_paths.append(path***REMOVED***
                    renames(path, new_path***REMOVED***
                for pth in self.pth.values(***REMOVED***:
                    pth.remove(***REMOVED***
                logger.info(
                    'Successfully uninstalled %s-%s',
                    self.dist.project_name, self.dist.version
                ***REMOVED***

    def rollback(self***REMOVED***:
        ***REMOVED***Rollback the changes previously made by remove(***REMOVED***.***REMOVED***
        if self.save_dir is None:
            logger.error(
                "Can't roll back %s; was not uninstalled",
                self.dist.project_name,
            ***REMOVED***
            return False
        logger.info('Rolling back uninstall of %s', self.dist.project_name***REMOVED***
        for path in self._moved_paths:
            tmp_path = self._stash(path***REMOVED***
            logger.debug('Replacing %s', path***REMOVED***
            renames(tmp_path, path***REMOVED***
        for pth in self.pth.values(***REMOVED***:
            pth.rollback(***REMOVED***

    def commit(self***REMOVED***:
        ***REMOVED***Remove temporary save dir: rollback will no longer be possible.***REMOVED***
        if self.save_dir is not None:
            rmtree(self.save_dir***REMOVED***
            self.save_dir = None
            self._moved_paths = [***REMOVED***


class UninstallPthEntries(object***REMOVED***:
    def __init__(self, pth_file***REMOVED***:
        if not os.path.isfile(pth_file***REMOVED***:
            raise UninstallationError(
                "Cannot remove entries from nonexistent file %s" % pth_file
            ***REMOVED***
        self.file = pth_file
        self.entries = set(***REMOVED***
        self._saved_lines = None

    def add(self, entry***REMOVED***:
        entry = os.path.normcase(entry***REMOVED***
        # On Windows, os.path.normcase converts the entry to use
        # backslashes.  This is correct for entries that describe absolute
        # paths outside of site-packages, but all the others use forward
        # slashes.
        if WINDOWS and not os.path.splitdrive(entry***REMOVED***[0***REMOVED***:
            entry = entry.replace('\\', '/'***REMOVED***
        self.entries.add(entry***REMOVED***

    def remove(self***REMOVED***:
        logger.debug('Removing pth entries from %s:', self.file***REMOVED***
        with open(self.file, 'rb'***REMOVED*** as fh:
            # windows uses '\r\n' with py3k, but uses '\n' with py2.x
            lines = fh.readlines(***REMOVED***
            self._saved_lines = lines
        if any(b'\r\n' in line for line in lines***REMOVED***:
            endline = '\r\n'
        else:
            endline = '\n'
        for entry in self.entries:
            ***REMOVED***
                logger.debug('Removing en***REMOVED*** %s', entry***REMOVED***
                lines.remove((entry + endline***REMOVED***.encode("utf-8"***REMOVED******REMOVED***
            except ValueError:
                pass
        with open(self.file, 'wb'***REMOVED*** as fh:
            fh.writelines(lines***REMOVED***

    def rollback(self***REMOVED***:
        if self._saved_lines is None:
            logger.error(
                'Cannot roll back changes to %s, none were made', self.file
            ***REMOVED***
            return False
        logger.debug('Rolling %s back to previous state', self.file***REMOVED***
        with open(self.file, 'wb'***REMOVED*** as fh:
            fh.writelines(self._saved_lines***REMOVED***
        return True
