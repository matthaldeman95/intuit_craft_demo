from __future__ import absolute_import

import logging
import tempfile
***REMOVED***.path

from pip.compat import samefile
from pip.exceptions import BadCommand
from pip._vendor.six.moves.urllib import parse as urllib_parse
from pip._vendor.six.moves.urllib import request as urllib_request

from pip.utils import display_path, rmtree
from pip.vcs import vcs, VersionControl


urlsplit = urllib_parse.urlsplit
urlunsplit = urllib_parse.urlunsplit


logger = logging.getLogger(__name__***REMOVED***


class Git(VersionControl***REMOVED***:
    name = 'git'
    dirname = '.git'
    repo_name = 'clone'
    schemes = (
        'git', 'git+http', 'git+https', 'git+ssh', 'git+git', 'git+file',
    ***REMOVED***

    def __init__(self, url=None, *args, **kwargs***REMOVED***:

        # Works around an apparent Git bug
        # (see http://article.gmane.org/gmane.comp.version-control.git/146500***REMOVED***
        if url:
            scheme, netloc, path, query, fragment = urlsplit(url***REMOVED***
            if scheme.endswith('file'***REMOVED***:
                initial_slashes = path[:-len(path.lstrip('/'***REMOVED******REMOVED******REMOVED***
                newpath = (
                    initial_slashes +
                    urllib_request.url2pathname(path***REMOVED***
                    .replace('\\', '/'***REMOVED***.lstrip('/'***REMOVED***
                ***REMOVED***
                url = urlunsplit((scheme, netloc, newpath, query, fragment***REMOVED******REMOVED***
                after_plus = scheme.find('+'***REMOVED*** + 1
                url = scheme[:after_plus***REMOVED*** + urlunsplit(
                    (scheme[after_plus:***REMOVED***, netloc, newpath, query, fragment***REMOVED***,
                ***REMOVED***

        super(Git, self***REMOVED***.__init__(url, *args, **kwargs***REMOVED***

    def export(self, location***REMOVED***:
        ***REMOVED***Export the Git repository at the url to the destination location***REMOVED***
        temp_dir = tempfile.mkdtemp('-export', 'pip-'***REMOVED***
        self.unpack(temp_dir***REMOVED***
        ***REMOVED***
            if not location.endswith('/'***REMOVED***:
                location = location + '/'
            self.run_command(
                ['checkout-index', '-a', '-f', '--prefix', location***REMOVED***,
                show_stdout=False, cwd=temp_dir***REMOVED***
        finally:
            rmtree(temp_dir***REMOVED***

    def check_rev_options(self, rev, dest, rev_options***REMOVED***:
        ***REMOVED***Check the revision options before checkout to compensate that tags
        and branches may need origin/ as a prefix.
        Returns the SHA1 of the branch or tag if found.
        ***REMOVED***
        revisions = self.get_short_refs(dest***REMOVED***

        origin_rev = 'origin/%s' % rev
        if origin_rev in revisions:
            # remote branch
            return [revisions[origin_rev***REMOVED******REMOVED***
        elif rev in revisions:
            # a local tag or branch name
            return [revisions[rev***REMOVED******REMOVED***
        else:
            logger.warning(
                "Could not find a tag or branch '%s', assuming commit.", rev,
            ***REMOVED***
            return rev_options

    def check_version(self, dest, rev_options***REMOVED***:
        ***REMOVED***
        Compare the current sha to the ref. ref may be a branch or tag name,
        but current rev will always point to a sha. This means that a branch
        or tag will never compare as True. So this ultimately only matches
        against exact shas.
        ***REMOVED***
        return self.get_revision(dest***REMOVED***.startswith(rev_options[0***REMOVED******REMOVED***

    def switch(self, dest, url, rev_options***REMOVED***:
        self.run_command(['config', 'remote.origin.url', url***REMOVED***, cwd=dest***REMOVED***
        self.run_command(['checkout', '-q'***REMOVED*** + rev_options, cwd=dest***REMOVED***

        self.update_submodules(dest***REMOVED***

    def update(self, dest, rev_options***REMOVED***:
        # First fetch changes from the default remote
        self.run_command(['fetch', '-q'***REMOVED***, cwd=dest***REMOVED***
        # Then reset to wanted revision (maybe even origin/master***REMOVED***
        if rev_options:
            rev_options = self.check_rev_options(
                rev_options[0***REMOVED***, dest, rev_options,
            ***REMOVED***
        self.run_command(['reset', '--hard', '-q'***REMOVED*** + rev_options, cwd=dest***REMOVED***
        #: update submodules
        self.update_submodules(dest***REMOVED***

    def obtain(self, dest***REMOVED***:
        url, rev = self.get_url_rev(***REMOVED***
        if rev:
            rev_options = [rev***REMOVED***
            rev_display = ' (to %s***REMOVED***' % rev
        else:
            rev_options = ['origin/master'***REMOVED***
            rev_display = ''
        if self.check_destination(dest, url, rev_options, rev_display***REMOVED***:
            logger.info(
                'Cloning %s%s to %s', url, rev_display, display_path(dest***REMOVED***,
            ***REMOVED***
            self.run_command(['clone', '-q', url, dest***REMOVED******REMOVED***

            if rev:
                rev_options = self.check_rev_options(rev, dest, rev_options***REMOVED***
                # Only do a checkout if rev_options differs from HEAD
                if not self.check_version(dest, rev_options***REMOVED***:
                    self.run_command(
                        ['checkout', '-q'***REMOVED*** + rev_options,
                        cwd=dest,
                    ***REMOVED***
            #: repo may contain submodules
            self.update_submodules(dest***REMOVED***

    def get_url(self, location***REMOVED***:
        ***REMOVED***Return URL of the first remote encountered.***REMOVED***
        remotes = self.run_command(
            ['config', '--get-regexp', 'remote\..*\.url'***REMOVED***,
            show_stdout=False, cwd=location***REMOVED***
        first_remote = remotes.splitlines(***REMOVED***[0***REMOVED***
        url = first_remote.split(' '***REMOVED***[1***REMOVED***
        return url.strip(***REMOVED***

    def get_revision(self, location***REMOVED***:
        current_rev = self.run_command(
            ['rev-parse', 'HEAD'***REMOVED***, show_stdout=False, cwd=location***REMOVED***
        return current_rev.strip(***REMOVED***

    def get_full_refs(self, location***REMOVED***:
        ***REMOVED***Yields tuples of (commit, ref***REMOVED*** for branches and tags***REMOVED***
        output = self.run_command(['show-ref'***REMOVED***,
                                  show_stdout=False, cwd=location***REMOVED***
        for line in output.strip(***REMOVED***.splitlines(***REMOVED***:
            commit, ref = line.split(' ', 1***REMOVED***
            yield commit.strip(***REMOVED***, ref.strip(***REMOVED***

    def is_ref_remote(self, ref***REMOVED***:
        return ref.startswith('refs/remotes/'***REMOVED***

    def is_ref_branch(self, ref***REMOVED***:
        return ref.startswith('refs/heads/'***REMOVED***

    def is_ref_tag(self, ref***REMOVED***:
        return ref.startswith('refs/tags/'***REMOVED***

    def is_ref_commit(self, ref***REMOVED***:
        ***REMOVED***A ref is a commit sha if it is not anything else***REMOVED***
        return not any((
            self.is_ref_remote(ref***REMOVED***,
            self.is_ref_branch(ref***REMOVED***,
            self.is_ref_tag(ref***REMOVED***,
        ***REMOVED******REMOVED***

    # Should deprecate `get_refs` since it's ambiguous
    def get_refs(self, location***REMOVED***:
        return self.get_short_refs(location***REMOVED***

    def get_short_refs(self, location***REMOVED***:
        ***REMOVED***Return map of named refs (branches or tags***REMOVED*** to commit hashes.***REMOVED***
        rv = {***REMOVED***
        for commit, ref in self.get_full_refs(location***REMOVED***:
            ref_name = None
            if self.is_ref_remote(ref***REMOVED***:
                ref_name = ref[len('refs/remotes/'***REMOVED***:***REMOVED***
            elif self.is_ref_branch(ref***REMOVED***:
                ref_name = ref[len('refs/heads/'***REMOVED***:***REMOVED***
            elif self.is_ref_tag(ref***REMOVED***:
                ref_name = ref[len('refs/tags/'***REMOVED***:***REMOVED***
            if ref_name is not None:
                rv[ref_name***REMOVED*** = commit
        return rv

    def _get_subdirectory(self, location***REMOVED***:
        ***REMOVED***Return the relative path of setup.py to the git repo root.***REMOVED***
        # find the repo root
        git_dir = self.run_command(['rev-parse', '--git-dir'***REMOVED***,
                                   show_stdout=False, cwd=location***REMOVED***.strip(***REMOVED***
        if not os.path.isabs(git_dir***REMOVED***:
            git_dir = os.path.join(location, git_dir***REMOVED***
        root_dir = os.path.join(git_dir, '..'***REMOVED***
        # find setup.py
        orig_location = location
        while not os.path.exists(os.path.join(location, 'setup.py'***REMOVED******REMOVED***:
            last_location = location
            location = os.path.dirname(location***REMOVED***
            if location == last_location:
                # We've traversed up to the root of the filesystem without
                # finding setup.py
                logger.warning(
                    "Could not find setup.py for directory %s (tried all "
                    "parent directories***REMOVED***",
                    orig_location,
                ***REMOVED***
                return None
        # relative path of setup.py to repo root
        if samefile(root_dir, location***REMOVED***:
            return None
        return os.path.relpath(location, root_dir***REMOVED***

    def get_src_requirement(self, dist, location***REMOVED***:
        repo = self.get_url(location***REMOVED***
        if not repo.lower(***REMOVED***.startswith('git:'***REMOVED***:
            repo = 'git+' + repo
        egg_project_name = dist.egg_name(***REMOVED***.split('-', 1***REMOVED***[0***REMOVED***
        if not repo:
            return None
        current_rev = self.get_revision(location***REMOVED***
        req = '%s@%s#egg=%s' % (repo, current_rev, egg_project_name***REMOVED***
        subdirectory = self._get_subdirectory(location***REMOVED***
        if subdirectory:
            req += '&subdirectory=' + subdirectory
        return req

    def get_url_rev(self***REMOVED***:
        ***REMOVED***
        Prefixes stub URLs like 'user@hostname:user/repo.git' with 'ssh://'.
        That's required because although they use SSH they sometimes doesn't
        work with a ssh:// scheme (e.g. Github***REMOVED***. But we need a scheme for
        parsing. Hence we remove it again afterwards and return it as a stub.
        ***REMOVED***
        if '://' not in self.url:
            assert 'file:' not in self.url
            self.url = self.url.replace('git+', 'git+ssh://'***REMOVED***
            url, rev = super(Git, self***REMOVED***.get_url_rev(***REMOVED***
            url = url.replace('ssh://', ''***REMOVED***
        else:
            url, rev = super(Git, self***REMOVED***.get_url_rev(***REMOVED***

        return url, rev

    def update_submodules(self, location***REMOVED***:
        if not os.path.exists(os.path.join(location, '.gitmodules'***REMOVED******REMOVED***:
            return
        self.run_command(
            ['submodule', 'update', '--init', '--recursive', '-q'***REMOVED***,
            cwd=location,
        ***REMOVED***

    @classmethod
    def controls_location(cls, location***REMOVED***:
        if super(Git, cls***REMOVED***.controls_location(location***REMOVED***:
            return True
        ***REMOVED***
            r = cls(***REMOVED***.run_command(['rev-parse'***REMOVED***,
                                  cwd=location,
                                  show_stdout=False,
                                  on_returncode='ignore'***REMOVED***
            return not r
        except BadCommand:
            logger.debug("could not determine if %s is under git control "
                         "because git is not available", location***REMOVED***
            return False


vcs.register(Git***REMOVED***
