***REMOVED***Handles all VCS (version control***REMOVED*** support***REMOVED***
from __future__ import absolute_import

import errno
import logging
***REMOVED***
import shutil

from pip._vendor.six.moves.urllib import parse as urllib_parse

from pip.exceptions import BadCommand
from pip.utils import (display_path, backup_dir, call_subprocess,
                       rmtree, ask_path_exists***REMOVED***


__all__ = ['vcs', 'get_src_requirement'***REMOVED***


logger = logging.getLogger(__name__***REMOVED***


class VcsSupport(object***REMOVED***:
    _registry = {***REMOVED***
    schemes = ['ssh', 'git', 'hg', 'bzr', 'sftp', 'svn'***REMOVED***

    def __init__(self***REMOVED***:
        # Register more schemes with urlparse for various version control
        # systems
        urllib_parse.uses_netloc.extend(self.schemes***REMOVED***
        # Python >= 2.7.4, 3.3 doesn't have uses_fragment
        if getattr(urllib_parse, 'uses_fragment', None***REMOVED***:
            urllib_parse.uses_fragment.extend(self.schemes***REMOVED***
        super(VcsSupport, self***REMOVED***.__init__(***REMOVED***

    def __iter__(self***REMOVED***:
        return self._registry.__iter__(***REMOVED***

    @property
    def backends(self***REMOVED***:
        return list(self._registry.values(***REMOVED******REMOVED***

    @property
    def dirnames(self***REMOVED***:
        return [backend.dirname for backend in self.backends***REMOVED***

    @property
    def all_schemes(self***REMOVED***:
        schemes = [***REMOVED***
        for backend in self.backends:
            schemes.extend(backend.schemes***REMOVED***
        return schemes

    def register(self, cls***REMOVED***:
        if not hasattr(cls, 'name'***REMOVED***:
            logger.warning('Cannot register VCS %s', cls.__name__***REMOVED***
            return
        if cls.name not in self._regis***REMOVED***
            self._registry[cls.name***REMOVED*** = cls
            logger.debug('Registered VCS backend: %s', cls.name***REMOVED***

    def unregister(self, cls=None, name=None***REMOVED***:
        if name in self._regis***REMOVED***
            del self._registry[name***REMOVED***
        elif cls in self._registry.values(***REMOVED***:
            del self._registry[cls.name***REMOVED***
        else:
            logger.warning('Cannot unregister because no class or name given'***REMOVED***

    def get_backend_name(self, location***REMOVED***:
        ***REMOVED***
        Return the name of the version control backend if found at given
        location, e.g. vcs.get_backend_name('/path/to/vcs/checkout'***REMOVED***
        ***REMOVED***
        for vc_type in self._registry.values(***REMOVED***:
            if vc_type.controls_location(location***REMOVED***:
                logger.debug('Determine that %s uses VCS: %s',
                             location, vc_type.name***REMOVED***
                return vc_type.name
        return None

    def get_backend(self, name***REMOVED***:
        name = name.lower(***REMOVED***
        if name in self._regis***REMOVED***
            return self._registry[name***REMOVED***

    def get_backend_from_location(self, location***REMOVED***:
        vc_type = self.get_backend_name(location***REMOVED***
        if vc_type:
            return self.get_backend(vc_type***REMOVED***
        return None


vcs = VcsSupport(***REMOVED***


class VersionControl(object***REMOVED***:
    name = ''
    dirname = ''
    # List of supported schemes for this Version Control
    schemes = (***REMOVED***

    def __init__(self, url=None, *args, **kwargs***REMOVED***:
        self.url = url
        super(VersionControl, self***REMOVED***.__init__(*args, **kwargs***REMOVED***

    def _is_local_repository(self, repo***REMOVED***:
        ***REMOVED***
           posix absolute paths start with os.path.sep,
           win32 ones ones start with drive (like c:\\folder***REMOVED***
        ***REMOVED***
        drive, tail = os.path.splitdrive(repo***REMOVED***
        return repo.startswith(os.path.sep***REMOVED*** or drive

    # See issue #1083 for why this method was introduced:
    # https://github.com/pypa/pip/issues/1083
    def translate_egg_surname(self, surname***REMOVED***:
        # For example, Django has branches of the form "stable/1.7.x".
        return surname.replace('/', '_'***REMOVED***

    def export(self, location***REMOVED***:
        ***REMOVED***
        Export the repository at the url to the destination location
        i.e. only download the files, without vcs informations
        ***REMOVED***
        raise NotImplementedError

    def get_url_rev(self***REMOVED***:
        ***REMOVED***
        Returns the correct repository URL and revision by parsing the given
        repository URL
        ***REMOVED***
        error_message = (
            "Sorry, '%s' is a malformed VCS url. "
            "The format is <vcs>+<protocol>://<url>, "
            "e.g. svn+http://myrepo/svn/MyApp#egg=MyApp"
        ***REMOVED***
        assert '+' in self.url, error_message % self.url
        url = self.url.split('+', 1***REMOVED***[1***REMOVED***
        scheme, netloc, path, query, frag = urllib_parse.urlsplit(url***REMOVED***
        rev = None
        if '@' in path:
            path, rev = path.rsplit('@', 1***REMOVED***
        url = urllib_parse.urlunsplit((scheme, netloc, path, query, ''***REMOVED******REMOVED***
        return url, rev

    def get_info(self, location***REMOVED***:
        ***REMOVED***
        Returns (url, revision***REMOVED***, where both are strings
        ***REMOVED***
        assert not location.rstrip('/'***REMOVED***.endswith(self.dirname***REMOVED***, \
            'Bad directory: %s' % location
        return self.get_url(location***REMOVED***, self.get_revision(location***REMOVED***

    def normalize_url(self, url***REMOVED***:
        ***REMOVED***
        Normalize a URL for comparison by unquoting it and removing any
        trailing slash.
        ***REMOVED***
        return urllib_parse.unquote(url***REMOVED***.rstrip('/'***REMOVED***

    def compare_urls(self, url1, url2***REMOVED***:
        ***REMOVED***
        Compare two repo URLs for identity, ignoring incidental differences.
        ***REMOVED***
        return (self.normalize_url(url1***REMOVED*** == self.normalize_url(url2***REMOVED******REMOVED***

    def obtain(self, dest***REMOVED***:
        ***REMOVED***
        Called when installing or updating an editable package, takes the
        source path of the checkout.
        ***REMOVED***
        raise NotImplementedError

    def switch(self, dest, url, rev_options***REMOVED***:
        ***REMOVED***
        Switch the repo at ``dest`` to point to ``URL``.
        ***REMOVED***
        raise NotImplementedError

    def update(self, dest, rev_options***REMOVED***:
        ***REMOVED***
        Update an already-existing repo to the given ``rev_options``.
        ***REMOVED***
        raise NotImplementedError

    def check_version(self, dest, rev_options***REMOVED***:
        ***REMOVED***
        Return True if the version is identical to what exists and
        doesn't need to be updated.
        ***REMOVED***
        raise NotImplementedError

    def check_destination(self, dest, url, rev_options, rev_display***REMOVED***:
        ***REMOVED***
        Prepare a location to receive a checkout/clone.

        Return True if the location is ready for (and requires***REMOVED*** a
        checkout/clone, False otherwise.
        ***REMOVED***
        checkout = True
        prompt = False
        if os.path.exists(dest***REMOVED***:
            checkout = False
            if os.path.exists(os.path.join(dest, self.dirname***REMOVED******REMOVED***:
                existing_url = self.get_url(dest***REMOVED***
                if self.compare_urls(existing_url, url***REMOVED***:
                    logger.debug(
                        '%s in %s exists, and has correct URL (%s***REMOVED***',
                        self.repo_name.title(***REMOVED***,
                        display_path(dest***REMOVED***,
                        url,
                    ***REMOVED***
                    if not self.check_version(dest, rev_options***REMOVED***:
                        logger.info(
                            'Updating %s %s%s',
                            display_path(dest***REMOVED***,
                            self.repo_name,
                            rev_display,
                        ***REMOVED***
                        self.update(dest, rev_options***REMOVED***
                    else:
                        logger.info(
                            'Skipping because already up-to-date.'***REMOVED***
                else:
                    logger.warning(
                        '%s %s in %s exists with URL %s',
                        self.name,
                        self.repo_name,
                        display_path(dest***REMOVED***,
                        existing_url,
                    ***REMOVED***
                    prompt = ('(s***REMOVED***witch, (i***REMOVED***gnore, (w***REMOVED***ipe, (b***REMOVED***ackup ',
                              ('s', 'i', 'w', 'b'***REMOVED******REMOVED***
            else:
                logger.warning(
                    'Directory %s already exists, and is not a %s %s.',
                    dest,
                    self.name,
                    self.repo_name,
                ***REMOVED***
                prompt = ('(i***REMOVED***gnore, (w***REMOVED***ipe, (b***REMOVED***ackup ', ('i', 'w', 'b'***REMOVED******REMOVED***
        if prompt:
            logger.warning(
                'The plan is to install the %s repository %s',
                self.name,
                url,
            ***REMOVED***
            response = ask_path_exists('What to do?  %s' % prompt[0***REMOVED***,
                                       prompt[1***REMOVED******REMOVED***

            if response == 's':
                logger.info(
                    'Switching %s %s to %s%s',
                    self.repo_name,
                    display_path(dest***REMOVED***,
                    url,
                    rev_display,
                ***REMOVED***
                self.switch(dest, url, rev_options***REMOVED***
            elif response == 'i':
                # do nothing
                pass
            elif response == 'w':
                logger.warning('Deleting %s', display_path(dest***REMOVED******REMOVED***
                rmtree(dest***REMOVED***
                checkout = True
            elif response == 'b':
                dest_dir = backup_dir(dest***REMOVED***
                logger.warning(
                    'Backing up %s to %s', display_path(dest***REMOVED***, dest_dir,
                ***REMOVED***
                shutil.move(dest, dest_dir***REMOVED***
                checkout = True
        return checkout

    def unpack(self, location***REMOVED***:
        ***REMOVED***
        Clean up current location and download the url repository
        (and vcs infos***REMOVED*** into location
        ***REMOVED***
        if os.path.exists(location***REMOVED***:
            rmtree(location***REMOVED***
        self.obtain(location***REMOVED***

    def get_src_requirement(self, dist, location***REMOVED***:
        ***REMOVED***
        Return a string representing the requirement needed to
        redownload the files currently present in location, something
        like:
      ***REMOVED***repository_url***REMOVED***@{revision***REMOVED***#egg={project_name***REMOVED***-{version_identifier***REMOVED***
        ***REMOVED***
        raise NotImplementedError

    def get_url(self, location***REMOVED***:
        ***REMOVED***
        Return the url used at location
        Used in get_info or check_destination
        ***REMOVED***
        raise NotImplementedError

    def get_revision(self, location***REMOVED***:
        ***REMOVED***
        Return the current revision of the files at location
        Used in get_info
        ***REMOVED***
        raise NotImplementedError

    def run_command(self, cmd, show_stdout=True, cwd=None,
                    on_returncode='raise',
                    command_level=logging.DEBUG, command_desc=None,
                    extra_environ=None, spinner=None***REMOVED***:
        ***REMOVED***
        Run a VCS subcommand
        This is simply a wrapper around call_subprocess that adds the VCS
        command name, and checks that the VCS is available
        ***REMOVED***
        cmd = [self.name***REMOVED*** + cmd
        ***REMOVED***
            return call_subprocess(cmd, show_stdout, cwd,
                                   on_returncode, command_level,
                                   command_desc, extra_environ,
                                   spinner***REMOVED***
        except OSError as e:
            # errno.ENOENT = no such file or directory
            # In other words, the VCS executable isn't available
            if e.errno == errno.ENOENT:
                raise BadCommand('Cannot find command %r' % self.name***REMOVED***
            else:
                raise  # re-raise exception if a different error occurred

    @classmethod
    def controls_location(cls, location***REMOVED***:
        ***REMOVED***
        Check if a location is controlled by the vcs.
        It is meant to be overridden to implement smarter detection
        mechanisms for specific vcs.
        ***REMOVED***
        logger.debug('Checking in %s for %s (%s***REMOVED***...',
                     location, cls.dirname, cls.name***REMOVED***
        path = os.path.join(location, cls.dirname***REMOVED***
        return os.path.exists(path***REMOVED***


def get_src_requirement(dist, location***REMOVED***:
    version_control = vcs.get_backend_from_location(location***REMOVED***
    if version_control:
        ***REMOVED***
            return version_control(***REMOVED***.get_src_requirement(dist,
                                                         location***REMOVED***
        except BadCommand:
            logger.warning(
                'cannot determine version of editable source in %s '
                '(%s command not found in path***REMOVED***',
                location,
                version_control.name,
            ***REMOVED***
            return dist.as_requirement(***REMOVED***
    logger.warning(
        'cannot determine version of editable source in %s (is not SVN '
        'checkout, Git clone, Mercurial clone or Bazaar branch***REMOVED***',
        location,
    ***REMOVED***
    return dist.as_requirement(***REMOVED***
