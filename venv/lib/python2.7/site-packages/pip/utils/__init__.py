from __future__ import absolute_import

from collections import deque
import contextlib
import errno
import io
import locale
# we have a submodule named 'logging' which would shadow this if we used the
# regular name:
import logging as std_logging
import re
***REMOVED***
import posixpath
import shutil
import stat
import subprocess
import sys
import tarfile
import zipfile

from pip.exceptions import InstallationError
from pip.compat import console_to_str, expanduser, stdlib_pkgs
from pip.locations import (
    site_packages, user_site, running_under_virtualenv, virtualenv_no_global,
    write_delete_marker_file,
***REMOVED***
from pip._vendor import pkg_resources
from pip._vendor.six.moves import input
from pip._vendor.six import PY2
from pip._vendor.retrying import retry

if PY2:
    from io import BytesIO as StringIO
else:
    from io import StringIO

__all__ = ['rmtree', 'display_path', 'backup_dir',
           'ask', 'splitext',
           'format_size', 'is_installable_dir',
           'is_svn_page', 'file_contents',
           'split_leading_dir', 'has_leading_dir',
           'normalize_path',
           'renames', 'get_terminal_size', 'get_prog',
           'unzip_file', 'untar_file', 'unpack_file', 'call_subprocess',
           'captured_stdout', 'remove_tracebacks', 'ensure_dir',
           'ARCHIVE_EXTENSIONS', 'SUPPORTED_EXTENSIONS',
           'get_installed_version'***REMOVED***


logger = std_logging.getLogger(__name__***REMOVED***

BZ2_EXTENSIONS = ('.tar.bz2', '.tbz'***REMOVED***
XZ_EXTENSIONS = ('.tar.xz', '.txz', '.tlz', '.tar.lz', '.tar.lzma'***REMOVED***
ZIP_EXTENSIONS = ('.zip', '.whl'***REMOVED***
TAR_EXTENSIONS = ('.tar.gz', '.tgz', '.tar'***REMOVED***
ARCHIVE_EXTENSIONS = (
    ZIP_EXTENSIONS + BZ2_EXTENSIONS + TAR_EXTENSIONS + XZ_EXTENSIONS***REMOVED***
SUPPORTED_EXTENSIONS = ZIP_EXTENSIONS + TAR_EXTENSIONS
***REMOVED***
    import bz2  # noqa
    SUPPORTED_EXTENSIONS += BZ2_EXTENSIONS
except ImportError:
    logger.debug('bz2 module is not available'***REMOVED***

***REMOVED***
    # Only for Python 3.3+
    import lzma  # noqa
    SUPPORTED_EXTENSIONS += XZ_EXTENSIONS
except ImportError:
    logger.debug('lzma module is not available'***REMOVED***


def import_or_raise(pkg_or_module_string, ExceptionType, *args, **kwargs***REMOVED***:
    ***REMOVED***
        return __import__(pkg_or_module_string***REMOVED***
    except ImportError:
        raise ExceptionType(*args, **kwargs***REMOVED***


def ensure_dir(path***REMOVED***:
    ***REMOVED***os.path.makedirs without EEXIST.***REMOVED***
    ***REMOVED***
        os.makedirs(path***REMOVED***
    except OSError as e:
        if e.errno != errno.EEXIST:
            raise


def get_prog(***REMOVED***:
    ***REMOVED***
        if os.path.basename(sys.argv[0***REMOVED******REMOVED*** in ('__main__.py', '-c'***REMOVED***:
            return "%s -m pip" % sys.executable
    except (AttributeError, TypeError, IndexError***REMOVED***:
        pass
    return 'pip'


# Retry every half second for up to 3 seconds
@retry(stop_max_delay=3000, wait_fixed=500***REMOVED***
def rmtree(dir, ignore_errors=False***REMOVED***:
    shutil.rmtree(dir, ignore_errors=ignore_errors,
                  onerror=rmtree_errorhandler***REMOVED***


def rmtree_errorhandler(func, path, exc_info***REMOVED***:
    ***REMOVED***On Windows, the files in .svn are read-only, so when rmtree(***REMOVED*** tries to
    remove them, an exception is thrown.  We catch that here, remove the
    read-only attribute, and hopefully continue without problems.***REMOVED***
    # if file type currently read only
    if os.stat(path***REMOVED***.st_mode & stat.S_IREAD:
        # convert to read/write
        os.chmod(path, stat.S_IWRITE***REMOVED***
        # use the original function to repeat the operation
        func(path***REMOVED***
        return
    else:
        raise


def display_path(path***REMOVED***:
    ***REMOVED***Gives the display value for a given path, making it relative to cwd
    if possible.***REMOVED***
    path = os.path.normcase(os.path.abspath(path***REMOVED******REMOVED***
    if sys.version_info[0***REMOVED*** == 2:
        path = path.decode(sys.getfilesystemencoding(***REMOVED***, 'replace'***REMOVED***
        path = path.encode(sys.getdefaultencoding(***REMOVED***, 'replace'***REMOVED***
    if path.startswith(os.getcwd(***REMOVED*** + os.path.sep***REMOVED***:
        path = '.' + path[len(os.getcwd(***REMOVED******REMOVED***:***REMOVED***
    return path


def backup_dir(dir, ext='.bak'***REMOVED***:
    ***REMOVED***Figure out the name of a directory to back up the given dir to
    (adding .bak, .bak2, etc***REMOVED******REMOVED***
    n = 1
    extension = ext
    while os.path.exists(dir + extension***REMOVED***:
        n += 1
        extension = ext + str(n***REMOVED***
    return dir + extension


def ask_path_exists(message, options***REMOVED***:
    for action in os.environ.get('PIP_EXISTS_ACTION', ''***REMOVED***.split(***REMOVED***:
        if action in options:
            return action
    return ask(message, options***REMOVED***


def ask(message, options***REMOVED***:
    ***REMOVED***Ask the message interactively, with the given possible responses***REMOVED***
    while 1:
        if os.environ.get('PIP_NO_INPUT'***REMOVED***:
            raise Exception(
                'No input was expected ($PIP_NO_INPUT set***REMOVED***; question: %s' %
                message
            ***REMOVED***
        response = input(message***REMOVED***
        response = response.strip(***REMOVED***.lower(***REMOVED***
        if response not in options:
            print(
                'Your response (%r***REMOVED*** was not one of the expected responses: '
                '%s' % (response, ', '.join(options***REMOVED******REMOVED***
            ***REMOVED***
        else:
            return response


def format_size(bytes***REMOVED***:
    if bytes > 1000 * 1000:
        return '%.1fMB' % (bytes / 1000.0 / 1000***REMOVED***
    elif bytes > 10 * 1000:
        return '%ikB' % (bytes / 1000***REMOVED***
    elif bytes > 1000:
        return '%.1fkB' % (bytes / 1000.0***REMOVED***
    else:
        return '%ibytes' % bytes


def is_installable_dir(path***REMOVED***:
    ***REMOVED***Return True if `path` is a directory containing a setup.py file.***REMOVED***
    if not os.path.isdir(path***REMOVED***:
        return False
    setup_py = os.path.join(path, 'setup.py'***REMOVED***
    if os.path.isfile(setup_py***REMOVED***:
        return True
    return False


def is_svn_page(html***REMOVED***:
    ***REMOVED***
    Returns true if the page appears to be the index page of an svn repository
    ***REMOVED***
    return (re.search(r'<title>[^<***REMOVED****Revision \d+:', html***REMOVED*** and
            re.search(r'Powered by (?:<a[^>***REMOVED****?>***REMOVED***?Subversion', html, re.I***REMOVED******REMOVED***


def file_contents(filename***REMOVED***:
    with open(filename, 'rb'***REMOVED*** as fp:
        return fp.read(***REMOVED***.decode('utf-8'***REMOVED***


def read_chunks(file, size=io.DEFAULT_BUFFER_SIZE***REMOVED***:
    ***REMOVED***Yield pieces of data from a file-like object until EOF.***REMOVED***
    while True:
        chunk = file.read(size***REMOVED***
        if not chunk:
            break
        yield chunk


def split_leading_dir(path***REMOVED***:
    path = path.lstrip('/'***REMOVED***.lstrip('\\'***REMOVED***
    if '/' in path and (('\\' in path and path.find('/'***REMOVED*** < path.find('\\'***REMOVED******REMOVED*** or
                        '\\' not in path***REMOVED***:
        return path.split('/', 1***REMOVED***
    elif '\\' in path:
        return path.split('\\', 1***REMOVED***
    else:
        return path, ''


def has_leading_dir(paths***REMOVED***:
    ***REMOVED***Returns true if all the paths have the same leading path name
    (i.e., everything is in one subdirectory in an archive***REMOVED******REMOVED***
    common_prefix = None
    for path in paths:
        prefix, rest = split_leading_dir(path***REMOVED***
        if not prefix:
            return False
        elif common_prefix is None:
            common_prefix = prefix
        elif prefix != common_prefix:
            return False
    return True


def normalize_path(path, resolve_symlinks=True***REMOVED***:
    ***REMOVED***
    Convert a path to its canonical, case-normalized, absolute version.

    ***REMOVED***
    path = expanduser(path***REMOVED***
    if resolve_symlinks:
        path = os.path.realpath(path***REMOVED***
    else:
        path = os.path.abspath(path***REMOVED***
    return os.path.normcase(path***REMOVED***


def splitext(path***REMOVED***:
    ***REMOVED***Like os.path.splitext, but take off .tar too***REMOVED***
    base, ext = posixpath.splitext(path***REMOVED***
    if base.lower(***REMOVED***.endswith('.tar'***REMOVED***:
        ext = base[-4:***REMOVED*** + ext
        base = base[:-4***REMOVED***
    return base, ext


def renames(old, new***REMOVED***:
    ***REMOVED***Like os.renames(***REMOVED***, but handles renaming across devices.***REMOVED***
    # Implementation borrowed from os.renames(***REMOVED***.
    head, tail = os.path.split(new***REMOVED***
    if head and tail and not os.path.exists(head***REMOVED***:
        os.makedirs(head***REMOVED***

    shutil.move(old, new***REMOVED***

    head, tail = os.path.split(old***REMOVED***
    if head and tail:
        ***REMOVED***
            os.removedirs(head***REMOVED***
        except OSError:
            pass


def is_local(path***REMOVED***:
    ***REMOVED***
    Return True if path is within sys.prefix, if we're running in a virtualenv.

    If we're not in a virtualenv, all paths are considered "local."

    ***REMOVED***
    if not running_under_virtualenv(***REMOVED***:
        return True
    return normalize_path(path***REMOVED***.startswith(normalize_path(sys.prefix***REMOVED******REMOVED***


def dist_is_local(dist***REMOVED***:
    ***REMOVED***
    Return True if given Distribution object is installed locally
    (i.e. within current virtualenv***REMOVED***.

    Always True if we're not in a virtualenv.

    ***REMOVED***
    return is_local(dist_location(dist***REMOVED******REMOVED***


def dist_in_usersite(dist***REMOVED***:
    ***REMOVED***
    Return True if given Distribution is installed in user site.
    ***REMOVED***
    norm_path = normalize_path(dist_location(dist***REMOVED******REMOVED***
    return norm_path.startswith(normalize_path(user_site***REMOVED******REMOVED***


def dist_in_site_packages(dist***REMOVED***:
    ***REMOVED***
    Return True if given Distribution is installed in
    distutils.sysconfig.get_python_lib(***REMOVED***.
    ***REMOVED***
    return normalize_path(
        dist_location(dist***REMOVED***
    ***REMOVED***.startswith(normalize_path(site_packages***REMOVED******REMOVED***


def dist_is_editable(dist***REMOVED***:
    ***REMOVED***Is distribution an editable install?***REMOVED***
    for path_item in sys.path:
        egg_link = os.path.join(path_item, dist.project_name + '.egg-link'***REMOVED***
        if os.path.isfile(egg_link***REMOVED***:
            return True
    return False


def get_installed_distributions(local_only=True,
                                skip=stdlib_pkgs,
                                include_editables=True,
                                editables_only=False,
                                user_only=False***REMOVED***:
    ***REMOVED***
    Return a list of installed Distribution objects.

    If ``local_only`` is True (default***REMOVED***, only return installations
    local to the current virtualenv, if in a virtualenv.

    ``skip`` argument is an iterable of lower-case project names to
    ignore; defaults to stdlib_pkgs

    If ``editables`` is False, don't report editables.

    If ``editables_only`` is True , only report editables.

    If ``user_only`` is True , only report installations in the user
    site directory.

    ***REMOVED***
    if local_only:
        local_test = dist_is_local
    else:
        def local_test(d***REMOVED***:
            return True

    if include_editables:
        def editable_test(d***REMOVED***:
            return True
    else:
        def editable_test(d***REMOVED***:
            return not dist_is_editable(d***REMOVED***

    if editables_only:
        def editables_only_test(d***REMOVED***:
            return dist_is_editable(d***REMOVED***
    else:
        def editables_only_test(d***REMOVED***:
            return True

    if user_only:
        user_test = dist_in_usersite
    else:
        def user_test(d***REMOVED***:
            return True

    return [d for d in pkg_resources.working_set
            if local_test(d***REMOVED*** and
            d.key not in skip and
            editable_test(d***REMOVED*** and
            editables_only_test(d***REMOVED*** and
            user_test(d***REMOVED***
            ***REMOVED***


def egg_link_path(dist***REMOVED***:
    ***REMOVED***
    Return the path for the .egg-link file if it exists, otherwise, None.

    There's 3 scenarios:
    1***REMOVED*** not in a virtualenv
       try to find in site.USER_SITE, then site_packages
    2***REMOVED*** in a no-global virtualenv
       try to find in site_packages
    3***REMOVED*** in a yes-global virtualenv
       try to find in site_packages, then site.USER_SITE
       (don't look in global location***REMOVED***

    For #1 and #3, there could be odd cases, where there's an egg-link in 2
    locations.

    This method will just return the first one found.
    ***REMOVED***
    sites = [***REMOVED***
    if running_under_virtualenv(***REMOVED***:
        if virtualenv_no_global(***REMOVED***:
            sites.append(site_packages***REMOVED***
        else:
            sites.append(site_packages***REMOVED***
            if user_site:
                sites.append(user_site***REMOVED***
    else:
        if user_site:
            sites.append(user_site***REMOVED***
        sites.append(site_packages***REMOVED***

    for site in sites:
        egglink = os.path.join(site, dist.project_name***REMOVED*** + '.egg-link'
        if os.path.isfile(egglink***REMOVED***:
            return egglink


def dist_location(dist***REMOVED***:
    ***REMOVED***
    Get the site-packages location of this distribution. Generally
    this is dist.location, except in the case of develop-installed
    packages, where dist.location is the source code location, and we
    want to know where the egg-link file is.

    ***REMOVED***
    egg_link = egg_link_path(dist***REMOVED***
    if egg_link:
        return egg_link
    return dist.location


def get_terminal_size(***REMOVED***:
    ***REMOVED***Returns a tuple (x, y***REMOVED*** representing the width(x***REMOVED*** and the height(x***REMOVED***
    in characters of the terminal window.***REMOVED***
    def ioctl_GWINSZ(fd***REMOVED***:
        ***REMOVED***
            import fcntl
            import termios
            import struct
            cr = struct.unpack(
                'hh',
                fcntl.ioctl(fd, termios.TIOCGWINSZ, '1234'***REMOVED***
            ***REMOVED***
        ***REMOVED***
            return None
        if cr == (0, 0***REMOVED***:
            return None
        return cr
    cr = ioctl_GWINSZ(0***REMOVED*** or ioctl_GWINSZ(1***REMOVED*** or ioctl_GWINSZ(2***REMOVED***
    if not cr:
        ***REMOVED***
            fd = os.open(os.ctermid(***REMOVED***, os.O_RDONLY***REMOVED***
            cr = ioctl_GWINSZ(fd***REMOVED***
            os.close(fd***REMOVED***
        ***REMOVED***
            pass
    if not cr:
        cr = (os.environ.get('LINES', 25***REMOVED***, os.environ.get('COLUMNS', 80***REMOVED******REMOVED***
    return int(cr[1***REMOVED******REMOVED***, int(cr[0***REMOVED******REMOVED***


def current_umask(***REMOVED***:
    ***REMOVED***Get the current umask which involves having to set it temporarily.***REMOVED***
    mask = os.umask(0***REMOVED***
    os.umask(mask***REMOVED***
    return mask


def unzip_file(filename, location, flatten=True***REMOVED***:
    ***REMOVED***
    Unzip the file (with path `filename`***REMOVED*** to the destination `location`.  All
    files are written based on system defaults and umask (i.e. permissions are
    not preserved***REMOVED***, except that regular file members with any execute
    permissions (user, group, or world***REMOVED*** have "chmod +x" applied after being
    written. Note that for windows, any execute changes using os.chmod are
    no-ops per the python docs.
    ***REMOVED***
    ensure_dir(location***REMOVED***
    zipfp = open(filename, 'rb'***REMOVED***
    ***REMOVED***
        zip = zipfile.ZipFile(zipfp, allowZip64=True***REMOVED***
        leading = has_leading_dir(zip.namelist(***REMOVED******REMOVED*** and flatten
        for info in zip.infolist(***REMOVED***:
            name = info.filename
            data = zip.read(name***REMOVED***
            fn = name
            if leading:
                fn = split_leading_dir(name***REMOVED***[1***REMOVED***
            fn = os.path.join(location, fn***REMOVED***
            dir = os.path.dirname(fn***REMOVED***
            if fn.endswith('/'***REMOVED*** or fn.endswith('\\'***REMOVED***:
                # A directory
                ensure_dir(fn***REMOVED***
            else:
                ensure_dir(dir***REMOVED***
                fp = open(fn, 'wb'***REMOVED***
                ***REMOVED***
                    fp.write(data***REMOVED***
                finally:
                    fp.close(***REMOVED***
                    mode = info.external_attr >> 16
                    # if mode and regular file and any execute permissions for
                    # user/group/world?
                    if mode and stat.S_ISREG(mode***REMOVED*** and mode & 0o111:
                        # make dest file have execute for user/group/world
                        # (chmod +x***REMOVED*** no-op on windows per python docs
                        os.chmod(fn, (0o777 - current_umask(***REMOVED*** | 0o111***REMOVED******REMOVED***
    finally:
        zipfp.close(***REMOVED***


def untar_file(filename, location***REMOVED***:
    ***REMOVED***
    Untar the file (with path `filename`***REMOVED*** to the destination `location`.
    All files are written based on system defaults and umask (i.e. permissions
    are not preserved***REMOVED***, except that regular file members with any execute
    permissions (user, group, or world***REMOVED*** have "chmod +x" applied after being
    written.  Note that for windows, any execute changes using os.chmod are
    no-ops per the python docs.
    ***REMOVED***
    ensure_dir(location***REMOVED***
    if filename.lower(***REMOVED***.endswith('.gz'***REMOVED*** or filename.lower(***REMOVED***.endswith('.tgz'***REMOVED***:
        mode = 'r:gz'
    elif filename.lower(***REMOVED***.endswith(BZ2_EXTENSIONS***REMOVED***:
        mode = 'r:bz2'
    elif filename.lower(***REMOVED***.endswith(XZ_EXTENSIONS***REMOVED***:
        mode = 'r:xz'
    elif filename.lower(***REMOVED***.endswith('.tar'***REMOVED***:
        mode = 'r'
    else:
        logger.warning(
            'Cannot determine compression type for file %s', filename,
        ***REMOVED***
        mode = 'r:*'
    tar = tarfile.open(filename, mode***REMOVED***
    ***REMOVED***
        # note: python<=2.5 doesn't seem to know about pax headers, filter them
        leading = has_leading_dir([
            member.name for member in tar.getmembers(***REMOVED***
            if member.name != 'pax_global_header'
        ***REMOVED******REMOVED***
        for member in tar.getmembers(***REMOVED***:
            fn = member.name
            if fn == 'pax_global_header':
                continue
            if leading:
                fn = split_leading_dir(fn***REMOVED***[1***REMOVED***
            path = os.path.join(location, fn***REMOVED***
            if member.isdir(***REMOVED***:
                ensure_dir(path***REMOVED***
            elif member.issym(***REMOVED***:
                ***REMOVED***
                    tar._extract_member(member, path***REMOVED***
                except Exception as exc:
                    # Some corrupt tar files seem to produce this
                    # (specifically bad symlinks***REMOVED***
                    logger.warning(
                        'In the tar file %s the member %s is invalid: %s',
                        filename, member.name, exc,
                    ***REMOVED***
                    continue
            else:
                ***REMOVED***
                    fp = tar.extractfile(member***REMOVED***
                except (KeyError, AttributeError***REMOVED*** as exc:
                    # Some corrupt tar files seem to produce this
                    # (specifically bad symlinks***REMOVED***
                    logger.warning(
                        'In the tar file %s the member %s is invalid: %s',
                        filename, member.name, exc,
                    ***REMOVED***
                    continue
                ensure_dir(os.path.dirname(path***REMOVED******REMOVED***
                with open(path, 'wb'***REMOVED*** as destfp:
                    shutil.copyfileobj(fp, destfp***REMOVED***
                fp.close(***REMOVED***
                # Update the timestamp (useful for cython compiled files***REMOVED***
                tar.utime(member, path***REMOVED***
                # member have any execute permissions for user/group/world?
                if member.mode & 0o111:
                    # make dest file have execute for user/group/world
                    # no-op on windows per python docs
                    os.chmod(path, (0o777 - current_umask(***REMOVED*** | 0o111***REMOVED******REMOVED***
    finally:
        tar.close(***REMOVED***


def unpack_file(filename, location, content_type, link***REMOVED***:
    filename = os.path.realpath(filename***REMOVED***
    if (content_type == 'application/zip' or
            filename.lower(***REMOVED***.endswith(ZIP_EXTENSIONS***REMOVED*** or
            zipfile.is_zipfile(filename***REMOVED******REMOVED***:
        unzip_file(
            filename,
            location,
            flatten=not filename.endswith('.whl'***REMOVED***
        ***REMOVED***
    elif (content_type == 'application/x-gzip' or
            tarfile.is_tarfile(filename***REMOVED*** or
            filename.lower(***REMOVED***.endswith(
                TAR_EXTENSIONS + BZ2_EXTENSIONS + XZ_EXTENSIONS***REMOVED******REMOVED***:
        untar_file(filename, location***REMOVED***
    elif (content_type and content_type.startswith('text/html'***REMOVED*** and
            is_svn_page(file_contents(filename***REMOVED******REMOVED******REMOVED***:
        # We don't really care about this
        from pip.vcs.subversion import Subversion
        Subversion('svn+' + link.url***REMOVED***.unpack(location***REMOVED***
    else:
        # FIXME: handle?
        # FIXME: magic signatures?
        logger.critical(
            'Cannot unpack file %s (downloaded from %s, content-type: %s***REMOVED***; '
            'cannot detect archive format',
            filename, location, content_type,
        ***REMOVED***
        raise InstallationError(
            'Cannot determine archive format of %s' % location
        ***REMOVED***


def remove_tracebacks(output***REMOVED***:
    pattern = (r'(?:\W+File "(?:.****REMOVED***", line (?:.****REMOVED***\W+(?:.****REMOVED***\W+\^\W+***REMOVED***?'
               r'Syntax(?:Error|Warning***REMOVED***: (?:.****REMOVED***'***REMOVED***
    output = re.sub(pattern, '', output***REMOVED***
    if PY2:
        return output
    # compileall.compile_dir(***REMOVED*** prints different messages to stdout
    # in Python 3
    return re.sub(r"\*\*\* Error compiling (?:.****REMOVED***", '', output***REMOVED***


def call_subprocess(cmd, show_stdout=True, cwd=None,
                    on_returncode='raise',
                    command_level=std_logging.DEBUG, command_desc=None,
                    extra_environ=None, spinner=None***REMOVED***:
    # This function's handling of subprocess output is confusing and I
    # previously broke it terribly, so as penance I will write a long comment
    # explaining things.
    #
    # The obvious thing that affects output is the show_stdout=
    # kwarg. show_stdout=True means, let the subprocess write directly to our
    # stdout. Even though it is nominally the default, it is almost never used
    # inside pip (and should not be used in new code without a very good
    # reason***REMOVED***; as of 2016-02-22 it is only used in a few places inside the VCS
    # wrapper code. Ideally we should get rid of it entirely, because it
    # creates a lot of complexity here for a rarely used feature.
    #
    # Most places in pip set show_stdout=False. What this means is:
    # - We connect the child stdout to a pipe, which we read.
    # - By default, we hide the output but show a spinner -- unless the
    #   subprocess exits with an error, in which case we show the output.
    # - If the --verbose option was passed (= loglevel is DEBUG***REMOVED***, then we show
    #   the output unconditionally. (But in this case we don't want to show
    #   the output a second time if it turns out that there was an error.***REMOVED***
    #
    # stderr is always merged with stdout (even if show_stdout=True***REMOVED***.
    if show_stdout:
        stdout = None
    else:
        stdout = subprocess.PIPE
    if command_desc is None:
        cmd_parts = [***REMOVED***
        for part in cmd:
            if ' ' in part or '\n' in part or '"' in part or "'" in part:
                part = '"%s"' % part.replace('"', '\\"'***REMOVED***
            cmd_parts.append(part***REMOVED***
        command_desc = ' '.join(cmd_parts***REMOVED***
    logger.log(command_level, "Running command %s", command_desc***REMOVED***
    env = os.environ.copy(***REMOVED***
    if extra_environ:
        env.update(extra_environ***REMOVED***
    ***REMOVED***
        proc = subprocess.Popen(
            cmd, stderr=subprocess.STDOUT, stdin=None, stdout=stdout,
            cwd=cwd, env=env***REMOVED***
    except Exception as exc:
        logger.critical(
            "Error %s while executing command %s", exc, command_desc,
        ***REMOVED***
        raise
    if stdout is not None:
        all_output = [***REMOVED***
        while True:
            line = console_to_str(proc.stdout.readline(***REMOVED******REMOVED***
            if not line:
                break
            line = line.rstrip(***REMOVED***
            all_output.append(line + '\n'***REMOVED***
            if logger.getEffectiveLevel(***REMOVED*** <= std_logging.DEBUG:
                # Show the line immediately
                logger.debug(line***REMOVED***
            else:
                # Update the spinner
                if spinner is not None:
                    spinner.spin(***REMOVED***
    proc.wait(***REMOVED***
    if spinner is not None:
        if proc.returncode:
            spinner.finish("error"***REMOVED***
        else:
            spinner.finish("done"***REMOVED***
    if proc.returncode:
        if on_returncode == 'raise':
            if (logger.getEffectiveLevel(***REMOVED*** > std_logging.DEBUG and
                    not show_stdout***REMOVED***:
                logger.info(
                    'Complete output from command %s:', command_desc,
                ***REMOVED***
                logger.info(
                    ''.join(all_output***REMOVED*** +
                    '\n----------------------------------------'
                ***REMOVED***
            raise InstallationError(
                'Command "%s" failed with error code %s in %s'
                % (command_desc, proc.returncode, cwd***REMOVED******REMOVED***
        elif on_returncode == 'warn':
            logger.warning(
                'Command "%s" had error code %s in %s',
                command_desc, proc.returncode, cwd,
            ***REMOVED***
        elif on_returncode == 'ignore':
            pass
        else:
            raise ValueError('Invalid value: on_returncode=%s' %
                             repr(on_returncode***REMOVED******REMOVED***
    if not show_stdout:
        return remove_tracebacks(''.join(all_output***REMOVED******REMOVED***


def read_text_file(filename***REMOVED***:
    ***REMOVED***Return the contents of *filename*.

    Try to decode the file contents with utf-8, the preferred system encoding
    (e.g., cp1252 on some Windows machines***REMOVED***, and latin1, in that order.
    Decoding a byte string with latin1 will never raise an error. In the worst
    case, the returned string will contain some garbage characters.

    ***REMOVED***
    with open(filename, 'rb'***REMOVED*** as fp:
        data = fp.read(***REMOVED***

    encodings = ['utf-8', locale.getpreferredencoding(False***REMOVED***, 'latin1'***REMOVED***
    for enc in encodings:
        ***REMOVED***
            data = data.decode(enc***REMOVED***
        except UnicodeDecodeError:
            continue
        break

    assert type(data***REMOVED*** != bytes  # Latin1 should have worked.
    return data


def _make_build_dir(build_dir***REMOVED***:
    os.makedirs(build_dir***REMOVED***
    write_delete_marker_file(build_dir***REMOVED***


class FakeFile(object***REMOVED***:
    ***REMOVED***Wrap a list of lines in an object with readline(***REMOVED*** to make
    ConfigParser happy.***REMOVED***
    def __init__(self, lines***REMOVED***:
        self._gen = (l for l in lines***REMOVED***

    def readline(self***REMOVED***:
        ***REMOVED***
            ***REMOVED***
                return next(self._gen***REMOVED***
            except NameError:
                return self._gen.next(***REMOVED***
        except StopIteration:
            return ''

    def __iter__(self***REMOVED***:
        return self._gen


class StreamWrapper(StringIO***REMOVED***:

    @classmethod
    def from_stream(cls, orig_stream***REMOVED***:
        cls.orig_stream = orig_stream
        return cls(***REMOVED***

    # compileall.compile_dir(***REMOVED*** needs stdout.encoding to print to stdout
    @property
    def encoding(self***REMOVED***:
        return self.orig_stream.encoding


@contextlib.contextmanager
def captured_output(stream_name***REMOVED***:
    ***REMOVED***Return a context manager used by captured_stdout/stdin/stderr
    that temporarily replaces the sys stream *stream_name* with a StringIO.

    Taken from Lib/support/__init__.py in the CPython repo.
    ***REMOVED***
    orig_stdout = getattr(sys, stream_name***REMOVED***
    setattr(sys, stream_name, StreamWrapper.from_stream(orig_stdout***REMOVED******REMOVED***
    ***REMOVED***
        yield getattr(sys, stream_name***REMOVED***
    finally:
        setattr(sys, stream_name, orig_stdout***REMOVED***


def captured_stdout(***REMOVED***:
    ***REMOVED***Capture the output of sys.stdout:

       with captured_stdout(***REMOVED*** as stdout:
           print('hello'***REMOVED***
       self.assertEqual(stdout.getvalue(***REMOVED***, 'hello\n'***REMOVED***

    Taken from Lib/support/__init__.py in the CPython repo.
    ***REMOVED***
    return captured_output('stdout'***REMOVED***


class cached_property(object***REMOVED***:
    ***REMOVED***A property that is only computed once per instance and then replaces
       itself with an ordinary attribute. Deleting the attribute resets the
       property.

       Source: https://github.com/bottlepy/bottle/blob/0.11.5/bottle.py#L175
    ***REMOVED***

    def __init__(self, func***REMOVED***:
        self.__doc__ = getattr(func, '__doc__'***REMOVED***
        self.func = func

    def __get__(self, obj, cls***REMOVED***:
        if obj is None:
            # We're being accessed from the class itself, not from an object
            return self
        value = obj.__dict__[self.func.__name__***REMOVED*** = self.func(obj***REMOVED***
        return value


def get_installed_version(dist_name***REMOVED***:
    ***REMOVED***Get the installed version of dist_name avoiding pkg_resources cache***REMOVED***
    # Create a requirement that we'll look for inside of setuptools.
    req = pkg_resources.Requirement.parse(dist_name***REMOVED***

    # We want to avoid having this cached, so we need to construct a new
    # working set each time.
    working_set = pkg_resources.WorkingSet(***REMOVED***

    # Get the installed distribution from our working set
    dist = working_set.find(req***REMOVED***

    # Check to see if we got an installed distribution or not, if we did
    # we want to return it's version.
    return dist.version if dist else None


def consume(iterator***REMOVED***:
    ***REMOVED***Consume an iterable at C speed.***REMOVED***
    deque(iterator, maxlen=0***REMOVED***
