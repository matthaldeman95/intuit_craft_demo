from __future__ import absolute_import

import hashlib

from pip.exceptions import HashMismatch, HashMissing, InstallationError
from pip.utils import read_chunks
from pip._vendor.six import iteritems, iterkeys, itervalues


# The recommended hash algo of the moment. Change this whenever the state of
# the art changes; it won't hurt backward compatibility.
FAVORITE_HASH = 'sha256'


# Names of hashlib algorithms allowed by the --hash option and ``pip hash``
# Currently, those are the ones at least as collision-resistant as sha256.
STRONG_HASHES = ['sha256', 'sha384', 'sha512'***REMOVED***


class Hashes(object***REMOVED***:
    ***REMOVED***A wrapper that builds multiple hashes at once and checks them against
    known-good values

    ***REMOVED***
    def __init__(self, hashes=None***REMOVED***:
        ***REMOVED***
        :param hashes: A dict of algorithm names pointing to lists of allowed
            hex digests
        ***REMOVED***
        self._allowed = {***REMOVED*** if hashes is None else hashes

    def check_against_chunks(self, chunks***REMOVED***:
        ***REMOVED***Check good hashes against ones built from iterable of chunks of
        data.

        Raise HashMismatch if none match.

        ***REMOVED***
        gots = {***REMOVED***
        for hash_name in iterkeys(self._allowed***REMOVED***:
            ***REMOVED***
                gots[hash_name***REMOVED*** = hashlib.new(hash_name***REMOVED***
            except (ValueError, TypeError***REMOVED***:
                raise InstallationError('Unknown hash name: %s' % hash_name***REMOVED***

        for chunk in chunks:
            for hash in itervalues(gots***REMOVED***:
                hash.update(chunk***REMOVED***

        for hash_name, got in iteritems(gots***REMOVED***:
            if got.hexdigest(***REMOVED*** in self._allowed[hash_name***REMOVED***:
                return
        self._raise(gots***REMOVED***

    def _raise(self, gots***REMOVED***:
        raise HashMismatch(self._allowed, gots***REMOVED***

    def check_against_file(self, file***REMOVED***:
        ***REMOVED***Check good hashes against a file-like object

        Raise HashMismatch if none match.

        ***REMOVED***
        return self.check_against_chunks(read_chunks(file***REMOVED******REMOVED***

    def check_against_path(self, path***REMOVED***:
        with open(path, 'rb'***REMOVED*** as file:
            return self.check_against_file(file***REMOVED***

    def __nonzero__(self***REMOVED***:
        ***REMOVED***Return whether I know any known-good hashes.***REMOVED***
        return bool(self._allowed***REMOVED***

    def __bool__(self***REMOVED***:
        return self.__nonzero__(***REMOVED***


class MissingHashes(Hashes***REMOVED***:
    ***REMOVED***A workalike for Hashes used when we're missing a hash for a requirement

    It computes the actual hash of the requirement and raises a HashMissing
    exception showing it to the user.

    ***REMOVED***
    def __init__(self***REMOVED***:
        ***REMOVED***Don't offer the ``hashes`` kwarg.***REMOVED***
        # Pass our favorite hash in to generate a "gotten hash". With the
        # empty list, it will never match, so an error will always raise.
        super(MissingHashes, self***REMOVED***.__init__(hashes={FAVORITE_HASH: [***REMOVED******REMOVED******REMOVED***

    def _raise(self, gots***REMOVED***:
        raise HashMissing(gots[FAVORITE_HASH***REMOVED***.hexdigest(***REMOVED******REMOVED***
