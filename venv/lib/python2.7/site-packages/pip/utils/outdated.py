from __future__ import absolute_import

import datetime
import json
import logging
***REMOVED***.path
import sys

from pip._vendor import lockfile
from pip._vendor.packaging import version as packaging_version

from pip.compat import total_seconds, WINDOWS
from pip.models import PyPI
from pip.locations import USER_CACHE_DIR, running_under_virtualenv
from pip.utils import ensure_dir, get_installed_version
from pip.utils.filesystem import check_path_owner


SELFCHECK_DATE_FMT = "%Y-%m-%dT%H:%M:%SZ"


logger = logging.getLogger(__name__***REMOVED***


class VirtualenvSelfCheckState(object***REMOVED***:
    def __init__(self***REMOVED***:
        self.statefile_path = os.path.join(sys.prefix, "pip-selfcheck.json"***REMOVED***

        # Load the existing state
        ***REMOVED***
            with open(self.statefile_path***REMOVED*** as statefile:
                self.state = json.load(statefile***REMOVED***
        except (IOError, ValueError***REMOVED***:
            self.state = {***REMOVED***

    def save(self, pypi_version, current_time***REMOVED***:
        # Attempt to write out our version check file
        with open(self.statefile_path, "w"***REMOVED*** as statefile:
            json.dump(
            ***REMOVED***
                    "last_check": current_time.strftime(SELFCHECK_DATE_FMT***REMOVED***,
                    "pypi_version": pypi_version,
        ***REMOVED***
                statefile,
                sort_keys=True,
                separators=(",", ":"***REMOVED***
            ***REMOVED***


class GlobalSelfCheckState(object***REMOVED***:
    def __init__(self***REMOVED***:
        self.statefile_path = os.path.join(USER_CACHE_DIR, "selfcheck.json"***REMOVED***

        # Load the existing state
        ***REMOVED***
            with open(self.statefile_path***REMOVED*** as statefile:
                self.state = json.load(statefile***REMOVED***[sys.prefix***REMOVED***
        except (IOError, ValueError, KeyError***REMOVED***:
            self.state = {***REMOVED***

    def save(self, pypi_version, current_time***REMOVED***:
        # Check to make sure that we own the directory
        if not check_path_owner(os.path.dirname(self.statefile_path***REMOVED******REMOVED***:
            return

        # Now that we've ensured the directory is owned by this user, we'll go
        # ahead and make sure that all our directories are created.
        ensure_dir(os.path.dirname(self.statefile_path***REMOVED******REMOVED***

        # Attempt to write out our version check file
        with lockfile.LockFile(self.statefile_path***REMOVED***:
            if os.path.exists(self.statefile_path***REMOVED***:
                with open(self.statefile_path***REMOVED*** as statefile:
                    state = json.load(statefile***REMOVED***
            else:
                state = {***REMOVED***

            state[sys.prefix***REMOVED*** = {
                "last_check": current_time.strftime(SELFCHECK_DATE_FMT***REMOVED***,
                "pypi_version": pypi_version,
        ***REMOVED***

            with open(self.statefile_path, "w"***REMOVED*** as statefile:
                json.dump(state, statefile, sort_keys=True,
                          separators=(",", ":"***REMOVED******REMOVED***


def load_selfcheck_statefile(***REMOVED***:
    if running_under_virtualenv(***REMOVED***:
        return VirtualenvSelfCheckState(***REMOVED***
    else:
        return GlobalSelfCheckState(***REMOVED***


def pip_version_check(session***REMOVED***:
    ***REMOVED***Check for an update for pip.

    Limit the frequency of checks to once per week. State is stored either in
    the active virtualenv or in the user's USER_CACHE_DIR keyed off the prefix
    of the pip script path.
    ***REMOVED***
    installed_version = get_installed_version("pip"***REMOVED***
    if installed_version is None:
        return

    pip_version = packaging_version.parse(installed_version***REMOVED***
    pypi_version = None

    ***REMOVED***
        state = load_selfcheck_statefile(***REMOVED***

        current_time = datetime.datetime.utcnow(***REMOVED***
        # Determine if we need to refresh the state
        if "last_check" in state.state and "pypi_version" in state.state:
            last_check = datetime.datetime.strptime(
                state.state["last_check"***REMOVED***,
                SELFCHECK_DATE_FMT
            ***REMOVED***
            if total_seconds(current_time - last_check***REMOVED*** < 7 * 24 * 60 * 60:
                pypi_version = state.state["pypi_version"***REMOVED***

        # Refresh the version if we need to or just see if we need to warn
        if pypi_version is None:
            resp = session.get(
                PyPI.pip_json_url,
                headers={"Accept": "application/json"***REMOVED***,
            ***REMOVED***
            resp.raise_for_status(***REMOVED***
            pypi_version = [
                v for v in sorted(
                    list(resp.json(***REMOVED***["releases"***REMOVED******REMOVED***,
                    key=packaging_version.parse,
                ***REMOVED***
                if not packaging_version.parse(v***REMOVED***.is_prerelease
            ***REMOVED***[-1***REMOVED***

            # save that we've performed a check
            state.save(pypi_version, current_time***REMOVED***

        remote_version = packaging_version.parse(pypi_version***REMOVED***

        # Determine if our pypi_version is older
        if (pip_version < remote_version and
                pip_version.base_version != remote_version.base_version***REMOVED***:
            # Advise "python -m pip" on Windows to avoid issues
            # with overwriting pip.exe.
            if WINDOWS:
                pip_cmd = "python -m pip"
            else:
                pip_cmd = "pip"
            logger.warning(
                "You are using pip version %s, however version %s is "
                "available.\nYou should consider upgrading via the "
                "'%s install --upgrade pip' command.",
                pip_version, pypi_version, pip_cmd
            ***REMOVED***

    except Exception:
        logger.debug(
            "There was an error checking the latest version of pip",
            exc_info=True,
        ***REMOVED***
