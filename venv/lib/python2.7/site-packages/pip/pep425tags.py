***REMOVED***Generate and work with PEP 425 Compatibility Tags.***REMOVED***
from __future__ import absolute_import

import re
import sys
import warnings
import platform
import logging
import ctypes

***REMOVED***
    import sysconfig
except ImportError:  # pragma nocover
    # Python < 2.7
    import distutils.sysconfig as sysconfig
import distutils.util

from pip.compat import OrderedDict


logger = logging.getLogger(__name__***REMOVED***

_osx_arch_pat = re.compile(r'(.+***REMOVED***_(\d+***REMOVED***_(\d+***REMOVED***_(.+***REMOVED***'***REMOVED***


def get_config_var(var***REMOVED***:
    ***REMOVED***
        return sysconfig.get_config_var(var***REMOVED***
    except IOError as e:  # Issue #1074
        warnings.warn("{0***REMOVED***".format(e***REMOVED***, RuntimeWarning***REMOVED***
        return None


def get_abbr_impl(***REMOVED***:
    ***REMOVED***Return abbreviated implementation name.***REMOVED***
    if hasattr(sys, 'pypy_version_info'***REMOVED***:
        pyimpl = 'pp'
    elif sys.platform.startswith('java'***REMOVED***:
        pyimpl = 'jy'
    elif sys.platform == 'cli':
        pyimpl = 'ip'
    else:
        pyimpl = 'cp'
    return pyimpl


def get_impl_ver(***REMOVED***:
    ***REMOVED***Return implementation version.***REMOVED***
    impl_ver = get_config_var("py_version_nodot"***REMOVED***
    if not impl_ver or get_abbr_impl(***REMOVED*** == 'pp':
        impl_ver = ''.join(map(str, get_impl_version_info(***REMOVED******REMOVED******REMOVED***
    return impl_ver


def get_impl_version_info(***REMOVED***:
    ***REMOVED***Return sys.version_info-like tuple for use in decrementing the minor
    version.***REMOVED***
    if get_abbr_impl(***REMOVED*** == 'pp':
        # as per https://github.com/pypa/pip/issues/2882
        return (sys.version_info[0***REMOVED***, sys.pypy_version_info.major,
                sys.pypy_version_info.minor***REMOVED***
    else:
        return sys.version_info[0***REMOVED***, sys.version_info[1***REMOVED***


def get_impl_tag(***REMOVED***:
    ***REMOVED***
    Returns the Tag for this specific implementation.
    ***REMOVED***
    return "{0***REMOVED***{1***REMOVED***".format(get_abbr_impl(***REMOVED***, get_impl_ver(***REMOVED******REMOVED***


def get_flag(var, fallback, expected=True, warn=True***REMOVED***:
    ***REMOVED***Use a fallback method for determining SOABI flags if the needed config
    var is unset or unavailable.***REMOVED***
    val = get_config_var(var***REMOVED***
    if val is None:
        if warn:
            logger.debug("Config variable '%s' is unset, Python ABI tag may "
                         "be incorrect", var***REMOVED***
        return fallback(***REMOVED***
    return val == expected


def get_abi_tag(***REMOVED***:
    ***REMOVED***Return the ABI tag based on SOABI (if available***REMOVED*** or emulate SOABI
    (CPython 2, PyPy***REMOVED***.***REMOVED***
    soabi = get_config_var('SOABI'***REMOVED***
    impl = get_abbr_impl(***REMOVED***
    if not soabi and impl in ('cp', 'pp'***REMOVED*** and hasattr(sys, 'maxunicode'***REMOVED***:
        d = ''
        m = ''
        u = ''
        if get_flag('Py_DEBUG',
                    lambda: hasattr(sys, 'gettotalrefcount'***REMOVED***,
                    warn=(impl == 'cp'***REMOVED******REMOVED***:
            d = 'd'
        if get_flag('WITH_PYMALLOC',
                    lambda: impl == 'cp',
                    warn=(impl == 'cp'***REMOVED******REMOVED***:
            m = 'm'
        if get_flag('Py_UNICODE_SIZE',
                    lambda: sys.maxunicode == 0x10ffff,
                    expected=4,
                    warn=(impl == 'cp' and
                          sys.version_info < (3, 3***REMOVED******REMOVED******REMOVED*** \
                and sys.version_info < (3, 3***REMOVED***:
            u = 'u'
        abi = '%s%s%s%s%s' % (impl, get_impl_ver(***REMOVED***, d, m, u***REMOVED***
    elif soabi and soabi.startswith('cpython-'***REMOVED***:
        abi = 'cp' + soabi.split('-'***REMOVED***[1***REMOVED***
    elif soabi:
        abi = soabi.replace('.', '_'***REMOVED***.replace('-', '_'***REMOVED***
    else:
        abi = None
    return abi


def _is_running_32bit(***REMOVED***:
    return sys.maxsize == 2147483647


def get_platform(***REMOVED***:
    ***REMOVED***Return our platform name 'win32', 'linux_x86_64'***REMOVED***
    if sys.platform == 'darwin':
        # distutils.util.get_platform(***REMOVED*** returns the release based on the value
        # of MACOSX_DEPLOYMENT_TARGET on which Python was built, which may
        # be signficantly older than the user's current machine.
        release, _, machine = platform.mac_ver(***REMOVED***
        split_ver = release.split('.'***REMOVED***

        if machine == "x86_64" and _is_running_32bit(***REMOVED***:
            machine = "i386"
        elif machine == "ppc64" and _is_running_32bit(***REMOVED***:
            machine = "ppc"

        return 'macosx_{0***REMOVED***_{1***REMOVED***_{2***REMOVED***'.format(split_ver[0***REMOVED***, split_ver[1***REMOVED***, machine***REMOVED***

    # XXX remove distutils dependency
    result = distutils.util.get_platform(***REMOVED***.replace('.', '_'***REMOVED***.replace('-', '_'***REMOVED***
    if result == "linux_x86_64" and _is_running_32bit(***REMOVED***:
        # 32 bit Python program (running on a 64 bit Linux***REMOVED***: pip should only
        # install and run 32 bit compiled extensions in that case.
        result = "linux_i686"

    return result


def is_manylinux1_compatible(***REMOVED***:
    # Only Linux, and only x86-64 / i686
    if get_platform(***REMOVED*** not in ("linux_x86_64", "linux_i686"***REMOVED***:
        return False

    # Check for presence of _manylinux module
    ***REMOVED***
        import _manylinux
        return bool(_manylinux.manylinux1_compatible***REMOVED***
    except (ImportError, AttributeError***REMOVED***:
        # Fall through to heuristic check below
        pass

    # Check glibc version. CentOS 5 uses glibc 2.5.
    return have_compatible_glibc(2, 5***REMOVED***


# Separated out from have_compatible_glibc for easier unit testing
def check_glibc_version(version_str, needed_major, needed_minor***REMOVED***:
    # Parse string and check against requested version.
    #
    # We use a regexp instead of str.split because we want to discard any
    # random junk that might come after the minor version -- this might happen
    # in patched/forked versions of glibc (e.g. Linaro's version of glibc
    # uses version strings like "2.20-2014.11"***REMOVED***. See gh-3588.
    m = re.match(r"(?P<major>[0-9***REMOVED***+***REMOVED***\.(?P<minor>[0-9***REMOVED***+***REMOVED***", version_str***REMOVED***
    if not m:
        warnings.warn("Expected glibc version with 2 components major.minor,"
                      " got: %s" % version_str, RuntimeWarning***REMOVED***
        return False
    return (int(m.group("major"***REMOVED******REMOVED*** == needed_major and
            int(m.group("minor"***REMOVED******REMOVED*** >= needed_minor***REMOVED***


def have_compatible_glibc(major, minimum_minor***REMOVED***:
    # ctypes.CDLL(None***REMOVED*** internally calls dlopen(NULL***REMOVED***, and as the dlopen
    # manpage says, "If filename is NULL, then the returned handle is for the
    # main program". This way we can let the linker do the work to figure out
    # which libc our process is actually using.
    process_namespace = ctypes.CDLL(None***REMOVED***
    ***REMOVED***
        gnu_get_libc_version = process_namespace.gnu_get_libc_version
    except AttributeError:
        # Symbol doesn't exist -> therefore, we are not linked to
        # glibc.
        return False

    # Call gnu_get_libc_version, which returns a string like "2.5".
    gnu_get_libc_version.restype = ctypes.c_char_p
    version_str = gnu_get_libc_version(***REMOVED***
    # py2 / py3 compatibility:
    if not isinstance(version_str, str***REMOVED***:
        version_str = version_str.decode("ascii"***REMOVED***

    return check_glibc_version(version_str, major, minimum_minor***REMOVED***


def get_darwin_arches(major, minor, machine***REMOVED***:
    ***REMOVED***Return a list of supported arches (including group arches***REMOVED*** for
    the given major, minor and machine architecture of an OS X machine.
    ***REMOVED***
    arches = [***REMOVED***

    def _supports_arch(major, minor, arch***REMOVED***:
        # Looking at the application support for OS X versions in the chart
        # provided by https://en.wikipedia.org/wiki/OS_X#Versions it appears
        # our timeline looks roughly like:
        #
        # 10.0 - Introduces ppc support.
        # 10.4 - Introduces ppc64, i386, and x86_64 support, however the ppc64
        #        and x86_64 support is CLI only, and cannot be used for GUI
        #        applications.
        # 10.5 - Extends ppc64 and x86_64 support to cover GUI applications.
        # 10.6 - Drops support for ppc64
        # 10.7 - Drops support for ppc
        #
        # Given that we do not know if we're installing a CLI or a GUI
        # application, we must be conservative and assume it might be a GUI
        # application and behave as if ppc64 and x86_64 support did not occur
        # until 10.5.
        #
        # Note: The above information is taken from the "Application support"
        #       column in the chart not the "Processor support" since I believe
        #       that we care about what instruction sets an application can use
        #       not which processors the OS supports.
        if arch == 'ppc':
            return (major, minor***REMOVED*** <= (10, 5***REMOVED***
        if arch == 'ppc64':
            return (major, minor***REMOVED*** == (10, 5***REMOVED***
        if arch == 'i386':
            return (major, minor***REMOVED*** >= (10, 4***REMOVED***
        if arch == 'x86_64':
            return (major, minor***REMOVED*** >= (10, 5***REMOVED***
        if arch in groups:
            for garch in groups[arch***REMOVED***:
                if _supports_arch(major, minor, garch***REMOVED***:
                    return True
        return False

    groups = OrderedDict([
        ("fat", ("i386", "ppc"***REMOVED******REMOVED***,
        ("intel", ("x86_64", "i386"***REMOVED******REMOVED***,
        ("fat64", ("x86_64", "ppc64"***REMOVED******REMOVED***,
        ("fat32", ("x86_64", "i386", "ppc"***REMOVED******REMOVED***,
    ***REMOVED******REMOVED***

    if _supports_arch(major, minor, machine***REMOVED***:
        arches.append(machine***REMOVED***

    for garch in groups:
        if machine in groups[garch***REMOVED*** and _supports_arch(major, minor, garch***REMOVED***:
            arches.append(garch***REMOVED***

    arches.append('universal'***REMOVED***

    return arches


def get_supported(versions=None, noarch=False***REMOVED***:
    ***REMOVED***Return a list of supported tags for each version specified in
    `versions`.

    :param versions: a list of string versions, of the form ["33", "32"***REMOVED***,
        or None. The first version will be assumed to support our ABI.
    ***REMOVED***
    supported = [***REMOVED***

    # Versions must be given with respect to the preference
    if versions is None:
        versions = [***REMOVED***
        version_info = get_impl_version_info(***REMOVED***
        major = version_info[:-1***REMOVED***
        # Support all previous minor Python versions.
        for minor in range(version_info[-1***REMOVED***, -1, -1***REMOVED***:
            versions.append(''.join(map(str, major + (minor,***REMOVED******REMOVED******REMOVED******REMOVED***

    impl = get_abbr_impl(***REMOVED***

    abis = [***REMOVED***

    abi = get_abi_tag(***REMOVED***
    if abi:
        abis[0:0***REMOVED*** = [abi***REMOVED***

    abi3s = set(***REMOVED***
    import imp
    for suffix in imp.get_suffixes(***REMOVED***:
        if suffix[0***REMOVED***.startswith('.abi'***REMOVED***:
            abi3s.add(suffix[0***REMOVED***.split('.', 2***REMOVED***[1***REMOVED******REMOVED***

    abis.extend(sorted(list(abi3s***REMOVED******REMOVED******REMOVED***

    abis.append('none'***REMOVED***

    if not noarch:
        arch = get_platform(***REMOVED***
        if sys.platform == 'darwin':
            # support macosx-10.6-intel on macosx-10.9-x86_64
            match = _osx_arch_pat.match(arch***REMOVED***
            if match:
                name, major, minor, actual_arch = match.groups(***REMOVED***
                tpl = '{0***REMOVED***_{1***REMOVED***_%i_%s'.format(name, major***REMOVED***
                arches = [***REMOVED***
                for m in reversed(range(int(minor***REMOVED*** + 1***REMOVED******REMOVED***:
                    for a in get_darwin_arches(int(major***REMOVED***, m, actual_arch***REMOVED***:
                        arches.append(tpl % (m, a***REMOVED******REMOVED***
            else:
                # arch pattern didn't match (?!***REMOVED***
                arches = [arch***REMOVED***
        elif is_manylinux1_compatible(***REMOVED***:
            arches = [arch.replace('linux', 'manylinux1'***REMOVED***, arch***REMOVED***
        else:
            arches = [arch***REMOVED***

        # Current version, current API (built specifically for our Python***REMOVED***:
        for abi in abis:
            for arch in arches:
                supported.append(('%s%s' % (impl, versions[0***REMOVED******REMOVED***, abi, arch***REMOVED******REMOVED***

        # Has binaries, does not use the Python API:
        for arch in arches:
            supported.append(('py%s' % (versions[0***REMOVED***[0***REMOVED******REMOVED***, 'none', arch***REMOVED******REMOVED***

    # No abi / arch, but requires our implementation:
    supported.append(('%s%s' % (impl, versions[0***REMOVED******REMOVED***, 'none', 'any'***REMOVED******REMOVED***
    # Tagged specifically as being cross-version compatible
    # (with just the major version specified***REMOVED***
    supported.append(('%s%s' % (impl, versions[0***REMOVED***[0***REMOVED******REMOVED***, 'none', 'any'***REMOVED******REMOVED***

    # No abi / arch, generic Python
    for i, version in enumerate(versions***REMOVED***:
        supported.append(('py%s' % (version,***REMOVED***, 'none', 'any'***REMOVED******REMOVED***
        if i == 0:
            supported.append(('py%s' % (version[0***REMOVED******REMOVED***, 'none', 'any'***REMOVED******REMOVED***

    return supported

supported_tags = get_supported(***REMOVED***
supported_tags_noarch = get_supported(noarch=True***REMOVED***

implementation_tag = get_impl_tag(***REMOVED***
