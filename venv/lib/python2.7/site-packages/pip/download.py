from __future__ import absolute_import

import cgi
import email.utils
import getpass
import json
import logging
import mimetypes
***REMOVED***
import platform
import re
import shutil
import sys
import tempfile

***REMOVED***
    import ssl  # noqa
    HAS_TLS = True
except ImportError:
    HAS_TLS = False

from pip._vendor.six.moves.urllib import parse as urllib_parse
from pip._vendor.six.moves.urllib import request as urllib_request

import pip

from pip.exceptions import InstallationError, HashMismatch
from pip.models import PyPI
from pip.utils import (splitext, rmtree, format_size, display_path,
                       backup_dir, ask_path_exists, unpack_file,
                       ARCHIVE_EXTENSIONS, consume, call_subprocess***REMOVED***
from pip.utils.encoding import auto_decode
from pip.utils.filesystem import check_path_owner
from pip.utils.logging import indent_log
from pip.utils.setuptools_build import SETUPTOOLS_SHIM
from pip.utils.ui import DownloadProgressBar, DownloadProgressSpinner
from pip.locations import write_delete_marker_file
from pip.vcs import vcs
from pip._vendor import requests, six
from pip._vendor.requests.adapters import BaseAdapter, HTTPAdapter
from pip._vendor.requests.auth import AuthBase, HTTPBasicAuth
from pip._vendor.requests.models import CONTENT_CHUNK_SIZE, Response
from pip._vendor.requests.structures import CaseInsensitiveDict
from pip._vendor.requests.packages import urllib3
from pip._vendor.cachecontrol import CacheControlAdapter
from pip._vendor.cachecontrol.caches import FileCache
from pip._vendor.lockfile import LockError
from pip._vendor.six.moves import xmlrpc_client


__all__ = ['get_file_content',
           'is_url', 'url_to_path', 'path_to_url',
           'is_archive_file', 'unpack_vcs_link',
           'unpack_file_url', 'is_vcs_url', 'is_file_url',
           'unpack_http_url', 'unpack_url'***REMOVED***


logger = logging.getLogger(__name__***REMOVED***


def user_agent(***REMOVED***:
    ***REMOVED***
    Return a string representing the user agent.
    ***REMOVED***
    data = {
        "installer": {"name": "pip", "version": pip.__version__***REMOVED***,
        "python": platform.python_version(***REMOVED***,
        "implementation": {
            "name": platform.python_implementation(***REMOVED***,
***REMOVED***
***REMOVED***

    if data["implementation"***REMOVED***["name"***REMOVED*** == 'CPython':
        data["implementation"***REMOVED***["version"***REMOVED*** = platform.python_version(***REMOVED***
    elif data["implementation"***REMOVED***["name"***REMOVED*** == 'PyPy':
        if sys.pypy_version_info.releaselevel == 'final':
            pypy_version_info = sys.pypy_version_info[:3***REMOVED***
        else:
            pypy_version_info = sys.pypy_version_info
        data["implementation"***REMOVED***["version"***REMOVED*** = ".".join(
            [str(x***REMOVED*** for x in pypy_version_info***REMOVED***
        ***REMOVED***
    elif data["implementation"***REMOVED***["name"***REMOVED*** == 'Jython':
        # Complete Guess
        data["implementation"***REMOVED***["version"***REMOVED*** = platform.python_version(***REMOVED***
    elif data["implementation"***REMOVED***["name"***REMOVED*** == 'IronPython':
        # Complete Guess
        data["implementation"***REMOVED***["version"***REMOVED*** = platform.python_version(***REMOVED***

    if sys.platform.startswith("linux"***REMOVED***:
        distro = dict(filter(
            lambda x: x[1***REMOVED***,
            zip(["name", "version", "id"***REMOVED***, platform.linux_distribution(***REMOVED******REMOVED***,
        ***REMOVED******REMOVED***
        libc = dict(filter(
            lambda x: x[1***REMOVED***,
            zip(["lib", "version"***REMOVED***, platform.libc_ver(***REMOVED******REMOVED***,
        ***REMOVED******REMOVED***
        if libc:
            distro["libc"***REMOVED*** = libc
        if distro:
            data["distro"***REMOVED*** = distro

    if sys.platform.startswith("darwin"***REMOVED*** and platform.mac_ver(***REMOVED***[0***REMOVED***:
        data["distro"***REMOVED*** = {"name": "OS X", "version": platform.mac_ver(***REMOVED***[0***REMOVED******REMOVED***

    if platform.system(***REMOVED***:
        data.setdefault("system", {***REMOVED******REMOVED***["name"***REMOVED*** = platform.system(***REMOVED***

    if platform.release(***REMOVED***:
        data.setdefault("system", {***REMOVED******REMOVED***["release"***REMOVED*** = platform.release(***REMOVED***

    if platform.machine(***REMOVED***:
        data["cpu"***REMOVED*** = platform.machine(***REMOVED***

    # Python 2.6 doesn't have ssl.OPENSSL_VERSION.
    if HAS_TLS and sys.version_info[:2***REMOVED*** > (2, 6***REMOVED***:
        data["openssl_version"***REMOVED*** = ssl.OPENSSL_VERSION

    return "{data[installer***REMOVED***[name***REMOVED******REMOVED***/{data[installer***REMOVED***[version***REMOVED******REMOVED*** {json***REMOVED***".format(
        data=data,
        json=json.dumps(data, separators=(",", ":"***REMOVED***, sort_keys=True***REMOVED***,
    ***REMOVED***


class MultiDomainBasicAuth(AuthBase***REMOVED***:

    def __init__(self, prompting=True***REMOVED***:
        self.prompting = prompting
        self.passwords = {***REMOVED***

    def __call__(self, req***REMOVED***:
        parsed = urllib_parse.urlparse(req.url***REMOVED***

        # Get the netloc without any embedded credentials
        netloc = parsed.netloc.rsplit("@", 1***REMOVED***[-1***REMOVED***

        # Set the url of the request to the url without any credentials
        req.url = urllib_parse.urlunparse(parsed[:1***REMOVED*** + (netloc,***REMOVED*** + parsed[2:***REMOVED******REMOVED***

        # Use any stored credentials that we have for this netloc
        username, password = self.passwords.get(netloc, (None, None***REMOVED******REMOVED***

        # Extract credentials embedded in the url if we have none stored
        if username is None:
            username, password = self.parse_credentials(parsed.netloc***REMOVED***

        if username or password:
            # Store the username and password
            self.passwords[netloc***REMOVED*** = (username, password***REMOVED***

            # Send the basic auth with this request
            req = HTTPBasicAuth(username or "", password or ""***REMOVED***(req***REMOVED***

        # Attach a hook to handle 401 responses
        req.register_hook("response", self.handle_401***REMOVED***

        return req

    def handle_401(self, resp, **kwargs***REMOVED***:
        # We only care about 401 responses, anything else we want to just
        #   pass through the actual response
        if resp.status_code != 401:
            return resp

        # We are not able to prompt the user so simple return the response
        if not self.prompting:
            return resp

        parsed = urllib_parse.urlparse(resp.url***REMOVED***

        # Prompt the user for a new username and password
        username = six.moves.input("User for %s: " % parsed.netloc***REMOVED***
        password = getpass.getpass("Password: "***REMOVED***

        # Store the new username and password to use for future requests
        if username or password:
            self.passwords[parsed.netloc***REMOVED*** = (username, password***REMOVED***

        # Consume content and release the original connection to allow our new
        #   request to reuse the same one.
        resp.content
        resp.raw.release_conn(***REMOVED***

        # Add our new username and password to the request
        req = HTTPBasicAuth(username or "", password or ""***REMOVED***(resp.request***REMOVED***

        # Send our new request
        new_resp = resp.connection.send(req, **kwargs***REMOVED***
        new_resp.history.append(resp***REMOVED***

        return new_resp

    def parse_credentials(self, netloc***REMOVED***:
        if "@" in netloc:
            userinfo = netloc.rsplit("@", 1***REMOVED***[0***REMOVED***
            if ":" in userinfo:
                return userinfo.split(":", 1***REMOVED***
            return userinfo, None
        return None, None


class LocalFSAdapter(BaseAdapter***REMOVED***:

    def send(self, request, stream=None, timeout=None, verify=None, cert=None,
             proxies=None***REMOVED***:
        pathname = url_to_path(request.url***REMOVED***

        resp = Response(***REMOVED***
        resp.status_code = 200
        resp.url = request.url

        ***REMOVED***
            stats = os.stat(pathname***REMOVED***
        except OSError as exc:
            resp.status_code = 404
            resp.raw = exc
        else:
            modified = email.utils.formatdate(stats.st_mtime, usegmt=True***REMOVED***
            content_type = mimetypes.guess_type(pathname***REMOVED***[0***REMOVED*** or "text/plain"
            resp.headers = CaseInsensitiveDict({
                "Content-Type": content_type,
                "Content-Length": stats.st_size,
                "Last-Modified": modified,
        ***REMOVED******REMOVED***

            resp.raw = open(pathname, "rb"***REMOVED***
            resp.close = resp.raw.close

        return resp

    def close(self***REMOVED***:
        pass


class SafeFileCache(FileCache***REMOVED***:
    ***REMOVED***
    A file based cache which is safe to use even when the target directory may
    not be accessible or writable.
    ***REMOVED***

    def __init__(self, *args, **kwargs***REMOVED***:
        super(SafeFileCache, self***REMOVED***.__init__(*args, **kwargs***REMOVED***

        # Check to ensure that the directory containing our cache directory
        # is owned by the user current executing pip. If it does not exist
        # we will check the parent directory until we find one that does exist.
        # If it is not owned by the user executing pip then we will disable
        # the cache and log a warning.
        if not check_path_owner(self.directory***REMOVED***:
            logger.warning(
                "The directory '%s' or its parent directory is not owned by "
                "the current user and the cache has been disabled. Please "
                "check the permissions and owner of that directory. If "
                "executing pip with sudo, you may want sudo's -H flag.",
                self.directory,
            ***REMOVED***

            # Set our directory to None to disable the Cache
            self.directory = None

    def get(self, *args, **kwargs***REMOVED***:
        # If we don't have a directory, then the cache should be a no-op.
        if self.directory is None:
            return

        ***REMOVED***
            return super(SafeFileCache, self***REMOVED***.get(*args, **kwargs***REMOVED***
        except (LockError, OSError, IOError***REMOVED***:
            # We intentionally silence this error, if we can't access the cache
            # then we can just skip caching and process the request as if
            # caching wasn't enabled.
            pass

    def set(self, *args, **kwargs***REMOVED***:
        # If we don't have a directory, then the cache should be a no-op.
        if self.directory is None:
            return

        ***REMOVED***
            return super(SafeFileCache, self***REMOVED***.set(*args, **kwargs***REMOVED***
        except (LockError, OSError, IOError***REMOVED***:
            # We intentionally silence this error, if we can't access the cache
            # then we can just skip caching and process the request as if
            # caching wasn't enabled.
            pass

    def delete(self, *args, **kwargs***REMOVED***:
        # If we don't have a directory, then the cache should be a no-op.
        if self.directory is None:
            return

        ***REMOVED***
            return super(SafeFileCache, self***REMOVED***.delete(*args, **kwargs***REMOVED***
        except (LockError, OSError, IOError***REMOVED***:
            # We intentionally silence this error, if we can't access the cache
            # then we can just skip caching and process the request as if
            # caching wasn't enabled.
            pass


class InsecureHTTPAdapter(HTTPAdapter***REMOVED***:

    def cert_verify(self, conn, url, verify, cert***REMOVED***:
        conn.cert_reqs = 'CERT_NONE'
        conn.ca_certs = None


class PipSession(requests.Session***REMOVED***:

    timeout = None

    def __init__(self, *args, **kwargs***REMOVED***:
        retries = kwargs.pop("retries", 0***REMOVED***
        cache = kwargs.pop("cache", None***REMOVED***
        insecure_hosts = kwargs.pop("insecure_hosts", [***REMOVED******REMOVED***

        super(PipSession, self***REMOVED***.__init__(*args, **kwargs***REMOVED***

        # Attach our User Agent to the request
        self.headers["User-Agent"***REMOVED*** = user_agent(***REMOVED***

        # Attach our Authentication handler to the session
        self.auth = MultiDomainBasicAuth(***REMOVED***

        # Create our urllib3.Retry instance which will allow us to customize
        # how we handle retries.
        retries = urllib3.Retry(
            # Set the total number of retries that a particular request can
            # have.
            total=retries,

            # A 503 error from PyPI typically means that the Fastly -> Origin
            # connection got interupted in some way. A 503 error in general
            # is typically considered a transient error so we'll go ahead and
            # retry it.
            status_forcelist=[503***REMOVED***,

            # Add a small amount of back off between failed requests in
            # order to prevent hammering the service.
            backoff_factor=0.25,
        ***REMOVED***

        # We want to _only_ cache responses on securely fetched origins. We do
        # this because we can't validate the response of an insecurely fetched
        # origin, and we don't want someone to be able to poison the cache and
        # require manual eviction from the cache to fix it.
        if cache:
            secure_adapter = CacheControlAdapter(
                cache=SafeFileCache(cache, use_dir_lock=True***REMOVED***,
                max_retries=retries,
            ***REMOVED***
        else:
            secure_adapter = HTTPAdapter(max_retries=retries***REMOVED***

        # Our Insecure HTTPAdapter disables HTTPS validation. It does not
        # support caching (see above***REMOVED*** so we'll use it for all http:// URLs as
        # well as any https:// host that we've marked as ignoring TLS errors
        # for.
        insecure_adapter = InsecureHTTPAdapter(max_retries=retries***REMOVED***

        self.mount("https://", secure_adapter***REMOVED***
        self.mount("http://", insecure_adapter***REMOVED***

        # Enable file:// urls
        self.mount("file://", LocalFSAdapter(***REMOVED******REMOVED***

        # We want to use a non-validating adapter for any requests which are
        # deemed insecure.
        for host in insecure_hosts:
            self.mount("https://{0***REMOVED***/".format(host***REMOVED***, insecure_adapter***REMOVED***

    def request(self, method, url, *args, **kwargs***REMOVED***:
        # Allow setting a default timeout on a session
        kwargs.setdefault("timeout", self.timeout***REMOVED***

        # Dispatch the actual request
        return super(PipSession, self***REMOVED***.request(method, url, *args, **kwargs***REMOVED***


def get_file_content(url, comes_from=None, session=None***REMOVED***:
    ***REMOVED***Gets the content of a file; it may be a filename, file: URL, or
    http: URL.  Returns (location, content***REMOVED***.  Content is unicode.***REMOVED***
    if session is None:
        raise TypeError(
            "get_file_content(***REMOVED*** missing 1 required keyword argument: 'session'"
        ***REMOVED***

    match = _scheme_re.search(url***REMOVED***
    if match:
        scheme = match.group(1***REMOVED***.lower(***REMOVED***
        if (scheme == 'file' and comes_from and
                comes_from.startswith('http'***REMOVED******REMOVED***:
            raise InstallationError(
                'Requirements file %s references URL %s, which is local'
                % (comes_from, url***REMOVED******REMOVED***
        if scheme == 'file':
            path = url.split(':', 1***REMOVED***[1***REMOVED***
            path = path.replace('\\', '/'***REMOVED***
            match = _url_slash_drive_re.match(path***REMOVED***
            if match:
                path = match.group(1***REMOVED*** + ':' + path.split('|', 1***REMOVED***[1***REMOVED***
            path = urllib_parse.unquote(path***REMOVED***
            if path.startswith('/'***REMOVED***:
                path = '/' + path.lstrip('/'***REMOVED***
            url = path
        else:
            # FIXME: catch some errors
            resp = session.get(url***REMOVED***
            resp.raise_for_status(***REMOVED***
            return resp.url, resp.text
    ***REMOVED***
        with open(url, 'rb'***REMOVED*** as f:
            content = auto_decode(f.read(***REMOVED******REMOVED***
    except IOError as exc:
        raise InstallationError(
            'Could not open requirements file: %s' % str(exc***REMOVED***
        ***REMOVED***
    return url, content


_scheme_re = re.compile(r'^(http|https|file***REMOVED***:', re.I***REMOVED***
_url_slash_drive_re = re.compile(r'/*([a-z***REMOVED******REMOVED***\|', re.I***REMOVED***


def is_url(name***REMOVED***:
    ***REMOVED***Returns true if the name looks like a URL***REMOVED***
    if ':' not in name:
        return False
    scheme = name.split(':', 1***REMOVED***[0***REMOVED***.lower(***REMOVED***
    return scheme in ['http', 'https', 'file', 'ftp'***REMOVED*** + vcs.all_schemes


def url_to_path(url***REMOVED***:
    ***REMOVED***
    Convert a file: URL to a path.
    ***REMOVED***
    assert url.startswith('file:'***REMOVED***, (
        "You can only turn file: urls into filenames (not %r***REMOVED***" % url***REMOVED***

    _, netloc, path, _, _ = urllib_parse.urlsplit(url***REMOVED***

    # if we have a UNC path, prepend UNC share notation
    if netloc:
        netloc = '\\\\' + netloc

    path = urllib_request.url2pathname(netloc + path***REMOVED***
    return path


def path_to_url(path***REMOVED***:
    ***REMOVED***
    Convert a path to a file: URL.  The path will be made absolute and have
    quoted path parts.
    ***REMOVED***
    path = os.path.normpath(os.path.abspath(path***REMOVED******REMOVED***
    url = urllib_parse.urljoin('file:', urllib_request.pathname2url(path***REMOVED******REMOVED***
    return url


def is_archive_file(name***REMOVED***:
    ***REMOVED***Return True if `name` is a considered as an archive file.***REMOVED***
    ext = splitext(name***REMOVED***[1***REMOVED***.lower(***REMOVED***
    if ext in ARCHIVE_EXTENSIONS:
        return True
    return False


def unpack_vcs_link(link, location***REMOVED***:
    vcs_backend = _get_used_vcs_backend(link***REMOVED***
    vcs_backend.unpack(location***REMOVED***


def _get_used_vcs_backend(link***REMOVED***:
    for backend in vcs.backends:
        if link.scheme in backend.schemes:
            vcs_backend = backend(link.url***REMOVED***
            return vcs_backend


def is_vcs_url(link***REMOVED***:
    return bool(_get_used_vcs_backend(link***REMOVED******REMOVED***


def is_file_url(link***REMOVED***:
    return link.url.lower(***REMOVED***.startswith('file:'***REMOVED***


def is_dir_url(link***REMOVED***:
    ***REMOVED***Return whether a file:// Link points to a directory.

    ``link`` must not have any other scheme but file://. Call is_file_url(***REMOVED***
    first.

    ***REMOVED***
    link_path = url_to_path(link.url_without_fragment***REMOVED***
    return os.path.isdir(link_path***REMOVED***


def _progress_indicator(iterable, *args, **kwargs***REMOVED***:
    return iterable


def _download_url(resp, link, content_file, hashes***REMOVED***:
    ***REMOVED***
        total_length = int(resp.headers['content-length'***REMOVED******REMOVED***
    except (ValueError, KeyError, TypeError***REMOVED***:
        total_length = 0

    cached_resp = getattr(resp, "from_cache", False***REMOVED***

    if logger.getEffectiveLevel(***REMOVED*** > logging.INFO:
        show_progress = False
    elif cached_resp:
        show_progress = False
    elif total_length > (40 * 1000***REMOVED***:
        show_progress = True
    elif not total_length:
        show_progress = True
    else:
        show_progress = False

    show_url = link.show_url

    def resp_read(chunk_size***REMOVED***:
        ***REMOVED***
            # Special case for urllib3.
            for chunk in resp.raw.stream(
                    chunk_size,
                    # We use decode_content=False here because we don't
                    # want urllib3 to mess with the raw bytes we get
                    # from the server. If we decompress inside of
                    # urllib3 then we cannot verify the checksum
                    # because the checksum will be of the compressed
                    # file. This breakage will only occur if the
                    # server adds a Content-Encoding header, which
                    # depends on how the server was configured:
                    # - Some servers will notice that the file isn't a
                    #   compressible file and will leave the file alone
                    #   and with an empty Content-Encoding
                    # - Some servers will notice that the file is
                    #   already compressed and will leave the file
                    #   alone and will add a Content-Encoding: gzip
                    #   header
                    # - Some servers won't notice anything at all and
                    #   will take a file that's already been compressed
                    #   and compress it again and set the
                    #   Content-Encoding: gzip header
                    #
                    # By setting this not to decode automatically we
                    # hope to eliminate problems with the second case.
                    decode_content=False***REMOVED***:
                yield chunk
        except AttributeError:
            # Standard file-like object.
            while True:
                chunk = resp.raw.read(chunk_size***REMOVED***
                if not chunk:
                    break
                yield chunk

    def written_chunks(chunks***REMOVED***:
        for chunk in chunks:
            content_file.write(chunk***REMOVED***
            yield chunk

    progress_indicator = _progress_indicator

    if link.netloc == PyPI.netloc:
        url = show_url
    else:
        url = link.url_without_fragment

    if show_progress:  # We don't show progress on cached responses
        if total_length:
            logger.info("Downloading %s (%s***REMOVED***", url, format_size(total_length***REMOVED******REMOVED***
            progress_indicator = DownloadProgressBar(max=total_length***REMOVED***.iter
        else:
            logger.info("Downloading %s", url***REMOVED***
            progress_indicator = DownloadProgressSpinner(***REMOVED***.iter
    elif cached_resp:
        logger.info("Using cached %s", url***REMOVED***
    else:
        logger.info("Downloading %s", url***REMOVED***

    logger.debug('Downloading from URL %s', link***REMOVED***

    downloaded_chunks = written_chunks(
        progress_indicator(
            resp_read(CONTENT_CHUNK_SIZE***REMOVED***,
            CONTENT_CHUNK_SIZE
        ***REMOVED***
    ***REMOVED***
    if hashes:
        hashes.check_against_chunks(downloaded_chunks***REMOVED***
    else:
        consume(downloaded_chunks***REMOVED***


def _copy_file(filename, location, link***REMOVED***:
    copy = True
    download_location = os.path.join(location, link.filename***REMOVED***
    if os.path.exists(download_location***REMOVED***:
        response = ask_path_exists(
            'The file %s exists. (i***REMOVED***gnore, (w***REMOVED***ipe, (b***REMOVED***ackup ' %
            display_path(download_location***REMOVED***, ('i', 'w', 'b'***REMOVED******REMOVED***
        if response == 'i':
            copy = False
        elif response == 'w':
            logger.warning('Deleting %s', display_path(download_location***REMOVED******REMOVED***
            os.remove(download_location***REMOVED***
        elif response == 'b':
            dest_file = backup_dir(download_location***REMOVED***
            logger.warning(
                'Backing up %s to %s',
                display_path(download_location***REMOVED***,
                display_path(dest_file***REMOVED***,
            ***REMOVED***
            shutil.move(download_location, dest_file***REMOVED***
    if copy:
        shutil.copy(filename, download_location***REMOVED***
        logger.info('Saved %s', display_path(download_location***REMOVED******REMOVED***


def unpack_http_url(link, location, download_dir=None,
                    session=None, hashes=None***REMOVED***:
    if session is None:
        raise TypeError(
            "unpack_http_url(***REMOVED*** missing 1 required keyword argument: 'session'"
        ***REMOVED***

    temp_dir = tempfile.mkdtemp('-unpack', 'pip-'***REMOVED***

    # If a download dir is specified, is the file already downloaded there?
    already_downloaded_path = None
    if download_dir:
        already_downloaded_path = _check_download_dir(link,
                                                      download_dir,
                                                      hashes***REMOVED***

    if already_downloaded_path:
        from_path = already_downloaded_path
        content_type = mimetypes.guess_type(from_path***REMOVED***[0***REMOVED***
    else:
        # let's download to a tmp dir
        from_path, content_type = _download_http_url(link,
                                                     session,
                                                     temp_dir,
                                                     hashes***REMOVED***

    # unpack the archive to the build dir location. even when only downloading
    # archives, they have to be unpacked to parse dependencies
    unpack_file(from_path, location, content_type, link***REMOVED***

    # a download dir is specified; let's copy the archive there
    if download_dir and not already_downloaded_path:
        _copy_file(from_path, download_dir, link***REMOVED***

    if not already_downloaded_path:
        os.unlink(from_path***REMOVED***
    rmtree(temp_dir***REMOVED***


def unpack_file_url(link, location, download_dir=None, hashes=None***REMOVED***:
    ***REMOVED***Unpack link into location.

    If download_dir is provided and link points to a file, make a copy
    of the link file inside download_dir.
    ***REMOVED***
    link_path = url_to_path(link.url_without_fragment***REMOVED***

    # If it's a url to a local directory
    if is_dir_url(link***REMOVED***:
        if os.path.isdir(location***REMOVED***:
            rmtree(location***REMOVED***
        shutil.copytree(link_path, location, symlinks=True***REMOVED***
        if download_dir:
            logger.info('Link is a directory, ignoring download_dir'***REMOVED***
        return

    # If --require-hashes is off, `hashes` is either empty, the
    # link's embeddded hash, or MissingHashes; it is required to
    # match. If --require-hashes is on, we are satisfied by any
    # hash in `hashes` matching: a URL-based or an option-based
    # one; no internet-sourced hash will be in `hashes`.
    if hashes:
        hashes.check_against_path(link_path***REMOVED***

    # If a download dir is specified, is the file already there and valid?
    already_downloaded_path = None
    if download_dir:
        already_downloaded_path = _check_download_dir(link,
                                                      download_dir,
                                                      hashes***REMOVED***

    if already_downloaded_path:
        from_path = already_downloaded_path
    else:
        from_path = link_path

    content_type = mimetypes.guess_type(from_path***REMOVED***[0***REMOVED***

    # unpack the archive to the build dir location. even when only downloading
    # archives, they have to be unpacked to parse dependencies
    unpack_file(from_path, location, content_type, link***REMOVED***

    # a download dir is specified and not already downloaded
    if download_dir and not already_downloaded_path:
        _copy_file(from_path, download_dir, link***REMOVED***


def _copy_dist_from_dir(link_path, location***REMOVED***:
    ***REMOVED***Copy distribution files in `link_path` to `location`.

    Invoked when user requests to install a local directory. E.g.:

        pip install .
        pip install ~/dev/git-repos/python-prompt-toolkit

    ***REMOVED***

    # Note: This is currently VERY SLOW if you have a lot of data in the
    # directory, because it copies everything with `shutil.copytree`.
    # What it should really do is build an sdist and install that.
    # See https://github.com/pypa/pip/issues/2195

    if os.path.isdir(location***REMOVED***:
        rmtree(location***REMOVED***

    # build an sdist
    setup_py = 'setup.py'
    sdist_args = [sys.executable***REMOVED***
    sdist_args.append('-c'***REMOVED***
    sdist_args.append(SETUPTOOLS_SHIM % setup_py***REMOVED***
    sdist_args.append('sdist'***REMOVED***
    sdist_args += ['--dist-dir', location***REMOVED***
    logger.info('Running setup.py sdist for %s', link_path***REMOVED***

    with indent_log(***REMOVED***:
        call_subprocess(sdist_args, cwd=link_path, show_stdout=False***REMOVED***

    # unpack sdist into `location`
    sdist = os.path.join(location, os.listdir(location***REMOVED***[0***REMOVED******REMOVED***
    logger.info('Unpacking sdist %s into %s', sdist, location***REMOVED***
    unpack_file(sdist, location, content_type=None, link=None***REMOVED***


class PipXmlrpcTransport(xmlrpc_client.Transport***REMOVED***:
    ***REMOVED***Provide a `xmlrpclib.Transport` implementation via a `PipSession`
    object.
    ***REMOVED***
    def __init__(self, index_url, session, use_datetime=False***REMOVED***:
        xmlrpc_client.Transport.__init__(self, use_datetime***REMOVED***
        index_parts = urllib_parse.urlparse(index_url***REMOVED***
        self._scheme = index_parts.scheme
        self._session = session

    def request(self, host, handler, request_body, verbose=False***REMOVED***:
        parts = (self._scheme, host, handler, None, None, None***REMOVED***
        url = urllib_parse.urlunparse(parts***REMOVED***
        ***REMOVED***
            headers = {'Content-Type': 'text/xml'***REMOVED***
            response = self._session.post(url, data=request_body,
                                          headers=headers, stream=True***REMOVED***
            response.raise_for_status(***REMOVED***
            self.verbose = verbose
            return self.parse_response(response.raw***REMOVED***
        except requests.HTTPError as exc:
            logger.critical(
                "HTTP error %s while getting %s",
                exc.response.status_code, url,
            ***REMOVED***
            raise


def unpack_url(link, location, download_dir=None,
               only_download=False, session=None, hashes=None***REMOVED***:
    ***REMOVED***Unpack link.
       If link is a VCS link:
         if only_download, export into download_dir and ignore location
          else unpack into location
       for other types of link:
         - unpack into location
         - if download_dir, copy the file into download_dir
         - if only_download, mark location for deletion

    :param hashes: A Hashes object, one of whose embedded hashes must match,
        or HashMismatch will be raised. If the Hashes is empty, no matches are
        required, and unhashable types of requirements (like VCS ones, which
        would ordinarily raise HashUnsupported***REMOVED*** are allowed.
    ***REMOVED***
    # non-editable vcs urls
    if is_vcs_url(link***REMOVED***:
        unpack_vcs_link(link, location***REMOVED***

    # file urls
    elif is_file_url(link***REMOVED***:
        unpack_file_url(link, location, download_dir, hashes=hashes***REMOVED***

    # http urls
    else:
        if session is None:
            session = PipSession(***REMOVED***

        unpack_http_url(
            link,
            location,
            download_dir,
            session,
            hashes=hashes
        ***REMOVED***
    if only_download:
        write_delete_marker_file(location***REMOVED***


def _download_http_url(link, session, temp_dir, hashes***REMOVED***:
    ***REMOVED***Download link url into temp_dir using provided session***REMOVED***
    target_url = link.url.split('#', 1***REMOVED***[0***REMOVED***
    ***REMOVED***
        resp = session.get(
            target_url,
            # We use Accept-Encoding: identity here because requests
            # defaults to accepting compressed responses. This breaks in
            # a variety of ways depending on how the server is configured.
            # - Some servers will notice that the file isn't a compressible
            #   file and will leave the file alone and with an empty
            #   Content-Encoding
            # - Some servers will notice that the file is already
            #   compressed and will leave the file alone and will add a
            #   Content-Encoding: gzip header
            # - Some servers won't notice anything at all and will take
            #   a file that's already been compressed and compress it again
            #   and set the Content-Encoding: gzip header
            # By setting this to request only the identity encoding We're
            # hoping to eliminate the third case. Hopefully there does not
            # exist a server which when given a file will notice it is
            # already compressed and that you're not asking for a
            # compressed file and will then decompress it before sending
            # because if that's the case I don't think it'll ever be
            # possible to make this work.
            headers={"Accept-Encoding": "identity"***REMOVED***,
            stream=True,
        ***REMOVED***
        resp.raise_for_status(***REMOVED***
    except requests.HTTPError as exc:
        logger.critical(
            "HTTP error %s while getting %s", exc.response.status_code, link,
        ***REMOVED***
        raise

    content_type = resp.headers.get('content-type', ''***REMOVED***
    filename = link.filename  # fallback
    # Have a look at the Content-Disposition header for a better guess
    content_disposition = resp.headers.get('content-disposition'***REMOVED***
    if content_disposition:
        type, params = cgi.parse_header(content_disposition***REMOVED***
        # We use ``or`` here because we don't want to use an "empty" value
        # from the filename param.
        filename = params.get('filename'***REMOVED*** or filename
    ext = splitext(filename***REMOVED***[1***REMOVED***
    if not ext:
        ext = mimetypes.guess_extension(content_type***REMOVED***
        if ext:
            filename += ext
    if not ext and link.url != resp.url:
        ext = os.path.splitext(resp.url***REMOVED***[1***REMOVED***
        if ext:
            filename += ext
    file_path = os.path.join(temp_dir, filename***REMOVED***
    with open(file_path, 'wb'***REMOVED*** as content_file:
        _download_url(resp, link, content_file, hashes***REMOVED***
    return file_path, content_type


def _check_download_dir(link, download_dir, hashes***REMOVED***:
    ***REMOVED*** Check download_dir for previously downloaded file with correct hash
        If a correct file is found return its path else None
    ***REMOVED***
    download_path = os.path.join(download_dir, link.filename***REMOVED***
    if os.path.exists(download_path***REMOVED***:
        # If already downloaded, does its hash match?
        logger.info('File was already downloaded %s', download_path***REMOVED***
        if hashes:
            ***REMOVED***
                hashes.check_against_path(download_path***REMOVED***
            except HashMismatch:
                logger.warning(
                    'Previously-downloaded file %s has bad hash. '
                    'Re-downloading.',
                    download_path
                ***REMOVED***
                os.unlink(download_path***REMOVED***
                return None
        return download_path
    return None
