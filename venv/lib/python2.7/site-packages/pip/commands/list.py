from __future__ import absolute_import

import logging
import warnings

from pip.basecommand import Command
from pip.exceptions import CommandError
from pip.index import PackageFinder
from pip.utils import (
    get_installed_distributions, dist_is_editable***REMOVED***
from pip.utils.deprecation import RemovedInPip10Warning
from pip.cmdoptions import make_option_group, index_group


logger = logging.getLogger(__name__***REMOVED***


class ListCommand(Command***REMOVED***:
    ***REMOVED***
    List installed packages, including editables.

    Packages are listed in a case-insensitive sorted order.
    ***REMOVED***
    name = 'list'
    usage = ***REMOVED***
      %prog [options***REMOVED******REMOVED***
    summary = 'List installed packages.'

    def __init__(self, *args, **kw***REMOVED***:
        super(ListCommand, self***REMOVED***.__init__(*args, **kw***REMOVED***

        cmd_opts = self.cmd_opts

        cmd_opts.add_option(
            '-o', '--outdated',
            action='store_true',
            default=False,
            help='List outdated packages'***REMOVED***
        cmd_opts.add_option(
            '-u', '--uptodate',
            action='store_true',
            default=False,
            help='List uptodate packages'***REMOVED***
        cmd_opts.add_option(
            '-e', '--editable',
            action='store_true',
            default=False,
            help='List editable projects.'***REMOVED***
        cmd_opts.add_option(
            '-l', '--local',
            action='store_true',
            default=False,
            help=('If in a virtualenv that has global access, do not list '
                  'globally-installed packages.'***REMOVED***,
        ***REMOVED***
        self.cmd_opts.add_option(
            '--user',
            dest='user',
            action='store_true',
            default=False,
            help='Only output packages installed in user-site.'***REMOVED***

        cmd_opts.add_option(
            '--pre',
            action='store_true',
            default=False,
            help=("Include pre-release and development versions. By default, "
                  "pip only finds stable versions."***REMOVED***,
        ***REMOVED***

        index_opts = make_option_group(index_group, self.parser***REMOVED***

        self.parser.insert_option_group(0, index_opts***REMOVED***
        self.parser.insert_option_group(0, cmd_opts***REMOVED***

    def _build_package_finder(self, options, index_urls, session***REMOVED***:
        ***REMOVED***
        Create a package finder appropriate to this list command.
        ***REMOVED***
        return PackageFinder(
            find_links=options.find_links,
            index_urls=index_urls,
            allow_all_prereleases=options.pre,
            trusted_hosts=options.trusted_hosts,
            process_dependency_links=options.process_dependency_links,
            session=session,
        ***REMOVED***

    def run(self, options, args***REMOVED***:
        if options.allow_external:
            warnings.warn(
                "--allow-external has been deprecated and will be removed in "
                "the future. Due to changes in the repository protocol, it no "
                "longer has any effect.",
                RemovedInPip10Warning,
            ***REMOVED***

        if options.allow_all_external:
            warnings.warn(
                "--allow-all-external has been deprecated and will be removed "
                "in the future. Due to changes in the repository protocol, it "
                "no longer has any effect.",
                RemovedInPip10Warning,
            ***REMOVED***

        if options.allow_unverified:
            warnings.warn(
                "--allow-unverified has been deprecated and will be removed "
                "in the future. Due to changes in the repository protocol, it "
                "no longer has any effect.",
                RemovedInPip10Warning,
            ***REMOVED***
        if options.outdated and options.uptodate:
            raise CommandError(
                "Options --outdated and --uptodate cannot be combined."***REMOVED***

        if options.outdated:
            self.run_outdated(options***REMOVED***
        elif options.uptodate:
            self.run_uptodate(options***REMOVED***
        else:
            self.run_listing(options***REMOVED***

    def run_outdated(self, options***REMOVED***:
        for dist, latest_version, typ in sorted(
                self.find_packages_latest_versions(options***REMOVED***,
                key=lambda p: p[0***REMOVED***.project_name.lower(***REMOVED******REMOVED***:
            if latest_version > dist.parsed_version:
                logger.info(
                    '%s - Latest: %s [%s***REMOVED***',
                    self.output_package(dist***REMOVED***, latest_version, typ,
                ***REMOVED***

    def find_packages_latest_versions(self, options***REMOVED***:
        index_urls = [options.index_url***REMOVED*** + options.extra_index_urls
        if options.no_index:
            logger.info('Ignoring indexes: %s', ','.join(index_urls***REMOVED******REMOVED***
            index_urls = [***REMOVED***

        dependency_links = [***REMOVED***
        for dist in get_installed_distributions(
                local_only=options.local,
                user_only=options.user,
                editables_only=options.editable***REMOVED***:
            if dist.has_metadata('dependency_links.txt'***REMOVED***:
                dependency_links.extend(
                    dist.get_metadata_lines('dependency_links.txt'***REMOVED***,
                ***REMOVED***

        with self._build_session(options***REMOVED*** as session:
            finder = self._build_package_finder(options, index_urls, session***REMOVED***
            finder.add_dependency_links(dependency_links***REMOVED***

            installed_packages = get_installed_distributions(
                local_only=options.local,
                user_only=options.user,
                editables_only=options.editable,
            ***REMOVED***
            for dist in installed_packages:
                typ = 'unknown'
                all_candidates = finder.find_all_candidates(dist.key***REMOVED***
                if not options.pre:
                    # Remove prereleases
                    all_candidates = [candidate for candidate in all_candidates
                                      if not candidate.version.is_prerelease***REMOVED***

                if not all_candidates:
                    continue
                best_candidate = max(all_candidates,
                                     key=finder._candidate_sort_key***REMOVED***
                remote_version = best_candidate.version
                if best_candidate.location.is_wheel:
                    typ = 'wheel'
                else:
                    typ = 'sdist'
                yield dist, remote_version, typ

    def run_listing(self, options***REMOVED***:
        installed_packages = get_installed_distributions(
            local_only=options.local,
            user_only=options.user,
            editables_only=options.editable,
        ***REMOVED***
        self.output_package_listing(installed_packages***REMOVED***

    def output_package(self, dist***REMOVED***:
        if dist_is_editable(dist***REMOVED***:
            return '%s (%s, %s***REMOVED***' % (
                dist.project_name,
                dist.version,
                dist.location,
            ***REMOVED***
        else:
            return '%s (%s***REMOVED***' % (dist.project_name, dist.version***REMOVED***

    def output_package_listing(self, installed_packages***REMOVED***:
        installed_packages = sorted(
            installed_packages,
            key=lambda dist: dist.project_name.lower(***REMOVED***,
        ***REMOVED***
        for dist in installed_packages:
            logger.info(self.output_package(dist***REMOVED******REMOVED***

    def run_uptodate(self, options***REMOVED***:
        uptodate = [***REMOVED***
        for dist, version, typ in self.find_packages_latest_versions(options***REMOVED***:
            if dist.parsed_version == version:
                uptodate.append(dist***REMOVED***
        self.output_package_listing(uptodate***REMOVED***
