from __future__ import absolute_import

import logging
import sys
import textwrap

from pip.basecommand import Command, SUCCESS
from pip.download import PipXmlrpcTransport
from pip.models import PyPI
from pip.utils import get_terminal_size
from pip.utils.logging import indent_log
from pip.exceptions import CommandError
from pip.status_codes import NO_MATCHES_FOUND
from pip._vendor import pkg_resources
from pip._vendor.six.moves import xmlrpc_client


logger = logging.getLogger(__name__***REMOVED***


class SearchCommand(Command***REMOVED***:
    ***REMOVED***Search for PyPI packages whose name or summary contains <query>.***REMOVED***
    name = 'search'
    usage = ***REMOVED***
      %prog [options***REMOVED*** <query>***REMOVED***
    summary = 'Search PyPI for packages.'

    def __init__(self, *args, **kw***REMOVED***:
        super(SearchCommand, self***REMOVED***.__init__(*args, **kw***REMOVED***
        self.cmd_opts.add_option(
            '--index',
            dest='index',
            metavar='URL',
            default=PyPI.pypi_url,
            help='Base URL of Python Package Index (default %default***REMOVED***'***REMOVED***

        self.parser.insert_option_group(0, self.cmd_opts***REMOVED***

    def run(self, options, args***REMOVED***:
        if not args:
            raise CommandError('Missing required argument (search query***REMOVED***.'***REMOVED***
        query = args
        pypi_hits = self.search(query, options***REMOVED***
        hits = transform_hits(pypi_hits***REMOVED***

        terminal_width = None
        if sys.stdout.isatty(***REMOVED***:
            terminal_width = get_terminal_size(***REMOVED***[0***REMOVED***

        print_results(hits, terminal_width=terminal_width***REMOVED***
        if pypi_hits:
            return SUCCESS
        return NO_MATCHES_FOUND

    def search(self, query, options***REMOVED***:
        index_url = options.index
        with self._build_session(options***REMOVED*** as session:
            transport = PipXmlrpcTransport(index_url, session***REMOVED***
            pypi = xmlrpc_client.ServerProxy(index_url, transport***REMOVED***
            hits = pypi.search({'name': query, 'summary': query***REMOVED***, 'or'***REMOVED***
            return hits


def transform_hits(hits***REMOVED***:
    ***REMOVED***
    The list from pypi is really a list of versions. We want a list of
    packages with the list of versions stored inline. This converts the
    list from pypi into one we can use.
    ***REMOVED***
    packages = {***REMOVED***
    for hit in hits:
        name = hit['name'***REMOVED***
        summary = hit['summary'***REMOVED***
        version = hit['version'***REMOVED***
        score = hit['_pypi_ordering'***REMOVED***
        if score is None:
            score = 0

        if name not in packages.keys(***REMOVED***:
            packages[name***REMOVED*** = {
                'name': name,
                'summary': summary,
                'versions': [version***REMOVED***,
                'score': score,
        ***REMOVED***
        else:
            packages[name***REMOVED***['versions'***REMOVED***.append(version***REMOVED***

            # if this is the highest version, replace summary and score
            if version == highest_version(packages[name***REMOVED***['versions'***REMOVED******REMOVED***:
                packages[name***REMOVED***['summary'***REMOVED*** = summary
                packages[name***REMOVED***['score'***REMOVED*** = score

    # each record has a unique name now, so we will convert the dict into a
    # list sorted by score
    package_list = sorted(
        packages.values(***REMOVED***,
        key=lambda x: x['score'***REMOVED***,
        reverse=True,
    ***REMOVED***
    return package_list


def print_results(hits, name_column_width=None, terminal_width=None***REMOVED***:
    if not hits:
        return
    if name_column_width is None:
        name_column_width = max([
            len(hit['name'***REMOVED******REMOVED*** + len(hit.get('versions', ['-'***REMOVED******REMOVED***[-1***REMOVED******REMOVED***
            for hit in hits
        ***REMOVED******REMOVED*** + 4

    installed_packages = [p.project_name for p in pkg_resources.working_set***REMOVED***
    for hit in hits:
        name = hit['name'***REMOVED***
        summary = hit['summary'***REMOVED*** or ''
        version = hit.get('versions', ['-'***REMOVED******REMOVED***[-1***REMOVED***
        if terminal_width is not None:
            target_width = terminal_width - name_column_width - 5
            if target_width > 10:
                # wrap and indent summary to fit terminal
                summary = textwrap.wrap(summary, target_width***REMOVED***
                summary = ('\n' + ' ' * (name_column_width + 3***REMOVED******REMOVED***.join(summary***REMOVED***

        line = '%-*s - %s' % (name_column_width,
                              '%s (%s***REMOVED***' % (name, version***REMOVED***, summary***REMOVED***
        ***REMOVED***
            logger.info(line***REMOVED***
            if name in installed_packages:
                dist = pkg_resources.get_distribution(name***REMOVED***
                with indent_log(***REMOVED***:
                    latest = highest_version(hit['versions'***REMOVED******REMOVED***
                    if dist.version == latest:
                        logger.info('INSTALLED: %s (latest***REMOVED***', dist.version***REMOVED***
                    else:
                        logger.info('INSTALLED: %s', dist.version***REMOVED***
                        logger.info('LATEST:    %s', latest***REMOVED***
        except UnicodeEncodeError:
            pass


def highest_version(versions***REMOVED***:
    return next(iter(
        sorted(versions, key=pkg_resources.parse_version, reverse=True***REMOVED***
    ***REMOVED******REMOVED***
