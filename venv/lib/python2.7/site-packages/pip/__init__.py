#!/usr/bin/env python
from __future__ import absolute_import

import locale
import logging
***REMOVED***
import optparse
import warnings

import sys
import re

from pip.exceptions import InstallationError, CommandError, PipError
from pip.utils import get_installed_distributions, get_prog
from pip.utils import deprecation, dist_is_editable
from pip.vcs import git, mercurial, subversion, bazaar  # noqa
from pip.baseparser import ConfigOptionParser, UpdatingDefaultsHelpFormatter
from pip.commands import get_summaries, get_similar_commands
from pip.commands import commands_dict
from pip._vendor.requests.packages.urllib3.exceptions import (
    InsecureRequestWarning,
***REMOVED***


# assignment for flake8 to be happy

# This fixes a peculiarity when importing via __import__ - as we are
# initialising the pip module, "from pip import cmdoptions" is recursive
# and appears not to work properly in that situation.
import pip.cmdoptions
cmdoptions = pip.cmdoptions

# The version as used in the setup.py and the docs conf.py
__version__ = "8.1.2"


logger = logging.getLogger(__name__***REMOVED***

# Hide the InsecureRequestWArning from urllib3
warnings.filterwarnings("ignore", category=InsecureRequestWarning***REMOVED***


def autocomplete(***REMOVED***:
    ***REMOVED***Command and option completion for the main option parser (and options***REMOVED***
    and its subcommands (and options***REMOVED***.

    Enable by sourcing one of the completion shell scripts (bash or zsh***REMOVED***.
    ***REMOVED***
    # Don't complete if user hasn't sourced bash_completion file.
    if 'PIP_AUTO_COMPLETE' not in os.environ:
        return
    cwords = os.environ['COMP_WORDS'***REMOVED***.split(***REMOVED***[1:***REMOVED***
    cword = int(os.environ['COMP_CWORD'***REMOVED******REMOVED***
    ***REMOVED***
        current = cwords[cword - 1***REMOVED***
    except IndexError:
        current = ''

    subcommands = [cmd for cmd, summary in get_summaries(***REMOVED******REMOVED***
    options = [***REMOVED***
    # subcommand
    ***REMOVED***
        subcommand_name = [w for w in cwords if w in subcommands***REMOVED***[0***REMOVED***
    except IndexError:
        subcommand_name = None

    parser = create_main_parser(***REMOVED***
    # subcommand options
    if subcommand_name:
        # special case: 'help' subcommand has no options
        if subcommand_name == 'help':
            sys.exit(1***REMOVED***
        # special case: list locally installed dists for uninstall command
        if subcommand_name == 'uninstall' and not current.startswith('-'***REMOVED***:
            installed = [***REMOVED***
            lc = current.lower(***REMOVED***
            for dist in get_installed_distributions(local_only=True***REMOVED***:
                if dist.key.startswith(lc***REMOVED*** and dist.key not in cwords[1:***REMOVED***:
                    installed.append(dist.key***REMOVED***
            # if there are no dists installed, fall back to option completion
            if installed:
                for dist in installed:
                    print(dist***REMOVED***
                sys.exit(1***REMOVED***

        subcommand = commands_dict[subcommand_name***REMOVED***(***REMOVED***
        options += [(opt.get_opt_string(***REMOVED***, opt.nargs***REMOVED***
                    for opt in subcommand.parser.option_list_all
                    if opt.help != optparse.SUPPRESS_HELP***REMOVED***

        # filter out previously specified options from available options
        prev_opts = [x.split('='***REMOVED***[0***REMOVED*** for x in cwords[1:cword - 1***REMOVED******REMOVED***
        options = [(x, v***REMOVED*** for (x, v***REMOVED*** in options if x not in prev_opts***REMOVED***
        # filter options by current input
        options = [(k, v***REMOVED*** for k, v in options if k.startswith(current***REMOVED******REMOVED***
        for option in options:
            opt_label = option[0***REMOVED***
            # append '=' to options which require args
            if option[1***REMOVED***:
                opt_label += '='
            print(opt_label***REMOVED***
    else:
        # show main parser options only when necessary
        if current.startswith('-'***REMOVED*** or current.startswith('--'***REMOVED***:
            opts = [i.option_list for i in parser.option_groups***REMOVED***
            opts.append(parser.option_list***REMOVED***
            opts = (o for it in opts for o in it***REMOVED***

            subcommands += [i.get_opt_string(***REMOVED*** for i in opts
                            if i.help != optparse.SUPPRESS_HELP***REMOVED***

        print(' '.join([x for x in subcommands if x.startswith(current***REMOVED******REMOVED******REMOVED******REMOVED***
    sys.exit(1***REMOVED***


def create_main_parser(***REMOVED***:
    parser_kw = {
        'usage': '\n%prog <command> [options***REMOVED***',
        'add_help_option': False,
        'formatter': UpdatingDefaultsHelpFormatter(***REMOVED***,
        'name': 'global',
        'prog': get_prog(***REMOVED***,
***REMOVED***

    parser = ConfigOptionParser(**parser_kw***REMOVED***
    parser.disable_interspersed_args(***REMOVED***

    pip_pkg_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__***REMOVED******REMOVED******REMOVED***
    parser.version = 'pip %s from %s (python %s***REMOVED***' % (
        __version__, pip_pkg_dir, sys.version[:3***REMOVED******REMOVED***

    # add the general options
    gen_opts = cmdoptions.make_option_group(cmdoptions.general_group, parser***REMOVED***
    parser.add_option_group(gen_opts***REMOVED***

    parser.main = True  # so the help formatter knows

    # create command listing for description
    command_summaries = get_summaries(***REMOVED***
    description = [''***REMOVED*** + ['%-27s %s' % (i, j***REMOVED*** for i, j in command_summaries***REMOVED***
    parser.description = '\n'.join(description***REMOVED***

    return parser


def parseopts(args***REMOVED***:
    parser = create_main_parser(***REMOVED***

    # Note: parser calls disable_interspersed_args(***REMOVED***, so the result of this
    # call is to split the initial args into the general options before the
    # subcommand and everything else.
    # For example:
    #  args: ['--timeout=5', 'install', '--user', 'INITools'***REMOVED***
    #  general_options: ['--timeout==5'***REMOVED***
    #  args_else: ['install', '--user', 'INITools'***REMOVED***
    general_options, args_else = parser.parse_args(args***REMOVED***

    # --version
    if general_options.version:
        sys.stdout.write(parser.version***REMOVED***
        sys.stdout.write(os.linesep***REMOVED***
        sys.exit(***REMOVED***

    # pip || pip help -> print_help(***REMOVED***
    if not args_else or (args_else[0***REMOVED*** == 'help' and len(args_else***REMOVED*** == 1***REMOVED***:
        parser.print_help(***REMOVED***
        sys.exit(***REMOVED***

    # the subcommand name
    cmd_name = args_else[0***REMOVED***

    if cmd_name not in commands_dict:
        guess = get_similar_commands(cmd_name***REMOVED***

        msg = ['unknown command "%s"' % cmd_name***REMOVED***
        if guess:
            msg.append('maybe you meant "%s"' % guess***REMOVED***

        raise CommandError(' - '.join(msg***REMOVED******REMOVED***

    # all the args without the subcommand
    cmd_args = args[:***REMOVED***
    cmd_args.remove(cmd_name***REMOVED***

    return cmd_name, cmd_args


def check_isolated(args***REMOVED***:
    isolated = False

    if "--isolated" in args:
        isolated = True

    return isolated


def main(args=None***REMOVED***:
    if args is None:
        args = sys.argv[1:***REMOVED***

    # Configure our deprecation warnings to be sent through loggers
    deprecation.install_warning_logger(***REMOVED***

    autocomplete(***REMOVED***

    ***REMOVED***
        cmd_name, cmd_args = parseopts(args***REMOVED***
    except PipError as exc:
        sys.stderr.write("ERROR: %s" % exc***REMOVED***
        sys.stderr.write(os.linesep***REMOVED***
        sys.exit(1***REMOVED***

    # Needed for locale.getpreferredencoding(False***REMOVED*** to work
    # in pip.utils.encoding.auto_decode
    ***REMOVED***
        locale.setlocale(locale.LC_ALL, ''***REMOVED***
    except locale.Error as e:
        # setlocale can apparently crash if locale are uninitialized
        logger.debug("Ignoring error %s when setting locale", e***REMOVED***
    command = commands_dict[cmd_name***REMOVED***(isolated=check_isolated(cmd_args***REMOVED******REMOVED***
    return command.main(cmd_args***REMOVED***


# ###########################################################
# # Writing freeze files

class FrozenRequirement(object***REMOVED***:

    def __init__(self, name, req, editable, comments=(***REMOVED******REMOVED***:
        self.name = name
        self.req = req
        self.editable = editable
        self.comments = comments

    _rev_re = re.compile(r'-r(\d+***REMOVED***$'***REMOVED***
    _date_re = re.compile(r'-(20\d\d\d\d\d\d***REMOVED***$'***REMOVED***

    @classmethod
    def from_dist(cls, dist, dependency_links***REMOVED***:
        location = os.path.normcase(os.path.abspath(dist.location***REMOVED******REMOVED***
        comments = [***REMOVED***
        from pip.vcs import vcs, get_src_requirement
        if dist_is_editable(dist***REMOVED*** and vcs.get_backend_name(location***REMOVED***:
            editable = True
            ***REMOVED***
                req = get_src_requirement(dist, location***REMOVED***
            except InstallationError as exc:
                logger.warning(
                    "Error when trying to get requirement for VCS system %s, "
                    "falling back to uneditable format", exc
                ***REMOVED***
                req = None
            if req is None:
                logger.warning(
                    'Could not determine repository location of %s', location
                ***REMOVED***
                comments.append(
                    '## !! Could not determine repository location'
                ***REMOVED***
                req = dist.as_requirement(***REMOVED***
                editable = False
        else:
            editable = False
            req = dist.as_requirement(***REMOVED***
            specs = req.specs
            assert len(specs***REMOVED*** == 1 and specs[0***REMOVED***[0***REMOVED*** in ["==", "==="***REMOVED***, \
                'Expected 1 spec with == or ===; specs = %r; dist = %r' % \
                (specs, dist***REMOVED***
            version = specs[0***REMOVED***[1***REMOVED***
            ver_match = cls._rev_re.search(version***REMOVED***
            date_match = cls._date_re.search(version***REMOVED***
            if ver_match or date_match:
                svn_backend = vcs.get_backend('svn'***REMOVED***
                if svn_backend:
                    svn_location = svn_backend(***REMOVED***.get_location(
                        dist,
                        dependency_links,
                    ***REMOVED***
                if not svn_location:
                    logger.warning(
                        'Warning: cannot find svn location for %s', req***REMOVED***
                    comments.append(
                        '## FIXME: could not find svn URL in dependency_links '
                        'for this package:'
                    ***REMOVED***
                else:
                    comments.append(
                        '# Installing as editable to satisfy requirement %s:' %
                        req
                    ***REMOVED***
                    if ver_match:
                        rev = ver_match.group(1***REMOVED***
                    else:
                        rev = '{%s***REMOVED***' % date_match.group(1***REMOVED***
                    editable = True
                    req = '%s@%s#egg=%s' % (
                        svn_location,
                        rev,
                        cls.egg_name(dist***REMOVED***
                    ***REMOVED***
        return cls(dist.project_name, req, editable, comments***REMOVED***

    @staticmethod
    def egg_name(dist***REMOVED***:
        name = dist.egg_name(***REMOVED***
        match = re.search(r'-py\d\.\d$', name***REMOVED***
        if match:
            name = name[:match.start(***REMOVED******REMOVED***
        return name

    def __str__(self***REMOVED***:
        req = self.req
        if self.editable:
            req = '-e %s' % req
        return '\n'.join(list(self.comments***REMOVED*** + [str(req***REMOVED******REMOVED******REMOVED*** + '\n'


if __name__ == '__main__':
    sys.exit(main(***REMOVED******REMOVED***
