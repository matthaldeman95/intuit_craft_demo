***REMOVED***Base option parser setup***REMOVED***
from __future__ import absolute_import

import sys
import optparse
***REMOVED***
import re
import textwrap
from distutils.util import strtobool

from pip._vendor.six import string_types
from pip._vendor.six.moves import configparser
from pip.locations import (
    legacy_config_file, config_basename, running_under_virtualenv,
    site_config_files
***REMOVED***
from pip.utils import appdirs, get_terminal_size


_environ_prefix_re = re.compile(r"^PIP_", re.I***REMOVED***


class PrettyHelpFormatter(optparse.IndentedHelpFormatter***REMOVED***:
    ***REMOVED***A prettier/less verbose help formatter for optparse.***REMOVED***

    def __init__(self, *args, **kwargs***REMOVED***:
        # help position must be aligned with __init__.parseopts.description
        kwargs['max_help_position'***REMOVED*** = 30
        kwargs['indent_increment'***REMOVED*** = 1
        kwargs['width'***REMOVED*** = get_terminal_size(***REMOVED***[0***REMOVED*** - 2
        optparse.IndentedHelpFormatter.__init__(self, *args, **kwargs***REMOVED***

    def format_option_strings(self, option***REMOVED***:
        return self._format_option_strings(option, ' <%s>', ', '***REMOVED***

    def _format_option_strings(self, option, mvarfmt=' <%s>', optsep=', '***REMOVED***:
        ***REMOVED***
        Return a comma-separated list of option strings and metavars.

        :param option:  tuple of (short opt, long opt***REMOVED***, e.g: ('-f', '--format'***REMOVED***
        :param mvarfmt: metavar format string - evaluated as mvarfmt % metavar
        :param optsep:  separator
        ***REMOVED***
        opts = [***REMOVED***

        if option._short_opts:
            opts.append(option._short_opts[0***REMOVED******REMOVED***
        if option._long_opts:
            opts.append(option._long_opts[0***REMOVED******REMOVED***
        if len(opts***REMOVED*** > 1:
            opts.insert(1, optsep***REMOVED***

        if option.takes_value(***REMOVED***:
            metavar = option.metavar or option.dest.lower(***REMOVED***
            opts.append(mvarfmt % metavar.lower(***REMOVED******REMOVED***

        return ''.join(opts***REMOVED***

    def format_heading(self, heading***REMOVED***:
        if heading == 'Options':
            return ''
        return heading + ':\n'

    def format_usage(self, usage***REMOVED***:
        ***REMOVED***
        Ensure there is only one newline between usage and the first heading
        if there is no description.
        ***REMOVED***
        msg = '\nUsage: %s\n' % self.indent_lines(textwrap.dedent(usage***REMOVED***, "  "***REMOVED***
        return msg

    def format_description(self, description***REMOVED***:
        # leave full control over description to us
        if description:
            if hasattr(self.parser, 'main'***REMOVED***:
                label = 'Commands'
            else:
                label = 'Description'
            # some doc strings have initial newlines, some don't
            description = description.lstrip('\n'***REMOVED***
            # some doc strings have final newlines and spaces, some don't
            description = description.rstrip(***REMOVED***
            # dedent, then reindent
            description = self.indent_lines(textwrap.dedent(description***REMOVED***, "  "***REMOVED***
            description = '%s:\n%s\n' % (label, description***REMOVED***
            return description
        else:
            return ''

    def format_epilog(self, epilog***REMOVED***:
        # leave full control over epilog to us
        if epilog:
            return epilog
        else:
            return ''

    def indent_lines(self, text, indent***REMOVED***:
        new_lines = [indent + line for line in text.split('\n'***REMOVED******REMOVED***
        return "\n".join(new_lines***REMOVED***


class UpdatingDefaultsHelpFormatter(PrettyHelpFormatter***REMOVED***:
    ***REMOVED***Custom help formatter for use in ConfigOptionParser.

    This is updates the defaults before expanding them, allowing
    them to show up correctly in the help listing.
    ***REMOVED***

    def expand_default(self, option***REMOVED***:
        if self.parser is not None:
            self.parser._update_defaults(self.parser.defaults***REMOVED***
        return optparse.IndentedHelpFormatter.expand_default(self, option***REMOVED***


class CustomOptionParser(optparse.OptionParser***REMOVED***:
    def insert_option_group(self, idx, *args, **kwargs***REMOVED***:
        ***REMOVED***Insert an OptionGroup at a given position.***REMOVED***
        group = self.add_option_group(*args, **kwargs***REMOVED***

        self.option_groups.pop(***REMOVED***
        self.option_groups.insert(idx, group***REMOVED***

        return group

    @property
    def option_list_all(self***REMOVED***:
        ***REMOVED***Get a list of all options, including those in option groups.***REMOVED***
        res = self.option_list[:***REMOVED***
        for i in self.option_groups:
            res.extend(i.option_list***REMOVED***

        return res


class ConfigOptionParser(CustomOptionParser***REMOVED***:
    ***REMOVED***Custom option parser which updates its defaults by checking the
    configuration files and environmental variables***REMOVED***

    isolated = False

    def __init__(self, *args, **kwargs***REMOVED***:
        self.config = configparser.RawConfigParser(***REMOVED***
        self.name = kwargs.pop('name'***REMOVED***
        self.isolated = kwargs.pop("isolated", False***REMOVED***
        self.files = self.get_config_files(***REMOVED***
        if self.files:
            self.config.read(self.files***REMOVED***
        assert self.name
        optparse.OptionParser.__init__(self, *args, **kwargs***REMOVED***

    def get_config_files(self***REMOVED***:
        # the files returned by this method will be parsed in order with the
        # first files listed being overridden by later files in standard
        # ConfigParser fashion
        config_file = os.environ.get('PIP_CONFIG_FILE', False***REMOVED***
        if config_file == os.devnull:
            return [***REMOVED***

        # at the base we have any site-wide configuration
        files = list(site_config_files***REMOVED***

        # per-user configuration next
        if not self.isolated:
            if config_file and os.path.exists(config_file***REMOVED***:
                files.append(config_file***REMOVED***
            else:
                # This is the legacy config file, we consider it to be a lower
                # priority than the new file location.
                files.append(legacy_config_file***REMOVED***

                # This is the new config file, we consider it to be a higher
                # priority than the legacy file.
                files.append(
                    os.path.join(
                        appdirs.user_config_dir("pip"***REMOVED***,
                        config_basename,
                    ***REMOVED***
                ***REMOVED***

        # finally virtualenv configuration first trumping others
        if running_under_virtualenv(***REMOVED***:
            venv_config_file = os.path.join(
                sys.prefix,
                config_basename,
            ***REMOVED***
            if os.path.exists(venv_config_file***REMOVED***:
                files.append(venv_config_file***REMOVED***

        return files

    def check_default(self, option, key, val***REMOVED***:
        ***REMOVED***
            return option.check_value(key, val***REMOVED***
        except optparse.OptionValueError as exc:
            print("An error occurred during configuration: %s" % exc***REMOVED***
            sys.exit(3***REMOVED***

    def _update_defaults(self, defaults***REMOVED***:
        ***REMOVED***Updates the given defaults with values from the config files and
        the environ. Does a little special handling for certain types of
        options (lists***REMOVED***.***REMOVED***
        # Then go and look for the other sources of configuration:
        config = {***REMOVED***
        # 1. config files
        for section in ('global', self.name***REMOVED***:
            config.update(
                self.normalize_keys(self.get_config_section(section***REMOVED******REMOVED***
            ***REMOVED***
        # 2. environmental variables
        if not self.isolated:
            config.update(self.normalize_keys(self.get_environ_vars(***REMOVED******REMOVED******REMOVED***
        # Accumulate complex default state.
        self.values = optparse.Values(self.defaults***REMOVED***
        late_eval = set(***REMOVED***
        # Then set the options with those values
        for key, val in config.items(***REMOVED***:
            # ignore empty values
            if not val:
                continue

            option = self.get_option(key***REMOVED***
            # Ignore options not present in this parser. E.g. non-globals put
            # in [global***REMOVED*** by users that want them to apply to all applicable
            # commands.
            if option is None:
                continue

            if option.action in ('store_true', 'store_false', 'count'***REMOVED***:
                val = strtobool(val***REMOVED***
            elif option.action == 'append':
                val = val.split(***REMOVED***
                val = [self.check_default(option, key, v***REMOVED*** for v in val***REMOVED***
            elif option.action == 'callback':
                late_eval.add(option.dest***REMOVED***
                opt_str = option.get_opt_string(***REMOVED***
                val = option.convert_value(opt_str, val***REMOVED***
                # From take_action
                args = option.callback_args or (***REMOVED***
                kwargs = option.callback_kwargs or {***REMOVED***
                option.callback(option, opt_str, val, self, *args, **kwargs***REMOVED***
            else:
                val = self.check_default(option, key, val***REMOVED***

            defaults[option.dest***REMOVED*** = val

        for key in late_eval:
            defaults[key***REMOVED*** = getattr(self.values, key***REMOVED***
        self.values = None
        return defaults

    def normalize_keys(self, items***REMOVED***:
        ***REMOVED***Return a config dictionary with normalized keys regardless of
        whether the keys were specified in environment variables or in config
        files***REMOVED***
        normalized = {***REMOVED***
        for key, val in items:
            key = key.replace('_', '-'***REMOVED***
            if not key.startswith('--'***REMOVED***:
                key = '--%s' % key  # only prefer long opts
            normalized[key***REMOVED*** = val
        return normalized

    def get_config_section(self, name***REMOVED***:
        ***REMOVED***Get a section of a configuration***REMOVED***
        if self.config.has_section(name***REMOVED***:
            return self.config.items(name***REMOVED***
        return [***REMOVED***

    def get_environ_vars(self***REMOVED***:
        ***REMOVED***Returns a generator with all environmental vars with prefix PIP_***REMOVED***
        for key, val in os.environ.items(***REMOVED***:
            if _environ_prefix_re.search(key***REMOVED***:
                yield (_environ_prefix_re.sub("", key***REMOVED***.lower(***REMOVED***, val***REMOVED***

    def get_default_values(self***REMOVED***:
        ***REMOVED***Overridding to make updating the defaults after instantiation of
        the option parser possible, _update_defaults(***REMOVED*** does the dirty work.***REMOVED***
        if not self.process_default_values:
            # Old, pre-Optik 1.5 behaviour.
            return optparse.Values(self.defaults***REMOVED***

        defaults = self._update_defaults(self.defaults.copy(***REMOVED******REMOVED***  # ours
        for option in self._get_all_options(***REMOVED***:
            default = defaults.get(option.dest***REMOVED***
            if isinstance(default, string_types***REMOVED***:
                opt_str = option.get_opt_string(***REMOVED***
                defaults[option.dest***REMOVED*** = option.check_value(opt_str, default***REMOVED***
        return optparse.Values(defaults***REMOVED***

    def error(self, msg***REMOVED***:
        self.print_usage(sys.stderr***REMOVED***
        self.exit(2, "%s\n" % msg***REMOVED***
