# Copyright (c***REMOVED*** 2009 Raymond Hettinger
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"***REMOVED***, to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
#     The above copyright notice and this permission notice shall be
#     included in all copies or substantial portions of the Software.
#
#     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
#     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
#     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
#     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
#     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
#     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
#     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
#     OTHER DEALINGS IN THE SOFTWARE.

# flake8: noqa

from UserDict import DictMixin

class OrderedDict(dict, DictMixin***REMOVED***:

    def __init__(self, *args, **kwds***REMOVED***:
        if len(args***REMOVED*** > 1:
            raise TypeError('expected at most 1 arguments, got %d' % len(args***REMOVED******REMOVED***
        ***REMOVED***
            self.__end
        except AttributeError:
            self.clear(***REMOVED***
        self.update(*args, **kwds***REMOVED***

    def clear(self***REMOVED***:
        self.__end = end = [***REMOVED***
        end += [None, end, end***REMOVED***         # sentinel node for doubly linked list
        self.__map = {***REMOVED***                 # key --> [key, prev, next***REMOVED***
        dict.clear(self***REMOVED***

    def __setitem__(self, key, value***REMOVED***:
        if key not in self:
            end = self.__end
            curr = end[1***REMOVED***
            curr[2***REMOVED*** = end[1***REMOVED*** = self.__map[key***REMOVED*** = [key, curr, end***REMOVED***
        dict.__setitem__(self, key, value***REMOVED***

    def __delitem__(self, key***REMOVED***:
        dict.__delitem__(self, key***REMOVED***
        key, prev, next = self.__map.pop(key***REMOVED***
        prev[2***REMOVED*** = next
        next[1***REMOVED*** = prev

    def __iter__(self***REMOVED***:
        end = self.__end
        curr = end[2***REMOVED***
        while curr is not end:
            yield curr[0***REMOVED***
            curr = curr[2***REMOVED***

    def __reversed__(self***REMOVED***:
        end = self.__end
        curr = end[1***REMOVED***
        while curr is not end:
            yield curr[0***REMOVED***
            curr = curr[1***REMOVED***

    def popitem(self, last=True***REMOVED***:
        if not self:
            raise KeyError('dictionary is empty'***REMOVED***
        if last:
            key = reversed(self***REMOVED***.next(***REMOVED***
        else:
            key = iter(self***REMOVED***.next(***REMOVED***
        value = self.pop(key***REMOVED***
        return key, value

    def __reduce__(self***REMOVED***:
        items = [[k, self[k***REMOVED******REMOVED*** for k in self***REMOVED***
        tmp = self.__map, self.__end
        del self.__map, self.__end
        inst_dict = vars(self***REMOVED***.copy(***REMOVED***
        self.__map, self.__end = tmp
        if inst_dict:
            return (self.__class__, (items,***REMOVED***, inst_dict***REMOVED***
        return self.__class__, (items,***REMOVED***

    def keys(self***REMOVED***:
        return list(self***REMOVED***

    setdefault = DictMixin.setdefault
    update = DictMixin.update
    pop = DictMixin.pop
    values = DictMixin.values
    items = DictMixin.items
    iterkeys = DictMixin.iterkeys
    itervalues = DictMixin.itervalues
    iteritems = DictMixin.iteritems

    def __repr__(self***REMOVED***:
        if not self:
            return '%s(***REMOVED***' % (self.__class__.__name__,***REMOVED***
        return '%s(%r***REMOVED***' % (self.__class__.__name__, self.items(***REMOVED******REMOVED***

    def copy(self***REMOVED***:
        return self.__class__(self***REMOVED***

    @classmethod
    def fromkeys(cls, iterable, value=None***REMOVED***:
        d = cls(***REMOVED***
        for key in iterable:
            d[key***REMOVED*** = value
        return d

    def __eq__(self, other***REMOVED***:
        if isinstance(other, OrderedDict***REMOVED***:
            if len(self***REMOVED*** != len(other***REMOVED***:
                return False
            for p, q in  zip(self.items(***REMOVED***, other.items(***REMOVED******REMOVED***:
                if p != q:
                    return False
            return True
        return dict.__eq__(self, other***REMOVED***

    def __ne__(self, other***REMOVED***:
        return not self == other
