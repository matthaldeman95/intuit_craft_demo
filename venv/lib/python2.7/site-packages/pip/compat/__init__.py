***REMOVED***Stuff that differs in different Python versions and platform
distributions.***REMOVED***
from __future__ import absolute_import, division

***REMOVED***
import sys

from pip._vendor.six import text_type

***REMOVED***
    from logging.config import dictConfig as logging_dictConfig
except ImportError:
    from pip.compat.dictconfig import dictConfig as logging_dictConfig

***REMOVED***
    from collections import OrderedDict
except ImportError:
    from pip.compat.ordereddict import OrderedDict

***REMOVED***
    import ipaddress
except ImportError:
    ***REMOVED***
        from pip._vendor import ipaddress
    except ImportError:
        import ipaddr as ipaddress
        ipaddress.ip_address = ipaddress.IPAddress
        ipaddress.ip_network = ipaddress.IPNetwork


***REMOVED***
    import sysconfig

    def get_stdlib(***REMOVED***:
        paths = [
            sysconfig.get_path("stdlib"***REMOVED***,
            sysconfig.get_path("platstdlib"***REMOVED***,
        ***REMOVED***
        return set(filter(bool, paths***REMOVED******REMOVED***
except ImportError:
    from distutils import sysconfig

    def get_stdlib(***REMOVED***:
        paths = [
            sysconfig.get_python_lib(standard_lib=True***REMOVED***,
            sysconfig.get_python_lib(standard_lib=True, plat_specific=True***REMOVED***,
        ***REMOVED***
        return set(filter(bool, paths***REMOVED******REMOVED***


__all__ = [
    "logging_dictConfig", "ipaddress", "uses_pycache", "console_to_str",
    "native_str", "get_path_uid", "stdlib_pkgs", "WINDOWS", "samefile",
    "OrderedDict",
***REMOVED***


if sys.version_info >= (3, 4***REMOVED***:
    uses_pycache = True
    from importlib.util import cache_from_source
else:
    import imp
    uses_pycache = hasattr(imp, 'cache_from_source'***REMOVED***
    if uses_pycache:
        cache_from_source = imp.cache_from_source
    else:
        cache_from_source = None


if sys.version_info >= (3,***REMOVED***:
    def console_to_str(s***REMOVED***:
        ***REMOVED***
            return s.decode(sys.__stdout__.encoding***REMOVED***
        except UnicodeDecodeError:
            return s.decode('utf_8'***REMOVED***

    def native_str(s, replace=False***REMOVED***:
        if isinstance(s, bytes***REMOVED***:
            return s.decode('utf-8', 'replace' if replace else 'strict'***REMOVED***
        return s

else:
    def console_to_str(s***REMOVED***:
        return s

    def native_str(s, replace=False***REMOVED***:
        # Replace is ignored -- unicode to UTF-8 can't fail
        if isinstance(s, text_type***REMOVED***:
            return s.encode('utf-8'***REMOVED***
        return s


def total_seconds(td***REMOVED***:
    if hasattr(td, "total_seconds"***REMOVED***:
        return td.total_seconds(***REMOVED***
    else:
        val = td.microseconds + (td.seconds + td.days * 24 * 3600***REMOVED*** * 10 ** 6
        return val / 10 ** 6


def get_path_uid(path***REMOVED***:
    ***REMOVED***
    Return path's uid.

    Does not follow symlinks:
        https://github.com/pypa/pip/pull/935#discussion_r5307003

    Placed this function in compat due to differences on AIX and
    Jython, that should eventually go away.

    :raises OSError: When path is a symlink or can't be read.
    ***REMOVED***
    if hasattr(os, 'O_NOFOLLOW'***REMOVED***:
        fd = os.open(path, os.O_RDONLY | os.O_NOFOLLOW***REMOVED***
        file_uid = os.fstat(fd***REMOVED***.st_uid
        os.close(fd***REMOVED***
    else:  # AIX and Jython
        # WARNING: time of check vulnerabity, but best we can do w/o NOFOLLOW
        if not os.path.islink(path***REMOVED***:
            # older versions of Jython don't have `os.fstat`
            file_uid = os.stat(path***REMOVED***.st_uid
        else:
            # raise OSError for parity with os.O_NOFOLLOW above
            raise OSError(
                "%s is a symlink; Will not return uid for symlinks" % path
            ***REMOVED***
    return file_uid


def expanduser(path***REMOVED***:
    ***REMOVED***
    Expand ~ and ~user constructions.

    Includes a workaround for http://bugs.python.org/issue14768
    ***REMOVED***
    expanded = os.path.expanduser(path***REMOVED***
    if path.startswith('~/'***REMOVED*** and expanded.startswith('//'***REMOVED***:
        expanded = expanded[1:***REMOVED***
    return expanded


# packages in the stdlib that may have installation metadata, but should not be
# considered 'installed'.  this theoretically could be determined based on
# dist.location (py27:`sysconfig.get_paths(***REMOVED***['stdlib'***REMOVED***`,
# py26:sysconfig.get_config_vars('LIBDEST'***REMOVED******REMOVED***, but fear platform variation may
# make this ineffective, so hard-coding
stdlib_pkgs = ('python', 'wsgiref'***REMOVED***
if sys.version_info >= (2, 7***REMOVED***:
    stdlib_pkgs += ('argparse',***REMOVED***


# windows detection, covers cpython and ironpython
WINDOWS = (sys.platform.startswith("win"***REMOVED*** or
           (sys.platform == 'cli' and os.name == 'nt'***REMOVED******REMOVED***


def samefile(file1, file2***REMOVED***:
    ***REMOVED***Provide an alternative for os.path.samefile on Windows/Python2***REMOVED***
    if hasattr(os.path, 'samefile'***REMOVED***:
        return os.path.samefile(file1, file2***REMOVED***
    else:
        path1 = os.path.normcase(os.path.abspath(file1***REMOVED******REMOVED***
        path2 = os.path.normcase(os.path.abspath(file2***REMOVED******REMOVED***
        return path1 == path2
