# This is a copy of the Python logging.config.dictconfig module,
# reproduced with permission. It is provided here for backwards
# compatibility for Python versions prior to 2.7.
#
# Copyright 2009-2010 by Vinay Sajip. All Rights Reserved.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose and without fee is hereby granted,
# provided that the above copyright notice appear in all copies and that
# both that copyright notice and this permission notice appear in
# supporting documentation, and that the name of Vinay Sajip
# not be used in advertising or publicity pertaining to distribution
# of the software without specific, written prior permission.
# VINAY SAJIP DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
# ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL
# VINAY SAJIP BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
# ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
from __future__ import absolute_import

import logging.handlers
import re
import sys
import types

from pip._vendor import six

# flake8: noqa

IDENTIFIER = re.compile('^[a-z_***REMOVED***[a-z0-9_***REMOVED****$', re.I***REMOVED***


def valid_ident(s***REMOVED***:
    m = IDENTIFIER.match(s***REMOVED***
    if not m:
        raise ValueError('Not a valid Python identifier: %r' % s***REMOVED***
    return True

#
# This function is defined in logging only in recent versions of Python
#
***REMOVED***
    from logging import _checkLevel
except ImportError:
    def _checkLevel(level***REMOVED***:
        if isinstance(level, int***REMOVED***:
            rv = level
        elif str(level***REMOVED*** == level:
            if level not in logging._levelNames:
                raise ValueError('Unknown level: %r' % level***REMOVED***
            rv = logging._levelNames[level***REMOVED***
        else:
            raise TypeError('Level not an integer or a '
                            'valid string: %r' % level***REMOVED***
        return rv

# The ConvertingXXX classes are wrappers around standard Python containers,
# and they serve to convert any suitable values in the container. The
# conversion converts base dicts, lists and tuples to their wrapped
# equivalents, whereas strings which match a conversion format are converted
# appropriately.
#
# Each wrapper should have a configurator attribute holding the actual
# configurator to use for conversion.


class ConvertingDict(dict***REMOVED***:
    ***REMOVED***A converting dictionary wrapper.***REMOVED***

    def __getitem__(self, key***REMOVED***:
        value = dict.__getitem__(self, key***REMOVED***
        result = self.configurator.convert(value***REMOVED***
        # If the converted value is different, save for next time
        if value is not result:
            self[key***REMOVED*** = result
            if type(result***REMOVED*** in (ConvertingDict, ConvertingList,
                                ConvertingTuple***REMOVED***:
                result.parent = self
                result.key = key
        return result

    def get(self, key, default=None***REMOVED***:
        value = dict.get(self, key, default***REMOVED***
        result = self.configurator.convert(value***REMOVED***
        # If the converted value is different, save for next time
        if value is not result:
            self[key***REMOVED*** = result
            if type(result***REMOVED*** in (ConvertingDict, ConvertingList,
                                ConvertingTuple***REMOVED***:
                result.parent = self
                result.key = key
        return result

    def pop(self, key, default=None***REMOVED***:
        value = dict.pop(self, key, default***REMOVED***
        result = self.configurator.convert(value***REMOVED***
        if value is not result:
            if type(result***REMOVED*** in (ConvertingDict, ConvertingList,
                                ConvertingTuple***REMOVED***:
                result.parent = self
                result.key = key
        return result


class ConvertingList(list***REMOVED***:
    ***REMOVED***A converting list wrapper.***REMOVED***
    def __getitem__(self, key***REMOVED***:
        value = list.__getitem__(self, key***REMOVED***
        result = self.configurator.convert(value***REMOVED***
        # If the converted value is different, save for next time
        if value is not result:
            self[key***REMOVED*** = result
            if type(result***REMOVED*** in (ConvertingDict, ConvertingList,
                                ConvertingTuple***REMOVED***:
                result.parent = self
                result.key = key
        return result

    def pop(self, idx=-1***REMOVED***:
        value = list.pop(self, idx***REMOVED***
        result = self.configurator.convert(value***REMOVED***
        if value is not result:
            if type(result***REMOVED*** in (ConvertingDict, ConvertingList,
                                ConvertingTuple***REMOVED***:
                result.parent = self
        return result


class ConvertingTuple(tuple***REMOVED***:
    ***REMOVED***A converting tuple wrapper.***REMOVED***
    def __getitem__(self, key***REMOVED***:
        value = tuple.__getitem__(self, key***REMOVED***
        result = self.configurator.convert(value***REMOVED***
        if value is not result:
            if type(result***REMOVED*** in (ConvertingDict, ConvertingList,
                                ConvertingTuple***REMOVED***:
                result.parent = self
                result.key = key
        return result


class BaseConfigurator(object***REMOVED***:
    ***REMOVED***
    The configurator base class which defines some useful defaults.
    ***REMOVED***

    CONVERT_PATTERN = re.compile(r'^(?P<prefix>[a-z***REMOVED***+***REMOVED***://(?P<suffix>.****REMOVED***$'***REMOVED***

    WORD_PATTERN = re.compile(r'^\s*(\w+***REMOVED***\s*'***REMOVED***
    DOT_PATTERN = re.compile(r'^\.\s*(\w+***REMOVED***\s*'***REMOVED***
    INDEX_PATTERN = re.compile(r'^\[\s*(\w+***REMOVED***\s*\***REMOVED***\s*'***REMOVED***
    DIGIT_PATTERN = re.compile(r'^\d+$'***REMOVED***

    value_converters = {
        'ext' : 'ext_convert',
        'cfg' : 'cfg_convert',
***REMOVED***

    # We might want to use a different one, e.g. importlib
    importer = __import__

    def __init__(self, config***REMOVED***:
        self.config = ConvertingDict(config***REMOVED***
        self.config.configurator = self

    def resolve(self, s***REMOVED***:
        ***REMOVED***
        Resolve strings to objects using standard import and attribute
        syntax.
        ***REMOVED***
        name = s.split('.'***REMOVED***
        used = name.pop(0***REMOVED***
        ***REMOVED***
            found = self.importer(used***REMOVED***
            for frag in name:
                used += '.' + frag
                ***REMOVED***
                    found = getattr(found, frag***REMOVED***
                except AttributeError:
                    self.importer(used***REMOVED***
                    found = getattr(found, frag***REMOVED***
            return found
        except ImportError:
            e, tb = sys.exc_info(***REMOVED***[1:***REMOVED***
            v = ValueError('Cannot resolve %r: %s' % (s, e***REMOVED******REMOVED***
            v.__cause__, v.__traceback__ = e, tb
            raise v

    def ext_convert(self, value***REMOVED***:
        ***REMOVED***Default converter for the ext:// protocol.***REMOVED***
        return self.resolve(value***REMOVED***

    def cfg_convert(self, value***REMOVED***:
        ***REMOVED***Default converter for the cfg:// protocol.***REMOVED***
        rest = value
        m = self.WORD_PATTERN.match(rest***REMOVED***
        if m is None:
            raise ValueError("Unable to convert %r" % value***REMOVED***
        else:
            rest = rest[m.end(***REMOVED***:***REMOVED***
            d = self.config[m.groups(***REMOVED***[0***REMOVED******REMOVED***
            # print d, rest
            while rest:
                m = self.DOT_PATTERN.match(rest***REMOVED***
                if m:
                    d = d[m.groups(***REMOVED***[0***REMOVED******REMOVED***
                else:
                    m = self.INDEX_PATTERN.match(rest***REMOVED***
                    if m:
                        idx = m.groups(***REMOVED***[0***REMOVED***
                        if not self.DIGIT_PATTERN.match(idx***REMOVED***:
                            d = d[idx***REMOVED***
                        else:
                            ***REMOVED***
                                n = int(idx***REMOVED***  # try as number first (most likely***REMOVED***
                                d = d[n***REMOVED***
                            except TypeError:
                                d = d[idx***REMOVED***
                if m:
                    rest = rest[m.end(***REMOVED***:***REMOVED***
                else:
                    raise ValueError('Unable to convert '
                                     '%r at %r' % (value, rest***REMOVED******REMOVED***
        # rest should be empty
        return d

    def convert(self, value***REMOVED***:
        ***REMOVED***
        Convert values to an appropriate type. dicts, lists and tuples are
        replaced by their converting alternatives. Strings are checked to
        see if they have a conversion format and are converted if they do.
        ***REMOVED***
        if not isinstance(value, ConvertingDict***REMOVED*** and isinstance(value, dict***REMOVED***:
            value = ConvertingDict(value***REMOVED***
            value.configurator = self
        elif not isinstance(value, ConvertingList***REMOVED*** and isinstance(value, list***REMOVED***:
            value = ConvertingList(value***REMOVED***
            value.configurator = self
        elif not isinstance(value, ConvertingTuple***REMOVED*** and\
                 isinstance(value, tuple***REMOVED***:
            value = ConvertingTuple(value***REMOVED***
            value.configurator = self
        elif isinstance(value, six.string_types***REMOVED***:  # str for py3k
            m = self.CONVERT_PATTERN.match(value***REMOVED***
            if m:
                d = m.groupdict(***REMOVED***
                prefix = d['prefix'***REMOVED***
                converter = self.value_converters.get(prefix, None***REMOVED***
                if converter:
                    suffix = d['suffix'***REMOVED***
                    converter = getattr(self, converter***REMOVED***
                    value = converter(suffix***REMOVED***
        return value

    def configure_custom(self, config***REMOVED***:
        ***REMOVED***Configure an object with a user-supplied factory.***REMOVED***
        c = config.pop('(***REMOVED***'***REMOVED***
        if not hasattr(c, '__call__'***REMOVED*** and hasattr(types, 'ClassType'***REMOVED*** and type(c***REMOVED*** != types.ClassType:
            c = self.resolve(c***REMOVED***
        props = config.pop('.', None***REMOVED***
        # Check for valid identifiers
        kwargs = dict((k, config[k***REMOVED******REMOVED*** for k in config if valid_ident(k***REMOVED******REMOVED***
        result = c(**kwargs***REMOVED***
        if props:
            for name, value in props.items(***REMOVED***:
                setattr(result, name, value***REMOVED***
        return result

    def as_tuple(self, value***REMOVED***:
        ***REMOVED***Utility function which converts lists to tuples.***REMOVED***
        if isinstance(value, list***REMOVED***:
            value = tuple(value***REMOVED***
        return value


class DictConfigurator(BaseConfigurator***REMOVED***:
    ***REMOVED***
    Configure logging using a dictionary-like object to describe the
    configuration.
    ***REMOVED***

    def configure(self***REMOVED***:
        ***REMOVED***Do the configuration.***REMOVED***

        config = self.config
        if 'version' not in config:
            raise ValueError("dictionary doesn't specify a version"***REMOVED***
        if config['version'***REMOVED*** != 1:
            raise ValueError("Unsupported version: %s" % config['version'***REMOVED******REMOVED***
        incremental = config.pop('incremental', False***REMOVED***
        EMPTY_DICT = {***REMOVED***
        logging._acquireLock(***REMOVED***
        ***REMOVED***
            if incremental:
                handlers = config.get('handlers', EMPTY_DICT***REMOVED***
                # incremental handler config only if handler name
                # ties in to logging._handlers (Python 2.7***REMOVED***
                if sys.version_info[:2***REMOVED*** == (2, 7***REMOVED***:
                    for name in handlers:
                        if name not in logging._handlers:
                            raise ValueError('No handler found with '
                                             'name %r'  % name***REMOVED***
                        else:
                            ***REMOVED***
                                handler = logging._handlers[name***REMOVED***
                                handler_config = handlers[name***REMOVED***
                                level = handler_config.get('level', None***REMOVED***
                                if level:
                                    handler.setLevel(_checkLevel(level***REMOVED******REMOVED***
                            except StandardError as e:
                                raise ValueError('Unable to configure handler '
                                                 '%r: %s' % (name, e***REMOVED******REMOVED***
                loggers = config.get('loggers', EMPTY_DICT***REMOVED***
                for name in loggers:
                    ***REMOVED***
                        self.configure_logger(name, loggers[name***REMOVED***, True***REMOVED***
                    except StandardError as e:
                        raise ValueError('Unable to configure logger '
                                         '%r: %s' % (name, e***REMOVED******REMOVED***
                root = config.get('root', None***REMOVED***
                if root:
                    ***REMOVED***
                        self.configure_root(root, True***REMOVED***
                    except StandardError as e:
                        raise ValueError('Unable to configure root '
                                         'logger: %s' % e***REMOVED***
            else:
                disable_existing = config.pop('disable_existing_loggers', True***REMOVED***

                logging._handlers.clear(***REMOVED***
                del logging._handlerList[:***REMOVED***

                # Do formatters first - they don't refer to anything else
                formatters = config.get('formatters', EMPTY_DICT***REMOVED***
                for name in formatters:
                    ***REMOVED***
                        formatters[name***REMOVED*** = self.configure_formatter(
                                                            formatters[name***REMOVED******REMOVED***
                    except StandardError as e:
                        raise ValueError('Unable to configure '
                                         'formatter %r: %s' % (name, e***REMOVED******REMOVED***
                # Next, do filters - they don't refer to anything else, either
                filters = config.get('filters', EMPTY_DICT***REMOVED***
                for name in filters:
                    ***REMOVED***
                        filters[name***REMOVED*** = self.configure_filter(filters[name***REMOVED******REMOVED***
                    except StandardError as e:
                        raise ValueError('Unable to configure '
                                         'filter %r: %s' % (name, e***REMOVED******REMOVED***

                # Next, do handlers - they refer to formatters and filters
                # As handlers can refer to other handlers, sort the keys
                # to allow a deterministic order of configuration
                handlers = config.get('handlers', EMPTY_DICT***REMOVED***
                for name in sorted(handlers***REMOVED***:
                    ***REMOVED***
                        handler = self.configure_handler(handlers[name***REMOVED******REMOVED***
                        handler.name = name
                        handlers[name***REMOVED*** = handler
                    except StandardError as e:
                        raise ValueError('Unable to configure handler '
                                         '%r: %s' % (name, e***REMOVED******REMOVED***
                # Next, do loggers - they refer to handlers and filters

                # we don't want to lose the existing loggers,
                # since other threads may have pointers to them.
                # existing is set to contain all existing loggers,
                # and as we go through the new configuration we
                # remove any which are configured. At the end,
                # what's left in existing is the set of loggers
                # which were in the previous configuration but
                # which are not in the new configuration.
                root = logging.root
                existing = list(root.manager.loggerDict***REMOVED***
                # The list needs to be sorted so that we can
                # avoid disabling child loggers of explicitly
                # named loggers. With a sorted list it is easier
                # to find the child loggers.
                existing.sort(***REMOVED***
                # We'll keep the list of existing loggers
                # which are children of named loggers here...
                child_loggers = [***REMOVED***
                # now set up the new ones...
                loggers = config.get('loggers', EMPTY_DICT***REMOVED***
                for name in loggers:
                    if name in existing:
                        i = existing.index(name***REMOVED***
                        prefixed = name + "."
                        pflen = len(prefixed***REMOVED***
                        num_existing = len(existing***REMOVED***
                        i = i + 1  # look at the entry after name
                        while (i < num_existing***REMOVED*** and\
                              (existing[i***REMOVED***[:pflen***REMOVED*** == prefixed***REMOVED***:
                            child_loggers.append(existing[i***REMOVED******REMOVED***
                            i = i + 1
                        existing.remove(name***REMOVED***
                    ***REMOVED***
                        self.configure_logger(name, loggers[name***REMOVED******REMOVED***
                    except StandardError as e:
                        raise ValueError('Unable to configure logger '
                                         '%r: %s' % (name, e***REMOVED******REMOVED***

                # Disable any old loggers. There's no point deleting
                # them as other threads may continue to hold references
                # and by disabling them, you stop them doing any logging.
                # However, don't disable children of named loggers, as that's
                # probably not what was intended by the user.
                for log in existing:
                    logger = root.manager.loggerDict[log***REMOVED***
                    if log in child_loggers:
                        logger.level = logging.NOTSET
                        logger.handlers = [***REMOVED***
                        logger.propagate = True
                    elif disable_existing:
                        logger.disabled = True

                # And finally, do the root logger
                root = config.get('root', None***REMOVED***
                if root:
                    ***REMOVED***
                        self.configure_root(root***REMOVED***
                    except StandardError as e:
                        raise ValueError('Unable to configure root '
                                         'logger: %s' % e***REMOVED***
        finally:
            logging._releaseLock(***REMOVED***

    def configure_formatter(self, config***REMOVED***:
        ***REMOVED***Configure a formatter from a dictionary.***REMOVED***
        if '(***REMOVED***' in config:
            factory = config['(***REMOVED***'***REMOVED***  # for use in exception handler
            ***REMOVED***
                result = self.configure_custom(config***REMOVED***
            except TypeError as te:
                if "'format'" not in str(te***REMOVED***:
                    raise
                # Name of parameter changed from fmt to format.
                # Retry with old name.
                # This is so that code can be used with older Python versions
                #(e.g. by Django***REMOVED***
                config['fmt'***REMOVED*** = config.pop('format'***REMOVED***
                config['(***REMOVED***'***REMOVED*** = factory
                result = self.configure_custom(config***REMOVED***
        else:
            fmt = config.get('format', None***REMOVED***
            dfmt = config.get('datefmt', None***REMOVED***
            result = logging.Formatter(fmt, dfmt***REMOVED***
        return result

    def configure_filter(self, config***REMOVED***:
        ***REMOVED***Configure a filter from a dictionary.***REMOVED***
        if '(***REMOVED***' in config:
            result = self.configure_custom(config***REMOVED***
        else:
            name = config.get('name', ''***REMOVED***
            result = logging.Filter(name***REMOVED***
        return result

    def add_filters(self, filterer, filters***REMOVED***:
        ***REMOVED***Add filters to a filterer from a list of names.***REMOVED***
        for f in filters:
            ***REMOVED***
                filterer.addFilter(self.config['filters'***REMOVED***[f***REMOVED******REMOVED***
            except StandardError as e:
                raise ValueError('Unable to add filter %r: %s' % (f, e***REMOVED******REMOVED***

    def configure_handler(self, config***REMOVED***:
        ***REMOVED***Configure a handler from a dictionary.***REMOVED***
        formatter = config.pop('formatter', None***REMOVED***
        if formatter:
            ***REMOVED***
                formatter = self.config['formatters'***REMOVED***[formatter***REMOVED***
            except StandardError as e:
                raise ValueError('Unable to set formatter '
                                 '%r: %s' % (formatter, e***REMOVED******REMOVED***
        level = config.pop('level', None***REMOVED***
        filters = config.pop('filters', None***REMOVED***
        if '(***REMOVED***' in config:
            c = config.pop('(***REMOVED***'***REMOVED***
            if not hasattr(c, '__call__'***REMOVED*** and hasattr(types, 'ClassType'***REMOVED*** and type(c***REMOVED*** != types.ClassType:
                c = self.resolve(c***REMOVED***
            factory = c
        else:
            klass = self.resolve(config.pop('class'***REMOVED******REMOVED***
            # Special case for handler which refers to another handler
            if issubclass(klass, logging.handlers.MemoryHandler***REMOVED*** and\
                'target' in config:
                ***REMOVED***
                    config['target'***REMOVED*** = self.config['handlers'***REMOVED***[config['target'***REMOVED******REMOVED***
                except StandardError as e:
                    raise ValueError('Unable to set target handler '
                                     '%r: %s' % (config['target'***REMOVED***, e***REMOVED******REMOVED***
            elif issubclass(klass, logging.handlers.SMTPHandler***REMOVED*** and\
                'mailhost' in config:
                config['mailhost'***REMOVED*** = self.as_tuple(config['mailhost'***REMOVED******REMOVED***
            elif issubclass(klass, logging.handlers.SysLogHandler***REMOVED*** and\
                'address' in config:
                config['address'***REMOVED*** = self.as_tuple(config['address'***REMOVED******REMOVED***
            factory = klass
        kwargs = dict((k, config[k***REMOVED******REMOVED*** for k in config if valid_ident(k***REMOVED******REMOVED***
        ***REMOVED***
            result = factory(**kwargs***REMOVED***
        except TypeError as te:
            if "'stream'" not in str(te***REMOVED***:
                raise
            # The argument name changed from strm to stream
            # Retry with old name.
            # This is so that code can be used with older Python versions
            #(e.g. by Django***REMOVED***
            kwargs['strm'***REMOVED*** = kwargs.pop('stream'***REMOVED***
            result = factory(**kwargs***REMOVED***
        if formatter:
            result.setFormatter(formatter***REMOVED***
        if level is not None:
            result.setLevel(_checkLevel(level***REMOVED******REMOVED***
        if filters:
            self.add_filters(result, filters***REMOVED***
        return result

    def add_handlers(self, logger, handlers***REMOVED***:
        ***REMOVED***Add handlers to a logger from a list of names.***REMOVED***
        for h in handlers:
            ***REMOVED***
                logger.addHandler(self.config['handlers'***REMOVED***[h***REMOVED******REMOVED***
            except StandardError as e:
                raise ValueError('Unable to add handler %r: %s' % (h, e***REMOVED******REMOVED***

    def common_logger_config(self, logger, config, incremental=False***REMOVED***:
        ***REMOVED***
        Perform configuration which is common to root and non-root loggers.
        ***REMOVED***
        level = config.get('level', None***REMOVED***
        if level is not None:
            logger.setLevel(_checkLevel(level***REMOVED******REMOVED***
        if not incremental:
            # Remove any existing handlers
            for h in logger.handlers[:***REMOVED***:
                logger.removeHandler(h***REMOVED***
            handlers = config.get('handlers', None***REMOVED***
            if handlers:
                self.add_handlers(logger, handlers***REMOVED***
            filters = config.get('filters', None***REMOVED***
            if filters:
                self.add_filters(logger, filters***REMOVED***

    def configure_logger(self, name, config, incremental=False***REMOVED***:
        ***REMOVED***Configure a non-root logger from a dictionary.***REMOVED***
        logger = logging.getLogger(name***REMOVED***
        self.common_logger_config(logger, config, incremental***REMOVED***
        propagate = config.get('propagate', None***REMOVED***
        if propagate is not None:
            logger.propagate = propagate

    def configure_root(self, config, incremental=False***REMOVED***:
        ***REMOVED***Configure a root logger from a dictionary.***REMOVED***
        root = logging.getLogger(***REMOVED***
        self.common_logger_config(root, config, incremental***REMOVED***

dictConfigClass = DictConfigurator


def dictConfig(config***REMOVED***:
    ***REMOVED***Configure logging using a dictionary.***REMOVED***
    dictConfigClass(config***REMOVED***.configure(***REMOVED***
