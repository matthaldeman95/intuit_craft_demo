***REMOVED***Exceptions used throughout package***REMOVED***
from __future__ import absolute_import

from itertools import chain, groupby, repeat

from pip._vendor.six import iteritems


class PipError(Exception***REMOVED***:
    ***REMOVED***Base pip exception***REMOVED***


class InstallationError(PipError***REMOVED***:
    ***REMOVED***General exception during installation***REMOVED***


class UninstallationError(PipError***REMOVED***:
    ***REMOVED***General exception during uninstallation***REMOVED***


class DistributionNotFound(InstallationError***REMOVED***:
    ***REMOVED***Raised when a distribution cannot be found to satisfy a requirement***REMOVED***


class RequirementsFileParseError(InstallationError***REMOVED***:
    ***REMOVED***Raised when a general error occurs parsing a requirements file line.***REMOVED***


class BestVersionAlreadyInstalled(PipError***REMOVED***:
    ***REMOVED***Raised when the most up-to-date version of a package is already
    installed.***REMOVED***


class BadCommand(PipError***REMOVED***:
    ***REMOVED***Raised when virtualenv or a command is not found***REMOVED***


class CommandError(PipError***REMOVED***:
    ***REMOVED***Raised when there is an error in command-line arguments***REMOVED***


class PreviousBuildDirError(PipError***REMOVED***:
    ***REMOVED***Raised when there's a previous conflicting build directory***REMOVED***


class InvalidWheelFilename(InstallationError***REMOVED***:
    ***REMOVED***Invalid wheel filename.***REMOVED***


class UnsupportedWheel(InstallationError***REMOVED***:
    ***REMOVED***Unsupported wheel.***REMOVED***


class HashErrors(InstallationError***REMOVED***:
    ***REMOVED***Multiple HashError instances rolled into one for reporting***REMOVED***

    def __init__(self***REMOVED***:
        self.errors = [***REMOVED***

    def append(self, error***REMOVED***:
        self.errors.append(error***REMOVED***

    def __str__(self***REMOVED***:
        lines = [***REMOVED***
        self.errors.sort(key=lambda e: e.order***REMOVED***
        for cls, errors_of_cls in groupby(self.errors, lambda e: e.__class__***REMOVED***:
            lines.append(cls.head***REMOVED***
            lines.extend(e.body(***REMOVED*** for e in errors_of_cls***REMOVED***
        if lines:
            return '\n'.join(lines***REMOVED***

    def __nonzero__(self***REMOVED***:
        return bool(self.errors***REMOVED***

    def __bool__(self***REMOVED***:
        return self.__nonzero__(***REMOVED***


class HashError(InstallationError***REMOVED***:
    ***REMOVED***
    A failure to verify a package against known-good hashes

    :cvar order: An int sorting hash exception classes by difficulty of
        recovery (lower being harder***REMOVED***, so the user doesn't bother fretting
        about unpinned packages when he has deeper issues, like VCS
        dependencies, to deal with. Also keeps error reports in a
        deterministic order.
    :cvar head: A section heading for display above potentially many
        exceptions of this kind
    :ivar req: The InstallRequirement that triggered this error. This is
        pasted on after the exception is instantiated, because it's not
        typically available earlier.

    ***REMOVED***
    req = None
    head = ''

    def body(self***REMOVED***:
        ***REMOVED***Return a summary of me for display under the heading.

        This default implementation simply prints a description of the
        triggering requirement.

        :param req: The InstallRequirement that provoked this error, with
            populate_link(***REMOVED*** having already been called

        ***REMOVED***
        return '    %s' % self._requirement_name(***REMOVED***

    def __str__(self***REMOVED***:
        return '%s\n%s' % (self.head, self.body(***REMOVED******REMOVED***

    def _requirement_name(self***REMOVED***:
        ***REMOVED***Return a description of the requirement that triggered me.

        This default implementation returns long description of the req, with
        line numbers

        ***REMOVED***
        return str(self.req***REMOVED*** if self.req else 'unknown package'


class VcsHashUnsupported(HashError***REMOVED***:
    ***REMOVED***A hash was provided for a version-control-system-based requirement, but
    we don't have a method for hashing those.***REMOVED***

    order = 0
    head = ("Can't verify hashes for these requirements because we don't "
            "have a way to hash version control repositories:"***REMOVED***


class DirectoryUrlHashUnsupported(HashError***REMOVED***:
    ***REMOVED***A hash was provided for a version-control-system-based requirement, but
    we don't have a method for hashing those.***REMOVED***

    order = 1
    head = ("Can't verify hashes for these file:// requirements because they "
            "point to directories:"***REMOVED***


class HashMissing(HashError***REMOVED***:
    ***REMOVED***A hash was needed for a requirement but is absent.***REMOVED***

    order = 2
    head = ('Hashes are required in --require-hashes mode, but they are '
            'missing from some requirements. Here is a list of those '
            'requirements along with the hashes their downloaded archives '
            'actually had. Add lines like these to your requirements files to '
            'prevent tampering. (If you did not enable --require-hashes '
            'manually, note that it turns on automatically when any package '
            'has a hash.***REMOVED***'***REMOVED***

    def __init__(self, gotten_hash***REMOVED***:
        ***REMOVED***
        :param gotten_hash: The hash of the (possibly malicious***REMOVED*** archive we
            just downloaded
        ***REMOVED***
        self.gotten_hash = gotten_hash

    def body(self***REMOVED***:
        from pip.utils.hashes import FAVORITE_HASH  # Dodge circular import.

        package = None
        if self.req:
            # In the case of URL-based requirements, display the original URL
            # seen in the requirements file rather than the package name,
            # so the output can be directly copied into the requirements file.
            package = (self.req.original_link if self.req.original_link
                       # In case someone feeds something downright stupid
                       # to InstallRequirement's constructor.
                       else getattr(self.req, 'req', None***REMOVED******REMOVED***
        return '    %s --hash=%s:%s' % (package or 'unknown package',
                                        FAVORITE_HASH,
                                        self.gotten_hash***REMOVED***


class HashUnpinned(HashError***REMOVED***:
    ***REMOVED***A requirement had a hash specified but was not pinned to a specific
    version.***REMOVED***

    order = 3
    head = ('In --require-hashes mode, all requirements must have their '
            'versions pinned with ==. These do not:'***REMOVED***


class HashMismatch(HashError***REMOVED***:
    ***REMOVED***
    Distribution file hash values don't match.

    :ivar package_name: The name of the package that triggered the hash
        mismatch. Feel free to write to this after the exception is raise to
        improve its error message.

    ***REMOVED***
    order = 4
    head = ('THESE PACKAGES DO NOT MATCH THE HASHES FROM THE REQUIREMENTS '
            'FILE. If you have updated the package versions, please update '
            'the hashes. Otherwise, examine the package contents carefully; '
            'someone may have tampered with them.'***REMOVED***

    def __init__(self, allowed, gots***REMOVED***:
        ***REMOVED***
        :param allowed: A dict of algorithm names pointing to lists of allowed
            hex digests
        :param gots: A dict of algorithm names pointing to hashes we
            actually got from the files under suspicion
        ***REMOVED***
        self.allowed = allowed
        self.gots = gots

    def body(self***REMOVED***:
        return '    %s:\n%s' % (self._requirement_name(***REMOVED***,
                                self._hash_comparison(***REMOVED******REMOVED***

    def _hash_comparison(self***REMOVED***:
        ***REMOVED***
        Return a comparison of actual and expected hash values.

        Example::

               Expected sha256 abcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcde
                            or 123451234512345123451234512345123451234512345
                    Got        bcdefbcdefbcdefbcdefbcdefbcdefbcdefbcdefbcdef

        ***REMOVED***
        def hash_then_or(hash_name***REMOVED***:
            # For now, all the decent hashes have 6-char names, so we can get
            # away with hard-coding space literals.
            return chain([hash_name***REMOVED***, repeat('    or'***REMOVED******REMOVED***

        lines = [***REMOVED***
        for hash_name, expecteds in iteritems(self.allowed***REMOVED***:
            prefix = hash_then_or(hash_name***REMOVED***
            lines.extend(('        Expected %s %s' % (next(prefix***REMOVED***, e***REMOVED******REMOVED***
                         for e in expecteds***REMOVED***
            lines.append('             Got        %s\n' %
                         self.gots[hash_name***REMOVED***.hexdigest(***REMOVED******REMOVED***
            prefix = '    or'
        return '\n'.join(lines***REMOVED***
