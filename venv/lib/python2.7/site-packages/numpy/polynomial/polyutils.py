***REMOVED***
Utililty classes and functions for the polynomial modules.

This module provides: error and warning objects; a polynomial base class;
and some routines used in both the `polynomial` and `chebyshev` modules.

Error objects
-------------

.. autosummary::
   :toctree: generated/

   PolyError            base class for this sub-package's errors.
   PolyDomainError      raised when domains are mismatched.

Warning objects
---------------

.. autosummary::
   :toctree: generated/

   RankWarning  raised in least-squares fit for rank-deficient matrix.

Base class
----------

.. autosummary::
   :toctree: generated/

   PolyBase Obsolete base class for the polynomial classes. Do not use.

Functions
---------

.. autosummary::
   :toctree: generated/

   as_series    convert list of array_likes into 1-D arrays of common type.
   trimseq      remove trailing zeros.
   trimcoef     remove small trailing coefficients.
   getdomain    return the domain appropriate for a given set of abscissae.
   mapdomain    maps points between domains.
   mapparms     parameters of the linear map between domains.

***REMOVED***
from __future__ import division, absolute_import, print_function

import numpy as np

__all__ = [
    'RankWarning', 'PolyError', 'PolyDomainError', 'as_series', 'trimseq',
    'trimcoef', 'getdomain', 'mapdomain', 'mapparms', 'PolyBase'***REMOVED***

#
# Warnings and Exceptions
#

class RankWarning(UserWarning***REMOVED***:
    ***REMOVED***Issued by chebfit when the design matrix is rank deficient.***REMOVED***
    pass

class PolyError(Exception***REMOVED***:
    ***REMOVED***Base class for errors in this module.***REMOVED***
    pass

class PolyDomainError(PolyError***REMOVED***:
    ***REMOVED***Issued by the generic Poly class when two domains don't match.

    This is raised when an binary operation is passed Poly objects with
    different domains.

    ***REMOVED***
    pass

#
# Base class for all polynomial types
#

class PolyBase(object***REMOVED***:
    ***REMOVED***
    Base class for all polynomial types.

    Deprecated in numpy 1.9.0, use the abstract
    ABCPolyBase class instead. Note that the latter
    reguires a number of virtual functions to be
    implemented.

    ***REMOVED***
    pass

#
# Helper functions to convert inputs to 1-D arrays
#
def trimseq(seq***REMOVED***:
    ***REMOVED***Remove small Poly series coefficients.

    Parameters
    ----------
    seq : sequence
        Sequence of Poly series coefficients. This routine fails for
        empty sequences.

    Returns
    -------
    series : sequence
        Subsequence with trailing zeros removed. If the resulting sequence
        would be empty, return the first element. The returned sequence may
        or may not be a view.

    Notes
    -----
    Do not lose the type info if the sequence contains unknown objects.

    ***REMOVED***
    if len(seq***REMOVED*** == 0:
        return seq
    else:
        for i in range(len(seq***REMOVED*** - 1, -1, -1***REMOVED***:
            if seq[i***REMOVED*** != 0:
                break
        return seq[:i+1***REMOVED***


def as_series(alist, trim=True***REMOVED***:
    ***REMOVED***
    Return argument as a list of 1-d arrays.

    The returned list contains array(s***REMOVED*** of dtype double, complex double, or
    object.  A 1-d argument of shape ``(N,***REMOVED***`` is parsed into ``N`` arrays of
    size one; a 2-d argument of shape ``(M,N***REMOVED***`` is parsed into ``M`` arrays
    of size ``N`` (i.e., is "parsed by row"***REMOVED***; and a higher dimensional array
    raises a Value Error if it is not first reshaped into either a 1-d or 2-d
    array.

    Parameters
    ----------
    alist : array_like
        A 1- or 2-d array_like
    trim : boolean, optional
        When True, trailing zeros are removed from the inputs.
        When False, the inputs are passed through intact.

    Returns
    -------
    [a1, a2,...***REMOVED*** : list of 1-D arrays
        A copy of the input data as a list of 1-d arrays.

    Raises
    ------
    ValueError
        Raised when `as_series` cannot convert its input to 1-d arrays, or at
        least one of the resulting arrays is empty.

    Examples
    --------
    >>> from numpy import polynomial as P
    >>> a = np.arange(4***REMOVED***
    >>> P.as_series(a***REMOVED***
    [array([ 0.***REMOVED******REMOVED***, array([ 1.***REMOVED******REMOVED***, array([ 2.***REMOVED******REMOVED***, array([ 3.***REMOVED******REMOVED******REMOVED***
    >>> b = np.arange(6***REMOVED***.reshape((2,3***REMOVED******REMOVED***
    >>> P.as_series(b***REMOVED***
    [array([ 0.,  1.,  2.***REMOVED******REMOVED***, array([ 3.,  4.,  5.***REMOVED******REMOVED******REMOVED***

    ***REMOVED***
    arrays = [np.array(a, ndmin=1, copy=0***REMOVED*** for a in alist***REMOVED***
    if min([a.size for a in arrays***REMOVED******REMOVED*** == 0:
        raise ValueError("Coefficient array is empty"***REMOVED***
    if any([a.ndim != 1 for a in arrays***REMOVED******REMOVED***:
        raise ValueError("Coefficient array is not 1-d"***REMOVED***
    if trim:
        arrays = [trimseq(a***REMOVED*** for a in arrays***REMOVED***

    if any([a.dtype == np.dtype(object***REMOVED*** for a in arrays***REMOVED******REMOVED***:
        ret = [***REMOVED***
        for a in arrays:
            if a.dtype != np.dtype(object***REMOVED***:
                tmp = np.empty(len(a***REMOVED***, dtype=np.dtype(object***REMOVED******REMOVED***
                tmp[:***REMOVED*** = a[:***REMOVED***
                ret.append(tmp***REMOVED***
            else:
                ret.append(a.copy(***REMOVED******REMOVED***
    else:
        ***REMOVED***
            dtype = np.common_type(*arrays***REMOVED***
        ***REMOVED***
            raise ValueError("Coefficient arrays have no common type"***REMOVED***
        ret = [np.array(a, copy=1, dtype=dtype***REMOVED*** for a in arrays***REMOVED***
    return ret


def trimcoef(c, tol=0***REMOVED***:
    ***REMOVED***
    Remove "small" "trailing" coefficients from a polynomial.

    "Small" means "small in absolute value" and is controlled by the
    parameter `tol`; "trailing" means highest order coefficient(s***REMOVED***, e.g., in
    ``[0, 1, 1, 0, 0***REMOVED***`` (which represents ``0 + x + x**2 + 0*x**3 + 0*x**4``***REMOVED***
    both the 3-rd and 4-th order coefficients would be "trimmed."

    Parameters
    ----------
    c : array_like
        1-d array of coefficients, ordered from lowest order to highest.
    tol : number, optional
        Trailing (i.e., highest order***REMOVED*** elements with absolute value less
        than or equal to `tol` (default value is zero***REMOVED*** are removed.

    Returns
    -------
    trimmed : ndarray
        1-d array with trailing zeros removed.  If the resulting series
        would be empty, a series containing a single zero is returned.

    Raises
    ------
    ValueError
        If `tol` < 0

    See Also
    --------
    trimseq

    Examples
    --------
    >>> from numpy import polynomial as P
    >>> P.trimcoef((0,0,3,0,5,0,0***REMOVED******REMOVED***
    array([ 0.,  0.,  3.,  0.,  5.***REMOVED******REMOVED***
    >>> P.trimcoef((0,0,1e-3,0,1e-5,0,0***REMOVED***,1e-3***REMOVED*** # item == tol is trimmed
    array([ 0.***REMOVED******REMOVED***
    >>> i = complex(0,1***REMOVED*** # works for complex
    >>> P.trimcoef((3e-4,1e-3*(1-i***REMOVED***,5e-4,2e-5*(1+i***REMOVED******REMOVED***, 1e-3***REMOVED***
    array([ 0.0003+0.j   ,  0.0010-0.001j***REMOVED******REMOVED***

    ***REMOVED***
    if tol < 0:
        raise ValueError("tol must be non-negative"***REMOVED***

    [c***REMOVED*** = as_series([c***REMOVED******REMOVED***
    [ind***REMOVED*** = np.where(np.abs(c***REMOVED*** > tol***REMOVED***
    if len(ind***REMOVED*** == 0:
        return c[:1***REMOVED****0
    else:
        return c[:ind[-1***REMOVED*** + 1***REMOVED***.copy(***REMOVED***

def getdomain(x***REMOVED***:
    ***REMOVED***
    Return a domain suitable for given abscissae.

    Find a domain suitable for a polynomial or Chebyshev series
    defined at the values supplied.

    Parameters
    ----------
    x : array_like
        1-d array of abscissae whose domain will be determined.

    Returns
    -------
    domain : ndarray
        1-d array containing two values.  If the inputs are complex, then
        the two returned points are the lower left and upper right corners
        of the smallest rectangle (aligned with the axes***REMOVED*** in the complex
        plane containing the points `x`. If the inputs are real, then the
        two points are the ends of the smallest interval containing the
        points `x`.

    See Also
    --------
    mapparms, mapdomain

    Examples
    --------
    >>> from numpy.polynomial import polyutils as pu
    >>> points = np.arange(4***REMOVED*****2 - 5; points
    array([-5, -4, -1,  4***REMOVED******REMOVED***
    >>> pu.getdomain(points***REMOVED***
    array([-5.,  4.***REMOVED******REMOVED***
    >>> c = np.exp(complex(0,1***REMOVED****np.pi*np.arange(12***REMOVED***/6***REMOVED*** # unit circle
    >>> pu.getdomain(c***REMOVED***
    array([-1.-1.j,  1.+1.j***REMOVED******REMOVED***

    ***REMOVED***
    [x***REMOVED*** = as_series([x***REMOVED***, trim=False***REMOVED***
    if x.dtype.char in np.typecodes['Complex'***REMOVED***:
        rmin, rmax = x.real.min(***REMOVED***, x.real.max(***REMOVED***
        imin, imax = x.imag.min(***REMOVED***, x.imag.max(***REMOVED***
        return np.array((complex(rmin, imin***REMOVED***, complex(rmax, imax***REMOVED******REMOVED******REMOVED***
    else:
        return np.array((x.min(***REMOVED***, x.max(***REMOVED******REMOVED******REMOVED***

def mapparms(old, new***REMOVED***:
    ***REMOVED***
    Linear map parameters between domains.

    Return the parameters of the linear map ``offset + scale*x`` that maps
    `old` to `new` such that ``old[i***REMOVED*** -> new[i***REMOVED***``, ``i = 0, 1``.

    Parameters
    ----------
    old, new : array_like
        Domains. Each domain must (successfully***REMOVED*** convert to a 1-d array
        containing precisely two values.

    Returns
    -------
    offset, scale : scalars
        The map ``L(x***REMOVED*** = offset + scale*x`` maps the first domain to the
        second.

    See Also
    --------
    getdomain, mapdomain

    Notes
    -----
    Also works for complex numbers, and thus can be used to calculate the
    parameters required to map any line in the complex plane to any other
    line therein.

    Examples
    --------
    >>> from numpy import polynomial as P
    >>> P.mapparms((-1,1***REMOVED***,(-1,1***REMOVED******REMOVED***
    (0.0, 1.0***REMOVED***
    >>> P.mapparms((1,-1***REMOVED***,(-1,1***REMOVED******REMOVED***
    (0.0, -1.0***REMOVED***
    >>> i = complex(0,1***REMOVED***
    >>> P.mapparms((-i,-1***REMOVED***,(1,i***REMOVED******REMOVED***
    ((1+1j***REMOVED***, (1+0j***REMOVED******REMOVED***

    ***REMOVED***
    oldlen = old[1***REMOVED*** - old[0***REMOVED***
    newlen = new[1***REMOVED*** - new[0***REMOVED***
    off = (old[1***REMOVED****new[0***REMOVED*** - old[0***REMOVED****new[1***REMOVED******REMOVED***/oldlen
    scl = newlen/oldlen
    return off, scl

def mapdomain(x, old, new***REMOVED***:
    ***REMOVED***
    Apply linear map to input points.

    The linear map ``offset + scale*x`` that maps the domain `old` to
    the domain `new` is applied to the points `x`.

    Parameters
    ----------
    x : array_like
        Points to be mapped. If `x` is a subtype of ndarray the subtype
        will be preserved.
    old, new : array_like
        The two domains that determine the map.  Each must (successfully***REMOVED***
        convert to 1-d arrays containing precisely two values.

    Returns
    -------
    x_out : ndarray
        Array of points of the same shape as `x`, after application of the
        linear map between the two domains.

    See Also
    --------
    getdomain, mapparms

    Notes
    -----
    Effectively, this implements:

    .. math ::
        x\\_out = new[0***REMOVED*** + m(x - old[0***REMOVED******REMOVED***

    where

    .. math ::
        m = \\frac{new[1***REMOVED***-new[0***REMOVED******REMOVED***{old[1***REMOVED***-old[0***REMOVED******REMOVED***

    Examples
    --------
    >>> from numpy import polynomial as P
    >>> old_domain = (-1,1***REMOVED***
    >>> new_domain = (0,2*np.pi***REMOVED***
    >>> x = np.linspace(-1,1,6***REMOVED***; x
    array([-1. , -0.6, -0.2,  0.2,  0.6,  1. ***REMOVED******REMOVED***
    >>> x_out = P.mapdomain(x, old_domain, new_domain***REMOVED***; x_out
    array([ 0.        ,  1.25663706,  2.51327412,  3.76991118,  5.02654825,
            6.28318531***REMOVED******REMOVED***
    >>> x - P.mapdomain(x_out, new_domain, old_domain***REMOVED***
    array([ 0.,  0.,  0.,  0.,  0.,  0.***REMOVED******REMOVED***

    Also works for complex numbers (and thus can be used to map any line in
    the complex plane to any other line therein***REMOVED***.

    >>> i = complex(0,1***REMOVED***
    >>> old = (-1 - i, 1 + i***REMOVED***
    >>> new = (-1 + i, 1 - i***REMOVED***
    >>> z = np.linspace(old[0***REMOVED***, old[1***REMOVED***, 6***REMOVED***; z
    array([-1.0-1.j , -0.6-0.6j, -0.2-0.2j,  0.2+0.2j,  0.6+0.6j,  1.0+1.j ***REMOVED******REMOVED***
    >>> new_z = P.mapdomain(z, old, new***REMOVED***; new_z
    array([-1.0+1.j , -0.6+0.6j, -0.2+0.2j,  0.2-0.2j,  0.6-0.6j,  1.0-1.j ***REMOVED******REMOVED***

    ***REMOVED***
    x = np.asanyarray(x***REMOVED***
    off, scl = mapparms(old, new***REMOVED***
    return off + scl*x
