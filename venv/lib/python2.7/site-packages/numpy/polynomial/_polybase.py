***REMOVED***
Abstract base class for the various polynomial Classes.

The ABCPolyBase class provides the methods needed to implement the common API
for the various polynomial classes. It operates as a mixin, but uses the
abc module from the stdlib, hence it is only available for Python >= 2.6.

***REMOVED***
from __future__ import division, absolute_import, print_function

from abc import ABCMeta, abstractmethod, abstractproperty
from numbers import Number

import numpy as np
from . import polyutils as pu

__all__ = ['ABCPolyBase'***REMOVED***

class ABCPolyBase(object***REMOVED***:
    ***REMOVED***An abstract base class for series classes.

    ABCPolyBase provides the standard Python numerical methods
    '+', '-', '*', '//', '%', 'divmod', '**', and '(***REMOVED***' along with the
    methods listed below.

    .. versionadded:: 1.9.0

    Parameters
    ----------
    coef : array_like
        Series coefficients in order of increasing degree, i.e.,
        ``(1, 2, 3***REMOVED***`` gives ``1*P_0(x***REMOVED*** + 2*P_1(x***REMOVED*** + 3*P_2(x***REMOVED***``, where
        ``P_i`` is the basis polynomials of degree ``i``.
    domain : (2,***REMOVED*** array_like, optional
        Domain to use. The interval ``[domain[0***REMOVED***, domain[1***REMOVED******REMOVED***`` is mapped
        to the interval ``[window[0***REMOVED***, window[1***REMOVED******REMOVED***`` by shifting and scaling.
        The default value is the derived class domain.
    window : (2,***REMOVED*** array_like, optional
        Window, see domain for its use. The default value is the
        derived class window.

    Attributes
    ----------
    coef : (N,***REMOVED*** ndarray
        Series coefficients in order of increasing degree.
    domain : (2,***REMOVED*** ndarray
        Domain that is mapped to window.
    window : (2,***REMOVED*** ndarray
        Window that domain is mapped to.

    Class Attributes
    ----------------
    maxpower : int
        Maximum power allowed, i.e., the largest number ``n`` such that
        ``p(x***REMOVED*****n`` is allowed. This is to limit runaway polynomial size.
    domain : (2,***REMOVED*** ndarray
        Default domain of the class.
    window : (2,***REMOVED*** ndarray
        Default window of the class.

    ***REMOVED***
    __metaclass__ = ABCMeta

    # Not hashable
    __hash__ = None

    # Don't let participate in array operations. Value doesn't matter.
    __array_priority__ = 1000

    # Limit runaway size. T_n^m has degree n*m
    maxpower = 100

    @abstractproperty
    def domain(self***REMOVED***:
        pass

    @abstractproperty
    def window(self***REMOVED***:
        pass

    @abstractproperty
    def nickname(self***REMOVED***:
        pass

    @abstractmethod
    def _add(self***REMOVED***:
        pass

    @abstractmethod
    def _sub(self***REMOVED***:
        pass

    @abstractmethod
    def _mul(self***REMOVED***:
        pass

    @abstractmethod
    def _div(self***REMOVED***:
        pass

    @abstractmethod
    def _pow(self***REMOVED***:
        pass

    @abstractmethod
    def _val(self***REMOVED***:
        pass

    @abstractmethod
    def _int(self***REMOVED***:
        pass

    @abstractmethod
    def _der(self***REMOVED***:
        pass

    @abstractmethod
    def _fit(self***REMOVED***:
        pass

    @abstractmethod
    def _line(self***REMOVED***:
        pass

    @abstractmethod
    def _roots(self***REMOVED***:
        pass

    @abstractmethod
    def _fromroots(self***REMOVED***:
        pass

    def has_samecoef(self, other***REMOVED***:
        ***REMOVED***Check if coefficients match.

        .. versionadded:: 1.6.0

        Parameters
        ----------
        other : class instance
            The other class must have the ``coef`` attribute.

        Returns
        -------
        bool : boolean
            True if the coefficients are the same, False otherwise.

        ***REMOVED***
        if len(self.coef***REMOVED*** != len(other.coef***REMOVED***:
            return False
        elif not np.all(self.coef == other.coef***REMOVED***:
            return False
        else:
            return True

    def has_samedomain(self, other***REMOVED***:
        ***REMOVED***Check if domains match.

        .. versionadded:: 1.6.0

        Parameters
        ----------
        other : class instance
            The other class must have the ``domain`` attribute.

        Returns
        -------
        bool : boolean
            True if the domains are the same, False otherwise.

        ***REMOVED***
        return np.all(self.domain == other.domain***REMOVED***

    def has_samewindow(self, other***REMOVED***:
        ***REMOVED***Check if windows match.

        .. versionadded:: 1.6.0

        Parameters
        ----------
        other : class instance
            The other class must have the ``window`` attribute.

        Returns
        -------
        bool : boolean
            True if the windows are the same, False otherwise.

        ***REMOVED***
        return np.all(self.window == other.window***REMOVED***

    def has_sametype(self, other***REMOVED***:
        ***REMOVED***Check if types match.

        .. versionadded:: 1.7.0

        Parameters
        ----------
        other : object
            Class instance.

        Returns
        -------
        bool : boolean
            True if other is same class as self

        ***REMOVED***
        return isinstance(other, self.__class__***REMOVED***

    def _get_coefficients(self, other***REMOVED***:
        ***REMOVED***Interpret other as polynomial coefficients.

        The `other` argument is checked to see if it is of the same
        class as self with identical domain and window. If so,
        return its coefficients, otherwise return `other`.

        .. versionadded:: 1.9.0

        Parameters
        ----------
        other : anything
            Object to be checked.

        Returns
        -------
        coef:
            The coefficients of`other` if it is a compatible instance,
            of ABCPolyBase, otherwise `other`.

        Raises
        ------
        TypeError:
            When `other` is an incompatible instance of ABCPolyBase.

        ***REMOVED***
        if isinstance(other, ABCPolyBase***REMOVED***:
            if not isinstance(other, self.__class__***REMOVED***:
                raise TypeError("Polynomial types differ"***REMOVED***
            elif not np.all(self.domain == other.domain***REMOVED***:
                raise TypeError("Domains differ"***REMOVED***
            elif not np.all(self.window == other.window***REMOVED***:
                raise TypeError("Windows differ"***REMOVED***
            return other.coef
        return other

    def __init__(self, coef, domain=None, window=None***REMOVED***:
        [coef***REMOVED*** = pu.as_series([coef***REMOVED***, trim=False***REMOVED***
        self.coef = coef

        if domain is not None:
            [domain***REMOVED*** = pu.as_series([domain***REMOVED***, trim=False***REMOVED***
            if len(domain***REMOVED*** != 2:
                raise ValueError("Domain has wrong number of elements."***REMOVED***
            self.domain = domain

        if window is not None:
            [window***REMOVED*** = pu.as_series([window***REMOVED***, trim=False***REMOVED***
            if len(window***REMOVED*** != 2:
                raise ValueError("Window has wrong number of elements."***REMOVED***
            self.window = window

    def __repr__(self***REMOVED***:
        format = "%s(%s, %s, %s***REMOVED***"
        coef = repr(self.coef***REMOVED***[6:-1***REMOVED***
        domain = repr(self.domain***REMOVED***[6:-1***REMOVED***
        window = repr(self.window***REMOVED***[6:-1***REMOVED***
        name = self.__class__.__name__
        return format % (name, coef, domain, window***REMOVED***

    def __str__(self***REMOVED***:
        format = "%s(%s***REMOVED***"
        coef = str(self.coef***REMOVED***
        name = self.nickname
        return format % (name, coef***REMOVED***

    # Pickle and copy

    def __getstate__(self***REMOVED***:
        ret = self.__dict__.copy(***REMOVED***
        ret['coef'***REMOVED*** = self.coef.copy(***REMOVED***
        ret['domain'***REMOVED*** = self.domain.copy(***REMOVED***
        ret['window'***REMOVED*** = self.window.copy(***REMOVED***
        return ret

    def __setstate__(self, dict***REMOVED***:
        self.__dict__ = dict

    # Call

    def __call__(self, arg***REMOVED***:
        off, scl = pu.mapparms(self.domain, self.window***REMOVED***
        arg = off + scl*arg
        return self._val(arg, self.coef***REMOVED***

    def __iter__(self***REMOVED***:
        return iter(self.coef***REMOVED***

    def __len__(self***REMOVED***:
        return len(self.coef***REMOVED***

    # Numeric properties.

    def __neg__(self***REMOVED***:
        return self.__class__(-self.coef, self.domain, self.window***REMOVED***

    def __pos__(self***REMOVED***:
        return self

    def __add__(self, other***REMOVED***:
        ***REMOVED***
            othercoef = self._get_coefficients(other***REMOVED***
            coef = self._add(self.coef, othercoef***REMOVED***
        except TypeError as e:
            raise e
        ***REMOVED***
            return NotImplemented
        return self.__class__(coef, self.domain, self.window***REMOVED***

    def __sub__(self, other***REMOVED***:
        ***REMOVED***
            othercoef = self._get_coefficients(other***REMOVED***
            coef = self._sub(self.coef, othercoef***REMOVED***
        except TypeError as e:
            raise e
        ***REMOVED***
            return NotImplemented
        return self.__class__(coef, self.domain, self.window***REMOVED***

    def __mul__(self, other***REMOVED***:
        ***REMOVED***
            othercoef = self._get_coefficients(other***REMOVED***
            coef = self._mul(self.coef, othercoef***REMOVED***
        except TypeError as e:
            raise e
        ***REMOVED***
            return NotImplemented
        return self.__class__(coef, self.domain, self.window***REMOVED***

    def __div__(self, other***REMOVED***:
        # set to __floordiv__,  /, for now.
        return self.__floordiv__(other***REMOVED***

    def __truediv__(self, other***REMOVED***:
        # there is no true divide if the rhs is not a Number, although it
        # could return the first n elements of an infinite series.
        # It is hard to see where n would come from, though.
        if not isinstance(other, Number***REMOVED*** or isinstance(other, bool***REMOVED***:
            form = "unsupported types for true division: '%s', '%s'"
            raise TypeError(form % (type(self***REMOVED***, type(other***REMOVED******REMOVED******REMOVED***
        return self.__floordiv__(other***REMOVED***

    def __floordiv__(self, other***REMOVED***:
        res = self.__divmod__(other***REMOVED***
        if res is NotImplemented:
            return res
        return res[0***REMOVED***

    def __mod__(self, other***REMOVED***:
        res = self.__divmod__(other***REMOVED***
        if res is NotImplemented:
            return res
        return res[1***REMOVED***

    def __divmod__(self, other***REMOVED***:
        ***REMOVED***
            othercoef = self._get_coefficients(other***REMOVED***
            quo, rem = self._div(self.coef, othercoef***REMOVED***
        except (TypeError, ZeroDivisionError***REMOVED*** as e:
            raise e
        ***REMOVED***
            return NotImplemented
        quo = self.__class__(quo, self.domain, self.window***REMOVED***
        rem = self.__class__(rem, self.domain, self.window***REMOVED***
        return quo, rem

    def __pow__(self, other***REMOVED***:
        coef = self._pow(self.coef, other, maxpower=self.maxpower***REMOVED***
        res = self.__class__(coef, self.domain, self.window***REMOVED***
        return res

    def __radd__(self, other***REMOVED***:
        ***REMOVED***
            coef = self._add(other, self.coef***REMOVED***
        ***REMOVED***
            return NotImplemented
        return self.__class__(coef, self.domain, self.window***REMOVED***

    def __rsub__(self, other***REMOVED***:
        ***REMOVED***
            coef = self._sub(other, self.coef***REMOVED***
        ***REMOVED***
            return NotImplemented
        return self.__class__(coef, self.domain, self.window***REMOVED***

    def __rmul__(self, other***REMOVED***:
        ***REMOVED***
            coef = self._mul(other, self.coef***REMOVED***
        ***REMOVED***
            return NotImplemented
        return self.__class__(coef, self.domain, self.window***REMOVED***

    def __rdiv__(self, other***REMOVED***:
        # set to __floordiv__ /.
        return self.__rfloordiv__(other***REMOVED***

    def __rtruediv__(self, other***REMOVED***:
        # An instance of ABCPolyBase is not considered a
        # Number.
        return NotImplemented

    def __rfloordiv__(self, other***REMOVED***:
        res = self.__rdivmod__(other***REMOVED***
        if res is NotImplemented:
            return res
        return res[0***REMOVED***

    def __rmod__(self, other***REMOVED***:
        res = self.__rdivmod__(other***REMOVED***
        if res is NotImplemented:
            return res
        return res[1***REMOVED***

    def __rdivmod__(self, other***REMOVED***:
        ***REMOVED***
            quo, rem = self._div(other, self.coef***REMOVED***
        except ZeroDivisionError as e:
            raise e
        ***REMOVED***
            return NotImplemented
        quo = self.__class__(quo, self.domain, self.window***REMOVED***
        rem = self.__class__(rem, self.domain, self.window***REMOVED***
        return quo, rem

    # Enhance me
    # some augmented arithmetic operations could be added here

    def __eq__(self, other***REMOVED***:
        res = (isinstance(other, self.__class__***REMOVED*** and
               np.all(self.domain == other.domain***REMOVED*** and
               np.all(self.window == other.window***REMOVED*** and
               (self.coef.shape == other.coef.shape***REMOVED*** and
               np.all(self.coef == other.coef***REMOVED******REMOVED***
        return res

    def __ne__(self, other***REMOVED***:
        return not self.__eq__(other***REMOVED***

    #
    # Extra methods.
    #

    def copy(self***REMOVED***:
        ***REMOVED***Return a copy.

        Returns
        -------
        new_series : series
            Copy of self.

        ***REMOVED***
        return self.__class__(self.coef, self.domain, self.window***REMOVED***

    def degree(self***REMOVED***:
        ***REMOVED***The degree of the series.

        .. versionadded:: 1.5.0

        Returns
        -------
        degree : int
            Degree of the series, one less than the number of coefficients.

        ***REMOVED***
        return len(self***REMOVED*** - 1

    def cutdeg(self, deg***REMOVED***:
        ***REMOVED***Truncate series to the given degree.

        Reduce the degree of the series to `deg` by discarding the
        high order terms. If `deg` is greater than the current degree a
        copy of the current series is returned. This can be useful in least
        squares where the coefficients of the high degree terms may be very
        small.

        .. versionadded:: 1.5.0

        Parameters
        ----------
        deg : non-negative int
            The series is reduced to degree `deg` by discarding the high
            order terms. The value of `deg` must be a non-negative integer.

        Returns
        -------
        new_series : series
            New instance of series with reduced degree.

        ***REMOVED***
        return self.truncate(deg + 1***REMOVED***

    def trim(self, tol=0***REMOVED***:
        ***REMOVED***Remove trailing coefficients

        Remove trailing coefficients until a coefficient is reached whose
        absolute value greater than `tol` or the beginning of the series is
        reached. If all the coefficients would be removed the series is set
        to ``[0***REMOVED***``. A new series instance is returned with the new
        coefficients.  The current instance remains unchanged.

        Parameters
        ----------
        tol : non-negative number.
            All trailing coefficients less than `tol` will be removed.

        Returns
        -------
        new_series : series
            Contains the new set of coefficients.

        ***REMOVED***
        coef = pu.trimcoef(self.coef, tol***REMOVED***
        return self.__class__(coef, self.domain, self.window***REMOVED***

    def truncate(self, size***REMOVED***:
        ***REMOVED***Truncate series to length `size`.

        Reduce the series to length `size` by discarding the high
        degree terms. The value of `size` must be a positive integer. This
        can be useful in least squares where the coefficients of the
        high degree terms may be very small.

        Parameters
        ----------
        size : positive int
            The series is reduced to length `size` by discarding the high
            degree terms. The value of `size` must be a positive integer.

        Returns
        -------
        new_series : series
            New instance of series with truncated coefficients.

        ***REMOVED***
        isize = int(size***REMOVED***
        if isize != size or isize < 1:
            raise ValueError("size must be a positive integer"***REMOVED***
        if isize >= len(self.coef***REMOVED***:
            coef = self.coef
        else:
            coef = self.coef[:isize***REMOVED***
        return self.__class__(coef, self.domain, self.window***REMOVED***

    def convert(self, domain=None, kind=None, window=None***REMOVED***:
        ***REMOVED***Convert series to a different kind and/or domain and/or window.

        Parameters
        ----------
        domain : array_like, optional
            The domain of the converted series. If the value is None,
            the default domain of `kind` is used.
        kind : class, optional
            The polynomial series type class to which the current instance
            should be converted. If kind is None, then the class of the
            current instance is used.
        window : array_like, optional
            The window of the converted series. If the value is None,
            the default window of `kind` is used.

        Returns
        -------
        new_series : series
            The returned class can be of different type than the current
            instance and/or have a different domain and/or different
            window.

        Notes
        -----
        Conversion between domains and class types can result in
        numerically ill defined series.

        Examples
        --------

        ***REMOVED***
        if kind is None:
            kind = self.__class__
        if domain is None:
            domain = kind.domain
        if window is None:
            window = kind.window
        return self(kind.identity(domain, window=window***REMOVED******REMOVED***

    def mapparms(self***REMOVED***:
        ***REMOVED***Return the mapping parameters.

        The returned values define a linear map ``off + scl*x`` that is
        applied to the input arguments before the series is evaluated. The
        map depends on the ``domain`` and ``window``; if the current
        ``domain`` is equal to the ``window`` the resulting map is the
        identity.  If the coefficients of the series instance are to be
        used by themselves outside this class, then the linear function
        must be substituted for the ``x`` in the standard representation of
        the base polynomials.

        Returns
        -------
        off, scl : float or complex
            The mapping function is defined by ``off + scl*x``.

        Notes
        -----
        If the current domain is the interval ``[l1, r1***REMOVED***`` and the window
        is ``[l2, r2***REMOVED***``, then the linear mapping function ``L`` is
        defined by the equations::

            L(l1***REMOVED*** = l2
            L(r1***REMOVED*** = r2

        ***REMOVED***
        return pu.mapparms(self.domain, self.window***REMOVED***

    def integ(self, m=1, k=[***REMOVED***, lbnd=None***REMOVED***:
        ***REMOVED***Integrate.

        Return a series instance that is the definite integral of the
        current series.

        Parameters
        ----------
        m : non-negative int
            The number of integrations to perform.
        k : array_like
            Integration constants. The first constant is applied to the
            first integration, the second to the second, and so on. The
            list of values must less than or equal to `m` in length and any
            missing values are set to zero.
        lbnd : Scalar
            The lower bound of the definite integral.

        Returns
        -------
        new_series : series
            A new series representing the integral. The domain is the same
            as the domain of the integrated series.

        ***REMOVED***
        off, scl = self.mapparms(***REMOVED***
        if lbnd is None:
            lbnd = 0
        else:
            lbnd = off + scl*lbnd
        coef = self._int(self.coef, m, k, lbnd, 1./scl***REMOVED***
        return self.__class__(coef, self.domain, self.window***REMOVED***

    def deriv(self, m=1***REMOVED***:
        ***REMOVED***Differentiate.

        Return a series instance of that is the derivative of the current
        series.

        Parameters
        ----------
        m : non-negative int
            Find the derivative of order `m`.

        Returns
        -------
        new_series : series
            A new series representing the derivative. The domain is the same
            as the domain of the differentiated series.

        ***REMOVED***
        off, scl = self.mapparms(***REMOVED***
        coef = self._der(self.coef, m, scl***REMOVED***
        return self.__class__(coef, self.domain, self.window***REMOVED***

    def roots(self***REMOVED***:
        ***REMOVED***Return the roots of the series polynomial.

        Compute the roots for the series. Note that the accuracy of the
        roots decrease the further outside the domain they lie.

        Returns
        -------
        roots : ndarray
            Array containing the roots of the series.

        ***REMOVED***
        roots = self._roots(self.coef***REMOVED***
        return pu.mapdomain(roots, self.window, self.domain***REMOVED***

    def linspace(self, n=100, domain=None***REMOVED***:
        ***REMOVED***Return x, y values at equally spaced points in domain.

        Returns the x, y values at `n` linearly spaced points across the
        domain.  Here y is the value of the polynomial at the points x. By
        default the domain is the same as that of the series instance.
        This method is intended mostly as a plotting aid.

        .. versionadded:: 1.5.0

        Parameters
        ----------
        n : int, optional
            Number of point pairs to return. The default value is 100.
        domain : {None, array_like***REMOVED***, optional
            If not None, the specified domain is used instead of that of
            the calling instance. It should be of the form ``[beg,end***REMOVED***``.
            The default is None which case the class domain is used.

        Returns
        -------
        x, y : ndarray
            x is equal to linspace(self.domain[0***REMOVED***, self.domain[1***REMOVED***, n***REMOVED*** and
            y is the series evaluated at element of x.

        ***REMOVED***
        if domain is None:
            domain = self.domain
        x = np.linspace(domain[0***REMOVED***, domain[1***REMOVED***, n***REMOVED***
        y = self(x***REMOVED***
        return x, y

    @classmethod
    def fit(cls, x, y, deg, domain=None, rcond=None, full=False, w=None,
        window=None***REMOVED***:
        ***REMOVED***Least squares fit to data.

        Return a series instance that is the least squares fit to the data
        `y` sampled at `x`. The domain of the returned instance can be
        specified and this will often result in a superior fit with less
        chance of ill conditioning.

        Parameters
        ----------
        x : array_like, shape (M,***REMOVED***
            x-coordinates of the M sample points ``(x[i***REMOVED***, y[i***REMOVED******REMOVED***``.
        y : array_like, shape (M,***REMOVED*** or (M, K***REMOVED***
            y-coordinates of the sample points. Several data sets of sample
            points sharing the same x-coordinates can be fitted at once by
            passing in a 2D-array that contains one dataset per column.
        deg : int or 1-D array_like
            Degree(s***REMOVED*** of the fitting polynomials. If `deg` is a single integer
            all terms up to and including the `deg`'th term are included in the
            fit. For Numpy versions >= 1.11 a list of integers specifying the
            degrees of the terms to include may be used instead.
        domain : {None, [beg, end***REMOVED***, [***REMOVED******REMOVED***, optional
            Domain to use for the returned series. If ``None``,
            then a minimal domain that covers the points `x` is chosen.  If
            ``[***REMOVED***`` the class domain is used. The default value was the
            class domain in NumPy 1.4 and ``None`` in later versions.
            The ``[***REMOVED***`` option was added in numpy 1.5.0.
        rcond : float, optional
            Relative condition number of the fit. Singular values smaller
            than this relative to the largest singular value will be
            ignored. The default value is len(x***REMOVED****eps, where eps is the
            relative precision of the float type, about 2e-16 in most
            cases.
        full : bool, optional
            Switch determining nature of return value. When it is False
            (the default***REMOVED*** just the coefficients are returned, when True
            diagnostic information from the singular value decomposition is
            also returned.
        w : array_like, shape (M,***REMOVED***, optional
            Weights. If not None the contribution of each point
            ``(x[i***REMOVED***,y[i***REMOVED******REMOVED***`` to the fit is weighted by `w[i***REMOVED***`. Ideally the
            weights are chosen so that the errors of the products
            ``w[i***REMOVED****y[i***REMOVED***`` all have the same variance.  The default value is
            None.

            .. versionadded:: 1.5.0
        window : {[beg, end***REMOVED******REMOVED***, optional
            Window to use for the returned series. The default
            value is the default class domain

            .. versionadded:: 1.6.0

        Returns
        -------
        new_series : series
            A series that represents the least squares fit to the data and
            has the domain specified in the call.

        [resid, rank, sv, rcond***REMOVED*** : list
            These values are only returned if `full` = True

            resid -- sum of squared residuals of the least squares fit
            rank -- the numerical rank of the scaled Vandermonde matrix
            sv -- singular values of the scaled Vandermonde matrix
            rcond -- value of `rcond`.

            For more details, see `linalg.lstsq`.

        ***REMOVED***
        if domain is None:
            domain = pu.getdomain(x***REMOVED***
        elif type(domain***REMOVED*** is list and len(domain***REMOVED*** == 0:
            domain = cls.domain

        if window is None:
            window = cls.window

        xnew = pu.mapdomain(x, domain, window***REMOVED***
        res = cls._fit(xnew, y, deg, w=w, rcond=rcond, full=full***REMOVED***
        if full:
            [coef, status***REMOVED*** = res
            return cls(coef, domain=domain, window=window***REMOVED***, status
        else:
            coef = res
            return cls(coef, domain=domain, window=window***REMOVED***

    @classmethod
    def fromroots(cls, roots, domain=[***REMOVED***, window=None***REMOVED***:
        ***REMOVED***Return series instance that has the specified roots.

        Returns a series representing the product
        ``(x - r[0***REMOVED******REMOVED****(x - r[1***REMOVED******REMOVED****...*(x - r[n-1***REMOVED******REMOVED***``, where ``r`` is a
        list of roots.

        Parameters
        ----------
        roots : array_like
            List of roots.
        domain : {[***REMOVED***, None, array_like***REMOVED***, optional
            Domain for the resulting series. If None the domain is the
            interval from the smallest root to the largest. If [***REMOVED*** the
            domain is the class domain. The default is [***REMOVED***.
        window : {None, array_like***REMOVED***, optional
            Window for the returned series. If None the class window is
            used. The default is None.

        Returns
        -------
        new_series : series
            Series with the specified roots.

        ***REMOVED***
        [roots***REMOVED*** = pu.as_series([roots***REMOVED***, trim=False***REMOVED***
        if domain is None:
            domain = pu.getdomain(roots***REMOVED***
        elif type(domain***REMOVED*** is list and len(domain***REMOVED*** == 0:
            domain = cls.domain

        if window is None:
            window = cls.window

        deg = len(roots***REMOVED***
        off, scl = pu.mapparms(domain, window***REMOVED***
        rnew = off + scl*roots
        coef = cls._fromroots(rnew***REMOVED*** / scl**deg
        return cls(coef, domain=domain, window=window***REMOVED***

    @classmethod
    def identity(cls, domain=None, window=None***REMOVED***:
        ***REMOVED***Identity function.

        If ``p`` is the returned series, then ``p(x***REMOVED*** == x`` for all
        values of x.

        Parameters
        ----------
        domain : {None, array_like***REMOVED***, optional
            If given, the array must be of the form ``[beg, end***REMOVED***``, where
            ``beg`` and ``end`` are the endpoints of the domain. If None is
            given then the class domain is used. The default is None.
        window : {None, array_like***REMOVED***, optional
            If given, the resulting array must be if the form
            ``[beg, end***REMOVED***``, where ``beg`` and ``end`` are the endpoints of
            the window. If None is given then the class window is used. The
            default is None.

        Returns
        -------
        new_series : series
             Series of representing the identity.

        ***REMOVED***
        if domain is None:
            domain = cls.domain
        if window is None:
            window = cls.window
        off, scl = pu.mapparms(window, domain***REMOVED***
        coef = cls._line(off, scl***REMOVED***
        return cls(coef, domain, window***REMOVED***

    @classmethod
    def basis(cls, deg, domain=None, window=None***REMOVED***:
        ***REMOVED***Series basis polynomial of degree `deg`.

        Returns the series representing the basis polynomial of degree `deg`.

        .. versionadded:: 1.7.0

        Parameters
        ----------
        deg : int
            Degree of the basis polynomial for the series. Must be >= 0.
        domain : {None, array_like***REMOVED***, optional
            If given, the array must be of the form ``[beg, end***REMOVED***``, where
            ``beg`` and ``end`` are the endpoints of the domain. If None is
            given then the class domain is used. The default is None.
        window : {None, array_like***REMOVED***, optional
            If given, the resulting array must be if the form
            ``[beg, end***REMOVED***``, where ``beg`` and ``end`` are the endpoints of
            the window. If None is given then the class window is used. The
            default is None.

        Returns
        -------
        new_series : series
            A series with the coefficient of the `deg` term set to one and
            all others zero.

        ***REMOVED***
        if domain is None:
            domain = cls.domain
        if window is None:
            window = cls.window
        ideg = int(deg***REMOVED***

        if ideg != deg or ideg < 0:
            raise ValueError("deg must be non-negative integer"***REMOVED***
        return cls([0***REMOVED****ideg + [1***REMOVED***, domain, window***REMOVED***

    @classmethod
    def cast(cls, series, domain=None, window=None***REMOVED***:
        ***REMOVED***Convert series to series of this class.

        The `series` is expected to be an instance of some polynomial
        series of one of the types supported by by the numpy.polynomial
        module, but could be some other class that supports the convert
        method.

        .. versionadded:: 1.7.0

        Parameters
        ----------
        series : series
            The series instance to be converted.
        domain : {None, array_like***REMOVED***, optional
            If given, the array must be of the form ``[beg, end***REMOVED***``, where
            ``beg`` and ``end`` are the endpoints of the domain. If None is
            given then the class domain is used. The default is None.
        window : {None, array_like***REMOVED***, optional
            If given, the resulting array must be if the form
            ``[beg, end***REMOVED***``, where ``beg`` and ``end`` are the endpoints of
            the window. If None is given then the class window is used. The
            default is None.

        Returns
        -------
        new_series : series
            A series of the same kind as the calling class and equal to
            `series` when evaluated.

        See Also
        --------
        convert : similar instance method

        ***REMOVED***
        if domain is None:
            domain = cls.domain
        if window is None:
            window = cls.window
        return series.convert(domain, cls, window***REMOVED***
