***REMOVED***Lite version of scipy.linalg.

Notes
-----
This module is a lite version of the linalg.py module in SciPy which
contains high-level Python interface to the LAPACK library.  The lite
version only accesses the following LAPACK functions: dgesv, zgesv,
dgeev, zgeev, dgesdd, zgesdd, dgelsd, zgelsd, dsyevd, zheevd, dgetrf,
zgetrf, dpotrf, zpotrf, dgeqrf, zgeqrf, zungqr, dorgqr.
***REMOVED***
from __future__ import division, absolute_import, print_function


__all__ = ['matrix_power', 'solve', 'tensorsolve', 'tensorinv', 'inv',
           'cholesky', 'eigvals', 'eigvalsh', 'pinv', 'slogdet', 'det',
           'svd', 'eig', 'eigh', 'lstsq', 'norm', 'qr', 'cond', 'matrix_rank',
           'LinAlgError', 'multi_dot'***REMOVED***

import warnings

from numpy.core import (
    array, asarray, zeros, empty, empty_like, transpose, intc, single, double,
    csingle, cdouble, inexact, complexfloating, newaxis, ravel, all, Inf, dot,
    add, multiply, sqrt, maximum, fastCopyAndTranspose, sum, isfinite, size,
    finfo, errstate, geterrobj, longdouble, rollaxis, amin, amax, product, abs,
    broadcast, atleast_2d, intp, asanyarray, isscalar, object_
    ***REMOVED***
from numpy.lib import triu, asfarray
from numpy.linalg import lapack_lite, _umath_linalg
from numpy.matrixlib.defmatrix import matrix_power
from numpy.compat import asbytes

# For Python2/3 compatibility
_N = asbytes('N'***REMOVED***
_V = asbytes('V'***REMOVED***
_A = asbytes('A'***REMOVED***
_S = asbytes('S'***REMOVED***
_L = asbytes('L'***REMOVED***

fortran_int = intc

# Error object
class LinAlgError(Exception***REMOVED***:
    ***REMOVED***
    Generic Python-exception-derived object raised by linalg functions.

    General purpose exception class, derived from Python's exception.Exception
    class, programmatically raised in linalg functions when a Linear
    Algebra-related condition would prevent further correct execution of the
    function.

    Parameters
    ----------
    None

    Examples
    --------
    >>> from numpy import linalg as LA
    >>> LA.inv(np.zeros((2,2***REMOVED******REMOVED******REMOVED***
    Traceback (most recent call last***REMOVED***:
      File "<stdin>", line 1, in <module>
      File "...linalg.py", line 350,
        in inv return wrap(solve(a, identity(a.shape[0***REMOVED***, dtype=a.dtype***REMOVED******REMOVED******REMOVED***
      File "...linalg.py", line 249,
        in solve
        raise LinAlgError('Singular matrix'***REMOVED***
    numpy.linalg.LinAlgError: Singular matrix

    ***REMOVED***
    pass

# Dealing with errors in _umath_linalg

_linalg_error_extobj = None

def _determine_error_states(***REMOVED***:
    global _linalg_error_extobj
    errobj = geterrobj(***REMOVED***
    bufsize = errobj[0***REMOVED***

    with errstate(invalid='call', over='ignore',
                  divide='ignore', under='ignore'***REMOVED***:
        invalid_call_errmask = geterrobj(***REMOVED***[1***REMOVED***

    _linalg_error_extobj = [bufsize, invalid_call_errmask, None***REMOVED***

_determine_error_states(***REMOVED***

def _raise_linalgerror_singular(err, flag***REMOVED***:
    raise LinAlgError("Singular matrix"***REMOVED***

def _raise_linalgerror_nonposdef(err, flag***REMOVED***:
    raise LinAlgError("Matrix is not positive definite"***REMOVED***

def _raise_linalgerror_eigenvalues_nonconvergence(err, flag***REMOVED***:
    raise LinAlgError("Eigenvalues did not converge"***REMOVED***

def _raise_linalgerror_svd_nonconvergence(err, flag***REMOVED***:
    raise LinAlgError("SVD did not converge"***REMOVED***

def get_linalg_error_extobj(callback***REMOVED***:
    extobj = list(_linalg_error_extobj***REMOVED***
    extobj[2***REMOVED*** = callback
    return extobj

def _makearray(a***REMOVED***:
    new = asarray(a***REMOVED***
    wrap = getattr(a, "__array_prepare__", new.__array_wrap__***REMOVED***
    return new, wrap

def isComplexType(t***REMOVED***:
    return issubclass(t, complexfloating***REMOVED***

_real_types_map = {single : single,
                   double : double,
                   csingle : single,
                   cdouble : double***REMOVED***

_complex_types_map = {single : csingle,
                      double : cdouble,
                      csingle : csingle,
                      cdouble : cdouble***REMOVED***

def _realType(t, default=double***REMOVED***:
    return _real_types_map.get(t, default***REMOVED***

def _complexType(t, default=cdouble***REMOVED***:
    return _complex_types_map.get(t, default***REMOVED***

def _linalgRealType(t***REMOVED***:
    ***REMOVED***Cast the type t to either double or cdouble.***REMOVED***
    return double

_complex_types_map = {single : csingle,
                      double : cdouble,
                      csingle : csingle,
                      cdouble : cdouble***REMOVED***

def _commonType(*arrays***REMOVED***:
    # in lite version, use higher precision (always double or cdouble***REMOVED***
    result_type = single
    is_complex = False
    for a in arrays:
        if issubclass(a.dtype.type, inexact***REMOVED***:
            if isComplexType(a.dtype.type***REMOVED***:
                is_complex = True
            rt = _realType(a.dtype.type, default=None***REMOVED***
            if rt is None:
                # unsupported inexact scalar
                raise TypeError("array type %s is unsupported in linalg" %
                        (a.dtype.name,***REMOVED******REMOVED***
        else:
            rt = double
        if rt is double:
            result_type = double
    if is_complex:
        t = cdouble
        result_type = _complex_types_map[result_type***REMOVED***
    else:
        t = double
    return t, result_type


# _fastCopyAndTranpose assumes the input is 2D (as all the calls in here are***REMOVED***.

_fastCT = fastCopyAndTranspose

def _to_native_byte_order(*arrays***REMOVED***:
    ret = [***REMOVED***
    for arr in arrays:
        if arr.dtype.byteorder not in ('=', '|'***REMOVED***:
            ret.append(asarray(arr, dtype=arr.dtype.newbyteorder('='***REMOVED******REMOVED******REMOVED***
        else:
            ret.append(arr***REMOVED***
    if len(ret***REMOVED*** == 1:
        return ret[0***REMOVED***
    else:
        return ret

def _fastCopyAndTranspose(type, *arrays***REMOVED***:
    cast_arrays = (***REMOVED***
    for a in arrays:
        if a.dtype.type is type:
            cast_arrays = cast_arrays + (_fastCT(a***REMOVED***,***REMOVED***
        else:
            cast_arrays = cast_arrays + (_fastCT(a.astype(type***REMOVED******REMOVED***,***REMOVED***
    if len(cast_arrays***REMOVED*** == 1:
        return cast_arrays[0***REMOVED***
    else:
        return cast_arrays

def _assertRank2(*arrays***REMOVED***:
    for a in arrays:
        if len(a.shape***REMOVED*** != 2:
            raise LinAlgError('%d-dimensional array given. Array must be '
                    'two-dimensional' % len(a.shape***REMOVED******REMOVED***

def _assertRankAtLeast2(*arrays***REMOVED***:
    for a in arrays:
        if len(a.shape***REMOVED*** < 2:
            raise LinAlgError('%d-dimensional array given. Array must be '
                    'at least two-dimensional' % len(a.shape***REMOVED******REMOVED***

def _assertSquareness(*arrays***REMOVED***:
    for a in arrays:
        if max(a.shape***REMOVED*** != min(a.shape***REMOVED***:
            raise LinAlgError('Array must be square'***REMOVED***

def _assertNdSquareness(*arrays***REMOVED***:
    for a in arrays:
        if max(a.shape[-2:***REMOVED******REMOVED*** != min(a.shape[-2:***REMOVED******REMOVED***:
            raise LinAlgError('Last 2 dimensions of the array must be square'***REMOVED***

def _assertFinite(*arrays***REMOVED***:
    for a in arrays:
        if not (isfinite(a***REMOVED***.all(***REMOVED******REMOVED***:
            raise LinAlgError("Array must not contain infs or NaNs"***REMOVED***

def _assertNoEmpty2d(*arrays***REMOVED***:
    for a in arrays:
        if a.size == 0 and product(a.shape[-2:***REMOVED******REMOVED*** == 0:
            raise LinAlgError("Arrays cannot be empty"***REMOVED***


# Linear equations

def tensorsolve(a, b, axes=None***REMOVED***:
    ***REMOVED***
    Solve the tensor equation ``a x = b`` for x.

    It is assumed that all indices of `x` are summed over in the product,
    together with the rightmost indices of `a`, as is done in, for example,
    ``tensordot(a, x, axes=len(b.shape***REMOVED******REMOVED***``.

    Parameters
    ----------
    a : array_like
        Coefficient tensor, of shape ``b.shape + Q``. `Q`, a tuple, equals
        the shape of that sub-tensor of `a` consisting of the appropriate
        number of its rightmost indices, and must be such that
        ``prod(Q***REMOVED*** == prod(b.shape***REMOVED***`` (in which sense `a` is said to be
        'square'***REMOVED***.
    b : array_like
        Right-hand tensor, which can be of any shape.
    axes : tuple of ints, optional
        Axes in `a` to reorder to the right, before inversion.
        If None (default***REMOVED***, no reordering is done.

    Returns
    -------
    x : ndarray, shape Q

    Raises
    ------
    LinAlgError
        If `a` is singular or not 'square' (in the above sense***REMOVED***.

    See Also
    --------
    tensordot, tensorinv, einsum

    Examples
    --------
    >>> a = np.eye(2*3*4***REMOVED***
    >>> a.shape = (2*3, 4, 2, 3, 4***REMOVED***
    >>> b = np.random.randn(2*3, 4***REMOVED***
    >>> x = np.linalg.tensorsolve(a, b***REMOVED***
    >>> x.shape
    (2, 3, 4***REMOVED***
    >>> np.allclose(np.tensordot(a, x, axes=3***REMOVED***, b***REMOVED***
    True

    ***REMOVED***
    a, wrap = _makearray(a***REMOVED***
    b = asarray(b***REMOVED***
    an = a.ndim

    if axes is not None:
        allaxes = list(range(0, an***REMOVED******REMOVED***
        for k in axes:
            allaxes.remove(k***REMOVED***
            allaxes.insert(an, k***REMOVED***
        a = a.transpose(allaxes***REMOVED***

    oldshape = a.shape[-(an-b.ndim***REMOVED***:***REMOVED***
    prod = 1
    for k in oldshape:
        prod *= k

    a = a.reshape(-1, prod***REMOVED***
    b = b.ravel(***REMOVED***
    res = wrap(solve(a, b***REMOVED******REMOVED***
    res.shape = oldshape
    return res

def solve(a, b***REMOVED***:
    ***REMOVED***
    Solve a linear matrix equation, or system of linear scalar equations.

    Computes the "exact" solution, `x`, of the well-determined, i.e., full
    rank, linear matrix equation `ax = b`.

    Parameters
    ----------
    a : (..., M, M***REMOVED*** array_like
        Coefficient matrix.
    b : {(..., M,***REMOVED***, (..., M, K***REMOVED******REMOVED***, array_like
        Ordinate or "dependent variable" values.

    Returns
    -------
    x : {(..., M,***REMOVED***, (..., M, K***REMOVED******REMOVED*** ndarray
        Solution to the system a x = b.  Returned shape is identical to `b`.

    Raises
    ------
    LinAlgError
        If `a` is singular or not square.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    The solutions are computed using LAPACK routine _gesv

    `a` must be square and of full-rank, i.e., all rows (or, equivalently,
    columns***REMOVED*** must be linearly independent; if either is not true, use
    `lstsq` for the least-squares best "solution" of the
    system/equation.

    References
    ----------
    .. [1***REMOVED*** G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando,
           FL, Academic Press, Inc., 1980, pg. 22.

    Examples
    --------
    Solve the system of equations ``3 * x0 + x1 = 9`` and ``x0 + 2 * x1 = 8``:

    >>> a = np.array([[3,1***REMOVED***, [1,2***REMOVED******REMOVED******REMOVED***
    >>> b = np.array([9,8***REMOVED******REMOVED***
    >>> x = np.linalg.solve(a, b***REMOVED***
    >>> x
    array([ 2.,  3.***REMOVED******REMOVED***

    Check that the solution is correct:

    >>> np.allclose(np.dot(a, x***REMOVED***, b***REMOVED***
    True

    ***REMOVED***
    a, _ = _makearray(a***REMOVED***
    _assertRankAtLeast2(a***REMOVED***
    _assertNdSquareness(a***REMOVED***
    b, wrap = _makearray(b***REMOVED***
    t, result_t = _commonType(a, b***REMOVED***

    # We use the b = (..., M,***REMOVED*** logic, only if the number of extra dimensions
    # match exactly
    if b.ndim == a.ndim - 1:
        if a.shape[-1***REMOVED*** == 0 and b.shape[-1***REMOVED*** == 0:
            # Legal, but the ufunc cannot handle the 0-sized inner dims
            # let the ufunc handle all wrong cases.
            a = a.reshape(a.shape[:-1***REMOVED******REMOVED***
            bc = broadcast(a, b***REMOVED***
            return wrap(empty(bc.shape, dtype=result_t***REMOVED******REMOVED***

        gufunc = _umath_linalg.solve1
    else:
        if b.size == 0:
            if (a.shape[-1***REMOVED*** == 0 and b.shape[-2***REMOVED*** == 0***REMOVED*** or b.shape[-1***REMOVED*** == 0:
                a = a[:,:1***REMOVED***.reshape(a.shape[:-1***REMOVED*** + (1,***REMOVED******REMOVED***
                bc = broadcast(a, b***REMOVED***
                return wrap(empty(bc.shape, dtype=result_t***REMOVED******REMOVED***

        gufunc = _umath_linalg.solve

    signature = 'DD->D' if isComplexType(t***REMOVED*** else 'dd->d'
    extobj = get_linalg_error_extobj(_raise_linalgerror_singular***REMOVED***
    r = gufunc(a, b, signature=signature, extobj=extobj***REMOVED***

    return wrap(r.astype(result_t, copy=False***REMOVED******REMOVED***


def tensorinv(a, ind=2***REMOVED***:
    ***REMOVED***
    Compute the 'inverse' of an N-dimensional array.

    The result is an inverse for `a` relative to the tensordot operation
    ``tensordot(a, b, ind***REMOVED***``, i. e., up to floating-point accuracy,
    ``tensordot(tensorinv(a***REMOVED***, a, ind***REMOVED***`` is the "identity" tensor for the
    tensordot operation.

    Parameters
    ----------
    a : array_like
        Tensor to 'invert'. Its shape must be 'square', i. e.,
        ``prod(a.shape[:ind***REMOVED******REMOVED*** == prod(a.shape[ind:***REMOVED******REMOVED***``.
    ind : int, optional
        Number of first indices that are involved in the inverse sum.
        Must be a positive integer, default is 2.

    Returns
    -------
    b : ndarray
        `a`'s tensordot inverse, shape ``a.shape[ind:***REMOVED*** + a.shape[:ind***REMOVED***``.

    Raises
    ------
    LinAlgError
        If `a` is singular or not 'square' (in the above sense***REMOVED***.

    See Also
    --------
    tensordot, tensorsolve

    Examples
    --------
    >>> a = np.eye(4*6***REMOVED***
    >>> a.shape = (4, 6, 8, 3***REMOVED***
    >>> ainv = np.linalg.tensorinv(a, ind=2***REMOVED***
    >>> ainv.shape
    (8, 3, 4, 6***REMOVED***
    >>> b = np.random.randn(4, 6***REMOVED***
    >>> np.allclose(np.tensordot(ainv, b***REMOVED***, np.linalg.tensorsolve(a, b***REMOVED******REMOVED***
    True

    >>> a = np.eye(4*6***REMOVED***
    >>> a.shape = (24, 8, 3***REMOVED***
    >>> ainv = np.linalg.tensorinv(a, ind=1***REMOVED***
    >>> ainv.shape
    (8, 3, 24***REMOVED***
    >>> b = np.random.randn(24***REMOVED***
    >>> np.allclose(np.tensordot(ainv, b, 1***REMOVED***, np.linalg.tensorsolve(a, b***REMOVED******REMOVED***
    True

    ***REMOVED***
    a = asarray(a***REMOVED***
    oldshape = a.shape
    prod = 1
    if ind > 0:
        invshape = oldshape[ind:***REMOVED*** + oldshape[:ind***REMOVED***
        for k in oldshape[ind:***REMOVED***:
            prod *= k
    else:
        raise ValueError("Invalid ind argument."***REMOVED***
    a = a.reshape(prod, -1***REMOVED***
    ia = inv(a***REMOVED***
    return ia.reshape(*invshape***REMOVED***


# Matrix inversion

def inv(a***REMOVED***:
    ***REMOVED***
    Compute the (multiplicative***REMOVED*** inverse of a matrix.

    Given a square matrix `a`, return the matrix `ainv` satisfying
    ``dot(a, ainv***REMOVED*** = dot(ainv, a***REMOVED*** = eye(a.shape[0***REMOVED******REMOVED***``.

    Parameters
    ----------
    a : (..., M, M***REMOVED*** array_like
        Matrix to be inverted.

    Returns
    -------
    ainv : (..., M, M***REMOVED*** ndarray or matrix
        (Multiplicative***REMOVED*** inverse of the matrix `a`.

    Raises
    ------
    LinAlgError
        If `a` is not square or inversion fails.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    Examples
    --------
    >>> from numpy.linalg import inv
    >>> a = np.array([[1., 2.***REMOVED***, [3., 4.***REMOVED******REMOVED******REMOVED***
    >>> ainv = inv(a***REMOVED***
    >>> np.allclose(np.dot(a, ainv***REMOVED***, np.eye(2***REMOVED******REMOVED***
    True
    >>> np.allclose(np.dot(ainv, a***REMOVED***, np.eye(2***REMOVED******REMOVED***
    True

    If a is a matrix object, then the return value is a matrix as well:

    >>> ainv = inv(np.matrix(a***REMOVED******REMOVED***
    >>> ainv
    matrix([[-2. ,  1. ***REMOVED***,
            [ 1.5, -0.5***REMOVED******REMOVED******REMOVED***

    Inverses of several matrices can be computed at once:

    >>> a = np.array([[[1., 2.***REMOVED***, [3., 4.***REMOVED******REMOVED***, [[1, 3***REMOVED***, [3, 5***REMOVED******REMOVED******REMOVED******REMOVED***
    >>> inv(a***REMOVED***
    array([[[-2. ,  1. ***REMOVED***,
            [ 1.5, -0.5***REMOVED******REMOVED***,
           [[-5. ,  2. ***REMOVED***,
            [ 3. , -1. ***REMOVED******REMOVED******REMOVED******REMOVED***

    ***REMOVED***
    a, wrap = _makearray(a***REMOVED***
    _assertRankAtLeast2(a***REMOVED***
    _assertNdSquareness(a***REMOVED***
    t, result_t = _commonType(a***REMOVED***

    if a.shape[-1***REMOVED*** == 0:
        # The inner array is 0x0, the ufunc cannot handle this case
        return wrap(empty_like(a, dtype=result_t***REMOVED******REMOVED***

    signature = 'D->D' if isComplexType(t***REMOVED*** else 'd->d'
    extobj = get_linalg_error_extobj(_raise_linalgerror_singular***REMOVED***
    ainv = _umath_linalg.inv(a, signature=signature, extobj=extobj***REMOVED***
    return wrap(ainv.astype(result_t, copy=False***REMOVED******REMOVED***


# Cholesky decomposition

def cholesky(a***REMOVED***:
    ***REMOVED***
    Cholesky decomposition.

    Return the Cholesky decomposition, `L * L.H`, of the square matrix `a`,
    where `L` is lower-triangular and .H is the conjugate transpose operator
    (which is the ordinary transpose if `a` is real-valued***REMOVED***.  `a` must be
    Hermitian (symmetric if real-valued***REMOVED*** and positive-definite.  Only `L` is
    actually returned.

    Parameters
    ----------
    a : (..., M, M***REMOVED*** array_like
        Hermitian (symmetric if all elements are real***REMOVED***, positive-definite
        input matrix.

    Returns
    -------
    L : (..., M, M***REMOVED*** array_like
        Upper or lower-triangular Cholesky factor of `a`.  Returns a
        matrix object if `a` is a matrix object.

    Raises
    ------
    LinAlgError
       If the decomposition fails, for example, if `a` is not
       positive-definite.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    The Cholesky decomposition is often used as a fast way of solving

    .. math:: A \\mathbf{x***REMOVED*** = \\mathbf{b***REMOVED***

    (when `A` is both Hermitian/symmetric and positive-definite***REMOVED***.

    First, we solve for :math:`\\mathbf{y***REMOVED***` in

    .. math:: L \\mathbf{y***REMOVED*** = \\mathbf{b***REMOVED***,

    and then for :math:`\\mathbf{x***REMOVED***` in

    .. math:: L.H \\mathbf{x***REMOVED*** = \\mathbf{y***REMOVED***.

    Examples
    --------
    >>> A = np.array([[1,-2j***REMOVED***,[2j,5***REMOVED******REMOVED******REMOVED***
    >>> A
    array([[ 1.+0.j,  0.-2.j***REMOVED***,
           [ 0.+2.j,  5.+0.j***REMOVED******REMOVED******REMOVED***
    >>> L = np.linalg.cholesky(A***REMOVED***
    >>> L
    array([[ 1.+0.j,  0.+0.j***REMOVED***,
           [ 0.+2.j,  1.+0.j***REMOVED******REMOVED******REMOVED***
    >>> np.dot(L, L.T.conj(***REMOVED******REMOVED*** # verify that L * L.H = A
    array([[ 1.+0.j,  0.-2.j***REMOVED***,
           [ 0.+2.j,  5.+0.j***REMOVED******REMOVED******REMOVED***
    >>> A = [[1,-2j***REMOVED***,[2j,5***REMOVED******REMOVED*** # what happens if A is only array_like?
    >>> np.linalg.cholesky(A***REMOVED*** # an ndarray object is returned
    array([[ 1.+0.j,  0.+0.j***REMOVED***,
           [ 0.+2.j,  1.+0.j***REMOVED******REMOVED******REMOVED***
    >>> # But a matrix object is returned if A is a matrix object
    >>> LA.cholesky(np.matrix(A***REMOVED******REMOVED***
    matrix([[ 1.+0.j,  0.+0.j***REMOVED***,
            [ 0.+2.j,  1.+0.j***REMOVED******REMOVED******REMOVED***

    ***REMOVED***
    extobj = get_linalg_error_extobj(_raise_linalgerror_nonposdef***REMOVED***
    gufunc = _umath_linalg.cholesky_lo
    a, wrap = _makearray(a***REMOVED***
    _assertRankAtLeast2(a***REMOVED***
    _assertNdSquareness(a***REMOVED***
    t, result_t = _commonType(a***REMOVED***
    signature = 'D->D' if isComplexType(t***REMOVED*** else 'd->d'
    r = gufunc(a, signature=signature, extobj=extobj***REMOVED***
    return wrap(r.astype(result_t, copy=False***REMOVED******REMOVED***

# QR decompostion

def qr(a, mode='reduced'***REMOVED***:
    ***REMOVED***
    Compute the qr factorization of a matrix.

    Factor the matrix `a` as *qr*, where `q` is orthonormal and `r` is
    upper-triangular.

    Parameters
    ----------
    a : array_like, shape (M, N***REMOVED***
        Matrix to be factored.
    mode : {'reduced', 'complete', 'r', 'raw', 'full', 'economic'***REMOVED***, optional
        If K = min(M, N***REMOVED***, then

        'reduced'  : returns q, r with dimensions (M, K***REMOVED***, (K, N***REMOVED*** (default***REMOVED***
        'complete' : returns q, r with dimensions (M, M***REMOVED***, (M, N***REMOVED***
        'r'        : returns r only with dimensions (K, N***REMOVED***
        'raw'      : returns h, tau with dimensions (N, M***REMOVED***, (K,***REMOVED***
        'full'     : alias of 'reduced', deprecated
        'economic' : returns h from 'raw', deprecated.

        The options 'reduced', 'complete, and 'raw' are new in numpy 1.8,
        see the notes for more information. The default is 'reduced' and to
        maintain backward compatibility with earlier versions of numpy both
        it and the old default 'full' can be omitted. Note that array h
        returned in 'raw' mode is transposed for calling Fortran. The
        'economic' mode is deprecated.  The modes 'full' and 'economic' may
        be passed using only the first letter for backwards compatibility,
        but all others must be spelled out. See the Notes for more
        explanation.


    Returns
    -------
    q : ndarray of float or complex, optional
        A matrix with orthonormal columns. When mode = 'complete' the
        result is an orthogonal/unitary matrix depending on whether or not
        a is real/complex. The determinant may be either +/- 1 in that
        case.
    r : ndarray of float or complex, optional
        The upper-triangular matrix.
    (h, tau***REMOVED*** : ndarrays of np.double or np.cdouble, optional
        The array h contains the Householder reflectors that generate q
        along with r. The tau array contains scaling factors for the
        reflectors. In the deprecated  'economic' mode only h is returned.

    Raises
    ------
    LinAlgError
        If factoring fails.

    Notes
    -----
    This is an interface to the LAPACK routines dgeqrf, zgeqrf,
    dorgqr, and zungqr.

    For more information on the qr factorization, see for example:
    http://en.wikipedia.org/wiki/QR_factorization

    Subclasses of `ndarray` are preserved except for the 'raw' mode. So if
    `a` is of type `matrix`, all the return values will be matrices too.

    New 'reduced', 'complete', and 'raw' options for mode were added in
    Numpy 1.8 and the old option 'full' was made an alias of 'reduced'.  In
    addition the options 'full' and 'economic' were deprecated.  Because
    'full' was the previous default and 'reduced' is the new default,
    backward compatibility can be maintained by letting `mode` default.
    The 'raw' option was added so that LAPACK routines that can multiply
    arrays by q using the Householder reflectors can be used. Note that in
    this case the returned arrays are of type np.double or np.cdouble and
    the h array is transposed to be FORTRAN compatible.  No routines using
    the 'raw' return are currently exposed by numpy, but some are available
    in lapack_lite and just await the necessary work.

    Examples
    --------
    >>> a = np.random.randn(9, 6***REMOVED***
    >>> q, r = np.linalg.qr(a***REMOVED***
    >>> np.allclose(a, np.dot(q, r***REMOVED******REMOVED***  # a does equal qr
    True
    >>> r2 = np.linalg.qr(a, mode='r'***REMOVED***
    >>> r3 = np.linalg.qr(a, mode='economic'***REMOVED***
    >>> np.allclose(r, r2***REMOVED***  # mode='r' returns the same r as mode='full'
    True
    >>> # But only triu parts are guaranteed equal when mode='economic'
    >>> np.allclose(r, np.triu(r3[:6,:6***REMOVED***, k=0***REMOVED******REMOVED***
    True

    Example illustrating a common use of `qr`: solving of least squares
    problems

    What are the least-squares-best `m` and `y0` in ``y = y0 + mx`` for
    the following data: {(0,1***REMOVED***, (1,0***REMOVED***, (1,2***REMOVED***, (2,1***REMOVED******REMOVED***. (Graph the points
    and you'll see that it should be y0 = 0, m = 1.***REMOVED***  The answer is provided
    by solving the over-determined matrix equation ``Ax = b``, where::

      A = array([[0, 1***REMOVED***, [1, 1***REMOVED***, [1, 1***REMOVED***, [2, 1***REMOVED******REMOVED******REMOVED***
      x = array([[y0***REMOVED***, [m***REMOVED******REMOVED******REMOVED***
      b = array([[1***REMOVED***, [0***REMOVED***, [2***REMOVED***, [1***REMOVED******REMOVED******REMOVED***

    If A = qr such that q is orthonormal (which is always possible via
    Gram-Schmidt***REMOVED***, then ``x = inv(r***REMOVED*** * (q.T***REMOVED*** * b``.  (In numpy practice,
    however, we simply use `lstsq`.***REMOVED***

    >>> A = np.array([[0, 1***REMOVED***, [1, 1***REMOVED***, [1, 1***REMOVED***, [2, 1***REMOVED******REMOVED******REMOVED***
    >>> A
    array([[0, 1***REMOVED***,
           [1, 1***REMOVED***,
           [1, 1***REMOVED***,
           [2, 1***REMOVED******REMOVED******REMOVED***
    >>> b = np.array([1, 0, 2, 1***REMOVED******REMOVED***
    >>> q, r = LA.qr(A***REMOVED***
    >>> p = np.dot(q.T, b***REMOVED***
    >>> np.dot(LA.inv(r***REMOVED***, p***REMOVED***
    array([  1.1e-16,   1.0e+00***REMOVED******REMOVED***

    ***REMOVED***
    if mode not in ('reduced', 'complete', 'r', 'raw'***REMOVED***:
        if mode in ('f', 'full'***REMOVED***:
            # 2013-04-01, 1.8
            msg = "".join((
                    "The 'full' option is deprecated in favor of 'reduced'.\n",
                    "For backward compatibility let mode default."***REMOVED******REMOVED***
            warnings.warn(msg, DeprecationWarning***REMOVED***
            mode = 'reduced'
        elif mode in ('e', 'economic'***REMOVED***:
            # 2013-04-01, 1.8
            msg = "The 'economic' option is deprecated.",
            warnings.warn(msg, DeprecationWarning***REMOVED***
            mode = 'economic'
        else:
            raise ValueError("Unrecognized mode '%s'" % mode***REMOVED***

    a, wrap = _makearray(a***REMOVED***
    _assertRank2(a***REMOVED***
    _assertNoEmpty2d(a***REMOVED***
    m, n = a.shape
    t, result_t = _commonType(a***REMOVED***
    a = _fastCopyAndTranspose(t, a***REMOVED***
    a = _to_native_byte_order(a***REMOVED***
    mn = min(m, n***REMOVED***
    tau = zeros((mn,***REMOVED***, t***REMOVED***
    if isComplexType(t***REMOVED***:
        lapack_routine = lapack_lite.zgeqrf
        routine_name = 'zgeqrf'
    else:
        lapack_routine = lapack_lite.dgeqrf
        routine_name = 'dgeqrf'

    # calculate optimal size of work data 'work'
    lwork = 1
    work = zeros((lwork,***REMOVED***, t***REMOVED***
    results = lapack_routine(m, n, a, m, tau, work, -1, 0***REMOVED***
    if results['info'***REMOVED*** != 0:
        raise LinAlgError('%s returns %d' % (routine_name, results['info'***REMOVED******REMOVED******REMOVED***

    # do qr decomposition
    lwork = int(abs(work[0***REMOVED******REMOVED******REMOVED***
    work = zeros((lwork,***REMOVED***, t***REMOVED***
    results = lapack_routine(m, n, a, m, tau, work, lwork, 0***REMOVED***
    if results['info'***REMOVED*** != 0:
        raise LinAlgError('%s returns %d' % (routine_name, results['info'***REMOVED******REMOVED******REMOVED***

    # handle modes that don't return q
    if mode == 'r':
        r = _fastCopyAndTranspose(result_t, a[:, :mn***REMOVED******REMOVED***
        return wrap(triu(r***REMOVED******REMOVED***

    if mode == 'raw':
        return a, tau

    if mode == 'economic':
        if t != result_t :
            a = a.astype(result_t, copy=False***REMOVED***
        return wrap(a.T***REMOVED***

    #  generate q from a
    if mode == 'complete' and m > n:
        mc = m
        q = empty((m, m***REMOVED***, t***REMOVED***
    else:
        mc = mn
        q = empty((n, m***REMOVED***, t***REMOVED***
    q[:n***REMOVED*** = a

    if isComplexType(t***REMOVED***:
        lapack_routine = lapack_lite.zungqr
        routine_name = 'zungqr'
    else:
        lapack_routine = lapack_lite.dorgqr
        routine_name = 'dorgqr'

    # determine optimal lwork
    lwork = 1
    work = zeros((lwork,***REMOVED***, t***REMOVED***
    results = lapack_routine(m, mc, mn, q, m, tau, work, -1, 0***REMOVED***
    if results['info'***REMOVED*** != 0:
        raise LinAlgError('%s returns %d' % (routine_name, results['info'***REMOVED******REMOVED******REMOVED***

    # compute q
    lwork = int(abs(work[0***REMOVED******REMOVED******REMOVED***
    work = zeros((lwork,***REMOVED***, t***REMOVED***
    results = lapack_routine(m, mc, mn, q, m, tau, work, lwork, 0***REMOVED***
    if results['info'***REMOVED*** != 0:
        raise LinAlgError('%s returns %d' % (routine_name, results['info'***REMOVED******REMOVED******REMOVED***

    q = _fastCopyAndTranspose(result_t, q[:mc***REMOVED******REMOVED***
    r = _fastCopyAndTranspose(result_t, a[:, :mc***REMOVED******REMOVED***

    return wrap(q***REMOVED***, wrap(triu(r***REMOVED******REMOVED***


# Eigenvalues


def eigvals(a***REMOVED***:
    ***REMOVED***
    Compute the eigenvalues of a general matrix.

    Main difference between `eigvals` and `eig`: the eigenvectors aren't
    returned.

    Parameters
    ----------
    a : (..., M, M***REMOVED*** array_like
        A complex- or real-valued matrix whose eigenvalues will be computed.

    Returns
    -------
    w : (..., M,***REMOVED*** ndarray
        The eigenvalues, each repeated according to its multiplicity.
        They are not necessarily ordered, nor are they necessarily
        real for real matrices.

    Raises
    ------
    LinAlgError
        If the eigenvalue computation does not converge.

    See Also
    --------
    eig : eigenvalues and right eigenvectors of general arrays
    eigvalsh : eigenvalues of symmetric or Hermitian arrays.
    eigh : eigenvalues and eigenvectors of symmetric/Hermitian arrays.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    This is implemented using the _geev LAPACK routines which compute
    the eigenvalues and eigenvectors of general square arrays.

    Examples
    --------
    Illustration, using the fact that the eigenvalues of a diagonal matrix
    are its diagonal elements, that multiplying a matrix on the left
    by an orthogonal matrix, `Q`, and on the right by `Q.T` (the transpose
    of `Q`***REMOVED***, preserves the eigenvalues of the "middle" matrix.  In other words,
    if `Q` is orthogonal, then ``Q * A * Q.T`` has the same eigenvalues as
    ``A``:

    >>> from numpy import linalg as LA
    >>> x = np.random.random(***REMOVED***
    >>> Q = np.array([[np.cos(x***REMOVED***, -np.sin(x***REMOVED******REMOVED***, [np.sin(x***REMOVED***, np.cos(x***REMOVED******REMOVED******REMOVED******REMOVED***
    >>> LA.norm(Q[0, :***REMOVED******REMOVED***, LA.norm(Q[1, :***REMOVED******REMOVED***, np.dot(Q[0, :***REMOVED***,Q[1, :***REMOVED******REMOVED***
    (1.0, 1.0, 0.0***REMOVED***

    Now multiply a diagonal matrix by Q on one side and by Q.T on the other:

    >>> D = np.diag((-1,1***REMOVED******REMOVED***
    >>> LA.eigvals(D***REMOVED***
    array([-1.,  1.***REMOVED******REMOVED***
    >>> A = np.dot(Q, D***REMOVED***
    >>> A = np.dot(A, Q.T***REMOVED***
    >>> LA.eigvals(A***REMOVED***
    array([ 1., -1.***REMOVED******REMOVED***

    ***REMOVED***
    a, wrap = _makearray(a***REMOVED***
    _assertNoEmpty2d(a***REMOVED***
    _assertRankAtLeast2(a***REMOVED***
    _assertNdSquareness(a***REMOVED***
    _assertFinite(a***REMOVED***
    t, result_t = _commonType(a***REMOVED***

    extobj = get_linalg_error_extobj(
        _raise_linalgerror_eigenvalues_nonconvergence***REMOVED***
    signature = 'D->D' if isComplexType(t***REMOVED*** else 'd->D'
    w = _umath_linalg.eigvals(a, signature=signature, extobj=extobj***REMOVED***

    if not isComplexType(t***REMOVED***:
        if all(w.imag == 0***REMOVED***:
            w = w.real
            result_t = _realType(result_t***REMOVED***
        else:
            result_t = _complexType(result_t***REMOVED***

    return w.astype(result_t, copy=False***REMOVED***

def eigvalsh(a, UPLO='L'***REMOVED***:
    ***REMOVED***
    Compute the eigenvalues of a Hermitian or real symmetric matrix.

    Main difference from eigh: the eigenvectors are not computed.

    Parameters
    ----------
    a : (..., M, M***REMOVED*** array_like
        A complex- or real-valued matrix whose eigenvalues are to be
        computed.
    UPLO : {'L', 'U'***REMOVED***, optional
        Same as `lower`, with 'L' for lower and 'U' for upper triangular.
        Deprecated.

    Returns
    -------
    w : (..., M,***REMOVED*** ndarray
        The eigenvalues in ascending order, each repeated according to
        its multiplicity.

    Raises
    ------
    LinAlgError
        If the eigenvalue computation does not converge.

    See Also
    --------
    eigh : eigenvalues and eigenvectors of symmetric/Hermitian arrays.
    eigvals : eigenvalues of general real or complex arrays.
    eig : eigenvalues and right eigenvectors of general real or complex
          arrays.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    The eigenvalues are computed using LAPACK routines _syevd, _heevd

    Examples
    --------
    >>> from numpy import linalg as LA
    >>> a = np.array([[1, -2j***REMOVED***, [2j, 5***REMOVED******REMOVED******REMOVED***
    >>> LA.eigvalsh(a***REMOVED***
    array([ 0.17157288,  5.82842712***REMOVED******REMOVED***

    ***REMOVED***
    UPLO = UPLO.upper(***REMOVED***
    if UPLO not in ('L', 'U'***REMOVED***:
        raise ValueError("UPLO argument must be 'L' or 'U'"***REMOVED***

    extobj = get_linalg_error_extobj(
        _raise_linalgerror_eigenvalues_nonconvergence***REMOVED***
    if UPLO == 'L':
        gufunc = _umath_linalg.eigvalsh_lo
    else:
        gufunc = _umath_linalg.eigvalsh_up

    a, wrap = _makearray(a***REMOVED***
    _assertNoEmpty2d(a***REMOVED***
    _assertRankAtLeast2(a***REMOVED***
    _assertNdSquareness(a***REMOVED***
    t, result_t = _commonType(a***REMOVED***
    signature = 'D->d' if isComplexType(t***REMOVED*** else 'd->d'
    w = gufunc(a, signature=signature, extobj=extobj***REMOVED***
    return w.astype(_realType(result_t***REMOVED***, copy=False***REMOVED***

def _convertarray(a***REMOVED***:
    t, result_t = _commonType(a***REMOVED***
    a = _fastCT(a.astype(t***REMOVED******REMOVED***
    return a, t, result_t


# Eigenvectors


def eig(a***REMOVED***:
    ***REMOVED***
    Compute the eigenvalues and right eigenvectors of a square array.

    Parameters
    ----------
    a : (..., M, M***REMOVED*** array
        Matrices for which the eigenvalues and right eigenvectors will
        be computed

    Returns
    -------
    w : (..., M***REMOVED*** array
        The eigenvalues, each repeated according to its multiplicity.
        The eigenvalues are not necessarily ordered. The resulting
        array will be of complex type, unless the imaginary part is
        zero in which case it will be cast to a real type. When `a`
        is real the resulting eigenvalues will be real (0 imaginary
        part***REMOVED*** or occur in conjugate pairs

    v : (..., M, M***REMOVED*** array
        The normalized (unit "length"***REMOVED*** eigenvectors, such that the
        column ``v[:,i***REMOVED***`` is the eigenvector corresponding to the
        eigenvalue ``w[i***REMOVED***``.

    Raises
    ------
    LinAlgError
        If the eigenvalue computation does not converge.

    See Also
    --------
    eigvals : eigenvalues of a non-symmetric array.

    eigh : eigenvalues and eigenvectors of a symmetric or Hermitian
           (conjugate symmetric***REMOVED*** array.

    eigvalsh : eigenvalues of a symmetric or Hermitian (conjugate symmetric***REMOVED***
               array.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    This is implemented using the _geev LAPACK routines which compute
    the eigenvalues and eigenvectors of general square arrays.

    The number `w` is an eigenvalue of `a` if there exists a vector
    `v` such that ``dot(a,v***REMOVED*** = w * v``. Thus, the arrays `a`, `w`, and
    `v` satisfy the equations ``dot(a[:,:***REMOVED***, v[:,i***REMOVED******REMOVED*** = w[i***REMOVED*** * v[:,i***REMOVED***``
    for :math:`i \\in \\{0,...,M-1\\***REMOVED***`.

    The array `v` of eigenvectors may not be of maximum rank, that is, some
    of the columns may be linearly dependent, although round-off error may
    obscure that fact. If the eigenvalues are all different, then theoretically
    the eigenvectors are linearly independent. Likewise, the (complex-valued***REMOVED***
    matrix of eigenvectors `v` is unitary if the matrix `a` is normal, i.e.,
    if ``dot(a, a.H***REMOVED*** = dot(a.H, a***REMOVED***``, where `a.H` denotes the conjugate
    transpose of `a`.

    Finally, it is emphasized that `v` consists of the *right* (as in
    right-hand side***REMOVED*** eigenvectors of `a`.  A vector `y` satisfying
    ``dot(y.T, a***REMOVED*** = z * y.T`` for some number `z` is called a *left*
    eigenvector of `a`, and, in general, the left and right eigenvectors
    of a matrix are not necessarily the (perhaps conjugate***REMOVED*** transposes
    of each other.

    References
    ----------
    G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando, FL,
    Academic Press, Inc., 1980, Various pp.

    Examples
    --------
    >>> from numpy import linalg as LA

    (Almost***REMOVED*** trivial example with real e-values and e-vectors.

    >>> w, v = LA.eig(np.diag((1, 2, 3***REMOVED******REMOVED******REMOVED***
    >>> w; v
    array([ 1.,  2.,  3.***REMOVED******REMOVED***
    array([[ 1.,  0.,  0.***REMOVED***,
           [ 0.,  1.,  0.***REMOVED***,
           [ 0.,  0.,  1.***REMOVED******REMOVED******REMOVED***

    Real matrix possessing complex e-values and e-vectors; note that the
    e-values are complex conjugates of each other.

    >>> w, v = LA.eig(np.array([[1, -1***REMOVED***, [1, 1***REMOVED******REMOVED******REMOVED******REMOVED***
    >>> w; v
    array([ 1. + 1.j,  1. - 1.j***REMOVED******REMOVED***
    array([[ 0.70710678+0.j        ,  0.70710678+0.j        ***REMOVED***,
           [ 0.00000000-0.70710678j,  0.00000000+0.70710678j***REMOVED******REMOVED******REMOVED***

    Complex-valued matrix with real e-values (but complex-valued e-vectors***REMOVED***;
    note that a.conj(***REMOVED***.T = a, i.e., a is Hermitian.

    >>> a = np.array([[1, 1j***REMOVED***, [-1j, 1***REMOVED******REMOVED******REMOVED***
    >>> w, v = LA.eig(a***REMOVED***
    >>> w; v
    array([  2.00000000e+00+0.j,   5.98651912e-36+0.j***REMOVED******REMOVED*** # i.e., {2, 0***REMOVED***
    array([[ 0.00000000+0.70710678j,  0.70710678+0.j        ***REMOVED***,
           [ 0.70710678+0.j        ,  0.00000000+0.70710678j***REMOVED******REMOVED******REMOVED***

    Be careful about round-off error!

    >>> a = np.array([[1 + 1e-9, 0***REMOVED***, [0, 1 - 1e-9***REMOVED******REMOVED******REMOVED***
    >>> # Theor. e-values are 1 +/- 1e-9
    >>> w, v = LA.eig(a***REMOVED***
    >>> w; v
    array([ 1.,  1.***REMOVED******REMOVED***
    array([[ 1.,  0.***REMOVED***,
           [ 0.,  1.***REMOVED******REMOVED******REMOVED***

    ***REMOVED***
    a, wrap = _makearray(a***REMOVED***
    _assertRankAtLeast2(a***REMOVED***
    _assertNdSquareness(a***REMOVED***
    _assertFinite(a***REMOVED***
    t, result_t = _commonType(a***REMOVED***

    extobj = get_linalg_error_extobj(
        _raise_linalgerror_eigenvalues_nonconvergence***REMOVED***
    signature = 'D->DD' if isComplexType(t***REMOVED*** else 'd->DD'
    w, vt = _umath_linalg.eig(a, signature=signature, extobj=extobj***REMOVED***

    if not isComplexType(t***REMOVED*** and all(w.imag == 0.0***REMOVED***:
        w = w.real
        vt = vt.real
        result_t = _realType(result_t***REMOVED***
    else:
        result_t = _complexType(result_t***REMOVED***

    vt = vt.astype(result_t, copy=False***REMOVED***
    return w.astype(result_t, copy=False***REMOVED***, wrap(vt***REMOVED***


def eigh(a, UPLO='L'***REMOVED***:
    ***REMOVED***
    Return the eigenvalues and eigenvectors of a Hermitian or symmetric matrix.

    Returns two objects, a 1-D array containing the eigenvalues of `a`, and
    a 2-D square array or matrix (depending on the input type***REMOVED*** of the
    corresponding eigenvectors (in columns***REMOVED***.

    Parameters
    ----------
    a : (..., M, M***REMOVED*** array
        Hermitian/Symmetric matrices whose eigenvalues and
        eigenvectors are to be computed.
    UPLO : {'L', 'U'***REMOVED***, optional
        Specifies whether the calculation is done with the lower triangular
        part of `a` ('L', default***REMOVED*** or the upper triangular part ('U'***REMOVED***.

    Returns
    -------
    w : (..., M***REMOVED*** ndarray
        The eigenvalues in ascending order, each repeated according to
        its multiplicity.
    v : {(..., M, M***REMOVED*** ndarray, (..., M, M***REMOVED*** matrix***REMOVED***
        The column ``v[:, i***REMOVED***`` is the normalized eigenvector corresponding
        to the eigenvalue ``w[i***REMOVED***``.  Will return a matrix object if `a` is
        a matrix object.

    Raises
    ------
    LinAlgError
        If the eigenvalue computation does not converge.

    See Also
    --------
    eigvalsh : eigenvalues of symmetric or Hermitian arrays.
    eig : eigenvalues and right eigenvectors for non-symmetric arrays.
    eigvals : eigenvalues of non-symmetric arrays.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    The eigenvalues/eigenvectors are computed using LAPACK routines _syevd,
    _heevd

    The eigenvalues of real symmetric or complex Hermitian matrices are
    always real. [1***REMOVED***_ The array `v` of (column***REMOVED*** eigenvectors is unitary
    and `a`, `w`, and `v` satisfy the equations
    ``dot(a, v[:, i***REMOVED******REMOVED*** = w[i***REMOVED*** * v[:, i***REMOVED***``.

    References
    ----------
    .. [1***REMOVED*** G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando,
           FL, Academic Press, Inc., 1980, pg. 222.

    Examples
    --------
    >>> from numpy import linalg as LA
    >>> a = np.array([[1, -2j***REMOVED***, [2j, 5***REMOVED******REMOVED******REMOVED***
    >>> a
    array([[ 1.+0.j,  0.-2.j***REMOVED***,
           [ 0.+2.j,  5.+0.j***REMOVED******REMOVED******REMOVED***
    >>> w, v = LA.eigh(a***REMOVED***
    >>> w; v
    array([ 0.17157288,  5.82842712***REMOVED******REMOVED***
    array([[-0.92387953+0.j        , -0.38268343+0.j        ***REMOVED***,
           [ 0.00000000+0.38268343j,  0.00000000-0.92387953j***REMOVED******REMOVED******REMOVED***

    >>> np.dot(a, v[:, 0***REMOVED******REMOVED*** - w[0***REMOVED*** * v[:, 0***REMOVED*** # verify 1st e-val/vec pair
    array([2.77555756e-17 + 0.j, 0. + 1.38777878e-16j***REMOVED******REMOVED***
    >>> np.dot(a, v[:, 1***REMOVED******REMOVED*** - w[1***REMOVED*** * v[:, 1***REMOVED*** # verify 2nd e-val/vec pair
    array([ 0.+0.j,  0.+0.j***REMOVED******REMOVED***

    >>> A = np.matrix(a***REMOVED*** # what happens if input is a matrix object
    >>> A
    matrix([[ 1.+0.j,  0.-2.j***REMOVED***,
            [ 0.+2.j,  5.+0.j***REMOVED******REMOVED******REMOVED***
    >>> w, v = LA.eigh(A***REMOVED***
    >>> w; v
    array([ 0.17157288,  5.82842712***REMOVED******REMOVED***
    matrix([[-0.92387953+0.j        , -0.38268343+0.j        ***REMOVED***,
            [ 0.00000000+0.38268343j,  0.00000000-0.92387953j***REMOVED******REMOVED******REMOVED***

    ***REMOVED***
    UPLO = UPLO.upper(***REMOVED***
    if UPLO not in ('L', 'U'***REMOVED***:
        raise ValueError("UPLO argument must be 'L' or 'U'"***REMOVED***

    a, wrap = _makearray(a***REMOVED***
    _assertRankAtLeast2(a***REMOVED***
    _assertNdSquareness(a***REMOVED***
    t, result_t = _commonType(a***REMOVED***

    extobj = get_linalg_error_extobj(
        _raise_linalgerror_eigenvalues_nonconvergence***REMOVED***
    if UPLO == 'L':
        gufunc = _umath_linalg.eigh_lo
    else:
        gufunc = _umath_linalg.eigh_up

    signature = 'D->dD' if isComplexType(t***REMOVED*** else 'd->dd'
    w, vt = gufunc(a, signature=signature, extobj=extobj***REMOVED***
    w = w.astype(_realType(result_t***REMOVED***, copy=False***REMOVED***
    vt = vt.astype(result_t, copy=False***REMOVED***
    return w, wrap(vt***REMOVED***


# Singular value decomposition

def svd(a, full_matrices=1, compute_uv=1***REMOVED***:
    ***REMOVED***
    Singular Value Decomposition.

    Factors the matrix `a` as ``u * np.diag(s***REMOVED*** * v``, where `u` and `v`
    are unitary and `s` is a 1-d array of `a`'s singular values.

    Parameters
    ----------
    a : (..., M, N***REMOVED*** array_like
        A real or complex matrix of shape (`M`, `N`***REMOVED*** .
    full_matrices : bool, optional
        If True (default***REMOVED***, `u` and `v` have the shapes (`M`, `M`***REMOVED*** and
        (`N`, `N`***REMOVED***, respectively.  Otherwise, the shapes are (`M`, `K`***REMOVED***
        and (`K`, `N`***REMOVED***, respectively, where `K` = min(`M`, `N`***REMOVED***.
    compute_uv : bool, optional
        Whether or not to compute `u` and `v` in addition to `s`.  True
        by default.

    Returns
    -------
    u : { (..., M, M***REMOVED***, (..., M, K***REMOVED*** ***REMOVED*** array
        Unitary matrices. The actual shape depends on the value of
        ``full_matrices``. Only returned when ``compute_uv`` is True.
    s : (..., K***REMOVED*** array
        The singular values for every matrix, sorted in descending order.
    v : { (..., N, N***REMOVED***, (..., K, N***REMOVED*** ***REMOVED*** array
        Unitary matrices. The actual shape depends on the value of
        ``full_matrices``. Only returned when ``compute_uv`` is True.

    Raises
    ------
    LinAlgError
        If SVD computation does not converge.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    The decomposition is performed using LAPACK routine _gesdd

    The SVD is commonly written as ``a = U S V.H``.  The `v` returned
    by this function is ``V.H`` and ``u = U``.

    If ``U`` is a unitary matrix, it means that it
    satisfies ``U.H = inv(U***REMOVED***``.

    The rows of `v` are the eigenvectors of ``a.H a``. The columns
    of `u` are the eigenvectors of ``a a.H``.  For row ``i`` in
    `v` and column ``i`` in `u`, the corresponding eigenvalue is
    ``s[i***REMOVED*****2``.

    If `a` is a `matrix` object (as opposed to an `ndarray`***REMOVED***, then so
    are all the return values.

    Examples
    --------
    >>> a = np.random.randn(9, 6***REMOVED*** + 1j*np.random.randn(9, 6***REMOVED***

    Reconstruction based on full SVD:

    >>> U, s, V = np.linalg.svd(a, full_matrices=True***REMOVED***
    >>> U.shape, V.shape, s.shape
    ((9, 9***REMOVED***, (6, 6***REMOVED***, (6,***REMOVED******REMOVED***
    >>> S = np.zeros((9, 6***REMOVED***, dtype=complex***REMOVED***
    >>> S[:6, :6***REMOVED*** = np.diag(s***REMOVED***
    >>> np.allclose(a, np.dot(U, np.dot(S, V***REMOVED******REMOVED******REMOVED***
    True

    Reconstruction based on reduced SVD:

    >>> U, s, V = np.linalg.svd(a, full_matrices=False***REMOVED***
    >>> U.shape, V.shape, s.shape
    ((9, 6***REMOVED***, (6, 6***REMOVED***, (6,***REMOVED******REMOVED***
    >>> S = np.diag(s***REMOVED***
    >>> np.allclose(a, np.dot(U, np.dot(S, V***REMOVED******REMOVED******REMOVED***
    True

    ***REMOVED***
    a, wrap = _makearray(a***REMOVED***
    _assertNoEmpty2d(a***REMOVED***
    _assertRankAtLeast2(a***REMOVED***
    t, result_t = _commonType(a***REMOVED***

    extobj = get_linalg_error_extobj(_raise_linalgerror_svd_nonconvergence***REMOVED***

    m = a.shape[-2***REMOVED***
    n = a.shape[-1***REMOVED***
    if compute_uv:
        if full_matrices:
            if m < n:
                gufunc = _umath_linalg.svd_m_f
            else:
                gufunc = _umath_linalg.svd_n_f
        else:
            if m < n:
                gufunc = _umath_linalg.svd_m_s
            else:
                gufunc = _umath_linalg.svd_n_s

        signature = 'D->DdD' if isComplexType(t***REMOVED*** else 'd->ddd'
        u, s, vt = gufunc(a, signature=signature, extobj=extobj***REMOVED***
        u = u.astype(result_t, copy=False***REMOVED***
        s = s.astype(_realType(result_t***REMOVED***, copy=False***REMOVED***
        vt = vt.astype(result_t, copy=False***REMOVED***
        return wrap(u***REMOVED***, s, wrap(vt***REMOVED***
    else:
        if m < n:
            gufunc = _umath_linalg.svd_m
        else:
            gufunc = _umath_linalg.svd_n

        signature = 'D->d' if isComplexType(t***REMOVED*** else 'd->d'
        s = gufunc(a, signature=signature, extobj=extobj***REMOVED***
        s = s.astype(_realType(result_t***REMOVED***, copy=False***REMOVED***
        return s

def cond(x, p=None***REMOVED***:
    ***REMOVED***
    Compute the condition number of a matrix.

    This function is capable of returning the condition number using
    one of seven different norms, depending on the value of `p` (see
    Parameters below***REMOVED***.

    Parameters
    ----------
    x : (..., M, N***REMOVED*** array_like
        The matrix whose condition number is sought.
    p : {None, 1, -1, 2, -2, inf, -inf, 'fro'***REMOVED***, optional
        Order of the norm:

        =====  ============================
        p      norm for matrices
        =====  ============================
        None   2-norm, computed directly using the ``SVD``
        'fro'  Frobenius norm
        inf    max(sum(abs(x***REMOVED***, axis=1***REMOVED******REMOVED***
        -inf   min(sum(abs(x***REMOVED***, axis=1***REMOVED******REMOVED***
        1      max(sum(abs(x***REMOVED***, axis=0***REMOVED******REMOVED***
        -1     min(sum(abs(x***REMOVED***, axis=0***REMOVED******REMOVED***
        2      2-norm (largest sing. value***REMOVED***
        -2     smallest singular value
        =====  ============================

        inf means the numpy.inf object, and the Frobenius norm is
        the root-of-sum-of-squares norm.

    Returns
    -------
    c : {float, inf***REMOVED***
        The condition number of the matrix. May be infinite.

    See Also
    --------
    numpy.linalg.norm

    Notes
    -----
    The condition number of `x` is defined as the norm of `x` times the
    norm of the inverse of `x` [1***REMOVED***_; the norm can be the usual L2-norm
    (root-of-sum-of-squares***REMOVED*** or one of a number of other matrix norms.

    References
    ----------
    .. [1***REMOVED*** G. Strang, *Linear Algebra and Its Applications*, Orlando, FL,
           Academic Press, Inc., 1980, pg. 285.

    Examples
    --------
    >>> from numpy import linalg as LA
    >>> a = np.array([[1, 0, -1***REMOVED***, [0, 1, 0***REMOVED***, [1, 0, 1***REMOVED******REMOVED******REMOVED***
    >>> a
    array([[ 1,  0, -1***REMOVED***,
           [ 0,  1,  0***REMOVED***,
           [ 1,  0,  1***REMOVED******REMOVED******REMOVED***
    >>> LA.cond(a***REMOVED***
    1.4142135623730951
    >>> LA.cond(a, 'fro'***REMOVED***
    3.1622776601683795
    >>> LA.cond(a, np.inf***REMOVED***
    2.0
    >>> LA.cond(a, -np.inf***REMOVED***
    1.0
    >>> LA.cond(a, 1***REMOVED***
    2.0
    >>> LA.cond(a, -1***REMOVED***
    1.0
    >>> LA.cond(a, 2***REMOVED***
    1.4142135623730951
    >>> LA.cond(a, -2***REMOVED***
    0.70710678118654746
    >>> min(LA.svd(a, compute_uv=0***REMOVED******REMOVED****min(LA.svd(LA.inv(a***REMOVED***, compute_uv=0***REMOVED******REMOVED***
    0.70710678118654746

    ***REMOVED***
    x = asarray(x***REMOVED***  # in case we have a matrix
    if p is None:
        s = svd(x, compute_uv=False***REMOVED***
        return s[..., 0***REMOVED***/s[..., -1***REMOVED***
    else:
        return norm(x, p, axis=(-2, -1***REMOVED******REMOVED*** * norm(inv(x***REMOVED***, p, axis=(-2, -1***REMOVED******REMOVED***


def matrix_rank(M, tol=None***REMOVED***:
    ***REMOVED***
    Return matrix rank of array using SVD method

    Rank of the array is the number of SVD singular values of the array that are
    greater than `tol`.

    Parameters
    ----------
    M : {(M,***REMOVED***, (M, N***REMOVED******REMOVED*** array_like
        array of <=2 dimensions
    tol : {None, float***REMOVED***, optional
       threshold below which SVD values are considered zero. If `tol` is
       None, and ``S`` is an array with singular values for `M`, and
       ``eps`` is the epsilon value for datatype of ``S``, then `tol` is
       set to ``S.max(***REMOVED*** * max(M.shape***REMOVED*** * eps``.

    Notes
    -----
    The default threshold to detect rank deficiency is a test on the magnitude
    of the singular values of `M`.  By default, we identify singular values less
    than ``S.max(***REMOVED*** * max(M.shape***REMOVED*** * eps`` as indicating rank deficiency (with
    the symbols defined above***REMOVED***. This is the algorithm MATLAB uses [1***REMOVED***.  It also
    appears in *Numerical recipes* in the discussion of SVD solutions for linear
    least squares [2***REMOVED***.

    This default threshold is designed to detect rank deficiency accounting for
    the numerical errors of the SVD computation.  Imagine that there is a column
    in `M` that is an exact (in floating point***REMOVED*** linear combination of other
    columns in `M`. Computing the SVD on `M` will not produce a singular value
    exactly equal to 0 in general: any difference of the smallest SVD value from
    0 will be caused by numerical imprecision in the calculation of the SVD.
    Our threshold for small SVD values takes this numerical imprecision into
    account, and the default threshold will detect such numerical rank
    deficiency.  The threshold may declare a matrix `M` rank deficient even if
    the linear combination of some columns of `M` is not exactly equal to
    another column of `M` but only numerically very close to another column of
    `M`.

    We chose our default threshold because it is in wide use.  Other thresholds
    are possible.  For example, elsewhere in the 2007 edition of *Numerical
    recipes* there is an alternative threshold of ``S.max(***REMOVED*** *
    np.finfo(M.dtype***REMOVED***.eps / 2. * np.sqrt(m + n + 1.***REMOVED***``. The authors describe
    this threshold as being based on "expected roundoff error" (p 71***REMOVED***.

    The thresholds above deal with floating point roundoff error in the
    calculation of the SVD.  However, you may have more information about the
    sources of error in `M` that would make you consider other tolerance values
    to detect *effective* rank deficiency.  The most useful measure of the
    tolerance depends on the operations you intend to use on your matrix.  For
    example, if your data come from uncertain measurements with uncertainties
    greater than floating point epsilon, choosing a tolerance near that
    uncertainty may be preferable.  The tolerance may be absolute if the
    uncertainties are absolute rather than relative.

    References
    ----------
    .. [1***REMOVED*** MATLAB reference documention, "Rank"
           http://www.mathworks.com/help/techdoc/ref/rank.html
    .. [2***REMOVED*** W. H. Press, S. A. Teukolsky, W. T. Vetterling and B. P. Flannery,
           "Numerical Recipes (3rd edition***REMOVED***", Cambridge University Press, 2007,
           page 795.

    Examples
    --------
    >>> from numpy.linalg import matrix_rank
    >>> matrix_rank(np.eye(4***REMOVED******REMOVED*** # Full rank matrix
    4
    >>> I=np.eye(4***REMOVED***; I[-1,-1***REMOVED*** = 0. # rank deficient matrix
    >>> matrix_rank(I***REMOVED***
    3
    >>> matrix_rank(np.ones((4,***REMOVED******REMOVED******REMOVED*** # 1 dimension - rank 1 unless all 0
    1
    >>> matrix_rank(np.zeros((4,***REMOVED******REMOVED******REMOVED***
    0
    ***REMOVED***
    M = asarray(M***REMOVED***
    if M.ndim > 2:
        raise TypeError('array should have 2 or fewer dimensions'***REMOVED***
    if M.ndim < 2:
        return int(not all(M==0***REMOVED******REMOVED***
    S = svd(M, compute_uv=False***REMOVED***
    if tol is None:
        tol = S.max(***REMOVED*** * max(M.shape***REMOVED*** * finfo(S.dtype***REMOVED***.eps
    return sum(S > tol***REMOVED***


# Generalized inverse

def pinv(a, rcond=1e-15 ***REMOVED***:
    ***REMOVED***
    Compute the (Moore-Penrose***REMOVED*** pseudo-inverse of a matrix.

    Calculate the generalized inverse of a matrix using its
    singular-value decomposition (SVD***REMOVED*** and including all
    *large* singular values.

    Parameters
    ----------
    a : (M, N***REMOVED*** array_like
      Matrix to be pseudo-inverted.
    rcond : float
      Cutoff for small singular values.
      Singular values smaller (in modulus***REMOVED*** than
      `rcond` * largest_singular_value (again, in modulus***REMOVED***
      are set to zero.

    Returns
    -------
    B : (N, M***REMOVED*** ndarray
      The pseudo-inverse of `a`. If `a` is a `matrix` instance, then so
      is `B`.

    Raises
    ------
    LinAlgError
      If the SVD computation does not converge.

    Notes
    -----
    The pseudo-inverse of a matrix A, denoted :math:`A^+`, is
    defined as: "the matrix that 'solves' [the least-squares problem***REMOVED***
    :math:`Ax = b`," i.e., if :math:`\\bar{x***REMOVED***` is said solution, then
    :math:`A^+` is that matrix such that :math:`\\bar{x***REMOVED*** = A^+b`.

    It can be shown that if :math:`Q_1 \\Sigma Q_2^T = A` is the singular
    value decomposition of A, then
    :math:`A^+ = Q_2 \\Sigma^+ Q_1^T`, where :math:`Q_{1,2***REMOVED***` are
    orthogonal matrices, :math:`\\Sigma` is a diagonal matrix consisting
    of A's so-called singular values, (followed, typically, by
    zeros***REMOVED***, and then :math:`\\Sigma^+` is simply the diagonal matrix
    consisting of the reciprocals of A's singular values
    (again, followed by zeros***REMOVED***. [1***REMOVED***_

    References
    ----------
    .. [1***REMOVED*** G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando,
           FL, Academic Press, Inc., 1980, pp. 139-142.

    Examples
    --------
    The following example checks that ``a * a+ * a == a`` and
    ``a+ * a * a+ == a+``:

    >>> a = np.random.randn(9, 6***REMOVED***
    >>> B = np.linalg.pinv(a***REMOVED***
    >>> np.allclose(a, np.dot(a, np.dot(B, a***REMOVED******REMOVED******REMOVED***
    True
    >>> np.allclose(B, np.dot(B, np.dot(a, B***REMOVED******REMOVED******REMOVED***
    True

    ***REMOVED***
    a, wrap = _makearray(a***REMOVED***
    _assertNoEmpty2d(a***REMOVED***
    a = a.conjugate(***REMOVED***
    u, s, vt = svd(a, 0***REMOVED***
    m = u.shape[0***REMOVED***
    n = vt.shape[1***REMOVED***
    cutoff = rcond*maximum.reduce(s***REMOVED***
    for i in range(min(n, m***REMOVED******REMOVED***:
        if s[i***REMOVED*** > cutoff:
            s[i***REMOVED*** = 1./s[i***REMOVED***
        else:
            s[i***REMOVED*** = 0.
    res = dot(transpose(vt***REMOVED***, multiply(s[:, newaxis***REMOVED***, transpose(u***REMOVED******REMOVED******REMOVED***
    return wrap(res***REMOVED***

# Determinant

def slogdet(a***REMOVED***:
    ***REMOVED***
    Compute the sign and (natural***REMOVED*** logarithm of the determinant of an array.

    If an array has a very small or very large determinant, then a call to
    `det` may overflow or underflow. This routine is more robust against such
    issues, because it computes the logarithm of the determinant rather than
    the determinant itself.

    Parameters
    ----------
    a : (..., M, M***REMOVED*** array_like
        Input array, has to be a square 2-D array.

    Returns
    -------
    sign : (...***REMOVED*** array_like
        A number representing the sign of the determinant. For a real matrix,
        this is 1, 0, or -1. For a complex matrix, this is a complex number
        with absolute value 1 (i.e., it is on the unit circle***REMOVED***, or else 0.
    logdet : (...***REMOVED*** array_like
        The natural log of the absolute value of the determinant.

    If the determinant is zero, then `sign` will be 0 and `logdet` will be
    -Inf. In all cases, the determinant is equal to ``sign * np.exp(logdet***REMOVED***``.

    See Also
    --------
    det

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    .. versionadded:: 1.6.0.

    The determinant is computed via LU factorization using the LAPACK
    routine z/dgetrf.


    Examples
    --------
    The determinant of a 2-D array ``[[a, b***REMOVED***, [c, d***REMOVED******REMOVED***`` is ``ad - bc``:

    >>> a = np.array([[1, 2***REMOVED***, [3, 4***REMOVED******REMOVED******REMOVED***
    >>> (sign, logdet***REMOVED*** = np.linalg.slogdet(a***REMOVED***
    >>> (sign, logdet***REMOVED***
    (-1, 0.69314718055994529***REMOVED***
    >>> sign * np.exp(logdet***REMOVED***
    -2.0

    Computing log-determinants for a stack of matrices:

    >>> a = np.array([ [[1, 2***REMOVED***, [3, 4***REMOVED******REMOVED***, [[1, 2***REMOVED***, [2, 1***REMOVED******REMOVED***, [[1, 3***REMOVED***, [3, 1***REMOVED******REMOVED*** ***REMOVED******REMOVED***
    >>> a.shape
    (3, 2, 2***REMOVED***
    >>> sign, logdet = np.linalg.slogdet(a***REMOVED***
    >>> (sign, logdet***REMOVED***
    (array([-1., -1., -1.***REMOVED******REMOVED***, array([ 0.69314718,  1.09861229,  2.07944154***REMOVED******REMOVED******REMOVED***
    >>> sign * np.exp(logdet***REMOVED***
    array([-2., -3., -8.***REMOVED******REMOVED***

    This routine succeeds where ordinary `det` does not:

    >>> np.linalg.det(np.eye(500***REMOVED*** * 0.1***REMOVED***
    0.0
    >>> np.linalg.slogdet(np.eye(500***REMOVED*** * 0.1***REMOVED***
    (1, -1151.2925464970228***REMOVED***

    ***REMOVED***
    a = asarray(a***REMOVED***
    _assertNoEmpty2d(a***REMOVED***
    _assertRankAtLeast2(a***REMOVED***
    _assertNdSquareness(a***REMOVED***
    t, result_t = _commonType(a***REMOVED***
    real_t = _realType(result_t***REMOVED***
    signature = 'D->Dd' if isComplexType(t***REMOVED*** else 'd->dd'
    sign, logdet = _umath_linalg.slogdet(a, signature=signature***REMOVED***
    if isscalar(sign***REMOVED***:
        sign = sign.astype(result_t***REMOVED***
    else:
        sign = sign.astype(result_t, copy=False***REMOVED***
    if isscalar(logdet***REMOVED***:
        logdet = logdet.astype(real_t***REMOVED***
    else:
        logdet = logdet.astype(real_t, copy=False***REMOVED***
    return sign, logdet

def det(a***REMOVED***:
    ***REMOVED***
    Compute the determinant of an array.

    Parameters
    ----------
    a : (..., M, M***REMOVED*** array_like
        Input array to compute determinants for.

    Returns
    -------
    det : (...***REMOVED*** array_like
        Determinant of `a`.

    See Also
    --------
    slogdet : Another way to representing the determinant, more suitable
      for large matrices where underflow/overflow may occur.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    The determinant is computed via LU factorization using the LAPACK
    routine z/dgetrf.

    Examples
    --------
    The determinant of a 2-D array [[a, b***REMOVED***, [c, d***REMOVED******REMOVED*** is ad - bc:

    >>> a = np.array([[1, 2***REMOVED***, [3, 4***REMOVED******REMOVED******REMOVED***
    >>> np.linalg.det(a***REMOVED***
    -2.0

    Computing determinants for a stack of matrices:

    >>> a = np.array([ [[1, 2***REMOVED***, [3, 4***REMOVED******REMOVED***, [[1, 2***REMOVED***, [2, 1***REMOVED******REMOVED***, [[1, 3***REMOVED***, [3, 1***REMOVED******REMOVED*** ***REMOVED******REMOVED***
    >>> a.shape
    (3, 2, 2***REMOVED***
    >>> np.linalg.det(a***REMOVED***
    array([-2., -3., -8.***REMOVED******REMOVED***

    ***REMOVED***
    a = asarray(a***REMOVED***
    _assertNoEmpty2d(a***REMOVED***
    _assertRankAtLeast2(a***REMOVED***
    _assertNdSquareness(a***REMOVED***
    t, result_t = _commonType(a***REMOVED***
    signature = 'D->D' if isComplexType(t***REMOVED*** else 'd->d'
    r = _umath_linalg.det(a, signature=signature***REMOVED***
    if isscalar(r***REMOVED***:
        r = r.astype(result_t***REMOVED***
    else:
        r = r.astype(result_t, copy=False***REMOVED***
    return r

# Linear Least Squares

def lstsq(a, b, rcond=-1***REMOVED***:
    ***REMOVED***
    Return the least-squares solution to a linear matrix equation.

    Solves the equation `a x = b` by computing a vector `x` that
    minimizes the Euclidean 2-norm `|| b - a x ||^2`.  The equation may
    be under-, well-, or over- determined (i.e., the number of
    linearly independent rows of `a` can be less than, equal to, or
    greater than its number of linearly independent columns***REMOVED***.  If `a`
    is square and of full rank, then `x` (but for round-off error***REMOVED*** is
    the "exact" solution of the equation.

    Parameters
    ----------
    a : (M, N***REMOVED*** array_like
        "Coefficient" matrix.
    b : {(M,***REMOVED***, (M, K***REMOVED******REMOVED*** array_like
        Ordinate or "dependent variable" values. If `b` is two-dimensional,
        the least-squares solution is calculated for each of the `K` columns
        of `b`.
    rcond : float, optional
        Cut-off ratio for small singular values of `a`.
        Singular values are set to zero if they are smaller than `rcond`
        times the largest singular value of `a`.

    Returns
    -------
    x : {(N,***REMOVED***, (N, K***REMOVED******REMOVED*** ndarray
        Least-squares solution. If `b` is two-dimensional,
        the solutions are in the `K` columns of `x`.
    residuals : {(***REMOVED***, (1,***REMOVED***, (K,***REMOVED******REMOVED*** ndarray
        Sums of residuals; squared Euclidean 2-norm for each column in
        ``b - a*x``.
        If the rank of `a` is < N or M <= N, this is an empty array.
        If `b` is 1-dimensional, this is a (1,***REMOVED*** shape array.
        Otherwise the shape is (K,***REMOVED***.
    rank : int
        Rank of matrix `a`.
    s : (min(M, N***REMOVED***,***REMOVED*** ndarray
        Singular values of `a`.

    Raises
    ------
    LinAlgError
        If computation does not converge.

    Notes
    -----
    If `b` is a matrix, then all array results are returned as matrices.

    Examples
    --------
    Fit a line, ``y = mx + c``, through some noisy data-points:

    >>> x = np.array([0, 1, 2, 3***REMOVED******REMOVED***
    >>> y = np.array([-1, 0.2, 0.9, 2.1***REMOVED******REMOVED***

    By examining the coefficients, we see that the line should have a
    gradient of roughly 1 and cut the y-axis at, more or less, -1.

    We can rewrite the line equation as ``y = Ap``, where ``A = [[x 1***REMOVED******REMOVED***``
    and ``p = [[m***REMOVED***, [c***REMOVED******REMOVED***``.  Now use `lstsq` to solve for `p`:

    >>> A = np.vstack([x, np.ones(len(x***REMOVED******REMOVED******REMOVED******REMOVED***.T
    >>> A
    array([[ 0.,  1.***REMOVED***,
           [ 1.,  1.***REMOVED***,
           [ 2.,  1.***REMOVED***,
           [ 3.,  1.***REMOVED******REMOVED******REMOVED***

    >>> m, c = np.linalg.lstsq(A, y***REMOVED***[0***REMOVED***
    >>> print(m, c***REMOVED***
    1.0 -0.95

    Plot the data along with the fitted line:

    >>> import matplotlib.pyplot as plt
    >>> plt.plot(x, y, 'o', label='Original data', markersize=10***REMOVED***
    >>> plt.plot(x, m*x + c, 'r', label='Fitted line'***REMOVED***
    >>> plt.legend(***REMOVED***
    >>> plt.show(***REMOVED***

    ***REMOVED***
    import math
    a, _ = _makearray(a***REMOVED***
    b, wrap = _makearray(b***REMOVED***
    is_1d = len(b.shape***REMOVED*** == 1
    if is_1d:
        b = b[:, newaxis***REMOVED***
    _assertRank2(a, b***REMOVED***
    m  = a.shape[0***REMOVED***
    n  = a.shape[1***REMOVED***
    n_rhs = b.shape[1***REMOVED***
    ldb = max(n, m***REMOVED***
    if m != b.shape[0***REMOVED***:
        raise LinAlgError('Incompatible dimensions'***REMOVED***
    t, result_t = _commonType(a, b***REMOVED***
    result_real_t = _realType(result_t***REMOVED***
    real_t = _linalgRealType(t***REMOVED***
    bstar = zeros((ldb, n_rhs***REMOVED***, t***REMOVED***
    bstar[:b.shape[0***REMOVED***, :n_rhs***REMOVED*** = b.copy(***REMOVED***
    a, bstar = _fastCopyAndTranspose(t, a, bstar***REMOVED***
    a, bstar = _to_native_byte_order(a, bstar***REMOVED***
    s = zeros((min(m, n***REMOVED***,***REMOVED***, real_t***REMOVED***
    nlvl = max( 0, int( math.log( float(min(m, n***REMOVED******REMOVED***/2. ***REMOVED*** ***REMOVED*** + 1 ***REMOVED***
    iwork = zeros((3*min(m, n***REMOVED****nlvl+11*min(m, n***REMOVED***,***REMOVED***, fortran_int***REMOVED***
    if isComplexType(t***REMOVED***:
        lapack_routine = lapack_lite.zgelsd
        lwork = 1
        rwork = zeros((lwork,***REMOVED***, real_t***REMOVED***
        work = zeros((lwork,***REMOVED***, t***REMOVED***
        results = lapack_routine(m, n, n_rhs, a, m, bstar, ldb, s, rcond,
                                 0, work, -1, rwork, iwork, 0***REMOVED***
        lwork = int(abs(work[0***REMOVED******REMOVED******REMOVED***
        rwork = zeros((lwork,***REMOVED***, real_t***REMOVED***
        a_real = zeros((m, n***REMOVED***, real_t***REMOVED***
        bstar_real = zeros((ldb, n_rhs,***REMOVED***, real_t***REMOVED***
        results = lapack_lite.dgelsd(m, n, n_rhs, a_real, m,
                                     bstar_real, ldb, s, rcond,
                                     0, rwork, -1, iwork, 0***REMOVED***
        lrwork = int(rwork[0***REMOVED******REMOVED***
        work = zeros((lwork,***REMOVED***, t***REMOVED***
        rwork = zeros((lrwork,***REMOVED***, real_t***REMOVED***
        results = lapack_routine(m, n, n_rhs, a, m, bstar, ldb, s, rcond,
                                 0, work, lwork, rwork, iwork, 0***REMOVED***
    else:
        lapack_routine = lapack_lite.dgelsd
        lwork = 1
        work = zeros((lwork,***REMOVED***, t***REMOVED***
        results = lapack_routine(m, n, n_rhs, a, m, bstar, ldb, s, rcond,
                                 0, work, -1, iwork, 0***REMOVED***
        lwork = int(work[0***REMOVED******REMOVED***
        work = zeros((lwork,***REMOVED***, t***REMOVED***
        results = lapack_routine(m, n, n_rhs, a, m, bstar, ldb, s, rcond,
                                 0, work, lwork, iwork, 0***REMOVED***
    if results['info'***REMOVED*** > 0:
        raise LinAlgError('SVD did not converge in Linear Least Squares'***REMOVED***
    resids = array([***REMOVED***, result_real_t***REMOVED***
    if is_1d:
        x = array(ravel(bstar***REMOVED***[:n***REMOVED***, dtype=result_t, copy=True***REMOVED***
        if results['rank'***REMOVED*** == n and m > n:
            if isComplexType(t***REMOVED***:
                resids = array([sum(abs(ravel(bstar***REMOVED***[n:***REMOVED******REMOVED*****2***REMOVED******REMOVED***,
                               dtype=result_real_t***REMOVED***
            else:
                resids = array([sum((ravel(bstar***REMOVED***[n:***REMOVED******REMOVED*****2***REMOVED******REMOVED***,
                               dtype=result_real_t***REMOVED***
    else:
        x = array(transpose(bstar***REMOVED***[:n,:***REMOVED***, dtype=result_t, copy=True***REMOVED***
        if results['rank'***REMOVED*** == n and m > n:
            if isComplexType(t***REMOVED***:
                resids = sum(abs(transpose(bstar***REMOVED***[n:,:***REMOVED******REMOVED*****2, axis=0***REMOVED***.astype(
                    result_real_t, copy=False***REMOVED***
            else:
                resids = sum((transpose(bstar***REMOVED***[n:,:***REMOVED******REMOVED*****2, axis=0***REMOVED***.astype(
                    result_real_t, copy=False***REMOVED***

    st = s[:min(n, m***REMOVED******REMOVED***.astype(result_real_t, copy=True***REMOVED***
    return wrap(x***REMOVED***, wrap(resids***REMOVED***, results['rank'***REMOVED***, st


def _multi_svd_norm(x, row_axis, col_axis, op***REMOVED***:
    ***REMOVED***Compute a function of the singular values of the 2-D matrices in `x`.

    This is a private utility function used by numpy.linalg.norm(***REMOVED***.

    Parameters
    ----------
    x : ndarray
    row_axis, col_axis : int
        The axes of `x` that hold the 2-D matrices.
    op : callable
        This should be either numpy.amin or numpy.amax or numpy.sum.

    Returns
    -------
    result : float or ndarray
        If `x` is 2-D, the return values is a float.
        Otherwise, it is an array with ``x.ndim - 2`` dimensions.
        The return values are either the minimum or maximum or sum of the
        singular values of the matrices, depending on whether `op`
        is `numpy.amin` or `numpy.amax` or `numpy.sum`.

    ***REMOVED***
    if row_axis > col_axis:
        row_axis -= 1
    y = rollaxis(rollaxis(x, col_axis, x.ndim***REMOVED***, row_axis, -1***REMOVED***
    result = op(svd(y, compute_uv=0***REMOVED***, axis=-1***REMOVED***
    return result


def norm(x, ord=None, axis=None, keepdims=False***REMOVED***:
    ***REMOVED***
    Matrix or vector norm.

    This function is able to return one of eight different matrix norms,
    or one of an infinite number of vector norms (described below***REMOVED***, depending
    on the value of the ``ord`` parameter.

    Parameters
    ----------
    x : array_like
        Input array.  If `axis` is None, `x` must be 1-D or 2-D.
    ord : {non-zero int, inf, -inf, 'fro', 'nuc'***REMOVED***, optional
        Order of the norm (see table under ``Notes``***REMOVED***. inf means numpy's
        `inf` object.
    axis : {int, 2-tuple of ints, None***REMOVED***, optional
        If `axis` is an integer, it specifies the axis of `x` along which to
        compute the vector norms.  If `axis` is a 2-tuple, it specifies the
        axes that hold 2-D matrices, and the matrix norms of these matrices
        are computed.  If `axis` is None then either a vector norm (when `x`
        is 1-D***REMOVED*** or a matrix norm (when `x` is 2-D***REMOVED*** is returned.
    keepdims : bool, optional
        If this is set to True, the axes which are normed over are left in the
        result as dimensions with size one.  With this option the result will
        broadcast correctly against the original `x`.

        .. versionadded:: 1.10.0

    Returns
    -------
    n : float or ndarray
        Norm of the matrix or vector(s***REMOVED***.

    Notes
    -----
    For values of ``ord <= 0``, the result is, strictly speaking, not a
    mathematical 'norm', but it may still be useful for various numerical
    purposes.

    The following norms can be calculated:

    =====  ============================  ==========================
    ord    norm for matrices             norm for vectors
    =====  ============================  ==========================
    None   Frobenius norm                2-norm
    'fro'  Frobenius norm                --
    'nuc'  nuclear norm                  --
    inf    max(sum(abs(x***REMOVED***, axis=1***REMOVED******REMOVED***      max(abs(x***REMOVED******REMOVED***
    -inf   min(sum(abs(x***REMOVED***, axis=1***REMOVED******REMOVED***      min(abs(x***REMOVED******REMOVED***
    0      --                            sum(x != 0***REMOVED***
    1      max(sum(abs(x***REMOVED***, axis=0***REMOVED******REMOVED***      as below
    -1     min(sum(abs(x***REMOVED***, axis=0***REMOVED******REMOVED***      as below
    2      2-norm (largest sing. value***REMOVED***  as below
    -2     smallest singular value       as below
    other  --                            sum(abs(x***REMOVED*****ord***REMOVED*****(1./ord***REMOVED***
    =====  ============================  ==========================

    The Frobenius norm is given by [1***REMOVED***_:

        :math:`||A||_F = [\\sum_{i,j***REMOVED*** abs(a_{i,j***REMOVED******REMOVED***^2***REMOVED***^{1/2***REMOVED***`

    The nuclear norm is the sum of the singular values.

    References
    ----------
    .. [1***REMOVED*** G. H. Golub and C. F. Van Loan, *Matrix Computations*,
           Baltimore, MD, Johns Hopkins University Press, 1985, pg. 15

    Examples
    --------
    >>> from numpy import linalg as LA
    >>> a = np.arange(9***REMOVED*** - 4
    >>> a
    array([-4, -3, -2, -1,  0,  1,  2,  3,  4***REMOVED******REMOVED***
    >>> b = a.reshape((3, 3***REMOVED******REMOVED***
    >>> b
    array([[-4, -3, -2***REMOVED***,
           [-1,  0,  1***REMOVED***,
           [ 2,  3,  4***REMOVED******REMOVED******REMOVED***

    >>> LA.norm(a***REMOVED***
    7.745966692414834
    >>> LA.norm(b***REMOVED***
    7.745966692414834
    >>> LA.norm(b, 'fro'***REMOVED***
    7.745966692414834
    >>> LA.norm(a, np.inf***REMOVED***
    4.0
    >>> LA.norm(b, np.inf***REMOVED***
    9.0
    >>> LA.norm(a, -np.inf***REMOVED***
    0.0
    >>> LA.norm(b, -np.inf***REMOVED***
    2.0

    >>> LA.norm(a, 1***REMOVED***
    20.0
    >>> LA.norm(b, 1***REMOVED***
    7.0
    >>> LA.norm(a, -1***REMOVED***
    -4.6566128774142013e-010
    >>> LA.norm(b, -1***REMOVED***
    6.0
    >>> LA.norm(a, 2***REMOVED***
    7.745966692414834
    >>> LA.norm(b, 2***REMOVED***
    7.3484692283495345

    >>> LA.norm(a, -2***REMOVED***
    nan
    >>> LA.norm(b, -2***REMOVED***
    1.8570331885190563e-016
    >>> LA.norm(a, 3***REMOVED***
    5.8480354764257312
    >>> LA.norm(a, -3***REMOVED***
    nan

    Using the `axis` argument to compute vector norms:

    >>> c = np.array([[ 1, 2, 3***REMOVED***,
    ...               [-1, 1, 4***REMOVED******REMOVED******REMOVED***
    >>> LA.norm(c, axis=0***REMOVED***
    array([ 1.41421356,  2.23606798,  5.        ***REMOVED******REMOVED***
    >>> LA.norm(c, axis=1***REMOVED***
    array([ 3.74165739,  4.24264069***REMOVED******REMOVED***
    >>> LA.norm(c, ord=1, axis=1***REMOVED***
    array([ 6.,  6.***REMOVED******REMOVED***

    Using the `axis` argument to compute matrix norms:

    >>> m = np.arange(8***REMOVED***.reshape(2,2,2***REMOVED***
    >>> LA.norm(m, axis=(1,2***REMOVED******REMOVED***
    array([  3.74165739,  11.22497216***REMOVED******REMOVED***
    >>> LA.norm(m[0, :, :***REMOVED******REMOVED***, LA.norm(m[1, :, :***REMOVED******REMOVED***
    (3.7416573867739413, 11.224972160321824***REMOVED***

    ***REMOVED***
    x = asarray(x***REMOVED***

    if not issubclass(x.dtype.type, (inexact, object_***REMOVED******REMOVED***:
        x = x.astype(float***REMOVED***

    # Immediately handle some default, simple, fast, and common cases.
    if axis is None:
        ndim = x.ndim
        if ((ord is None***REMOVED*** or
            (ord in ('f', 'fro'***REMOVED*** and ndim == 2***REMOVED*** or
            (ord == 2 and ndim == 1***REMOVED******REMOVED***:

            x = x.ravel(order='K'***REMOVED***
            if isComplexType(x.dtype.type***REMOVED***:
                sqnorm = dot(x.real, x.real***REMOVED*** + dot(x.imag, x.imag***REMOVED***
            else:
                sqnorm = dot(x, x***REMOVED***
            ret = sqrt(sqnorm***REMOVED***
            if keepdims:
                ret = ret.reshape(ndim*[1***REMOVED******REMOVED***
            return ret

    # Normalize the `axis` argument to a tuple.
    nd = x.ndim
    if axis is None:
        axis = tuple(range(nd***REMOVED******REMOVED***
    elif not isinstance(axis, tuple***REMOVED***:
        ***REMOVED***
            axis = int(axis***REMOVED***
        ***REMOVED***
            raise TypeError("'axis' must be None, an integer or a tuple of integers"***REMOVED***
        axis = (axis,***REMOVED***

    if len(axis***REMOVED*** == 1:
        if ord == Inf:
            return abs(x***REMOVED***.max(axis=axis, keepdims=keepdims***REMOVED***
        elif ord == -Inf:
            return abs(x***REMOVED***.min(axis=axis, keepdims=keepdims***REMOVED***
        elif ord == 0:
            # Zero norm
            return (x != 0***REMOVED***.astype(float***REMOVED***.sum(axis=axis, keepdims=keepdims***REMOVED***
        elif ord == 1:
            # special case for speedup
            return add.reduce(abs(x***REMOVED***, axis=axis, keepdims=keepdims***REMOVED***
        elif ord is None or ord == 2:
            # special case for speedup
            s = (x.conj(***REMOVED*** * x***REMOVED***.real
            return sqrt(add.reduce(s, axis=axis, keepdims=keepdims***REMOVED******REMOVED***
        else:
            ***REMOVED***
                ord + 1
            except TypeError:
                raise ValueError("Invalid norm order for vectors."***REMOVED***
            if x.dtype.type is longdouble:
                # Convert to a float type, so integer arrays give
                # float results.  Don't apply asfarray to longdouble arrays,
                # because it will downcast to float64.
                absx = abs(x***REMOVED***
            else:
                absx = x if isComplexType(x.dtype.type***REMOVED*** else asfarray(x***REMOVED***
                if absx.dtype is x.dtype:
                    absx = abs(absx***REMOVED***
                else:
                    # if the type changed, we can safely overwrite absx
                    abs(absx, out=absx***REMOVED***
            absx **= ord
            return add.reduce(absx, axis=axis, keepdims=keepdims***REMOVED*** ** (1.0 / ord***REMOVED***
    elif len(axis***REMOVED*** == 2:
        row_axis, col_axis = axis
        if row_axis < 0:
            row_axis += nd
        if col_axis < 0:
            col_axis += nd
        if not (0 <= row_axis < nd and 0 <= col_axis < nd***REMOVED***:
            raise ValueError('Invalid axis %r for an array with shape %r' %
                             (axis, x.shape***REMOVED******REMOVED***
        if row_axis == col_axis:
            raise ValueError('Duplicate axes given.'***REMOVED***
        if ord == 2:
            ret =  _multi_svd_norm(x, row_axis, col_axis, amax***REMOVED***
        elif ord == -2:
            ret = _multi_svd_norm(x, row_axis, col_axis, amin***REMOVED***
        elif ord == 1:
            if col_axis > row_axis:
                col_axis -= 1
            ret = add.reduce(abs(x***REMOVED***, axis=row_axis***REMOVED***.max(axis=col_axis***REMOVED***
        elif ord == Inf:
            if row_axis > col_axis:
                row_axis -= 1
            ret = add.reduce(abs(x***REMOVED***, axis=col_axis***REMOVED***.max(axis=row_axis***REMOVED***
        elif ord == -1:
            if col_axis > row_axis:
                col_axis -= 1
            ret = add.reduce(abs(x***REMOVED***, axis=row_axis***REMOVED***.min(axis=col_axis***REMOVED***
        elif ord == -Inf:
            if row_axis > col_axis:
                row_axis -= 1
            ret = add.reduce(abs(x***REMOVED***, axis=col_axis***REMOVED***.min(axis=row_axis***REMOVED***
        elif ord in [None, 'fro', 'f'***REMOVED***:
            ret = sqrt(add.reduce((x.conj(***REMOVED*** * x***REMOVED***.real, axis=axis***REMOVED******REMOVED***
        elif ord == 'nuc':
            ret = _multi_svd_norm(x, row_axis, col_axis, sum***REMOVED***
        else:
            raise ValueError("Invalid norm order for matrices."***REMOVED***
        if keepdims:
            ret_shape = list(x.shape***REMOVED***
            ret_shape[axis[0***REMOVED******REMOVED*** = 1
            ret_shape[axis[1***REMOVED******REMOVED*** = 1
            ret = ret.reshape(ret_shape***REMOVED***
        return ret
    else:
        raise ValueError("Improper number of dimensions to norm."***REMOVED***


# multi_dot

def multi_dot(arrays***REMOVED***:
    ***REMOVED***
    Compute the dot product of two or more arrays in a single function call,
    while automatically selecting the fastest evaluation order.

    `multi_dot` chains `numpy.dot` and uses optimal parenthesization
    of the matrices [1***REMOVED***_ [2***REMOVED***_. Depending on the shapes of the matrices,
    this can speed up the multiplication a lot.

    If the first argument is 1-D it is treated as a row vector.
    If the last argument is 1-D it is treated as a column vector.
    The other arguments must be 2-D.

    Think of `multi_dot` as::

        def multi_dot(arrays***REMOVED***: return functools.reduce(np.dot, arrays***REMOVED***


    Parameters
    ----------
    arrays : sequence of array_like
        If the first argument is 1-D it is treated as row vector.
        If the last argument is 1-D it is treated as column vector.
        The other arguments must be 2-D.

    Returns
    -------
    output : ndarray
        Returns the dot product of the supplied arrays.

    See Also
    --------
    dot : dot multiplication with two arguments.

    References
    ----------

    .. [1***REMOVED*** Cormen, "Introduction to Algorithms", Chapter 15.2, p. 370-378
    .. [2***REMOVED*** http://en.wikipedia.org/wiki/Matrix_chain_multiplication

    Examples
    --------
    `multi_dot` allows you to write::

    >>> from numpy.linalg import multi_dot
    >>> # Prepare some data
    >>> A = np.random.random(10000, 100***REMOVED***
    >>> B = np.random.random(100, 1000***REMOVED***
    >>> C = np.random.random(1000, 5***REMOVED***
    >>> D = np.random.random(5, 333***REMOVED***
    >>> # the actual dot multiplication
    >>> multi_dot([A, B, C, D***REMOVED******REMOVED***

    instead of::

    >>> np.dot(np.dot(np.dot(A, B***REMOVED***, C***REMOVED***, D***REMOVED***
    >>> # or
    >>> A.dot(B***REMOVED***.dot(C***REMOVED***.dot(D***REMOVED***


    Example: multiplication costs of different parenthesizations
    ------------------------------------------------------------

    The cost for a matrix multiplication can be calculated with the
    following function::

        def cost(A, B***REMOVED***: return A.shape[0***REMOVED*** * A.shape[1***REMOVED*** * B.shape[1***REMOVED***

    Let's assume we have three matrices
    :math:`A_{10x100***REMOVED***, B_{100x5***REMOVED***, C_{5x50***REMOVED***$`.

    The costs for the two different parenthesizations are as follows::

        cost((AB***REMOVED***C***REMOVED*** = 10*100*5 + 10*5*50   = 5000 + 2500   = 7500
        cost(A(BC***REMOVED******REMOVED*** = 10*100*50 + 100*5*50 = 50000 + 25000 = 75000

    ***REMOVED***
    n = len(arrays***REMOVED***
    # optimization only makes sense for len(arrays***REMOVED*** > 2
    if n < 2:
        raise ValueError("Expecting at least two arrays."***REMOVED***
    elif n == 2:
        return dot(arrays[0***REMOVED***, arrays[1***REMOVED******REMOVED***

    arrays = [asanyarray(a***REMOVED*** for a in arrays***REMOVED***

    # save original ndim to reshape the result array into the proper form later
    ndim_first, ndim_last = arrays[0***REMOVED***.ndim, arrays[-1***REMOVED***.ndim
    # Explicitly convert vectors to 2D arrays to keep the logic of the internal
    # _multi_dot_* functions as simple as possible.
    if arrays[0***REMOVED***.ndim == 1:
        arrays[0***REMOVED*** = atleast_2d(arrays[0***REMOVED******REMOVED***
    if arrays[-1***REMOVED***.ndim == 1:
        arrays[-1***REMOVED*** = atleast_2d(arrays[-1***REMOVED******REMOVED***.T
    _assertRank2(*arrays***REMOVED***

    # _multi_dot_three is much faster than _multi_dot_matrix_chain_order
    if n == 3:
        result = _multi_dot_three(arrays[0***REMOVED***, arrays[1***REMOVED***, arrays[2***REMOVED******REMOVED***
    else:
        order = _multi_dot_matrix_chain_order(arrays***REMOVED***
        result = _multi_dot(arrays, order, 0, n - 1***REMOVED***

    # return proper shape
    if ndim_first == 1 and ndim_last == 1:
        return result[0, 0***REMOVED***  # scalar
    elif ndim_first == 1 or ndim_last == 1:
        return result.ravel(***REMOVED***  # 1-D
    else:
        return result


def _multi_dot_three(A, B, C***REMOVED***:
    ***REMOVED***
    Find the best order for three arrays and do the multiplication.

    For three arguments `_multi_dot_three` is approximately 15 times faster
    than `_multi_dot_matrix_chain_order`

    ***REMOVED***
    # cost1 = cost((AB***REMOVED***C***REMOVED***
    cost1 = (A.shape[0***REMOVED*** * A.shape[1***REMOVED*** * B.shape[1***REMOVED*** +  # (AB***REMOVED***
             A.shape[0***REMOVED*** * B.shape[1***REMOVED*** * C.shape[1***REMOVED******REMOVED***   # (--***REMOVED***C
    # cost2 = cost((AB***REMOVED***C***REMOVED***
    cost2 = (B.shape[0***REMOVED*** * B.shape[1***REMOVED*** * C.shape[1***REMOVED*** +  #  (BC***REMOVED***
             A.shape[0***REMOVED*** * A.shape[1***REMOVED*** * C.shape[1***REMOVED******REMOVED***   # A(--***REMOVED***

    if cost1 < cost2:
        return dot(dot(A, B***REMOVED***, C***REMOVED***
    else:
        return dot(A, dot(B, C***REMOVED******REMOVED***


def _multi_dot_matrix_chain_order(arrays, return_costs=False***REMOVED***:
    ***REMOVED***
    Return a np.array that encodes the optimal order of mutiplications.

    The optimal order array is then used by `_multi_dot(***REMOVED***` to do the
    multiplication.

    Also return the cost matrix if `return_costs` is `True`

    The implementation CLOSELY follows Cormen, "Introduction to Algorithms",
    Chapter 15.2, p. 370-378.  Note that Cormen uses 1-based indices.

        cost[i, j***REMOVED*** = min([
            cost[prefix***REMOVED*** + cost[suffix***REMOVED*** + cost_mult(prefix, suffix***REMOVED***
            for k in range(i, j***REMOVED******REMOVED******REMOVED***

    ***REMOVED***
    n = len(arrays***REMOVED***
    # p stores the dimensions of the matrices
    # Example for p: A_{10x100***REMOVED***, B_{100x5***REMOVED***, C_{5x50***REMOVED*** --> p = [10, 100, 5, 50***REMOVED***
    p = [a.shape[0***REMOVED*** for a in arrays***REMOVED*** + [arrays[-1***REMOVED***.shape[1***REMOVED******REMOVED***
    # m is a matrix of costs of the subproblems
    # m[i,j***REMOVED***: min number of scalar multiplications needed to compute A_{i..j***REMOVED***
    m = zeros((n, n***REMOVED***, dtype=double***REMOVED***
    # s is the actual ordering
    # s[i, j***REMOVED*** is the value of k at which we split the product A_i..A_j
    s = empty((n, n***REMOVED***, dtype=intp***REMOVED***

    for l in range(1, n***REMOVED***:
        for i in range(n - l***REMOVED***:
            j = i + l
            m[i, j***REMOVED*** = Inf
            for k in range(i, j***REMOVED***:
                q = m[i, k***REMOVED*** + m[k+1, j***REMOVED*** + p[i***REMOVED****p[k+1***REMOVED****p[j+1***REMOVED***
                if q < m[i, j***REMOVED***:
                    m[i, j***REMOVED*** = q
                    s[i, j***REMOVED*** = k  # Note that Cormen uses 1-based index

    return (s, m***REMOVED*** if return_costs else s


def _multi_dot(arrays, order, i, j***REMOVED***:
    ***REMOVED***Actually do the multiplication with the given order.***REMOVED***
    if i == j:
        return arrays[i***REMOVED***
    else:
        return dot(_multi_dot(arrays, order, i, order[i, j***REMOVED******REMOVED***,
                   _multi_dot(arrays, order, order[i, j***REMOVED*** + 1, j***REMOVED******REMOVED***
