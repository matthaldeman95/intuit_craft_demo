***REMOVED*** Test functions for linalg module

***REMOVED***
from __future__ import division, absolute_import, print_function

***REMOVED***
import sys
import itertools
import traceback
import warnings

import numpy as np
from numpy import array, single, double, csingle, cdouble, dot, identity
from numpy import multiply, atleast_2d, inf, asarray, matrix
from numpy import linalg
from numpy.linalg import matrix_power, norm, matrix_rank, multi_dot
from numpy.linalg.linalg import _multi_dot_matrix_chain_order
from numpy.testing import (
    assert_, assert_equal, assert_raises, assert_array_equal,
    assert_almost_equal, assert_allclose, run_module_suite,
    dec, SkipTest
***REMOVED***


def ifthen(a, b***REMOVED***:
    return not a or b


def imply(a, b***REMOVED***:
    return not a or b


old_assert_almost_equal = assert_almost_equal


def assert_almost_equal(a, b, **kw***REMOVED***:
    if asarray(a***REMOVED***.dtype.type in (single, csingle***REMOVED***:
        decimal = 6
    else:
        decimal = 12
    old_assert_almost_equal(a, b, decimal=decimal, **kw***REMOVED***


def get_real_dtype(dtype***REMOVED***:
    return {single: single, double: double,
            csingle: single, cdouble: double***REMOVED***[dtype***REMOVED***


def get_complex_dtype(dtype***REMOVED***:
    return {single: csingle, double: cdouble,
            csingle: csingle, cdouble: cdouble***REMOVED***[dtype***REMOVED***


def get_rtol(dtype***REMOVED***:
    # Choose a safe rtol
    if dtype in (single, csingle***REMOVED***:
        return 1e-5
    else:
        return 1e-11


class LinalgCase(object***REMOVED***:

    def __init__(self, name, a, b, exception_cls=None***REMOVED***:
        assert_(isinstance(name, str***REMOVED******REMOVED***
        self.name = name
        self.a = a
        self.b = b
        self.exception_cls = exception_cls

    def check(self, do***REMOVED***:
        if self.exception_cls is None:
            do(self.a, self.b***REMOVED***
        else:
            assert_raises(self.exception_cls, do, self.a, self.b***REMOVED***

    def __repr__(self***REMOVED***:
        return "<LinalgCase: %s>" % (self.name,***REMOVED***


#
# Base test cases
#

np.random.seed(1234***REMOVED***

SQUARE_CASES = [
    LinalgCase("single",
               array([[1., 2.***REMOVED***, [3., 4.***REMOVED******REMOVED***, dtype=single***REMOVED***,
               array([2., 1.***REMOVED***, dtype=single***REMOVED******REMOVED***,
    LinalgCase("double",
               array([[1., 2.***REMOVED***, [3., 4.***REMOVED******REMOVED***, dtype=double***REMOVED***,
               array([2., 1.***REMOVED***, dtype=double***REMOVED******REMOVED***,
    LinalgCase("double_2",
               array([[1., 2.***REMOVED***, [3., 4.***REMOVED******REMOVED***, dtype=double***REMOVED***,
               array([[2., 1., 4.***REMOVED***, [3., 4., 6.***REMOVED******REMOVED***, dtype=double***REMOVED******REMOVED***,
    LinalgCase("csingle",
               array([[1. + 2j, 2 + 3j***REMOVED***, [3 + 4j, 4 + 5j***REMOVED******REMOVED***, dtype=csingle***REMOVED***,
               array([2. + 1j, 1. + 2j***REMOVED***, dtype=csingle***REMOVED******REMOVED***,
    LinalgCase("cdouble",
               array([[1. + 2j, 2 + 3j***REMOVED***, [3 + 4j, 4 + 5j***REMOVED******REMOVED***, dtype=cdouble***REMOVED***,
               array([2. + 1j, 1. + 2j***REMOVED***, dtype=cdouble***REMOVED******REMOVED***,
    LinalgCase("cdouble_2",
               array([[1. + 2j, 2 + 3j***REMOVED***, [3 + 4j, 4 + 5j***REMOVED******REMOVED***, dtype=cdouble***REMOVED***,
               array([[2. + 1j, 1. + 2j, 1 + 3j***REMOVED***, [1 - 2j, 1 - 3j, 1 - 6j***REMOVED******REMOVED***, dtype=cdouble***REMOVED******REMOVED***,
    LinalgCase("empty",
               atleast_2d(array([***REMOVED***, dtype=double***REMOVED******REMOVED***,
               atleast_2d(array([***REMOVED***, dtype=double***REMOVED******REMOVED***,
               linalg.LinAlgError***REMOVED***,
    LinalgCase("8x8",
               np.random.rand(8, 8***REMOVED***,
               np.random.rand(8***REMOVED******REMOVED***,
    LinalgCase("1x1",
               np.random.rand(1, 1***REMOVED***,
               np.random.rand(1***REMOVED******REMOVED***,
    LinalgCase("nonarray",
               [[1, 2***REMOVED***, [3, 4***REMOVED******REMOVED***,
               [2, 1***REMOVED******REMOVED***,
    LinalgCase("matrix_b_only",
               array([[1., 2.***REMOVED***, [3., 4.***REMOVED******REMOVED******REMOVED***,
               matrix([2., 1.***REMOVED******REMOVED***.T***REMOVED***,
    LinalgCase("matrix_a_and_b",
               matrix([[1., 2.***REMOVED***, [3., 4.***REMOVED******REMOVED******REMOVED***,
               matrix([2., 1.***REMOVED******REMOVED***.T***REMOVED***,
***REMOVED***

NONSQUARE_CASES = [
    LinalgCase("single_nsq_1",
               array([[1., 2., 3.***REMOVED***, [3., 4., 6.***REMOVED******REMOVED***, dtype=single***REMOVED***,
               array([2., 1.***REMOVED***, dtype=single***REMOVED******REMOVED***,
    LinalgCase("single_nsq_2",
               array([[1., 2.***REMOVED***, [3., 4.***REMOVED***, [5., 6.***REMOVED******REMOVED***, dtype=single***REMOVED***,
               array([2., 1., 3.***REMOVED***, dtype=single***REMOVED******REMOVED***,
    LinalgCase("double_nsq_1",
               array([[1., 2., 3.***REMOVED***, [3., 4., 6.***REMOVED******REMOVED***, dtype=double***REMOVED***,
               array([2., 1.***REMOVED***, dtype=double***REMOVED******REMOVED***,
    LinalgCase("double_nsq_2",
               array([[1., 2.***REMOVED***, [3., 4.***REMOVED***, [5., 6.***REMOVED******REMOVED***, dtype=double***REMOVED***,
               array([2., 1., 3.***REMOVED***, dtype=double***REMOVED******REMOVED***,
    LinalgCase("csingle_nsq_1",
               array(
                   [[1. + 1j, 2. + 2j, 3. - 3j***REMOVED***, [3. - 5j, 4. + 9j, 6. + 2j***REMOVED******REMOVED***, dtype=csingle***REMOVED***,
               array([2. + 1j, 1. + 2j***REMOVED***, dtype=csingle***REMOVED******REMOVED***,
    LinalgCase("csingle_nsq_2",
               array(
                   [[1. + 1j, 2. + 2j***REMOVED***, [3. - 3j, 4. - 9j***REMOVED***, [5. - 4j, 6. + 8j***REMOVED******REMOVED***, dtype=csingle***REMOVED***,
               array([2. + 1j, 1. + 2j, 3. - 3j***REMOVED***, dtype=csingle***REMOVED******REMOVED***,
    LinalgCase("cdouble_nsq_1",
               array(
                   [[1. + 1j, 2. + 2j, 3. - 3j***REMOVED***, [3. - 5j, 4. + 9j, 6. + 2j***REMOVED******REMOVED***, dtype=cdouble***REMOVED***,
               array([2. + 1j, 1. + 2j***REMOVED***, dtype=cdouble***REMOVED******REMOVED***,
    LinalgCase("cdouble_nsq_2",
               array(
                   [[1. + 1j, 2. + 2j***REMOVED***, [3. - 3j, 4. - 9j***REMOVED***, [5. - 4j, 6. + 8j***REMOVED******REMOVED***, dtype=cdouble***REMOVED***,
               array([2. + 1j, 1. + 2j, 3. - 3j***REMOVED***, dtype=cdouble***REMOVED******REMOVED***,
    LinalgCase("cdouble_nsq_1_2",
               array(
                   [[1. + 1j, 2. + 2j, 3. - 3j***REMOVED***, [3. - 5j, 4. + 9j, 6. + 2j***REMOVED******REMOVED***, dtype=cdouble***REMOVED***,
               array([[2. + 1j, 1. + 2j***REMOVED***, [1 - 1j, 2 - 2j***REMOVED******REMOVED***, dtype=cdouble***REMOVED******REMOVED***,
    LinalgCase("cdouble_nsq_2_2",
               array(
                   [[1. + 1j, 2. + 2j***REMOVED***, [3. - 3j, 4. - 9j***REMOVED***, [5. - 4j, 6. + 8j***REMOVED******REMOVED***, dtype=cdouble***REMOVED***,
               array([[2. + 1j, 1. + 2j***REMOVED***, [1 - 1j, 2 - 2j***REMOVED***, [1 - 1j, 2 - 2j***REMOVED******REMOVED***, dtype=cdouble***REMOVED******REMOVED***,
    LinalgCase("8x11",
               np.random.rand(8, 11***REMOVED***,
               np.random.rand(11***REMOVED******REMOVED***,
    LinalgCase("1x5",
               np.random.rand(1, 5***REMOVED***,
               np.random.rand(5***REMOVED******REMOVED***,
    LinalgCase("5x1",
               np.random.rand(5, 1***REMOVED***,
               np.random.rand(1***REMOVED******REMOVED***,
***REMOVED***

HERMITIAN_CASES = [
    LinalgCase("hsingle",
               array([[1., 2.***REMOVED***, [2., 1.***REMOVED******REMOVED***, dtype=single***REMOVED***,
               None***REMOVED***,
    LinalgCase("hdouble",
               array([[1., 2.***REMOVED***, [2., 1.***REMOVED******REMOVED***, dtype=double***REMOVED***,
               None***REMOVED***,
    LinalgCase("hcsingle",
               array([[1., 2 + 3j***REMOVED***, [2 - 3j, 1***REMOVED******REMOVED***, dtype=csingle***REMOVED***,
               None***REMOVED***,
    LinalgCase("hcdouble",
               array([[1., 2 + 3j***REMOVED***, [2 - 3j, 1***REMOVED******REMOVED***, dtype=cdouble***REMOVED***,
               None***REMOVED***,
    LinalgCase("hempty",
               atleast_2d(array([***REMOVED***, dtype=double***REMOVED******REMOVED***,
               None,
               linalg.LinAlgError***REMOVED***,
    LinalgCase("hnonarray",
               [[1, 2***REMOVED***, [2, 1***REMOVED******REMOVED***,
               None***REMOVED***,
    LinalgCase("matrix_b_only",
               array([[1., 2.***REMOVED***, [2., 1.***REMOVED******REMOVED******REMOVED***,
               None***REMOVED***,
    LinalgCase("hmatrix_a_and_b",
               matrix([[1., 2.***REMOVED***, [2., 1.***REMOVED******REMOVED******REMOVED***,
               None***REMOVED***,
    LinalgCase("hmatrix_1x1",
               np.random.rand(1, 1***REMOVED***,
               None***REMOVED***,
***REMOVED***


#
# Gufunc test cases
#

GENERALIZED_SQUARE_CASES = [***REMOVED***
GENERALIZED_NONSQUARE_CASES = [***REMOVED***
GENERALIZED_HERMITIAN_CASES = [***REMOVED***

for tgt, src in ((GENERALIZED_SQUARE_CASES, SQUARE_CASES***REMOVED***,
                 (GENERALIZED_NONSQUARE_CASES, NONSQUARE_CASES***REMOVED***,
                 (GENERALIZED_HERMITIAN_CASES, HERMITIAN_CASES***REMOVED******REMOVED***:
    for case in src:
        if not isinstance(case.a, np.ndarray***REMOVED***:
            continue

        a = np.array([case.a, 2 * case.a, 3 * case.a***REMOVED******REMOVED***
        if case.b is None:
            b = None
        else:
            b = np.array([case.b, 7 * case.b, 6 * case.b***REMOVED******REMOVED***
        new_case = LinalgCase(case.name + "_tile3", a, b,
                              case.exception_cls***REMOVED***
        tgt.append(new_case***REMOVED***

        a = np.array([case.a***REMOVED*** * 2 * 3***REMOVED***.reshape((3, 2***REMOVED*** + case.a.shape***REMOVED***
        if case.b is None:
            b = None
        else:
            b = np.array([case.b***REMOVED*** * 2 * 3***REMOVED***.reshape((3, 2***REMOVED*** + case.b.shape***REMOVED***
        new_case = LinalgCase(case.name + "_tile213", a, b,
                              case.exception_cls***REMOVED***
        tgt.append(new_case***REMOVED***

#
# Generate stride combination variations of the above
#


def _stride_comb_iter(x***REMOVED***:
    ***REMOVED***
    Generate cartesian product of strides for all axes
    ***REMOVED***

    if not isinstance(x, np.ndarray***REMOVED***:
        yield x, "nop"
        return

    stride_set = [(1,***REMOVED******REMOVED*** * x.ndim
    stride_set[-1***REMOVED*** = (1, 3, -4***REMOVED***
    if x.ndim > 1:
        stride_set[-2***REMOVED*** = (1, 3, -4***REMOVED***
    if x.ndim > 2:
        stride_set[-3***REMOVED*** = (1, -4***REMOVED***

    for repeats in itertools.product(*tuple(stride_set***REMOVED******REMOVED***:
        new_shape = [abs(a * b***REMOVED*** for a, b in zip(x.shape, repeats***REMOVED******REMOVED***
        slices = tuple([slice(None, None, repeat***REMOVED*** for repeat in repeats***REMOVED******REMOVED***

        # new array with different strides, but same data
        xi = np.empty(new_shape, dtype=x.dtype***REMOVED***
        xi.view(np.uint32***REMOVED***.fill(0xdeadbeef***REMOVED***
        xi = xi[slices***REMOVED***
        xi[...***REMOVED*** = x
        xi = xi.view(x.__class__***REMOVED***
        assert_(np.all(xi == x***REMOVED******REMOVED***
        yield xi, "stride_" + "_".join(["%+d" % j for j in repeats***REMOVED******REMOVED***

        # generate also zero strides if possible
        if x.ndim >= 1 and x.shape[-1***REMOVED*** == 1:
            s = list(x.strides***REMOVED***
            s[-1***REMOVED*** = 0
            xi = np.lib.stride_tricks.as_strided(x, strides=s***REMOVED***
            yield xi, "stride_xxx_0"
        if x.ndim >= 2 and x.shape[-2***REMOVED*** == 1:
            s = list(x.strides***REMOVED***
            s[-2***REMOVED*** = 0
            xi = np.lib.stride_tricks.as_strided(x, strides=s***REMOVED***
            yield xi, "stride_xxx_0_x"
        if x.ndim >= 2 and x.shape[:-2***REMOVED*** == (1, 1***REMOVED***:
            s = list(x.strides***REMOVED***
            s[-1***REMOVED*** = 0
            s[-2***REMOVED*** = 0
            xi = np.lib.stride_tricks.as_strided(x, strides=s***REMOVED***
            yield xi, "stride_xxx_0_0"

for src in (SQUARE_CASES,
            NONSQUARE_CASES,
            HERMITIAN_CASES,
            GENERALIZED_SQUARE_CASES,
            GENERALIZED_NONSQUARE_CASES,
            GENERALIZED_HERMITIAN_CASES***REMOVED***:

    new_cases = [***REMOVED***
    for case in src:
        for a, a_tag in _stride_comb_iter(case.a***REMOVED***:
            for b, b_tag in _stride_comb_iter(case.b***REMOVED***:
                new_case = LinalgCase(case.name + "_" + a_tag + "_" + b_tag, a, b,
                                      exception_cls=case.exception_cls***REMOVED***
                new_cases.append(new_case***REMOVED***
    src.extend(new_cases***REMOVED***


#
# Test different routines against the above cases
#

def _check_cases(func, cases***REMOVED***:
    for case in cases:
        ***REMOVED***
            case.check(func***REMOVED***
        except Exception:
            msg = "In test case: %r\n\n" % case
            msg += traceback.format_exc(***REMOVED***
            raise AssertionError(msg***REMOVED***


class LinalgTestCase(object***REMOVED***:

    def test_sq_cases(self***REMOVED***:
        _check_cases(self.do, SQUARE_CASES***REMOVED***


class LinalgNonsquareTestCase(object***REMOVED***:

    def test_sq_cases(self***REMOVED***:
        _check_cases(self.do, NONSQUARE_CASES***REMOVED***


class LinalgGeneralizedTestCase(object***REMOVED***:

    @dec.slow
    def test_generalized_sq_cases(self***REMOVED***:
        _check_cases(self.do, GENERALIZED_SQUARE_CASES***REMOVED***


class LinalgGeneralizedNonsquareTestCase(object***REMOVED***:

    @dec.slow
    def test_generalized_nonsq_cases(self***REMOVED***:
        _check_cases(self.do, GENERALIZED_NONSQUARE_CASES***REMOVED***


class HermitianTestCase(object***REMOVED***:

    def test_herm_cases(self***REMOVED***:
        _check_cases(self.do, HERMITIAN_CASES***REMOVED***


class HermitianGeneralizedTestCase(object***REMOVED***:

    @dec.slow
    def test_generalized_herm_cases(self***REMOVED***:
        _check_cases(self.do, GENERALIZED_HERMITIAN_CASES***REMOVED***


def dot_generalized(a, b***REMOVED***:
    a = asarray(a***REMOVED***
    if a.ndim >= 3:
        if a.ndim == b.ndim:
            # matrix x matrix
            new_shape = a.shape[:-1***REMOVED*** + b.shape[-1:***REMOVED***
        elif a.ndim == b.ndim + 1:
            # matrix x vector
            new_shape = a.shape[:-1***REMOVED***
        else:
            raise ValueError("Not implemented..."***REMOVED***
        r = np.empty(new_shape, dtype=np.common_type(a, b***REMOVED******REMOVED***
        for c in itertools.product(*map(range, a.shape[:-2***REMOVED******REMOVED******REMOVED***:
            r[c***REMOVED*** = dot(a[c***REMOVED***, b[c***REMOVED******REMOVED***
        return r
    else:
        return dot(a, b***REMOVED***


def identity_like_generalized(a***REMOVED***:
    a = asarray(a***REMOVED***
    if a.ndim >= 3:
        r = np.empty(a.shape, dtype=a.dtype***REMOVED***
        for c in itertools.product(*map(range, a.shape[:-2***REMOVED******REMOVED******REMOVED***:
            r[c***REMOVED*** = identity(a.shape[-2***REMOVED******REMOVED***
        return r
    else:
        return identity(a.shape[0***REMOVED******REMOVED***


class TestSolve(LinalgTestCase, LinalgGeneralizedTestCase***REMOVED***:

    def do(self, a, b***REMOVED***:
        x = linalg.solve(a, b***REMOVED***
        assert_almost_equal(b, dot_generalized(a, x***REMOVED******REMOVED***
        assert_(imply(isinstance(b, matrix***REMOVED***, isinstance(x, matrix***REMOVED******REMOVED******REMOVED***

    def test_types(self***REMOVED***:
        def check(dtype***REMOVED***:
            x = np.array([[1, 0.5***REMOVED***, [0.5, 1***REMOVED******REMOVED***, dtype=dtype***REMOVED***
            assert_equal(linalg.solve(x, x***REMOVED***.dtype, dtype***REMOVED***
        for dtype in [single, double, csingle, cdouble***REMOVED***:
            yield check, dtype

    def test_0_size(self***REMOVED***:
        class ArraySubclass(np.ndarray***REMOVED***:
            pass
        # Test system of 0x0 matrices
        a = np.arange(8***REMOVED***.reshape(2, 2, 2***REMOVED***
        b = np.arange(6***REMOVED***.reshape(1, 2, 3***REMOVED***.view(ArraySubclass***REMOVED***

        expected = linalg.solve(a, b***REMOVED***[:, 0:0, :***REMOVED***
        result = linalg.solve(a[:, 0:0, 0:0***REMOVED***, b[:, 0:0, :***REMOVED******REMOVED***
        assert_array_equal(result, expected***REMOVED***
        assert_(isinstance(result, ArraySubclass***REMOVED******REMOVED***

        # Test errors for non-square and only b's dimension being 0
        assert_raises(linalg.LinAlgError, linalg.solve, a[:, 0:0, 0:1***REMOVED***, b***REMOVED***
        assert_raises(ValueError, linalg.solve, a, b[:, 0:0, :***REMOVED******REMOVED***

        # Test broadcasting error
        b = np.arange(6***REMOVED***.reshape(1, 3, 2***REMOVED***  # broadcasting error
        assert_raises(ValueError, linalg.solve, a, b***REMOVED***
        assert_raises(ValueError, linalg.solve, a[0:0***REMOVED***, b[0:0***REMOVED******REMOVED***

        # Test zero "single equations" with 0x0 matrices.
        b = np.arange(2***REMOVED***.reshape(1, 2***REMOVED***.view(ArraySubclass***REMOVED***
        expected = linalg.solve(a, b***REMOVED***[:, 0:0***REMOVED***
        result = linalg.solve(a[:, 0:0, 0:0***REMOVED***, b[:, 0:0***REMOVED******REMOVED***
        assert_array_equal(result, expected***REMOVED***
        assert_(isinstance(result, ArraySubclass***REMOVED******REMOVED***

        b = np.arange(3***REMOVED***.reshape(1, 3***REMOVED***
        assert_raises(ValueError, linalg.solve, a, b***REMOVED***
        assert_raises(ValueError, linalg.solve, a[0:0***REMOVED***, b[0:0***REMOVED******REMOVED***
        assert_raises(ValueError, linalg.solve, a[:, 0:0, 0:0***REMOVED***, b***REMOVED***

    def test_0_size_k(self***REMOVED***:
        # test zero multiple equation (K=0***REMOVED*** case.
        class ArraySubclass(np.ndarray***REMOVED***:
            pass
        a = np.arange(4***REMOVED***.reshape(1, 2, 2***REMOVED***
        b = np.arange(6***REMOVED***.reshape(3, 2, 1***REMOVED***.view(ArraySubclass***REMOVED***

        expected = linalg.solve(a, b***REMOVED***[:, :, 0:0***REMOVED***
        result = linalg.solve(a, b[:, :, 0:0***REMOVED******REMOVED***
        assert_array_equal(result, expected***REMOVED***
        assert_(isinstance(result, ArraySubclass***REMOVED******REMOVED***

        # test both zero.
        expected = linalg.solve(a, b***REMOVED***[:, 0:0, 0:0***REMOVED***
        result = linalg.solve(a[:, 0:0, 0:0***REMOVED***, b[:, 0:0, 0:0***REMOVED******REMOVED***
        assert_array_equal(result, expected***REMOVED***
        assert_(isinstance(result, ArraySubclass***REMOVED******REMOVED***


class TestInv(LinalgTestCase, LinalgGeneralizedTestCase***REMOVED***:

    def do(self, a, b***REMOVED***:
        a_inv = linalg.inv(a***REMOVED***
        assert_almost_equal(dot_generalized(a, a_inv***REMOVED***,
                            identity_like_generalized(a***REMOVED******REMOVED***
        assert_(imply(isinstance(a, matrix***REMOVED***, isinstance(a_inv, matrix***REMOVED******REMOVED******REMOVED***

    def test_types(self***REMOVED***:
        def check(dtype***REMOVED***:
            x = np.array([[1, 0.5***REMOVED***, [0.5, 1***REMOVED******REMOVED***, dtype=dtype***REMOVED***
            assert_equal(linalg.inv(x***REMOVED***.dtype, dtype***REMOVED***
        for dtype in [single, double, csingle, cdouble***REMOVED***:
            yield check, dtype

    def test_0_size(self***REMOVED***:
        # Check that all kinds of 0-sized arrays work
        class ArraySubclass(np.ndarray***REMOVED***:
            pass
        a = np.zeros((0, 1, 1***REMOVED***, dtype=np.int_***REMOVED***.view(ArraySubclass***REMOVED***
        res = linalg.inv(a***REMOVED***
        assert_(res.dtype.type is np.float64***REMOVED***
        assert_equal(a.shape, res.shape***REMOVED***
        assert_(isinstance(a, ArraySubclass***REMOVED******REMOVED***

        a = np.zeros((0, 0***REMOVED***, dtype=np.complex64***REMOVED***.view(ArraySubclass***REMOVED***
        res = linalg.inv(a***REMOVED***
        assert_(res.dtype.type is np.complex64***REMOVED***
        assert_equal(a.shape, res.shape***REMOVED***


class TestEigvals(LinalgTestCase, LinalgGeneralizedTestCase***REMOVED***:

    def do(self, a, b***REMOVED***:
        ev = linalg.eigvals(a***REMOVED***
        evalues, evectors = linalg.eig(a***REMOVED***
        assert_almost_equal(ev, evalues***REMOVED***

    def test_types(self***REMOVED***:
        def check(dtype***REMOVED***:
            x = np.array([[1, 0.5***REMOVED***, [0.5, 1***REMOVED******REMOVED***, dtype=dtype***REMOVED***
            assert_equal(linalg.eigvals(x***REMOVED***.dtype, dtype***REMOVED***
            x = np.array([[1, 0.5***REMOVED***, [-1, 1***REMOVED******REMOVED***, dtype=dtype***REMOVED***
            assert_equal(linalg.eigvals(x***REMOVED***.dtype, get_complex_dtype(dtype***REMOVED******REMOVED***
        for dtype in [single, double, csingle, cdouble***REMOVED***:
            yield check, dtype


class TestEig(LinalgTestCase, LinalgGeneralizedTestCase***REMOVED***:

    def do(self, a, b***REMOVED***:
        evalues, evectors = linalg.eig(a***REMOVED***
        assert_allclose(dot_generalized(a, evectors***REMOVED***,
                        np.asarray(evectors***REMOVED*** * np.asarray(evalues***REMOVED***[..., None, :***REMOVED***,
                        rtol=get_rtol(evalues.dtype***REMOVED******REMOVED***
        assert_(imply(isinstance(a, matrix***REMOVED***, isinstance(evectors, matrix***REMOVED******REMOVED******REMOVED***

    def test_types(self***REMOVED***:
        def check(dtype***REMOVED***:
            x = np.array([[1, 0.5***REMOVED***, [0.5, 1***REMOVED******REMOVED***, dtype=dtype***REMOVED***
            w, v = np.linalg.eig(x***REMOVED***
            assert_equal(w.dtype, dtype***REMOVED***
            assert_equal(v.dtype, dtype***REMOVED***

            x = np.array([[1, 0.5***REMOVED***, [-1, 1***REMOVED******REMOVED***, dtype=dtype***REMOVED***
            w, v = np.linalg.eig(x***REMOVED***
            assert_equal(w.dtype, get_complex_dtype(dtype***REMOVED******REMOVED***
            assert_equal(v.dtype, get_complex_dtype(dtype***REMOVED******REMOVED***

        for dtype in [single, double, csingle, cdouble***REMOVED***:
            yield check, dtype


class TestSVD(LinalgTestCase, LinalgGeneralizedTestCase***REMOVED***:

    def do(self, a, b***REMOVED***:
        u, s, vt = linalg.svd(a, 0***REMOVED***
        assert_allclose(a, dot_generalized(np.asarray(u***REMOVED*** * np.asarray(s***REMOVED***[..., None, :***REMOVED***,
                                           np.asarray(vt***REMOVED******REMOVED***,
                        rtol=get_rtol(u.dtype***REMOVED******REMOVED***
        assert_(imply(isinstance(a, matrix***REMOVED***, isinstance(u, matrix***REMOVED******REMOVED******REMOVED***
        assert_(imply(isinstance(a, matrix***REMOVED***, isinstance(vt, matrix***REMOVED******REMOVED******REMOVED***

    def test_types(self***REMOVED***:
        def check(dtype***REMOVED***:
            x = np.array([[1, 0.5***REMOVED***, [0.5, 1***REMOVED******REMOVED***, dtype=dtype***REMOVED***
            u, s, vh = linalg.svd(x***REMOVED***
            assert_equal(u.dtype, dtype***REMOVED***
            assert_equal(s.dtype, get_real_dtype(dtype***REMOVED******REMOVED***
            assert_equal(vh.dtype, dtype***REMOVED***
            s = linalg.svd(x, compute_uv=False***REMOVED***
            assert_equal(s.dtype, get_real_dtype(dtype***REMOVED******REMOVED***

        for dtype in [single, double, csingle, cdouble***REMOVED***:
            yield check, dtype


class TestCondSVD(LinalgTestCase, LinalgGeneralizedTestCase***REMOVED***:

    def do(self, a, b***REMOVED***:
        c = asarray(a***REMOVED***  # a might be a matrix
        s = linalg.svd(c, compute_uv=False***REMOVED***
        old_assert_almost_equal(
            s[..., 0***REMOVED*** / s[..., -1***REMOVED***, linalg.cond(a***REMOVED***, decimal=5***REMOVED***

    def test_stacked_arrays_explicitly(self***REMOVED***:
        A = np.array([[1., 2., 1.***REMOVED***, [0, -2., 0***REMOVED***, [6., 2., 3.***REMOVED******REMOVED******REMOVED***
        assert_equal(linalg.cond(A***REMOVED***, linalg.cond(A[None, ...***REMOVED******REMOVED***[0***REMOVED******REMOVED***


class TestCond2(LinalgTestCase***REMOVED***:

    def do(self, a, b***REMOVED***:
        c = asarray(a***REMOVED***  # a might be a matrix
        s = linalg.svd(c, compute_uv=False***REMOVED***
        old_assert_almost_equal(
            s[..., 0***REMOVED*** / s[..., -1***REMOVED***, linalg.cond(a, 2***REMOVED***, decimal=5***REMOVED***

    def test_stacked_arrays_explicitly(self***REMOVED***:
        A = np.array([[1., 2., 1.***REMOVED***, [0, -2., 0***REMOVED***, [6., 2., 3.***REMOVED******REMOVED******REMOVED***
        assert_equal(linalg.cond(A, 2***REMOVED***, linalg.cond(A[None, ...***REMOVED***, 2***REMOVED***[0***REMOVED******REMOVED***


class TestCondInf(object***REMOVED***:

    def test(self***REMOVED***:
        A = array([[1., 0, 0***REMOVED***, [0, -2., 0***REMOVED***, [0, 0, 3.***REMOVED******REMOVED******REMOVED***
        assert_almost_equal(linalg.cond(A, inf***REMOVED***, 3.***REMOVED***


class TestPinv(LinalgTestCase***REMOVED***:

    def do(self, a, b***REMOVED***:
        a_ginv = linalg.pinv(a***REMOVED***
        assert_almost_equal(dot(a, a_ginv***REMOVED***, identity(asarray(a***REMOVED***.shape[0***REMOVED******REMOVED******REMOVED***
        assert_(imply(isinstance(a, matrix***REMOVED***, isinstance(a_ginv, matrix***REMOVED******REMOVED******REMOVED***


class TestDet(LinalgTestCase, LinalgGeneralizedTestCase***REMOVED***:

    def do(self, a, b***REMOVED***:
        d = linalg.det(a***REMOVED***
        (s, ld***REMOVED*** = linalg.slogdet(a***REMOVED***
        if asarray(a***REMOVED***.dtype.type in (single, double***REMOVED***:
            ad = asarray(a***REMOVED***.astype(double***REMOVED***
        else:
            ad = asarray(a***REMOVED***.astype(cdouble***REMOVED***
        ev = linalg.eigvals(ad***REMOVED***
        assert_almost_equal(d, multiply.reduce(ev, axis=-1***REMOVED******REMOVED***
        assert_almost_equal(s * np.exp(ld***REMOVED***, multiply.reduce(ev, axis=-1***REMOVED******REMOVED***

        s = np.atleast_1d(s***REMOVED***
        ld = np.atleast_1d(ld***REMOVED***
        m = (s != 0***REMOVED***
        assert_almost_equal(np.abs(s[m***REMOVED******REMOVED***, 1***REMOVED***
        assert_equal(ld[~m***REMOVED***, -inf***REMOVED***

    def test_zero(self***REMOVED***:
        assert_equal(linalg.det([[0.0***REMOVED******REMOVED******REMOVED***, 0.0***REMOVED***
        assert_equal(type(linalg.det([[0.0***REMOVED******REMOVED******REMOVED******REMOVED***, double***REMOVED***
        assert_equal(linalg.det([[0.0j***REMOVED******REMOVED******REMOVED***, 0.0***REMOVED***
        assert_equal(type(linalg.det([[0.0j***REMOVED******REMOVED******REMOVED******REMOVED***, cdouble***REMOVED***

        assert_equal(linalg.slogdet([[0.0***REMOVED******REMOVED******REMOVED***, (0.0, -inf***REMOVED******REMOVED***
        assert_equal(type(linalg.slogdet([[0.0***REMOVED******REMOVED******REMOVED***[0***REMOVED******REMOVED***, double***REMOVED***
        assert_equal(type(linalg.slogdet([[0.0***REMOVED******REMOVED******REMOVED***[1***REMOVED******REMOVED***, double***REMOVED***
        assert_equal(linalg.slogdet([[0.0j***REMOVED******REMOVED******REMOVED***, (0.0j, -inf***REMOVED******REMOVED***
        assert_equal(type(linalg.slogdet([[0.0j***REMOVED******REMOVED******REMOVED***[0***REMOVED******REMOVED***, cdouble***REMOVED***
        assert_equal(type(linalg.slogdet([[0.0j***REMOVED******REMOVED******REMOVED***[1***REMOVED******REMOVED***, double***REMOVED***

    def test_types(self***REMOVED***:
        def check(dtype***REMOVED***:
            x = np.array([[1, 0.5***REMOVED***, [0.5, 1***REMOVED******REMOVED***, dtype=dtype***REMOVED***
            assert_equal(np.linalg.det(x***REMOVED***.dtype, dtype***REMOVED***
            ph, s = np.linalg.slogdet(x***REMOVED***
            assert_equal(s.dtype, get_real_dtype(dtype***REMOVED******REMOVED***
            assert_equal(ph.dtype, dtype***REMOVED***
        for dtype in [single, double, csingle, cdouble***REMOVED***:
            yield check, dtype


class TestLstsq(LinalgTestCase, LinalgNonsquareTestCase***REMOVED***:

    def do(self, a, b***REMOVED***:
        arr = np.asarray(a***REMOVED***
        m, n = arr.shape
        u, s, vt = linalg.svd(a, 0***REMOVED***
        x, residuals, rank, sv = linalg.lstsq(a, b***REMOVED***
        if m <= n:
            assert_almost_equal(b, dot(a, x***REMOVED******REMOVED***
            assert_equal(rank, m***REMOVED***
        else:
            assert_equal(rank, n***REMOVED***
        assert_almost_equal(sv, sv.__array_wrap__(s***REMOVED******REMOVED***
        if rank == n and m > n:
            expect_resids = (
                np.asarray(abs(np.dot(a, x***REMOVED*** - b***REMOVED******REMOVED*** ** 2***REMOVED***.sum(axis=0***REMOVED***
            expect_resids = np.asarray(expect_resids***REMOVED***
            if len(np.asarray(b***REMOVED***.shape***REMOVED*** == 1:
                expect_resids.shape = (1,***REMOVED***
                assert_equal(residuals.shape, expect_resids.shape***REMOVED***
        else:
            expect_resids = np.array([***REMOVED******REMOVED***.view(type(x***REMOVED******REMOVED***
        assert_almost_equal(residuals, expect_resids***REMOVED***
        assert_(np.issubdtype(residuals.dtype, np.floating***REMOVED******REMOVED***
        assert_(imply(isinstance(b, matrix***REMOVED***, isinstance(x, matrix***REMOVED******REMOVED******REMOVED***
        assert_(imply(isinstance(b, matrix***REMOVED***, isinstance(residuals, matrix***REMOVED******REMOVED******REMOVED***


class TestMatrixPower(object***REMOVED***:
    R90 = array([[0, 1***REMOVED***, [-1, 0***REMOVED******REMOVED******REMOVED***
    Arb22 = array([[4, -7***REMOVED***, [-2, 10***REMOVED******REMOVED******REMOVED***
    noninv = array([[1, 0***REMOVED***, [0, 0***REMOVED******REMOVED******REMOVED***
    arbfloat = array([[0.1, 3.2***REMOVED***, [1.2, 0.7***REMOVED******REMOVED******REMOVED***

    large = identity(10***REMOVED***
    t = large[1, :***REMOVED***.copy(***REMOVED***
    large[1, :***REMOVED*** = large[0,:***REMOVED***
    large[0, :***REMOVED*** = t

    def test_large_power(self***REMOVED***:
        assert_equal(
            matrix_power(self.R90, 2 ** 100 + 2 ** 10 + 2 ** 5 + 1***REMOVED***, self.R90***REMOVED***

    def test_large_power_trailing_zero(self***REMOVED***:
        assert_equal(
            matrix_power(self.R90, 2 ** 100 + 2 ** 10 + 2 ** 5***REMOVED***, identity(2***REMOVED******REMOVED***

    def testip_zero(self***REMOVED***:
        def tz(M***REMOVED***:
            mz = matrix_power(M, 0***REMOVED***
            assert_equal(mz, identity(M.shape[0***REMOVED******REMOVED******REMOVED***
            assert_equal(mz.dtype, M.dtype***REMOVED***
        for M in [self.Arb22, self.arbfloat, self.large***REMOVED***:
            yield tz, M

    def testip_one(self***REMOVED***:
        def tz(M***REMOVED***:
            mz = matrix_power(M, 1***REMOVED***
            assert_equal(mz, M***REMOVED***
            assert_equal(mz.dtype, M.dtype***REMOVED***
        for M in [self.Arb22, self.arbfloat, self.large***REMOVED***:
            yield tz, M

    def testip_two(self***REMOVED***:
        def tz(M***REMOVED***:
            mz = matrix_power(M, 2***REMOVED***
            assert_equal(mz, dot(M, M***REMOVED******REMOVED***
            assert_equal(mz.dtype, M.dtype***REMOVED***
        for M in [self.Arb22, self.arbfloat, self.large***REMOVED***:
            yield tz, M

    def testip_invert(self***REMOVED***:
        def tz(M***REMOVED***:
            mz = matrix_power(M, -1***REMOVED***
            assert_almost_equal(identity(M.shape[0***REMOVED******REMOVED***, dot(mz, M***REMOVED******REMOVED***
        for M in [self.R90, self.Arb22, self.arbfloat, self.large***REMOVED***:
            yield tz, M

    def test_invert_noninvertible(self***REMOVED***:
        import numpy.linalg
        assert_raises(numpy.linalg.linalg.LinAlgError,
                      lambda: matrix_power(self.noninv, -1***REMOVED******REMOVED***


class TestBoolPower(object***REMOVED***:

    def test_square(self***REMOVED***:
        A = array([[True, False***REMOVED***, [True, True***REMOVED******REMOVED******REMOVED***
        assert_equal(matrix_power(A, 2***REMOVED***, A***REMOVED***


class TestEigvalsh(HermitianTestCase, HermitianGeneralizedTestCase***REMOVED***:

    def do(self, a, b***REMOVED***:
        # note that eigenvalue arrays returned by eig must be sorted since
        # their order isn't guaranteed.
        ev = linalg.eigvalsh(a, 'L'***REMOVED***
        evalues, evectors = linalg.eig(a***REMOVED***
        evalues.sort(axis=-1***REMOVED***
        assert_allclose(ev, evalues, rtol=get_rtol(ev.dtype***REMOVED******REMOVED***

        ev2 = linalg.eigvalsh(a, 'U'***REMOVED***
        assert_allclose(ev2, evalues, rtol=get_rtol(ev.dtype***REMOVED******REMOVED***

    def test_types(self***REMOVED***:
        def check(dtype***REMOVED***:
            x = np.array([[1, 0.5***REMOVED***, [0.5, 1***REMOVED******REMOVED***, dtype=dtype***REMOVED***
            w = np.linalg.eigvalsh(x***REMOVED***
            assert_equal(w.dtype, get_real_dtype(dtype***REMOVED******REMOVED***
        for dtype in [single, double, csingle, cdouble***REMOVED***:
            yield check, dtype

    def test_invalid(self***REMOVED***:
        x = np.array([[1, 0.5***REMOVED***, [0.5, 1***REMOVED******REMOVED***, dtype=np.float32***REMOVED***
        assert_raises(ValueError, np.linalg.eigvalsh, x, UPLO="lrong"***REMOVED***
        assert_raises(ValueError, np.linalg.eigvalsh, x, "lower"***REMOVED***
        assert_raises(ValueError, np.linalg.eigvalsh, x, "upper"***REMOVED***

    def test_UPLO(self***REMOVED***:
        Klo = np.array([[0, 0***REMOVED***, [1, 0***REMOVED******REMOVED***, dtype=np.double***REMOVED***
        Kup = np.array([[0, 1***REMOVED***, [0, 0***REMOVED******REMOVED***, dtype=np.double***REMOVED***
        tgt = np.array([-1, 1***REMOVED***, dtype=np.double***REMOVED***
        rtol = get_rtol(np.double***REMOVED***

        # Check default is 'L'
        w = np.linalg.eigvalsh(Klo***REMOVED***
        assert_allclose(w, tgt, rtol=rtol***REMOVED***
        # Check 'L'
        w = np.linalg.eigvalsh(Klo, UPLO='L'***REMOVED***
        assert_allclose(w, tgt, rtol=rtol***REMOVED***
        # Check 'l'
        w = np.linalg.eigvalsh(Klo, UPLO='l'***REMOVED***
        assert_allclose(w, tgt, rtol=rtol***REMOVED***
        # Check 'U'
        w = np.linalg.eigvalsh(Kup, UPLO='U'***REMOVED***
        assert_allclose(w, tgt, rtol=rtol***REMOVED***
        # Check 'u'
        w = np.linalg.eigvalsh(Kup, UPLO='u'***REMOVED***
        assert_allclose(w, tgt, rtol=rtol***REMOVED***


class TestEigh(HermitianTestCase, HermitianGeneralizedTestCase***REMOVED***:

    def do(self, a, b***REMOVED***:
        # note that eigenvalue arrays returned by eig must be sorted since
        # their order isn't guaranteed.
        ev, evc = linalg.eigh(a***REMOVED***
        evalues, evectors = linalg.eig(a***REMOVED***
        evalues.sort(axis=-1***REMOVED***
        assert_almost_equal(ev, evalues***REMOVED***

        assert_allclose(dot_generalized(a, evc***REMOVED***,
                        np.asarray(ev***REMOVED***[..., None, :***REMOVED*** * np.asarray(evc***REMOVED***,
                        rtol=get_rtol(ev.dtype***REMOVED******REMOVED***

        ev2, evc2 = linalg.eigh(a, 'U'***REMOVED***
        assert_almost_equal(ev2, evalues***REMOVED***

        assert_allclose(dot_generalized(a, evc2***REMOVED***,
                        np.asarray(ev2***REMOVED***[..., None, :***REMOVED*** * np.asarray(evc2***REMOVED***,
                        rtol=get_rtol(ev.dtype***REMOVED***, err_msg=repr(a***REMOVED******REMOVED***

    def test_types(self***REMOVED***:
        def check(dtype***REMOVED***:
            x = np.array([[1, 0.5***REMOVED***, [0.5, 1***REMOVED******REMOVED***, dtype=dtype***REMOVED***
            w, v = np.linalg.eigh(x***REMOVED***
            assert_equal(w.dtype, get_real_dtype(dtype***REMOVED******REMOVED***
            assert_equal(v.dtype, dtype***REMOVED***
        for dtype in [single, double, csingle, cdouble***REMOVED***:
            yield check, dtype

    def test_invalid(self***REMOVED***:
        x = np.array([[1, 0.5***REMOVED***, [0.5, 1***REMOVED******REMOVED***, dtype=np.float32***REMOVED***
        assert_raises(ValueError, np.linalg.eigh, x, UPLO="lrong"***REMOVED***
        assert_raises(ValueError, np.linalg.eigh, x, "lower"***REMOVED***
        assert_raises(ValueError, np.linalg.eigh, x, "upper"***REMOVED***

    def test_UPLO(self***REMOVED***:
        Klo = np.array([[0, 0***REMOVED***, [1, 0***REMOVED******REMOVED***, dtype=np.double***REMOVED***
        Kup = np.array([[0, 1***REMOVED***, [0, 0***REMOVED******REMOVED***, dtype=np.double***REMOVED***
        tgt = np.array([-1, 1***REMOVED***, dtype=np.double***REMOVED***
        rtol = get_rtol(np.double***REMOVED***

        # Check default is 'L'
        w, v = np.linalg.eigh(Klo***REMOVED***
        assert_allclose(w, tgt, rtol=rtol***REMOVED***
        # Check 'L'
        w, v = np.linalg.eigh(Klo, UPLO='L'***REMOVED***
        assert_allclose(w, tgt, rtol=rtol***REMOVED***
        # Check 'l'
        w, v = np.linalg.eigh(Klo, UPLO='l'***REMOVED***
        assert_allclose(w, tgt, rtol=rtol***REMOVED***
        # Check 'U'
        w, v = np.linalg.eigh(Kup, UPLO='U'***REMOVED***
        assert_allclose(w, tgt, rtol=rtol***REMOVED***
        # Check 'u'
        w, v = np.linalg.eigh(Kup, UPLO='u'***REMOVED***
        assert_allclose(w, tgt, rtol=rtol***REMOVED***


class _TestNorm(object***REMOVED***:

    dt = None
    dec = None

    def test_empty(self***REMOVED***:
        assert_equal(norm([***REMOVED******REMOVED***, 0.0***REMOVED***
        assert_equal(norm(array([***REMOVED***, dtype=self.dt***REMOVED******REMOVED***, 0.0***REMOVED***
        assert_equal(norm(atleast_2d(array([***REMOVED***, dtype=self.dt***REMOVED******REMOVED******REMOVED***, 0.0***REMOVED***

    def test_vector_return_type(self***REMOVED***:
        a = np.array([1, 0, 1***REMOVED******REMOVED***

        exact_types = np.typecodes['AllInteger'***REMOVED***
        inexact_types = np.typecodes['AllFloat'***REMOVED***

        all_types = exact_types + inexact_types

        for each_inexact_types in all_types:
            at = a.astype(each_inexact_types***REMOVED***

            an = norm(at, -np.inf***REMOVED***
            assert_(issubclass(an.dtype.type, np.floating***REMOVED******REMOVED***
            assert_almost_equal(an, 0.0***REMOVED***

            with warnings.catch_warnings(***REMOVED***:
                warnings.simplefilter("ignore", RuntimeWarning***REMOVED***
                an = norm(at, -1***REMOVED***
                assert_(issubclass(an.dtype.type, np.floating***REMOVED******REMOVED***
                assert_almost_equal(an, 0.0***REMOVED***

            an = norm(at, 0***REMOVED***
            assert_(issubclass(an.dtype.type, np.floating***REMOVED******REMOVED***
            assert_almost_equal(an, 2***REMOVED***

            an = norm(at, 1***REMOVED***
            assert_(issubclass(an.dtype.type, np.floating***REMOVED******REMOVED***
            assert_almost_equal(an, 2.0***REMOVED***

            an = norm(at, 2***REMOVED***
            assert_(issubclass(an.dtype.type, np.floating***REMOVED******REMOVED***
            assert_almost_equal(an, an.dtype.type(2.0***REMOVED*****an.dtype.type(1.0/2.0***REMOVED******REMOVED***

            an = norm(at, 4***REMOVED***
            assert_(issubclass(an.dtype.type, np.floating***REMOVED******REMOVED***
            assert_almost_equal(an, an.dtype.type(2.0***REMOVED*****an.dtype.type(1.0/4.0***REMOVED******REMOVED***

            an = norm(at, np.inf***REMOVED***
            assert_(issubclass(an.dtype.type, np.floating***REMOVED******REMOVED***
            assert_almost_equal(an, 1.0***REMOVED***

    def test_matrix_return_type(self***REMOVED***:
        a = np.array([[1, 0, 1***REMOVED***, [0, 1, 1***REMOVED******REMOVED******REMOVED***

        exact_types = np.typecodes['AllInteger'***REMOVED***

        # float32, complex64, float64, complex128 types are the only types
        # allowed by `linalg`, which performs the matrix operations used
        # within `norm`.
        inexact_types = 'fdFD'

        all_types = exact_types + inexact_types

        for each_inexact_types in all_types:
            at = a.astype(each_inexact_types***REMOVED***

            an = norm(at, -np.inf***REMOVED***
            assert_(issubclass(an.dtype.type, np.floating***REMOVED******REMOVED***
            assert_almost_equal(an, 2.0***REMOVED***

            with warnings.catch_warnings(***REMOVED***:
                warnings.simplefilter("ignore", RuntimeWarning***REMOVED***
                an = norm(at, -1***REMOVED***
                assert_(issubclass(an.dtype.type, np.floating***REMOVED******REMOVED***
                assert_almost_equal(an, 1.0***REMOVED***

            an = norm(at, 1***REMOVED***
            assert_(issubclass(an.dtype.type, np.floating***REMOVED******REMOVED***
            assert_almost_equal(an, 2.0***REMOVED***

            an = norm(at, 2***REMOVED***
            assert_(issubclass(an.dtype.type, np.floating***REMOVED******REMOVED***
            assert_almost_equal(an, 3.0**(1.0/2.0***REMOVED******REMOVED***

            an = norm(at, -2***REMOVED***
            assert_(issubclass(an.dtype.type, np.floating***REMOVED******REMOVED***
            assert_almost_equal(an, 1.0***REMOVED***

            an = norm(at, np.inf***REMOVED***
            assert_(issubclass(an.dtype.type, np.floating***REMOVED******REMOVED***
            assert_almost_equal(an, 2.0***REMOVED***

            an = norm(at, 'fro'***REMOVED***
            assert_(issubclass(an.dtype.type, np.floating***REMOVED******REMOVED***
            assert_almost_equal(an, 2.0***REMOVED***

            an = norm(at, 'nuc'***REMOVED***
            assert_(issubclass(an.dtype.type, np.floating***REMOVED******REMOVED***
            # Lower bar needed to support low precision floats.
            # They end up being off by 1 in the 7th place.
            old_assert_almost_equal(an, 2.7320508075688772, decimal=6***REMOVED***

    def test_vector(self***REMOVED***:
        a = [1, 2, 3, 4***REMOVED***
        b = [-1, -2, -3, -4***REMOVED***
        c = [-1, 2, -3, 4***REMOVED***

        def _test(v***REMOVED***:
            np.testing.assert_almost_equal(norm(v***REMOVED***, 30 ** 0.5,
                                           decimal=self.dec***REMOVED***
            np.testing.assert_almost_equal(norm(v, inf***REMOVED***, 4.0,
                                           decimal=self.dec***REMOVED***
            np.testing.assert_almost_equal(norm(v, -inf***REMOVED***, 1.0,
                                           decimal=self.dec***REMOVED***
            np.testing.assert_almost_equal(norm(v, 1***REMOVED***, 10.0,
                                           decimal=self.dec***REMOVED***
            np.testing.assert_almost_equal(norm(v, -1***REMOVED***, 12.0 / 25,
                                           decimal=self.dec***REMOVED***
            np.testing.assert_almost_equal(norm(v, 2***REMOVED***, 30 ** 0.5,
                                           decimal=self.dec***REMOVED***
            np.testing.assert_almost_equal(norm(v, -2***REMOVED***, ((205. / 144***REMOVED*** ** -0.5***REMOVED***,
                                           decimal=self.dec***REMOVED***
            np.testing.assert_almost_equal(norm(v, 0***REMOVED***, 4,
                                           decimal=self.dec***REMOVED***

        for v in (a, b, c,***REMOVED***:
            _test(v***REMOVED***

        for v in (array(a, dtype=self.dt***REMOVED***, array(b, dtype=self.dt***REMOVED***,
                  array(c, dtype=self.dt***REMOVED******REMOVED***:
            _test(v***REMOVED***

    def test_matrix_2x2(self***REMOVED***:
        A = matrix([[1, 3***REMOVED***, [5, 7***REMOVED******REMOVED***, dtype=self.dt***REMOVED***
        assert_almost_equal(norm(A***REMOVED***, 84 ** 0.5***REMOVED***
        assert_almost_equal(norm(A, 'fro'***REMOVED***, 84 ** 0.5***REMOVED***
        assert_almost_equal(norm(A, 'nuc'***REMOVED***, 10.0***REMOVED***
        assert_almost_equal(norm(A, inf***REMOVED***, 12.0***REMOVED***
        assert_almost_equal(norm(A, -inf***REMOVED***, 4.0***REMOVED***
        assert_almost_equal(norm(A, 1***REMOVED***, 10.0***REMOVED***
        assert_almost_equal(norm(A, -1***REMOVED***, 6.0***REMOVED***
        assert_almost_equal(norm(A, 2***REMOVED***, 9.1231056256176615***REMOVED***
        assert_almost_equal(norm(A, -2***REMOVED***, 0.87689437438234041***REMOVED***

        assert_raises(ValueError, norm, A, 'nofro'***REMOVED***
        assert_raises(ValueError, norm, A, -3***REMOVED***
        assert_raises(ValueError, norm, A, 0***REMOVED***

    def test_matrix_3x3(self***REMOVED***:
        # This test has been added because the 2x2 example
        # happened to have equal nuclear norm and induced 1-norm.
        # The 1/10 scaling factor accommodates the absolute tolerance
        # used in assert_almost_equal.
        A = (1 / 10***REMOVED*** * \
            np.array([[1, 2, 3***REMOVED***, [6, 0, 5***REMOVED***, [3, 2, 1***REMOVED******REMOVED***, dtype=self.dt***REMOVED***
        assert_almost_equal(norm(A***REMOVED***, (1 / 10***REMOVED*** * 89 ** 0.5***REMOVED***
        assert_almost_equal(norm(A, 'fro'***REMOVED***, (1 / 10***REMOVED*** * 89 ** 0.5***REMOVED***
        assert_almost_equal(norm(A, 'nuc'***REMOVED***, 1.3366836911774836***REMOVED***
        assert_almost_equal(norm(A, inf***REMOVED***, 1.1***REMOVED***
        assert_almost_equal(norm(A, -inf***REMOVED***, 0.6***REMOVED***
        assert_almost_equal(norm(A, 1***REMOVED***, 1.0***REMOVED***
        assert_almost_equal(norm(A, -1***REMOVED***, 0.4***REMOVED***
        assert_almost_equal(norm(A, 2***REMOVED***, 0.88722940323461277***REMOVED***
        assert_almost_equal(norm(A, -2***REMOVED***, 0.19456584790481812***REMOVED***

    def test_axis(self***REMOVED***:
        # Vector norms.
        # Compare the use of `axis` with computing the norm of each row
        # or column separately.
        A = array([[1, 2, 3***REMOVED***, [4, 5, 6***REMOVED******REMOVED***, dtype=self.dt***REMOVED***
        for order in [None, -1, 0, 1, 2, 3, np.Inf, -np.Inf***REMOVED***:
            expected0 = [norm(A[:, k***REMOVED***, ord=order***REMOVED*** for k in range(A.shape[1***REMOVED******REMOVED******REMOVED***
            assert_almost_equal(norm(A, ord=order, axis=0***REMOVED***, expected0***REMOVED***
            expected1 = [norm(A[k, :***REMOVED***, ord=order***REMOVED*** for k in range(A.shape[0***REMOVED******REMOVED******REMOVED***
            assert_almost_equal(norm(A, ord=order, axis=1***REMOVED***, expected1***REMOVED***

        # Matrix norms.
        B = np.arange(1, 25, dtype=self.dt***REMOVED***.reshape(2, 3, 4***REMOVED***
        nd = B.ndim
        for order in [None, -2, 2, -1, 1, np.Inf, -np.Inf, 'fro'***REMOVED***:
            for axis in itertools.combinations(range(-nd, nd***REMOVED***, 2***REMOVED***:
                row_axis, col_axis = axis
                if row_axis < 0:
                    row_axis += nd
                if col_axis < 0:
                    col_axis += nd
                if row_axis == col_axis:
                    assert_raises(ValueError, norm, B, ord=order, axis=axis***REMOVED***
                else:
                    n = norm(B, ord=order, axis=axis***REMOVED***

                    # The logic using k_index only works for nd = 3.
                    # This has to be changed if nd is increased.
                    k_index = nd - (row_axis + col_axis***REMOVED***
                    if row_axis < col_axis:
                        expected = [norm(B[:***REMOVED***.take(k, axis=k_index***REMOVED***, ord=order***REMOVED***
                                    for k in range(B.shape[k_index***REMOVED******REMOVED******REMOVED***
                    else:
                        expected = [norm(B[:***REMOVED***.take(k, axis=k_index***REMOVED***.T, ord=order***REMOVED***
                                    for k in range(B.shape[k_index***REMOVED******REMOVED******REMOVED***
                    assert_almost_equal(n, expected***REMOVED***

    def test_keepdims(self***REMOVED***:
        A = np.arange(1, 25, dtype=self.dt***REMOVED***.reshape(2, 3, 4***REMOVED***

        allclose_err = 'order {0***REMOVED***, axis = {1***REMOVED***'
        shape_err = 'Shape mismatch found {0***REMOVED***, expected {1***REMOVED***, order={2***REMOVED***, axis={3***REMOVED***'

        # check the order=None, axis=None case
        expected = norm(A, ord=None, axis=None***REMOVED***
        found = norm(A, ord=None, axis=None, keepdims=True***REMOVED***
        assert_allclose(np.squeeze(found***REMOVED***, expected,
                        err_msg=allclose_err.format(None, None***REMOVED******REMOVED***
        expected_shape = (1, 1, 1***REMOVED***
        assert_(found.shape == expected_shape,
                shape_err.format(found.shape, expected_shape, None, None***REMOVED******REMOVED***

        # Vector norms.
        for order in [None, -1, 0, 1, 2, 3, np.Inf, -np.Inf***REMOVED***:
            for k in range(A.ndim***REMOVED***:
                expected = norm(A, ord=order, axis=k***REMOVED***
                found = norm(A, ord=order, axis=k, keepdims=True***REMOVED***
                assert_allclose(np.squeeze(found***REMOVED***, expected,
                                err_msg=allclose_err.format(order, k***REMOVED******REMOVED***
                expected_shape = list(A.shape***REMOVED***
                expected_shape[k***REMOVED*** = 1
                expected_shape = tuple(expected_shape***REMOVED***
                assert_(found.shape == expected_shape,
                        shape_err.format(found.shape, expected_shape, order, k***REMOVED******REMOVED***

        # Matrix norms.
        for order in [None, -2, 2, -1, 1, np.Inf, -np.Inf, 'fro', 'nuc'***REMOVED***:
            for k in itertools.permutations(range(A.ndim***REMOVED***, 2***REMOVED***:
                expected = norm(A, ord=order, axis=k***REMOVED***
                found = norm(A, ord=order, axis=k, keepdims=True***REMOVED***
                assert_allclose(np.squeeze(found***REMOVED***, expected,
                                err_msg=allclose_err.format(order, k***REMOVED******REMOVED***
                expected_shape = list(A.shape***REMOVED***
                expected_shape[k[0***REMOVED******REMOVED*** = 1
                expected_shape[k[1***REMOVED******REMOVED*** = 1
                expected_shape = tuple(expected_shape***REMOVED***
                assert_(found.shape == expected_shape,
                        shape_err.format(found.shape, expected_shape, order, k***REMOVED******REMOVED***

    def test_bad_args(self***REMOVED***:
        # Check that bad arguments raise the appropriate exceptions.

        A = array([[1, 2, 3***REMOVED***, [4, 5, 6***REMOVED******REMOVED***, dtype=self.dt***REMOVED***
        B = np.arange(1, 25, dtype=self.dt***REMOVED***.reshape(2, 3, 4***REMOVED***

        # Using `axis=<integer>` or passing in a 1-D array implies vector
        # norms are being computed, so also using `ord='fro'`
        # or `ord='nuc'` raises a ValueError.
        assert_raises(ValueError, norm, A, 'fro', 0***REMOVED***
        assert_raises(ValueError, norm, A, 'nuc', 0***REMOVED***
        assert_raises(ValueError, norm, [3, 4***REMOVED***, 'fro', None***REMOVED***
        assert_raises(ValueError, norm, [3, 4***REMOVED***, 'nuc', None***REMOVED***

        # Similarly, norm should raise an exception when ord is any finite
        # number other than 1, 2, -1 or -2 when computing matrix norms.
        for order in [0, 3***REMOVED***:
            assert_raises(ValueError, norm, A, order, None***REMOVED***
            assert_raises(ValueError, norm, A, order, (0, 1***REMOVED******REMOVED***
            assert_raises(ValueError, norm, B, order, (1, 2***REMOVED******REMOVED***

        # Invalid axis
        assert_raises(ValueError, norm, B, None, 3***REMOVED***
        assert_raises(ValueError, norm, B, None, (2, 3***REMOVED******REMOVED***
        assert_raises(ValueError, norm, B, None, (0, 1, 2***REMOVED******REMOVED***


class TestNorm_NonSystematic(object***REMOVED***:

    def test_longdouble_norm(self***REMOVED***:
        # Non-regression test: p-norm of longdouble would previously raise
        # UnboundLocalError.
        x = np.arange(10, dtype=np.longdouble***REMOVED***
        old_assert_almost_equal(norm(x, ord=3***REMOVED***, 12.65, decimal=2***REMOVED***

    def test_intmin(self***REMOVED***:
        # Non-regression test: p-norm of signed integer would previously do
        # float cast and abs in the wrong order.
        x = np.array([-2 ** 31***REMOVED***, dtype=np.int32***REMOVED***
        old_assert_almost_equal(norm(x, ord=3***REMOVED***, 2 ** 31, decimal=5***REMOVED***

    def test_complex_high_ord(self***REMOVED***:
        # gh-4156
        d = np.empty((2,***REMOVED***, dtype=np.clongdouble***REMOVED***
        d[0***REMOVED*** = 6 + 7j
        d[1***REMOVED*** = -6 + 7j
        res = 11.615898132184
        old_assert_almost_equal(np.linalg.norm(d, ord=3***REMOVED***, res, decimal=10***REMOVED***
        d = d.astype(np.complex128***REMOVED***
        old_assert_almost_equal(np.linalg.norm(d, ord=3***REMOVED***, res, decimal=9***REMOVED***
        d = d.astype(np.complex64***REMOVED***
        old_assert_almost_equal(np.linalg.norm(d, ord=3***REMOVED***, res, decimal=5***REMOVED***


class TestNormDouble(_TestNorm***REMOVED***:
    dt = np.double
    dec = 12


class TestNormSingle(_TestNorm***REMOVED***:
    dt = np.float32
    dec = 6


class TestNormInt64(_TestNorm***REMOVED***:
    dt = np.int64
    dec = 12


class TestMatrixRank(object***REMOVED***:

    def test_matrix_rank(self***REMOVED***:
        # Full rank matrix
        yield assert_equal, 4, matrix_rank(np.eye(4***REMOVED******REMOVED***
        # rank deficient matrix
        I = np.eye(4***REMOVED***
        I[-1, -1***REMOVED*** = 0.
        yield assert_equal, matrix_rank(I***REMOVED***, 3
        # All zeros - zero rank
        yield assert_equal, matrix_rank(np.zeros((4, 4***REMOVED******REMOVED******REMOVED***, 0
        # 1 dimension - rank 1 unless all 0
        yield assert_equal, matrix_rank([1, 0, 0, 0***REMOVED******REMOVED***, 1
        yield assert_equal, matrix_rank(np.zeros((4,***REMOVED******REMOVED******REMOVED***, 0
        # accepts array-like
        yield assert_equal, matrix_rank([1***REMOVED******REMOVED***, 1
        # greater than 2 dimensions raises error
        yield assert_raises, TypeError, matrix_rank, np.zeros((2, 2, 2***REMOVED******REMOVED***
        # works on scalar
        yield assert_equal, matrix_rank(1***REMOVED***, 1


def test_reduced_rank(***REMOVED***:
    # Test matrices with reduced rank
    rng = np.random.RandomState(20120714***REMOVED***
    for i in range(100***REMOVED***:
        # Make a rank deficient matrix
        X = rng.normal(size=(40, 10***REMOVED******REMOVED***
        X[:, 0***REMOVED*** = X[:, 1***REMOVED*** + X[:, 2***REMOVED***
        # Assert that matrix_rank detected deficiency
        assert_equal(matrix_rank(X***REMOVED***, 9***REMOVED***
        X[:, 3***REMOVED*** = X[:, 4***REMOVED*** + X[:, 5***REMOVED***
        assert_equal(matrix_rank(X***REMOVED***, 8***REMOVED***


class TestQR(object***REMOVED***:

    def check_qr(self, a***REMOVED***:
        # This test expects the argument `a` to be an ndarray or
        # a subclass of an ndarray of inexact type.
        a_type = type(a***REMOVED***
        a_dtype = a.dtype
        m, n = a.shape
        k = min(m, n***REMOVED***

        # mode == 'complete'
        q, r = linalg.qr(a, mode='complete'***REMOVED***
        assert_(q.dtype == a_dtype***REMOVED***
        assert_(r.dtype == a_dtype***REMOVED***
        assert_(isinstance(q, a_type***REMOVED******REMOVED***
        assert_(isinstance(r, a_type***REMOVED******REMOVED***
        assert_(q.shape == (m, m***REMOVED******REMOVED***
        assert_(r.shape == (m, n***REMOVED******REMOVED***
        assert_almost_equal(dot(q, r***REMOVED***, a***REMOVED***
        assert_almost_equal(dot(q.T.conj(***REMOVED***, q***REMOVED***, np.eye(m***REMOVED******REMOVED***
        assert_almost_equal(np.triu(r***REMOVED***, r***REMOVED***

        # mode == 'reduced'
        q1, r1 = linalg.qr(a, mode='reduced'***REMOVED***
        assert_(q1.dtype == a_dtype***REMOVED***
        assert_(r1.dtype == a_dtype***REMOVED***
        assert_(isinstance(q1, a_type***REMOVED******REMOVED***
        assert_(isinstance(r1, a_type***REMOVED******REMOVED***
        assert_(q1.shape == (m, k***REMOVED******REMOVED***
        assert_(r1.shape == (k, n***REMOVED******REMOVED***
        assert_almost_equal(dot(q1, r1***REMOVED***, a***REMOVED***
        assert_almost_equal(dot(q1.T.conj(***REMOVED***, q1***REMOVED***, np.eye(k***REMOVED******REMOVED***
        assert_almost_equal(np.triu(r1***REMOVED***, r1***REMOVED***

        # mode == 'r'
        r2 = linalg.qr(a, mode='r'***REMOVED***
        assert_(r2.dtype == a_dtype***REMOVED***
        assert_(isinstance(r2, a_type***REMOVED******REMOVED***
        assert_almost_equal(r2, r1***REMOVED***

    def test_qr_empty(self***REMOVED***:
        a = np.zeros((0, 2***REMOVED******REMOVED***
        assert_raises(linalg.LinAlgError, linalg.qr, a***REMOVED***

    def test_mode_raw(self***REMOVED***:
        # The factorization is not unique and varies between libraries,
        # so it is not possible to check against known values. Functional
        # testing is a possibility, but awaits the exposure of more
        # of the functions in lapack_lite. Consequently, this test is
        # very limited in scope. Note that the results are in FORTRAN
        # order, hence the h arrays are transposed.
        a = array([[1, 2***REMOVED***, [3, 4***REMOVED***, [5, 6***REMOVED******REMOVED***, dtype=np.double***REMOVED***

        # Test double
        h, tau = linalg.qr(a, mode='raw'***REMOVED***
        assert_(h.dtype == np.double***REMOVED***
        assert_(tau.dtype == np.double***REMOVED***
        assert_(h.shape == (2, 3***REMOVED******REMOVED***
        assert_(tau.shape == (2,***REMOVED******REMOVED***

        h, tau = linalg.qr(a.T, mode='raw'***REMOVED***
        assert_(h.dtype == np.double***REMOVED***
        assert_(tau.dtype == np.double***REMOVED***
        assert_(h.shape == (3, 2***REMOVED******REMOVED***
        assert_(tau.shape == (2,***REMOVED******REMOVED***

    def test_mode_all_but_economic(self***REMOVED***:
        a = array([[1, 2***REMOVED***, [3, 4***REMOVED******REMOVED******REMOVED***
        b = array([[1, 2***REMOVED***, [3, 4***REMOVED***, [5, 6***REMOVED******REMOVED******REMOVED***
        for dt in "fd":
            m1 = a.astype(dt***REMOVED***
            m2 = b.astype(dt***REMOVED***
            self.check_qr(m1***REMOVED***
            self.check_qr(m2***REMOVED***
            self.check_qr(m2.T***REMOVED***
            self.check_qr(matrix(m1***REMOVED******REMOVED***
        for dt in "fd":
            m1 = 1 + 1j * a.astype(dt***REMOVED***
            m2 = 1 + 1j * b.astype(dt***REMOVED***
            self.check_qr(m1***REMOVED***
            self.check_qr(m2***REMOVED***
            self.check_qr(m2.T***REMOVED***
            self.check_qr(matrix(m1***REMOVED******REMOVED***


def test_byteorder_check(***REMOVED***:
    # Byte order check should pass for native order
    if sys.byteorder == 'little':
        native = '<'
    else:
        native = '>'

    for dtt in (np.float32, np.float64***REMOVED***:
        arr = np.eye(4, dtype=dtt***REMOVED***
        n_arr = arr.newbyteorder(native***REMOVED***
        sw_arr = arr.newbyteorder('S'***REMOVED***.byteswap(***REMOVED***
        assert_equal(arr.dtype.byteorder, '='***REMOVED***
        for routine in (linalg.inv, linalg.det, linalg.pinv***REMOVED***:
            # Normal call
            res = routine(arr***REMOVED***
            # Native but not '='
            assert_array_equal(res, routine(n_arr***REMOVED******REMOVED***
            # Swapped
            assert_array_equal(res, routine(sw_arr***REMOVED******REMOVED***


def test_generalized_raise_multiloop(***REMOVED***:
    # It should raise an error even if the error doesn't occur in the
    # last iteration of the ufunc inner loop

    invertible = np.array([[1, 2***REMOVED***, [3, 4***REMOVED******REMOVED******REMOVED***
    non_invertible = np.array([[1, 1***REMOVED***, [1, 1***REMOVED******REMOVED******REMOVED***

    x = np.zeros([4, 4, 2, 2***REMOVED******REMOVED***[1::2***REMOVED***
    x[...***REMOVED*** = invertible
    x[0, 0***REMOVED*** = non_invertible

    assert_raises(np.linalg.LinAlgError, np.linalg.inv, x***REMOVED***


def test_xerbla_override(***REMOVED***:
    # Check that our xerbla has been successfully linked in. If it is not,
    # the default xerbla routine is called, which prints a message to stdout
    # and may, or may not, abort the process depending on the LAPACK package.

    XERBLA_OK = 255

    ***REMOVED***
        pid = os.fork(***REMOVED***
    except (OSError, AttributeError***REMOVED***:
        # fork failed, or not running on POSIX
        raise SkipTest("Not POSIX or fork failed."***REMOVED***

    if pid == 0:
        # child; close i/o file handles
        os.close(1***REMOVED***
        os.close(0***REMOVED***
        # Avoid producing core files.
        import resource
        resource.setrlimit(resource.RLIMIT_CORE, (0, 0***REMOVED******REMOVED***
        # These calls may abort.
        ***REMOVED***
            np.linalg.lapack_lite.xerbla(***REMOVED***
        except ValueError:
            pass
        ***REMOVED***
            os._exit(os.EX_CONFIG***REMOVED***

        ***REMOVED***
            a = np.array([[1.***REMOVED******REMOVED******REMOVED***
            np.linalg.lapack_lite.dorgqr(
                1, 1, 1, a,
                0,  # <- invalid value
                a, a, 0, 0***REMOVED***
        except ValueError as e:
            if "DORGQR parameter number 5" in str(e***REMOVED***:
                # success, reuse error code to mark success as
                # FORTRAN STOP returns as success.
                os._exit(XERBLA_OK***REMOVED***

        # Did not abort, but our xerbla was not linked in.
        os._exit(os.EX_CONFIG***REMOVED***
    else:
        # parent
        pid, status = os.wait(***REMOVED***
        if os.WEXITSTATUS(status***REMOVED*** != XERBLA_OK:
            raise SkipTest('Numpy xerbla not linked in.'***REMOVED***


class TestMultiDot(object***REMOVED***:

    def test_basic_function_with_three_arguments(self***REMOVED***:
        # multi_dot with three arguments uses a fast hand coded algorithm to
        # determine the optimal order. Therefore test it separately.
        A = np.random.random((6, 2***REMOVED******REMOVED***
        B = np.random.random((2, 6***REMOVED******REMOVED***
        C = np.random.random((6, 2***REMOVED******REMOVED***

        assert_almost_equal(multi_dot([A, B, C***REMOVED******REMOVED***, A.dot(B***REMOVED***.dot(C***REMOVED******REMOVED***
        assert_almost_equal(multi_dot([A, B, C***REMOVED******REMOVED***, np.dot(A, np.dot(B, C***REMOVED******REMOVED******REMOVED***

    def test_basic_function_with_dynamic_programing_optimization(self***REMOVED***:
        # multi_dot with four or more arguments uses the dynamic programing
        # optimization and therefore deserve a separate
        A = np.random.random((6, 2***REMOVED******REMOVED***
        B = np.random.random((2, 6***REMOVED******REMOVED***
        C = np.random.random((6, 2***REMOVED******REMOVED***
        D = np.random.random((2, 1***REMOVED******REMOVED***
        assert_almost_equal(multi_dot([A, B, C, D***REMOVED******REMOVED***, A.dot(B***REMOVED***.dot(C***REMOVED***.dot(D***REMOVED******REMOVED***

    def test_vector_as_first_argument(self***REMOVED***:
        # The first argument can be 1-D
        A1d = np.random.random(2***REMOVED***  # 1-D
        B = np.random.random((2, 6***REMOVED******REMOVED***
        C = np.random.random((6, 2***REMOVED******REMOVED***
        D = np.random.random((2, 2***REMOVED******REMOVED***

        # the result should be 1-D
        assert_equal(multi_dot([A1d, B, C, D***REMOVED******REMOVED***.shape, (2,***REMOVED******REMOVED***

    def test_vector_as_last_argument(self***REMOVED***:
        # The last argument can be 1-D
        A = np.random.random((6, 2***REMOVED******REMOVED***
        B = np.random.random((2, 6***REMOVED******REMOVED***
        C = np.random.random((6, 2***REMOVED******REMOVED***
        D1d = np.random.random(2***REMOVED***  # 1-D

        # the result should be 1-D
        assert_equal(multi_dot([A, B, C, D1d***REMOVED******REMOVED***.shape, (6,***REMOVED******REMOVED***

    def test_vector_as_first_and_last_argument(self***REMOVED***:
        # The first and last arguments can be 1-D
        A1d = np.random.random(2***REMOVED***  # 1-D
        B = np.random.random((2, 6***REMOVED******REMOVED***
        C = np.random.random((6, 2***REMOVED******REMOVED***
        D1d = np.random.random(2***REMOVED***  # 1-D

        # the result should be a scalar
        assert_equal(multi_dot([A1d, B, C, D1d***REMOVED******REMOVED***.shape, (***REMOVED******REMOVED***

    def test_dynamic_programming_logic(self***REMOVED***:
        # Test for the dynamic programming part
        # This test is directly taken from Cormen page 376.
        arrays = [np.random.random((30, 35***REMOVED******REMOVED***,
                  np.random.random((35, 15***REMOVED******REMOVED***,
                  np.random.random((15, 5***REMOVED******REMOVED***,
                  np.random.random((5, 10***REMOVED******REMOVED***,
                  np.random.random((10, 20***REMOVED******REMOVED***,
                  np.random.random((20, 25***REMOVED******REMOVED******REMOVED***
        m_expected = np.array([[0., 15750., 7875., 9375., 11875., 15125.***REMOVED***,
                               [0.,     0., 2625., 4375.,  7125., 10500.***REMOVED***,
                               [0.,     0.,    0.,  750.,  2500.,  5375.***REMOVED***,
                               [0.,     0.,    0.,    0.,  1000.,  3500.***REMOVED***,
                               [0.,     0.,    0.,    0.,     0.,  5000.***REMOVED***,
                               [0.,     0.,    0.,    0.,     0.,     0.***REMOVED******REMOVED******REMOVED***
        s_expected = np.array([[0,  1,  1,  3,  3,  3***REMOVED***,
                               [0,  0,  2,  3,  3,  3***REMOVED***,
                               [0,  0,  0,  3,  3,  3***REMOVED***,
                               [0,  0,  0,  0,  4,  5***REMOVED***,
                               [0,  0,  0,  0,  0,  5***REMOVED***,
                               [0,  0,  0,  0,  0,  0***REMOVED******REMOVED***, dtype=np.int***REMOVED***
        s_expected -= 1  # Cormen uses 1-based index, python does not.

        s, m = _multi_dot_matrix_chain_order(arrays, return_costs=True***REMOVED***

        # Only the upper triangular part (without the diagonal***REMOVED*** is interesting.
        assert_almost_equal(np.triu(s[:-1, 1:***REMOVED******REMOVED***,
                            np.triu(s_expected[:-1, 1:***REMOVED******REMOVED******REMOVED***
        assert_almost_equal(np.triu(m***REMOVED***, np.triu(m_expected***REMOVED******REMOVED***

    def test_too_few_input_arrays(self***REMOVED***:
        assert_raises(ValueError, multi_dot, [***REMOVED******REMOVED***
        assert_raises(ValueError, multi_dot, [np.random.random((3, 3***REMOVED******REMOVED******REMOVED******REMOVED***


if __name__ == "__main__":
    run_module_suite(***REMOVED***
