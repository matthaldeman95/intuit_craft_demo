#!/usr/bin/env python
***REMOVED***
exec_command

Implements exec_command function that is (almost***REMOVED*** equivalent to
commands.getstatusoutput function but on NT, DOS systems the
returned status is actually correct (though, the returned status
values may be different by a factor***REMOVED***. In addition, exec_command
takes keyword arguments for (re-***REMOVED***defining environment variables.

Provides functions:

  exec_command  --- execute command in a specified directory and
                    in the modified environment.
  find_executable --- locate a command using info from environment
                    variable PATH. Equivalent to posix `which`
                    command.

Author: Pearu Peterson <pearu@cens.ioc.ee>
Created: 11 January 2003

Requires: Python 2.x

Succesfully tested on:

========  ============  =================================================
os.name   sys.platform  comments
========  ============  =================================================
posix     linux2        Debian (sid***REMOVED*** Linux, Python 2.1.3+, 2.2.3+, 2.3.3
                        PyCrust 0.9.3, Idle 1.0.2
posix     linux2        Red Hat 9 Linux, Python 2.1.3, 2.2.2, 2.3.2
posix     sunos5        SunOS 5.9, Python 2.2, 2.3.2
posix     darwin        Darwin 7.2.0, Python 2.3
nt        win32         Windows Me
                        Python 2.3(EE***REMOVED***, Idle 1.0, PyCrust 0.7.2
                        Python 2.1.1 Idle 0.8
nt        win32         Windows 98, Python 2.1.1. Idle 0.8
nt        win32         Cygwin 98-4.10, Python 2.1.1(MSC***REMOVED*** - echo tests
                        fail i.e. redefining environment variables may
                        not work. FIXED: don't use cygwin echo!
                        Comment: also `cmd /c echo` will not work
                        but redefining environment variables do work.
posix     cygwin        Cygwin 98-4.10, Python 2.3.3(cygming special***REMOVED***
nt        win32         Windows XP, Python 2.3.3
========  ============  =================================================

Known bugs:

* Tests, that send messages to stderr, fail when executed from MSYS prompt
  because the messages are lost at some point.

***REMOVED***
from __future__ import division, absolute_import, print_function

__all__ = ['exec_command', 'find_executable'***REMOVED***

***REMOVED***
import sys
import shlex

from numpy.distutils.misc_util import is_sequence, make_temp_file
from numpy.distutils import log
from numpy.distutils.compat import get_exception

from numpy.compat import open_latin1

def temp_file_name(***REMOVED***:
    fo, name = make_temp_file(***REMOVED***
    fo.close(***REMOVED***
    return name

def get_pythonexe(***REMOVED***:
    pythonexe = sys.executable
    if os.name in ['nt', 'dos'***REMOVED***:
        fdir, fn = os.path.split(pythonexe***REMOVED***
        fn = fn.upper(***REMOVED***.replace('PYTHONW', 'PYTHON'***REMOVED***
        pythonexe = os.path.join(fdir, fn***REMOVED***
        assert os.path.isfile(pythonexe***REMOVED***, '%r is not a file' % (pythonexe,***REMOVED***
    return pythonexe

def find_executable(exe, path=None, _cache={***REMOVED******REMOVED***:
    ***REMOVED***Return full path of a executable or None.

    Symbolic links are not followed.
    ***REMOVED***
    key = exe, path
    ***REMOVED***
        return _cache[key***REMOVED***
    except KeyError:
        pass
    log.debug('find_executable(%r***REMOVED***' % exe***REMOVED***
    orig_exe = exe

    if path is None:
        path = os.environ.get('PATH', os.defpath***REMOVED***
    if os.name=='posix':
        realpath = os.path.realpath
    else:
        realpath = lambda a:a

    if exe.startswith('"'***REMOVED***:
        exe = exe[1:-1***REMOVED***

    suffixes = [''***REMOVED***
    if os.name in ['nt', 'dos', 'os2'***REMOVED***:
        fn, ext = os.path.splitext(exe***REMOVED***
        extra_suffixes = ['.exe', '.com', '.bat'***REMOVED***
        if ext.lower(***REMOVED*** not in extra_suffixes:
            suffixes = extra_suffixes

    if os.path.isabs(exe***REMOVED***:
        paths = [''***REMOVED***
    else:
        paths = [ os.path.abspath(p***REMOVED*** for p in path.split(os.pathsep***REMOVED*** ***REMOVED***

    for path in paths:
        fn = os.path.join(path, exe***REMOVED***
        for s in suffixes:
            f_ext = fn+s
            if not os.path.islink(f_ext***REMOVED***:
                f_ext = realpath(f_ext***REMOVED***
            if os.path.isfile(f_ext***REMOVED*** and os.access(f_ext, os.X_OK***REMOVED***:
                log.info('Found executable %s' % f_ext***REMOVED***
                _cache[key***REMOVED*** = f_ext
                return f_ext

    log.warn('Could not locate executable %s' % orig_exe***REMOVED***
    return None

############################################################

def _preserve_environment( names ***REMOVED***:
    log.debug('_preserve_environment(%r***REMOVED***' % (names***REMOVED******REMOVED***
    env = {***REMOVED***
    for name in names:
        env[name***REMOVED*** = os.environ.get(name***REMOVED***
    return env

def _update_environment( **env ***REMOVED***:
    log.debug('_update_environment(...***REMOVED***'***REMOVED***
    for name, value in env.items(***REMOVED***:
        os.environ[name***REMOVED*** = value or ''

def _supports_fileno(stream***REMOVED***:
    ***REMOVED***
    Returns True if 'stream' supports the file descriptor and allows fileno(***REMOVED***.
    ***REMOVED***
    if hasattr(stream, 'fileno'***REMOVED***:
        ***REMOVED***
            r = stream.fileno(***REMOVED***
            return True
        except IOError:
            return False
    else:
        return False

def exec_command(command, execute_in='', use_shell=None, use_tee=None,
                 _with_python = 1, **env ***REMOVED***:
    ***REMOVED***
    Return (status,output***REMOVED*** of executed command.

    Parameters
    ----------
    command : str
        A concatenated string of executable and arguments.
    execute_in : str
        Before running command ``cd execute_in`` and after ``cd -``.
    use_shell : {bool, None***REMOVED***, optional
        If True, execute ``sh -c command``. Default None (True***REMOVED***
    use_tee : {bool, None***REMOVED***, optional
        If True use tee. Default None (True***REMOVED***


    Returns
    -------
    res : str
        Both stdout and stderr messages.

    Notes
    -----
    On NT, DOS systems the returned status is correct for external commands.
    Wild cards will not work for non-posix systems or when use_shell=0.

    ***REMOVED***
    log.debug('exec_command(%r,%s***REMOVED***' % (command,\
         ','.join(['%s=%r'%kv for kv in env.items(***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***

    if use_tee is None:
        use_tee = os.name=='posix'
    if use_shell is None:
        use_shell = os.name=='posix'
    execute_in = os.path.abspath(execute_in***REMOVED***
    oldcwd = os.path.abspath(os.getcwd(***REMOVED******REMOVED***

    if __name__[-12:***REMOVED*** == 'exec_command':
        exec_dir = os.path.dirname(os.path.abspath(__file__***REMOVED******REMOVED***
    elif os.path.isfile('exec_command.py'***REMOVED***:
        exec_dir = os.path.abspath('.'***REMOVED***
    else:
        exec_dir = os.path.abspath(sys.argv[0***REMOVED******REMOVED***
        if os.path.isfile(exec_dir***REMOVED***:
            exec_dir = os.path.dirname(exec_dir***REMOVED***

    if oldcwd!=execute_in:
        os.chdir(execute_in***REMOVED***
        log.debug('New cwd: %s' % execute_in***REMOVED***
    else:
        log.debug('Retaining cwd: %s' % oldcwd***REMOVED***

    oldenv = _preserve_environment( list(env.keys(***REMOVED******REMOVED*** ***REMOVED***
    _update_environment( **env ***REMOVED***

    ***REMOVED***
        # _exec_command is robust but slow, it relies on
        # usable sys.std*.fileno(***REMOVED*** descriptors. If they
        # are bad (like in win32 Idle, PyCrust environments***REMOVED***
        # then _exec_command_python (even slower***REMOVED***
        # will be used as a last resort.
        #
        # _exec_command_posix uses os.system and is faster
        # but not on all platforms os.system will return
        # a correct status.
        if (_with_python and _supports_fileno(sys.stdout***REMOVED*** and
                            sys.stdout.fileno(***REMOVED*** == -1***REMOVED***:
            st = _exec_command_python(command,
                                      exec_command_dir = exec_dir,
                                      **env***REMOVED***
        elif os.name=='posix':
            st = _exec_command_posix(command,
                                     use_shell=use_shell,
                                     use_tee=use_tee,
                                     **env***REMOVED***
        else:
            st = _exec_command(command, use_shell=use_shell,
                               use_tee=use_tee,**env***REMOVED***
    finally:
        if oldcwd!=execute_in:
            os.chdir(oldcwd***REMOVED***
            log.debug('Restored cwd to %s' % oldcwd***REMOVED***
        _update_environment(**oldenv***REMOVED***

    return st

def _exec_command_posix( command,
                         use_shell = None,
                         use_tee = None,
                         **env ***REMOVED***:
    log.debug('_exec_command_posix(...***REMOVED***'***REMOVED***

    if is_sequence(command***REMOVED***:
        command_str = ' '.join(list(command***REMOVED******REMOVED***
    else:
        command_str = command

    tmpfile = temp_file_name(***REMOVED***
    stsfile = None
    if use_tee:
        stsfile = temp_file_name(***REMOVED***
        filter = ''
        if use_tee == 2:
            filter = r'| tr -cd "\n" | tr "\n" "."; echo'
        command_posix = '( %s ; echo $? > %s ***REMOVED*** 2>&1 | tee %s %s'\
                      % (command_str, stsfile, tmpfile, filter***REMOVED***
    else:
        stsfile = temp_file_name(***REMOVED***
        command_posix = '( %s ; echo $? > %s ***REMOVED*** > %s 2>&1'\
                        % (command_str, stsfile, tmpfile***REMOVED***
        #command_posix = '( %s ***REMOVED*** > %s 2>&1' % (command_str,tmpfile***REMOVED***

    log.debug('Running os.system(%r***REMOVED***' % (command_posix***REMOVED******REMOVED***
    status = os.system(command_posix***REMOVED***

    if use_tee:
        if status:
            # if command_tee fails then fall back to robust exec_command
            log.warn('_exec_command_posix failed (status=%s***REMOVED***' % status***REMOVED***
            return _exec_command(command, use_shell=use_shell, **env***REMOVED***

    if stsfile is not None:
        f = open_latin1(stsfile, 'r'***REMOVED***
        status_text = f.read(***REMOVED***
        status = int(status_text***REMOVED***
        f.close(***REMOVED***
        os.remove(stsfile***REMOVED***

    f = open_latin1(tmpfile, 'r'***REMOVED***
    text = f.read(***REMOVED***
    f.close(***REMOVED***
    os.remove(tmpfile***REMOVED***

    if text[-1:***REMOVED***=='\n':
        text = text[:-1***REMOVED***

    return status, text


def _exec_command_python(command,
                         exec_command_dir='', **env***REMOVED***:
    log.debug('_exec_command_python(...***REMOVED***'***REMOVED***

    python_exe = get_pythonexe(***REMOVED***
    cmdfile = temp_file_name(***REMOVED***
    stsfile = temp_file_name(***REMOVED***
    outfile = temp_file_name(***REMOVED***

    f = open(cmdfile, 'w'***REMOVED***
    f.write('***REMOVED***\n'***REMOVED***
    f.write('import sys\n'***REMOVED***
    f.write('sys.path.insert(0,%r***REMOVED***\n' % (exec_command_dir***REMOVED******REMOVED***
    f.write('from exec_command import exec_command\n'***REMOVED***
    f.write('del sys.path[0***REMOVED***\n'***REMOVED***
    f.write('cmd = %r\n' % command***REMOVED***
    f.write('os.environ = %r\n' % (os.environ***REMOVED******REMOVED***
    f.write('s,o = exec_command(cmd, _with_python=0, **%r***REMOVED***\n' % (env***REMOVED******REMOVED***
    f.write('f=open(%r,"w"***REMOVED***\nf.write(str(s***REMOVED******REMOVED***\nf.close(***REMOVED***\n' % (stsfile***REMOVED******REMOVED***
    f.write('f=open(%r,"w"***REMOVED***\nf.write(o***REMOVED***\nf.close(***REMOVED***\n' % (outfile***REMOVED******REMOVED***
    f.close(***REMOVED***

    cmd = '%s %s' % (python_exe, cmdfile***REMOVED***
    status = os.system(cmd***REMOVED***
    if status:
        raise RuntimeError("%r failed" % (cmd,***REMOVED******REMOVED***
    os.remove(cmdfile***REMOVED***

    f = open_latin1(stsfile, 'r'***REMOVED***
    status = int(f.read(***REMOVED******REMOVED***
    f.close(***REMOVED***
    os.remove(stsfile***REMOVED***

    f = open_latin1(outfile, 'r'***REMOVED***
    text = f.read(***REMOVED***
    f.close(***REMOVED***
    os.remove(outfile***REMOVED***

    return status, text

def quote_arg(arg***REMOVED***:
    if arg[0***REMOVED***!='"' and ' ' in arg:
        return '"%s"' % arg
    return arg

def _exec_command( command, use_shell=None, use_tee = None, **env ***REMOVED***:
    log.debug('_exec_command(...***REMOVED***'***REMOVED***

    if use_shell is None:
        use_shell = os.name=='posix'
    if use_tee is None:
        use_tee = os.name=='posix'
    using_command = 0
    if use_shell:
        # We use shell (unless use_shell==0***REMOVED*** so that wildcards can be
        # used.
        sh = os.environ.get('SHELL', '/bin/sh'***REMOVED***
        if is_sequence(command***REMOVED***:
            argv = [sh, '-c', ' '.join(list(command***REMOVED******REMOVED******REMOVED***
        else:
            argv = [sh, '-c', command***REMOVED***
    else:
        # On NT, DOS we avoid using command.com as it's exit status is
        # not related to the exit status of a command.
        if is_sequence(command***REMOVED***:
            argv = command[:***REMOVED***
        else:
            argv = shlex.split(command***REMOVED***

    if hasattr(os, 'spawnvpe'***REMOVED***:
        spawn_command = os.spawnvpe
    else:
        spawn_command = os.spawnve
        argv[0***REMOVED*** = find_executable(argv[0***REMOVED******REMOVED*** or argv[0***REMOVED***
        if not os.path.isfile(argv[0***REMOVED******REMOVED***:
            log.warn('Executable %s does not exist' % (argv[0***REMOVED******REMOVED******REMOVED***
            if os.name in ['nt', 'dos'***REMOVED***:
                # argv[0***REMOVED*** might be internal command
                argv = [os.environ['COMSPEC'***REMOVED***, '/C'***REMOVED*** + argv
                using_command = 1

    _so_has_fileno = _supports_fileno(sys.stdout***REMOVED***
    _se_has_fileno = _supports_fileno(sys.stderr***REMOVED***
    so_flush = sys.stdout.flush
    se_flush = sys.stderr.flush
    if _so_has_fileno:
        so_fileno = sys.stdout.fileno(***REMOVED***
        so_dup = os.dup(so_fileno***REMOVED***
    if _se_has_fileno:
        se_fileno = sys.stderr.fileno(***REMOVED***
        se_dup = os.dup(se_fileno***REMOVED***

    outfile = temp_file_name(***REMOVED***
    fout = open(outfile, 'w'***REMOVED***
    if using_command:
        errfile = temp_file_name(***REMOVED***
        ferr = open(errfile, 'w'***REMOVED***

    log.debug('Running %s(%s,%r,%r,os.environ***REMOVED***' \
              % (spawn_command.__name__, os.P_WAIT, argv[0***REMOVED***, argv***REMOVED******REMOVED***

    if sys.version_info[0***REMOVED*** >= 3 and os.name == 'nt':
        # Pre-encode os.environ, discarding un-encodable entries,
        # to avoid it failing during encoding as part of spawn. Failure
        # is possible if the environment contains entries that are not
        # encoded using the system codepage as windows expects.
        #
        # This is not necessary on unix, where os.environ is encoded
        # using the surrogateescape error handler and decoded using
        # it as part of spawn.
        encoded_environ = {***REMOVED***
        for k, v in os.environ.items(***REMOVED***:
            ***REMOVED***
                encoded_environ[k.encode(sys.getfilesystemencoding(***REMOVED******REMOVED******REMOVED*** = v.encode(
                    sys.getfilesystemencoding(***REMOVED******REMOVED***
            except UnicodeEncodeError:
                log.debug("ignoring un-encodable env entry %s", k***REMOVED***
    else:
        encoded_environ = os.environ

    argv0 = argv[0***REMOVED***
    if not using_command:
        argv[0***REMOVED*** = quote_arg(argv0***REMOVED***

    so_flush(***REMOVED***
    se_flush(***REMOVED***
    if _so_has_fileno:
        os.dup2(fout.fileno(***REMOVED***, so_fileno***REMOVED***

    if _se_has_fileno:
        if using_command:
            #XXX: disabled for now as it does not work from cmd under win32.
            #     Tests fail on msys
            os.dup2(ferr.fileno(***REMOVED***, se_fileno***REMOVED***
        else:
            os.dup2(fout.fileno(***REMOVED***, se_fileno***REMOVED***
    ***REMOVED***
        status = spawn_command(os.P_WAIT, argv0, argv, encoded_environ***REMOVED***
    except Exception:
        errmess = str(get_exception(***REMOVED******REMOVED***
        status = 999
        sys.stderr.write('%s: %s'%(errmess, argv[0***REMOVED******REMOVED******REMOVED***

    so_flush(***REMOVED***
    se_flush(***REMOVED***
    if _so_has_fileno:
        os.dup2(so_dup, so_fileno***REMOVED***
        os.close(so_dup***REMOVED***
    if _se_has_fileno:
        os.dup2(se_dup, se_fileno***REMOVED***
        os.close(se_dup***REMOVED***

    fout.close(***REMOVED***
    fout = open_latin1(outfile, 'r'***REMOVED***
    text = fout.read(***REMOVED***
    fout.close(***REMOVED***
    os.remove(outfile***REMOVED***

    if using_command:
        ferr.close(***REMOVED***
        ferr = open_latin1(errfile, 'r'***REMOVED***
        errmess = ferr.read(***REMOVED***
        ferr.close(***REMOVED***
        os.remove(errfile***REMOVED***
        if errmess and not status:
            # Not sure how to handle the case where errmess
            # contains only warning messages and that should
            # not be treated as errors.
            #status = 998
            if text:
                text = text + '\n'
            #text = '%sCOMMAND %r FAILED: %s' %(text,command,errmess***REMOVED***
            text = text + errmess
            print (errmess***REMOVED***
    if text[-1:***REMOVED***=='\n':
        text = text[:-1***REMOVED***
    if status is None:
        status = 0

    if use_tee:
        print (text***REMOVED***

    return status, text


def test_nt(**kws***REMOVED***:
    pythonexe = get_pythonexe(***REMOVED***
    echo = find_executable('echo'***REMOVED***
    using_cygwin_echo = echo != 'echo'
    if using_cygwin_echo:
        log.warn('Using cygwin echo in win32 environment is not supported'***REMOVED***

        s, o=exec_command(pythonexe\
                         +' -c "***REMOVED***;print os.environ.get(\'AAA\',\'\'***REMOVED***"'***REMOVED***
        assert s==0 and o=='', (s, o***REMOVED***

        s, o=exec_command(pythonexe\
                         +' -c "***REMOVED***;print os.environ.get(\'AAA\'***REMOVED***"',
                         AAA='Tere'***REMOVED***
        assert s==0 and o=='Tere', (s, o***REMOVED***

        os.environ['BBB'***REMOVED*** = 'Hi'
        s, o=exec_command(pythonexe\
                         +' -c "***REMOVED***;print os.environ.get(\'BBB\',\'\'***REMOVED***"'***REMOVED***
        assert s==0 and o=='Hi', (s, o***REMOVED***

        s, o=exec_command(pythonexe\
                         +' -c "***REMOVED***;print os.environ.get(\'BBB\',\'\'***REMOVED***"',
                         BBB='Hey'***REMOVED***
        assert s==0 and o=='Hey', (s, o***REMOVED***

        s, o=exec_command(pythonexe\
                         +' -c "***REMOVED***;print os.environ.get(\'BBB\',\'\'***REMOVED***"'***REMOVED***
        assert s==0 and o=='Hi', (s, o***REMOVED***
    elif 0:
        s, o=exec_command('echo Hello'***REMOVED***
        assert s==0 and o=='Hello', (s, o***REMOVED***

        s, o=exec_command('echo a%AAA%'***REMOVED***
        assert s==0 and o=='a', (s, o***REMOVED***

        s, o=exec_command('echo a%AAA%', AAA='Tere'***REMOVED***
        assert s==0 and o=='aTere', (s, o***REMOVED***

        os.environ['BBB'***REMOVED*** = 'Hi'
        s, o=exec_command('echo a%BBB%'***REMOVED***
        assert s==0 and o=='aHi', (s, o***REMOVED***

        s, o=exec_command('echo a%BBB%', BBB='Hey'***REMOVED***
        assert s==0 and o=='aHey', (s, o***REMOVED***
        s, o=exec_command('echo a%BBB%'***REMOVED***
        assert s==0 and o=='aHi', (s, o***REMOVED***

        s, o=exec_command('this_is_not_a_command'***REMOVED***
        assert s and o!='', (s, o***REMOVED***

        s, o=exec_command('type not_existing_file'***REMOVED***
        assert s and o!='', (s, o***REMOVED***

    s, o=exec_command('echo path=%path%'***REMOVED***
    assert s==0 and o!='', (s, o***REMOVED***

    s, o=exec_command('%s -c "import sys;sys.stderr.write(sys.platform***REMOVED***"' \
                     % pythonexe***REMOVED***
    assert s==0 and o=='win32', (s, o***REMOVED***

    s, o=exec_command('%s -c "raise \'Ignore me.\'"' % pythonexe***REMOVED***
    assert s==1 and o, (s, o***REMOVED***

    s, o=exec_command('%s -c "import sys;sys.stderr.write(\'0\'***REMOVED***;sys.stderr.write(\'1\'***REMOVED***;sys.stderr.write(\'2\'***REMOVED***"'\
                     % pythonexe***REMOVED***
    assert s==0 and o=='012', (s, o***REMOVED***

    s, o=exec_command('%s -c "import sys;sys.exit(15***REMOVED***"' % pythonexe***REMOVED***
    assert s==15 and o=='', (s, o***REMOVED***

    s, o=exec_command('%s -c "print \'Heipa\'"' % pythonexe***REMOVED***
    assert s==0 and o=='Heipa', (s, o***REMOVED***

    print ('ok'***REMOVED***

def test_posix(**kws***REMOVED***:
    s, o=exec_command("echo Hello",**kws***REMOVED***
    assert s==0 and o=='Hello', (s, o***REMOVED***

    s, o=exec_command('echo $AAA',**kws***REMOVED***
    assert s==0 and o=='', (s, o***REMOVED***

    s, o=exec_command('echo "$AAA"',AAA='Tere',**kws***REMOVED***
    assert s==0 and o=='Tere', (s, o***REMOVED***


    s, o=exec_command('echo "$AAA"',**kws***REMOVED***
    assert s==0 and o=='', (s, o***REMOVED***

    os.environ['BBB'***REMOVED*** = 'Hi'
    s, o=exec_command('echo "$BBB"',**kws***REMOVED***
    assert s==0 and o=='Hi', (s, o***REMOVED***

    s, o=exec_command('echo "$BBB"',BBB='Hey',**kws***REMOVED***
    assert s==0 and o=='Hey', (s, o***REMOVED***

    s, o=exec_command('echo "$BBB"',**kws***REMOVED***
    assert s==0 and o=='Hi', (s, o***REMOVED***


    s, o=exec_command('this_is_not_a_command',**kws***REMOVED***
    assert s!=0 and o!='', (s, o***REMOVED***

    s, o=exec_command('echo path=$PATH',**kws***REMOVED***
    assert s==0 and o!='', (s, o***REMOVED***

    s, o=exec_command('python -c "import sys,os;sys.stderr.write(os.name***REMOVED***"',**kws***REMOVED***
    assert s==0 and o=='posix', (s, o***REMOVED***

    s, o=exec_command('python -c "raise \'Ignore me.\'"',**kws***REMOVED***
    assert s==1 and o, (s, o***REMOVED***

    s, o=exec_command('python -c "import sys;sys.stderr.write(\'0\'***REMOVED***;sys.stderr.write(\'1\'***REMOVED***;sys.stderr.write(\'2\'***REMOVED***"',**kws***REMOVED***
    assert s==0 and o=='012', (s, o***REMOVED***

    s, o=exec_command('python -c "import sys;sys.exit(15***REMOVED***"',**kws***REMOVED***
    assert s==15 and o=='', (s, o***REMOVED***

    s, o=exec_command('python -c "print \'Heipa\'"',**kws***REMOVED***
    assert s==0 and o=='Heipa', (s, o***REMOVED***

    print ('ok'***REMOVED***

def test_execute_in(**kws***REMOVED***:
    pythonexe = get_pythonexe(***REMOVED***
    tmpfile = temp_file_name(***REMOVED***
    fn = os.path.basename(tmpfile***REMOVED***
    tmpdir = os.path.dirname(tmpfile***REMOVED***
    f = open(tmpfile, 'w'***REMOVED***
    f.write('Hello'***REMOVED***
    f.close(***REMOVED***

    s, o = exec_command('%s -c "print \'Ignore the following IOError:\','\
                       'open(%r,\'r\'***REMOVED***"' % (pythonexe, fn***REMOVED***,**kws***REMOVED***
    assert s and o!='', (s, o***REMOVED***
    s, o = exec_command('%s -c "print open(%r,\'r\'***REMOVED***.read(***REMOVED***"' % (pythonexe, fn***REMOVED***,
                       execute_in = tmpdir,**kws***REMOVED***
    assert s==0 and o=='Hello', (s, o***REMOVED***
    os.remove(tmpfile***REMOVED***
    print ('ok'***REMOVED***

def test_svn(**kws***REMOVED***:
    s, o = exec_command(['svn', 'status'***REMOVED***,**kws***REMOVED***
    assert s, (s, o***REMOVED***
    print ('svn ok'***REMOVED***

def test_cl(**kws***REMOVED***:
    if os.name=='nt':
        s, o = exec_command(['cl', '/V'***REMOVED***,**kws***REMOVED***
        assert s, (s, o***REMOVED***
        print ('cl ok'***REMOVED***

if os.name=='posix':
    test = test_posix
elif os.name in ['nt', 'dos'***REMOVED***:
    test = test_nt
else:
    raise NotImplementedError('exec_command tests for ', os.name***REMOVED***

############################################################

if __name__ == "__main__":

    test(use_tee=0***REMOVED***
    test(use_tee=1***REMOVED***
    test_execute_in(use_tee=0***REMOVED***
    test_execute_in(use_tee=1***REMOVED***
    test_svn(use_tee=1***REMOVED***
    test_cl(use_tee=1***REMOVED***
