from __future__ import division, absolute_import, print_function

import re
import sys
***REMOVED***
import subprocess

__doc__ = ***REMOVED***This module generates a DEF file from the symbols in
an MSVC-compiled DLL import library.  It correctly discriminates between
data and functions.  The data is collected from the output of the program
nm(1***REMOVED***.

Usage:
    python lib2def.py [libname.lib***REMOVED*** [output.def***REMOVED***
or
    python lib2def.py [libname.lib***REMOVED*** > output.def

libname.lib defaults to python<py_ver>.lib and output.def defaults to stdout

Author: Robert Kern <kernr@mail.ncifcrf.gov>
Last Update: April 30, 1999
***REMOVED***

__version__ = '0.1a'

py_ver = "%d%d" % tuple(sys.version_info[:2***REMOVED******REMOVED***

DEFAULT_NM = 'nm -Cs'

DEF_HEADER = ***REMOVED***LIBRARY         python%s.dll
;CODE           PRELOAD MOVEABLE DISCARDABLE
;DATA           PRELOAD SINGLE

EXPORTS
***REMOVED*** % py_ver
# the header of the DEF file

FUNC_RE = re.compile(r"^(.****REMOVED*** in python%s\.dll" % py_ver, re.MULTILINE***REMOVED***
DATA_RE = re.compile(r"^_imp__(.****REMOVED*** in python%s\.dll" % py_ver, re.MULTILINE***REMOVED***

def parse_cmd(***REMOVED***:
    ***REMOVED***Parses the command-line arguments.

libfile, deffile = parse_cmd(***REMOVED******REMOVED***
    if len(sys.argv***REMOVED*** == 3:
        if sys.argv[1***REMOVED***[-4:***REMOVED*** == '.lib' and sys.argv[2***REMOVED***[-4:***REMOVED*** == '.def':
            libfile, deffile = sys.argv[1:***REMOVED***
        elif sys.argv[1***REMOVED***[-4:***REMOVED*** == '.def' and sys.argv[2***REMOVED***[-4:***REMOVED*** == '.lib':
            deffile, libfile = sys.argv[1:***REMOVED***
        else:
            print("I'm assuming that your first argument is the library"***REMOVED***
            print("and the second is the DEF file."***REMOVED***
    elif len(sys.argv***REMOVED*** == 2:
        if sys.argv[1***REMOVED***[-4:***REMOVED*** == '.def':
            deffile = sys.argv[1***REMOVED***
            libfile = 'python%s.lib' % py_ver
        elif sys.argv[1***REMOVED***[-4:***REMOVED*** == '.lib':
            deffile = None
            libfile = sys.argv[1***REMOVED***
    else:
        libfile = 'python%s.lib' % py_ver
        deffile = None
    return libfile, deffile

def getnm(nm_cmd = ['nm', '-Cs', 'python%s.lib' % py_ver***REMOVED******REMOVED***:
    ***REMOVED***Returns the output of nm_cmd via a pipe.

nm_output = getnam(nm_cmd = 'nm -Cs py_lib'***REMOVED******REMOVED***
    f = subprocess.Popen(nm_cmd, shell=True, stdout=subprocess.PIPE, universal_newlines=True***REMOVED***
    nm_output = f.stdout.read(***REMOVED***
    f.stdout.close(***REMOVED***
    return nm_output

def parse_nm(nm_output***REMOVED***:
    ***REMOVED***Returns a tuple of lists: dlist for the list of data
symbols and flist for the list of function symbols.

dlist, flist = parse_nm(nm_output***REMOVED******REMOVED***
    data = DATA_RE.findall(nm_output***REMOVED***
    func = FUNC_RE.findall(nm_output***REMOVED***

    flist = [***REMOVED***
    for sym in data:
        if sym in func and (sym[:2***REMOVED*** == 'Py' or sym[:3***REMOVED*** == '_Py' or sym[:4***REMOVED*** == 'init'***REMOVED***:
            flist.append(sym***REMOVED***

    dlist = [***REMOVED***
    for sym in data:
        if sym not in flist and (sym[:2***REMOVED*** == 'Py' or sym[:3***REMOVED*** == '_Py'***REMOVED***:
            dlist.append(sym***REMOVED***

    dlist.sort(***REMOVED***
    flist.sort(***REMOVED***
    return dlist, flist

def output_def(dlist, flist, header, file = sys.stdout***REMOVED***:
    ***REMOVED***Outputs the final DEF file to a file defaulting to stdout.

output_def(dlist, flist, header, file = sys.stdout***REMOVED******REMOVED***
    for data_sym in dlist:
        header = header + '\t%s DATA\n' % data_sym
    header = header + '\n' # blank line
    for func_sym in flist:
        header = header + '\t%s\n' % func_sym
    file.write(header***REMOVED***

if __name__ == '__main__':
    libfile, deffile = parse_cmd(***REMOVED***
    if deffile is None:
        deffile = sys.stdout
    else:
        deffile = open(deffile, 'w'***REMOVED***
    nm_cmd = [str(DEFAULT_NM***REMOVED***, str(libfile***REMOVED******REMOVED***
    nm_output = getnm(nm_cmd***REMOVED***
    dlist, flist = parse_nm(nm_output***REMOVED***
    output_def(dlist, flist, DEF_HEADER, deffile***REMOVED***
