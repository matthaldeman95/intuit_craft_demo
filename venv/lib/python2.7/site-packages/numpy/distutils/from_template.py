#!/usr/bin/python
***REMOVED***

process_file(filename***REMOVED***

  takes templated file .xxx.src and produces .xxx file where .xxx
  is .pyf .f90 or .f using the following template rules:

  '<..>' denotes a template.

  All function and subroutine blocks in a source file with names that
  contain '<..>' will be replicated according to the rules in '<..>'.

  The number of comma-separeted words in '<..>' will determine the number of
  replicates.

  '<..>' may have two different forms, named and short. For example,

  named:
   <p=d,s,z,c> where anywhere inside a block '<p>' will be replaced with
   'd', 's', 'z', and 'c' for each replicate of the block.

   <_c>  is already defined: <_c=s,d,c,z>
   <_t>  is already defined: <_t=real,double precision,complex,double complex>

  short:
   <s,d,c,z>, a short form of the named, useful when no <p> appears inside
   a block.

  In general, '<..>' contains a comma separated list of arbitrary
  expressions. If these expression must contain a comma|leftarrow|rightarrow,
  then prepend the comma|leftarrow|rightarrow with a backslash.

  If an expression matches '\\<index>' then it will be replaced
  by <index>-th expression.

  Note that all '<..>' forms in a block must have the same number of
  comma-separated entries.

 Predefined named template rules:
  <prefix=s,d,c,z>
  <ftype=real,double precision,complex,double complex>
  <ftypereal=real,double precision,\\0,\\1>
  <ctype=float,double,complex_float,complex_double>
  <ctypereal=float,double,\\0,\\1>

***REMOVED***
from __future__ import division, absolute_import, print_function

__all__ = ['process_str', 'process_file'***REMOVED***

***REMOVED***
import sys
import re

routine_start_re = re.compile(r'(\n|\A***REMOVED***((     (\$|\****REMOVED******REMOVED***|***REMOVED***\s*(subroutine|function***REMOVED***\b', re.I***REMOVED***
routine_end_re = re.compile(r'\n\s*end\s*(subroutine|function***REMOVED***\b.*(\n|\Z***REMOVED***', re.I***REMOVED***
function_start_re = re.compile(r'\n     (\$|\****REMOVED***\s*function\b', re.I***REMOVED***

def parse_structure(astr***REMOVED***:
    ***REMOVED*** Return a list of tuples for each function or subroutine each
    tuple is the start and end of a subroutine or function to be
    expanded.
    ***REMOVED***

    spanlist = [***REMOVED***
    ind = 0
    while True:
        m = routine_start_re.search(astr, ind***REMOVED***
        if m is None:
            break
        start = m.start(***REMOVED***
        if function_start_re.match(astr, start, m.end(***REMOVED******REMOVED***:
            while True:
                i = astr.rfind('\n', ind, start***REMOVED***
                if i==-1:
                    break
                start = i
                if astr[i:i+7***REMOVED***!='\n     $':
                    break
        start += 1
        m = routine_end_re.search(astr, m.end(***REMOVED******REMOVED***
        ind = end = m and m.end(***REMOVED***-1 or len(astr***REMOVED***
        spanlist.append((start, end***REMOVED******REMOVED***
    return spanlist

template_re = re.compile(r"<\s*(\w[\w\d***REMOVED*******REMOVED***\s*>"***REMOVED***
named_re = re.compile(r"<\s*(\w[\w\d***REMOVED*******REMOVED***\s*=\s*(.*?***REMOVED***\s*>"***REMOVED***
list_re = re.compile(r"<\s*((.*?***REMOVED******REMOVED***\s*>"***REMOVED***

def find_repl_patterns(astr***REMOVED***:
    reps = named_re.findall(astr***REMOVED***
    names = {***REMOVED***
    for rep in reps:
        name = rep[0***REMOVED***.strip(***REMOVED*** or unique_key(names***REMOVED***
        repl = rep[1***REMOVED***.replace('\,', '@comma@'***REMOVED***
        thelist = conv(repl***REMOVED***
        names[name***REMOVED*** = thelist
    return names

item_re = re.compile(r"\A\\(?P<index>\d+***REMOVED***\Z"***REMOVED***
def conv(astr***REMOVED***:
    b = astr.split(','***REMOVED***
    l = [x.strip(***REMOVED*** for x in b***REMOVED***
    for i in range(len(l***REMOVED******REMOVED***:
        m = item_re.match(l[i***REMOVED******REMOVED***
        if m:
            j = int(m.group('index'***REMOVED******REMOVED***
            l[i***REMOVED*** = l[j***REMOVED***
    return ','.join(l***REMOVED***

def unique_key(adict***REMOVED***:
    ***REMOVED*** Obtain a unique key given a dictionary.***REMOVED***
    allkeys = list(adict.keys(***REMOVED******REMOVED***
    done = False
    n = 1
    while not done:
        newkey = '__l%s' % (n***REMOVED***
        if newkey in allkeys:
            n += 1
        else:
            done = True
    return newkey


template_name_re = re.compile(r'\A\s*(\w[\w\d***REMOVED*******REMOVED***\s*\Z'***REMOVED***
def expand_sub(substr, names***REMOVED***:
    substr = substr.replace('\>', '@rightarrow@'***REMOVED***
    substr = substr.replace('\<', '@leftarrow@'***REMOVED***
    lnames = find_repl_patterns(substr***REMOVED***
    substr = named_re.sub(r"<\1>", substr***REMOVED***  # get rid of definition templates

    def listrepl(mobj***REMOVED***:
        thelist = conv(mobj.group(1***REMOVED***.replace('\,', '@comma@'***REMOVED******REMOVED***
        if template_name_re.match(thelist***REMOVED***:
            return "<%s>" % (thelist***REMOVED***
        name = None
        for key in lnames.keys(***REMOVED***:    # see if list is already in dictionary
            if lnames[key***REMOVED*** == thelist:
                name = key
        if name is None:      # this list is not in the dictionary yet
            name = unique_key(lnames***REMOVED***
            lnames[name***REMOVED*** = thelist
        return "<%s>" % name

    substr = list_re.sub(listrepl, substr***REMOVED*** # convert all lists to named templates
                                           # newnames are constructed as needed

    numsubs = None
    base_rule = None
    rules = {***REMOVED***
    for r in template_re.findall(substr***REMOVED***:
        if r not in rules:
            thelist = lnames.get(r, names.get(r, None***REMOVED******REMOVED***
            if thelist is None:
                raise ValueError('No replicates found for <%s>' % (r***REMOVED******REMOVED***
            if r not in names and not thelist.startswith('_'***REMOVED***:
                names[r***REMOVED*** = thelist
            rule = [i.replace('@comma@', ','***REMOVED*** for i in thelist.split(','***REMOVED******REMOVED***
            num = len(rule***REMOVED***

            if numsubs is None:
                numsubs = num
                rules[r***REMOVED*** = rule
                base_rule = r
            elif num == numsubs:
                rules[r***REMOVED*** = rule
            else:
                print("Mismatch in number of replacements (base <%s=%s>***REMOVED***"
                      " for <%s=%s>. Ignoring." %
                      (base_rule, ','.join(rules[base_rule***REMOVED******REMOVED***, r, thelist***REMOVED******REMOVED***
    if not rules:
        return substr

    def namerepl(mobj***REMOVED***:
        name = mobj.group(1***REMOVED***
        return rules.get(name, (k+1***REMOVED****[name***REMOVED******REMOVED***[k***REMOVED***

    newstr = ''
    for k in range(numsubs***REMOVED***:
        newstr += template_re.sub(namerepl, substr***REMOVED*** + '\n\n'

    newstr = newstr.replace('@rightarrow@', '>'***REMOVED***
    newstr = newstr.replace('@leftarrow@', '<'***REMOVED***
    return newstr

def process_str(allstr***REMOVED***:
    newstr = allstr
    writestr = '' #_head # using _head will break free-format files

    struct = parse_structure(newstr***REMOVED***

    oldend = 0
    names = {***REMOVED***
    names.update(_special_names***REMOVED***
    for sub in struct:
        writestr += newstr[oldend:sub[0***REMOVED******REMOVED***
        names.update(find_repl_patterns(newstr[oldend:sub[0***REMOVED******REMOVED******REMOVED******REMOVED***
        writestr += expand_sub(newstr[sub[0***REMOVED***:sub[1***REMOVED******REMOVED***, names***REMOVED***
        oldend =  sub[1***REMOVED***
    writestr += newstr[oldend:***REMOVED***

    return writestr

include_src_re = re.compile(r"(\n|\A***REMOVED***\s*include\s*['\"***REMOVED***(?P<name>[\w\d./\\***REMOVED***+[.***REMOVED***src***REMOVED***['\"***REMOVED***", re.I***REMOVED***

def resolve_includes(source***REMOVED***:
    d = os.path.dirname(source***REMOVED***
    fid = open(source***REMOVED***
    lines = [***REMOVED***
    for line in fid:
        m = include_src_re.match(line***REMOVED***
        if m:
            fn = m.group('name'***REMOVED***
            if not os.path.isabs(fn***REMOVED***:
                fn = os.path.join(d, fn***REMOVED***
            if os.path.isfile(fn***REMOVED***:
                print('Including file', fn***REMOVED***
                lines.extend(resolve_includes(fn***REMOVED******REMOVED***
            else:
                lines.append(line***REMOVED***
        else:
            lines.append(line***REMOVED***
    fid.close(***REMOVED***
    return lines

def process_file(source***REMOVED***:
    lines = resolve_includes(source***REMOVED***
    return process_str(''.join(lines***REMOVED******REMOVED***

_special_names = find_repl_patterns('''
<_c=s,d,c,z>
<_t=real,double precision,complex,double complex>
<prefix=s,d,c,z>
<ftype=real,double precision,complex,double complex>
<ctype=float,double,complex_float,complex_double>
<ftypereal=real,double precision,\\0,\\1>
<ctypereal=float,double,\\0,\\1>
'''***REMOVED***

if __name__ == "__main__":

    ***REMOVED***
        file = sys.argv[1***REMOVED***
    except IndexError:
        fid = sys.stdin
        outfile = sys.stdout
    else:
        fid = open(file, 'r'***REMOVED***
        (base, ext***REMOVED*** = os.path.splitext(file***REMOVED***
        newname = base
        outfile = open(newname, 'w'***REMOVED***

    allstr = fid.read(***REMOVED***
    writestr = process_str(allstr***REMOVED***
    outfile.write(writestr***REMOVED***
