from __future__ import division, absolute_import, print_function

***REMOVED***
import re
import sys
import types
from copy import copy
from distutils import ccompiler
from distutils.ccompiler import *
from distutils.errors import DistutilsExecError, DistutilsModuleError, \
                             DistutilsPlatformError
from distutils.sysconfig import customize_compiler
from distutils.version import LooseVersion

from numpy.distutils import log
from numpy.distutils.compat import get_exception
from numpy.distutils.exec_command import exec_command
from numpy.distutils.misc_util import cyg2win32, is_sequence, mingw32, \
                                      quote_args, get_num_build_jobs


def replace_method(klass, method_name, func***REMOVED***:
    if sys.version_info[0***REMOVED*** < 3:
        m = types.MethodType(func, None, klass***REMOVED***
    else:
        # Py3k does not have unbound method anymore, MethodType does not work
        m = lambda self, *args, **kw: func(self, *args, **kw***REMOVED***
    setattr(klass, method_name, m***REMOVED***

# Using customized CCompiler.spawn.
def CCompiler_spawn(self, cmd, display=None***REMOVED***:
    ***REMOVED***
    Execute a command in a sub-process.

    Parameters
    ----------
    cmd : str
        The command to execute.
    display : str or sequence of str, optional
        The text to add to the log file kept by `numpy.distutils`.
        If not given, `display` is equal to `cmd`.

    Returns
    -------
    None

    Raises
    ------
    DistutilsExecError
        If the command failed, i.e. the exit status was not 0.

    ***REMOVED***
    if display is None:
        display = cmd
        if is_sequence(display***REMOVED***:
            display = ' '.join(list(display***REMOVED******REMOVED***
    log.info(display***REMOVED***
    s, o = exec_command(cmd***REMOVED***
    if s:
        if is_sequence(cmd***REMOVED***:
            cmd = ' '.join(list(cmd***REMOVED******REMOVED***
        ***REMOVED***
            print(o***REMOVED***
        except UnicodeError:
            # When installing through pip, `o` can contain non-ascii chars
            pass
        if re.search('Too many open files', o***REMOVED***:
            msg = '\nTry rerunning setup command until build succeeds.'
        else:
            msg = ''
        raise DistutilsExecError('Command "%s" failed with exit status %d%s' % (cmd, s, msg***REMOVED******REMOVED***

replace_method(CCompiler, 'spawn', CCompiler_spawn***REMOVED***

def CCompiler_object_filenames(self, source_filenames, strip_dir=0, output_dir=''***REMOVED***:
    ***REMOVED***
    Return the name of the object files for the given source files.

    Parameters
    ----------
    source_filenames : list of str
        The list of paths to source files. Paths can be either relative or
        absolute, this is handled transparently.
    strip_dir : bool, optional
        Whether to strip the directory from the returned paths. If True,
        the file name prepended by `output_dir` is returned. Default is False.
    output_dir : str, optional
        If given, this path is prepended to the returned paths to the
        object files.

    Returns
    -------
    obj_names : list of str
        The list of paths to the object files corresponding to the source
        files in `source_filenames`.

    ***REMOVED***
    if output_dir is None:
        output_dir = ''
    obj_names = [***REMOVED***
    for src_name in source_filenames:
        base, ext = os.path.splitext(os.path.normpath(src_name***REMOVED******REMOVED***
        base = os.path.splitdrive(base***REMOVED***[1***REMOVED*** # Chop off the drive
        base = base[os.path.isabs(base***REMOVED***:***REMOVED***  # If abs, chop off leading /
        if base.startswith('..'***REMOVED***:
            # Resolve starting relative path components, middle ones
            # (if any***REMOVED*** have been handled by os.path.normpath above.
            i = base.rfind('..'***REMOVED***+2
            d = base[:i***REMOVED***
            d = os.path.basename(os.path.abspath(d***REMOVED******REMOVED***
            base = d + base[i:***REMOVED***
        if ext not in self.src_extensions:
            raise UnknownFileError("unknown file type '%s' (from '%s'***REMOVED***" % (ext, src_name***REMOVED******REMOVED***
        if strip_dir:
            base = os.path.basename(base***REMOVED***
        obj_name = os.path.join(output_dir, base + self.obj_extension***REMOVED***
        obj_names.append(obj_name***REMOVED***
    return obj_names

replace_method(CCompiler, 'object_filenames', CCompiler_object_filenames***REMOVED***

def CCompiler_compile(self, sources, output_dir=None, macros=None,
                      include_dirs=None, debug=0, extra_preargs=None,
                      extra_postargs=None, depends=None***REMOVED***:
    ***REMOVED***
    Compile one or more source files.

    Please refer to the Python distutils API reference for more details.

    Parameters
    ----------
    sources : list of str
        A list of filenames
    output_dir : str, optional
        Path to the output directory.
    macros : list of tuples
        A list of macro definitions.
    include_dirs : list of str, optional
        The directories to add to the default include file search path for
        this compilation only.
    debug : bool, optional
        Whether or not to output debug symbols in or alongside the object
        file(s***REMOVED***.
    extra_preargs, extra_postargs : ?
        Extra pre- and post-arguments.
    depends : list of str, optional
        A list of file names that all targets depend on.

    Returns
    -------
    objects : list of str
        A list of object file names, one per source file `sources`.

    Raises
    ------
    CompileError
        If compilation fails.

    ***REMOVED***
    # This method is effective only with Python >=2.3 distutils.
    # Any changes here should be applied also to fcompiler.compile
    # method to support pre Python 2.3 distutils.
    if not sources:
        return [***REMOVED***
    # FIXME:RELATIVE_IMPORT
    if sys.version_info[0***REMOVED*** < 3:
        from .fcompiler import FCompiler, is_f_file, has_f90_header
    else:
        from numpy.distutils.fcompiler import (FCompiler, is_f_file,
                                               has_f90_header***REMOVED***
    if isinstance(self, FCompiler***REMOVED***:
        display = [***REMOVED***
        for fc in ['f77', 'f90', 'fix'***REMOVED***:
            fcomp = getattr(self, 'compiler_'+fc***REMOVED***
            if fcomp is None:
                continue
            display.append("Fortran %s compiler: %s" % (fc, ' '.join(fcomp***REMOVED******REMOVED******REMOVED***
        display = '\n'.join(display***REMOVED***
    else:
        ccomp = self.compiler_so
        display = "C compiler: %s\n" % (' '.join(ccomp***REMOVED***,***REMOVED***
    log.info(display***REMOVED***
    macros, objects, extra_postargs, pp_opts, build = \
            self._setup_compile(output_dir, macros, include_dirs, sources,
                                depends, extra_postargs***REMOVED***
    cc_args = self._get_cc_args(pp_opts, debug, extra_preargs***REMOVED***
    display = "compile options: '%s'" % (' '.join(cc_args***REMOVED******REMOVED***
    if extra_postargs:
        display += "\nextra options: '%s'" % (' '.join(extra_postargs***REMOVED******REMOVED***
    log.info(display***REMOVED***

    def single_compile(args***REMOVED***:
        obj, (src, ext***REMOVED*** = args
        self._compile(obj, src, ext, cc_args, extra_postargs, pp_opts***REMOVED***

    if isinstance(self, FCompiler***REMOVED***:
        objects_to_build = list(build.keys(***REMOVED******REMOVED***
        f77_objects, other_objects = [***REMOVED***, [***REMOVED***
        for obj in objects:
            if obj in objects_to_build:
                src, ext = build[obj***REMOVED***
                if self.compiler_type=='absoft':
                    obj = cyg2win32(obj***REMOVED***
                    src = cyg2win32(src***REMOVED***
                if is_f_file(src***REMOVED*** and not has_f90_header(src***REMOVED***:
                    f77_objects.append((obj, (src, ext***REMOVED******REMOVED******REMOVED***
                else:
                    other_objects.append((obj, (src, ext***REMOVED******REMOVED******REMOVED***

        # f77 objects can be built in parallel
        build_items = f77_objects
        # build f90 modules serial, module files are generated during
        # compilation and may be used by files later in the list so the
        # ordering is important
        for o in other_objects:
            single_compile(o***REMOVED***
    else:
        build_items = build.items(***REMOVED***

    jobs = get_num_build_jobs(***REMOVED***
    if len(build***REMOVED*** > 1 and jobs > 1:
        # build parallel
        import multiprocessing.pool
        pool = multiprocessing.pool.ThreadPool(jobs***REMOVED***
        pool.map(single_compile, build_items***REMOVED***
        pool.close(***REMOVED***
    else:
        # build serial
        for o in build_items:
            single_compile(o***REMOVED***

    # Return *all* object filenames, not just the ones we just built.
    return objects

replace_method(CCompiler, 'compile', CCompiler_compile***REMOVED***

def CCompiler_customize_cmd(self, cmd, ignore=(***REMOVED******REMOVED***:
    ***REMOVED***
    Customize compiler using distutils command.

    Parameters
    ----------
    cmd : class instance
        An instance inheriting from `distutils.cmd.Command`.
    ignore : sequence of str, optional
        List of `CCompiler` commands (without ``'set_'``***REMOVED*** that should not be
        altered. Strings that are checked for are:
        ``('include_dirs', 'define', 'undef', 'libraries', 'library_dirs',
        'rpath', 'link_objects'***REMOVED***``.

    Returns
    -------
    None

    ***REMOVED***
    log.info('customize %s using %s' % (self.__class__.__name__,
                                        cmd.__class__.__name__***REMOVED******REMOVED***
    def allow(attr***REMOVED***:
        return getattr(cmd, attr, None***REMOVED*** is not None and attr not in ignore

    if allow('include_dirs'***REMOVED***:
        self.set_include_dirs(cmd.include_dirs***REMOVED***
    if allow('define'***REMOVED***:
        for (name, value***REMOVED*** in cmd.define:
            self.define_macro(name, value***REMOVED***
    if allow('undef'***REMOVED***:
        for macro in cmd.undef:
            self.undefine_macro(macro***REMOVED***
    if allow('libraries'***REMOVED***:
        self.set_libraries(self.libraries + cmd.libraries***REMOVED***
    if allow('library_dirs'***REMOVED***:
        self.set_library_dirs(self.library_dirs + cmd.library_dirs***REMOVED***
    if allow('rpath'***REMOVED***:
        self.set_runtime_library_dirs(cmd.rpath***REMOVED***
    if allow('link_objects'***REMOVED***:
        self.set_link_objects(cmd.link_objects***REMOVED***

replace_method(CCompiler, 'customize_cmd', CCompiler_customize_cmd***REMOVED***

def _compiler_to_string(compiler***REMOVED***:
    props = [***REMOVED***
    mx = 0
    keys = list(compiler.executables.keys(***REMOVED******REMOVED***
    for key in ['version', 'libraries', 'library_dirs',
                'object_switch', 'compile_switch',
                'include_dirs', 'define', 'undef', 'rpath', 'link_objects'***REMOVED***:
        if key not in keys:
            keys.append(key***REMOVED***
    for key in keys:
        if hasattr(compiler, key***REMOVED***:
            v = getattr(compiler, key***REMOVED***
            mx = max(mx, len(key***REMOVED******REMOVED***
            props.append((key, repr(v***REMOVED******REMOVED******REMOVED***
    lines = [***REMOVED***
    format = '%-' + repr(mx+1***REMOVED*** + 's = %s'
    for prop in props:
        lines.append(format % prop***REMOVED***
    return '\n'.join(lines***REMOVED***

def CCompiler_show_customization(self***REMOVED***:
    ***REMOVED***
    Print the compiler customizations to stdout.

    Parameters
    ----------
    None

    Returns
    -------
    None

    Notes
    -----
    Printing is only done if the distutils log threshold is < 2.

    ***REMOVED***
    if 0:
        for attrname in ['include_dirs', 'define', 'undef',
                         'libraries', 'library_dirs',
                         'rpath', 'link_objects'***REMOVED***:
            attr = getattr(self, attrname, None***REMOVED***
            if not attr:
                continue
            log.info("compiler '%s' is set to %s" % (attrname, attr***REMOVED******REMOVED***
    ***REMOVED***
        self.get_version(***REMOVED***
    ***REMOVED***
        pass
    if log._global_log.threshold<2:
        print('*'*80***REMOVED***
        print(self.__class__***REMOVED***
        print(_compiler_to_string(self***REMOVED******REMOVED***
        print('*'*80***REMOVED***

replace_method(CCompiler, 'show_customization', CCompiler_show_customization***REMOVED***

def CCompiler_customize(self, dist, need_cxx=0***REMOVED***:
    ***REMOVED***
    Do any platform-specific customization of a compiler instance.

    This method calls `distutils.sysconfig.customize_compiler` for
    platform-specific customization, as well as optionally remove a flag
    to suppress spurious warnings in case C++ code is being compiled.

    Parameters
    ----------
    dist : object
        This parameter is not used for anything.
    need_cxx : bool, optional
        Whether or not C++ has to be compiled. If so (True***REMOVED***, the
        ``"-Wstrict-prototypes"`` option is removed to prevent spurious
        warnings. Default is False.

    Returns
    -------
    None

    Notes
    -----
    All the default options used by distutils can be extracted with::

      from distutils import sysconfig
      sysconfig.get_config_vars('CC', 'CXX', 'OPT', 'BASECFLAGS',
                                'CCSHARED', 'LDSHARED', 'SO'***REMOVED***

    ***REMOVED***
    # See FCompiler.customize for suggested usage.
    log.info('customize %s' % (self.__class__.__name__***REMOVED******REMOVED***
    customize_compiler(self***REMOVED***
    if need_cxx:
        # In general, distutils uses -Wstrict-prototypes, but this option is
        # not valid for C++ code, only for C.  Remove it if it's there to
        # avoid a spurious warning on every compilation.
        ***REMOVED***
            self.compiler_so.remove('-Wstrict-prototypes'***REMOVED***
        except (AttributeError, ValueError***REMOVED***:
            pass

        if hasattr(self, 'compiler'***REMOVED*** and 'cc' in self.compiler[0***REMOVED***:
            if not self.compiler_cxx:
                if self.compiler[0***REMOVED***.startswith('gcc'***REMOVED***:
                    a, b = 'gcc', 'g++'
                else:
                    a, b = 'cc', 'c++'
                self.compiler_cxx = [self.compiler[0***REMOVED***.replace(a, b***REMOVED******REMOVED***\
                                    + self.compiler[1:***REMOVED***
        else:
            if hasattr(self, 'compiler'***REMOVED***:
                log.warn("#### %s #######" % (self.compiler,***REMOVED******REMOVED***
            if not hasattr(self, 'compiler_cxx'***REMOVED***:
                log.warn('Missing compiler_cxx fix for ' + self.__class__.__name__***REMOVED***
    return

replace_method(CCompiler, 'customize', CCompiler_customize***REMOVED***

def simple_version_match(pat=r'[-.\d***REMOVED***+', ignore='', start=''***REMOVED***:
    ***REMOVED***
    Simple matching of version numbers, for use in CCompiler and FCompiler.

    Parameters
    ----------
    pat : str, optional
        A regular expression matching version numbers.
        Default is ``r'[-.\\d***REMOVED***+'``.
    ignore : str, optional
        A regular expression matching patterns to skip.
        Default is ``''``, in which case nothing is skipped.
    start : str, optional
        A regular expression matching the start of where to start looking
        for version numbers.
        Default is ``''``, in which case searching is started at the
        beginning of the version string given to `matcher`.

    Returns
    -------
    matcher : callable
        A function that is appropriate to use as the ``.version_match``
        attribute of a `CCompiler` class. `matcher` takes a single parameter,
        a version string.

    ***REMOVED***
    def matcher(self, version_string***REMOVED***:
        # version string may appear in the second line, so getting rid
        # of new lines:
        version_string = version_string.replace('\n', ' '***REMOVED***
        pos = 0
        if start:
            m = re.match(start, version_string***REMOVED***
            if not m:
                return None
            pos = m.end(***REMOVED***
        while True:
            m = re.search(pat, version_string[pos:***REMOVED******REMOVED***
            if not m:
                return None
            if ignore and re.match(ignore, m.group(0***REMOVED******REMOVED***:
                pos = m.end(***REMOVED***
                continue
            break
        return m.group(0***REMOVED***
    return matcher

def CCompiler_get_version(self, force=False, ok_status=[0***REMOVED******REMOVED***:
    ***REMOVED***
    Return compiler version, or None if compiler is not available.

    Parameters
    ----------
    force : bool, optional
        If True, force a new determination of the version, even if the
        compiler already has a version attribute. Default is False.
    ok_status : list of int, optional
        The list of status values returned by the version look-up process
        for which a version string is returned. If the status value is not
        in `ok_status`, None is returned. Default is ``[0***REMOVED***``.

    Returns
    -------
    version : str or None
        Version string, in the format of `distutils.version.LooseVersion`.

    ***REMOVED***
    if not force and hasattr(self, 'version'***REMOVED***:
        return self.version
    self.find_executables(***REMOVED***
    ***REMOVED***
        version_cmd = self.version_cmd
    except AttributeError:
        return None
    if not version_cmd or not version_cmd[0***REMOVED***:
        return None
    ***REMOVED***
        matcher = self.version_match
    except AttributeError:
        ***REMOVED***
            pat = self.version_pattern
        except AttributeError:
            return None
        def matcher(version_string***REMOVED***:
            m = re.match(pat, version_string***REMOVED***
            if not m:
                return None
            version = m.group('version'***REMOVED***
            return version

    status, output = exec_command(version_cmd, use_tee=0***REMOVED***

    version = None
    if status in ok_status:
        version = matcher(output***REMOVED***
        if version:
            version = LooseVersion(version***REMOVED***
    self.version = version
    return version

replace_method(CCompiler, 'get_version', CCompiler_get_version***REMOVED***

def CCompiler_cxx_compiler(self***REMOVED***:
    ***REMOVED***
    Return the C++ compiler.

    Parameters
    ----------
    None

    Returns
    -------
    cxx : class instance
        The C++ compiler, as a `CCompiler` instance.

    ***REMOVED***
    if self.compiler_type in ('msvc', 'intelw', 'intelemw'***REMOVED***:
        return self

    cxx = copy(self***REMOVED***
    cxx.compiler_so = [cxx.compiler_cxx[0***REMOVED******REMOVED*** + cxx.compiler_so[1:***REMOVED***
    if sys.platform.startswith('aix'***REMOVED*** and 'ld_so_aix' in cxx.linker_so[0***REMOVED***:
        # AIX needs the ld_so_aix script included with Python
        cxx.linker_so = [cxx.linker_so[0***REMOVED***, cxx.compiler_cxx[0***REMOVED******REMOVED*** \
                        + cxx.linker_so[2:***REMOVED***
    else:
        cxx.linker_so = [cxx.compiler_cxx[0***REMOVED******REMOVED*** + cxx.linker_so[1:***REMOVED***
    return cxx

replace_method(CCompiler, 'cxx_compiler', CCompiler_cxx_compiler***REMOVED***

compiler_class['intel'***REMOVED*** = ('intelccompiler', 'IntelCCompiler',
                           "Intel C Compiler for 32-bit applications"***REMOVED***
compiler_class['intele'***REMOVED*** = ('intelccompiler', 'IntelItaniumCCompiler',
                            "Intel C Itanium Compiler for Itanium-based applications"***REMOVED***
compiler_class['intelem'***REMOVED*** = ('intelccompiler', 'IntelEM64TCCompiler',
                             "Intel C Compiler for 64-bit applications"***REMOVED***
compiler_class['intelw'***REMOVED*** = ('intelccompiler', 'IntelCCompilerW',
                            "Intel C Compiler for 32-bit applications on Windows"***REMOVED***
compiler_class['intelemw'***REMOVED*** = ('intelccompiler', 'IntelEM64TCCompilerW',
                              "Intel C Compiler for 64-bit applications on Windows"***REMOVED***
compiler_class['pathcc'***REMOVED*** = ('pathccompiler', 'PathScaleCCompiler',
                            "PathScale Compiler for SiCortex-based applications"***REMOVED***
ccompiler._default_compilers += (('linux.*', 'intel'***REMOVED***,
                                 ('linux.*', 'intele'***REMOVED***,
                                 ('linux.*', 'intelem'***REMOVED***,
                                 ('linux.*', 'pathcc'***REMOVED***,
                                 ('nt', 'intelw'***REMOVED***,
                                 ('nt', 'intelemw'***REMOVED******REMOVED***

if sys.platform == 'win32':
    compiler_class['mingw32'***REMOVED*** = ('mingw32ccompiler', 'Mingw32CCompiler',
                                 "Mingw32 port of GNU C Compiler for Win32"\
                                 "(for MSC built Python***REMOVED***"***REMOVED***
    if mingw32(***REMOVED***:
        # On windows platforms, we want to default to mingw32 (gcc***REMOVED***
        # because msvc can't build blitz stuff.
        log.info('Setting mingw32 as default compiler for nt.'***REMOVED***
        ccompiler._default_compilers = (('nt', 'mingw32'***REMOVED***,***REMOVED*** \
                                       + ccompiler._default_compilers


_distutils_new_compiler = new_compiler
def new_compiler (plat=None,
                  compiler=None,
                  verbose=0,
                  dry_run=0,
                  force=0***REMOVED***:
    # Try first C compilers from numpy.distutils.
    if plat is None:
        plat = os.name
    ***REMOVED***
        if compiler is None:
            compiler = get_default_compiler(plat***REMOVED***
        (module_name, class_name, long_description***REMOVED*** = compiler_class[compiler***REMOVED***
    except KeyError:
        msg = "don't know how to compile C/C++ code on platform '%s'" % plat
        if compiler is not None:
            msg = msg + " with '%s' compiler" % compiler
        raise DistutilsPlatformError(msg***REMOVED***
    module_name = "numpy.distutils." + module_name
    ***REMOVED***
        __import__ (module_name***REMOVED***
    except ImportError:
        msg = str(get_exception(***REMOVED******REMOVED***
        log.info('%s in numpy.distutils; trying from distutils',
                 str(msg***REMOVED******REMOVED***
        module_name = module_name[6:***REMOVED***
        ***REMOVED***
            __import__(module_name***REMOVED***
        except ImportError:
            msg = str(get_exception(***REMOVED******REMOVED***
            raise DistutilsModuleError("can't compile C/C++ code: unable to load module '%s'" % \
                  module_name***REMOVED***
    ***REMOVED***
        module = sys.modules[module_name***REMOVED***
        klass = vars(module***REMOVED***[class_name***REMOVED***
    except KeyError:
        raise DistutilsModuleError(("can't compile C/C++ code: unable to find class '%s' " +
               "in module '%s'"***REMOVED*** % (class_name, module_name***REMOVED******REMOVED***
    compiler = klass(None, dry_run, force***REMOVED***
    log.debug('new_compiler returns %s' % (klass***REMOVED******REMOVED***
    return compiler

ccompiler.new_compiler = new_compiler

_distutils_gen_lib_options = gen_lib_options
def gen_lib_options(compiler, library_dirs, runtime_library_dirs, libraries***REMOVED***:
    library_dirs = quote_args(library_dirs***REMOVED***
    runtime_library_dirs = quote_args(runtime_library_dirs***REMOVED***
    r = _distutils_gen_lib_options(compiler, library_dirs,
                                   runtime_library_dirs, libraries***REMOVED***
    lib_opts = [***REMOVED***
    for i in r:
        if is_sequence(i***REMOVED***:
            lib_opts.extend(list(i***REMOVED******REMOVED***
        else:
            lib_opts.append(i***REMOVED***
    return lib_opts
ccompiler.gen_lib_options = gen_lib_options

# Also fix up the various compiler modules, which do
# from distutils.ccompiler import gen_lib_options
# Don't bother with mwerks, as we don't support Classic Mac.
for _cc in ['msvc9', 'msvc', '_msvc', 'bcpp', 'cygwinc', 'emxc', 'unixc'***REMOVED***:
    _m = sys.modules.get('distutils.' + _cc + 'compiler'***REMOVED***
    if _m is not None:
        setattr(_m, 'gen_lib_options', gen_lib_options***REMOVED***

_distutils_gen_preprocess_options = gen_preprocess_options
def gen_preprocess_options (macros, include_dirs***REMOVED***:
    include_dirs = quote_args(include_dirs***REMOVED***
    return _distutils_gen_preprocess_options(macros, include_dirs***REMOVED***
ccompiler.gen_preprocess_options = gen_preprocess_options

##Fix distutils.util.split_quoted:
# NOTE:  I removed this fix in revision 4481 (see ticket #619***REMOVED***, but it appears
# that removing this fix causes f2py problems on Windows XP (see ticket #723***REMOVED***.
# Specifically, on WinXP when gfortran is installed in a directory path, which
# contains spaces, then f2py is unable to find it.
import string
_wordchars_re = re.compile(r'[^\\\'\"%s ***REMOVED****' % string.whitespace***REMOVED***
_squote_re = re.compile(r"'(?:[^'\\***REMOVED***|\\.***REMOVED****'"***REMOVED***
_dquote_re = re.compile(r'"(?:[^"\\***REMOVED***|\\.***REMOVED****"'***REMOVED***
_has_white_re = re.compile(r'\s'***REMOVED***
def split_quoted(s***REMOVED***:
    s = s.strip(***REMOVED***
    words = [***REMOVED***
    pos = 0

    while s:
        m = _wordchars_re.match(s, pos***REMOVED***
        end = m.end(***REMOVED***
        if end == len(s***REMOVED***:
            words.append(s[:end***REMOVED******REMOVED***
            break

        if s[end***REMOVED*** in string.whitespace: # unescaped, unquoted whitespace: now
            words.append(s[:end***REMOVED******REMOVED***       # we definitely have a word delimiter
            s = s[end:***REMOVED***.lstrip(***REMOVED***
            pos = 0

        elif s[end***REMOVED*** == '\\':            # preserve whatever is being escaped;
                                        # will become part of the current word
            s = s[:end***REMOVED*** + s[end+1:***REMOVED***
            pos = end+1

        else:
            if s[end***REMOVED*** == "'":           # slurp singly-quoted string
                m = _squote_re.match(s, end***REMOVED***
            elif s[end***REMOVED*** == '"':         # slurp doubly-quoted string
                m = _dquote_re.match(s, end***REMOVED***
            else:
                raise RuntimeError("this can't happen (bad char '%c'***REMOVED***" % s[end***REMOVED******REMOVED***

            if m is None:
                raise ValueError("bad string (mismatched %s quotes?***REMOVED***" % s[end***REMOVED******REMOVED***

            (beg, end***REMOVED*** = m.span(***REMOVED***
            if _has_white_re.search(s[beg+1:end-1***REMOVED******REMOVED***:
                s = s[:beg***REMOVED*** + s[beg+1:end-1***REMOVED*** + s[end:***REMOVED***
                pos = m.end(***REMOVED*** - 2
            else:
                # Keeping quotes when a quoted word does not contain
                # white-space. XXX: send a patch to distutils
                pos = m.end(***REMOVED***

        if pos >= len(s***REMOVED***:
            words.append(s***REMOVED***
            break

    return words
ccompiler.split_quoted = split_quoted
##Fix distutils.util.split_quoted:
