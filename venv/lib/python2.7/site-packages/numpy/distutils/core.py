from __future__ import division, absolute_import, print_function

import sys
from distutils.core import *

if 'setuptools' in sys.modules:
    have_setuptools = True
    from setuptools import setup as old_setup
    # easy_install imports math, it may be picked up from cwd
    from setuptools.command import easy_install
    ***REMOVED***
        # very old versions of setuptools don't have this
        from setuptools.command import bdist_egg
    except ImportError:
        have_setuptools = False
else:
    from distutils.core import setup as old_setup
    have_setuptools = False

import warnings
import distutils.core
import distutils.dist

from numpy.distutils.extension import Extension
from numpy.distutils.numpy_distribution import NumpyDistribution
from numpy.distutils.command import config, config_compiler, \
     build, build_py, build_ext, build_clib, build_src, build_scripts, \
     sdist, install_data, install_headers, install, bdist_rpm, \
     install_clib
from numpy.distutils.misc_util import get_data_files, is_sequence, is_string

numpy_cmdclass = {'build':            build.build,
                  'build_src':        build_src.build_src,
                  'build_scripts':    build_scripts.build_scripts,
                  'config_cc':        config_compiler.config_cc,
                  'config_fc':        config_compiler.config_fc,
                  'config':           config.config,
                  'build_ext':        build_ext.build_ext,
                  'build_py':         build_py.build_py,
                  'build_clib':       build_clib.build_clib,
                  'sdist':            sdist.sdist,
                  'install_data':     install_data.install_data,
                  'install_headers':  install_headers.install_headers,
                  'install_clib':     install_clib.install_clib,
                  'install':          install.install,
                  'bdist_rpm':        bdist_rpm.bdist_rpm,
              ***REMOVED***
if have_setuptools:
    # Use our own versions of develop and egg_info to ensure that build_src is
    # handled appropriately.
    from numpy.distutils.command import develop, egg_info
    numpy_cmdclass['bdist_egg'***REMOVED*** = bdist_egg.bdist_egg
    numpy_cmdclass['develop'***REMOVED*** = develop.develop
    numpy_cmdclass['easy_install'***REMOVED*** = easy_install.easy_install
    numpy_cmdclass['egg_info'***REMOVED*** = egg_info.egg_info

def _dict_append(d, **kws***REMOVED***:
    for k, v in kws.items(***REMOVED***:
        if k not in d:
            d[k***REMOVED*** = v
            continue
        dv = d[k***REMOVED***
        if isinstance(dv, tuple***REMOVED***:
            d[k***REMOVED*** = dv + tuple(v***REMOVED***
        elif isinstance(dv, list***REMOVED***:
            d[k***REMOVED*** = dv + list(v***REMOVED***
        elif isinstance(dv, dict***REMOVED***:
            _dict_append(dv, **v***REMOVED***
        elif is_string(dv***REMOVED***:
            d[k***REMOVED*** = dv + v
        else:
            raise TypeError(repr(type(dv***REMOVED******REMOVED******REMOVED***

def _command_line_ok(_cache=[***REMOVED******REMOVED***:
    ***REMOVED*** Return True if command line does not contain any
    help or display requests.
    ***REMOVED***
    if _cache:
        return _cache[0***REMOVED***
    ok = True
    display_opts = ['--'+n for n in Distribution.display_option_names***REMOVED***
    for o in Distribution.display_options:
        if o[1***REMOVED***:
            display_opts.append('-'+o[1***REMOVED******REMOVED***
    for arg in sys.argv:
        if arg.startswith('--help'***REMOVED*** or arg=='-h' or arg in display_opts:
            ok = False
            break
    _cache.append(ok***REMOVED***
    return ok

def get_distribution(always=False***REMOVED***:
    dist = distutils.core._setup_distribution
    # XXX Hack to get numpy installable with easy_install.
    # The problem is easy_install runs it's own setup(***REMOVED***, which
    # sets up distutils.core._setup_distribution. However,
    # when our setup(***REMOVED*** runs, that gets overwritten and lost.
    # We can't use isinstance, as the DistributionWithoutHelpCommands
    # class is local to a function in setuptools.command.easy_install
    if dist is not None and \
            'DistributionWithoutHelpCommands' in repr(dist***REMOVED***:
        dist = None
    if always and dist is None:
        dist = NumpyDistribution(***REMOVED***
    return dist

def setup(**attr***REMOVED***:

    cmdclass = numpy_cmdclass.copy(***REMOVED***

    new_attr = attr.copy(***REMOVED***
    if 'cmdclass' in new_attr:
        cmdclass.update(new_attr['cmdclass'***REMOVED******REMOVED***
    new_attr['cmdclass'***REMOVED*** = cmdclass

    if 'configuration' in new_attr:
        # To avoid calling configuration if there are any errors
        # or help request in command in the line.
        configuration = new_attr.pop('configuration'***REMOVED***

        old_dist = distutils.core._setup_distribution
        old_stop = distutils.core._setup_stop_after
        distutils.core._setup_distribution = None
        distutils.core._setup_stop_after = "commandline"
        ***REMOVED***
            dist = setup(**new_attr***REMOVED***
        finally:
            distutils.core._setup_distribution = old_dist
            distutils.core._setup_stop_after = old_stop
        if dist.help or not _command_line_ok(***REMOVED***:
            # probably displayed help, skip running any commands
            return dist

        # create setup dictionary and append to new_attr
        config = configuration(***REMOVED***
        if hasattr(config, 'todict'***REMOVED***:
            config = config.todict(***REMOVED***
        _dict_append(new_attr, **config***REMOVED***

    # Move extension source libraries to libraries
    libraries = [***REMOVED***
    for ext in new_attr.get('ext_modules', [***REMOVED******REMOVED***:
        new_libraries = [***REMOVED***
        for item in ext.libraries:
            if is_sequence(item***REMOVED***:
                lib_name, build_info = item
                _check_append_ext_library(libraries, lib_name, build_info***REMOVED***
                new_libraries.append(lib_name***REMOVED***
            elif is_string(item***REMOVED***:
                new_libraries.append(item***REMOVED***
            else:
                raise TypeError("invalid description of extension module "
                                "library %r" % (item,***REMOVED******REMOVED***
        ext.libraries = new_libraries
    if libraries:
        if 'libraries' not in new_attr:
            new_attr['libraries'***REMOVED*** = [***REMOVED***
        for item in libraries:
            _check_append_library(new_attr['libraries'***REMOVED***, item***REMOVED***

    # sources in ext_modules or libraries may contain header files
    if ('ext_modules' in new_attr or 'libraries' in new_attr***REMOVED*** \
       and 'headers' not in new_attr:
        new_attr['headers'***REMOVED*** = [***REMOVED***

    # Use our custom NumpyDistribution class instead of distutils' one
    new_attr['distclass'***REMOVED*** = NumpyDistribution

    return old_setup(**new_attr***REMOVED***

def _check_append_library(libraries, item***REMOVED***:
    for libitem in libraries:
        if is_sequence(libitem***REMOVED***:
            if is_sequence(item***REMOVED***:
                if item[0***REMOVED***==libitem[0***REMOVED***:
                    if item[1***REMOVED*** is libitem[1***REMOVED***:
                        return
                    warnings.warn("[0***REMOVED*** libraries list contains %r with"
                                  " different build_info" % (item[0***REMOVED***,***REMOVED******REMOVED***
                    break
            else:
                if item==libitem[0***REMOVED***:
                    warnings.warn("[1***REMOVED*** libraries list contains %r with"
                                  " no build_info" % (item[0***REMOVED***,***REMOVED******REMOVED***
                    break
        else:
            if is_sequence(item***REMOVED***:
                if item[0***REMOVED***==libitem:
                    warnings.warn("[2***REMOVED*** libraries list contains %r with"
                                  " no build_info" % (item[0***REMOVED***,***REMOVED******REMOVED***
                    break
            else:
                if item==libitem:
                    return
    libraries.append(item***REMOVED***

def _check_append_ext_library(libraries, lib_name, build_info***REMOVED***:
    for item in libraries:
        if is_sequence(item***REMOVED***:
            if item[0***REMOVED***==lib_name:
                if item[1***REMOVED*** is build_info:
                    return
                warnings.warn("[3***REMOVED*** libraries list contains %r with"
                              " different build_info" % (lib_name,***REMOVED******REMOVED***
                break
        elif item==lib_name:
            warnings.warn("[4***REMOVED*** libraries list contains %r with"
                          " no build_info" % (lib_name,***REMOVED******REMOVED***
            break
    libraries.append((lib_name, build_info***REMOVED******REMOVED***
