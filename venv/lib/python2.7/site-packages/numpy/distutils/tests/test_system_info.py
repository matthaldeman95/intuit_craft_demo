from __future__ import division, print_function

***REMOVED***
import shutil
from tempfile import mkstemp, mkdtemp
from subprocess import Popen, PIPE
from distutils.errors import DistutilsError

from numpy.distutils import ccompiler
from numpy.testing import TestCase, run_module_suite, assert_, assert_equal
from numpy.testing.decorators import skipif
from numpy.distutils.system_info import system_info, ConfigParser
from numpy.distutils.system_info import default_lib_dirs, default_include_dirs


def get_class(name, notfound_action=1***REMOVED***:
    ***REMOVED***
    notfound_action:
      0 - do nothing
      1 - display warning message
      2 - raise error
    ***REMOVED***
    cl = {'temp1': TestTemp1,
          'temp2': TestTemp2
      ***REMOVED***.get(name.lower(***REMOVED***, test_system_info***REMOVED***
    return cl(***REMOVED***

simple_site = ***REMOVED***
[ALL***REMOVED***
library_dirs = {dir1:s***REMOVED***{pathsep:s***REMOVED***{dir2:s***REMOVED***
libraries = {lib1:s***REMOVED***,{lib2:s***REMOVED***
extra_compile_args = -I/fake/directory
runtime_library_dirs = {dir1:s***REMOVED***

[temp1***REMOVED***
library_dirs = {dir1:s***REMOVED***
libraries = {lib1:s***REMOVED***
runtime_library_dirs = {dir1:s***REMOVED***

[temp2***REMOVED***
library_dirs = {dir2:s***REMOVED***
libraries = {lib2:s***REMOVED***
extra_link_args = -Wl,-rpath={lib2:s***REMOVED***
rpath = {dir2:s***REMOVED***
***REMOVED***
site_cfg = simple_site

fakelib_c_text = ***REMOVED***
/* This file is generated from numpy/distutils/testing/test_system_info.py */
#include<stdio.h>
void foo(void***REMOVED*** {
   printf("Hello foo"***REMOVED***;
***REMOVED***
void bar(void***REMOVED*** {
   printf("Hello bar"***REMOVED***;
***REMOVED***
***REMOVED***

def have_compiler(***REMOVED***:
    ***REMOVED*** Return True if there appears to be an executable compiler
    ***REMOVED***
    compiler = ccompiler.new_compiler(***REMOVED***
    ***REMOVED***
        cmd = compiler.compiler  # Unix compilers
    except AttributeError:
        ***REMOVED***
            compiler.initialize(***REMOVED***  # MSVC is different
        except DistutilsError:
            return False
        cmd = [compiler.cc***REMOVED***
    ***REMOVED***
        Popen(cmd, stdout=PIPE, stderr=PIPE***REMOVED***
    except OSError:
        return False
    return True


HAVE_COMPILER = have_compiler(***REMOVED***


class test_system_info(system_info***REMOVED***:

    def __init__(self,
                 default_lib_dirs=default_lib_dirs,
                 default_include_dirs=default_include_dirs,
                 verbosity=1,
                 ***REMOVED***:
        self.__class__.info = {***REMOVED***
        self.local_prefixes = [***REMOVED***
        defaults = {'library_dirs': '',
                    'include_dirs': '',
                    'runtime_library_dirs': '',
                    'rpath': '',
                    'src_dirs': '',
                    'search_static_first': "0",
                    'extra_compile_args': '',
                    'extra_link_args': ''***REMOVED***
        self.cp = ConfigParser(defaults***REMOVED***
        # We have to parse the config files afterwards
        # to have a consistent temporary filepath

    def _check_libs(self, lib_dirs, libs, opt_libs, exts***REMOVED***:
        ***REMOVED***Override _check_libs to return with all dirs ***REMOVED***
        info = {'libraries': libs, 'library_dirs': lib_dirs***REMOVED***
        return info


class TestTemp1(test_system_info***REMOVED***:
    section = 'temp1'


class TestTemp2(test_system_info***REMOVED***:
    section = 'temp2'


class TestSystemInfoReading(TestCase***REMOVED***:

    def setUp(self***REMOVED***:
        ***REMOVED*** Create the libraries ***REMOVED***
        # Create 2 sources and 2 libraries
        self._dir1 = mkdtemp(***REMOVED***
        self._src1 = os.path.join(self._dir1, 'foo.c'***REMOVED***
        self._lib1 = os.path.join(self._dir1, 'libfoo.so'***REMOVED***
        self._dir2 = mkdtemp(***REMOVED***
        self._src2 = os.path.join(self._dir2, 'bar.c'***REMOVED***
        self._lib2 = os.path.join(self._dir2, 'libbar.so'***REMOVED***
        # Update local site.cfg
        global simple_site, site_cfg
        site_cfg = simple_site.format(**{
            'dir1': self._dir1,
            'lib1': self._lib1,
            'dir2': self._dir2,
            'lib2': self._lib2,
            'pathsep': os.pathsep
    ***REMOVED******REMOVED***
        # Write site.cfg
        fd, self._sitecfg = mkstemp(***REMOVED***
        os.close(fd***REMOVED***
        with open(self._sitecfg, 'w'***REMOVED*** as fd:
            fd.write(site_cfg***REMOVED***
        # Write the sources
        with open(self._src1, 'w'***REMOVED*** as fd:
            fd.write(fakelib_c_text***REMOVED***
        with open(self._src2, 'w'***REMOVED*** as fd:
            fd.write(fakelib_c_text***REMOVED***
        # We create all class-instances

        def site_and_parse(c, site_cfg***REMOVED***:
            c.files = [site_cfg***REMOVED***
            c.parse_config_files(***REMOVED***
            return c
        self.c_default = site_and_parse(get_class('default'***REMOVED***, self._sitecfg***REMOVED***
        self.c_temp1 = site_and_parse(get_class('temp1'***REMOVED***, self._sitecfg***REMOVED***
        self.c_temp2 = site_and_parse(get_class('temp2'***REMOVED***, self._sitecfg***REMOVED***

    def tearDown(self***REMOVED***:
        # Do each removal separately
        ***REMOVED***
            shutil.rmtree(self._dir1***REMOVED***
        ***REMOVED***
            pass
        ***REMOVED***
            shutil.rmtree(self._dir2***REMOVED***
        ***REMOVED***
            pass
        ***REMOVED***
            os.remove(self._sitecfg***REMOVED***
        ***REMOVED***
            pass

    def test_all(self***REMOVED***:
        # Read in all information in the ALL block
        tsi = self.c_default
        assert_equal(tsi.get_lib_dirs(***REMOVED***, [self._dir1, self._dir2***REMOVED******REMOVED***
        assert_equal(tsi.get_libraries(***REMOVED***, [self._lib1, self._lib2***REMOVED******REMOVED***
        assert_equal(tsi.get_runtime_lib_dirs(***REMOVED***, [self._dir1***REMOVED******REMOVED***
        extra = tsi.calc_extra_info(***REMOVED***
        assert_equal(extra['extra_compile_args'***REMOVED***, ['-I/fake/directory'***REMOVED******REMOVED***

    def test_temp1(self***REMOVED***:
        # Read in all information in the temp1 block
        tsi = self.c_temp1
        assert_equal(tsi.get_lib_dirs(***REMOVED***, [self._dir1***REMOVED******REMOVED***
        assert_equal(tsi.get_libraries(***REMOVED***, [self._lib1***REMOVED******REMOVED***
        assert_equal(tsi.get_runtime_lib_dirs(***REMOVED***, [self._dir1***REMOVED******REMOVED***

    def test_temp2(self***REMOVED***:
        # Read in all information in the temp2 block
        tsi = self.c_temp2
        assert_equal(tsi.get_lib_dirs(***REMOVED***, [self._dir2***REMOVED******REMOVED***
        assert_equal(tsi.get_libraries(***REMOVED***, [self._lib2***REMOVED******REMOVED***
        # Now from rpath and not runtime_library_dirs
        assert_equal(tsi.get_runtime_lib_dirs(key='rpath'***REMOVED***, [self._dir2***REMOVED******REMOVED***
        extra = tsi.calc_extra_info(***REMOVED***
        assert_equal(extra['extra_link_args'***REMOVED***, ['-Wl,-rpath=' + self._lib2***REMOVED******REMOVED***

    @skipif(not HAVE_COMPILER***REMOVED***
    def test_compile1(self***REMOVED***:
        # Compile source and link the first source
        c = ccompiler.new_compiler(***REMOVED***
        previousDir = os.getcwd(***REMOVED***
        ***REMOVED***
            # Change directory to not screw up directories
            os.chdir(self._dir1***REMOVED***
            c.compile([os.path.basename(self._src1***REMOVED******REMOVED***, output_dir=self._dir1***REMOVED***
            # Ensure that the object exists
            assert_(os.path.isfile(self._src1.replace('.c', '.o'***REMOVED******REMOVED*** or
                    os.path.isfile(self._src1.replace('.c', '.obj'***REMOVED******REMOVED******REMOVED***
        finally:
            os.chdir(previousDir***REMOVED***

    @skipif(not HAVE_COMPILER***REMOVED***
    @skipif('msvc' in repr(ccompiler.new_compiler(***REMOVED******REMOVED******REMOVED***
    def test_compile2(self***REMOVED***:
        # Compile source and link the second source
        tsi = self.c_temp2
        c = ccompiler.new_compiler(***REMOVED***
        extra_link_args = tsi.calc_extra_info(***REMOVED***['extra_link_args'***REMOVED***
        previousDir = os.getcwd(***REMOVED***
        ***REMOVED***
            # Change directory to not screw up directories
            os.chdir(self._dir2***REMOVED***
            c.compile([os.path.basename(self._src2***REMOVED******REMOVED***, output_dir=self._dir2,
                      extra_postargs=extra_link_args***REMOVED***
            # Ensure that the object exists
            assert_(os.path.isfile(self._src2.replace('.c', '.o'***REMOVED******REMOVED******REMOVED***
        finally:
            os.chdir(previousDir***REMOVED***


if __name__ == '__main__':
    run_module_suite(***REMOVED***
