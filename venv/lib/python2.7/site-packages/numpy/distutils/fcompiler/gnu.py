from __future__ import division, absolute_import, print_function

import re
***REMOVED***
import sys
import warnings
import platform
import tempfile
from subprocess import Popen, PIPE, STDOUT

from numpy.distutils.fcompiler import FCompiler
from numpy.distutils.exec_command import exec_command
from numpy.distutils.misc_util import msvc_runtime_library
from numpy.distutils.compat import get_exception

compilers = ['GnuFCompiler', 'Gnu95FCompiler'***REMOVED***

TARGET_R = re.compile("Target: ([a-zA-Z0-9_\-***REMOVED*******REMOVED***"***REMOVED***

# XXX: handle cross compilation
def is_win64(***REMOVED***:
    return sys.platform == "win32" and platform.architecture(***REMOVED***[0***REMOVED*** == "64bit"

if is_win64(***REMOVED***:
    #_EXTRAFLAGS = ["-fno-leading-underscore"***REMOVED***
    _EXTRAFLAGS = [***REMOVED***
else:
    _EXTRAFLAGS = [***REMOVED***

class GnuFCompiler(FCompiler***REMOVED***:
    compiler_type = 'gnu'
    compiler_aliases = ('g77',***REMOVED***
    description = 'GNU Fortran 77 compiler'

    def gnu_version_match(self, version_string***REMOVED***:
        ***REMOVED***Handle the different versions of GNU fortran compilers***REMOVED***
        # Strip warning(s***REMOVED*** that may be emitted by gfortran
        while version_string.startswith('gfortran: warning'***REMOVED***:
            version_string = version_string[version_string.find('\n'***REMOVED***+1:***REMOVED***

        # Gfortran versions from after 2010 will output a simple string
        # (usually "x.y", "x.y.z" or "x.y.z-q"***REMOVED*** for ``-dumpversion``; older
        # gfortrans may still return long version strings (``-dumpversion`` was
        # an alias for ``--version``***REMOVED***
        if len(version_string***REMOVED*** <= 20:
            # Try to find a valid version string
            m = re.search(r'([0-9.***REMOVED***+***REMOVED***', version_string***REMOVED***
            if m:
                # g77 provides a longer version string that starts with GNU
                # Fortran
                if version_string.startswith('GNU Fortran'***REMOVED***:
                    return ('g77', m.group(1***REMOVED******REMOVED***

                # gfortran only outputs a version string such as #.#.#, so check
                # if the match is at the start of the string
                elif m.start(***REMOVED*** == 0:
                    return ('gfortran', m.group(1***REMOVED******REMOVED***
        else:
            # Output probably from --version, try harder:
            m = re.search(r'GNU Fortran\s+95.*?([0-9-.***REMOVED***+***REMOVED***', version_string***REMOVED***
            if m:
                return ('gfortran', m.group(1***REMOVED******REMOVED***
            m = re.search(r'GNU Fortran.*?\-?([0-9-.***REMOVED***+***REMOVED***', version_string***REMOVED***
            if m:
                v = m.group(1***REMOVED***
                if v.startswith('0'***REMOVED*** or v.startswith('2'***REMOVED*** or v.startswith('3'***REMOVED***:
                    # the '0' is for early g77's
                    return ('g77', v***REMOVED***
                else:
                    # at some point in the 4.x series, the ' 95' was dropped
                    # from the version string
                    return ('gfortran', v***REMOVED***

        # If still nothing, raise an error to make the problem easy to find.
        err = 'A valid Fortran version was not found in this string:\n'
        raise ValueError(err + version_string***REMOVED***

    def version_match(self, version_string***REMOVED***:
        v = self.gnu_version_match(version_string***REMOVED***
        if not v or v[0***REMOVED*** != 'g77':
            return None
        return v[1***REMOVED***

    possible_executables = ['g77', 'f77'***REMOVED***
    executables = {
        'version_cmd'  : [None, "-dumpversion"***REMOVED***,
        'compiler_f77' : [None, "-g", "-Wall", "-fno-second-underscore"***REMOVED***,
        'compiler_f90' : None,  # Use --fcompiler=gnu95 for f90 codes
        'compiler_fix' : None,
        'linker_so'    : [None, "-g", "-Wall"***REMOVED***,
        'archiver'     : ["ar", "-cr"***REMOVED***,
        'ranlib'       : ["ranlib"***REMOVED***,
        'linker_exe'   : [None, "-g", "-Wall"***REMOVED***
    ***REMOVED***
    module_dir_switch = None
    module_include_switch = None

    # Cygwin: f771: warning: -fPIC ignored for target (all code is
    # position independent***REMOVED***
    if os.name != 'nt' and sys.platform != 'cygwin':
        pic_flags = ['-fPIC'***REMOVED***

    # use -mno-cygwin for g77 when Python is not Cygwin-Python
    if sys.platform == 'win32':
        for key in ['version_cmd', 'compiler_f77', 'linker_so', 'linker_exe'***REMOVED***:
            executables[key***REMOVED***.append('-mno-cygwin'***REMOVED***

    g2c = 'g2c'
    suggested_f90_compiler = 'gnu95'

    def get_flags_linker_so(self***REMOVED***:
        opt = self.linker_so[1:***REMOVED***
        if sys.platform == 'darwin':
            target = os.environ.get('MACOSX_DEPLOYMENT_TARGET', None***REMOVED***
            # If MACOSX_DEPLOYMENT_TARGET is set, we simply trust the value
            # and leave it alone.  But, distutils will complain if the
            # environment's value is different from the one in the Python
            # Makefile used to build Python.  We let disutils handle this
            # error checking.
            if not target:
                # If MACOSX_DEPLOYMENT_TARGET is not set in the environment,
                # we try to get it first from the Python Makefile and then we
                # fall back to setting it to 10.3 to maximize the set of
                # versions we can work with.  This is a reasonable default
                # even when using the official Python dist and those derived
                # from it.
                import distutils.sysconfig as sc
                g = {***REMOVED***
                filename = sc.get_makefile_filename(***REMOVED***
                sc.parse_makefile(filename, g***REMOVED***
                target = g.get('MACOSX_DEPLOYMENT_TARGET', '10.3'***REMOVED***
                os.environ['MACOSX_DEPLOYMENT_TARGET'***REMOVED*** = target
                if target == '10.3':
                    s = 'Env. variable MACOSX_DEPLOYMENT_TARGET set to 10.3'
                    warnings.warn(s***REMOVED***

            opt.extend(['-undefined', 'dynamic_lookup', '-bundle'***REMOVED******REMOVED***
        else:
            opt.append("-shared"***REMOVED***
        if sys.platform.startswith('sunos'***REMOVED***:
            # SunOS often has dynamically loaded symbols defined in the
            # static library libg2c.a  The linker doesn't like this.  To
            # ignore the problem, use the -mimpure-text flag.  It isn't
            # the safest thing, but seems to work. 'man gcc' says:
            # ".. Instead of using -mimpure-text, you should compile all
            #  source code with -fpic or -fPIC."
            opt.append('-mimpure-text'***REMOVED***
        return opt

    def get_libgcc_dir(self***REMOVED***:
        status, output = exec_command(self.compiler_f77 +
                                      ['-print-libgcc-file-name'***REMOVED***,
                                      use_tee=0***REMOVED***
        if not status:
            return os.path.dirname(output***REMOVED***
        return None

    def get_library_dirs(self***REMOVED***:
        opt = [***REMOVED***
        if sys.platform[:5***REMOVED*** != 'linux':
            d = self.get_libgcc_dir(***REMOVED***
            if d:
                # if windows and not cygwin, libg2c lies in a different folder
                if sys.platform == 'win32' and not d.startswith('/usr/lib'***REMOVED***:
                    d = os.path.normpath(d***REMOVED***
                    path = os.path.join(d, "lib%s.a" % self.g2c***REMOVED***
                    if not os.path.exists(path***REMOVED***:
                        root = os.path.join(d, *((os.pardir,***REMOVED****4***REMOVED******REMOVED***
                        d2 = os.path.abspath(os.path.join(root, 'lib'***REMOVED******REMOVED***
                        path = os.path.join(d2, "lib%s.a" % self.g2c***REMOVED***
                        if os.path.exists(path***REMOVED***:
                            opt.append(d2***REMOVED***
                opt.append(d***REMOVED***
        return opt

    def get_libraries(self***REMOVED***:
        opt = [***REMOVED***
        d = self.get_libgcc_dir(***REMOVED***
        if d is not None:
            g2c = self.g2c + '-pic'
            f = self.static_lib_format % (g2c, self.static_lib_extension***REMOVED***
            if not os.path.isfile(os.path.join(d, f***REMOVED******REMOVED***:
                g2c = self.g2c
        else:
            g2c = self.g2c

        if g2c is not None:
            opt.append(g2c***REMOVED***
        c_compiler = self.c_compiler
        if sys.platform == 'win32' and c_compiler and \
               c_compiler.compiler_type == 'msvc':
            # the following code is not needed (read: breaks***REMOVED*** when using MinGW
            # in case want to link F77 compiled code with MSVC
            opt.append('gcc'***REMOVED***
            runtime_lib = msvc_runtime_library(***REMOVED***
            if runtime_lib:
                opt.append(runtime_lib***REMOVED***
        if sys.platform == 'darwin':
            opt.append('cc_dynamic'***REMOVED***
        return opt

    def get_flags_debug(self***REMOVED***:
        return ['-g'***REMOVED***

    def get_flags_opt(self***REMOVED***:
        v = self.get_version(***REMOVED***
        if v and v <= '3.3.3':
            # With this compiler version building Fortran BLAS/LAPACK
            # with -O3 caused failures in lib.lapack heevr,syevr tests.
            opt = ['-O2'***REMOVED***
        else:
            opt = ['-O3'***REMOVED***
        opt.append('-funroll-loops'***REMOVED***
        return opt

    def _c_arch_flags(self***REMOVED***:
        ***REMOVED*** Return detected arch flags from CFLAGS ***REMOVED***
        from distutils import sysconfig
        ***REMOVED***
            cflags = sysconfig.get_config_vars(***REMOVED***['CFLAGS'***REMOVED***
        except KeyError:
            return [***REMOVED***
        arch_re = re.compile(r"-arch\s+(\w+***REMOVED***"***REMOVED***
        arch_flags = [***REMOVED***
        for arch in arch_re.findall(cflags***REMOVED***:
            arch_flags += ['-arch', arch***REMOVED***
        return arch_flags

    def get_flags_arch(self***REMOVED***:
        return [***REMOVED***

    def runtime_library_dir_option(self, dir***REMOVED***:
        return '-Wl,-rpath="%s"' % dir

class Gnu95FCompiler(GnuFCompiler***REMOVED***:
    compiler_type = 'gnu95'
    compiler_aliases = ('gfortran',***REMOVED***
    description = 'GNU Fortran 95 compiler'

    def version_match(self, version_string***REMOVED***:
        v = self.gnu_version_match(version_string***REMOVED***
        if not v or v[0***REMOVED*** != 'gfortran':
            return None
        v = v[1***REMOVED***
        if v >= '4.':
            # gcc-4 series releases do not support -mno-cygwin option
            pass
        else:
            # use -mno-cygwin flag for gfortran when Python is not
            # Cygwin-Python
            if sys.platform == 'win32':
                for key in ['version_cmd', 'compiler_f77', 'compiler_f90',
                            'compiler_fix', 'linker_so', 'linker_exe'***REMOVED***:
                    self.executables[key***REMOVED***.append('-mno-cygwin'***REMOVED***
        return v

    possible_executables = ['gfortran', 'f95'***REMOVED***
    executables = {
        'version_cmd'  : ["<F90>", "-dumpversion"***REMOVED***,
        'compiler_f77' : [None, "-Wall", "-g", "-ffixed-form",
                          "-fno-second-underscore"***REMOVED*** + _EXTRAFLAGS,
        'compiler_f90' : [None, "-Wall", "-g",
                          "-fno-second-underscore"***REMOVED*** + _EXTRAFLAGS,
        'compiler_fix' : [None, "-Wall",  "-g","-ffixed-form",
                          "-fno-second-underscore"***REMOVED*** + _EXTRAFLAGS,
        'linker_so'    : ["<F90>", "-Wall", "-g"***REMOVED***,
        'archiver'     : ["ar", "-cr"***REMOVED***,
        'ranlib'       : ["ranlib"***REMOVED***,
        'linker_exe'   : [None, "-Wall"***REMOVED***
    ***REMOVED***

    module_dir_switch = '-J'
    module_include_switch = '-I'

    g2c = 'gfortran'

    def _universal_flags(self, cmd***REMOVED***:
        ***REMOVED***Return a list of -arch flags for every supported architecture.***REMOVED***
        if not sys.platform == 'darwin':
            return [***REMOVED***
        arch_flags = [***REMOVED***
        # get arches the C compiler gets.
        c_archs = self._c_arch_flags(***REMOVED***
        if "i386" in c_archs:
            c_archs[c_archs.index("i386"***REMOVED******REMOVED*** = "i686"
        # check the arches the Fortran compiler supports, and compare with
        # arch flags from C compiler
        for arch in ["ppc", "i686", "x86_64", "ppc64"***REMOVED***:
            if _can_target(cmd, arch***REMOVED*** and arch in c_archs:
                arch_flags.extend(["-arch", arch***REMOVED******REMOVED***
        return arch_flags

    def get_flags(self***REMOVED***:
        flags = GnuFCompiler.get_flags(self***REMOVED***
        arch_flags = self._universal_flags(self.compiler_f90***REMOVED***
        if arch_flags:
            flags[:0***REMOVED*** = arch_flags
        return flags

    def get_flags_linker_so(self***REMOVED***:
        flags = GnuFCompiler.get_flags_linker_so(self***REMOVED***
        arch_flags = self._universal_flags(self.linker_so***REMOVED***
        if arch_flags:
            flags[:0***REMOVED*** = arch_flags
        return flags

    def get_library_dirs(self***REMOVED***:
        opt = GnuFCompiler.get_library_dirs(self***REMOVED***
        if sys.platform == 'win32':
            c_compiler = self.c_compiler
            if c_compiler and c_compiler.compiler_type == "msvc":
                target = self.get_target(***REMOVED***
                if target:
                    d = os.path.normpath(self.get_libgcc_dir(***REMOVED******REMOVED***
                    root = os.path.join(d, *((os.pardir,***REMOVED****4***REMOVED******REMOVED***
                    path = os.path.join(root, "lib"***REMOVED***
                    mingwdir = os.path.normpath(path***REMOVED***
                    if os.path.exists(os.path.join(mingwdir, "libmingwex.a"***REMOVED******REMOVED***:
                        opt.append(mingwdir***REMOVED***
        return opt

    def get_libraries(self***REMOVED***:
        opt = GnuFCompiler.get_libraries(self***REMOVED***
        if sys.platform == 'darwin':
            opt.remove('cc_dynamic'***REMOVED***
        if sys.platform == 'win32':
            c_compiler = self.c_compiler
            if c_compiler and c_compiler.compiler_type == "msvc":
                if "gcc" in opt:
                    i = opt.index("gcc"***REMOVED***
                    opt.insert(i+1, "mingwex"***REMOVED***
                    opt.insert(i+1, "mingw32"***REMOVED***
            # XXX: fix this mess, does not work for mingw
            if is_win64(***REMOVED***:
                c_compiler = self.c_compiler
                if c_compiler and c_compiler.compiler_type == "msvc":
                    return [***REMOVED***
                else:
                    pass
        return opt

    def get_target(self***REMOVED***:
        status, output = exec_command(self.compiler_f77 +
                                      ['-v'***REMOVED***,
                                      use_tee=0***REMOVED***
        if not status:
            m = TARGET_R.search(output***REMOVED***
            if m:
                return m.group(1***REMOVED***
        return ""

    def get_flags_opt(self***REMOVED***:
        if is_win64(***REMOVED***:
            return ['-O0'***REMOVED***
        else:
            return GnuFCompiler.get_flags_opt(self***REMOVED***

def _can_target(cmd, arch***REMOVED***:
    ***REMOVED***Return true if the architecture supports the -arch flag***REMOVED***
    newcmd = cmd[:***REMOVED***
    fid, filename = tempfile.mkstemp(suffix=".f"***REMOVED***
    ***REMOVED***
        d = os.path.dirname(filename***REMOVED***
        output = os.path.splitext(filename***REMOVED***[0***REMOVED*** + ".o"
        ***REMOVED***
            newcmd.extend(["-arch", arch, "-c", filename***REMOVED******REMOVED***
            p = Popen(newcmd, stderr=STDOUT, stdout=PIPE, cwd=d***REMOVED***
            p.communicate(***REMOVED***
            return p.returncode == 0
        finally:
            if os.path.exists(output***REMOVED***:
                os.remove(output***REMOVED***
    finally:
        os.remove(filename***REMOVED***
    return False

if __name__ == '__main__':
    from distutils import log
    log.set_verbosity(2***REMOVED***

    compiler = GnuFCompiler(***REMOVED***
    compiler.customize(***REMOVED***
    print(compiler.get_version(***REMOVED******REMOVED***

    ***REMOVED***
        compiler = Gnu95FCompiler(***REMOVED***
        compiler.customize(***REMOVED***
        print(compiler.get_version(***REMOVED******REMOVED***
    except Exception:
        msg = get_exception(***REMOVED***
        print(msg***REMOVED***
