***REMOVED***numpy.distutils.fcompiler

Contains FCompiler, an abstract base class that defines the interface
for the numpy.distutils Fortran compiler abstraction model.

Terminology:

To be consistent, where the term 'executable' is used, it means the single
file, like 'gcc', that is executed, and should be a string. In contrast,
'command' means the entire command line, like ['gcc', '-c', 'file.c'***REMOVED***, and
should be a list.

But note that FCompiler.executables is actually a dictionary of commands.

***REMOVED***
from __future__ import division, absolute_import, print_function

__all__ = ['FCompiler', 'new_fcompiler', 'show_fcompilers',
           'dummy_fortran_file'***REMOVED***

***REMOVED***
import sys
import re
import types
***REMOVED***
    set
except NameError:
    from sets import Set as set

from numpy.compat import open_latin1

from distutils.sysconfig import get_python_lib
from distutils.fancy_getopt import FancyGetopt
from distutils.errors import DistutilsModuleError, \
     DistutilsExecError, CompileError, LinkError, DistutilsPlatformError
from distutils.util import split_quoted, strtobool

from numpy.distutils.ccompiler import CCompiler, gen_lib_options
from numpy.distutils import log
from numpy.distutils.misc_util import is_string, all_strings, is_sequence, \
    make_temp_file, get_shared_lib_extension
from numpy.distutils.environment import EnvironmentConfig
from numpy.distutils.exec_command import find_executable
from numpy.distutils.compat import get_exception

__metaclass__ = type

class CompilerNotFound(Exception***REMOVED***:
    pass

def flaglist(s***REMOVED***:
    if is_string(s***REMOVED***:
        return split_quoted(s***REMOVED***
    else:
        return s

def str2bool(s***REMOVED***:
    if is_string(s***REMOVED***:
        return strtobool(s***REMOVED***
    return bool(s***REMOVED***

def is_sequence_of_strings(seq***REMOVED***:
    return is_sequence(seq***REMOVED*** and all_strings(seq***REMOVED***

class FCompiler(CCompiler***REMOVED***:
    ***REMOVED***Abstract base class to define the interface that must be implemented
    by real Fortran compiler classes.

    Methods that subclasses may redefine:

        update_executables(***REMOVED***, find_executables(***REMOVED***, get_version(***REMOVED***
        get_flags(***REMOVED***, get_flags_opt(***REMOVED***, get_flags_arch(***REMOVED***, get_flags_debug(***REMOVED***
        get_flags_f77(***REMOVED***, get_flags_opt_f77(***REMOVED***, get_flags_arch_f77(***REMOVED***,
        get_flags_debug_f77(***REMOVED***, get_flags_f90(***REMOVED***, get_flags_opt_f90(***REMOVED***,
        get_flags_arch_f90(***REMOVED***, get_flags_debug_f90(***REMOVED***,
        get_flags_fix(***REMOVED***, get_flags_linker_so(***REMOVED***

    DON'T call these methods (except get_version***REMOVED*** after
    constructing a compiler instance or inside any other method.
    All methods, except update_executables(***REMOVED*** and find_executables(***REMOVED***,
    may call the get_version(***REMOVED*** method.

    After constructing a compiler instance, always call customize(dist=None***REMOVED***
    method that finalizes compiler construction and makes the following
    attributes available:
      compiler_f77
      compiler_f90
      compiler_fix
      linker_so
      archiver
      ranlib
      libraries
      library_dirs
    ***REMOVED***

    # These are the environment variables and distutils keys used.
    # Each configuration descripition is
    # (<hook name>, <environment variable>, <key in distutils.cfg>, <convert>***REMOVED***
    # The hook names are handled by the self._environment_hook method.
    #  - names starting with 'self.' call methods in this class
    #  - names starting with 'exe.' return the key in the executables dict
    #  - names like 'flags.YYY' return self.get_flag_YYY(***REMOVED***
    # convert is either None or a function to convert a string to the
    # appropiate type used.

    distutils_vars = EnvironmentConfig(
        distutils_section='config_fc',
        noopt = (None, None, 'noopt', str2bool***REMOVED***,
        noarch = (None, None, 'noarch', str2bool***REMOVED***,
        debug = (None, None, 'debug', str2bool***REMOVED***,
        verbose = (None, None, 'verbose', str2bool***REMOVED***,
    ***REMOVED***

    command_vars = EnvironmentConfig(
        distutils_section='config_fc',
        compiler_f77 = ('exe.compiler_f77', 'F77', 'f77exec', None***REMOVED***,
        compiler_f90 = ('exe.compiler_f90', 'F90', 'f90exec', None***REMOVED***,
        compiler_fix = ('exe.compiler_fix', 'F90', 'f90exec', None***REMOVED***,
        version_cmd = ('exe.version_cmd', None, None, None***REMOVED***,
        linker_so = ('exe.linker_so', 'LDSHARED', 'ldshared', None***REMOVED***,
        linker_exe = ('exe.linker_exe', 'LD', 'ld', None***REMOVED***,
        archiver = (None, 'AR', 'ar', None***REMOVED***,
        ranlib = (None, 'RANLIB', 'ranlib', None***REMOVED***,
    ***REMOVED***

    flag_vars = EnvironmentConfig(
        distutils_section='config_fc',
        f77 = ('flags.f77', 'F77FLAGS', 'f77flags', flaglist***REMOVED***,
        f90 = ('flags.f90', 'F90FLAGS', 'f90flags', flaglist***REMOVED***,
        free = ('flags.free', 'FREEFLAGS', 'freeflags', flaglist***REMOVED***,
        fix = ('flags.fix', None, None, flaglist***REMOVED***,
        opt = ('flags.opt', 'FOPT', 'opt', flaglist***REMOVED***,
        opt_f77 = ('flags.opt_f77', None, None, flaglist***REMOVED***,
        opt_f90 = ('flags.opt_f90', None, None, flaglist***REMOVED***,
        arch = ('flags.arch', 'FARCH', 'arch', flaglist***REMOVED***,
        arch_f77 = ('flags.arch_f77', None, None, flaglist***REMOVED***,
        arch_f90 = ('flags.arch_f90', None, None, flaglist***REMOVED***,
        debug = ('flags.debug', 'FDEBUG', 'fdebug', flaglist***REMOVED***,
        debug_f77 = ('flags.debug_f77', None, None, flaglist***REMOVED***,
        debug_f90 = ('flags.debug_f90', None, None, flaglist***REMOVED***,
        flags = ('self.get_flags', 'FFLAGS', 'fflags', flaglist***REMOVED***,
        linker_so = ('flags.linker_so', 'LDFLAGS', 'ldflags', flaglist***REMOVED***,
        linker_exe = ('flags.linker_exe', 'LDFLAGS', 'ldflags', flaglist***REMOVED***,
        ar = ('flags.ar', 'ARFLAGS', 'arflags', flaglist***REMOVED***,
    ***REMOVED***

    language_map = {'.f': 'f77',
                    '.for': 'f77',
                    '.F': 'f77',    # XXX: needs preprocessor
                    '.ftn': 'f77',
                    '.f77': 'f77',
                    '.f90': 'f90',
                    '.F90': 'f90',  # XXX: needs preprocessor
                    '.f95': 'f90',
                ***REMOVED***
    language_order = ['f90', 'f77'***REMOVED***


    # These will be set by the subclass

    compiler_type = None
    compiler_aliases = (***REMOVED***
    version_pattern = None

    possible_executables = [***REMOVED***
    executables = {
        'version_cmd': ["f77", "-v"***REMOVED***,
        'compiler_f77': ["f77"***REMOVED***,
        'compiler_f90': ["f90"***REMOVED***,
        'compiler_fix': ["f90", "-fixed"***REMOVED***,
        'linker_so': ["f90", "-shared"***REMOVED***,
        'linker_exe': ["f90"***REMOVED***,
        'archiver': ["ar", "-cr"***REMOVED***,
        'ranlib': None,
    ***REMOVED***

    # If compiler does not support compiling Fortran 90 then it can
    # suggest using another compiler. For example, gnu would suggest
    # gnu95 compiler type when there are F90 sources.
    suggested_f90_compiler = None

    compile_switch = "-c"
    object_switch = "-o "   # Ending space matters! It will be stripped
                            # but if it is missing then object_switch
                            # will be prefixed to object file name by
                            # string concatenation.
    library_switch = "-o "  # Ditto!

    # Switch to specify where module files are created and searched
    # for USE statement.  Normally it is a string and also here ending
    # space matters. See above.
    module_dir_switch = None

    # Switch to specify where module files are searched for USE statement.
    module_include_switch = '-I'

    pic_flags = [***REMOVED***           # Flags to create position-independent code

    src_extensions = ['.for', '.ftn', '.f77', '.f', '.f90', '.f95', '.F', '.F90', '.FOR'***REMOVED***
    obj_extension = ".o"

    shared_lib_extension = get_shared_lib_extension(***REMOVED***
    static_lib_extension = ".a"  # or .lib
    static_lib_format = "lib%s%s" # or %s%s
    shared_lib_format = "%s%s"
    exe_extension = ""

    _exe_cache = {***REMOVED***

    _executable_keys = ['version_cmd', 'compiler_f77', 'compiler_f90',
                        'compiler_fix', 'linker_so', 'linker_exe', 'archiver',
                        'ranlib'***REMOVED***

    # This will be set by new_fcompiler when called in
    # command/{build_ext.py, build_clib.py, config.py***REMOVED*** files.
    c_compiler = None

    # extra_{f77,f90***REMOVED***_compile_args are set by build_ext.build_extension method
    extra_f77_compile_args = [***REMOVED***
    extra_f90_compile_args = [***REMOVED***

    def __init__(self, *args, **kw***REMOVED***:
        CCompiler.__init__(self, *args, **kw***REMOVED***
        self.distutils_vars = self.distutils_vars.clone(self._environment_hook***REMOVED***
        self.command_vars = self.command_vars.clone(self._environment_hook***REMOVED***
        self.flag_vars = self.flag_vars.clone(self._environment_hook***REMOVED***
        self.executables = self.executables.copy(***REMOVED***
        for e in self._executable_keys:
            if e not in self.executables:
                self.executables[e***REMOVED*** = None

        # Some methods depend on .customize(***REMOVED*** being called first, so
        # this keeps track of whether that's happened yet.
        self._is_customised = False

    def __copy__(self***REMOVED***:
        obj = self.__new__(self.__class__***REMOVED***
        obj.__dict__.update(self.__dict__***REMOVED***
        obj.distutils_vars = obj.distutils_vars.clone(obj._environment_hook***REMOVED***
        obj.command_vars = obj.command_vars.clone(obj._environment_hook***REMOVED***
        obj.flag_vars = obj.flag_vars.clone(obj._environment_hook***REMOVED***
        obj.executables = obj.executables.copy(***REMOVED***
        return obj

    def copy(self***REMOVED***:
        return self.__copy__(***REMOVED***

    # Use properties for the attributes used by CCompiler. Setting them
    # as attributes from the self.executables dictionary is error-prone,
    # so we get them from there each time.
    def _command_property(key***REMOVED***:
        def fget(self***REMOVED***:
            assert self._is_customised
            return self.executables[key***REMOVED***
        return property(fget=fget***REMOVED***
    version_cmd = _command_property('version_cmd'***REMOVED***
    compiler_f77 = _command_property('compiler_f77'***REMOVED***
    compiler_f90 = _command_property('compiler_f90'***REMOVED***
    compiler_fix = _command_property('compiler_fix'***REMOVED***
    linker_so = _command_property('linker_so'***REMOVED***
    linker_exe = _command_property('linker_exe'***REMOVED***
    archiver = _command_property('archiver'***REMOVED***
    ranlib = _command_property('ranlib'***REMOVED***

    # Make our terminology consistent.
    def set_executable(self, key, value***REMOVED***:
        self.set_command(key, value***REMOVED***

    def set_commands(self, **kw***REMOVED***:
        for k, v in kw.items(***REMOVED***:
            self.set_command(k, v***REMOVED***

    def set_command(self, key, value***REMOVED***:
        if not key in self._executable_keys:
            raise ValueError(
                "unknown executable '%s' for class %s" %
                (key, self.__class__.__name__***REMOVED******REMOVED***
        if is_string(value***REMOVED***:
            value = split_quoted(value***REMOVED***
        assert value is None or is_sequence_of_strings(value[1:***REMOVED******REMOVED***, (key, value***REMOVED***
        self.executables[key***REMOVED*** = value

    ######################################################################
    ## Methods that subclasses may redefine. But don't call these methods!
    ## They are private to FCompiler class and may return unexpected
    ## results if used elsewhere. So, you have been warned..

    def find_executables(self***REMOVED***:
        ***REMOVED***Go through the self.executables dictionary, and attempt to
        find and assign appropiate executables.

        Executable names are looked for in the environment (environment
        variables, the distutils.cfg, and command line***REMOVED***, the 0th-element of
        the command list, and the self.possible_executables list.

        Also, if the 0th element is "<F77>" or "<F90>", the Fortran 77
        or the Fortran 90 compiler executable is used, unless overridden
        by an environment setting.

        Subclasses should call this if overriden.
        ***REMOVED***
        assert self._is_customised
        exe_cache = self._exe_cache
        def cached_find_executable(exe***REMOVED***:
            if exe in exe_cache:
                return exe_cache[exe***REMOVED***
            fc_exe = find_executable(exe***REMOVED***
            exe_cache[exe***REMOVED*** = exe_cache[fc_exe***REMOVED*** = fc_exe
            return fc_exe
        def verify_command_form(name, value***REMOVED***:
            if value is not None and not is_sequence_of_strings(value***REMOVED***:
                raise ValueError(
                    "%s value %r is invalid in class %s" %
                    (name, value, self.__class__.__name__***REMOVED******REMOVED***
        def set_exe(exe_key, f77=None, f90=None***REMOVED***:
            cmd = self.executables.get(exe_key, None***REMOVED***
            if not cmd:
                return None
            # Note that we get cmd[0***REMOVED*** here if the environment doesn't
            # have anything set
            exe_from_environ = getattr(self.command_vars, exe_key***REMOVED***
            if not exe_from_environ:
                possibles = [f90, f77***REMOVED*** + self.possible_executables
            else:
                possibles = [exe_from_environ***REMOVED*** + self.possible_executables

            seen = set(***REMOVED***
            unique_possibles = [***REMOVED***
            for e in possibles:
                if e == '<F77>':
                    e = f77
                elif e == '<F90>':
                    e = f90
                if not e or e in seen:
                    continue
                seen.add(e***REMOVED***
                unique_possibles.append(e***REMOVED***

            for exe in unique_possibles:
                fc_exe = cached_find_executable(exe***REMOVED***
                if fc_exe:
                    cmd[0***REMOVED*** = fc_exe
                    return fc_exe
            self.set_command(exe_key, None***REMOVED***
            return None

        ctype = self.compiler_type
        f90 = set_exe('compiler_f90'***REMOVED***
        if not f90:
            f77 = set_exe('compiler_f77'***REMOVED***
            if f77:
                log.warn('%s: no Fortran 90 compiler found' % ctype***REMOVED***
            else:
                raise CompilerNotFound('%s: f90 nor f77' % ctype***REMOVED***
        else:
            f77 = set_exe('compiler_f77', f90=f90***REMOVED***
            if not f77:
                log.warn('%s: no Fortran 77 compiler found' % ctype***REMOVED***
            set_exe('compiler_fix', f90=f90***REMOVED***

        set_exe('linker_so', f77=f77, f90=f90***REMOVED***
        set_exe('linker_exe', f77=f77, f90=f90***REMOVED***
        set_exe('version_cmd', f77=f77, f90=f90***REMOVED***
        set_exe('archiver'***REMOVED***
        set_exe('ranlib'***REMOVED***

    def update_executables(elf***REMOVED***:
        ***REMOVED***Called at the beginning of customisation. Subclasses should
        override this if they need to set up the executables dictionary.

        Note that self.find_executables(***REMOVED*** is run afterwards, so the
        self.executables dictionary values can contain <F77> or <F90> as
        the command, which will be replaced by the found F77 or F90
        compiler.
        ***REMOVED***
        pass

    def get_flags(self***REMOVED***:
        ***REMOVED***List of flags common to all compiler types.***REMOVED***
        return [***REMOVED*** + self.pic_flags

    def _get_command_flags(self, key***REMOVED***:
        cmd = self.executables.get(key, None***REMOVED***
        if cmd is None:
            return [***REMOVED***
        return cmd[1:***REMOVED***

    def get_flags_f77(self***REMOVED***:
        ***REMOVED***List of Fortran 77 specific flags.***REMOVED***
        return self._get_command_flags('compiler_f77'***REMOVED***
    def get_flags_f90(self***REMOVED***:
        ***REMOVED***List of Fortran 90 specific flags.***REMOVED***
        return self._get_command_flags('compiler_f90'***REMOVED***
    def get_flags_free(self***REMOVED***:
        ***REMOVED***List of Fortran 90 free format specific flags.***REMOVED***
        return [***REMOVED***
    def get_flags_fix(self***REMOVED***:
        ***REMOVED***List of Fortran 90 fixed format specific flags.***REMOVED***
        return self._get_command_flags('compiler_fix'***REMOVED***
    def get_flags_linker_so(self***REMOVED***:
        ***REMOVED***List of linker flags to build a shared library.***REMOVED***
        return self._get_command_flags('linker_so'***REMOVED***
    def get_flags_linker_exe(self***REMOVED***:
        ***REMOVED***List of linker flags to build an executable.***REMOVED***
        return self._get_command_flags('linker_exe'***REMOVED***
    def get_flags_ar(self***REMOVED***:
        ***REMOVED***List of archiver flags. ***REMOVED***
        return self._get_command_flags('archiver'***REMOVED***
    def get_flags_opt(self***REMOVED***:
        ***REMOVED***List of architecture independent compiler flags.***REMOVED***
        return [***REMOVED***
    def get_flags_arch(self***REMOVED***:
        ***REMOVED***List of architecture dependent compiler flags.***REMOVED***
        return [***REMOVED***
    def get_flags_debug(self***REMOVED***:
        ***REMOVED***List of compiler flags to compile with debugging information.***REMOVED***
        return [***REMOVED***

    get_flags_opt_f77 = get_flags_opt_f90 = get_flags_opt
    get_flags_arch_f77 = get_flags_arch_f90 = get_flags_arch
    get_flags_debug_f77 = get_flags_debug_f90 = get_flags_debug

    def get_libraries(self***REMOVED***:
        ***REMOVED***List of compiler libraries.***REMOVED***
        return self.libraries[:***REMOVED***
    def get_library_dirs(self***REMOVED***:
        ***REMOVED***List of compiler library directories.***REMOVED***
        return self.library_dirs[:***REMOVED***

    def get_version(self, force=False, ok_status=[0***REMOVED******REMOVED***:
        assert self._is_customised
        version = CCompiler.get_version(self, force=force, ok_status=ok_status***REMOVED***
        if version is None:
            raise CompilerNotFound(***REMOVED***
        return version

    ############################################################

    ## Public methods:

    def customize(self, dist = None***REMOVED***:
        ***REMOVED***Customize Fortran compiler.

        This method gets Fortran compiler specific information from
        (i***REMOVED*** class definition, (ii***REMOVED*** environment, (iii***REMOVED*** distutils config
        files, and (iv***REMOVED*** command line (later overrides earlier***REMOVED***.

        This method should be always called after constructing a
        compiler instance. But not in __init__ because Distribution
        instance is needed for (iii***REMOVED*** and (iv***REMOVED***.
        ***REMOVED***
        log.info('customize %s' % (self.__class__.__name__***REMOVED******REMOVED***

        self._is_customised = True

        self.distutils_vars.use_distribution(dist***REMOVED***
        self.command_vars.use_distribution(dist***REMOVED***
        self.flag_vars.use_distribution(dist***REMOVED***

        self.update_executables(***REMOVED***

        # find_executables takes care of setting the compiler commands,
        # version_cmd, linker_so, linker_exe, ar, and ranlib
        self.find_executables(***REMOVED***

        noopt = self.distutils_vars.get('noopt', False***REMOVED***
        noarch = self.distutils_vars.get('noarch', noopt***REMOVED***
        debug = self.distutils_vars.get('debug', False***REMOVED***

        f77 = self.command_vars.compiler_f77
        f90 = self.command_vars.compiler_f90

        f77flags = [***REMOVED***
        f90flags = [***REMOVED***
        freeflags = [***REMOVED***
        fixflags = [***REMOVED***

        if f77:
            f77flags = self.flag_vars.f77
        if f90:
            f90flags = self.flag_vars.f90
            freeflags = self.flag_vars.free
        # XXX Assuming that free format is default for f90 compiler.
        fix = self.command_vars.compiler_fix
        if fix:
            fixflags = self.flag_vars.fix + f90flags

        oflags, aflags, dflags = [***REMOVED***, [***REMOVED***, [***REMOVED***
        # examine get_flags_<tag>_<compiler> for extra flags
        # only add them if the method is different from get_flags_<tag>
        def get_flags(tag, flags***REMOVED***:
            # note that self.flag_vars.<tag> calls self.get_flags_<tag>(***REMOVED***
            flags.extend(getattr(self.flag_vars, tag***REMOVED******REMOVED***
            this_get = getattr(self, 'get_flags_' + tag***REMOVED***
            for name, c, flagvar in [('f77', f77, f77flags***REMOVED***,
                                     ('f90', f90, f90flags***REMOVED***,
                                     ('f90', fix, fixflags***REMOVED******REMOVED***:
                t = '%s_%s' % (tag, name***REMOVED***
                if c and this_get is not getattr(self, 'get_flags_' + t***REMOVED***:
                    flagvar.extend(getattr(self.flag_vars, t***REMOVED******REMOVED***
        if not noopt:
            get_flags('opt', oflags***REMOVED***
            if not noarch:
                get_flags('arch', aflags***REMOVED***
        if debug:
            get_flags('debug', dflags***REMOVED***

        fflags = self.flag_vars.flags + dflags + oflags + aflags

        if f77:
            self.set_commands(compiler_f77=[f77***REMOVED***+f77flags+fflags***REMOVED***
        if f90:
            self.set_commands(compiler_f90=[f90***REMOVED***+freeflags+f90flags+fflags***REMOVED***
        if fix:
            self.set_commands(compiler_fix=[fix***REMOVED***+fixflags+fflags***REMOVED***


        #XXX: Do we need LDSHARED->SOSHARED, LDFLAGS->SOFLAGS
        linker_so = self.linker_so
        if linker_so:
            linker_so_flags = self.flag_vars.linker_so
            if sys.platform.startswith('aix'***REMOVED***:
                python_lib = get_python_lib(standard_lib=1***REMOVED***
                ld_so_aix = os.path.join(python_lib, 'config', 'ld_so_aix'***REMOVED***
                python_exp = os.path.join(python_lib, 'config', 'python.exp'***REMOVED***
                linker_so = [ld_so_aix***REMOVED*** + linker_so + ['-bI:'+python_exp***REMOVED***
            self.set_commands(linker_so=linker_so+linker_so_flags***REMOVED***

        linker_exe = self.linker_exe
        if linker_exe:
            linker_exe_flags = self.flag_vars.linker_exe
            self.set_commands(linker_exe=linker_exe+linker_exe_flags***REMOVED***

        ar = self.command_vars.archiver
        if ar:
            arflags = self.flag_vars.ar
            self.set_commands(archiver=[ar***REMOVED***+arflags***REMOVED***

        self.set_library_dirs(self.get_library_dirs(***REMOVED******REMOVED***
        self.set_libraries(self.get_libraries(***REMOVED******REMOVED***

    def dump_properties(self***REMOVED***:
        ***REMOVED***Print out the attributes of a compiler instance.***REMOVED***
        props = [***REMOVED***
        for key in list(self.executables.keys(***REMOVED******REMOVED*** + \
                ['version', 'libraries', 'library_dirs',
                 'object_switch', 'compile_switch'***REMOVED***:
            if hasattr(self, key***REMOVED***:
                v = getattr(self, key***REMOVED***
                props.append((key, None, '= '+repr(v***REMOVED******REMOVED******REMOVED***
        props.sort(***REMOVED***

        pretty_printer = FancyGetopt(props***REMOVED***
        for l in pretty_printer.generate_help("%s instance properties:" \
                                              % (self.__class__.__name__***REMOVED******REMOVED***:
            if l[:4***REMOVED***=='  --':
                l = '  ' + l[4:***REMOVED***
            print(l***REMOVED***

    ###################

    def _compile(self, obj, src, ext, cc_args, extra_postargs, pp_opts***REMOVED***:
        ***REMOVED***Compile 'src' to product 'obj'.***REMOVED***
        src_flags = {***REMOVED***
        if is_f_file(src***REMOVED*** and not has_f90_header(src***REMOVED***:
            flavor = ':f77'
            compiler = self.compiler_f77
            src_flags = get_f77flags(src***REMOVED***
            extra_compile_args = self.extra_f77_compile_args or [***REMOVED***
        elif is_free_format(src***REMOVED***:
            flavor = ':f90'
            compiler = self.compiler_f90
            if compiler is None:
                raise DistutilsExecError('f90 not supported by %s needed for %s'\
                      % (self.__class__.__name__, src***REMOVED******REMOVED***
            extra_compile_args = self.extra_f90_compile_args or [***REMOVED***
        else:
            flavor = ':fix'
            compiler = self.compiler_fix
            if compiler is None:
                raise DistutilsExecError('f90 (fixed***REMOVED*** not supported by %s needed for %s'\
                      % (self.__class__.__name__, src***REMOVED******REMOVED***
            extra_compile_args = self.extra_f90_compile_args or [***REMOVED***
        if self.object_switch[-1***REMOVED***==' ':
            o_args = [self.object_switch.strip(***REMOVED***, obj***REMOVED***
        else:
            o_args = [self.object_switch.strip(***REMOVED***+obj***REMOVED***

        assert self.compile_switch.strip(***REMOVED***
        s_args = [self.compile_switch, src***REMOVED***

        if extra_compile_args:
            log.info('extra %s options: %r' \
                     % (flavor[1:***REMOVED***, ' '.join(extra_compile_args***REMOVED******REMOVED******REMOVED***

        extra_flags = src_flags.get(self.compiler_type, [***REMOVED******REMOVED***
        if extra_flags:
            log.info('using compile options from source: %r' \
                     % ' '.join(extra_flags***REMOVED******REMOVED***

        command = compiler + cc_args + extra_flags + s_args + o_args \
                  + extra_postargs + extra_compile_args

        display = '%s: %s' % (os.path.basename(compiler[0***REMOVED******REMOVED*** + flavor,
                              src***REMOVED***
        ***REMOVED***
            self.spawn(command, display=display***REMOVED***
        except DistutilsExecError:
            msg = str(get_exception(***REMOVED******REMOVED***
            raise CompileError(msg***REMOVED***

    def module_options(self, module_dirs, module_build_dir***REMOVED***:
        options = [***REMOVED***
        if self.module_dir_switch is not None:
            if self.module_dir_switch[-1***REMOVED***==' ':
                options.extend([self.module_dir_switch.strip(***REMOVED***, module_build_dir***REMOVED******REMOVED***
            else:
                options.append(self.module_dir_switch.strip(***REMOVED***+module_build_dir***REMOVED***
        else:
            print('XXX: module_build_dir=%r option ignored' % (module_build_dir***REMOVED******REMOVED***
            print('XXX: Fix module_dir_switch for ', self.__class__.__name__***REMOVED***
        if self.module_include_switch is not None:
            for d in [module_build_dir***REMOVED***+module_dirs:
                options.append('%s%s' % (self.module_include_switch, d***REMOVED******REMOVED***
        else:
            print('XXX: module_dirs=%r option ignored' % (module_dirs***REMOVED******REMOVED***
            print('XXX: Fix module_include_switch for ', self.__class__.__name__***REMOVED***
        return options

    def library_option(self, lib***REMOVED***:
        return "-l" + lib
    def library_dir_option(self, dir***REMOVED***:
        return "-L" + dir

    def link(self, target_desc, objects,
             output_filename, output_dir=None, libraries=None,
             library_dirs=None, runtime_library_dirs=None,
             export_symbols=None, debug=0, extra_preargs=None,
             extra_postargs=None, build_temp=None, target_lang=None***REMOVED***:
        objects, output_dir = self._fix_object_args(objects, output_dir***REMOVED***
        libraries, library_dirs, runtime_library_dirs = \
            self._fix_lib_args(libraries, library_dirs, runtime_library_dirs***REMOVED***

        lib_opts = gen_lib_options(self, library_dirs, runtime_library_dirs,
                                   libraries***REMOVED***
        if is_string(output_dir***REMOVED***:
            output_filename = os.path.join(output_dir, output_filename***REMOVED***
        elif output_dir is not None:
            raise TypeError("'output_dir' must be a string or None"***REMOVED***

        if self._need_link(objects, output_filename***REMOVED***:
            if self.library_switch[-1***REMOVED***==' ':
                o_args = [self.library_switch.strip(***REMOVED***, output_filename***REMOVED***
            else:
                o_args = [self.library_switch.strip(***REMOVED***+output_filename***REMOVED***

            if is_string(self.objects***REMOVED***:
                ld_args = objects + [self.objects***REMOVED***
            else:
                ld_args = objects + self.objects
            ld_args = ld_args + lib_opts + o_args
            if debug:
                ld_args[:0***REMOVED*** = ['-g'***REMOVED***
            if extra_preargs:
                ld_args[:0***REMOVED*** = extra_preargs
            if extra_postargs:
                ld_args.extend(extra_postargs***REMOVED***
            self.mkpath(os.path.dirname(output_filename***REMOVED******REMOVED***
            if target_desc == CCompiler.EXECUTABLE:
                linker = self.linker_exe[:***REMOVED***
            else:
                linker = self.linker_so[:***REMOVED***
            command = linker + ld_args
            ***REMOVED***
                self.spawn(command***REMOVED***
            except DistutilsExecError:
                msg = str(get_exception(***REMOVED******REMOVED***
                raise LinkError(msg***REMOVED***
        else:
            log.debug("skipping %s (up-to-date***REMOVED***", output_filename***REMOVED***

    def _environment_hook(self, name, hook_name***REMOVED***:
        if hook_name is None:
            return None
        if is_string(hook_name***REMOVED***:
            if hook_name.startswith('self.'***REMOVED***:
                hook_name = hook_name[5:***REMOVED***
                hook = getattr(self, hook_name***REMOVED***
                return hook(***REMOVED***
            elif hook_name.startswith('exe.'***REMOVED***:
                hook_name = hook_name[4:***REMOVED***
                var = self.executables[hook_name***REMOVED***
                if var:
                    return var[0***REMOVED***
                else:
                    return None
            elif hook_name.startswith('flags.'***REMOVED***:
                hook_name = hook_name[6:***REMOVED***
                hook = getattr(self, 'get_flags_' + hook_name***REMOVED***
                return hook(***REMOVED***
        else:
            return hook_name(***REMOVED***

    ## class FCompiler

_default_compilers = (
    # sys.platform mappings
    ('win32', ('gnu', 'intelv', 'absoft', 'compaqv', 'intelev', 'gnu95', 'g95',
               'intelvem', 'intelem'***REMOVED******REMOVED***,
    ('cygwin.*', ('gnu', 'intelv', 'absoft', 'compaqv', 'intelev', 'gnu95', 'g95'***REMOVED******REMOVED***,
    ('linux.*', ('gnu95', 'intel', 'lahey', 'pg', 'absoft', 'nag', 'vast', 'compaq',
                'intele', 'intelem', 'gnu', 'g95', 'pathf95'***REMOVED******REMOVED***,
    ('darwin.*', ('gnu95', 'nag', 'absoft', 'ibm', 'intel', 'gnu', 'g95', 'pg'***REMOVED******REMOVED***,
    ('sunos.*', ('sun', 'gnu', 'gnu95', 'g95'***REMOVED******REMOVED***,
    ('irix.*', ('mips', 'gnu', 'gnu95',***REMOVED******REMOVED***,
    ('aix.*', ('ibm', 'gnu', 'gnu95',***REMOVED******REMOVED***,
    # os.name mappings
    ('posix', ('gnu', 'gnu95',***REMOVED******REMOVED***,
    ('nt', ('gnu', 'gnu95',***REMOVED******REMOVED***,
    ('mac', ('gnu95', 'gnu', 'pg'***REMOVED******REMOVED***,
    ***REMOVED***

fcompiler_class = None
fcompiler_aliases = None

def load_all_fcompiler_classes(***REMOVED***:
    ***REMOVED***Cache all the FCompiler classes found in modules in the
    numpy.distutils.fcompiler package.
    ***REMOVED***
    from glob import glob
    global fcompiler_class, fcompiler_aliases
    if fcompiler_class is not None:
        return
    pys = os.path.join(os.path.dirname(__file__***REMOVED***, '*.py'***REMOVED***
    fcompiler_class = {***REMOVED***
    fcompiler_aliases = {***REMOVED***
    for fname in glob(pys***REMOVED***:
        module_name, ext = os.path.splitext(os.path.basename(fname***REMOVED******REMOVED***
        module_name = 'numpy.distutils.fcompiler.' + module_name
        __import__ (module_name***REMOVED***
        module = sys.modules[module_name***REMOVED***
        if hasattr(module, 'compilers'***REMOVED***:
            for cname in module.compilers:
                klass = getattr(module, cname***REMOVED***
                desc = (klass.compiler_type, klass, klass.description***REMOVED***
                fcompiler_class[klass.compiler_type***REMOVED*** = desc
                for alias in klass.compiler_aliases:
                    if alias in fcompiler_aliases:
                        raise ValueError("alias %r defined for both %s and %s"
                                         % (alias, klass.__name__,
                                            fcompiler_aliases[alias***REMOVED***[1***REMOVED***.__name__***REMOVED******REMOVED***
                    fcompiler_aliases[alias***REMOVED*** = desc

def _find_existing_fcompiler(compiler_types,
                             osname=None, platform=None,
                             requiref90=False,
                             c_compiler=None***REMOVED***:
    from numpy.distutils.core import get_distribution
    dist = get_distribution(always=True***REMOVED***
    for compiler_type in compiler_types:
        v = None
        ***REMOVED***
            c = new_fcompiler(plat=platform, compiler=compiler_type,
                              c_compiler=c_compiler***REMOVED***
            c.customize(dist***REMOVED***
            v = c.get_version(***REMOVED***
            if requiref90 and c.compiler_f90 is None:
                v = None
                new_compiler = c.suggested_f90_compiler
                if new_compiler:
                    log.warn('Trying %r compiler as suggested by %r '
                             'compiler for f90 support.' % (compiler_type,
                                                            new_compiler***REMOVED******REMOVED***
                    c = new_fcompiler(plat=platform, compiler=new_compiler,
                                      c_compiler=c_compiler***REMOVED***
                    c.customize(dist***REMOVED***
                    v = c.get_version(***REMOVED***
                    if v is not None:
                        compiler_type = new_compiler
            if requiref90 and c.compiler_f90 is None:
                raise ValueError('%s does not support compiling f90 codes, '
                                 'skipping.' % (c.__class__.__name__***REMOVED******REMOVED***
        except DistutilsModuleError:
            log.debug("_find_existing_fcompiler: compiler_type='%s' raised DistutilsModuleError", compiler_type***REMOVED***
        except CompilerNotFound:
            log.debug("_find_existing_fcompiler: compiler_type='%s' not found", compiler_type***REMOVED***
        if v is not None:
            return compiler_type
    return None

def available_fcompilers_for_platform(osname=None, platform=None***REMOVED***:
    if osname is None:
        osname = os.name
    if platform is None:
        platform = sys.platform
    matching_compiler_types = [***REMOVED***
    for pattern, compiler_type in _default_compilers:
        if re.match(pattern, platform***REMOVED*** or re.match(pattern, osname***REMOVED***:
            for ct in compiler_type:
                if ct not in matching_compiler_types:
                    matching_compiler_types.append(ct***REMOVED***
    if not matching_compiler_types:
        matching_compiler_types.append('gnu'***REMOVED***
    return matching_compiler_types

def get_default_fcompiler(osname=None, platform=None, requiref90=False,
                          c_compiler=None***REMOVED***:
    ***REMOVED***Determine the default Fortran compiler to use for the given
    platform.***REMOVED***
    matching_compiler_types = available_fcompilers_for_platform(osname,
                                                                platform***REMOVED***
    compiler_type =  _find_existing_fcompiler(matching_compiler_types,
                                              osname=osname,
                                              platform=platform,
                                              requiref90=requiref90,
                                              c_compiler=c_compiler***REMOVED***
    return compiler_type

# Flag to avoid rechecking for Fortran compiler every time
failed_fcompilers = set(***REMOVED***

def new_fcompiler(plat=None,
                  compiler=None,
                  verbose=0,
                  dry_run=0,
                  force=0,
                  requiref90=False,
                  c_compiler = None***REMOVED***:
    ***REMOVED***Generate an instance of some FCompiler subclass for the supplied
    platform/compiler combination.
    ***REMOVED***
    global failed_fcompilers
    fcompiler_key = (plat, compiler***REMOVED***
    if fcompiler_key in failed_fcompilers:
        return None

    load_all_fcompiler_classes(***REMOVED***
    if plat is None:
        plat = os.name
    if compiler is None:
        compiler = get_default_fcompiler(plat, requiref90=requiref90,
                                         c_compiler=c_compiler***REMOVED***
    if compiler in fcompiler_class:
        module_name, klass, long_description = fcompiler_class[compiler***REMOVED***
    elif compiler in fcompiler_aliases:
        module_name, klass, long_description = fcompiler_aliases[compiler***REMOVED***
    else:
        msg = "don't know how to compile Fortran code on platform '%s'" % plat
        if compiler is not None:
            msg = msg + " with '%s' compiler." % compiler
            msg = msg + " Supported compilers are: %s***REMOVED***" \
                  % (','.join(fcompiler_class.keys(***REMOVED******REMOVED******REMOVED***
        log.warn(msg***REMOVED***
        failed_fcompilers.add(fcompiler_key***REMOVED***
        return None

    compiler = klass(verbose=verbose, dry_run=dry_run, force=force***REMOVED***
    compiler.c_compiler = c_compiler
    return compiler

def show_fcompilers(dist=None***REMOVED***:
    ***REMOVED***Print list of available compilers (used by the "--help-fcompiler"
    option to "config_fc"***REMOVED***.
    ***REMOVED***
    if dist is None:
        from distutils.dist import Distribution
        from numpy.distutils.command.config_compiler import config_fc
        dist = Distribution(***REMOVED***
        dist.script_name = os.path.basename(sys.argv[0***REMOVED******REMOVED***
        dist.script_args = ['config_fc'***REMOVED*** + sys.argv[1:***REMOVED***
        ***REMOVED***
            dist.script_args.remove('--help-fcompiler'***REMOVED***
        except ValueError:
            pass
        dist.cmdclass['config_fc'***REMOVED*** = config_fc
        dist.parse_config_files(***REMOVED***
        dist.parse_command_line(***REMOVED***
    compilers = [***REMOVED***
    compilers_na = [***REMOVED***
    compilers_ni = [***REMOVED***
    if not fcompiler_class:
        load_all_fcompiler_classes(***REMOVED***
    platform_compilers = available_fcompilers_for_platform(***REMOVED***
    for compiler in platform_compilers:
        v = None
        log.set_verbosity(-2***REMOVED***
        ***REMOVED***
            c = new_fcompiler(compiler=compiler, verbose=dist.verbose***REMOVED***
            c.customize(dist***REMOVED***
            v = c.get_version(***REMOVED***
        except (DistutilsModuleError, CompilerNotFound***REMOVED***:
            e = get_exception(***REMOVED***
            log.debug("show_fcompilers: %s not found" % (compiler,***REMOVED******REMOVED***
            log.debug(repr(e***REMOVED******REMOVED***

        if v is None:
            compilers_na.append(("fcompiler="+compiler, None,
                              fcompiler_class[compiler***REMOVED***[2***REMOVED******REMOVED******REMOVED***
        else:
            c.dump_properties(***REMOVED***
            compilers.append(("fcompiler="+compiler, None,
                              fcompiler_class[compiler***REMOVED***[2***REMOVED*** + ' (%s***REMOVED***' % v***REMOVED******REMOVED***

    compilers_ni = list(set(fcompiler_class.keys(***REMOVED******REMOVED*** - set(platform_compilers***REMOVED******REMOVED***
    compilers_ni = [("fcompiler="+fc, None, fcompiler_class[fc***REMOVED***[2***REMOVED******REMOVED***
                    for fc in compilers_ni***REMOVED***

    compilers.sort(***REMOVED***
    compilers_na.sort(***REMOVED***
    compilers_ni.sort(***REMOVED***
    pretty_printer = FancyGetopt(compilers***REMOVED***
    pretty_printer.print_help("Fortran compilers found:"***REMOVED***
    pretty_printer = FancyGetopt(compilers_na***REMOVED***
    pretty_printer.print_help("Compilers available for this "
                              "platform, but not found:"***REMOVED***
    if compilers_ni:
        pretty_printer = FancyGetopt(compilers_ni***REMOVED***
        pretty_printer.print_help("Compilers not available on this platform:"***REMOVED***
    print("For compiler details, run 'config_fc --verbose' setup command."***REMOVED***


def dummy_fortran_file(***REMOVED***:
    fo, name = make_temp_file(suffix='.f'***REMOVED***
    fo.write("      subroutine dummy(***REMOVED***\n      end\n"***REMOVED***
    fo.close(***REMOVED***
    return name[:-2***REMOVED***


is_f_file = re.compile(r'.*[.***REMOVED***(for|ftn|f77|f***REMOVED***\Z', re.I***REMOVED***.match
_has_f_header = re.compile(r'-[****REMOVED***-\s*fortran\s*-[****REMOVED***-', re.I***REMOVED***.search
_has_f90_header = re.compile(r'-[****REMOVED***-\s*f90\s*-[****REMOVED***-', re.I***REMOVED***.search
_has_fix_header = re.compile(r'-[****REMOVED***-\s*fix\s*-[****REMOVED***-', re.I***REMOVED***.search
_free_f90_start = re.compile(r'[^c*!***REMOVED***\s*[^\s\d\t***REMOVED***', re.I***REMOVED***.match

def is_free_format(file***REMOVED***:
    ***REMOVED***Check if file is in free format Fortran.***REMOVED***
    # f90 allows both fixed and free format, assuming fixed unless
    # signs of free format are detected.
    result = 0
    f = open_latin1(file, 'r'***REMOVED***
    line = f.readline(***REMOVED***
    n = 10000 # the number of non-comment lines to scan for hints
    if _has_f_header(line***REMOVED***:
        n = 0
    elif _has_f90_header(line***REMOVED***:
        n = 0
        result = 1
    while n>0 and line:
        line = line.rstrip(***REMOVED***
        if line and line[0***REMOVED***!='!':
            n -= 1
            if (line[0***REMOVED***!='\t' and _free_f90_start(line[:5***REMOVED******REMOVED******REMOVED*** or line[-1:***REMOVED***=='&':
                result = 1
                break
        line = f.readline(***REMOVED***
    f.close(***REMOVED***
    return result

def has_f90_header(src***REMOVED***:
    f = open_latin1(src, 'r'***REMOVED***
    line = f.readline(***REMOVED***
    f.close(***REMOVED***
    return _has_f90_header(line***REMOVED*** or _has_fix_header(line***REMOVED***

_f77flags_re = re.compile(r'(c|***REMOVED***f77flags\s*\(\s*(?P<fcname>\w+***REMOVED***\s*\***REMOVED***\s*=\s*(?P<fflags>.****REMOVED***', re.I***REMOVED***
def get_f77flags(src***REMOVED***:
    ***REMOVED***
    Search the first 20 lines of fortran 77 code for line pattern
      `CF77FLAGS(<fcompiler type>***REMOVED***=<f77 flags>`
    Return a dictionary {<fcompiler type>:<f77 flags>***REMOVED***.
    ***REMOVED***
    flags = {***REMOVED***
    f = open_latin1(src, 'r'***REMOVED***
    i = 0
    for line in f:
        i += 1
        if i>20: break
        m = _f77flags_re.match(line***REMOVED***
        if not m: continue
        fcname = m.group('fcname'***REMOVED***.strip(***REMOVED***
        fflags = m.group('fflags'***REMOVED***.strip(***REMOVED***
        flags[fcname***REMOVED*** = split_quoted(fflags***REMOVED***
    f.close(***REMOVED***
    return flags

# TODO: implement get_f90flags and use it in _compile similarly to get_f77flags

if __name__ == '__main__':
    show_fcompilers(***REMOVED***
