from __future__ import division, absolute_import, print_function

import sys
import re
***REMOVED***

if sys.version_info[0***REMOVED*** < 3:
    from ConfigParser import RawConfigParser, NoOptionError
else:
    from configparser import RawConfigParser, NoOptionError

__all__ = ['FormatError', 'PkgNotFound', 'LibraryInfo', 'VariableSet',
        'read_config', 'parse_flags'***REMOVED***

_VAR = re.compile('\$\{([a-zA-Z0-9_-***REMOVED***+***REMOVED***\***REMOVED***'***REMOVED***

class FormatError(IOError***REMOVED***:
    ***REMOVED***
    Exception thrown when there is a problem parsing a configuration file.

    ***REMOVED***
    def __init__(self, msg***REMOVED***:
        self.msg = msg

    def __str__(self***REMOVED***:
        return self.msg

class PkgNotFound(IOError***REMOVED***:
    ***REMOVED***Exception raised when a package can not be located.***REMOVED***
    def __init__(self, msg***REMOVED***:
        self.msg = msg

    def __str__(self***REMOVED***:
        return self.msg

def parse_flags(line***REMOVED***:
    ***REMOVED***
    Parse a line from a config file containing compile flags.

    Parameters
    ----------
    line : str
        A single line containing one or more compile flags.

    Returns
    -------
    d : dict
        Dictionary of parsed flags, split into relevant categories.
        These categories are the keys of `d`:

        * 'include_dirs'
        * 'library_dirs'
        * 'libraries'
        * 'macros'
        * 'ignored'

    ***REMOVED***
    d = {'include_dirs': [***REMOVED***, 'library_dirs': [***REMOVED***, 'libraries': [***REMOVED***,
         'macros': [***REMOVED***, 'ignored': [***REMOVED******REMOVED***

    flags = (' ' + line***REMOVED***.split(' -'***REMOVED***
    for flag in flags:
        flag = '-' + flag
        if len(flag***REMOVED*** > 0:
            if flag.startswith('-I'***REMOVED***:
                d['include_dirs'***REMOVED***.append(flag[2:***REMOVED***.strip(***REMOVED******REMOVED***
            elif flag.startswith('-L'***REMOVED***:
                d['library_dirs'***REMOVED***.append(flag[2:***REMOVED***.strip(***REMOVED******REMOVED***
            elif flag.startswith('-l'***REMOVED***:
                d['libraries'***REMOVED***.append(flag[2:***REMOVED***.strip(***REMOVED******REMOVED***
            elif flag.startswith('-D'***REMOVED***:
                d['macros'***REMOVED***.append(flag[2:***REMOVED***.strip(***REMOVED******REMOVED***
            else:
                d['ignored'***REMOVED***.append(flag***REMOVED***

    return d

def _escape_backslash(val***REMOVED***:
    return val.replace('\\', '\\\\'***REMOVED***

class LibraryInfo(object***REMOVED***:
    ***REMOVED***
    Object containing build information about a library.

    Parameters
    ----------
    name : str
        The library name.
    description : str
        Description of the library.
    version : str
        Version string.
    sections : dict
        The sections of the configuration file for the library. The keys are
        the section headers, the values the text under each header.
    vars : class instance
        A `VariableSet` instance, which contains ``(name, value***REMOVED***`` pairs for
        variables defined in the configuration file for the library.
    requires : sequence, optional
        The required libraries for the library to be installed.

    Notes
    -----
    All input parameters (except "sections" which is a method***REMOVED*** are available as
    attributes of the same name.

    ***REMOVED***
    def __init__(self, name, description, version, sections, vars, requires=None***REMOVED***:
        self.name = name
        self.description = description
        if requires:
            self.requires = requires
        else:
            self.requires = [***REMOVED***
        self.version = version
        self._sections = sections
        self.vars = vars

    def sections(self***REMOVED***:
        ***REMOVED***
        Return the section headers of the config file.

        Parameters
        ----------
        None

        Returns
        -------
        keys : list of str
            The list of section headers.

        ***REMOVED***
        return list(self._sections.keys(***REMOVED******REMOVED***

    def cflags(self, section="default"***REMOVED***:
        val = self.vars.interpolate(self._sections[section***REMOVED***['cflags'***REMOVED******REMOVED***
        return _escape_backslash(val***REMOVED***

    def libs(self, section="default"***REMOVED***:
        val = self.vars.interpolate(self._sections[section***REMOVED***['libs'***REMOVED******REMOVED***
        return _escape_backslash(val***REMOVED***

    def __str__(self***REMOVED***:
        m = ['Name: %s' % self.name, 'Description: %s' % self.description***REMOVED***
        if self.requires:
            m.append('Requires:'***REMOVED***
        else:
            m.append('Requires: %s' % ",".join(self.requires***REMOVED******REMOVED***
        m.append('Version: %s' % self.version***REMOVED***

        return "\n".join(m***REMOVED***

class VariableSet(object***REMOVED***:
    ***REMOVED***
    Container object for the variables defined in a config file.

    `VariableSet` can be used as a plain dictionary, with the variable names
    as keys.

    Parameters
    ----------
    d : dict
        Dict of items in the "variables" section of the configuration file.

    ***REMOVED***
    def __init__(self, d***REMOVED***:
        self._raw_data = dict([(k, v***REMOVED*** for k, v in d.items(***REMOVED******REMOVED******REMOVED***

        self._re = {***REMOVED***
        self._re_sub = {***REMOVED***

        self._init_parse(***REMOVED***

    def _init_parse(self***REMOVED***:
        for k, v in self._raw_data.items(***REMOVED***:
            self._init_parse_var(k, v***REMOVED***

    def _init_parse_var(self, name, value***REMOVED***:
        self._re[name***REMOVED*** = re.compile(r'\$\{%s\***REMOVED***' % name***REMOVED***
        self._re_sub[name***REMOVED*** = value

    def interpolate(self, value***REMOVED***:
        # Brute force: we keep interpolating until there is no '${var***REMOVED***' anymore
        # or until interpolated string is equal to input string
        def _interpolate(value***REMOVED***:
            for k in self._re.keys(***REMOVED***:
                value = self._re[k***REMOVED***.sub(self._re_sub[k***REMOVED***, value***REMOVED***
            return value
        while _VAR.search(value***REMOVED***:
            nvalue = _interpolate(value***REMOVED***
            if nvalue == value:
                break
            value = nvalue

        return value

    def variables(self***REMOVED***:
        ***REMOVED***
        Return the list of variable names.

        Parameters
        ----------
        None

        Returns
        -------
        names : list of str
            The names of all variables in the `VariableSet` instance.

        ***REMOVED***
        return list(self._raw_data.keys(***REMOVED******REMOVED***

    # Emulate a dict to set/get variables values
    def __getitem__(self, name***REMOVED***:
        return self._raw_data[name***REMOVED***

    def __setitem__(self, name, value***REMOVED***:
        self._raw_data[name***REMOVED*** = value
        self._init_parse_var(name, value***REMOVED***

def parse_meta(config***REMOVED***:
    if not config.has_section('meta'***REMOVED***:
        raise FormatError("No meta section found !"***REMOVED***

    d = {***REMOVED***
    for name, value in config.items('meta'***REMOVED***:
        d[name***REMOVED*** = value

    for k in ['name', 'description', 'version'***REMOVED***:
        if not k in d:
            raise FormatError("Option %s (section [meta***REMOVED******REMOVED*** is mandatory, "
                "but not found" % k***REMOVED***

    if not 'requires' in d:
        d['requires'***REMOVED*** = [***REMOVED***

    return d

def parse_variables(config***REMOVED***:
    if not config.has_section('variables'***REMOVED***:
        raise FormatError("No variables section found !"***REMOVED***

    d = {***REMOVED***

    for name, value in config.items("variables"***REMOVED***:
        d[name***REMOVED*** = value

    return VariableSet(d***REMOVED***

def parse_sections(config***REMOVED***:
    return meta_d, r

def pkg_to_filename(pkg_name***REMOVED***:
    return "%s.ini" % pkg_name

def parse_config(filename, dirs=None***REMOVED***:
    if dirs:
        filenames = [os.path.join(d, filename***REMOVED*** for d in dirs***REMOVED***
    else:
        filenames = [filename***REMOVED***

    config = RawConfigParser(***REMOVED***

    n = config.read(filenames***REMOVED***
    if not len(n***REMOVED*** >= 1:
        raise PkgNotFound("Could not find file(s***REMOVED*** %s" % str(filenames***REMOVED******REMOVED***

    # Parse meta and variables sections
    meta = parse_meta(config***REMOVED***

    vars = {***REMOVED***
    if config.has_section('variables'***REMOVED***:
        for name, value in config.items("variables"***REMOVED***:
            vars[name***REMOVED*** = _escape_backslash(value***REMOVED***

    # Parse "normal" sections
    secs = [s for s in config.sections(***REMOVED*** if not s in ['meta', 'variables'***REMOVED******REMOVED***
    sections = {***REMOVED***

    requires = {***REMOVED***
    for s in secs:
        d = {***REMOVED***
        if config.has_option(s, "requires"***REMOVED***:
            requires[s***REMOVED*** = config.get(s, 'requires'***REMOVED***

        for name, value in config.items(s***REMOVED***:
            d[name***REMOVED*** = value
        sections[s***REMOVED*** = d

    return meta, vars, sections, requires

def _read_config_imp(filenames, dirs=None***REMOVED***:
    def _read_config(f***REMOVED***:
        meta, vars, sections, reqs = parse_config(f, dirs***REMOVED***
        # recursively add sections and variables of required libraries
        for rname, rvalue in reqs.items(***REMOVED***:
            nmeta, nvars, nsections, nreqs = _read_config(pkg_to_filename(rvalue***REMOVED******REMOVED***

            # Update var dict for variables not in 'top' config file
            for k, v in nvars.items(***REMOVED***:
                if not k in vars:
                    vars[k***REMOVED*** = v

            # Update sec dict
            for oname, ovalue in nsections[rname***REMOVED***.items(***REMOVED***:
                if ovalue:
                    sections[rname***REMOVED***[oname***REMOVED*** += ' %s' % ovalue

        return meta, vars, sections, reqs

    meta, vars, sections, reqs = _read_config(filenames***REMOVED***

    # FIXME: document this. If pkgname is defined in the variables section, and
    # there is no pkgdir variable defined, pkgdir is automatically defined to
    # the path of pkgname. This requires the package to be imported to work
    if not 'pkgdir' in vars and "pkgname" in vars:
        pkgname = vars["pkgname"***REMOVED***
        if not pkgname in sys.modules:
            raise ValueError("You should import %s to get information on %s" %
                             (pkgname, meta["name"***REMOVED******REMOVED******REMOVED***

        mod = sys.modules[pkgname***REMOVED***
        vars["pkgdir"***REMOVED*** = _escape_backslash(os.path.dirname(mod.__file__***REMOVED******REMOVED***

    return LibraryInfo(name=meta["name"***REMOVED***, description=meta["description"***REMOVED***,
            version=meta["version"***REMOVED***, sections=sections, vars=VariableSet(vars***REMOVED******REMOVED***

# Trivial cache to cache LibraryInfo instances creation. To be really
# efficient, the cache should be handled in read_config, since a same file can
# be parsed many time outside LibraryInfo creation, but I doubt this will be a
# problem in practice
_CACHE = {***REMOVED***
def read_config(pkgname, dirs=None***REMOVED***:
    ***REMOVED***
    Return library info for a package from its configuration file.

    Parameters
    ----------
    pkgname : str
        Name of the package (should match the name of the .ini file, without
        the extension, e.g. foo for the file foo.ini***REMOVED***.
    dirs : sequence, optional
        If given, should be a sequence of directories - usually including
        the NumPy base directory - where to look for npy-pkg-config files.

    Returns
    -------
    pkginfo : class instance
        The `LibraryInfo` instance containing the build information.

    Raises
    ------
    PkgNotFound
        If the package is not found.

    See Also
    --------
    misc_util.get_info, misc_util.get_pkg_info

    Examples
    --------
    >>> npymath_info = np.distutils.npy_pkg_config.read_config('npymath'***REMOVED***
    >>> type(npymath_info***REMOVED***
    <class 'numpy.distutils.npy_pkg_config.LibraryInfo'>
    >>> print(npymath_info***REMOVED***
    Name: npymath
    Description: Portable, core math library implementing C99 standard
    Requires:
    Version: 0.1  #random

    ***REMOVED***
    ***REMOVED***
        return _CACHE[pkgname***REMOVED***
    except KeyError:
        v = _read_config_imp(pkg_to_filename(pkgname***REMOVED***, dirs***REMOVED***
        _CACHE[pkgname***REMOVED*** = v
        return v

# TODO:
#   - implements version comparison (modversion + atleast***REMOVED***

# pkg-config simple emulator - useful for debugging, and maybe later to query
# the system
if __name__ == '__main__':
    import sys
    from optparse import OptionParser
    import glob

    parser = OptionParser(***REMOVED***
    parser.add_option("--cflags", dest="cflags", action="store_true",
                      help="output all preprocessor and compiler flags"***REMOVED***
    parser.add_option("--libs", dest="libs", action="store_true",
                      help="output all linker flags"***REMOVED***
    parser.add_option("--use-section", dest="section",
                      help="use this section instead of default for options"***REMOVED***
    parser.add_option("--version", dest="version", action="store_true",
                      help="output version"***REMOVED***
    parser.add_option("--atleast-version", dest="min_version",
                      help="Minimal version"***REMOVED***
    parser.add_option("--list-all", dest="list_all", action="store_true",
                      help="Minimal version"***REMOVED***
    parser.add_option("--define-variable", dest="define_variable",
                      help="Replace variable with the given value"***REMOVED***

    (options, args***REMOVED*** = parser.parse_args(sys.argv***REMOVED***

    if len(args***REMOVED*** < 2:
        raise ValueError("Expect package name on the command line:"***REMOVED***

    if options.list_all:
        files = glob.glob("*.ini"***REMOVED***
        for f in files:
            info = read_config(f***REMOVED***
            print("%s\t%s - %s" % (info.name, info.name, info.description***REMOVED******REMOVED***

    pkg_name = args[1***REMOVED***
    ***REMOVED***
    d = os.environ.get('NPY_PKG_CONFIG_PATH'***REMOVED***
    if d:
        info = read_config(pkg_name, ['numpy/core/lib/npy-pkg-config', '.', d***REMOVED******REMOVED***
    else:
        info = read_config(pkg_name, ['numpy/core/lib/npy-pkg-config', '.'***REMOVED******REMOVED***

    if options.section:
        section = options.section
    else:
        section = "default"

    if options.define_variable:
        m = re.search('([\S***REMOVED***+***REMOVED***=([\S***REMOVED***+***REMOVED***', options.define_variable***REMOVED***
        if not m:
            raise ValueError("--define-variable option should be of " \
                             "the form --define-variable=foo=bar"***REMOVED***
        else:
            name = m.group(1***REMOVED***
            value = m.group(2***REMOVED***
        info.vars[name***REMOVED*** = value

    if options.cflags:
        print(info.cflags(section***REMOVED******REMOVED***
    if options.libs:
        print(info.libs(section***REMOVED******REMOVED***
    if options.version:
        print(info.version***REMOVED***
    if options.min_version:
        print(info.version >= options.min_version***REMOVED***
