***REMOVED*** Modified version of build_clib that handles fortran source files.
***REMOVED***
from __future__ import division, absolute_import, print_function

***REMOVED***
from glob import glob
import shutil
from distutils.command.build_clib import build_clib as old_build_clib
from distutils.errors import DistutilsSetupError, DistutilsError, \
     DistutilsFileError

from numpy.distutils import log
from distutils.dep_util import newer_group
from numpy.distutils.misc_util import filter_sources, has_f_sources,\
     has_cxx_sources, all_strings, get_lib_source_files, is_sequence, \
     get_numpy_include_dirs

# Fix Python distutils bug sf #1718574:
_l = old_build_clib.user_options
for _i in range(len(_l***REMOVED******REMOVED***:
    if _l[_i***REMOVED***[0***REMOVED*** in ['build-clib', 'build-temp'***REMOVED***:
        _l[_i***REMOVED*** = (_l[_i***REMOVED***[0***REMOVED***+'=',***REMOVED***+_l[_i***REMOVED***[1:***REMOVED***
#

class build_clib(old_build_clib***REMOVED***:

    description = "build C/C++/F libraries used by Python extensions"

    user_options = old_build_clib.user_options + [
        ('fcompiler=', None,
         "specify the Fortran compiler type"***REMOVED***,
        ('inplace', 'i', 'Build in-place'***REMOVED***,
        ('parallel=', 'j',
         "number of parallel jobs"***REMOVED***,
        ***REMOVED***

    boolean_options = old_build_clib.boolean_options + ['inplace'***REMOVED***

    def initialize_options(self***REMOVED***:
        old_build_clib.initialize_options(self***REMOVED***
        self.fcompiler = None
        self.inplace = 0
        self.parallel = None

    def finalize_options(self***REMOVED***:
        if self.parallel:
            ***REMOVED***
                self.parallel = int(self.parallel***REMOVED***
            except ValueError:
                raise ValueError("--parallel/-j argument must be an integer"***REMOVED***
        old_build_clib.finalize_options(self***REMOVED***
        self.set_undefined_options('build', ('parallel', 'parallel'***REMOVED******REMOVED***

    def have_f_sources(self***REMOVED***:
        for (lib_name, build_info***REMOVED*** in self.libraries:
            if has_f_sources(build_info.get('sources', [***REMOVED******REMOVED******REMOVED***:
                return True
        return False

    def have_cxx_sources(self***REMOVED***:
        for (lib_name, build_info***REMOVED*** in self.libraries:
            if has_cxx_sources(build_info.get('sources', [***REMOVED******REMOVED******REMOVED***:
                return True
        return False

    def run(self***REMOVED***:
        if not self.libraries:
            return

        # Make sure that library sources are complete.
        languages = [***REMOVED***

        # Make sure that extension sources are complete.
        self.run_command('build_src'***REMOVED***

        for (lib_name, build_info***REMOVED*** in self.libraries:
            l = build_info.get('language', None***REMOVED***
            if l and l not in languages: languages.append(l***REMOVED***

        from distutils.ccompiler import new_compiler
        self.compiler = new_compiler(compiler=self.compiler,
                                     dry_run=self.dry_run,
                                     force=self.force***REMOVED***
        self.compiler.customize(self.distribution,
                                need_cxx=self.have_cxx_sources(***REMOVED******REMOVED***

        libraries = self.libraries
        self.libraries = None
        self.compiler.customize_cmd(self***REMOVED***
        self.libraries = libraries

        self.compiler.show_customization(***REMOVED***

        if self.have_f_sources(***REMOVED***:
            from numpy.distutils.fcompiler import new_fcompiler
            self._f_compiler = new_fcompiler(compiler=self.fcompiler,
                                               verbose=self.verbose,
                                               dry_run=self.dry_run,
                                               force=self.force,
                                               requiref90='f90' in languages,
                                               c_compiler=self.compiler***REMOVED***
            if self._f_compiler is not None:
                self._f_compiler.customize(self.distribution***REMOVED***

                libraries = self.libraries
                self.libraries = None
                self._f_compiler.customize_cmd(self***REMOVED***
                self.libraries = libraries

                self._f_compiler.show_customization(***REMOVED***
        else:
            self._f_compiler = None

        self.build_libraries(self.libraries***REMOVED***

        if self.inplace:
            for l in  self.distribution.installed_libraries:
                libname = self.compiler.library_filename(l.name***REMOVED***
                source = os.path.join(self.build_clib, libname***REMOVED***
                target =  os.path.join(l.target_dir, libname***REMOVED***
                self.mkpath(l.target_dir***REMOVED***
                shutil.copy(source, target***REMOVED***

    def get_source_files(self***REMOVED***:
        self.check_library_list(self.libraries***REMOVED***
        filenames = [***REMOVED***
        for lib in self.libraries:
            filenames.extend(get_lib_source_files(lib***REMOVED******REMOVED***
        return filenames

    def build_libraries(self, libraries***REMOVED***:
        for (lib_name, build_info***REMOVED*** in libraries:
            self.build_a_library(build_info, lib_name, libraries***REMOVED***

    def build_a_library(self, build_info, lib_name, libraries***REMOVED***:
        # default compilers
        compiler = self.compiler
        fcompiler = self._f_compiler

        sources = build_info.get('sources'***REMOVED***
        if sources is None or not is_sequence(sources***REMOVED***:
            raise DistutilsSetupError(("in 'libraries' option (library '%s'***REMOVED***, " +
                   "'sources' must be present and must be " +
                   "a list of source filenames"***REMOVED*** % lib_name***REMOVED***
        sources = list(sources***REMOVED***

        c_sources, cxx_sources, f_sources, fmodule_sources \
                   = filter_sources(sources***REMOVED***
        requiref90 = not not fmodule_sources or \
                     build_info.get('language', 'c'***REMOVED***=='f90'

        # save source type information so that build_ext can use it.
        source_languages = [***REMOVED***
        if c_sources: source_languages.append('c'***REMOVED***
        if cxx_sources: source_languages.append('c++'***REMOVED***
        if requiref90: source_languages.append('f90'***REMOVED***
        elif f_sources: source_languages.append('f77'***REMOVED***
        build_info['source_languages'***REMOVED*** = source_languages

        lib_file = compiler.library_filename(lib_name,
                                             output_dir=self.build_clib***REMOVED***
        depends = sources + build_info.get('depends', [***REMOVED******REMOVED***
        if not (self.force or newer_group(depends, lib_file, 'newer'***REMOVED******REMOVED***:
            log.debug("skipping '%s' library (up-to-date***REMOVED***", lib_name***REMOVED***
            return
        else:
            log.info("building '%s' library", lib_name***REMOVED***

        config_fc = build_info.get('config_fc', {***REMOVED******REMOVED***
        if fcompiler is not None and config_fc:
            log.info('using additional config_fc from setup script '\
                     'for fortran compiler: %s' \
                     % (config_fc,***REMOVED******REMOVED***
            from numpy.distutils.fcompiler import new_fcompiler
            fcompiler = new_fcompiler(compiler=fcompiler.compiler_type,
                                      verbose=self.verbose,
                                      dry_run=self.dry_run,
                                      force=self.force,
                                      requiref90=requiref90,
                                      c_compiler=self.compiler***REMOVED***
            if fcompiler is not None:
                dist = self.distribution
                base_config_fc = dist.get_option_dict('config_fc'***REMOVED***.copy(***REMOVED***
                base_config_fc.update(config_fc***REMOVED***
                fcompiler.customize(base_config_fc***REMOVED***

        # check availability of Fortran compilers
        if (f_sources or fmodule_sources***REMOVED*** and fcompiler is None:
            raise DistutilsError("library %s has Fortran sources"\
                  " but no Fortran compiler found" % (lib_name***REMOVED******REMOVED***

        if fcompiler is not None:
            fcompiler.extra_f77_compile_args = build_info.get('extra_f77_compile_args'***REMOVED*** or [***REMOVED***
            fcompiler.extra_f90_compile_args = build_info.get('extra_f90_compile_args'***REMOVED*** or [***REMOVED***

        macros = build_info.get('macros'***REMOVED***
        include_dirs = build_info.get('include_dirs'***REMOVED***
        if include_dirs is None:
            include_dirs = [***REMOVED***
        extra_postargs = build_info.get('extra_compiler_args'***REMOVED*** or [***REMOVED***

        include_dirs.extend(get_numpy_include_dirs(***REMOVED******REMOVED***
        # where compiled F90 module files are:
        module_dirs = build_info.get('module_dirs'***REMOVED*** or [***REMOVED***
        module_build_dir = os.path.dirname(lib_file***REMOVED***
        if requiref90: self.mkpath(module_build_dir***REMOVED***

        if compiler.compiler_type=='msvc':
            # this hack works around the msvc compiler attributes
            # problem, msvc uses its own convention :(
            c_sources += cxx_sources
            cxx_sources = [***REMOVED***

        objects = [***REMOVED***
        if c_sources:
            log.info("compiling C sources"***REMOVED***
            objects = compiler.compile(c_sources,
                                       output_dir=self.build_temp,
                                       macros=macros,
                                       include_dirs=include_dirs,
                                       debug=self.debug,
                                       extra_postargs=extra_postargs***REMOVED***

        if cxx_sources:
            log.info("compiling C++ sources"***REMOVED***
            cxx_compiler = compiler.cxx_compiler(***REMOVED***
            cxx_objects = cxx_compiler.compile(cxx_sources,
                                               output_dir=self.build_temp,
                                               macros=macros,
                                               include_dirs=include_dirs,
                                               debug=self.debug,
                                               extra_postargs=extra_postargs***REMOVED***
            objects.extend(cxx_objects***REMOVED***

        if f_sources or fmodule_sources:
            extra_postargs = [***REMOVED***
            f_objects = [***REMOVED***

            if requiref90:
                if fcompiler.module_dir_switch is None:
                    existing_modules = glob('*.mod'***REMOVED***
                extra_postargs += fcompiler.module_options(\
                    module_dirs, module_build_dir***REMOVED***

            if fmodule_sources:
                log.info("compiling Fortran 90 module sources"***REMOVED***
                f_objects += fcompiler.compile(fmodule_sources,
                                               output_dir=self.build_temp,
                                               macros=macros,
                                               include_dirs=include_dirs,
                                               debug=self.debug,
                                               extra_postargs=extra_postargs***REMOVED***

            if requiref90 and self._f_compiler.module_dir_switch is None:
                # move new compiled F90 module files to module_build_dir
                for f in glob('*.mod'***REMOVED***:
                    if f in existing_modules:
                        continue
                    t = os.path.join(module_build_dir, f***REMOVED***
                    if os.path.abspath(f***REMOVED***==os.path.abspath(t***REMOVED***:
                        continue
                    if os.path.isfile(t***REMOVED***:
                        os.remove(t***REMOVED***
                    ***REMOVED***
                        self.move_file(f, module_build_dir***REMOVED***
                    except DistutilsFileError:
                        log.warn('failed to move %r to %r' \
                                 % (f, module_build_dir***REMOVED******REMOVED***

            if f_sources:
                log.info("compiling Fortran sources"***REMOVED***
                f_objects += fcompiler.compile(f_sources,
                                               output_dir=self.build_temp,
                                               macros=macros,
                                               include_dirs=include_dirs,
                                               debug=self.debug,
                                               extra_postargs=extra_postargs***REMOVED***
        else:
            f_objects = [***REMOVED***

        objects.extend(f_objects***REMOVED***

        # assume that default linker is suitable for
        # linking Fortran object files
        compiler.create_static_lib(objects, lib_name,
                                   output_dir=self.build_clib,
                                   debug=self.debug***REMOVED***

        # fix library dependencies
        clib_libraries = build_info.get('libraries', [***REMOVED******REMOVED***
        for lname, binfo in libraries:
            if lname in clib_libraries:
                clib_libraries.extend(binfo.get('libraries', [***REMOVED******REMOVED******REMOVED***
        if clib_libraries:
            build_info['libraries'***REMOVED*** = clib_libraries
