***REMOVED*** Modified version of build_ext that handles fortran source files.

***REMOVED***
from __future__ import division, absolute_import, print_function

***REMOVED***
import sys
from glob import glob

from distutils.dep_util import newer_group
from distutils.command.build_ext import build_ext as old_build_ext
from distutils.errors import DistutilsFileError, DistutilsSetupError,\
     DistutilsError
from distutils.file_util import copy_file

from numpy.distutils import log
from numpy.distutils.exec_command import exec_command
from numpy.distutils.system_info import combine_paths
from numpy.distutils.misc_util import filter_sources, has_f_sources, \
     has_cxx_sources, get_ext_source_files, \
     get_numpy_include_dirs, is_sequence, get_build_architecture, \
     msvc_version
from numpy.distutils.command.config_compiler import show_fortran_compilers

***REMOVED***
    set
except NameError:
    from sets import Set as set

class build_ext (old_build_ext***REMOVED***:

    description = "build C/C++/F extensions (compile/link to build directory***REMOVED***"

    user_options = old_build_ext.user_options + [
        ('fcompiler=', None,
         "specify the Fortran compiler type"***REMOVED***,
        ('parallel=', 'j',
         "number of parallel jobs"***REMOVED***,
        ***REMOVED***

    help_options = old_build_ext.help_options + [
        ('help-fcompiler', None, "list available Fortran compilers",
         show_fortran_compilers***REMOVED***,
        ***REMOVED***

    def initialize_options(self***REMOVED***:
        old_build_ext.initialize_options(self***REMOVED***
        self.fcompiler = None
        self.parallel = None

    def finalize_options(self***REMOVED***:
        if self.parallel:
            ***REMOVED***
                self.parallel = int(self.parallel***REMOVED***
            except ValueError:
                raise ValueError("--parallel/-j argument must be an integer"***REMOVED***

        # Ensure that self.include_dirs and self.distribution.include_dirs
        # refer to the same list object. finalize_options will modify
        # self.include_dirs, but self.distribution.include_dirs is used
        # during the actual build.
        # self.include_dirs is None unless paths are specified with
        # --include-dirs.
        # The include paths will be passed to the compiler in the order:
        # numpy paths, --include-dirs paths, Python include path.
        if isinstance(self.include_dirs, str***REMOVED***:
            self.include_dirs = self.include_dirs.split(os.pathsep***REMOVED***
        incl_dirs = self.include_dirs or [***REMOVED***
        if self.distribution.include_dirs is None:
            self.distribution.include_dirs = [***REMOVED***
        self.include_dirs = self.distribution.include_dirs
        self.include_dirs.extend(incl_dirs***REMOVED***

        old_build_ext.finalize_options(self***REMOVED***
        self.set_undefined_options('build', ('parallel', 'parallel'***REMOVED******REMOVED***

    def run(self***REMOVED***:
        if not self.extensions:
            return

        # Make sure that extension sources are complete.
        self.run_command('build_src'***REMOVED***

        if self.distribution.has_c_libraries(***REMOVED***:
            if self.inplace:
                if self.distribution.have_run.get('build_clib'***REMOVED***:
                    log.warn('build_clib already run, it is too late to ' \
                            'ensure in-place build of build_clib'***REMOVED***
                    build_clib = self.distribution.get_command_obj('build_clib'***REMOVED***
                else:
                    build_clib = self.distribution.get_command_obj('build_clib'***REMOVED***
                    build_clib.inplace = 1
                    build_clib.ensure_finalized(***REMOVED***
                    build_clib.run(***REMOVED***
                    self.distribution.have_run['build_clib'***REMOVED*** = 1

            else:
                self.run_command('build_clib'***REMOVED***
                build_clib = self.get_finalized_command('build_clib'***REMOVED***
            self.library_dirs.append(build_clib.build_clib***REMOVED***
        else:
            build_clib = None

        # Not including C libraries to the list of
        # extension libraries automatically to prevent
        # bogus linking commands. Extensions must
        # explicitly specify the C libraries that they use.

        from distutils.ccompiler import new_compiler
        from numpy.distutils.fcompiler import new_fcompiler

        compiler_type = self.compiler
        # Initialize C compiler:
        self.compiler = new_compiler(compiler=compiler_type,
                                     verbose=self.verbose,
                                     dry_run=self.dry_run,
                                     force=self.force***REMOVED***
        self.compiler.customize(self.distribution***REMOVED***
        self.compiler.customize_cmd(self***REMOVED***
        self.compiler.show_customization(***REMOVED***

        # Create mapping of libraries built by build_clib:
        clibs = {***REMOVED***
        if build_clib is not None:
            for libname, build_info in build_clib.libraries or [***REMOVED***:
                if libname in clibs and clibs[libname***REMOVED*** != build_info:
                    log.warn('library %r defined more than once,'\
                             ' overwriting build_info\n%s... \nwith\n%s...' \
                             % (libname, repr(clibs[libname***REMOVED******REMOVED***[:300***REMOVED***, repr(build_info***REMOVED***[:300***REMOVED******REMOVED******REMOVED***
                clibs[libname***REMOVED*** = build_info
        # .. and distribution libraries:
        for libname, build_info in self.distribution.libraries or [***REMOVED***:
            if libname in clibs:
                # build_clib libraries have a precedence before distribution ones
                continue
            clibs[libname***REMOVED*** = build_info

        # Determine if C++/Fortran 77/Fortran 90 compilers are needed.
        # Update extension libraries, library_dirs, and macros.
        all_languages = set(***REMOVED***
        for ext in self.extensions:
            ext_languages = set(***REMOVED***
            c_libs = [***REMOVED***
            c_lib_dirs = [***REMOVED***
            macros = [***REMOVED***
            for libname in ext.libraries:
                if libname in clibs:
                    binfo = clibs[libname***REMOVED***
                    c_libs += binfo.get('libraries', [***REMOVED******REMOVED***
                    c_lib_dirs += binfo.get('library_dirs', [***REMOVED******REMOVED***
                    for m in binfo.get('macros', [***REMOVED******REMOVED***:
                        if m not in macros:
                            macros.append(m***REMOVED***

                for l in clibs.get(libname, {***REMOVED******REMOVED***.get('source_languages', [***REMOVED******REMOVED***:
                    ext_languages.add(l***REMOVED***
            if c_libs:
                new_c_libs = ext.libraries + c_libs
                log.info('updating extension %r libraries from %r to %r'
                         % (ext.name, ext.libraries, new_c_libs***REMOVED******REMOVED***
                ext.libraries = new_c_libs
                ext.library_dirs = ext.library_dirs + c_lib_dirs
            if macros:
                log.info('extending extension %r defined_macros with %r'
                         % (ext.name, macros***REMOVED******REMOVED***
                ext.define_macros = ext.define_macros + macros

            # determine extension languages
            if has_f_sources(ext.sources***REMOVED***:
                ext_languages.add('f77'***REMOVED***
            if has_cxx_sources(ext.sources***REMOVED***:
                ext_languages.add('c++'***REMOVED***
            l = ext.language or self.compiler.detect_language(ext.sources***REMOVED***
            if l:
                ext_languages.add(l***REMOVED***
            # reset language attribute for choosing proper linker
            if 'c++' in ext_languages:
                ext_language = 'c++'
            elif 'f90' in ext_languages:
                ext_language = 'f90'
            elif 'f77' in ext_languages:
                ext_language = 'f77'
            else:
                ext_language = 'c' # default
            if l and l != ext_language and ext.language:
                log.warn('resetting extension %r language from %r to %r.' %
                         (ext.name, l, ext_language***REMOVED******REMOVED***
            ext.language = ext_language
            # global language
            all_languages.update(ext_languages***REMOVED***

        need_f90_compiler = 'f90' in all_languages
        need_f77_compiler = 'f77' in all_languages
        need_cxx_compiler = 'c++' in all_languages

        # Initialize C++ compiler:
        if need_cxx_compiler:
            self._cxx_compiler = new_compiler(compiler=compiler_type,
                                             verbose=self.verbose,
                                             dry_run=self.dry_run,
                                             force=self.force***REMOVED***
            compiler = self._cxx_compiler
            compiler.customize(self.distribution, need_cxx=need_cxx_compiler***REMOVED***
            compiler.customize_cmd(self***REMOVED***
            compiler.show_customization(***REMOVED***
            self._cxx_compiler = compiler.cxx_compiler(***REMOVED***
        else:
            self._cxx_compiler = None

        # Initialize Fortran 77 compiler:
        if need_f77_compiler:
            ctype = self.fcompiler
            self._f77_compiler = new_fcompiler(compiler=self.fcompiler,
                                               verbose=self.verbose,
                                               dry_run=self.dry_run,
                                               force=self.force,
                                               requiref90=False,
                                               c_compiler=self.compiler***REMOVED***
            fcompiler = self._f77_compiler
            if fcompiler:
                ctype = fcompiler.compiler_type
                fcompiler.customize(self.distribution***REMOVED***
            if fcompiler and fcompiler.get_version(***REMOVED***:
                fcompiler.customize_cmd(self***REMOVED***
                fcompiler.show_customization(***REMOVED***
            else:
                self.warn('f77_compiler=%s is not available.' %
                          (ctype***REMOVED******REMOVED***
                self._f77_compiler = None
        else:
            self._f77_compiler = None

        # Initialize Fortran 90 compiler:
        if need_f90_compiler:
            ctype = self.fcompiler
            self._f90_compiler = new_fcompiler(compiler=self.fcompiler,
                                               verbose=self.verbose,
                                               dry_run=self.dry_run,
                                               force=self.force,
                                               requiref90=True,
                                               c_compiler = self.compiler***REMOVED***
            fcompiler = self._f90_compiler
            if fcompiler:
                ctype = fcompiler.compiler_type
                fcompiler.customize(self.distribution***REMOVED***
            if fcompiler and fcompiler.get_version(***REMOVED***:
                fcompiler.customize_cmd(self***REMOVED***
                fcompiler.show_customization(***REMOVED***
            else:
                self.warn('f90_compiler=%s is not available.' %
                          (ctype***REMOVED******REMOVED***
                self._f90_compiler = None
        else:
            self._f90_compiler = None

        # Build extensions
        self.build_extensions(***REMOVED***


    def swig_sources(self, sources***REMOVED***:
        # Do nothing. Swig sources have beed handled in build_src command.
        return sources

    def build_extension(self, ext***REMOVED***:
        sources = ext.sources
        if sources is None or not is_sequence(sources***REMOVED***:
            raise DistutilsSetupError(
                ("in 'ext_modules' option (extension '%s'***REMOVED***, " +
                 "'sources' must be present and must be " +
                 "a list of source filenames"***REMOVED*** % ext.name***REMOVED***
        sources = list(sources***REMOVED***

        if not sources:
            return

        fullname = self.get_ext_fullname(ext.name***REMOVED***
        if self.inplace:
            modpath = fullname.split('.'***REMOVED***
            package = '.'.join(modpath[0:-1***REMOVED******REMOVED***
            base = modpath[-1***REMOVED***
            build_py = self.get_finalized_command('build_py'***REMOVED***
            package_dir = build_py.get_package_dir(package***REMOVED***
            ext_filename = os.path.join(package_dir,
                                        self.get_ext_filename(base***REMOVED******REMOVED***
        else:
            ext_filename = os.path.join(self.build_lib,
                                        self.get_ext_filename(fullname***REMOVED******REMOVED***
        depends = sources + ext.depends

        if not (self.force or newer_group(depends, ext_filename, 'newer'***REMOVED******REMOVED***:
            log.debug("skipping '%s' extension (up-to-date***REMOVED***", ext.name***REMOVED***
            return
        else:
            log.info("building '%s' extension", ext.name***REMOVED***

        extra_args = ext.extra_compile_args or [***REMOVED***
        macros = ext.define_macros[:***REMOVED***
        for undef in ext.undef_macros:
            macros.append((undef,***REMOVED******REMOVED***

        c_sources, cxx_sources, f_sources, fmodule_sources = \
                   filter_sources(ext.sources***REMOVED***



        if self.compiler.compiler_type=='msvc':
            if cxx_sources:
                # Needed to compile kiva.agg._agg extension.
                extra_args.append('/Zm1000'***REMOVED***
            # this hack works around the msvc compiler attributes
            # problem, msvc uses its own convention :(
            c_sources += cxx_sources
            cxx_sources = [***REMOVED***

        # Set Fortran/C++ compilers for compilation and linking.
        if ext.language=='f90':
            fcompiler = self._f90_compiler
        elif ext.language=='f77':
            fcompiler = self._f77_compiler
        else: # in case ext.language is c++, for instance
            fcompiler = self._f90_compiler or self._f77_compiler
        if fcompiler is not None:
            fcompiler.extra_f77_compile_args = (ext.extra_f77_compile_args or [***REMOVED******REMOVED*** if hasattr(ext, 'extra_f77_compile_args'***REMOVED*** else [***REMOVED***
            fcompiler.extra_f90_compile_args = (ext.extra_f90_compile_args or [***REMOVED******REMOVED*** if hasattr(ext, 'extra_f90_compile_args'***REMOVED*** else [***REMOVED***
        cxx_compiler = self._cxx_compiler

        # check for the availability of required compilers
        if cxx_sources and cxx_compiler is None:
            raise DistutilsError("extension %r has C++ sources" \
                  "but no C++ compiler found" % (ext.name***REMOVED******REMOVED***
        if (f_sources or fmodule_sources***REMOVED*** and fcompiler is None:
            raise DistutilsError("extension %r has Fortran sources " \
                  "but no Fortran compiler found" % (ext.name***REMOVED******REMOVED***
        if ext.language in ['f77', 'f90'***REMOVED*** and fcompiler is None:
            self.warn("extension %r has Fortran libraries " \
                  "but no Fortran linker found, using default linker" % (ext.name***REMOVED******REMOVED***
        if ext.language=='c++' and cxx_compiler is None:
            self.warn("extension %r has C++ libraries " \
                  "but no C++ linker found, using default linker" % (ext.name***REMOVED******REMOVED***

        kws = {'depends':ext.depends***REMOVED***
        output_dir = self.build_temp

        include_dirs = ext.include_dirs + get_numpy_include_dirs(***REMOVED***

        c_objects = [***REMOVED***
        if c_sources:
            log.info("compiling C sources"***REMOVED***
            c_objects = self.compiler.compile(c_sources,
                                              output_dir=output_dir,
                                              macros=macros,
                                              include_dirs=include_dirs,
                                              debug=self.debug,
                                              extra_postargs=extra_args,
                                              **kws***REMOVED***

        if cxx_sources:
            log.info("compiling C++ sources"***REMOVED***
            c_objects += cxx_compiler.compile(cxx_sources,
                                              output_dir=output_dir,
                                              macros=macros,
                                              include_dirs=include_dirs,
                                              debug=self.debug,
                                              extra_postargs=extra_args,
                                              **kws***REMOVED***

        extra_postargs = [***REMOVED***
        f_objects = [***REMOVED***
        if fmodule_sources:
            log.info("compiling Fortran 90 module sources"***REMOVED***
            module_dirs = ext.module_dirs[:***REMOVED***
            module_build_dir = os.path.join(
                self.build_temp, os.path.dirname(
                    self.get_ext_filename(fullname***REMOVED******REMOVED******REMOVED***

            self.mkpath(module_build_dir***REMOVED***
            if fcompiler.module_dir_switch is None:
                existing_modules = glob('*.mod'***REMOVED***
            extra_postargs += fcompiler.module_options(
                module_dirs, module_build_dir***REMOVED***
            f_objects += fcompiler.compile(fmodule_sources,
                                           output_dir=self.build_temp,
                                           macros=macros,
                                           include_dirs=include_dirs,
                                           debug=self.debug,
                                           extra_postargs=extra_postargs,
                                           depends=ext.depends***REMOVED***

            if fcompiler.module_dir_switch is None:
                for f in glob('*.mod'***REMOVED***:
                    if f in existing_modules:
                        continue
                    t = os.path.join(module_build_dir, f***REMOVED***
                    if os.path.abspath(f***REMOVED***==os.path.abspath(t***REMOVED***:
                        continue
                    if os.path.isfile(t***REMOVED***:
                        os.remove(t***REMOVED***
                    ***REMOVED***
                        self.move_file(f, module_build_dir***REMOVED***
                    except DistutilsFileError:
                        log.warn('failed to move %r to %r' %
                                 (f, module_build_dir***REMOVED******REMOVED***
        if f_sources:
            log.info("compiling Fortran sources"***REMOVED***
            f_objects += fcompiler.compile(f_sources,
                                           output_dir=self.build_temp,
                                           macros=macros,
                                           include_dirs=include_dirs,
                                           debug=self.debug,
                                           extra_postargs=extra_postargs,
                                           depends=ext.depends***REMOVED***

        objects = c_objects + f_objects

        if ext.extra_objects:
            objects.extend(ext.extra_objects***REMOVED***
        extra_args = ext.extra_link_args or [***REMOVED***
        libraries = self.get_libraries(ext***REMOVED***[:***REMOVED***
        library_dirs = ext.library_dirs[:***REMOVED***

        linker = self.compiler.link_shared_object
        # Always use system linker when using MSVC compiler.
        if self.compiler.compiler_type in ('msvc', 'intelw', 'intelemw'***REMOVED***:
            # expand libraries with fcompiler libraries as we are
            # not using fcompiler linker
            self._libs_with_msvc_and_fortran(fcompiler, libraries, library_dirs***REMOVED***

        elif ext.language in ['f77', 'f90'***REMOVED*** and fcompiler is not None:
            linker = fcompiler.link_shared_object
        if ext.language=='c++' and cxx_compiler is not None:
            linker = cxx_compiler.link_shared_object

        linker(objects, ext_filename,
               libraries=libraries,
               library_dirs=library_dirs,
               runtime_library_dirs=ext.runtime_library_dirs,
               extra_postargs=extra_args,
               export_symbols=self.get_export_symbols(ext***REMOVED***,
               debug=self.debug,
               build_temp=self.build_temp,
               target_lang=ext.language***REMOVED***

    def _add_dummy_mingwex_sym(self, c_sources***REMOVED***:
        build_src = self.get_finalized_command("build_src"***REMOVED***.build_src
        build_clib = self.get_finalized_command("build_clib"***REMOVED***.build_clib
        objects = self.compiler.compile([os.path.join(build_src,
                "gfortran_vs2003_hack.c"***REMOVED******REMOVED***,
                output_dir=self.build_temp***REMOVED***
        self.compiler.create_static_lib(objects, "_gfortran_workaround", output_dir=build_clib, debug=self.debug***REMOVED***

    def _libs_with_msvc_and_fortran(self, fcompiler, c_libraries,
                                    c_library_dirs***REMOVED***:
        if fcompiler is None: return

        for libname in c_libraries:
            if libname.startswith('msvc'***REMOVED***: continue
            fileexists = False
            for libdir in c_library_dirs or [***REMOVED***:
                libfile = os.path.join(libdir, '%s.lib' % (libname***REMOVED******REMOVED***
                if os.path.isfile(libfile***REMOVED***:
                    fileexists = True
                    break
            if fileexists: continue
            # make g77-compiled static libs available to MSVC
            fileexists = False
            for libdir in c_library_dirs:
                libfile = os.path.join(libdir, 'lib%s.a' % (libname***REMOVED******REMOVED***
                if os.path.isfile(libfile***REMOVED***:
                    # copy libname.a file to name.lib so that MSVC linker
                    # can find it
                    libfile2 = os.path.join(self.build_temp, libname + '.lib'***REMOVED***
                    copy_file(libfile, libfile2***REMOVED***
                    if self.build_temp not in c_library_dirs:
                        c_library_dirs.append(self.build_temp***REMOVED***
                    fileexists = True
                    break
            if fileexists: continue
            log.warn('could not find library %r in directories %s'
                     % (libname, c_library_dirs***REMOVED******REMOVED***

        # Always use system linker when using MSVC compiler.
        f_lib_dirs = [***REMOVED***
        for dir in fcompiler.library_dirs:
            # correct path when compiling in Cygwin but with normal Win
            # Python
            if dir.startswith('/usr/lib'***REMOVED***:
                s, o = exec_command(['cygpath', '-w', dir***REMOVED***, use_tee=False***REMOVED***
                if not s:
                    dir = o
            f_lib_dirs.append(dir***REMOVED***
        c_library_dirs.extend(f_lib_dirs***REMOVED***

        # make g77-compiled static libs available to MSVC
        for lib in fcompiler.libraries:
            if not lib.startswith('msvc'***REMOVED***:
                c_libraries.append(lib***REMOVED***
                p = combine_paths(f_lib_dirs, 'lib' + lib + '.a'***REMOVED***
                if p:
                    dst_name = os.path.join(self.build_temp, lib + '.lib'***REMOVED***
                    if not os.path.isfile(dst_name***REMOVED***:
                        copy_file(p[0***REMOVED***, dst_name***REMOVED***
                    if self.build_temp not in c_library_dirs:
                        c_library_dirs.append(self.build_temp***REMOVED***

    def get_source_files (self***REMOVED***:
        self.check_extensions_list(self.extensions***REMOVED***
        filenames = [***REMOVED***
        for ext in self.extensions:
            filenames.extend(get_ext_source_files(ext***REMOVED******REMOVED***
        return filenames

    def get_outputs (self***REMOVED***:
        self.check_extensions_list(self.extensions***REMOVED***

        outputs = [***REMOVED***
        for ext in self.extensions:
            if not ext.sources:
                continue
            fullname = self.get_ext_fullname(ext.name***REMOVED***
            outputs.append(os.path.join(self.build_lib,
                                        self.get_ext_filename(fullname***REMOVED******REMOVED******REMOVED***
        return outputs
