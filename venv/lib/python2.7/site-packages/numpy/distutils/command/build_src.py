***REMOVED*** Build swig and f2py sources.
***REMOVED***
from __future__ import division, absolute_import, print_function

***REMOVED***
import re
import sys
import shlex
import copy

from distutils.command import build_ext
from distutils.dep_util import newer_group, newer
from distutils.util import get_platform
from distutils.errors import DistutilsError, DistutilsSetupError


# this import can't be done here, as it uses numpy stuff only available
# after it's installed
#import numpy.f2py
from numpy.distutils import log
from numpy.distutils.misc_util import fortran_ext_match, \
     appendpath, is_string, is_sequence, get_cmd
from numpy.distutils.from_template import process_file as process_f_file
from numpy.distutils.conv_template import process_file as process_c_file

def subst_vars(target, source, d***REMOVED***:
    ***REMOVED***Substitute any occurence of @foo@ by d['foo'***REMOVED*** from source file into
    target.***REMOVED***
    var = re.compile('@([a-zA-Z_***REMOVED***+***REMOVED***@'***REMOVED***
    fs = open(source, 'r'***REMOVED***
    ***REMOVED***
        ft = open(target, 'w'***REMOVED***
        ***REMOVED***
            for l in fs:
                m = var.search(l***REMOVED***
                if m:
                    ft.write(l.replace('@%s@' % m.group(1***REMOVED***, d[m.group(1***REMOVED******REMOVED******REMOVED******REMOVED***
                else:
                    ft.write(l***REMOVED***
        finally:
            ft.close(***REMOVED***
    finally:
        fs.close(***REMOVED***

class build_src(build_ext.build_ext***REMOVED***:

    description = "build sources from SWIG, F2PY files or a function"

    user_options = [
        ('build-src=', 'd', "directory to \"build\" sources to"***REMOVED***,
        ('f2py-opts=', None, "list of f2py command line options"***REMOVED***,
        ('swig=', None, "path to the SWIG executable"***REMOVED***,
        ('swig-opts=', None, "list of SWIG command line options"***REMOVED***,
        ('swig-cpp', None, "make SWIG create C++ files (default is autodetected from sources***REMOVED***"***REMOVED***,
        ('f2pyflags=', None, "additional flags to f2py (use --f2py-opts= instead***REMOVED***"***REMOVED***, # obsolete
        ('swigflags=', None, "additional flags to swig (use --swig-opts= instead***REMOVED***"***REMOVED***, # obsolete
        ('force', 'f', "forcibly build everything (ignore file timestamps***REMOVED***"***REMOVED***,
        ('inplace', 'i',
         "ignore build-lib and put compiled extensions into the source " +
         "directory alongside your pure Python modules"***REMOVED***,
        ***REMOVED***

    boolean_options = ['force', 'inplace'***REMOVED***

    help_options = [***REMOVED***

    def initialize_options(self***REMOVED***:
        self.extensions = None
        self.package = None
        self.py_modules = None
        self.py_modules_dict = None
        self.build_src = None
        self.build_lib = None
        self.build_base = None
        self.force = None
        self.inplace = None
        self.package_dir = None
        self.f2pyflags = None # obsolete
        self.f2py_opts = None
        self.swigflags = None # obsolete
        self.swig_opts = None
        self.swig_cpp = None
        self.swig = None

    def finalize_options(self***REMOVED***:
        self.set_undefined_options('build',
                                   ('build_base', 'build_base'***REMOVED***,
                                   ('build_lib', 'build_lib'***REMOVED***,
                                   ('force', 'force'***REMOVED******REMOVED***
        if self.package is None:
            self.package = self.distribution.ext_package
        self.extensions = self.distribution.ext_modules
        self.libraries = self.distribution.libraries or [***REMOVED***
        self.py_modules = self.distribution.py_modules or [***REMOVED***
        self.data_files = self.distribution.data_files or [***REMOVED***

        if self.build_src is None:
            plat_specifier = ".%s-%s" % (get_platform(***REMOVED***, sys.version[0:3***REMOVED******REMOVED***
            self.build_src = os.path.join(self.build_base, 'src'+plat_specifier***REMOVED***

        # py_modules_dict is used in build_py.find_package_modules
        self.py_modules_dict = {***REMOVED***

        if self.f2pyflags:
            if self.f2py_opts:
                log.warn('ignoring --f2pyflags as --f2py-opts already used'***REMOVED***
            else:
                self.f2py_opts = self.f2pyflags
            self.f2pyflags = None
        if self.f2py_opts is None:
            self.f2py_opts = [***REMOVED***
        else:
            self.f2py_opts = shlex.split(self.f2py_opts***REMOVED***

        if self.swigflags:
            if self.swig_opts:
                log.warn('ignoring --swigflags as --swig-opts already used'***REMOVED***
            else:
                self.swig_opts = self.swigflags
            self.swigflags = None

        if self.swig_opts is None:
            self.swig_opts = [***REMOVED***
        else:
            self.swig_opts = shlex.split(self.swig_opts***REMOVED***

        # use options from build_ext command
        build_ext = self.get_finalized_command('build_ext'***REMOVED***
        if self.inplace is None:
            self.inplace = build_ext.inplace
        if self.swig_cpp is None:
            self.swig_cpp = build_ext.swig_cpp
        for c in ['swig', 'swig_opt'***REMOVED***:
            o = '--'+c.replace('_', '-'***REMOVED***
            v = getattr(build_ext, c, None***REMOVED***
            if v:
                if getattr(self, c***REMOVED***:
                    log.warn('both build_src and build_ext define %s option' % (o***REMOVED******REMOVED***
                else:
                    log.info('using "%s=%s" option from build_ext command' % (o, v***REMOVED******REMOVED***
                    setattr(self, c, v***REMOVED***

    def run(self***REMOVED***:
        log.info("build_src"***REMOVED***
        if not (self.extensions or self.libraries***REMOVED***:
            return
        self.build_sources(***REMOVED***

    def build_sources(self***REMOVED***:

        if self.inplace:
            self.get_package_dir = \
                     self.get_finalized_command('build_py'***REMOVED***.get_package_dir

        self.build_py_modules_sources(***REMOVED***

        for libname_info in self.libraries:
            self.build_library_sources(*libname_info***REMOVED***

        if self.extensions:
            self.check_extensions_list(self.extensions***REMOVED***

            for ext in self.extensions:
                self.build_extension_sources(ext***REMOVED***

        self.build_data_files_sources(***REMOVED***
        self.build_npy_pkg_config(***REMOVED***

    def build_data_files_sources(self***REMOVED***:
        if not self.data_files:
            return
        log.info('building data_files sources'***REMOVED***
        from numpy.distutils.misc_util import get_data_files
        new_data_files = [***REMOVED***
        for data in self.data_files:
            if isinstance(data, str***REMOVED***:
                new_data_files.append(data***REMOVED***
            elif isinstance(data, tuple***REMOVED***:
                d, files = data
                if self.inplace:
                    build_dir = self.get_package_dir('.'.join(d.split(os.sep***REMOVED******REMOVED******REMOVED***
                else:
                    build_dir = os.path.join(self.build_src, d***REMOVED***
                funcs = [f for f in files if hasattr(f, '__call__'***REMOVED******REMOVED***
                files = [f for f in files if not hasattr(f, '__call__'***REMOVED******REMOVED***
                for f in funcs:
                    if f.__code__.co_argcount==1:
                        s = f(build_dir***REMOVED***
                    else:
                        s = f(***REMOVED***
                    if s is not None:
                        if isinstance(s, list***REMOVED***:
                            files.extend(s***REMOVED***
                        elif isinstance(s, str***REMOVED***:
                            files.append(s***REMOVED***
                        else:
                            raise TypeError(repr(s***REMOVED******REMOVED***
                filenames = get_data_files((d, files***REMOVED******REMOVED***
                new_data_files.append((d, filenames***REMOVED******REMOVED***
            else:
                raise TypeError(repr(data***REMOVED******REMOVED***
        self.data_files[:***REMOVED*** = new_data_files


    def _build_npy_pkg_config(self, info, gd***REMOVED***:
        import shutil
        template, install_dir, subst_dict = info
        template_dir = os.path.dirname(template***REMOVED***
        for k, v in gd.items(***REMOVED***:
            subst_dict[k***REMOVED*** = v

        if self.inplace == 1:
            generated_dir = os.path.join(template_dir, install_dir***REMOVED***
        else:
            generated_dir = os.path.join(self.build_src, template_dir,
                    install_dir***REMOVED***
        generated = os.path.basename(os.path.splitext(template***REMOVED***[0***REMOVED******REMOVED***
        generated_path = os.path.join(generated_dir, generated***REMOVED***
        if not os.path.exists(generated_dir***REMOVED***:
            os.makedirs(generated_dir***REMOVED***

        subst_vars(generated_path, template, subst_dict***REMOVED***

        # Where to install relatively to install prefix
        full_install_dir = os.path.join(template_dir, install_dir***REMOVED***
        return full_install_dir, generated_path

    def build_npy_pkg_config(self***REMOVED***:
        log.info('build_src: building npy-pkg config files'***REMOVED***

        # XXX: another ugly workaround to circumvent distutils brain damage. We
        # need the install prefix here, but finalizing the options of the
        # install command when only building sources cause error. Instead, we
        # copy the install command instance, and finalize the copy so that it
        # does not disrupt how distutils want to do things when with the
        # original install command instance.
        install_cmd = copy.copy(get_cmd('install'***REMOVED******REMOVED***
        if not install_cmd.finalized == 1:
            install_cmd.finalize_options(***REMOVED***
        build_npkg = False
        gd = {***REMOVED***
        if self.inplace == 1:
            top_prefix = '.'
            build_npkg = True
        elif hasattr(install_cmd, 'install_libbase'***REMOVED***:
            top_prefix = install_cmd.install_libbase
            build_npkg = True

        if build_npkg:
            for pkg, infos in self.distribution.installed_pkg_config.items(***REMOVED***:
                pkg_path = self.distribution.package_dir[pkg***REMOVED***
                prefix = os.path.join(os.path.abspath(top_prefix***REMOVED***, pkg_path***REMOVED***
                d = {'prefix': prefix***REMOVED***
                for info in infos:
                    install_dir, generated = self._build_npy_pkg_config(info, d***REMOVED***
                    self.distribution.data_files.append((install_dir,
                        [generated***REMOVED******REMOVED******REMOVED***

    def build_py_modules_sources(self***REMOVED***:
        if not self.py_modules:
            return
        log.info('building py_modules sources'***REMOVED***
        new_py_modules = [***REMOVED***
        for source in self.py_modules:
            if is_sequence(source***REMOVED*** and len(source***REMOVED***==3:
                package, module_base, source = source
                if self.inplace:
                    build_dir = self.get_package_dir(package***REMOVED***
                else:
                    build_dir = os.path.join(self.build_src,
                                             os.path.join(*package.split('.'***REMOVED******REMOVED******REMOVED***
                if hasattr(source, '__call__'***REMOVED***:
                    target = os.path.join(build_dir, module_base + '.py'***REMOVED***
                    source = source(target***REMOVED***
                if source is None:
                    continue
                modules = [(package, module_base, source***REMOVED******REMOVED***
                if package not in self.py_modules_dict:
                    self.py_modules_dict[package***REMOVED*** = [***REMOVED***
                self.py_modules_dict[package***REMOVED*** += modules
            else:
                new_py_modules.append(source***REMOVED***
        self.py_modules[:***REMOVED*** = new_py_modules

    def build_library_sources(self, lib_name, build_info***REMOVED***:
        sources = list(build_info.get('sources', [***REMOVED******REMOVED******REMOVED***

        if not sources:
            return

        log.info('building library "%s" sources' % (lib_name***REMOVED******REMOVED***

        sources = self.generate_sources(sources, (lib_name, build_info***REMOVED******REMOVED***

        sources = self.template_sources(sources, (lib_name, build_info***REMOVED******REMOVED***

        sources, h_files = self.filter_h_files(sources***REMOVED***

        if h_files:
            log.info('%s - nothing done with h_files = %s',
                     self.package, h_files***REMOVED***

        #for f in h_files:
        #    self.distribution.headers.append((lib_name,f***REMOVED******REMOVED***

        build_info['sources'***REMOVED*** = sources
        return

    def build_extension_sources(self, ext***REMOVED***:

        sources = list(ext.sources***REMOVED***

        log.info('building extension "%s" sources' % (ext.name***REMOVED******REMOVED***

        fullname = self.get_ext_fullname(ext.name***REMOVED***

        modpath = fullname.split('.'***REMOVED***
        package = '.'.join(modpath[0:-1***REMOVED******REMOVED***

        if self.inplace:
            self.ext_target_dir = self.get_package_dir(package***REMOVED***

        sources = self.generate_sources(sources, ext***REMOVED***
        sources = self.template_sources(sources, ext***REMOVED***
        sources = self.swig_sources(sources, ext***REMOVED***
        sources = self.f2py_sources(sources, ext***REMOVED***
        sources = self.pyrex_sources(sources, ext***REMOVED***

        sources, py_files = self.filter_py_files(sources***REMOVED***

        if package not in self.py_modules_dict:
            self.py_modules_dict[package***REMOVED*** = [***REMOVED***
        modules = [***REMOVED***
        for f in py_files:
            module = os.path.splitext(os.path.basename(f***REMOVED******REMOVED***[0***REMOVED***
            modules.append((package, module, f***REMOVED******REMOVED***
        self.py_modules_dict[package***REMOVED*** += modules

        sources, h_files = self.filter_h_files(sources***REMOVED***

        if h_files:
            log.info('%s - nothing done with h_files = %s',
                     package, h_files***REMOVED***
        #for f in h_files:
        #    self.distribution.headers.append((package,f***REMOVED******REMOVED***

        ext.sources = sources

    def generate_sources(self, sources, extension***REMOVED***:
        new_sources = [***REMOVED***
        func_sources = [***REMOVED***
        for source in sources:
            if is_string(source***REMOVED***:
                new_sources.append(source***REMOVED***
            else:
                func_sources.append(source***REMOVED***
        if not func_sources:
            return new_sources
        if self.inplace and not is_sequence(extension***REMOVED***:
            build_dir = self.ext_target_dir
        else:
            if is_sequence(extension***REMOVED***:
                name = extension[0***REMOVED***
            #    if 'include_dirs' not in extension[1***REMOVED***:
            #        extension[1***REMOVED***['include_dirs'***REMOVED*** = [***REMOVED***
            #    incl_dirs = extension[1***REMOVED***['include_dirs'***REMOVED***
            else:
                name = extension.name
            #    incl_dirs = extension.include_dirs
            #if self.build_src not in incl_dirs:
            #    incl_dirs.append(self.build_src***REMOVED***
            build_dir = os.path.join(*([self.build_src***REMOVED***\
                                       +name.split('.'***REMOVED***[:-1***REMOVED******REMOVED******REMOVED***
        self.mkpath(build_dir***REMOVED***
        for func in func_sources:
            source = func(extension, build_dir***REMOVED***
            if not source:
                continue
            if is_sequence(source***REMOVED***:
                [log.info("  adding '%s' to sources." % (s,***REMOVED******REMOVED*** for s in source***REMOVED***
                new_sources.extend(source***REMOVED***
            else:
                log.info("  adding '%s' to sources." % (source,***REMOVED******REMOVED***
                new_sources.append(source***REMOVED***

        return new_sources

    def filter_py_files(self, sources***REMOVED***:
        return self.filter_files(sources, ['.py'***REMOVED******REMOVED***

    def filter_h_files(self, sources***REMOVED***:
        return self.filter_files(sources, ['.h', '.hpp', '.inc'***REMOVED******REMOVED***

    def filter_files(self, sources, exts = [***REMOVED******REMOVED***:
        new_sources = [***REMOVED***
        files = [***REMOVED***
        for source in sources:
            (base, ext***REMOVED*** = os.path.splitext(source***REMOVED***
            if ext in exts:
                files.append(source***REMOVED***
            else:
                new_sources.append(source***REMOVED***
        return new_sources, files

    def template_sources(self, sources, extension***REMOVED***:
        new_sources = [***REMOVED***
        if is_sequence(extension***REMOVED***:
            depends = extension[1***REMOVED***.get('depends'***REMOVED***
            include_dirs = extension[1***REMOVED***.get('include_dirs'***REMOVED***
        else:
            depends = extension.depends
            include_dirs = extension.include_dirs
        for source in sources:
            (base, ext***REMOVED*** = os.path.splitext(source***REMOVED***
            if ext == '.src':  # Template file
                if self.inplace:
                    target_dir = os.path.dirname(base***REMOVED***
                else:
                    target_dir = appendpath(self.build_src, os.path.dirname(base***REMOVED******REMOVED***
                self.mkpath(target_dir***REMOVED***
                target_file = os.path.join(target_dir, os.path.basename(base***REMOVED******REMOVED***
                if (self.force or newer_group([source***REMOVED*** + depends, target_file***REMOVED******REMOVED***:
                    if _f_pyf_ext_match(base***REMOVED***:
                        log.info("from_template:> %s" % (target_file***REMOVED******REMOVED***
                        outstr = process_f_file(source***REMOVED***
                    else:
                        log.info("conv_template:> %s" % (target_file***REMOVED******REMOVED***
                        outstr = process_c_file(source***REMOVED***
                    fid = open(target_file, 'w'***REMOVED***
                    fid.write(outstr***REMOVED***
                    fid.close(***REMOVED***
                if _header_ext_match(target_file***REMOVED***:
                    d = os.path.dirname(target_file***REMOVED***
                    if d not in include_dirs:
                        log.info("  adding '%s' to include_dirs." % (d***REMOVED******REMOVED***
                        include_dirs.append(d***REMOVED***
                new_sources.append(target_file***REMOVED***
            else:
                new_sources.append(source***REMOVED***
        return new_sources

    def pyrex_sources(self, sources, extension***REMOVED***:
        ***REMOVED***Pyrex not supported; this remains for Cython support (see below***REMOVED******REMOVED***
        new_sources = [***REMOVED***
        ext_name = extension.name.split('.'***REMOVED***[-1***REMOVED***
        for source in sources:
            (base, ext***REMOVED*** = os.path.splitext(source***REMOVED***
            if ext == '.pyx':
                target_file = self.generate_a_pyrex_source(base, ext_name,
                                                           source,
                                                           extension***REMOVED***
                new_sources.append(target_file***REMOVED***
            else:
                new_sources.append(source***REMOVED***
        return new_sources

    def generate_a_pyrex_source(self, base, ext_name, source, extension***REMOVED***:
        ***REMOVED***Pyrex is not supported, but some projects monkeypatch this method.

        That allows compiling Cython code, see gh-6955.
        This method will remain here for compatibility reasons.
        ***REMOVED***
        return [***REMOVED***

    def f2py_sources(self, sources, extension***REMOVED***:
        new_sources = [***REMOVED***
        f2py_sources = [***REMOVED***
        f_sources = [***REMOVED***
        f2py_targets = {***REMOVED***
        target_dirs = [***REMOVED***
        ext_name = extension.name.split('.'***REMOVED***[-1***REMOVED***
        skip_f2py = 0

        for source in sources:
            (base, ext***REMOVED*** = os.path.splitext(source***REMOVED***
            if ext == '.pyf': # F2PY interface file
                if self.inplace:
                    target_dir = os.path.dirname(base***REMOVED***
                else:
                    target_dir = appendpath(self.build_src, os.path.dirname(base***REMOVED******REMOVED***
                if os.path.isfile(source***REMOVED***:
                    name = get_f2py_modulename(source***REMOVED***
                    if name != ext_name:
                        raise DistutilsSetupError('mismatch of extension names: %s '
                                                  'provides %r but expected %r' % (
                            source, name, ext_name***REMOVED******REMOVED***
                    target_file = os.path.join(target_dir, name+'module.c'***REMOVED***
                else:
                    log.debug('  source %s does not exist: skipping f2py\'ing.' \
                              % (source***REMOVED******REMOVED***
                    name = ext_name
                    skip_f2py = 1
                    target_file = os.path.join(target_dir, name+'module.c'***REMOVED***
                    if not os.path.isfile(target_file***REMOVED***:
                        log.warn('  target %s does not exist:\n   '\
                                 'Assuming %smodule.c was generated with '\
                                 '"build_src --inplace" command.' \
                                 % (target_file, name***REMOVED******REMOVED***
                        target_dir = os.path.dirname(base***REMOVED***
                        target_file = os.path.join(target_dir, name+'module.c'***REMOVED***
                        if not os.path.isfile(target_file***REMOVED***:
                            raise DistutilsSetupError("%r missing" % (target_file,***REMOVED******REMOVED***
                        log.info('   Yes! Using %r as up-to-date target.' \
                                 % (target_file***REMOVED******REMOVED***
                target_dirs.append(target_dir***REMOVED***
                f2py_sources.append(source***REMOVED***
                f2py_targets[source***REMOVED*** = target_file
                new_sources.append(target_file***REMOVED***
            elif fortran_ext_match(ext***REMOVED***:
                f_sources.append(source***REMOVED***
            else:
                new_sources.append(source***REMOVED***

        if not (f2py_sources or f_sources***REMOVED***:
            return new_sources

        for d in target_dirs:
            self.mkpath(d***REMOVED***

        f2py_options = extension.f2py_options + self.f2py_opts

        if self.distribution.libraries:
            for name, build_info in self.distribution.libraries:
                if name in extension.libraries:
                    f2py_options.extend(build_info.get('f2py_options', [***REMOVED******REMOVED******REMOVED***

        log.info("f2py options: %s" % (f2py_options***REMOVED******REMOVED***

        if f2py_sources:
            if len(f2py_sources***REMOVED*** != 1:
                raise DistutilsSetupError(
                    'only one .pyf file is allowed per extension module but got'\
                    ' more: %r' % (f2py_sources,***REMOVED******REMOVED***
            source = f2py_sources[0***REMOVED***
            target_file = f2py_targets[source***REMOVED***
            target_dir = os.path.dirname(target_file***REMOVED*** or '.'
            depends = [source***REMOVED*** + extension.depends
            if (self.force or newer_group(depends, target_file, 'newer'***REMOVED******REMOVED*** \
                   and not skip_f2py:
                log.info("f2py: %s" % (source***REMOVED******REMOVED***
                import numpy.f2py
                numpy.f2py.run_main(f2py_options
                                    + ['--build-dir', target_dir, source***REMOVED******REMOVED***
            else:
                log.debug("  skipping '%s' f2py interface (up-to-date***REMOVED***" % (source***REMOVED******REMOVED***
        else:
            #XXX TODO: --inplace support for sdist command
            if is_sequence(extension***REMOVED***:
                name = extension[0***REMOVED***
            else: name = extension.name
            target_dir = os.path.join(*([self.build_src***REMOVED***\
                                        +name.split('.'***REMOVED***[:-1***REMOVED******REMOVED******REMOVED***
            target_file = os.path.join(target_dir, ext_name + 'module.c'***REMOVED***
            new_sources.append(target_file***REMOVED***
            depends = f_sources + extension.depends
            if (self.force or newer_group(depends, target_file, 'newer'***REMOVED******REMOVED*** \
                   and not skip_f2py:
                log.info("f2py:> %s" % (target_file***REMOVED******REMOVED***
                self.mkpath(target_dir***REMOVED***
                import numpy.f2py
                numpy.f2py.run_main(f2py_options + ['--lower',
                                                '--build-dir', target_dir***REMOVED***+\
                                ['-m', ext_name***REMOVED***+f_sources***REMOVED***
            else:
                log.debug("  skipping f2py fortran files for '%s' (up-to-date***REMOVED***"\
                          % (target_file***REMOVED******REMOVED***

        if not os.path.isfile(target_file***REMOVED***:
            raise DistutilsError("f2py target file %r not generated" % (target_file,***REMOVED******REMOVED***

        target_c = os.path.join(self.build_src, 'fortranobject.c'***REMOVED***
        target_h = os.path.join(self.build_src, 'fortranobject.h'***REMOVED***
        log.info("  adding '%s' to sources." % (target_c***REMOVED******REMOVED***
        new_sources.append(target_c***REMOVED***
        if self.build_src not in extension.include_dirs:
            log.info("  adding '%s' to include_dirs." \
                     % (self.build_src***REMOVED******REMOVED***
            extension.include_dirs.append(self.build_src***REMOVED***

        if not skip_f2py:
            import numpy.f2py
            d = os.path.dirname(numpy.f2py.__file__***REMOVED***
            source_c = os.path.join(d, 'src', 'fortranobject.c'***REMOVED***
            source_h = os.path.join(d, 'src', 'fortranobject.h'***REMOVED***
            if newer(source_c, target_c***REMOVED*** or newer(source_h, target_h***REMOVED***:
                self.mkpath(os.path.dirname(target_c***REMOVED******REMOVED***
                self.copy_file(source_c, target_c***REMOVED***
                self.copy_file(source_h, target_h***REMOVED***
        else:
            if not os.path.isfile(target_c***REMOVED***:
                raise DistutilsSetupError("f2py target_c file %r not found" % (target_c,***REMOVED******REMOVED***
            if not os.path.isfile(target_h***REMOVED***:
                raise DistutilsSetupError("f2py target_h file %r not found" % (target_h,***REMOVED******REMOVED***

        for name_ext in ['-f2pywrappers.f', '-f2pywrappers2.f90'***REMOVED***:
            filename = os.path.join(target_dir, ext_name + name_ext***REMOVED***
            if os.path.isfile(filename***REMOVED***:
                log.info("  adding '%s' to sources." % (filename***REMOVED******REMOVED***
                f_sources.append(filename***REMOVED***

        return new_sources + f_sources

    def swig_sources(self, sources, extension***REMOVED***:
        # Assuming SWIG 1.3.14 or later. See compatibility note in
        #   http://www.swig.org/Doc1.3/Python.html#Python_nn6

        new_sources = [***REMOVED***
        swig_sources = [***REMOVED***
        swig_targets = {***REMOVED***
        target_dirs = [***REMOVED***
        py_files = [***REMOVED***     # swig generated .py files
        target_ext = '.c'
        if '-c++' in extension.swig_opts:
            typ = 'c++'
            is_cpp = True
            extension.swig_opts.remove('-c++'***REMOVED***
        elif self.swig_cpp:
            typ = 'c++'
            is_cpp = True
        else:
            typ = None
            is_cpp = False
        skip_swig = 0
        ext_name = extension.name.split('.'***REMOVED***[-1***REMOVED***

        for source in sources:
            (base, ext***REMOVED*** = os.path.splitext(source***REMOVED***
            if ext == '.i': # SWIG interface file
                # the code below assumes that the sources list
                # contains not more than one .i SWIG interface file
                if self.inplace:
                    target_dir = os.path.dirname(base***REMOVED***
                    py_target_dir = self.ext_target_dir
                else:
                    target_dir = appendpath(self.build_src, os.path.dirname(base***REMOVED******REMOVED***
                    py_target_dir = target_dir
                if os.path.isfile(source***REMOVED***:
                    name = get_swig_modulename(source***REMOVED***
                    if name != ext_name[1:***REMOVED***:
                        raise DistutilsSetupError(
                            'mismatch of extension names: %s provides %r'
                            ' but expected %r' % (source, name, ext_name[1:***REMOVED******REMOVED******REMOVED***
                    if typ is None:
                        typ = get_swig_target(source***REMOVED***
                        is_cpp = typ=='c++'
                    else:
                        typ2 = get_swig_target(source***REMOVED***
                        if typ2 is None:
                            log.warn('source %r does not define swig target, assuming %s swig target' \
                                     % (source, typ***REMOVED******REMOVED***
                        elif typ!=typ2:
                            log.warn('expected %r but source %r defines %r swig target' \
                                     % (typ, source, typ2***REMOVED******REMOVED***
                            if typ2=='c++':
                                log.warn('resetting swig target to c++ (some targets may have .c extension***REMOVED***'***REMOVED***
                                is_cpp = True
                            else:
                                log.warn('assuming that %r has c++ swig target' % (source***REMOVED******REMOVED***
                    if is_cpp:
                        target_ext = '.cpp'
                    target_file = os.path.join(target_dir, '%s_wrap%s' \
                                               % (name, target_ext***REMOVED******REMOVED***
                else:
                    log.warn('  source %s does not exist: skipping swig\'ing.' \
                             % (source***REMOVED******REMOVED***
                    name = ext_name[1:***REMOVED***
                    skip_swig = 1
                    target_file = _find_swig_target(target_dir, name***REMOVED***
                    if not os.path.isfile(target_file***REMOVED***:
                        log.warn('  target %s does not exist:\n   '\
                                 'Assuming %s_wrap.{c,cpp***REMOVED*** was generated with '\
                                 '"build_src --inplace" command.' \
                                 % (target_file, name***REMOVED******REMOVED***
                        target_dir = os.path.dirname(base***REMOVED***
                        target_file = _find_swig_target(target_dir, name***REMOVED***
                        if not os.path.isfile(target_file***REMOVED***:
                            raise DistutilsSetupError("%r missing" % (target_file,***REMOVED******REMOVED***
                        log.warn('   Yes! Using %r as up-to-date target.' \
                                 % (target_file***REMOVED******REMOVED***
                target_dirs.append(target_dir***REMOVED***
                new_sources.append(target_file***REMOVED***
                py_files.append(os.path.join(py_target_dir, name+'.py'***REMOVED******REMOVED***
                swig_sources.append(source***REMOVED***
                swig_targets[source***REMOVED*** = new_sources[-1***REMOVED***
            else:
                new_sources.append(source***REMOVED***

        if not swig_sources:
            return new_sources

        if skip_swig:
            return new_sources + py_files

        for d in target_dirs:
            self.mkpath(d***REMOVED***

        swig = self.swig or self.find_swig(***REMOVED***
        swig_cmd = [swig, "-python"***REMOVED*** + extension.swig_opts
        if is_cpp:
            swig_cmd.append('-c++'***REMOVED***
        for d in extension.include_dirs:
            swig_cmd.append('-I'+d***REMOVED***
        for source in swig_sources:
            target = swig_targets[source***REMOVED***
            depends = [source***REMOVED*** + extension.depends
            if self.force or newer_group(depends, target, 'newer'***REMOVED***:
                log.info("%s: %s" % (os.path.basename(swig***REMOVED*** \
                                     + (is_cpp and '++' or ''***REMOVED***, source***REMOVED******REMOVED***
                self.spawn(swig_cmd + self.swig_opts \
                           + ["-o", target, '-outdir', py_target_dir, source***REMOVED******REMOVED***
            else:
                log.debug("  skipping '%s' swig interface (up-to-date***REMOVED***" \
                         % (source***REMOVED******REMOVED***

        return new_sources + py_files

_f_pyf_ext_match = re.compile(r'.*[.***REMOVED***(f90|f95|f77|for|ftn|f|pyf***REMOVED***\Z', re.I***REMOVED***.match
_header_ext_match = re.compile(r'.*[.***REMOVED***(inc|h|hpp***REMOVED***\Z', re.I***REMOVED***.match

#### SWIG related auxiliary functions ####
_swig_module_name_match = re.compile(r'\s*%module\s*(.*\(\s*package\s*=\s*"(?P<package>[\w_***REMOVED***+***REMOVED***".*\***REMOVED***|***REMOVED***\s*(?P<name>[\w_***REMOVED***+***REMOVED***',
                                     re.I***REMOVED***.match
_has_c_header = re.compile(r'-[****REMOVED***-\s*c\s*-[****REMOVED***-', re.I***REMOVED***.search
_has_cpp_header = re.compile(r'-[****REMOVED***-\s*c[+***REMOVED***[+***REMOVED***\s*-[****REMOVED***-', re.I***REMOVED***.search

def get_swig_target(source***REMOVED***:
    f = open(source, 'r'***REMOVED***
    result = None
    line = f.readline(***REMOVED***
    if _has_cpp_header(line***REMOVED***:
        result = 'c++'
    if _has_c_header(line***REMOVED***:
        result = 'c'
    f.close(***REMOVED***
    return result

def get_swig_modulename(source***REMOVED***:
    f = open(source, 'r'***REMOVED***
    name = None
    for line in f:
        m = _swig_module_name_match(line***REMOVED***
        if m:
            name = m.group('name'***REMOVED***
            break
    f.close(***REMOVED***
    return name

def _find_swig_target(target_dir, name***REMOVED***:
    for ext in ['.cpp', '.c'***REMOVED***:
        target = os.path.join(target_dir, '%s_wrap%s' % (name, ext***REMOVED******REMOVED***
        if os.path.isfile(target***REMOVED***:
            break
    return target

#### F2PY related auxiliary functions ####

_f2py_module_name_match = re.compile(r'\s*python\s*module\s*(?P<name>[\w_***REMOVED***+***REMOVED***',
                                re.I***REMOVED***.match
_f2py_user_module_name_match = re.compile(r'\s*python\s*module\s*(?P<name>[\w_***REMOVED****?'\
                                     '__user__[\w_***REMOVED*******REMOVED***', re.I***REMOVED***.match

def get_f2py_modulename(source***REMOVED***:
    name = None
    f = open(source***REMOVED***
    for line in f:
        m = _f2py_module_name_match(line***REMOVED***
        if m:
            if _f2py_user_module_name_match(line***REMOVED***: # skip *__user__* names
                continue
            name = m.group('name'***REMOVED***
            break
    f.close(***REMOVED***
    return name

##########################################
