# Added Fortran compiler support to config. Currently useful only for
# try_compile call. try_run works but is untested for most of Fortran
# compilers (they must define linker_exe first***REMOVED***.
# Pearu Peterson
from __future__ import division, absolute_import, print_function

***REMOVED***, signal
import warnings
import sys

from distutils.command.config import config as old_config
from distutils.command.config import LANG_EXT
from distutils import log
from distutils.file_util import copy_file
from distutils.ccompiler import CompileError, LinkError
import distutils
from numpy.distutils.exec_command import exec_command
from numpy.distutils.mingw32ccompiler import generate_manifest
from numpy.distutils.command.autodist import (check_gcc_function_attribute,
                                              check_gcc_variable_attribute,
                                              check_inline,
                                              check_restrict,
                                              check_compiler_gcc4***REMOVED***
from numpy.distutils.compat import get_exception

LANG_EXT['f77'***REMOVED*** = '.f'
LANG_EXT['f90'***REMOVED*** = '.f90'

class config(old_config***REMOVED***:
    old_config.user_options += [
        ('fcompiler=', None, "specify the Fortran compiler type"***REMOVED***,
        ***REMOVED***

    def initialize_options(self***REMOVED***:
        self.fcompiler = None
        old_config.initialize_options(self***REMOVED***

    def _check_compiler (self***REMOVED***:
        old_config._check_compiler(self***REMOVED***
        from numpy.distutils.fcompiler import FCompiler, new_fcompiler

        if sys.platform == 'win32' and (self.compiler.compiler_type in
                                        ('msvc', 'intelw', 'intelemw'***REMOVED******REMOVED***:
            # XXX: hack to circumvent a python 2.6 bug with msvc9compiler:
            # initialize call query_vcvarsall, which throws an IOError, and
            # causes an error along the way without much information. We try to
            # catch it here, hoping it is early enough, and print an helpful
            # message instead of Error: None.
            if not self.compiler.initialized:
                ***REMOVED***
                    self.compiler.initialize(***REMOVED***
                except IOError:
                    e = get_exception(***REMOVED***
                    msg = ***REMOVED***\
Could not initialize compiler instance: do you have Visual Studio
installed?  If you are trying to build with MinGW, please use "python setup.py
build -c mingw32" instead.  If you have Visual Studio installed, check it is
correctly installed, and the right version (VS 2008 for python 2.6, 2.7 and 3.2,
VS 2010 for >= 3.3***REMOVED***.

Original exception was: %s, and the Compiler class was %s
============================================================================***REMOVED*** \
                        % (e, self.compiler.__class__.__name__***REMOVED***
                    print (***REMOVED***\
============================================================================***REMOVED******REMOVED***
                    raise distutils.errors.DistutilsPlatformError(msg***REMOVED***

            # After MSVC is initialized, add an explicit /MANIFEST to linker
            # flags.  See issues gh-4245 and gh-4101 for details.  Also
            # relevant are issues 4431 and 16296 on the Python bug tracker.
            from distutils import msvc9compiler
            if msvc9compiler.get_build_version(***REMOVED*** >= 10:
                for ldflags in [self.compiler.ldflags_shared,
                                self.compiler.ldflags_shared_debug***REMOVED***:
                    if '/MANIFEST' not in ldflags:
                        ldflags.append('/MANIFEST'***REMOVED***

        if not isinstance(self.fcompiler, FCompiler***REMOVED***:
            self.fcompiler = new_fcompiler(compiler=self.fcompiler,
                                           dry_run=self.dry_run, force=1,
                                           c_compiler=self.compiler***REMOVED***
            if self.fcompiler is not None:
                self.fcompiler.customize(self.distribution***REMOVED***
                if self.fcompiler.get_version(***REMOVED***:
                    self.fcompiler.customize_cmd(self***REMOVED***
                    self.fcompiler.show_customization(***REMOVED***

    def _wrap_method(self, mth, lang, args***REMOVED***:
        from distutils.ccompiler import CompileError
        from distutils.errors import DistutilsExecError
        save_compiler = self.compiler
        if lang in ['f77', 'f90'***REMOVED***:
            self.compiler = self.fcompiler
        ***REMOVED***
            ret = mth(*((self,***REMOVED***+args***REMOVED******REMOVED***
        except (DistutilsExecError, CompileError***REMOVED***:
            msg = str(get_exception(***REMOVED******REMOVED***
            self.compiler = save_compiler
            raise CompileError
        self.compiler = save_compiler
        return ret

    def _compile (self, body, headers, include_dirs, lang***REMOVED***:
        return self._wrap_method(old_config._compile, lang,
                                 (body, headers, include_dirs, lang***REMOVED******REMOVED***

    def _link (self, body,
               headers, include_dirs,
               libraries, library_dirs, lang***REMOVED***:
        if self.compiler.compiler_type=='msvc':
            libraries = (libraries or [***REMOVED******REMOVED***[:***REMOVED***
            library_dirs = (library_dirs or [***REMOVED******REMOVED***[:***REMOVED***
            if lang in ['f77', 'f90'***REMOVED***:
                lang = 'c' # always use system linker when using MSVC compiler
                if self.fcompiler:
                    for d in self.fcompiler.library_dirs or [***REMOVED***:
                        # correct path when compiling in Cygwin but with
                        # normal Win Python
                        if d.startswith('/usr/lib'***REMOVED***:
                            s, o = exec_command(['cygpath', '-w', d***REMOVED***,
                                               use_tee=False***REMOVED***
                            if not s: d = o
                        library_dirs.append(d***REMOVED***
                    for libname in self.fcompiler.libraries or [***REMOVED***:
                        if libname not in libraries:
                            libraries.append(libname***REMOVED***
            for libname in libraries:
                if libname.startswith('msvc'***REMOVED***: continue
                fileexists = False
                for libdir in library_dirs or [***REMOVED***:
                    libfile = os.path.join(libdir, '%s.lib' % (libname***REMOVED******REMOVED***
                    if os.path.isfile(libfile***REMOVED***:
                        fileexists = True
                        break
                if fileexists: continue
                # make g77-compiled static libs available to MSVC
                fileexists = False
                for libdir in library_dirs:
                    libfile = os.path.join(libdir, 'lib%s.a' % (libname***REMOVED******REMOVED***
                    if os.path.isfile(libfile***REMOVED***:
                        # copy libname.a file to name.lib so that MSVC linker
                        # can find it
                        libfile2 = os.path.join(libdir, '%s.lib' % (libname***REMOVED******REMOVED***
                        copy_file(libfile, libfile2***REMOVED***
                        self.temp_files.append(libfile2***REMOVED***
                        fileexists = True
                        break
                if fileexists: continue
                log.warn('could not find library %r in directories %s' \
                         % (libname, library_dirs***REMOVED******REMOVED***
        elif self.compiler.compiler_type == 'mingw32':
            generate_manifest(self***REMOVED***
        return self._wrap_method(old_config._link, lang,
                                 (body, headers, include_dirs,
                                  libraries, library_dirs, lang***REMOVED******REMOVED***

    def check_header(self, header, include_dirs=None, library_dirs=None, lang='c'***REMOVED***:
        self._check_compiler(***REMOVED***
        return self.try_compile(
                "/* we need a dummy line to make distutils happy */",
                [header***REMOVED***, include_dirs***REMOVED***

    def check_decl(self, symbol,
                   headers=None, include_dirs=None***REMOVED***:
        self._check_compiler(***REMOVED***
        body = ***REMOVED***
int main(void***REMOVED***
{
#ifndef %s
    (void***REMOVED*** %s;
#endif
    ;
    return 0;
***REMOVED******REMOVED*** % (symbol, symbol***REMOVED***

        return self.try_compile(body, headers, include_dirs***REMOVED***

    def check_macro_true(self, symbol,
                         headers=None, include_dirs=None***REMOVED***:
        self._check_compiler(***REMOVED***
        body = ***REMOVED***
int main(void***REMOVED***
{
#if %s
#else
#error false or undefined macro
#endif
    ;
    return 0;
***REMOVED******REMOVED*** % (symbol,***REMOVED***

        return self.try_compile(body, headers, include_dirs***REMOVED***

    def check_type(self, type_name, headers=None, include_dirs=None,
            library_dirs=None***REMOVED***:
        ***REMOVED***Check type availability. Return True if the type can be compiled,
        False otherwise***REMOVED***
        self._check_compiler(***REMOVED***

        # First check the type can be compiled
        body = r***REMOVED***
int main(void***REMOVED*** {
  if ((%(name***REMOVED***s ****REMOVED*** 0***REMOVED***
    return 0;
  if (sizeof (%(name***REMOVED***s***REMOVED******REMOVED***
    return 0;
***REMOVED***
***REMOVED*** % {'name': type_name***REMOVED***

        st = False
        ***REMOVED***
            ***REMOVED***
                self._compile(body % {'type': type_name***REMOVED***,
                        headers, include_dirs, 'c'***REMOVED***
                st = True
            except distutils.errors.CompileError:
                st = False
        finally:
            self._clean(***REMOVED***

        return st

    def check_type_size(self, type_name, headers=None, include_dirs=None, library_dirs=None, expected=None***REMOVED***:
        ***REMOVED***Check size of a given type.***REMOVED***
        self._check_compiler(***REMOVED***

        # First check the type can be compiled
        body = r***REMOVED***
typedef %(type***REMOVED***s npy_check_sizeof_type;
int main (void***REMOVED***
{
    static int test_array [1 - 2 * !(((long***REMOVED*** (sizeof (npy_check_sizeof_type***REMOVED******REMOVED******REMOVED*** >= 0***REMOVED******REMOVED***;
    test_array [0***REMOVED*** = 0

    ;
    return 0;
***REMOVED***
***REMOVED***
        self._compile(body % {'type': type_name***REMOVED***,
                headers, include_dirs, 'c'***REMOVED***
        self._clean(***REMOVED***

        if expected:
            body = r***REMOVED***
typedef %(type***REMOVED***s npy_check_sizeof_type;
int main (void***REMOVED***
{
    static int test_array [1 - 2 * !(((long***REMOVED*** (sizeof (npy_check_sizeof_type***REMOVED******REMOVED******REMOVED*** == %(size***REMOVED***s***REMOVED******REMOVED***;
    test_array [0***REMOVED*** = 0

    ;
    return 0;
***REMOVED***
***REMOVED***
            for size in expected:
                ***REMOVED***
                    self._compile(body % {'type': type_name, 'size': size***REMOVED***,
                            headers, include_dirs, 'c'***REMOVED***
                    self._clean(***REMOVED***
                    return size
                except CompileError:
                    pass

        # this fails to *compile* if size > sizeof(type***REMOVED***
        body = r***REMOVED***
typedef %(type***REMOVED***s npy_check_sizeof_type;
int main (void***REMOVED***
{
    static int test_array [1 - 2 * !(((long***REMOVED*** (sizeof (npy_check_sizeof_type***REMOVED******REMOVED******REMOVED*** <= %(size***REMOVED***s***REMOVED******REMOVED***;
    test_array [0***REMOVED*** = 0

    ;
    return 0;
***REMOVED***
***REMOVED***

        # The principle is simple: we first find low and high bounds of size
        # for the type, where low/high are looked up on a log scale. Then, we
        # do a binary search to find the exact size between low and high
        low = 0
        mid = 0
        while True:
            ***REMOVED***
                self._compile(body % {'type': type_name, 'size': mid***REMOVED***,
                        headers, include_dirs, 'c'***REMOVED***
                self._clean(***REMOVED***
                break
            except CompileError:
                #log.info("failure to test for bound %d" % mid***REMOVED***
                low = mid + 1
                mid = 2 * mid + 1

        high = mid
        # Binary search:
        while low != high:
            mid = (high - low***REMOVED*** // 2 + low
            ***REMOVED***
                self._compile(body % {'type': type_name, 'size': mid***REMOVED***,
                        headers, include_dirs, 'c'***REMOVED***
                self._clean(***REMOVED***
                high = mid
            except CompileError:
                low = mid + 1
        return low

    def check_func(self, func,
                   headers=None, include_dirs=None,
                   libraries=None, library_dirs=None,
                   decl=False, call=False, call_args=None***REMOVED***:
        # clean up distutils's config a bit: add void to main(***REMOVED***, and
        # return a value.
        self._check_compiler(***REMOVED***
        body = [***REMOVED***
        if decl:
            if type(decl***REMOVED*** == str:
                body.append(decl***REMOVED***
            else:
                body.append("int %s (void***REMOVED***;" % func***REMOVED***
        # Handle MSVC intrinsics: force MS compiler to make a function call.
        # Useful to test for some functions when built with optimization on, to
        # avoid build error because the intrinsic and our 'fake' test
        # declaration do not match.
        body.append("#ifdef _MSC_VER"***REMOVED***
        body.append("#pragma function(%s***REMOVED***" % func***REMOVED***
        body.append("#endif"***REMOVED***
        body.append("int main (void***REMOVED*** {"***REMOVED***
        if call:
            if call_args is None:
                call_args = ''
            body.append("  %s(%s***REMOVED***;" % (func, call_args***REMOVED******REMOVED***
        else:
            body.append("  %s;" % func***REMOVED***
        body.append("  return 0;"***REMOVED***
        body.append("***REMOVED***"***REMOVED***
        body = '\n'.join(body***REMOVED*** + "\n"

        return self.try_link(body, headers, include_dirs,
                             libraries, library_dirs***REMOVED***

    def check_funcs_once(self, funcs,
                   headers=None, include_dirs=None,
                   libraries=None, library_dirs=None,
                   decl=False, call=False, call_args=None***REMOVED***:
        ***REMOVED***Check a list of functions at once.

        This is useful to speed up things, since all the functions in the funcs
        list will be put in one compilation unit.

        Arguments
        ---------
        funcs : seq
            list of functions to test
        include_dirs : seq
            list of header paths
        libraries : seq
            list of libraries to link the code snippet to
        libraru_dirs : seq
            list of library paths
        decl : dict
            for every (key, value***REMOVED***, the declaration in the value will be
            used for function in key. If a function is not in the
            dictionay, no declaration will be used.
        call : dict
            for every item (f, value***REMOVED***, if the value is True, a call will be
            done to the function f.
        ***REMOVED***
        self._check_compiler(***REMOVED***
        body = [***REMOVED***
        if decl:
            for f, v in decl.items(***REMOVED***:
                if v:
                    body.append("int %s (void***REMOVED***;" % f***REMOVED***

        # Handle MS intrinsics. See check_func for more info.
        body.append("#ifdef _MSC_VER"***REMOVED***
        for func in funcs:
            body.append("#pragma function(%s***REMOVED***" % func***REMOVED***
        body.append("#endif"***REMOVED***

        body.append("int main (void***REMOVED*** {"***REMOVED***
        if call:
            for f in funcs:
                if f in call and call[f***REMOVED***:
                    if not (call_args and f in call_args and call_args[f***REMOVED******REMOVED***:
                        args = ''
                    else:
                        args = call_args[f***REMOVED***
                    body.append("  %s(%s***REMOVED***;" % (f, args***REMOVED******REMOVED***
                else:
                    body.append("  %s;" % f***REMOVED***
        else:
            for f in funcs:
                body.append("  %s;" % f***REMOVED***
        body.append("  return 0;"***REMOVED***
        body.append("***REMOVED***"***REMOVED***
        body = '\n'.join(body***REMOVED*** + "\n"

        return self.try_link(body, headers, include_dirs,
                             libraries, library_dirs***REMOVED***

    def check_inline(self***REMOVED***:
        ***REMOVED***Return the inline keyword recognized by the compiler, empty string
        otherwise.***REMOVED***
        return check_inline(self***REMOVED***

    def check_restrict(self***REMOVED***:
        ***REMOVED***Return the restrict keyword recognized by the compiler, empty string
        otherwise.***REMOVED***
        return check_restrict(self***REMOVED***

    def check_compiler_gcc4(self***REMOVED***:
        ***REMOVED***Return True if the C compiler is gcc >= 4.***REMOVED***
        return check_compiler_gcc4(self***REMOVED***

    def check_gcc_function_attribute(self, attribute, name***REMOVED***:
        return check_gcc_function_attribute(self, attribute, name***REMOVED***

    def check_gcc_variable_attribute(self, attribute***REMOVED***:
        return check_gcc_variable_attribute(self, attribute***REMOVED***

    def get_output(self, body, headers=None, include_dirs=None,
                   libraries=None, library_dirs=None,
                   lang="c", use_tee=None***REMOVED***:
        ***REMOVED***Try to compile, link to an executable, and run a program
        built from 'body' and 'headers'. Returns the exit status code
        of the program and its output.
        ***REMOVED***
        # 2008-11-16, RemoveMe
        warnings.warn("\n+++++++++++++++++++++++++++++++++++++++++++++++++\n" \
                      "Usage of get_output is deprecated: please do not \n" \
                      "use it anymore, and avoid configuration checks \n" \
                      "involving running executable on the target machine.\n" \
                      "+++++++++++++++++++++++++++++++++++++++++++++++++\n",
                      DeprecationWarning***REMOVED***
        from distutils.ccompiler import CompileError, LinkError
        self._check_compiler(***REMOVED***
        exitcode, output = 255, ''
        ***REMOVED***
            grabber = GrabStdout(***REMOVED***
            ***REMOVED***
                src, obj, exe = self._link(body, headers, include_dirs,
                                           libraries, library_dirs, lang***REMOVED***
                grabber.restore(***REMOVED***
            ***REMOVED***
                output = grabber.data
                grabber.restore(***REMOVED***
                raise
            exe = os.path.join('.', exe***REMOVED***
            exitstatus, output = exec_command(exe, execute_in='.',
                                              use_tee=use_tee***REMOVED***
            if hasattr(os, 'WEXITSTATUS'***REMOVED***:
                exitcode = os.WEXITSTATUS(exitstatus***REMOVED***
                if os.WIFSIGNALED(exitstatus***REMOVED***:
                    sig = os.WTERMSIG(exitstatus***REMOVED***
                    log.error('subprocess exited with signal %d' % (sig,***REMOVED******REMOVED***
                    if sig == signal.SIGINT:
                        # control-C
                        raise KeyboardInterrupt
            else:
                exitcode = exitstatus
            log.info("success!"***REMOVED***
        except (CompileError, LinkError***REMOVED***:
            log.info("failure."***REMOVED***
        self._clean(***REMOVED***
        return exitcode, output

class GrabStdout(object***REMOVED***:

    def __init__(self***REMOVED***:
        self.sys_stdout = sys.stdout
        self.data = ''
        sys.stdout = self

    def write (self, data***REMOVED***:
        self.sys_stdout.write(data***REMOVED***
        self.data += data

    def flush (self***REMOVED***:
        self.sys_stdout.flush(***REMOVED***

    def restore(self***REMOVED***:
        sys.stdout = self.sys_stdout
