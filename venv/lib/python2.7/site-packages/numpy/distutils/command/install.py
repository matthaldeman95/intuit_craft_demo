from __future__ import division, absolute_import, print_function

import sys
if 'setuptools' in sys.modules:
    import setuptools.command.install as old_install_mod
    have_setuptools = True
else:
    import distutils.command.install as old_install_mod
    have_setuptools = False
from distutils.file_util import write_file

old_install = old_install_mod.install

class install(old_install***REMOVED***:

    # Always run install_clib - the command is cheap, so no need to bypass it;
    # but it's not run by setuptools -- so it's run again in install_data
    sub_commands = old_install.sub_commands + [
        ('install_clib', lambda x: True***REMOVED***
    ***REMOVED***

    def finalize_options (self***REMOVED***:
        old_install.finalize_options(self***REMOVED***
        self.install_lib = self.install_libbase

    def setuptools_run(self***REMOVED***:
        ***REMOVED*** The setuptools version of the .run(***REMOVED*** method.

        We must pull in the entire code so we can override the level used in the
        _getframe(***REMOVED*** call since we wrap this call by one more level.
        ***REMOVED***
        from distutils.command.install import install as distutils_install

        # Explicit request for old-style install?  Just do it
        if self.old_and_unmanageable or self.single_version_externally_managed:
            return distutils_install.run(self***REMOVED***

        # Attempt to detect whether we were called from setup(***REMOVED*** or by another
        # command.  If we were called by setup(***REMOVED***, our caller will be the
        # 'run_command' method in 'distutils.dist', and *its* caller will be
        # the 'run_commands' method.  If we were called any other way, our
        # immediate caller *might* be 'run_command', but it won't have been
        # called by 'run_commands'.  This is slightly kludgy, but seems to
        # work.
        #
        caller = sys._getframe(3***REMOVED***
        caller_module = caller.f_globals.get('__name__', ''***REMOVED***
        caller_name = caller.f_code.co_name

        if caller_module != 'distutils.dist' or caller_name!='run_commands':
            # We weren't called from the command line or setup(***REMOVED***, so we
            # should run in backward-compatibility mode to support bdist_*
            # commands.
            distutils_install.run(self***REMOVED***
        else:
            self.do_egg_install(***REMOVED***

    def run(self***REMOVED***:
        if not have_setuptools:
            r = old_install.run(self***REMOVED***
        else:
            r = self.setuptools_run(***REMOVED***
        if self.record:
            # bdist_rpm fails when INSTALLED_FILES contains
            # paths with spaces. Such paths must be enclosed
            # with double-quotes.
            f = open(self.record, 'r'***REMOVED***
            lines = [***REMOVED***
            need_rewrite = False
            for l in f:
                l = l.rstrip(***REMOVED***
                if ' ' in l:
                    need_rewrite = True
                    l = '"%s"' % (l***REMOVED***
                lines.append(l***REMOVED***
            f.close(***REMOVED***
            if need_rewrite:
                self.execute(write_file,
                             (self.record, lines***REMOVED***,
                             "re-writing list of installed files to '%s'" %
                             self.record***REMOVED***
        return r
