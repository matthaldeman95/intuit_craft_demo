from __future__ import division, absolute_import, print_function

from distutils.core import Command
from numpy.distutils import log

#XXX: Linker flags

def show_fortran_compilers(_cache=[***REMOVED******REMOVED***:
    # Using cache to prevent infinite recursion
    if _cache: return
    _cache.append(1***REMOVED***
    from numpy.distutils.fcompiler import show_fcompilers
    import distutils.core
    dist = distutils.core._setup_distribution
    show_fcompilers(dist***REMOVED***

class config_fc(Command***REMOVED***:
    ***REMOVED*** Distutils command to hold user specified options
    to Fortran compilers.

    config_fc command is used by the FCompiler.customize(***REMOVED*** method.
    ***REMOVED***

    description = "specify Fortran 77/Fortran 90 compiler information"

    user_options = [
        ('fcompiler=', None, "specify Fortran compiler type"***REMOVED***,
        ('f77exec=', None, "specify F77 compiler command"***REMOVED***,
        ('f90exec=', None, "specify F90 compiler command"***REMOVED***,
        ('f77flags=', None, "specify F77 compiler flags"***REMOVED***,
        ('f90flags=', None, "specify F90 compiler flags"***REMOVED***,
        ('opt=', None, "specify optimization flags"***REMOVED***,
        ('arch=', None, "specify architecture specific optimization flags"***REMOVED***,
        ('debug', 'g', "compile with debugging information"***REMOVED***,
        ('noopt', None, "compile without optimization"***REMOVED***,
        ('noarch', None, "compile without arch-dependent optimization"***REMOVED***,
        ***REMOVED***

    help_options = [
        ('help-fcompiler', None, "list available Fortran compilers",
         show_fortran_compilers***REMOVED***,
        ***REMOVED***

    boolean_options = ['debug', 'noopt', 'noarch'***REMOVED***

    def initialize_options(self***REMOVED***:
        self.fcompiler = None
        self.f77exec = None
        self.f90exec = None
        self.f77flags = None
        self.f90flags = None
        self.opt = None
        self.arch = None
        self.debug = None
        self.noopt = None
        self.noarch = None

    def finalize_options(self***REMOVED***:
        log.info('unifing config_fc, config, build_clib, build_ext, build commands --fcompiler options'***REMOVED***
        build_clib = self.get_finalized_command('build_clib'***REMOVED***
        build_ext = self.get_finalized_command('build_ext'***REMOVED***
        config = self.get_finalized_command('config'***REMOVED***
        build = self.get_finalized_command('build'***REMOVED***
        cmd_list = [self, config, build_clib, build_ext, build***REMOVED***
        for a in ['fcompiler'***REMOVED***:
            l = [***REMOVED***
            for c in cmd_list:
                v = getattr(c, a***REMOVED***
                if v is not None:
                    if not isinstance(v, str***REMOVED***: v = v.compiler_type
                    if v not in l: l.append(v***REMOVED***
            if not l: v1 = None
            else: v1 = l[0***REMOVED***
            if len(l***REMOVED***>1:
                log.warn('  commands have different --%s options: %s'\
                         ', using first in list as default' % (a, l***REMOVED******REMOVED***
            if v1:
                for c in cmd_list:
                    if getattr(c, a***REMOVED*** is None: setattr(c, a, v1***REMOVED***

    def run(self***REMOVED***:
        # Do nothing.
        return

class config_cc(Command***REMOVED***:
    ***REMOVED*** Distutils command to hold user specified options
    to C/C++ compilers.
    ***REMOVED***

    description = "specify C/C++ compiler information"

    user_options = [
        ('compiler=', None, "specify C/C++ compiler type"***REMOVED***,
        ***REMOVED***

    def initialize_options(self***REMOVED***:
        self.compiler = None

    def finalize_options(self***REMOVED***:
        log.info('unifing config_cc, config, build_clib, build_ext, build commands --compiler options'***REMOVED***
        build_clib = self.get_finalized_command('build_clib'***REMOVED***
        build_ext = self.get_finalized_command('build_ext'***REMOVED***
        config = self.get_finalized_command('config'***REMOVED***
        build = self.get_finalized_command('build'***REMOVED***
        cmd_list = [self, config, build_clib, build_ext, build***REMOVED***
        for a in ['compiler'***REMOVED***:
            l = [***REMOVED***
            for c in cmd_list:
                v = getattr(c, a***REMOVED***
                if v is not None:
                    if not isinstance(v, str***REMOVED***: v = v.compiler_type
                    if v not in l: l.append(v***REMOVED***
            if not l: v1 = None
            else: v1 = l[0***REMOVED***
            if len(l***REMOVED***>1:
                log.warn('  commands have different --%s options: %s'\
                         ', using first in list as default' % (a, l***REMOVED******REMOVED***
            if v1:
                for c in cmd_list:
                    if getattr(c, a***REMOVED*** is None: setattr(c, a, v1***REMOVED***
        return

    def run(self***REMOVED***:
        # Do nothing.
        return
