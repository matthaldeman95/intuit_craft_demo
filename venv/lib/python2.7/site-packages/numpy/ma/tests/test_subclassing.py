# pylint: disable-msg=W0611, W0612, W0511,R0201
***REMOVED***Tests suite for MaskedArray & subclassing.

:author: Pierre Gerard-Marchant
:contact: pierregm_at_uga_dot_edu
:version: $Id: test_subclassing.py 3473 2007-10-29 15:18:13Z jarrod.millman $

***REMOVED***
from __future__ import division, absolute_import, print_function

import numpy as np
from numpy.testing import TestCase, run_module_suite, assert_raises
from numpy.ma.testutils import assert_equal
from numpy.ma.core import (
    array, arange, masked, MaskedArray, masked_array, log, add, hypot,
    divide, asarray, asanyarray, nomask
    ***REMOVED***
# from numpy.ma.core import (


class SubArray(np.ndarray***REMOVED***:
    # Defines a generic np.ndarray subclass, that stores some metadata
    # in the  dictionary `info`.
    def __new__(cls,arr,info={***REMOVED******REMOVED***:
        x = np.asanyarray(arr***REMOVED***.view(cls***REMOVED***
        x.info = info.copy(***REMOVED***
        return x

    def __array_finalize__(self, obj***REMOVED***:
        if callable(getattr(super(SubArray, self***REMOVED***,
                            '__array_finalize__', None***REMOVED******REMOVED***:
            super(SubArray, self***REMOVED***.__array_finalize__(obj***REMOVED***
        self.info = getattr(obj, 'info', {***REMOVED******REMOVED***.copy(***REMOVED***
        return

    def __add__(self, other***REMOVED***:
        result = super(SubArray, self***REMOVED***.__add__(other***REMOVED***
        result.info['added'***REMOVED*** = result.info.get('added', 0***REMOVED*** + 1
        return result

    def __iadd__(self, other***REMOVED***:
        result = super(SubArray, self***REMOVED***.__iadd__(other***REMOVED***
        result.info['iadded'***REMOVED*** = result.info.get('iadded', 0***REMOVED*** + 1
        return result


subarray = SubArray


class SubMaskedArray(MaskedArray***REMOVED***:
    ***REMOVED***Pure subclass of MaskedArray, keeping some info on subclass.***REMOVED***
    def __new__(cls, info=None, **kwargs***REMOVED***:
        obj = super(SubMaskedArray, cls***REMOVED***.__new__(cls, **kwargs***REMOVED***
        obj._optinfo['info'***REMOVED*** = info
        return obj


class MSubArray(SubArray, MaskedArray***REMOVED***:

    def __new__(cls, data, info={***REMOVED***, mask=nomask***REMOVED***:
        subarr = SubArray(data, info***REMOVED***
        _data = MaskedArray.__new__(cls, data=subarr, mask=mask***REMOVED***
        _data.info = subarr.info
        return _data

    def _get_series(self***REMOVED***:
        _view = self.view(MaskedArray***REMOVED***
        _view._sharedmask = False
        return _view
    _series = property(fget=_get_series***REMOVED***

msubarray = MSubArray


class MMatrix(MaskedArray, np.matrix,***REMOVED***:

    def __new__(cls, data, mask=nomask***REMOVED***:
        mat = np.matrix(data***REMOVED***
        _data = MaskedArray.__new__(cls, data=mat, mask=mask***REMOVED***
        return _data

    def __array_finalize__(self, obj***REMOVED***:
        np.matrix.__array_finalize__(self, obj***REMOVED***
        MaskedArray.__array_finalize__(self, obj***REMOVED***
        return

    def _get_series(self***REMOVED***:
        _view = self.view(MaskedArray***REMOVED***
        _view._sharedmask = False
        return _view
    _series = property(fget=_get_series***REMOVED***

mmatrix = MMatrix


# Also a subclass that overrides __str__, __repr__ and __setitem__, disallowing
# setting to non-class values (and thus np.ma.core.masked_print_option***REMOVED***
# and overrides __array_wrap__, updating the info dict, to check that this
# doesn't get destroyed by MaskedArray._update_from.  But this one also needs
# its own iterator...
class CSAIterator(object***REMOVED***:
    ***REMOVED***
    Flat iterator object that uses its own setter/getter
    (works around ndarray.flat not propagating subclass setters/getters
    see https://github.com/numpy/numpy/issues/4564***REMOVED***
    roughly following MaskedIterator
    ***REMOVED***
    def __init__(self, a***REMOVED***:
        self._original = a
        self._dataiter = a.view(np.ndarray***REMOVED***.flat

    def __iter__(self***REMOVED***:
        return self

    def __getitem__(self, indx***REMOVED***:
        out = self._dataiter.__getitem__(indx***REMOVED***
        if not isinstance(out, np.ndarray***REMOVED***:
            out = out.__array__(***REMOVED***
        out = out.view(type(self._original***REMOVED******REMOVED***
        return out

    def __setitem__(self, index, value***REMOVED***:
        self._dataiter[index***REMOVED*** = self._original._validate_input(value***REMOVED***

    def __next__(self***REMOVED***:
        return next(self._dataiter***REMOVED***.__array__(***REMOVED***.view(type(self._original***REMOVED******REMOVED***

    next = __next__


class ComplicatedSubArray(SubArray***REMOVED***:

    def __str__(self***REMOVED***:
        return 'myprefix {0***REMOVED*** mypostfix'.format(self.view(SubArray***REMOVED******REMOVED***

    def __repr__(self***REMOVED***:
        # Return a repr that does not start with 'name('
        return '<{0***REMOVED*** {1***REMOVED***>'.format(self.__class__.__name__, self***REMOVED***

    def _validate_input(self, value***REMOVED***:
        if not isinstance(value, ComplicatedSubArray***REMOVED***:
            raise ValueError("Can only set to MySubArray values"***REMOVED***
        return value

    def __setitem__(self, item, value***REMOVED***:
        # validation ensures direct assignment with ndarray or
        # masked_print_option will fail
        super(ComplicatedSubArray, self***REMOVED***.__setitem__(
            item, self._validate_input(value***REMOVED******REMOVED***

    def __getitem__(self, item***REMOVED***:
        # ensure getter returns our own class also for scalars
        value = super(ComplicatedSubArray, self***REMOVED***.__getitem__(item***REMOVED***
        if not isinstance(value, np.ndarray***REMOVED***:  # scalar
            value = value.__array__(***REMOVED***.view(ComplicatedSubArray***REMOVED***
        return value

    @property
    def flat(self***REMOVED***:
        return CSAIterator(self***REMOVED***

    @flat.setter
    def flat(self, value***REMOVED***:
        y = self.ravel(***REMOVED***
        y[:***REMOVED*** = value

    def __array_wrap__(self, obj, context=None***REMOVED***:
        obj = super(ComplicatedSubArray, self***REMOVED***.__array_wrap__(obj, context***REMOVED***
        if context is not None and context[0***REMOVED*** is np.multiply:
            obj.info['multiplied'***REMOVED*** = obj.info.get('multiplied', 0***REMOVED*** + 1

        return obj


class TestSubclassing(TestCase***REMOVED***:
    # Test suite for masked subclasses of ndarray.

    def setUp(self***REMOVED***:
        x = np.arange(5***REMOVED***
        mx = mmatrix(x, mask=[0, 1, 0, 0, 0***REMOVED******REMOVED***
        self.data = (x, mx***REMOVED***

    def test_data_subclassing(self***REMOVED***:
        # Tests whether the subclass is kept.
        x = np.arange(5***REMOVED***
        m = [0, 0, 1, 0, 0***REMOVED***
        xsub = SubArray(x***REMOVED***
        xmsub = masked_array(xsub, mask=m***REMOVED***
        self.assertTrue(isinstance(xmsub, MaskedArray***REMOVED******REMOVED***
        assert_equal(xmsub._data, xsub***REMOVED***
        self.assertTrue(isinstance(xmsub._data, SubArray***REMOVED******REMOVED***

    def test_maskedarray_subclassing(self***REMOVED***:
        # Tests subclassing MaskedArray
        (x, mx***REMOVED*** = self.data
        self.assertTrue(isinstance(mx._data, np.matrix***REMOVED******REMOVED***

    def test_masked_unary_operations(self***REMOVED***:
        # Tests masked_unary_operation
        (x, mx***REMOVED*** = self.data
        with np.errstate(divide='ignore'***REMOVED***:
            self.assertTrue(isinstance(log(mx***REMOVED***, mmatrix***REMOVED******REMOVED***
            assert_equal(log(x***REMOVED***, np.log(x***REMOVED******REMOVED***

    def test_masked_binary_operations(self***REMOVED***:
        # Tests masked_binary_operation
        (x, mx***REMOVED*** = self.data
        # Result should be a mmatrix
        self.assertTrue(isinstance(add(mx, mx***REMOVED***, mmatrix***REMOVED******REMOVED***
        self.assertTrue(isinstance(add(mx, x***REMOVED***, mmatrix***REMOVED******REMOVED***
        # Result should work
        assert_equal(add(mx, x***REMOVED***, mx+x***REMOVED***
        self.assertTrue(isinstance(add(mx, mx***REMOVED***._data, np.matrix***REMOVED******REMOVED***
        self.assertTrue(isinstance(add.outer(mx, mx***REMOVED***, mmatrix***REMOVED******REMOVED***
        self.assertTrue(isinstance(hypot(mx, mx***REMOVED***, mmatrix***REMOVED******REMOVED***
        self.assertTrue(isinstance(hypot(mx, x***REMOVED***, mmatrix***REMOVED******REMOVED***

    def test_masked_binary_operations2(self***REMOVED***:
        # Tests domained_masked_binary_operation
        (x, mx***REMOVED*** = self.data
        xmx = masked_array(mx.data.__array__(***REMOVED***, mask=mx.mask***REMOVED***
        self.assertTrue(isinstance(divide(mx, mx***REMOVED***, mmatrix***REMOVED******REMOVED***
        self.assertTrue(isinstance(divide(mx, x***REMOVED***, mmatrix***REMOVED******REMOVED***
        assert_equal(divide(mx, mx***REMOVED***, divide(xmx, xmx***REMOVED******REMOVED***

    def test_attributepropagation(self***REMOVED***:
        x = array(arange(5***REMOVED***, mask=[0***REMOVED***+[1***REMOVED****4***REMOVED***
        my = masked_array(subarray(x***REMOVED******REMOVED***
        ym = msubarray(x***REMOVED***
        #
        z = (my+1***REMOVED***
        self.assertTrue(isinstance(z, MaskedArray***REMOVED******REMOVED***
        self.assertTrue(not isinstance(z, MSubArray***REMOVED******REMOVED***
        self.assertTrue(isinstance(z._data, SubArray***REMOVED******REMOVED***
        assert_equal(z._data.info, {***REMOVED******REMOVED***
        #
        z = (ym+1***REMOVED***
        self.assertTrue(isinstance(z, MaskedArray***REMOVED******REMOVED***
        self.assertTrue(isinstance(z, MSubArray***REMOVED******REMOVED***
        self.assertTrue(isinstance(z._data, SubArray***REMOVED******REMOVED***
        self.assertTrue(z._data.info['added'***REMOVED*** > 0***REMOVED***
        # Test that inplace methods from data get used (gh-4617***REMOVED***
        ym += 1
        self.assertTrue(isinstance(ym, MaskedArray***REMOVED******REMOVED***
        self.assertTrue(isinstance(ym, MSubArray***REMOVED******REMOVED***
        self.assertTrue(isinstance(ym._data, SubArray***REMOVED******REMOVED***
        self.assertTrue(ym._data.info['iadded'***REMOVED*** > 0***REMOVED***
        #
        ym._set_mask([1, 0, 0, 0, 1***REMOVED******REMOVED***
        assert_equal(ym._mask, [1, 0, 0, 0, 1***REMOVED******REMOVED***
        ym._series._set_mask([0, 0, 0, 0, 1***REMOVED******REMOVED***
        assert_equal(ym._mask, [0, 0, 0, 0, 1***REMOVED******REMOVED***
        #
        xsub = subarray(x, info={'name':'x'***REMOVED******REMOVED***
        mxsub = masked_array(xsub***REMOVED***
        self.assertTrue(hasattr(mxsub, 'info'***REMOVED******REMOVED***
        assert_equal(mxsub.info, xsub.info***REMOVED***

    def test_subclasspreservation(self***REMOVED***:
        # Checks that masked_array(...,subok=True***REMOVED*** preserves the class.
        x = np.arange(5***REMOVED***
        m = [0, 0, 1, 0, 0***REMOVED***
        xinfo = [(i, j***REMOVED*** for (i, j***REMOVED*** in zip(x, m***REMOVED******REMOVED***
        xsub = MSubArray(x, mask=m, info={'xsub':xinfo***REMOVED******REMOVED***
        #
        mxsub = masked_array(xsub, subok=False***REMOVED***
        self.assertTrue(not isinstance(mxsub, MSubArray***REMOVED******REMOVED***
        self.assertTrue(isinstance(mxsub, MaskedArray***REMOVED******REMOVED***
        assert_equal(mxsub._mask, m***REMOVED***
        #
        mxsub = asarray(xsub***REMOVED***
        self.assertTrue(not isinstance(mxsub, MSubArray***REMOVED******REMOVED***
        self.assertTrue(isinstance(mxsub, MaskedArray***REMOVED******REMOVED***
        assert_equal(mxsub._mask, m***REMOVED***
        #
        mxsub = masked_array(xsub, subok=True***REMOVED***
        self.assertTrue(isinstance(mxsub, MSubArray***REMOVED******REMOVED***
        assert_equal(mxsub.info, xsub.info***REMOVED***
        assert_equal(mxsub._mask, xsub._mask***REMOVED***
        #
        mxsub = asanyarray(xsub***REMOVED***
        self.assertTrue(isinstance(mxsub, MSubArray***REMOVED******REMOVED***
        assert_equal(mxsub.info, xsub.info***REMOVED***
        assert_equal(mxsub._mask, m***REMOVED***

    def test_subclass_items(self***REMOVED***:
        ***REMOVED***test that getter and setter go via baseclass***REMOVED***
        x = np.arange(5***REMOVED***
        xcsub = ComplicatedSubArray(x***REMOVED***
        mxcsub = masked_array(xcsub, mask=[True, False, True, False, False***REMOVED******REMOVED***
        # getter should  return a ComplicatedSubArray, even for single item
        # first check we wrote ComplicatedSubArray correctly
        self.assertTrue(isinstance(xcsub[1***REMOVED***, ComplicatedSubArray***REMOVED******REMOVED***
        self.assertTrue(isinstance(xcsub[1:4***REMOVED***, ComplicatedSubArray***REMOVED******REMOVED***
        # now that it propagates inside the MaskedArray
        self.assertTrue(isinstance(mxcsub[1***REMOVED***, ComplicatedSubArray***REMOVED******REMOVED***
        self.assertTrue(mxcsub[0***REMOVED*** is masked***REMOVED***
        self.assertTrue(isinstance(mxcsub[1:4***REMOVED***.data, ComplicatedSubArray***REMOVED******REMOVED***
        # also for flattened version (which goes via MaskedIterator***REMOVED***
        self.assertTrue(isinstance(mxcsub.flat[1***REMOVED***.data, ComplicatedSubArray***REMOVED******REMOVED***
        self.assertTrue(mxcsub[0***REMOVED*** is masked***REMOVED***
        self.assertTrue(isinstance(mxcsub.flat[1:4***REMOVED***.base, ComplicatedSubArray***REMOVED******REMOVED***

        # setter should only work with ComplicatedSubArray input
        # first check we wrote ComplicatedSubArray correctly
        assert_raises(ValueError, xcsub.__setitem__, 1, x[4***REMOVED******REMOVED***
        # now that it propagates inside the MaskedArray
        assert_raises(ValueError, mxcsub.__setitem__, 1, x[4***REMOVED******REMOVED***
        assert_raises(ValueError, mxcsub.__setitem__, slice(1, 4***REMOVED***, x[1:4***REMOVED******REMOVED***
        mxcsub[1***REMOVED*** = xcsub[4***REMOVED***
        mxcsub[1:4***REMOVED*** = xcsub[1:4***REMOVED***
        # also for flattened version (which goes via MaskedIterator***REMOVED***
        assert_raises(ValueError, mxcsub.flat.__setitem__, 1, x[4***REMOVED******REMOVED***
        assert_raises(ValueError, mxcsub.flat.__setitem__, slice(1, 4***REMOVED***, x[1:4***REMOVED******REMOVED***
        mxcsub.flat[1***REMOVED*** = xcsub[4***REMOVED***
        mxcsub.flat[1:4***REMOVED*** = xcsub[1:4***REMOVED***

    def test_subclass_repr(self***REMOVED***:
        ***REMOVED***test that repr uses the name of the subclass
        and 'array' for np.ndarray***REMOVED***
        x = np.arange(5***REMOVED***
        mx = masked_array(x, mask=[True, False, True, False, False***REMOVED******REMOVED***
        self.assertTrue(repr(mx***REMOVED***.startswith('masked_array'***REMOVED******REMOVED***
        xsub = SubArray(x***REMOVED***
        mxsub = masked_array(xsub, mask=[True, False, True, False, False***REMOVED******REMOVED***
        self.assertTrue(repr(mxsub***REMOVED***.startswith(
            'masked_{0***REMOVED***(data = [-- 1 -- 3 4***REMOVED***'.format(SubArray.__name__***REMOVED******REMOVED******REMOVED***

    def test_subclass_str(self***REMOVED***:
        ***REMOVED***test str with subclass that has overridden str, setitem***REMOVED***
        # first without override
        x = np.arange(5***REMOVED***
        xsub = SubArray(x***REMOVED***
        mxsub = masked_array(xsub, mask=[True, False, True, False, False***REMOVED******REMOVED***
        self.assertTrue(str(mxsub***REMOVED*** == '[-- 1 -- 3 4***REMOVED***'***REMOVED***

        xcsub = ComplicatedSubArray(x***REMOVED***
        assert_raises(ValueError, xcsub.__setitem__, 0,
                      np.ma.core.masked_print_option***REMOVED***
        mxcsub = masked_array(xcsub, mask=[True, False, True, False, False***REMOVED******REMOVED***
        self.assertTrue(str(mxcsub***REMOVED*** == 'myprefix [-- 1 -- 3 4***REMOVED*** mypostfix'***REMOVED***

    def test_pure_subclass_info_preservation(self***REMOVED***:
        # Test that ufuncs and methods conserve extra information consistently;
        # see gh-7122.
        arr1 = SubMaskedArray('test', data=[1,2,3,4,5,6***REMOVED******REMOVED***
        arr2 = SubMaskedArray(data=[0,1,2,3,4,5***REMOVED******REMOVED***
        diff1 = np.subtract(arr1, arr2***REMOVED***
        self.assertTrue('info' in diff1._optinfo***REMOVED***
        self.assertTrue(diff1._optinfo['info'***REMOVED*** == 'test'***REMOVED***
        diff2 = arr1 - arr2
        self.assertTrue('info' in diff2._optinfo***REMOVED***
        self.assertTrue(diff2._optinfo['info'***REMOVED*** == 'test'***REMOVED***


###############################################################################
if __name__ == '__main__':
    run_module_suite(***REMOVED***
