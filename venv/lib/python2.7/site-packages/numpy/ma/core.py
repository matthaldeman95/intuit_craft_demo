***REMOVED***
numpy.ma : a package to handle missing or invalid values.

This package was initially written for numarray by Paul F. Dubois
at Lawrence Livermore National Laboratory.
In 2006, the package was completely rewritten by Pierre Gerard-Marchant
(University of Georgia***REMOVED*** to make the MaskedArray class a subclass of ndarray,
and to improve support of structured arrays.


Copyright 1999, 2000, 2001 Regents of the University of California.
Released for unlimited redistribution.

* Adapted for numpy_core 2005 by Travis Oliphant and (mainly***REMOVED*** Paul Dubois.
* Subclassing of the base `ndarray` 2006 by Pierre Gerard-Marchant
  (pgmdevlist_AT_gmail_DOT_com***REMOVED***
* Improvements suggested by Reggie Dugard (reggie_AT_merfinllc_DOT_com***REMOVED***

.. moduleauthor:: Pierre Gerard-Marchant

***REMOVED***
# pylint: disable-msg=E1002
from __future__ import division, absolute_import, print_function

import sys
import warnings
from functools import reduce

if sys.version_info[0***REMOVED*** >= 3:
    import builtins
else:
    import __builtin__ as builtins

import numpy as np
import numpy.core.umath as umath
import numpy.core.numerictypes as ntypes
from numpy import ndarray, amax, amin, iscomplexobj, bool_, _NoValue
from numpy import array as narray
from numpy.lib.function_base import angle
from numpy.compat import (
    getargspec, formatargspec, long, basestring, unicode, bytes, sixu
    ***REMOVED***
from numpy import expand_dims as n_expand_dims


if sys.version_info[0***REMOVED*** >= 3:
    import pickle
else:
    import cPickle as pickle

__all__ = [
    'MAError', 'MaskError', 'MaskType', 'MaskedArray', 'abs', 'absolute',
    'add', 'all', 'allclose', 'allequal', 'alltrue', 'amax', 'amin',
    'angle', 'anom', 'anomalies', 'any', 'append', 'arange', 'arccos',
    'arccosh', 'arcsin', 'arcsinh', 'arctan', 'arctan2', 'arctanh',
    'argmax', 'argmin', 'argsort', 'around', 'array', 'asanyarray',
    'asarray', 'bitwise_and', 'bitwise_or', 'bitwise_xor', 'bool_', 'ceil',
    'choose', 'clip', 'common_fill_value', 'compress', 'compressed',
    'concatenate', 'conjugate', 'copy', 'cos', 'cosh', 'count', 'cumprod',
    'cumsum', 'default_fill_value', 'diag', 'diagonal', 'diff', 'divide',
    'dump', 'dumps', 'empty', 'empty_like', 'equal', 'exp', 'expand_dims',
    'fabs', 'filled', 'fix_invalid', 'flatten_mask',
    'flatten_structured_array', 'floor', 'floor_divide', 'fmod',
    'frombuffer', 'fromflex', 'fromfunction', 'getdata', 'getmask',
    'getmaskarray', 'greater', 'greater_equal', 'harden_mask', 'hypot',
    'identity', 'ids', 'indices', 'inner', 'innerproduct', 'isMA',
    'isMaskedArray', 'is_mask', 'is_masked', 'isarray', 'left_shift',
    'less', 'less_equal', 'load', 'loads', 'log', 'log10', 'log2',
    'logical_and', 'logical_not', 'logical_or', 'logical_xor', 'make_mask',
    'make_mask_descr', 'make_mask_none', 'mask_or', 'masked',
    'masked_array', 'masked_equal', 'masked_greater',
    'masked_greater_equal', 'masked_inside', 'masked_invalid',
    'masked_less', 'masked_less_equal', 'masked_not_equal',
    'masked_object', 'masked_outside', 'masked_print_option',
    'masked_singleton', 'masked_values', 'masked_where', 'max', 'maximum',
    'maximum_fill_value', 'mean', 'min', 'minimum', 'minimum_fill_value',
    'mod', 'multiply', 'mvoid', 'ndim', 'negative', 'nomask', 'nonzero',
    'not_equal', 'ones', 'outer', 'outerproduct', 'power', 'prod',
    'product', 'ptp', 'put', 'putmask', 'rank', 'ravel', 'remainder',
    'repeat', 'reshape', 'resize', 'right_shift', 'round', 'round_',
    'set_fill_value', 'shape', 'sin', 'sinh', 'size', 'soften_mask',
    'sometrue', 'sort', 'sqrt', 'squeeze', 'std', 'subtract', 'sum',
    'swapaxes', 'take', 'tan', 'tanh', 'trace', 'transpose', 'true_divide',
    'var', 'where', 'zeros',
    ***REMOVED***

MaskType = np.bool_
nomask = MaskType(0***REMOVED***

class MaskedArrayFutureWarning(FutureWarning***REMOVED***:
    pass


def doc_note(initialdoc, note***REMOVED***:
    ***REMOVED***
    Adds a Notes section to an existing docstring.

    ***REMOVED***
    if initialdoc is None:
        return
    if note is None:
        return initialdoc
    newdoc = ***REMOVED***
    %s

    Notes
    -----
    %s
    ***REMOVED***
    return newdoc % (initialdoc, note***REMOVED***


def get_object_signature(obj***REMOVED***:
    ***REMOVED***
    Get the signature from obj

    ***REMOVED***
    ***REMOVED***
        sig = formatargspec(*getargspec(obj***REMOVED******REMOVED***
    except TypeError:
        sig = ''
    return sig


###############################################################################
#                              Exceptions                                     #
###############################################################################


class MAError(Exception***REMOVED***:
    ***REMOVED***
    Class for masked array related errors.

    ***REMOVED***
    pass


class MaskError(MAError***REMOVED***:
    ***REMOVED***
    Class for mask related errors.

    ***REMOVED***
    pass


###############################################################################
#                           Filling options                                   #
###############################################################################


# b: boolean - c: complex - f: floats - i: integer - O: object - S: string
default_filler = {'b': True,
                  'c': 1.e20 + 0.0j,
                  'f': 1.e20,
                  'i': 999999,
                  'O': '?',
                  'S': b'N/A',
                  'u': 999999,
                  'V': '???',
                  'U': sixu('N/A'***REMOVED***
              ***REMOVED***

# Add datetime64 and timedelta64 types
for v in ["Y", "M", "W", "D", "h", "m", "s", "ms", "us", "ns", "ps",
          "fs", "as"***REMOVED***:
    default_filler["M8[" + v + "***REMOVED***"***REMOVED*** = np.datetime64("NaT", v***REMOVED***
    default_filler["m8[" + v + "***REMOVED***"***REMOVED*** = np.timedelta64("NaT", v***REMOVED***

max_filler = ntypes._minvals
max_filler.update([(k, -np.inf***REMOVED*** for k in [np.float32, np.float64***REMOVED******REMOVED******REMOVED***
min_filler = ntypes._maxvals
min_filler.update([(k, +np.inf***REMOVED*** for k in [np.float32, np.float64***REMOVED******REMOVED******REMOVED***
if 'float128' in ntypes.typeDict:
    max_filler.update([(np.float128, -np.inf***REMOVED******REMOVED******REMOVED***
    min_filler.update([(np.float128, +np.inf***REMOVED******REMOVED******REMOVED***


def default_fill_value(obj***REMOVED***:
    ***REMOVED***
    Return the default fill value for the argument object.

    The default filling value depends on the datatype of the input
    array or the type of the input scalar:

       ========  ========
       datatype  default
       ========  ========
       bool      True
       int       999999
       float     1.e20
       complex   1.e20+0j
       object    '?'
       string    'N/A'
       ========  ========


    Parameters
    ----------
    obj : ndarray, dtype or scalar
        The array data-type or scalar for which the default fill value
        is returned.

    Returns
    -------
    fill_value : scalar
        The default fill value.

    Examples
    --------
    >>> np.ma.default_fill_value(1***REMOVED***
    999999
    >>> np.ma.default_fill_value(np.array([1.1, 2., np.pi***REMOVED******REMOVED******REMOVED***
    1e+20
    >>> np.ma.default_fill_value(np.dtype(complex***REMOVED******REMOVED***
    (1e+20+0j***REMOVED***

    ***REMOVED***
    if hasattr(obj, 'dtype'***REMOVED***:
        defval = _check_fill_value(None, obj.dtype***REMOVED***
    elif isinstance(obj, np.dtype***REMOVED***:
        if obj.subdtype:
            defval = default_filler.get(obj.subdtype[0***REMOVED***.kind, '?'***REMOVED***
        elif obj.kind in 'Mm':
            defval = default_filler.get(obj.str[1:***REMOVED***, '?'***REMOVED***
        else:
            defval = default_filler.get(obj.kind, '?'***REMOVED***
    elif isinstance(obj, float***REMOVED***:
        defval = default_filler['f'***REMOVED***
    elif isinstance(obj, int***REMOVED*** or isinstance(obj, long***REMOVED***:
        defval = default_filler['i'***REMOVED***
    elif isinstance(obj, bytes***REMOVED***:
        defval = default_filler['S'***REMOVED***
    elif isinstance(obj, unicode***REMOVED***:
        defval = default_filler['U'***REMOVED***
    elif isinstance(obj, complex***REMOVED***:
        defval = default_filler['c'***REMOVED***
    else:
        defval = default_filler['O'***REMOVED***
    return defval


def _recursive_extremum_fill_value(ndtype, extremum***REMOVED***:
    names = ndtype.names
    if names:
        deflist = [***REMOVED***
        for name in names:
            fval = _recursive_extremum_fill_value(ndtype[name***REMOVED***, extremum***REMOVED***
            deflist.append(fval***REMOVED***
        return tuple(deflist***REMOVED***
    return extremum[ndtype***REMOVED***


def minimum_fill_value(obj***REMOVED***:
    ***REMOVED***
    Return the maximum value that can be represented by the dtype of an object.

    This function is useful for calculating a fill value suitable for
    taking the minimum of an array with a given dtype.

    Parameters
    ----------
    obj : ndarray or dtype
        An object that can be queried for it's numeric type.

    Returns
    -------
    val : scalar
        The maximum representable value.

    Raises
    ------
    TypeError
        If `obj` isn't a suitable numeric type.

    See Also
    --------
    maximum_fill_value : The inverse function.
    set_fill_value : Set the filling value of a masked array.
    MaskedArray.fill_value : Return current fill value.

    Examples
    --------
    >>> import numpy.ma as ma
    >>> a = np.int8(***REMOVED***
    >>> ma.minimum_fill_value(a***REMOVED***
    127
    >>> a = np.int32(***REMOVED***
    >>> ma.minimum_fill_value(a***REMOVED***
    2147483647

    An array of numeric data can also be passed.

    >>> a = np.array([1, 2, 3***REMOVED***, dtype=np.int8***REMOVED***
    >>> ma.minimum_fill_value(a***REMOVED***
    127
    >>> a = np.array([1, 2, 3***REMOVED***, dtype=np.float32***REMOVED***
    >>> ma.minimum_fill_value(a***REMOVED***
    inf

    ***REMOVED***
    errmsg = "Unsuitable type for calculating minimum."
    if hasattr(obj, 'dtype'***REMOVED***:
        return _recursive_extremum_fill_value(obj.dtype, min_filler***REMOVED***
    elif isinstance(obj, float***REMOVED***:
        return min_filler[ntypes.typeDict['float_'***REMOVED******REMOVED***
    elif isinstance(obj, int***REMOVED***:
        return min_filler[ntypes.typeDict['int_'***REMOVED******REMOVED***
    elif isinstance(obj, long***REMOVED***:
        return min_filler[ntypes.typeDict['uint'***REMOVED******REMOVED***
    elif isinstance(obj, np.dtype***REMOVED***:
        return min_filler[obj***REMOVED***
    else:
        raise TypeError(errmsg***REMOVED***


def maximum_fill_value(obj***REMOVED***:
    ***REMOVED***
    Return the minimum value that can be represented by the dtype of an object.

    This function is useful for calculating a fill value suitable for
    taking the maximum of an array with a given dtype.

    Parameters
    ----------
    obj : {ndarray, dtype***REMOVED***
        An object that can be queried for it's numeric type.

    Returns
    -------
    val : scalar
        The minimum representable value.

    Raises
    ------
    TypeError
        If `obj` isn't a suitable numeric type.

    See Also
    --------
    minimum_fill_value : The inverse function.
    set_fill_value : Set the filling value of a masked array.
    MaskedArray.fill_value : Return current fill value.

    Examples
    --------
    >>> import numpy.ma as ma
    >>> a = np.int8(***REMOVED***
    >>> ma.maximum_fill_value(a***REMOVED***
    -128
    >>> a = np.int32(***REMOVED***
    >>> ma.maximum_fill_value(a***REMOVED***
    -2147483648

    An array of numeric data can also be passed.

    >>> a = np.array([1, 2, 3***REMOVED***, dtype=np.int8***REMOVED***
    >>> ma.maximum_fill_value(a***REMOVED***
    -128
    >>> a = np.array([1, 2, 3***REMOVED***, dtype=np.float32***REMOVED***
    >>> ma.maximum_fill_value(a***REMOVED***
    -inf

    ***REMOVED***
    errmsg = "Unsuitable type for calculating maximum."
    if hasattr(obj, 'dtype'***REMOVED***:
        return _recursive_extremum_fill_value(obj.dtype, max_filler***REMOVED***
    elif isinstance(obj, float***REMOVED***:
        return max_filler[ntypes.typeDict['float_'***REMOVED******REMOVED***
    elif isinstance(obj, int***REMOVED***:
        return max_filler[ntypes.typeDict['int_'***REMOVED******REMOVED***
    elif isinstance(obj, long***REMOVED***:
        return max_filler[ntypes.typeDict['uint'***REMOVED******REMOVED***
    elif isinstance(obj, np.dtype***REMOVED***:
        return max_filler[obj***REMOVED***
    else:
        raise TypeError(errmsg***REMOVED***


def _recursive_set_default_fill_value(dt***REMOVED***:
    ***REMOVED***
    Create the default fill value for a structured dtype.

    Parameters
    ----------
    dt: dtype
        The structured dtype for which to create the fill value.

    Returns
    -------
    val: tuple
        A tuple of values corresponding to the default structured fill value.

    ***REMOVED***
    deflist = [***REMOVED***
    for name in dt.names:
        currenttype = dt[name***REMOVED***
        if currenttype.subdtype:
            currenttype = currenttype.subdtype[0***REMOVED***

        if currenttype.names:
            deflist.append(
                tuple(_recursive_set_default_fill_value(currenttype***REMOVED******REMOVED******REMOVED***
        else:
            deflist.append(default_fill_value(currenttype***REMOVED******REMOVED***
    return tuple(deflist***REMOVED***


def _recursive_set_fill_value(fillvalue, dt***REMOVED***:
    ***REMOVED***
    Create a fill value for a structured dtype.

    Parameters
    ----------
    fillvalue: scalar or array_like
        Scalar or array representing the fill value. If it is of shorter
        length than the number of fields in dt, it will be resized.
    dt: dtype
        The structured dtype for which to create the fill value.

    Returns
    -------
    val: tuple
        A tuple of values corresponding to the structured fill value.

    ***REMOVED***
    fillvalue = np.resize(fillvalue, len(dt.names***REMOVED******REMOVED***
    output_value = [***REMOVED***
    for (fval, name***REMOVED*** in zip(fillvalue, dt.names***REMOVED***:
        cdtype = dt[name***REMOVED***
        if cdtype.subdtype:
            cdtype = cdtype.subdtype[0***REMOVED***

        if cdtype.names:
            output_value.append(tuple(_recursive_set_fill_value(fval, cdtype***REMOVED******REMOVED******REMOVED***
        else:
            output_value.append(np.array(fval, dtype=cdtype***REMOVED***.item(***REMOVED******REMOVED***
    return tuple(output_value***REMOVED***


def _check_fill_value(fill_value, ndtype***REMOVED***:
    ***REMOVED***
    Private function validating the given `fill_value` for the given dtype.

    If fill_value is None, it is set to the default corresponding to the dtype
    if this latter is standard (no fields***REMOVED***. If the datatype is flexible (named
    fields***REMOVED***, fill_value is set to a tuple whose elements are the default fill
    values corresponding to each field.

    If fill_value is not None, its value is forced to the given dtype.

    ***REMOVED***
    ndtype = np.dtype(ndtype***REMOVED***
    fields = ndtype.fields
    if fill_value is None:
        if fields:
            fill_value = np.array(_recursive_set_default_fill_value(ndtype***REMOVED***,
                                  dtype=ndtype***REMOVED***
        else:
            fill_value = default_fill_value(ndtype***REMOVED***
    elif fields:
        fdtype = [(_[0***REMOVED***, _[1***REMOVED******REMOVED*** for _ in ndtype.descr***REMOVED***
        if isinstance(fill_value, (ndarray, np.void***REMOVED******REMOVED***:
            ***REMOVED***
                fill_value = np.array(fill_value, copy=False, dtype=fdtype***REMOVED***
            except ValueError:
                err_msg = "Unable to transform %s to dtype %s"
                raise ValueError(err_msg % (fill_value, fdtype***REMOVED******REMOVED***
        else:
            fill_value = np.asarray(fill_value, dtype=object***REMOVED***
            fill_value = np.array(_recursive_set_fill_value(fill_value, ndtype***REMOVED***,
                                  dtype=ndtype***REMOVED***
    else:
        if isinstance(fill_value, basestring***REMOVED*** and (ndtype.char not in 'OSVU'***REMOVED***:
            err_msg = "Cannot set fill value of string with array of dtype %s"
            raise TypeError(err_msg % ndtype***REMOVED***
        else:
            # In case we want to convert 1e20 to int.
            ***REMOVED***
                fill_value = np.array(fill_value, copy=False, dtype=ndtype***REMOVED***
            except OverflowError:
                # Raise TypeError instead of OverflowError. OverflowError
                # is seldom used, and the real problem here is that the
                # passed fill_value is not compatible with the ndtype.
                err_msg = "Fill value %s overflows dtype %s"
                raise TypeError(err_msg % (fill_value, ndtype***REMOVED******REMOVED***
    return np.array(fill_value***REMOVED***


def set_fill_value(a, fill_value***REMOVED***:
    ***REMOVED***
    Set the filling value of a, if a is a masked array.

    This function changes the fill value of the masked array `a` in place.
    If `a` is not a masked array, the function returns silently, without
    doing anything.

    Parameters
    ----------
    a : array_like
        Input array.
    fill_value : dtype
        Filling value. A consistency test is performed to make sure
        the value is compatible with the dtype of `a`.

    Returns
    -------
    None
        Nothing returned by this function.

    See Also
    --------
    maximum_fill_value : Return the default fill value for a dtype.
    MaskedArray.fill_value : Return current fill value.
    MaskedArray.set_fill_value : Equivalent method.

    Examples
    --------
    >>> import numpy.ma as ma
    >>> a = np.arange(5***REMOVED***
    >>> a
    array([0, 1, 2, 3, 4***REMOVED******REMOVED***
    >>> a = ma.masked_where(a < 3, a***REMOVED***
    >>> a
    masked_array(data = [-- -- -- 3 4***REMOVED***,
          mask = [ True  True  True False False***REMOVED***,
          fill_value=999999***REMOVED***
    >>> ma.set_fill_value(a, -999***REMOVED***
    >>> a
    masked_array(data = [-- -- -- 3 4***REMOVED***,
          mask = [ True  True  True False False***REMOVED***,
          fill_value=-999***REMOVED***

    Nothing happens if `a` is not a masked array.

    >>> a = range(5***REMOVED***
    >>> a
    [0, 1, 2, 3, 4***REMOVED***
    >>> ma.set_fill_value(a, 100***REMOVED***
    >>> a
    [0, 1, 2, 3, 4***REMOVED***
    >>> a = np.arange(5***REMOVED***
    >>> a
    array([0, 1, 2, 3, 4***REMOVED******REMOVED***
    >>> ma.set_fill_value(a, 100***REMOVED***
    >>> a
    array([0, 1, 2, 3, 4***REMOVED******REMOVED***

    ***REMOVED***
    if isinstance(a, MaskedArray***REMOVED***:
        a.set_fill_value(fill_value***REMOVED***
    return


def get_fill_value(a***REMOVED***:
    ***REMOVED***
    Return the filling value of a, if any.  Otherwise, returns the
    default filling value for that type.

    ***REMOVED***
    if isinstance(a, MaskedArray***REMOVED***:
        result = a.fill_value
    else:
        result = default_fill_value(a***REMOVED***
    return result


def common_fill_value(a, b***REMOVED***:
    ***REMOVED***
    Return the common filling value of two masked arrays, if any.

    If ``a.fill_value == b.fill_value``, return the fill value,
    otherwise return None.

    Parameters
    ----------
    a, b : MaskedArray
        The masked arrays for which to compare fill values.

    Returns
    -------
    fill_value : scalar or None
        The common fill value, or None.

    Examples
    --------
    >>> x = np.ma.array([0, 1.***REMOVED***, fill_value=3***REMOVED***
    >>> y = np.ma.array([0, 1.***REMOVED***, fill_value=3***REMOVED***
    >>> np.ma.common_fill_value(x, y***REMOVED***
    3.0

    ***REMOVED***
    t1 = get_fill_value(a***REMOVED***
    t2 = get_fill_value(b***REMOVED***
    if t1 == t2:
        return t1
    return None


def filled(a, fill_value=None***REMOVED***:
    ***REMOVED***
    Return input as an array with masked data replaced by a fill value.

    If `a` is not a `MaskedArray`, `a` itself is returned.
    If `a` is a `MaskedArray` and `fill_value` is None, `fill_value` is set to
    ``a.fill_value``.

    Parameters
    ----------
    a : MaskedArray or array_like
        An input object.
    fill_value : scalar, optional
        Filling value. Default is None.

    Returns
    -------
    a : ndarray
        The filled array.

    See Also
    --------
    compressed

    Examples
    --------
    >>> x = np.ma.array(np.arange(9***REMOVED***.reshape(3, 3***REMOVED***, mask=[[1, 0, 0***REMOVED***,
    ...                                                   [1, 0, 0***REMOVED***,
    ...                                                   [0, 0, 0***REMOVED******REMOVED******REMOVED***
    >>> x.filled(***REMOVED***
    array([[999999,      1,      2***REMOVED***,
           [999999,      4,      5***REMOVED***,
           [     6,      7,      8***REMOVED******REMOVED******REMOVED***

    ***REMOVED***
    if hasattr(a, 'filled'***REMOVED***:
        return a.filled(fill_value***REMOVED***
    elif isinstance(a, ndarray***REMOVED***:
        # Should we check for contiguity ? and a.flags['CONTIGUOUS'***REMOVED***:
        return a
    elif isinstance(a, dict***REMOVED***:
        return np.array(a, 'O'***REMOVED***
    else:
        return np.array(a***REMOVED***


def get_masked_subclass(*arrays***REMOVED***:
    ***REMOVED***
    Return the youngest subclass of MaskedArray from a list of (masked***REMOVED*** arrays.

    In case of siblings, the first listed takes over.

    ***REMOVED***
    if len(arrays***REMOVED*** == 1:
        arr = arrays[0***REMOVED***
        if isinstance(arr, MaskedArray***REMOVED***:
            rcls = type(arr***REMOVED***
        else:
            rcls = MaskedArray
    else:
        arrcls = [type(a***REMOVED*** for a in arrays***REMOVED***
        rcls = arrcls[0***REMOVED***
        if not issubclass(rcls, MaskedArray***REMOVED***:
            rcls = MaskedArray
        for cls in arrcls[1:***REMOVED***:
            if issubclass(cls, rcls***REMOVED***:
                rcls = cls
    # Don't return MaskedConstant as result: revert to MaskedArray
    if rcls.__name__ == 'MaskedConstant':
        return MaskedArray
    return rcls


def getdata(a, subok=True***REMOVED***:
    ***REMOVED***
    Return the data of a masked array as an ndarray.

    Return the data of `a` (if any***REMOVED*** as an ndarray if `a` is a ``MaskedArray``,
    else return `a` as a ndarray or subclass (depending on `subok`***REMOVED*** if not.

    Parameters
    ----------
    a : array_like
        Input ``MaskedArray``, alternatively a ndarray or a subclass thereof.
    subok : bool
        Whether to force the output to be a `pure` ndarray (False***REMOVED*** or to
        return a subclass of ndarray if appropriate (True, default***REMOVED***.

    See Also
    --------
    getmask : Return the mask of a masked array, or nomask.
    getmaskarray : Return the mask of a masked array, or full array of False.

    Examples
    --------
    >>> import numpy.ma as ma
    >>> a = ma.masked_equal([[1,2***REMOVED***,[3,4***REMOVED******REMOVED***, 2***REMOVED***
    >>> a
    masked_array(data =
     [[1 --***REMOVED***
     [3 4***REMOVED******REMOVED***,
          mask =
     [[False  True***REMOVED***
     [False False***REMOVED******REMOVED***,
          fill_value=999999***REMOVED***
    >>> ma.getdata(a***REMOVED***
    array([[1, 2***REMOVED***,
           [3, 4***REMOVED******REMOVED******REMOVED***

    Equivalently use the ``MaskedArray`` `data` attribute.

    >>> a.data
    array([[1, 2***REMOVED***,
           [3, 4***REMOVED******REMOVED******REMOVED***

    ***REMOVED***
    ***REMOVED***
        data = a._data
    except AttributeError:
        data = np.array(a, copy=False, subok=subok***REMOVED***
    if not subok:
        return data.view(ndarray***REMOVED***
    return data


get_data = getdata


def fix_invalid(a, mask=nomask, copy=True, fill_value=None***REMOVED***:
    ***REMOVED***
    Return input with invalid data masked and replaced by a fill value.

    Invalid data means values of `nan`, `inf`, etc.

    Parameters
    ----------
    a : array_like
        Input array, a (subclass of***REMOVED*** ndarray.
    mask : sequence, optional
        Mask. Must be convertible to an array of booleans with the same
        shape as `data`. True indicates a masked (i.e. invalid***REMOVED*** data.
    copy : bool, optional
        Whether to use a copy of `a` (True***REMOVED*** or to fix `a` in place (False***REMOVED***.
        Default is True.
    fill_value : scalar, optional
        Value used for fixing invalid data. Default is None, in which case
        the ``a.fill_value`` is used.

    Returns
    -------
    b : MaskedArray
        The input array with invalid entries fixed.

    Notes
    -----
    A copy is performed by default.

    Examples
    --------
    >>> x = np.ma.array([1., -1, np.nan, np.inf***REMOVED***, mask=[1***REMOVED*** + [0***REMOVED****3***REMOVED***
    >>> x
    masked_array(data = [-- -1.0 nan inf***REMOVED***,
                 mask = [ True False False False***REMOVED***,
           fill_value = 1e+20***REMOVED***
    >>> np.ma.fix_invalid(x***REMOVED***
    masked_array(data = [-- -1.0 -- --***REMOVED***,
                 mask = [ True False  True  True***REMOVED***,
           fill_value = 1e+20***REMOVED***

    >>> fixed = np.ma.fix_invalid(x***REMOVED***
    >>> fixed.data
    array([  1.00000000e+00,  -1.00000000e+00,   1.00000000e+20,
             1.00000000e+20***REMOVED******REMOVED***
    >>> x.data
    array([  1.,  -1.,  NaN,  Inf***REMOVED******REMOVED***

    ***REMOVED***
    a = masked_array(a, copy=copy, mask=mask, subok=True***REMOVED***
    invalid = np.logical_not(np.isfinite(a._data***REMOVED******REMOVED***
    if not invalid.any(***REMOVED***:
        return a
    a._mask |= invalid
    if fill_value is None:
        fill_value = a.fill_value
    a._data[invalid***REMOVED*** = fill_value
    return a


###############################################################################
#                                  Ufuncs                                     #
###############################################################################


ufunc_domain = {***REMOVED***
ufunc_fills = {***REMOVED***


class _DomainCheckInterval:
    ***REMOVED***
    Define a valid interval, so that :

    ``domain_check_interval(a,b***REMOVED***(x***REMOVED*** == True`` where
    ``x < a`` or ``x > b``.

    ***REMOVED***

    def __init__(self, a, b***REMOVED***:
        "domain_check_interval(a,b***REMOVED***(x***REMOVED*** = true where x < a or y > b"
        if (a > b***REMOVED***:
            (a, b***REMOVED*** = (b, a***REMOVED***
        self.a = a
        self.b = b

    def __call__(self, x***REMOVED***:
        "Execute the call behavior."
        return umath.logical_or(umath.greater(x, self.b***REMOVED***,
                                umath.less(x, self.a***REMOVED******REMOVED***


class _DomainTan:
    ***REMOVED***
    Define a valid interval for the `tan` function, so that:

    ``domain_tan(eps***REMOVED*** = True`` where ``abs(cos(x***REMOVED******REMOVED*** < eps``

    ***REMOVED***

    def __init__(self, eps***REMOVED***:
        "domain_tan(eps***REMOVED*** = true where abs(cos(x***REMOVED******REMOVED*** < eps***REMOVED***"
        self.eps = eps

    def __call__(self, x***REMOVED***:
        "Executes the call behavior."
        return umath.less(umath.absolute(umath.cos(x***REMOVED******REMOVED***, self.eps***REMOVED***


class _DomainSafeDivide:
    ***REMOVED***
    Define a domain for safe division.

    ***REMOVED***

    def __init__(self, tolerance=None***REMOVED***:
        self.tolerance = tolerance

    def __call__(self, a, b***REMOVED***:
        # Delay the selection of the tolerance to here in order to reduce numpy
        # import times. The calculation of these parameters is a substantial
        # component of numpy's import time.
        if self.tolerance is None:
            self.tolerance = np.finfo(float***REMOVED***.tiny
        # don't call ma ufuncs from __array_wrap__ which would fail for scalars
        a, b = np.asarray(a***REMOVED***, np.asarray(b***REMOVED***
        return umath.absolute(a***REMOVED*** * self.tolerance >= umath.absolute(b***REMOVED***


class _DomainGreater:
    ***REMOVED***
    DomainGreater(v***REMOVED***(x***REMOVED*** is True where x <= v.

    ***REMOVED***

    def __init__(self, critical_value***REMOVED***:
        "DomainGreater(v***REMOVED***(x***REMOVED*** = true where x <= v"
        self.critical_value = critical_value

    def __call__(self, x***REMOVED***:
        "Executes the call behavior."
        return umath.less_equal(x, self.critical_value***REMOVED***


class _DomainGreaterEqual:
    ***REMOVED***
    DomainGreaterEqual(v***REMOVED***(x***REMOVED*** is True where x < v.

    ***REMOVED***

    def __init__(self, critical_value***REMOVED***:
        "DomainGreaterEqual(v***REMOVED***(x***REMOVED*** = true where x < v"
        self.critical_value = critical_value

    def __call__(self, x***REMOVED***:
        "Executes the call behavior."
        return umath.less(x, self.critical_value***REMOVED***


class _MaskedUnaryOperation:
    ***REMOVED***
    Defines masked version of unary operations, where invalid values are
    pre-masked.

    Parameters
    ----------
    mufunc : callable
        The function for which to define a masked version. Made available
        as ``_MaskedUnaryOperation.f``.
    fill : scalar, optional
        Filling value, default is 0.
    domain : class instance
        Domain for the function. Should be one of the ``_Domain*``
        classes. Default is None.

    ***REMOVED***

    def __init__(self, mufunc, fill=0, domain=None***REMOVED***:
        self.f = mufunc
        self.fill = fill
        self.domain = domain
        self.__doc__ = getattr(mufunc, "__doc__", str(mufunc***REMOVED******REMOVED***
        self.__name__ = getattr(mufunc, "__name__", str(mufunc***REMOVED******REMOVED***
        ufunc_domain[mufunc***REMOVED*** = domain
        ufunc_fills[mufunc***REMOVED*** = fill

    def __call__(self, a, *args, **kwargs***REMOVED***:
        ***REMOVED***
        Execute the call behavior.

        ***REMOVED***
        d = getdata(a***REMOVED***
        # Deal with domain
        if self.domain is not None:
            # Case 1.1. : Domained function
            with np.errstate(divide='ignore', invalid='ignore'***REMOVED***:
                result = self.f(d, *args, **kwargs***REMOVED***
            # Make a mask
            m = ~umath.isfinite(result***REMOVED***
            m |= self.domain(d***REMOVED***
            m |= getmask(a***REMOVED***
        else:
            # Case 1.2. : Function without a domain
            # Get the result and the mask
            result = self.f(d, *args, **kwargs***REMOVED***
            m = getmask(a***REMOVED***

        if not result.ndim:
            # Case 2.1. : The result is scalarscalar
            if m:
                return masked
            return result

        if m is not nomask:
            # Case 2.2. The result is an array
            # We need to fill the invalid data back w/ the input Now,
            # that's plain silly: in C, we would just skip the element and
            # keep the original, but we do have to do it that way in Python

            # In case result has a lower dtype than the inputs (as in
            # equal***REMOVED***
            ***REMOVED***
                np.copyto(result, d, where=m***REMOVED***
            except TypeError:
                pass
        # Transform to
        masked_result = result.view(get_masked_subclass(a***REMOVED******REMOVED***
        masked_result._mask = m
        masked_result._update_from(a***REMOVED***
        return masked_result

    def __str__(self***REMOVED***:
        return "Masked version of %s. [Invalid values are masked***REMOVED***" % str(self.f***REMOVED***


class _MaskedBinaryOperation:
    ***REMOVED***
    Define masked version of binary operations, where invalid
    values are pre-masked.

    Parameters
    ----------
    mbfunc : function
        The function for which to define a masked version. Made available
        as ``_MaskedBinaryOperation.f``.
    domain : class instance
        Default domain for the function. Should be one of the ``_Domain*``
        classes. Default is None.
    fillx : scalar, optional
        Filling value for the first argument, default is 0.
    filly : scalar, optional
        Filling value for the second argument, default is 0.

    ***REMOVED***

    def __init__(self, mbfunc, fillx=0, filly=0***REMOVED***:
        ***REMOVED***
        abfunc(fillx, filly***REMOVED*** must be defined.

        abfunc(x, filly***REMOVED*** = x for all x to enable reduce.

        ***REMOVED***
        self.f = mbfunc
        self.fillx = fillx
        self.filly = filly
        self.__doc__ = getattr(mbfunc, "__doc__", str(mbfunc***REMOVED******REMOVED***
        self.__name__ = getattr(mbfunc, "__name__", str(mbfunc***REMOVED******REMOVED***
        ufunc_domain[mbfunc***REMOVED*** = None
        ufunc_fills[mbfunc***REMOVED*** = (fillx, filly***REMOVED***

    def __call__(self, a, b, *args, **kwargs***REMOVED***:
        ***REMOVED***
        Execute the call behavior.

        ***REMOVED***
        # Get the data, as ndarray
        (da, db***REMOVED*** = (getdata(a***REMOVED***, getdata(b***REMOVED******REMOVED***
        # Get the result
        with np.errstate(***REMOVED***:
            np.seterr(divide='ignore', invalid='ignore'***REMOVED***
            result = self.f(da, db, *args, **kwargs***REMOVED***
        # Get the mask for the result
        (ma, mb***REMOVED*** = (getmask(a***REMOVED***, getmask(b***REMOVED******REMOVED***
        if ma is nomask:
            if mb is nomask:
                m = nomask
            else:
                m = umath.logical_or(getmaskarray(a***REMOVED***, mb***REMOVED***
        elif mb is nomask:
            m = umath.logical_or(ma, getmaskarray(b***REMOVED******REMOVED***
        else:
            m = umath.logical_or(ma, mb***REMOVED***

        # Case 1. : scalar
        if not result.ndim:
            if m:
                return masked
            return result

        # Case 2. : array
        # Revert result to da where masked
        if m is not nomask and m.any(***REMOVED***:
            # any errors, just abort; impossible to guarantee masked values
            ***REMOVED***
                np.copyto(result, 0, casting='unsafe', where=m***REMOVED***
                # avoid using "*" since this may be overlaid
                masked_da = umath.multiply(m, da***REMOVED***
                # only add back if it can be cast safely
                if np.can_cast(masked_da.dtype, result.dtype, casting='safe'***REMOVED***:
                    result += masked_da
            ***REMOVED***
                pass

        # Transforms to a (subclass of***REMOVED*** MaskedArray
        masked_result = result.view(get_masked_subclass(a, b***REMOVED******REMOVED***
        masked_result._mask = m
        if isinstance(a, MaskedArray***REMOVED***:
            masked_result._update_from(a***REMOVED***
        elif isinstance(b, MaskedArray***REMOVED***:
            masked_result._update_from(b***REMOVED***
        return masked_result

    def reduce(self, target, axis=0, dtype=None***REMOVED***:
        ***REMOVED***
        Reduce `target` along the given `axis`.

        ***REMOVED***
        tclass = get_masked_subclass(target***REMOVED***
        m = getmask(target***REMOVED***
        t = filled(target, self.filly***REMOVED***
        if t.shape == (***REMOVED***:
            t = t.reshape(1***REMOVED***
            if m is not nomask:
                m = make_mask(m, copy=1***REMOVED***
                m.shape = (1,***REMOVED***

        if m is nomask:
            tr = self.f.reduce(t, axis***REMOVED***
            mr = nomask
        else:
            tr = self.f.reduce(t, axis, dtype=dtype or t.dtype***REMOVED***
            mr = umath.logical_and.reduce(m, axis***REMOVED***

        if not tr.shape:
            if mr:
                return masked
            else:
                return tr
        masked_tr = tr.view(tclass***REMOVED***
        masked_tr._mask = mr
        return masked_tr

    def outer(self, a, b***REMOVED***:
        ***REMOVED***
        Return the function applied to the outer product of a and b.

        ***REMOVED***
        (da, db***REMOVED*** = (getdata(a***REMOVED***, getdata(b***REMOVED******REMOVED***
        d = self.f.outer(da, db***REMOVED***
        ma = getmask(a***REMOVED***
        mb = getmask(b***REMOVED***
        if ma is nomask and mb is nomask:
            m = nomask
        else:
            ma = getmaskarray(a***REMOVED***
            mb = getmaskarray(b***REMOVED***
            m = umath.logical_or.outer(ma, mb***REMOVED***
        if (not m.ndim***REMOVED*** and m:
            return masked
        if m is not nomask:
            np.copyto(d, da, where=m***REMOVED***
        if not d.shape:
            return d
        masked_d = d.view(get_masked_subclass(a, b***REMOVED******REMOVED***
        masked_d._mask = m
        return masked_d

    def accumulate(self, target, axis=0***REMOVED***:
        ***REMOVED***Accumulate `target` along `axis` after filling with y fill
        value.

        ***REMOVED***
        tclass = get_masked_subclass(target***REMOVED***
        t = filled(target, self.filly***REMOVED***
        result = self.f.accumulate(t, axis***REMOVED***
        masked_result = result.view(tclass***REMOVED***
        return masked_result

    def __str__(self***REMOVED***:
        return "Masked version of " + str(self.f***REMOVED***


class _DomainedBinaryOperation:
    ***REMOVED***
    Define binary operations that have a domain, like divide.

    They have no reduce, outer or accumulate.

    Parameters
    ----------
    mbfunc : function
        The function for which to define a masked version. Made available
        as ``_DomainedBinaryOperation.f``.
    domain : class instance
        Default domain for the function. Should be one of the ``_Domain*``
        classes.
    fillx : scalar, optional
        Filling value for the first argument, default is 0.
    filly : scalar, optional
        Filling value for the second argument, default is 0.

    ***REMOVED***

    def __init__(self, dbfunc, domain, fillx=0, filly=0***REMOVED***:
        ***REMOVED***abfunc(fillx, filly***REMOVED*** must be defined.
           abfunc(x, filly***REMOVED*** = x for all x to enable reduce.
        ***REMOVED***
        self.f = dbfunc
        self.domain = domain
        self.fillx = fillx
        self.filly = filly
        self.__doc__ = getattr(dbfunc, "__doc__", str(dbfunc***REMOVED******REMOVED***
        self.__name__ = getattr(dbfunc, "__name__", str(dbfunc***REMOVED******REMOVED***
        ufunc_domain[dbfunc***REMOVED*** = domain
        ufunc_fills[dbfunc***REMOVED*** = (fillx, filly***REMOVED***

    def __call__(self, a, b, *args, **kwargs***REMOVED***:
        "Execute the call behavior."
        # Get the data
        (da, db***REMOVED*** = (getdata(a***REMOVED***, getdata(b***REMOVED******REMOVED***
        # Get the result
        with np.errstate(divide='ignore', invalid='ignore'***REMOVED***:
            result = self.f(da, db, *args, **kwargs***REMOVED***
        # Get the mask as a combination of the source masks and invalid
        m = ~umath.isfinite(result***REMOVED***
        m |= getmask(a***REMOVED***
        m |= getmask(b***REMOVED***
        # Apply the domain
        domain = ufunc_domain.get(self.f, None***REMOVED***
        if domain is not None:
            m |= filled(domain(da, db***REMOVED***, True***REMOVED***
        # Take care of the scalar case first
        if (not m.ndim***REMOVED***:
            if m:
                return masked
            else:
                return result
        # When the mask is True, put back da if possible
        # any errors, just abort; impossible to guarantee masked values
        ***REMOVED***
            np.copyto(result, 0, casting='unsafe', where=m***REMOVED***
            # avoid using "*" since this may be overlaid
            masked_da = umath.multiply(m, da***REMOVED***
            # only add back if it can be cast safely
            if np.can_cast(masked_da.dtype, result.dtype, casting='safe'***REMOVED***:
                result += masked_da
        ***REMOVED***
            pass

        # Transforms to a (subclass of***REMOVED*** MaskedArray
        masked_result = result.view(get_masked_subclass(a, b***REMOVED******REMOVED***
        masked_result._mask = m
        if isinstance(a, MaskedArray***REMOVED***:
            masked_result._update_from(a***REMOVED***
        elif isinstance(b, MaskedArray***REMOVED***:
            masked_result._update_from(b***REMOVED***
        return masked_result

    def __str__(self***REMOVED***:
        return "Masked version of " + str(self.f***REMOVED***


# Unary ufuncs
exp = _MaskedUnaryOperation(umath.exp***REMOVED***
conjugate = _MaskedUnaryOperation(umath.conjugate***REMOVED***
sin = _MaskedUnaryOperation(umath.sin***REMOVED***
cos = _MaskedUnaryOperation(umath.cos***REMOVED***
tan = _MaskedUnaryOperation(umath.tan***REMOVED***
arctan = _MaskedUnaryOperation(umath.arctan***REMOVED***
arcsinh = _MaskedUnaryOperation(umath.arcsinh***REMOVED***
sinh = _MaskedUnaryOperation(umath.sinh***REMOVED***
cosh = _MaskedUnaryOperation(umath.cosh***REMOVED***
tanh = _MaskedUnaryOperation(umath.tanh***REMOVED***
abs = absolute = _MaskedUnaryOperation(umath.absolute***REMOVED***
angle = _MaskedUnaryOperation(angle***REMOVED***  # from numpy.lib.function_base
fabs = _MaskedUnaryOperation(umath.fabs***REMOVED***
negative = _MaskedUnaryOperation(umath.negative***REMOVED***
floor = _MaskedUnaryOperation(umath.floor***REMOVED***
ceil = _MaskedUnaryOperation(umath.ceil***REMOVED***
around = _MaskedUnaryOperation(np.round_***REMOVED***
logical_not = _MaskedUnaryOperation(umath.logical_not***REMOVED***

# Domained unary ufuncs
sqrt = _MaskedUnaryOperation(umath.sqrt, 0.0,
                             _DomainGreaterEqual(0.0***REMOVED******REMOVED***
log = _MaskedUnaryOperation(umath.log, 1.0,
                            _DomainGreater(0.0***REMOVED******REMOVED***
log2 = _MaskedUnaryOperation(umath.log2, 1.0,
                             _DomainGreater(0.0***REMOVED******REMOVED***
log10 = _MaskedUnaryOperation(umath.log10, 1.0,
                              _DomainGreater(0.0***REMOVED******REMOVED***
tan = _MaskedUnaryOperation(umath.tan, 0.0,
                            _DomainTan(1e-35***REMOVED******REMOVED***
arcsin = _MaskedUnaryOperation(umath.arcsin, 0.0,
                               _DomainCheckInterval(-1.0, 1.0***REMOVED******REMOVED***
arccos = _MaskedUnaryOperation(umath.arccos, 0.0,
                               _DomainCheckInterval(-1.0, 1.0***REMOVED******REMOVED***
arccosh = _MaskedUnaryOperation(umath.arccosh, 1.0,
                                _DomainGreaterEqual(1.0***REMOVED******REMOVED***
arctanh = _MaskedUnaryOperation(umath.arctanh, 0.0,
                                _DomainCheckInterval(-1.0 + 1e-15, 1.0 - 1e-15***REMOVED******REMOVED***

# Binary ufuncs
add = _MaskedBinaryOperation(umath.add***REMOVED***
subtract = _MaskedBinaryOperation(umath.subtract***REMOVED***
multiply = _MaskedBinaryOperation(umath.multiply, 1, 1***REMOVED***
arctan2 = _MaskedBinaryOperation(umath.arctan2, 0.0, 1.0***REMOVED***
equal = _MaskedBinaryOperation(umath.equal***REMOVED***
equal.reduce = None
not_equal = _MaskedBinaryOperation(umath.not_equal***REMOVED***
not_equal.reduce = None
less_equal = _MaskedBinaryOperation(umath.less_equal***REMOVED***
less_equal.reduce = None
greater_equal = _MaskedBinaryOperation(umath.greater_equal***REMOVED***
greater_equal.reduce = None
less = _MaskedBinaryOperation(umath.less***REMOVED***
less.reduce = None
greater = _MaskedBinaryOperation(umath.greater***REMOVED***
greater.reduce = None
logical_and = _MaskedBinaryOperation(umath.logical_and***REMOVED***
alltrue = _MaskedBinaryOperation(umath.logical_and, 1, 1***REMOVED***.reduce
logical_or = _MaskedBinaryOperation(umath.logical_or***REMOVED***
sometrue = logical_or.reduce
logical_xor = _MaskedBinaryOperation(umath.logical_xor***REMOVED***
bitwise_and = _MaskedBinaryOperation(umath.bitwise_and***REMOVED***
bitwise_or = _MaskedBinaryOperation(umath.bitwise_or***REMOVED***
bitwise_xor = _MaskedBinaryOperation(umath.bitwise_xor***REMOVED***
hypot = _MaskedBinaryOperation(umath.hypot***REMOVED***

# Domained binary ufuncs
divide = _DomainedBinaryOperation(umath.divide, _DomainSafeDivide(***REMOVED***, 0, 1***REMOVED***
true_divide = _DomainedBinaryOperation(umath.true_divide,
                                       _DomainSafeDivide(***REMOVED***, 0, 1***REMOVED***
floor_divide = _DomainedBinaryOperation(umath.floor_divide,
                                        _DomainSafeDivide(***REMOVED***, 0, 1***REMOVED***
remainder = _DomainedBinaryOperation(umath.remainder,
                                     _DomainSafeDivide(***REMOVED***, 0, 1***REMOVED***
fmod = _DomainedBinaryOperation(umath.fmod, _DomainSafeDivide(***REMOVED***, 0, 1***REMOVED***
mod = _DomainedBinaryOperation(umath.mod, _DomainSafeDivide(***REMOVED***, 0, 1***REMOVED***


###############################################################################
#                        Mask creation functions                              #
###############################################################################


def _recursive_make_descr(datatype, newtype=bool_***REMOVED***:
    "Private function allowing recursion in make_descr."
    # Do we have some name fields ?
    if datatype.names:
        descr = [***REMOVED***
        for name in datatype.names:
            field = datatype.fields[name***REMOVED***
            if len(field***REMOVED*** == 3:
                # Prepend the title to the name
                name = (field[-1***REMOVED***, name***REMOVED***
            descr.append((name, _recursive_make_descr(field[0***REMOVED***, newtype***REMOVED******REMOVED******REMOVED***
        return descr
    # Is this some kind of composite a la (np.float,2***REMOVED***
    elif datatype.subdtype:
        mdescr = list(datatype.subdtype***REMOVED***
        mdescr[0***REMOVED*** = _recursive_make_descr(datatype.subdtype[0***REMOVED***, newtype***REMOVED***
        return tuple(mdescr***REMOVED***
    else:
        return newtype


def make_mask_descr(ndtype***REMOVED***:
    ***REMOVED***
    Construct a dtype description list from a given dtype.

    Returns a new dtype object, with the type of all fields in `ndtype` to a
    boolean type. Field names are not altered.

    Parameters
    ----------
    ndtype : dtype
        The dtype to convert.

    Returns
    -------
    result : dtype
        A dtype that looks like `ndtype`, the type of all fields is boolean.

    Examples
    --------
    >>> import numpy.ma as ma
    >>> dtype = np.dtype({'names':['foo', 'bar'***REMOVED***,
                          'formats':[np.float32, np.int***REMOVED******REMOVED******REMOVED***
    >>> dtype
    dtype([('foo', '<f4'***REMOVED***, ('bar', '<i4'***REMOVED******REMOVED******REMOVED***
    >>> ma.make_mask_descr(dtype***REMOVED***
    dtype([('foo', '|b1'***REMOVED***, ('bar', '|b1'***REMOVED******REMOVED******REMOVED***
    >>> ma.make_mask_descr(np.float32***REMOVED***
    <type 'numpy.bool_'>

    ***REMOVED***
    # Make sure we do have a dtype
    if not isinstance(ndtype, np.dtype***REMOVED***:
        ndtype = np.dtype(ndtype***REMOVED***
    return np.dtype(_recursive_make_descr(ndtype, np.bool***REMOVED******REMOVED***


def getmask(a***REMOVED***:
    ***REMOVED***
    Return the mask of a masked array, or nomask.

    Return the mask of `a` as an ndarray if `a` is a `MaskedArray` and the
    mask is not `nomask`, else return `nomask`. To guarantee a full array
    of booleans of the same shape as a, use `getmaskarray`.

    Parameters
    ----------
    a : array_like
        Input `MaskedArray` for which the mask is required.

    See Also
    --------
    getdata : Return the data of a masked array as an ndarray.
    getmaskarray : Return the mask of a masked array, or full array of False.

    Examples
    --------
    >>> import numpy.ma as ma
    >>> a = ma.masked_equal([[1,2***REMOVED***,[3,4***REMOVED******REMOVED***, 2***REMOVED***
    >>> a
    masked_array(data =
     [[1 --***REMOVED***
     [3 4***REMOVED******REMOVED***,
          mask =
     [[False  True***REMOVED***
     [False False***REMOVED******REMOVED***,
          fill_value=999999***REMOVED***
    >>> ma.getmask(a***REMOVED***
    array([[False,  True***REMOVED***,
           [False, False***REMOVED******REMOVED***, dtype=bool***REMOVED***

    Equivalently use the `MaskedArray` `mask` attribute.

    >>> a.mask
    array([[False,  True***REMOVED***,
           [False, False***REMOVED******REMOVED***, dtype=bool***REMOVED***

    Result when mask == `nomask`

    >>> b = ma.masked_array([[1,2***REMOVED***,[3,4***REMOVED******REMOVED******REMOVED***
    >>> b
    masked_array(data =
     [[1 2***REMOVED***
     [3 4***REMOVED******REMOVED***,
          mask =
     False,
          fill_value=999999***REMOVED***
    >>> ma.nomask
    False
    >>> ma.getmask(b***REMOVED*** == ma.nomask
    True
    >>> b.mask == ma.nomask
    True

    ***REMOVED***
    return getattr(a, '_mask', nomask***REMOVED***


get_mask = getmask


def getmaskarray(arr***REMOVED***:
    ***REMOVED***
    Return the mask of a masked array, or full boolean array of False.

    Return the mask of `arr` as an ndarray if `arr` is a `MaskedArray` and
    the mask is not `nomask`, else return a full boolean array of False of
    the same shape as `arr`.

    Parameters
    ----------
    arr : array_like
        Input `MaskedArray` for which the mask is required.

    See Also
    --------
    getmask : Return the mask of a masked array, or nomask.
    getdata : Return the data of a masked array as an ndarray.

    Examples
    --------
    >>> import numpy.ma as ma
    >>> a = ma.masked_equal([[1,2***REMOVED***,[3,4***REMOVED******REMOVED***, 2***REMOVED***
    >>> a
    masked_array(data =
     [[1 --***REMOVED***
     [3 4***REMOVED******REMOVED***,
          mask =
     [[False  True***REMOVED***
     [False False***REMOVED******REMOVED***,
          fill_value=999999***REMOVED***
    >>> ma.getmaskarray(a***REMOVED***
    array([[False,  True***REMOVED***,
           [False, False***REMOVED******REMOVED***, dtype=bool***REMOVED***

    Result when mask == ``nomask``

    >>> b = ma.masked_array([[1,2***REMOVED***,[3,4***REMOVED******REMOVED******REMOVED***
    >>> b
    masked_array(data =
     [[1 2***REMOVED***
     [3 4***REMOVED******REMOVED***,
          mask =
     False,
          fill_value=999999***REMOVED***
    >>> >ma.getmaskarray(b***REMOVED***
    array([[False, False***REMOVED***,
           [False, False***REMOVED******REMOVED***, dtype=bool***REMOVED***

    ***REMOVED***
    mask = getmask(arr***REMOVED***
    if mask is nomask:
        mask = make_mask_none(np.shape(arr***REMOVED***, getattr(arr, 'dtype', None***REMOVED******REMOVED***
    return mask


def is_mask(m***REMOVED***:
    ***REMOVED***
    Return True if m is a valid, standard mask.

    This function does not check the contents of the input, only that the
    type is MaskType. In particular, this function returns False if the
    mask has a flexible dtype.

    Parameters
    ----------
    m : array_like
        Array to test.

    Returns
    -------
    result : bool
        True if `m.dtype.type` is MaskType, False otherwise.

    See Also
    --------
    isMaskedArray : Test whether input is an instance of MaskedArray.

    Examples
    --------
    >>> import numpy.ma as ma
    >>> m = ma.masked_equal([0, 1, 0, 2, 3***REMOVED***, 0***REMOVED***
    >>> m
    masked_array(data = [-- 1 -- 2 3***REMOVED***,
          mask = [ True False  True False False***REMOVED***,
          fill_value=999999***REMOVED***
    >>> ma.is_mask(m***REMOVED***
    False
    >>> ma.is_mask(m.mask***REMOVED***
    True

    Input must be an ndarray (or have similar attributes***REMOVED***
    for it to be considered a valid mask.

    >>> m = [False, True, False***REMOVED***
    >>> ma.is_mask(m***REMOVED***
    False
    >>> m = np.array([False, True, False***REMOVED******REMOVED***
    >>> m
    array([False,  True, False***REMOVED***, dtype=bool***REMOVED***
    >>> ma.is_mask(m***REMOVED***
    True

    Arrays with complex dtypes don't return True.

    >>> dtype = np.dtype({'names':['monty', 'pithon'***REMOVED***,
                          'formats':[np.bool, np.bool***REMOVED******REMOVED******REMOVED***
    >>> dtype
    dtype([('monty', '|b1'***REMOVED***, ('pithon', '|b1'***REMOVED******REMOVED******REMOVED***
    >>> m = np.array([(True, False***REMOVED***, (False, True***REMOVED***, (True, False***REMOVED******REMOVED***,
                     dtype=dtype***REMOVED***
    >>> m
    array([(True, False***REMOVED***, (False, True***REMOVED***, (True, False***REMOVED******REMOVED***,
          dtype=[('monty', '|b1'***REMOVED***, ('pithon', '|b1'***REMOVED******REMOVED******REMOVED***
    >>> ma.is_mask(m***REMOVED***
    False

    ***REMOVED***
    ***REMOVED***
        return m.dtype.type is MaskType
    except AttributeError:
        return False


def make_mask(m, copy=False, shrink=True, dtype=MaskType***REMOVED***:
    ***REMOVED***
    Create a boolean mask from an array.

    Return `m` as a boolean mask, creating a copy if necessary or requested.
    The function can accept any sequence that is convertible to integers,
    or ``nomask``.  Does not require that contents must be 0s and 1s, values
    of 0 are interepreted as False, everything else as True.

    Parameters
    ----------
    m : array_like
        Potential mask.
    copy : bool, optional
        Whether to return a copy of `m` (True***REMOVED*** or `m` itself (False***REMOVED***.
    shrink : bool, optional
        Whether to shrink `m` to ``nomask`` if all its values are False.
    dtype : dtype, optional
        Data-type of the output mask. By default, the output mask has a
        dtype of MaskType (bool***REMOVED***. If the dtype is flexible, each field has
        a boolean dtype. This is ignored when `m` is ``nomask``, in which
        case ``nomask`` is always returned.

    Returns
    -------
    result : ndarray
        A boolean mask derived from `m`.

    Examples
    --------
    >>> import numpy.ma as ma
    >>> m = [True, False, True, True***REMOVED***
    >>> ma.make_mask(m***REMOVED***
    array([ True, False,  True,  True***REMOVED***, dtype=bool***REMOVED***
    >>> m = [1, 0, 1, 1***REMOVED***
    >>> ma.make_mask(m***REMOVED***
    array([ True, False,  True,  True***REMOVED***, dtype=bool***REMOVED***
    >>> m = [1, 0, 2, -3***REMOVED***
    >>> ma.make_mask(m***REMOVED***
    array([ True, False,  True,  True***REMOVED***, dtype=bool***REMOVED***

    Effect of the `shrink` parameter.

    >>> m = np.zeros(4***REMOVED***
    >>> m
    array([ 0.,  0.,  0.,  0.***REMOVED******REMOVED***
    >>> ma.make_mask(m***REMOVED***
    False
    >>> ma.make_mask(m, shrink=False***REMOVED***
    array([False, False, False, False***REMOVED***, dtype=bool***REMOVED***

    Using a flexible `dtype`.

    >>> m = [1, 0, 1, 1***REMOVED***
    >>> n = [0, 1, 0, 0***REMOVED***
    >>> arr = [***REMOVED***
    >>> for man, mouse in zip(m, n***REMOVED***:
    ...     arr.append((man, mouse***REMOVED******REMOVED***
    >>> arr
    [(1, 0***REMOVED***, (0, 1***REMOVED***, (1, 0***REMOVED***, (1, 0***REMOVED******REMOVED***
    >>> dtype = np.dtype({'names':['man', 'mouse'***REMOVED***,
                          'formats':[np.int, np.int***REMOVED******REMOVED******REMOVED***
    >>> arr = np.array(arr, dtype=dtype***REMOVED***
    >>> arr
    array([(1, 0***REMOVED***, (0, 1***REMOVED***, (1, 0***REMOVED***, (1, 0***REMOVED******REMOVED***,
          dtype=[('man', '<i4'***REMOVED***, ('mouse', '<i4'***REMOVED******REMOVED******REMOVED***
    >>> ma.make_mask(arr, dtype=dtype***REMOVED***
    array([(True, False***REMOVED***, (False, True***REMOVED***, (True, False***REMOVED***, (True, False***REMOVED******REMOVED***,
          dtype=[('man', '|b1'***REMOVED***, ('mouse', '|b1'***REMOVED******REMOVED******REMOVED***

    ***REMOVED***
    if m is nomask:
        return nomask
    elif isinstance(m, ndarray***REMOVED***:
        # We won't return after this point to make sure we can shrink the mask
        # Fill the mask in case there are missing data
        m = filled(m, True***REMOVED***
        # Make sure the input dtype is valid
        dtype = make_mask_descr(dtype***REMOVED***
        if m.dtype == dtype:
            if copy:
                result = m.copy(***REMOVED***
            else:
                result = m
        else:
            result = np.array(m, dtype=dtype, copy=copy***REMOVED***
    else:
        result = np.array(filled(m, True***REMOVED***, dtype=MaskType***REMOVED***
    # Bas les masques !
    if shrink and (not result.dtype.names***REMOVED*** and (not result.any(***REMOVED******REMOVED***:
        return nomask
    else:
        return result


def make_mask_none(newshape, dtype=None***REMOVED***:
    ***REMOVED***
    Return a boolean mask of the given shape, filled with False.

    This function returns a boolean ndarray with all entries False, that can
    be used in common mask manipulations. If a complex dtype is specified, the
    type of each field is converted to a boolean type.

    Parameters
    ----------
    newshape : tuple
        A tuple indicating the shape of the mask.
    dtype : {None, dtype***REMOVED***, optional
        If None, use a MaskType instance. Otherwise, use a new datatype with
        the same fields as `dtype`, converted to boolean types.

    Returns
    -------
    result : ndarray
        An ndarray of appropriate shape and dtype, filled with False.

    See Also
    --------
    make_mask : Create a boolean mask from an array.
    make_mask_descr : Construct a dtype description list from a given dtype.

    Examples
    --------
    >>> import numpy.ma as ma
    >>> ma.make_mask_none((3,***REMOVED******REMOVED***
    array([False, False, False***REMOVED***, dtype=bool***REMOVED***

    Defining a more complex dtype.

    >>> dtype = np.dtype({'names':['foo', 'bar'***REMOVED***,
                          'formats':[np.float32, np.int***REMOVED******REMOVED******REMOVED***
    >>> dtype
    dtype([('foo', '<f4'***REMOVED***, ('bar', '<i4'***REMOVED******REMOVED******REMOVED***
    >>> ma.make_mask_none((3,***REMOVED***, dtype=dtype***REMOVED***
    array([(False, False***REMOVED***, (False, False***REMOVED***, (False, False***REMOVED******REMOVED***,
          dtype=[('foo', '|b1'***REMOVED***, ('bar', '|b1'***REMOVED******REMOVED******REMOVED***

    ***REMOVED***
    if dtype is None:
        result = np.zeros(newshape, dtype=MaskType***REMOVED***
    else:
        result = np.zeros(newshape, dtype=make_mask_descr(dtype***REMOVED******REMOVED***
    return result


def mask_or(m1, m2, copy=False, shrink=True***REMOVED***:
    ***REMOVED***
    Combine two masks with the ``logical_or`` operator.

    The result may be a view on `m1` or `m2` if the other is `nomask`
    (i.e. False***REMOVED***.

    Parameters
    ----------
    m1, m2 : array_like
        Input masks.
    copy : bool, optional
        If copy is False and one of the inputs is `nomask`, return a view
        of the other input mask. Defaults to False.
    shrink : bool, optional
        Whether to shrink the output to `nomask` if all its values are
        False. Defaults to True.

    Returns
    -------
    mask : output mask
        The result masks values that are masked in either `m1` or `m2`.

    Raises
    ------
    ValueError
        If `m1` and `m2` have different flexible dtypes.

    Examples
    --------
    >>> m1 = np.ma.make_mask([0, 1, 1, 0***REMOVED******REMOVED***
    >>> m2 = np.ma.make_mask([1, 0, 0, 0***REMOVED******REMOVED***
    >>> np.ma.mask_or(m1, m2***REMOVED***
    array([ True,  True,  True, False***REMOVED***, dtype=bool***REMOVED***

    ***REMOVED***

    def _recursive_mask_or(m1, m2, newmask***REMOVED***:
        names = m1.dtype.names
        for name in names:
            current1 = m1[name***REMOVED***
            if current1.dtype.names:
                _recursive_mask_or(current1, m2[name***REMOVED***, newmask[name***REMOVED******REMOVED***
            else:
                umath.logical_or(current1, m2[name***REMOVED***, newmask[name***REMOVED******REMOVED***
        return

    if (m1 is nomask***REMOVED*** or (m1 is False***REMOVED***:
        dtype = getattr(m2, 'dtype', MaskType***REMOVED***
        return make_mask(m2, copy=copy, shrink=shrink, dtype=dtype***REMOVED***
    if (m2 is nomask***REMOVED*** or (m2 is False***REMOVED***:
        dtype = getattr(m1, 'dtype', MaskType***REMOVED***
        return make_mask(m1, copy=copy, shrink=shrink, dtype=dtype***REMOVED***
    if m1 is m2 and is_mask(m1***REMOVED***:
        return m1
    (dtype1, dtype2***REMOVED*** = (getattr(m1, 'dtype', None***REMOVED***, getattr(m2, 'dtype', None***REMOVED******REMOVED***
    if (dtype1 != dtype2***REMOVED***:
        raise ValueError("Incompatible dtypes '%s'<>'%s'" % (dtype1, dtype2***REMOVED******REMOVED***
    if dtype1.names:
        newmask = np.empty_like(m1***REMOVED***
        _recursive_mask_or(m1, m2, newmask***REMOVED***
        return newmask
    return make_mask(umath.logical_or(m1, m2***REMOVED***, copy=copy, shrink=shrink***REMOVED***


def flatten_mask(mask***REMOVED***:
    ***REMOVED***
    Returns a completely flattened version of the mask, where nested fields
    are collapsed.

    Parameters
    ----------
    mask : array_like
        Input array, which will be interpreted as booleans.

    Returns
    -------
    flattened_mask : ndarray of bools
        The flattened input.

    Examples
    --------
    >>> mask = np.array([0, 0, 1***REMOVED***, dtype=np.bool***REMOVED***
    >>> flatten_mask(mask***REMOVED***
    array([False, False,  True***REMOVED***, dtype=bool***REMOVED***

    >>> mask = np.array([(0, 0***REMOVED***, (0, 1***REMOVED******REMOVED***, dtype=[('a', bool***REMOVED***, ('b', bool***REMOVED******REMOVED******REMOVED***
    >>> flatten_mask(mask***REMOVED***
    array([False, False, False,  True***REMOVED***, dtype=bool***REMOVED***

    >>> mdtype = [('a', bool***REMOVED***, ('b', [('ba', bool***REMOVED***, ('bb', bool***REMOVED******REMOVED******REMOVED******REMOVED***
    >>> mask = np.array([(0, (0, 0***REMOVED******REMOVED***, (0, (0, 1***REMOVED******REMOVED******REMOVED***, dtype=mdtype***REMOVED***
    >>> flatten_mask(mask***REMOVED***
    array([False, False, False, False, False,  True***REMOVED***, dtype=bool***REMOVED***

    ***REMOVED***

    def _flatmask(mask***REMOVED***:
        "Flatten the mask and returns a (maybe nested***REMOVED*** sequence of booleans."
        mnames = mask.dtype.names
        if mnames:
            return [flatten_mask(mask[name***REMOVED******REMOVED*** for name in mnames***REMOVED***
        else:
            return mask

    def _flatsequence(sequence***REMOVED***:
        "Generates a flattened version of the sequence."
        ***REMOVED***
            for element in sequence:
                if hasattr(element, '__iter__'***REMOVED***:
                    for f in _flatsequence(element***REMOVED***:
                        yield f
                else:
                    yield element
        except TypeError:
            yield sequence

    mask = np.asarray(mask***REMOVED***
    flattened = _flatsequence(_flatmask(mask***REMOVED******REMOVED***
    return np.array([_ for _ in flattened***REMOVED***, dtype=bool***REMOVED***


def _check_mask_axis(mask, axis, keepdims=np._NoValue***REMOVED***:
    "Check whether there are masked values along the given axis"
    kwargs = {***REMOVED*** if keepdims is np._NoValue else {'keepdims': keepdims***REMOVED***
    if mask is not nomask:
        return mask.all(axis=axis, **kwargs***REMOVED***
    return nomask


###############################################################################
#                             Masking functions                               #
###############################################################################

def masked_where(condition, a, copy=True***REMOVED***:
    ***REMOVED***
    Mask an array where a condition is met.

    Return `a` as an array masked where `condition` is True.
    Any masked values of `a` or `condition` are also masked in the output.

    Parameters
    ----------
    condition : array_like
        Masking condition.  When `condition` tests floating point values for
        equality, consider using ``masked_values`` instead.
    a : array_like
        Array to mask.
    copy : bool
        If True (default***REMOVED*** make a copy of `a` in the result.  If False modify
        `a` in place and return a view.

    Returns
    -------
    result : MaskedArray
        The result of masking `a` where `condition` is True.

    See Also
    --------
    masked_values : Mask using floating point equality.
    masked_equal : Mask where equal to a given value.
    masked_not_equal : Mask where `not` equal to a given value.
    masked_less_equal : Mask where less than or equal to a given value.
    masked_greater_equal : Mask where greater than or equal to a given value.
    masked_less : Mask where less than a given value.
    masked_greater : Mask where greater than a given value.
    masked_inside : Mask inside a given interval.
    masked_outside : Mask outside a given interval.
    masked_invalid : Mask invalid values (NaNs or infs***REMOVED***.

    Examples
    --------
    >>> import numpy.ma as ma
    >>> a = np.arange(4***REMOVED***
    >>> a
    array([0, 1, 2, 3***REMOVED******REMOVED***
    >>> ma.masked_where(a <= 2, a***REMOVED***
    masked_array(data = [-- -- -- 3***REMOVED***,
          mask = [ True  True  True False***REMOVED***,
          fill_value=999999***REMOVED***

    Mask array `b` conditional on `a`.

    >>> b = ['a', 'b', 'c', 'd'***REMOVED***
    >>> ma.masked_where(a == 2, b***REMOVED***
    masked_array(data = [a b -- d***REMOVED***,
          mask = [False False  True False***REMOVED***,
          fill_value=N/A***REMOVED***

    Effect of the `copy` argument.

    >>> c = ma.masked_where(a <= 2, a***REMOVED***
    >>> c
    masked_array(data = [-- -- -- 3***REMOVED***,
          mask = [ True  True  True False***REMOVED***,
          fill_value=999999***REMOVED***
    >>> c[0***REMOVED*** = 99
    >>> c
    masked_array(data = [99 -- -- 3***REMOVED***,
          mask = [False  True  True False***REMOVED***,
          fill_value=999999***REMOVED***
    >>> a
    array([0, 1, 2, 3***REMOVED******REMOVED***
    >>> c = ma.masked_where(a <= 2, a, copy=False***REMOVED***
    >>> c[0***REMOVED*** = 99
    >>> c
    masked_array(data = [99 -- -- 3***REMOVED***,
          mask = [False  True  True False***REMOVED***,
          fill_value=999999***REMOVED***
    >>> a
    array([99,  1,  2,  3***REMOVED******REMOVED***

    When `condition` or `a` contain masked values.

    >>> a = np.arange(4***REMOVED***
    >>> a = ma.masked_where(a == 2, a***REMOVED***
    >>> a
    masked_array(data = [0 1 -- 3***REMOVED***,
          mask = [False False  True False***REMOVED***,
          fill_value=999999***REMOVED***
    >>> b = np.arange(4***REMOVED***
    >>> b = ma.masked_where(b == 0, b***REMOVED***
    >>> b
    masked_array(data = [-- 1 2 3***REMOVED***,
          mask = [ True False False False***REMOVED***,
          fill_value=999999***REMOVED***
    >>> ma.masked_where(a == 3, b***REMOVED***
    masked_array(data = [-- 1 -- --***REMOVED***,
          mask = [ True False  True  True***REMOVED***,
          fill_value=999999***REMOVED***

    ***REMOVED***
    # Make sure that condition is a valid standard-type mask.
    cond = make_mask(condition***REMOVED***
    a = np.array(a, copy=copy, subok=True***REMOVED***

    (cshape, ashape***REMOVED*** = (cond.shape, a.shape***REMOVED***
    if cshape and cshape != ashape:
        raise IndexError("Inconsistant shape between the condition and the input"
                         " (got %s and %s***REMOVED***" % (cshape, ashape***REMOVED******REMOVED***
    if hasattr(a, '_mask'***REMOVED***:
        cond = mask_or(cond, a._mask***REMOVED***
        cls = type(a***REMOVED***
    else:
        cls = MaskedArray
    result = a.view(cls***REMOVED***
    # Assign to *.mask so that structured masks are handled correctly.
    result.mask = cond
    return result


def masked_greater(x, value, copy=True***REMOVED***:
    ***REMOVED***
    Mask an array where greater than a given value.

    This function is a shortcut to ``masked_where``, with
    `condition` = (x > value***REMOVED***.

    See Also
    --------
    masked_where : Mask where a condition is met.

    Examples
    --------
    >>> import numpy.ma as ma
    >>> a = np.arange(4***REMOVED***
    >>> a
    array([0, 1, 2, 3***REMOVED******REMOVED***
    >>> ma.masked_greater(a, 2***REMOVED***
    masked_array(data = [0 1 2 --***REMOVED***,
          mask = [False False False  True***REMOVED***,
          fill_value=999999***REMOVED***

    ***REMOVED***
    return masked_where(greater(x, value***REMOVED***, x, copy=copy***REMOVED***


def masked_greater_equal(x, value, copy=True***REMOVED***:
    ***REMOVED***
    Mask an array where greater than or equal to a given value.

    This function is a shortcut to ``masked_where``, with
    `condition` = (x >= value***REMOVED***.

    See Also
    --------
    masked_where : Mask where a condition is met.

    Examples
    --------
    >>> import numpy.ma as ma
    >>> a = np.arange(4***REMOVED***
    >>> a
    array([0, 1, 2, 3***REMOVED******REMOVED***
    >>> ma.masked_greater_equal(a, 2***REMOVED***
    masked_array(data = [0 1 -- --***REMOVED***,
          mask = [False False  True  True***REMOVED***,
          fill_value=999999***REMOVED***

    ***REMOVED***
    return masked_where(greater_equal(x, value***REMOVED***, x, copy=copy***REMOVED***


def masked_less(x, value, copy=True***REMOVED***:
    ***REMOVED***
    Mask an array where less than a given value.

    This function is a shortcut to ``masked_where``, with
    `condition` = (x < value***REMOVED***.

    See Also
    --------
    masked_where : Mask where a condition is met.

    Examples
    --------
    >>> import numpy.ma as ma
    >>> a = np.arange(4***REMOVED***
    >>> a
    array([0, 1, 2, 3***REMOVED******REMOVED***
    >>> ma.masked_less(a, 2***REMOVED***
    masked_array(data = [-- -- 2 3***REMOVED***,
          mask = [ True  True False False***REMOVED***,
          fill_value=999999***REMOVED***

    ***REMOVED***
    return masked_where(less(x, value***REMOVED***, x, copy=copy***REMOVED***


def masked_less_equal(x, value, copy=True***REMOVED***:
    ***REMOVED***
    Mask an array where less than or equal to a given value.

    This function is a shortcut to ``masked_where``, with
    `condition` = (x <= value***REMOVED***.

    See Also
    --------
    masked_where : Mask where a condition is met.

    Examples
    --------
    >>> import numpy.ma as ma
    >>> a = np.arange(4***REMOVED***
    >>> a
    array([0, 1, 2, 3***REMOVED******REMOVED***
    >>> ma.masked_less_equal(a, 2***REMOVED***
    masked_array(data = [-- -- -- 3***REMOVED***,
          mask = [ True  True  True False***REMOVED***,
          fill_value=999999***REMOVED***

    ***REMOVED***
    return masked_where(less_equal(x, value***REMOVED***, x, copy=copy***REMOVED***


def masked_not_equal(x, value, copy=True***REMOVED***:
    ***REMOVED***
    Mask an array where `not` equal to a given value.

    This function is a shortcut to ``masked_where``, with
    `condition` = (x != value***REMOVED***.

    See Also
    --------
    masked_where : Mask where a condition is met.

    Examples
    --------
    >>> import numpy.ma as ma
    >>> a = np.arange(4***REMOVED***
    >>> a
    array([0, 1, 2, 3***REMOVED******REMOVED***
    >>> ma.masked_not_equal(a, 2***REMOVED***
    masked_array(data = [-- -- 2 --***REMOVED***,
          mask = [ True  True False  True***REMOVED***,
          fill_value=999999***REMOVED***

    ***REMOVED***
    return masked_where(not_equal(x, value***REMOVED***, x, copy=copy***REMOVED***


def masked_equal(x, value, copy=True***REMOVED***:
    ***REMOVED***
    Mask an array where equal to a given value.

    This function is a shortcut to ``masked_where``, with
    `condition` = (x == value***REMOVED***.  For floating point arrays,
    consider using ``masked_values(x, value***REMOVED***``.

    See Also
    --------
    masked_where : Mask where a condition is met.
    masked_values : Mask using floating point equality.

    Examples
    --------
    >>> import numpy.ma as ma
    >>> a = np.arange(4***REMOVED***
    >>> a
    array([0, 1, 2, 3***REMOVED******REMOVED***
    >>> ma.masked_equal(a, 2***REMOVED***
    masked_array(data = [0 1 -- 3***REMOVED***,
          mask = [False False  True False***REMOVED***,
          fill_value=999999***REMOVED***

    ***REMOVED***
    output = masked_where(equal(x, value***REMOVED***, x, copy=copy***REMOVED***
    output.fill_value = value
    return output


def masked_inside(x, v1, v2, copy=True***REMOVED***:
    ***REMOVED***
    Mask an array inside a given interval.

    Shortcut to ``masked_where``, where `condition` is True for `x` inside
    the interval [v1,v2***REMOVED*** (v1 <= x <= v2***REMOVED***.  The boundaries `v1` and `v2`
    can be given in either order.

    See Also
    --------
    masked_where : Mask where a condition is met.

    Notes
    -----
    The array `x` is prefilled with its filling value.

    Examples
    --------
    >>> import numpy.ma as ma
    >>> x = [0.31, 1.2, 0.01, 0.2, -0.4, -1.1***REMOVED***
    >>> ma.masked_inside(x, -0.3, 0.3***REMOVED***
    masked_array(data = [0.31 1.2 -- -- -0.4 -1.1***REMOVED***,
          mask = [False False  True  True False False***REMOVED***,
          fill_value=1e+20***REMOVED***

    The order of `v1` and `v2` doesn't matter.

    >>> ma.masked_inside(x, 0.3, -0.3***REMOVED***
    masked_array(data = [0.31 1.2 -- -- -0.4 -1.1***REMOVED***,
          mask = [False False  True  True False False***REMOVED***,
          fill_value=1e+20***REMOVED***

    ***REMOVED***
    if v2 < v1:
        (v1, v2***REMOVED*** = (v2, v1***REMOVED***
    xf = filled(x***REMOVED***
    condition = (xf >= v1***REMOVED*** & (xf <= v2***REMOVED***
    return masked_where(condition, x, copy=copy***REMOVED***


def masked_outside(x, v1, v2, copy=True***REMOVED***:
    ***REMOVED***
    Mask an array outside a given interval.

    Shortcut to ``masked_where``, where `condition` is True for `x` outside
    the interval [v1,v2***REMOVED*** (x < v1***REMOVED***|(x > v2***REMOVED***.
    The boundaries `v1` and `v2` can be given in either order.

    See Also
    --------
    masked_where : Mask where a condition is met.

    Notes
    -----
    The array `x` is prefilled with its filling value.

    Examples
    --------
    >>> import numpy.ma as ma
    >>> x = [0.31, 1.2, 0.01, 0.2, -0.4, -1.1***REMOVED***
    >>> ma.masked_outside(x, -0.3, 0.3***REMOVED***
    masked_array(data = [-- -- 0.01 0.2 -- --***REMOVED***,
          mask = [ True  True False False  True  True***REMOVED***,
          fill_value=1e+20***REMOVED***

    The order of `v1` and `v2` doesn't matter.

    >>> ma.masked_outside(x, 0.3, -0.3***REMOVED***
    masked_array(data = [-- -- 0.01 0.2 -- --***REMOVED***,
          mask = [ True  True False False  True  True***REMOVED***,
          fill_value=1e+20***REMOVED***

    ***REMOVED***
    if v2 < v1:
        (v1, v2***REMOVED*** = (v2, v1***REMOVED***
    xf = filled(x***REMOVED***
    condition = (xf < v1***REMOVED*** | (xf > v2***REMOVED***
    return masked_where(condition, x, copy=copy***REMOVED***


def masked_object(x, value, copy=True, shrink=True***REMOVED***:
    ***REMOVED***
    Mask the array `x` where the data are exactly equal to value.

    This function is similar to `masked_values`, but only suitable
    for object arrays: for floating point, use `masked_values` instead.

    Parameters
    ----------
    x : array_like
        Array to mask
    value : object
        Comparison value
    copy : {True, False***REMOVED***, optional
        Whether to return a copy of `x`.
    shrink : {True, False***REMOVED***, optional
        Whether to collapse a mask full of False to nomask

    Returns
    -------
    result : MaskedArray
        The result of masking `x` where equal to `value`.

    See Also
    --------
    masked_where : Mask where a condition is met.
    masked_equal : Mask where equal to a given value (integers***REMOVED***.
    masked_values : Mask using floating point equality.

    Examples
    --------
    >>> import numpy.ma as ma
    >>> food = np.array(['green_eggs', 'ham'***REMOVED***, dtype=object***REMOVED***
    >>> # don't eat spoiled food
    >>> eat = ma.masked_object(food, 'green_eggs'***REMOVED***
    >>> print(eat***REMOVED***
    [-- ham***REMOVED***
    >>> # plain ol` ham is boring
    >>> fresh_food = np.array(['cheese', 'ham', 'pineapple'***REMOVED***, dtype=object***REMOVED***
    >>> eat = ma.masked_object(fresh_food, 'green_eggs'***REMOVED***
    >>> print(eat***REMOVED***
    [cheese ham pineapple***REMOVED***

    Note that `mask` is set to ``nomask`` if possible.

    >>> eat
    masked_array(data = [cheese ham pineapple***REMOVED***,
          mask = False,
          fill_value=?***REMOVED***

    ***REMOVED***
    if isMaskedArray(x***REMOVED***:
        condition = umath.equal(x._data, value***REMOVED***
        mask = x._mask
    else:
        condition = umath.equal(np.asarray(x***REMOVED***, value***REMOVED***
        mask = nomask
    mask = mask_or(mask, make_mask(condition, shrink=shrink***REMOVED******REMOVED***
    return masked_array(x, mask=mask, copy=copy, fill_value=value***REMOVED***


def masked_values(x, value, rtol=1e-5, atol=1e-8, copy=True, shrink=True***REMOVED***:
    ***REMOVED***
    Mask using floating point equality.

    Return a MaskedArray, masked where the data in array `x` are approximately
    equal to `value`, i.e. where the following condition is True

    (abs(x - value***REMOVED*** <= atol+rtol*abs(value***REMOVED******REMOVED***

    The fill_value is set to `value` and the mask is set to ``nomask`` if
    possible.  For integers, consider using ``masked_equal``.

    Parameters
    ----------
    x : array_like
        Array to mask.
    value : float
        Masking value.
    rtol : float, optional
        Tolerance parameter.
    atol : float, optional
        Tolerance parameter (1e-8***REMOVED***.
    copy : bool, optional
        Whether to return a copy of `x`.
    shrink : bool, optional
        Whether to collapse a mask full of False to ``nomask``.

    Returns
    -------
    result : MaskedArray
        The result of masking `x` where approximately equal to `value`.

    See Also
    --------
    masked_where : Mask where a condition is met.
    masked_equal : Mask where equal to a given value (integers***REMOVED***.

    Examples
    --------
    >>> import numpy.ma as ma
    >>> x = np.array([1, 1.1, 2, 1.1, 3***REMOVED******REMOVED***
    >>> ma.masked_values(x, 1.1***REMOVED***
    masked_array(data = [1.0 -- 2.0 -- 3.0***REMOVED***,
          mask = [False  True False  True False***REMOVED***,
          fill_value=1.1***REMOVED***

    Note that `mask` is set to ``nomask`` if possible.

    >>> ma.masked_values(x, 1.5***REMOVED***
    masked_array(data = [ 1.   1.1  2.   1.1  3. ***REMOVED***,
          mask = False,
          fill_value=1.5***REMOVED***

    For integers, the fill value will be different in general to the
    result of ``masked_equal``.

    >>> x = np.arange(5***REMOVED***
    >>> x
    array([0, 1, 2, 3, 4***REMOVED******REMOVED***
    >>> ma.masked_values(x, 2***REMOVED***
    masked_array(data = [0 1 -- 3 4***REMOVED***,
          mask = [False False  True False False***REMOVED***,
          fill_value=2***REMOVED***
    >>> ma.masked_equal(x, 2***REMOVED***
    masked_array(data = [0 1 -- 3 4***REMOVED***,
          mask = [False False  True False False***REMOVED***,
          fill_value=999999***REMOVED***

    ***REMOVED***
    mabs = umath.absolute
    xnew = filled(x, value***REMOVED***
    if issubclass(xnew.dtype.type, np.floating***REMOVED***:
        condition = umath.less_equal(
            mabs(xnew - value***REMOVED***, atol + rtol * mabs(value***REMOVED******REMOVED***
        mask = getattr(x, '_mask', nomask***REMOVED***
    else:
        condition = umath.equal(xnew, value***REMOVED***
        mask = nomask
    mask = mask_or(mask, make_mask(condition, shrink=shrink***REMOVED***, shrink=shrink***REMOVED***
    return masked_array(xnew, mask=mask, copy=copy, fill_value=value***REMOVED***


def masked_invalid(a, copy=True***REMOVED***:
    ***REMOVED***
    Mask an array where invalid values occur (NaNs or infs***REMOVED***.

    This function is a shortcut to ``masked_where``, with
    `condition` = ~(np.isfinite(a***REMOVED******REMOVED***. Any pre-existing mask is conserved.
    Only applies to arrays with a dtype where NaNs or infs make sense
    (i.e. floating point types***REMOVED***, but accepts any array_like object.

    See Also
    --------
    masked_where : Mask where a condition is met.

    Examples
    --------
    >>> import numpy.ma as ma
    >>> a = np.arange(5, dtype=np.float***REMOVED***
    >>> a[2***REMOVED*** = np.NaN
    >>> a[3***REMOVED*** = np.PINF
    >>> a
    array([  0.,   1.,  NaN,  Inf,   4.***REMOVED******REMOVED***
    >>> ma.masked_invalid(a***REMOVED***
    masked_array(data = [0.0 1.0 -- -- 4.0***REMOVED***,
          mask = [False False  True  True False***REMOVED***,
          fill_value=1e+20***REMOVED***

    ***REMOVED***
    a = np.array(a, copy=copy, subok=True***REMOVED***
    mask = getattr(a, '_mask', None***REMOVED***
    if mask is not None:
        condition = ~(np.isfinite(getdata(a***REMOVED******REMOVED******REMOVED***
        if mask is not nomask:
            condition |= mask
        cls = type(a***REMOVED***
    else:
        condition = ~(np.isfinite(a***REMOVED******REMOVED***
        cls = MaskedArray
    result = a.view(cls***REMOVED***
    result._mask = condition
    return result


###############################################################################
#                            Printing options                                 #
###############################################################################


class _MaskedPrintOption:
    ***REMOVED***
    Handle the string used to represent missing data in a masked array.

    ***REMOVED***

    def __init__(self, display***REMOVED***:
        ***REMOVED***
        Create the masked_print_option object.

        ***REMOVED***
        self._display = display
        self._enabled = True

    def display(self***REMOVED***:
        ***REMOVED***
        Display the string to print for masked values.

        ***REMOVED***
        return self._display

    def set_display(self, s***REMOVED***:
        ***REMOVED***
        Set the string to print for masked values.

        ***REMOVED***
        self._display = s

    def enabled(self***REMOVED***:
        ***REMOVED***
        Is the use of the display value enabled?

        ***REMOVED***
        return self._enabled

    def enable(self, shrink=1***REMOVED***:
        ***REMOVED***
        Set the enabling shrink to `shrink`.

        ***REMOVED***
        self._enabled = shrink

    def __str__(self***REMOVED***:
        return str(self._display***REMOVED***

    __repr__ = __str__

# if you single index into a masked location you get this object.
masked_print_option = _MaskedPrintOption('--'***REMOVED***


def _recursive_printoption(result, mask, printopt***REMOVED***:
    ***REMOVED***
    Puts printoptions in result where mask is True.

    Private function allowing for recursion

    ***REMOVED***
    names = result.dtype.names
    for name in names:
        (curdata, curmask***REMOVED*** = (result[name***REMOVED***, mask[name***REMOVED******REMOVED***
        if curdata.dtype.names:
            _recursive_printoption(curdata, curmask, printopt***REMOVED***
        else:
            np.copyto(curdata, printopt, where=curmask***REMOVED***
    return

_print_templates = dict(long_std=***REMOVED***\
masked_%(name***REMOVED***s(data =
 %(data***REMOVED***s,
       %(nlen***REMOVED***s mask =
 %(mask***REMOVED***s,
 %(nlen***REMOVED***s fill_value = %(fill***REMOVED***s***REMOVED***
***REMOVED***,
                        short_std=***REMOVED***\
masked_%(name***REMOVED***s(data = %(data***REMOVED***s,
       %(nlen***REMOVED***s mask = %(mask***REMOVED***s,
%(nlen***REMOVED***s  fill_value = %(fill***REMOVED***s***REMOVED***
***REMOVED***,
                        long_flx=***REMOVED***\
masked_%(name***REMOVED***s(data =
 %(data***REMOVED***s,
       %(nlen***REMOVED***s mask =
 %(mask***REMOVED***s,
%(nlen***REMOVED***s  fill_value = %(fill***REMOVED***s,
      %(nlen***REMOVED***s dtype = %(dtype***REMOVED***s***REMOVED***
***REMOVED***,
                        short_flx=***REMOVED***\
masked_%(name***REMOVED***s(data = %(data***REMOVED***s,
%(nlen***REMOVED***s        mask = %(mask***REMOVED***s,
%(nlen***REMOVED***s  fill_value = %(fill***REMOVED***s,
%(nlen***REMOVED***s       dtype = %(dtype***REMOVED***s***REMOVED***
***REMOVED******REMOVED***

###############################################################################
#                          MaskedArray class                                  #
###############################################################################


def _recursive_filled(a, mask, fill_value***REMOVED***:
    ***REMOVED***
    Recursively fill `a` with `fill_value`.

    ***REMOVED***
    names = a.dtype.names
    for name in names:
        current = a[name***REMOVED***
        if current.dtype.names:
            _recursive_filled(current, mask[name***REMOVED***, fill_value[name***REMOVED******REMOVED***
        else:
            np.copyto(current, fill_value[name***REMOVED***, where=mask[name***REMOVED******REMOVED***


def flatten_structured_array(a***REMOVED***:
    ***REMOVED***
    Flatten a structured array.

    The data type of the output is chosen such that it can represent all of the
    (nested***REMOVED*** fields.

    Parameters
    ----------
    a : structured array

    Returns
    -------
    output : masked array or ndarray
        A flattened masked array if the input is a masked array, otherwise a
        standard ndarray.

    Examples
    --------
    >>> ndtype = [('a', int***REMOVED***, ('b', float***REMOVED******REMOVED***
    >>> a = np.array([(1, 1***REMOVED***, (2, 2***REMOVED******REMOVED***, dtype=ndtype***REMOVED***
    >>> flatten_structured_array(a***REMOVED***
    array([[1., 1.***REMOVED***,
           [2., 2.***REMOVED******REMOVED******REMOVED***

    ***REMOVED***

    def flatten_sequence(iterable***REMOVED***:
        ***REMOVED***
        Flattens a compound of nested iterables.

        ***REMOVED***
        for elm in iter(iterable***REMOVED***:
            if hasattr(elm, '__iter__'***REMOVED***:
                for f in flatten_sequence(elm***REMOVED***:
                    yield f
            else:
                yield elm

    a = np.asanyarray(a***REMOVED***
    inishape = a.shape
    a = a.ravel(***REMOVED***
    if isinstance(a, MaskedArray***REMOVED***:
        out = np.array([tuple(flatten_sequence(d.item(***REMOVED******REMOVED******REMOVED*** for d in a._data***REMOVED******REMOVED***
        out = out.view(MaskedArray***REMOVED***
        out._mask = np.array([tuple(flatten_sequence(d.item(***REMOVED******REMOVED******REMOVED***
                              for d in getmaskarray(a***REMOVED******REMOVED******REMOVED***
    else:
        out = np.array([tuple(flatten_sequence(d.item(***REMOVED******REMOVED******REMOVED*** for d in a***REMOVED******REMOVED***
    if len(inishape***REMOVED*** > 1:
        newshape = list(out.shape***REMOVED***
        newshape[0***REMOVED*** = inishape
        out.shape = tuple(flatten_sequence(newshape***REMOVED******REMOVED***
    return out


def _arraymethod(funcname, onmask=True***REMOVED***:
    ***REMOVED***
    Return a class method wrapper around a basic array method.

    Creates a class method which returns a masked array, where the new
    ``_data`` array is the output of the corresponding basic method called
    on the original ``_data``.

    If `onmask` is True, the new mask is the output of the method called
    on the initial mask. Otherwise, the new mask is just a reference
    to the initial mask.

    Parameters
    ----------
    funcname : str
        Name of the function to apply on data.
    onmask : bool
        Whether the mask must be processed also (True***REMOVED*** or left
        alone (False***REMOVED***. Default is True. Make available as `_onmask`
        attribute.

    Returns
    -------
    method : instancemethod
        Class method wrapper of the specified basic array method.

    ***REMOVED***
    def wrapped_method(self, *args, **params***REMOVED***:
        result = getattr(self._data, funcname***REMOVED***(*args, **params***REMOVED***
        result = result.view(type(self***REMOVED******REMOVED***
        result._update_from(self***REMOVED***
        mask = self._mask
        if result.ndim:
            if not onmask:
                result.__setmask__(mask***REMOVED***
            elif mask is not nomask:
                result.__setmask__(getattr(mask, funcname***REMOVED***(*args, **params***REMOVED******REMOVED***
        else:
            if mask.ndim and (not mask.dtype.names and mask.all(***REMOVED******REMOVED***:
                return masked
        return result
    methdoc = getattr(ndarray, funcname, None***REMOVED*** or getattr(np, funcname, None***REMOVED***
    if methdoc is not None:
        wrapped_method.__doc__ = methdoc.__doc__
    wrapped_method.__name__ = funcname
    return wrapped_method


class MaskedIterator(object***REMOVED***:
    ***REMOVED***
    Flat iterator object to iterate over masked arrays.

    A `MaskedIterator` iterator is returned by ``x.flat`` for any masked array
    `x`. It allows iterating over the array as if it were a 1-D array,
    either in a for-loop or by calling its `next` method.

    Iteration is done in C-contiguous style, with the last index varying the
    fastest. The iterator can also be indexed using basic slicing or
    advanced indexing.

    See Also
    --------
    MaskedArray.flat : Return a flat iterator over an array.
    MaskedArray.flatten : Returns a flattened copy of an array.

    Notes
    -----
    `MaskedIterator` is not exported by the `ma` module. Instead of
    instantiating a `MaskedIterator` directly, use `MaskedArray.flat`.

    Examples
    --------
    >>> x = np.ma.array(arange(6***REMOVED***.reshape(2, 3***REMOVED******REMOVED***
    >>> fl = x.flat
    >>> type(fl***REMOVED***
    <class 'numpy.ma.core.MaskedIterator'>
    >>> for item in fl:
    ...     print(item***REMOVED***
    ...
    0
    1
    2
    3
    4
    5

    Extracting more than a single element b indexing the `MaskedIterator`
    returns a masked array:

    >>> fl[2:4***REMOVED***
    masked_array(data = [2 3***REMOVED***,
                 mask = False,
           fill_value = 999999***REMOVED***

    ***REMOVED***

    def __init__(self, ma***REMOVED***:
        self.ma = ma
        self.dataiter = ma._data.flat

        if ma._mask is nomask:
            self.maskiter = None
        else:
            self.maskiter = ma._mask.flat

    def __iter__(self***REMOVED***:
        return self

    def __getitem__(self, indx***REMOVED***:
        result = self.dataiter.__getitem__(indx***REMOVED***.view(type(self.ma***REMOVED******REMOVED***
        if self.maskiter is not None:
            _mask = self.maskiter.__getitem__(indx***REMOVED***
            if isinstance(_mask, ndarray***REMOVED***:
                # set shape to match that of data; this is needed for matrices
                _mask.shape = result.shape
                result._mask = _mask
            elif isinstance(_mask, np.void***REMOVED***:
                return mvoid(result, mask=_mask, hardmask=self.ma._hardmask***REMOVED***
            elif _mask:  # Just a scalar, masked
                return masked
        return result

    # This won't work if ravel makes a copy
    def __setitem__(self, index, value***REMOVED***:
        self.dataiter[index***REMOVED*** = getdata(value***REMOVED***
        if self.maskiter is not None:
            self.maskiter[index***REMOVED*** = getmaskarray(value***REMOVED***

    def __next__(self***REMOVED***:
        ***REMOVED***
        Return the next value, or raise StopIteration.

        Examples
        --------
        >>> x = np.ma.array([3, 2***REMOVED***, mask=[0, 1***REMOVED******REMOVED***
        >>> fl = x.flat
        >>> fl.next(***REMOVED***
        3
        >>> fl.next(***REMOVED***
        masked_array(data = --,
                     mask = True,
               fill_value = 1e+20***REMOVED***
        >>> fl.next(***REMOVED***
        Traceback (most recent call last***REMOVED***:
          File "<stdin>", line 1, in <module>
          File "/home/ralf/python/numpy/numpy/ma/core.py", line 2243, in next
            d = self.dataiter.next(***REMOVED***
        StopIteration

        ***REMOVED***
        d = next(self.dataiter***REMOVED***
        if self.maskiter is not None:
            m = next(self.maskiter***REMOVED***
            if isinstance(m, np.void***REMOVED***:
                return mvoid(d, mask=m, hardmask=self.ma._hardmask***REMOVED***
            elif m:  # Just a scalar, masked
                return masked
        return d

    next = __next__


class MaskedArray(ndarray***REMOVED***:
    ***REMOVED***
    An array class with possibly masked values.

    Masked values of True exclude the corresponding element from any
    computation.

    Construction::

      x = MaskedArray(data, mask=nomask, dtype=None, copy=False, subok=True,
                      ndmin=0, fill_value=None, keep_mask=True, hard_mask=None,
                      shrink=True, order=None***REMOVED***

    Parameters
    ----------
    data : array_like
        Input data.
    mask : sequence, optional
        Mask. Must be convertible to an array of booleans with the same
        shape as `data`. True indicates a masked (i.e. invalid***REMOVED*** data.
    dtype : dtype, optional
        Data type of the output.
        If `dtype` is None, the type of the data argument (``data.dtype``***REMOVED***
        is used. If `dtype` is not None and different from ``data.dtype``,
        a copy is performed.
    copy : bool, optional
        Whether to copy the input data (True***REMOVED***, or to use a reference instead.
        Default is False.
    subok : bool, optional
        Whether to return a subclass of `MaskedArray` if possible (True***REMOVED*** or a
        plain `MaskedArray`. Default is True.
    ndmin : int, optional
        Minimum number of dimensions. Default is 0.
    fill_value : scalar, optional
        Value used to fill in the masked values when necessary.
        If None, a default based on the data-type is used.
    keep_mask : bool, optional
        Whether to combine `mask` with the mask of the input data, if any
        (True***REMOVED***, or to use only `mask` for the output (False***REMOVED***. Default is True.
    hard_mask : bool, optional
        Whether to use a hard mask or not. With a hard mask, masked values
        cannot be unmasked. Default is False.
    shrink : bool, optional
        Whether to force compression of an empty mask. Default is True.
    order : {'C', 'F', 'A'***REMOVED***, optional
        Specify the order of the array.  If order is 'C', then the array
        will be in C-contiguous order (last-index varies the fastest***REMOVED***.
        If order is 'F', then the returned array will be in
        Fortran-contiguous order (first-index varies the fastest***REMOVED***.
        If order is 'A' (default***REMOVED***, then the returned array may be
        in any order (either C-, Fortran-contiguous, or even discontiguous***REMOVED***,
        unless a copy is required, in which case it will be C-contiguous.

    ***REMOVED***

    __array_priority__ = 15
    _defaultmask = nomask
    _defaulthardmask = False
    _baseclass = ndarray

    # Maximum number of elements per axis used when printing an array. The
    # 1d case is handled separately because we need more values in this case.
    _print_width = 100
    _print_width_1d = 1500

    def __new__(cls, data=None, mask=nomask, dtype=None, copy=False,
                subok=True, ndmin=0, fill_value=None, keep_mask=True,
                hard_mask=None, shrink=True, order=None, **options***REMOVED***:
        ***REMOVED***
        Create a new masked array from scratch.

        Notes
        -----
        A masked array can also be created by taking a .view(MaskedArray***REMOVED***.

        ***REMOVED***
        # Process data.
        _data = np.array(data, dtype=dtype, copy=copy,
                         order=order, subok=True, ndmin=ndmin***REMOVED***
        _baseclass = getattr(data, '_baseclass', type(_data***REMOVED******REMOVED***
        # Check that we're not erasing the mask.
        if isinstance(data, MaskedArray***REMOVED*** and (data.shape != _data.shape***REMOVED***:
            copy = True
        # Careful, cls might not always be MaskedArray.
        if not isinstance(data, cls***REMOVED*** or not subok:
            _data = ndarray.view(_data, cls***REMOVED***
        else:
            _data = ndarray.view(_data, type(data***REMOVED******REMOVED***
        # Backwards compatibility w/ numpy.core.ma.
        if hasattr(data, '_mask'***REMOVED*** and not isinstance(data, ndarray***REMOVED***:
            _data._mask = data._mask
            # FIXME _sharedmask is never used.
            _sharedmask = True
        # Process mask.
        # Number of named fields (or zero if none***REMOVED***
        names_ = _data.dtype.names or (***REMOVED***
        # Type of the mask
        if names_:
            mdtype = make_mask_descr(_data.dtype***REMOVED***
        else:
            mdtype = MaskType

        if mask is nomask:
            # Case 1. : no mask in input.
            # Erase the current mask ?
            if not keep_mask:
                # With a reduced version
                if shrink:
                    _data._mask = nomask
                # With full version
                else:
                    _data._mask = np.zeros(_data.shape, dtype=mdtype***REMOVED***
            # Check whether we missed something
            elif isinstance(data, (tuple, list***REMOVED******REMOVED***:
                ***REMOVED***
                    # If data is a sequence of masked array
                    mask = np.array([getmaskarray(m***REMOVED*** for m in data***REMOVED***,
                                    dtype=mdtype***REMOVED***
                except ValueError:
                    # If data is nested
                    mask = nomask
                # Force shrinking of the mask if needed (and possible***REMOVED***
                if (mdtype == MaskType***REMOVED*** and mask.any(***REMOVED***:
                    _data._mask = mask
                    _data._sharedmask = False
            else:
                if copy:
                    _data._mask = _data._mask.copy(***REMOVED***
                    _data._sharedmask = False
                    # Reset the shape of the original mask
                    if getmask(data***REMOVED*** is not nomask:
                        data._mask.shape = data.shape
                else:
                    _data._sharedmask = True
        else:
            # Case 2. : With a mask in input.
            # If mask is boolean, create an array of True or False
            if mask is True and mdtype == MaskType:
                mask = np.ones(_data.shape, dtype=mdtype***REMOVED***
            elif mask is False and mdtype == MaskType:
                mask = np.zeros(_data.shape, dtype=mdtype***REMOVED***
            else:
                # Read the mask with the current mdtype
                ***REMOVED***
                    mask = np.array(mask, copy=copy, dtype=mdtype***REMOVED***
                # Or assume it's a sequence of bool/int
                except TypeError:
                    mask = np.array([tuple([m***REMOVED*** * len(mdtype***REMOVED******REMOVED*** for m in mask***REMOVED***,
                                    dtype=mdtype***REMOVED***
            # Make sure the mask and the data have the same shape
            if mask.shape != _data.shape:
                (nd, nm***REMOVED*** = (_data.size, mask.size***REMOVED***
                if nm == 1:
                    mask = np.resize(mask, _data.shape***REMOVED***
                elif nm == nd:
                    mask = np.reshape(mask, _data.shape***REMOVED***
                else:
                    msg = "Mask and data not compatible: data size is %i, " + \
                          "mask size is %i."
                    raise MaskError(msg % (nd, nm***REMOVED******REMOVED***
                copy = True
            # Set the mask to the new value
            if _data._mask is nomask:
                _data._mask = mask
                _data._sharedmask = not copy
            else:
                if not keep_mask:
                    _data._mask = mask
                    _data._sharedmask = not copy
                else:
                    if names_:
                        def _recursive_or(a, b***REMOVED***:
                            "do a|=b on each field of a, recursively"
                            for name in a.dtype.names:
                                (af, bf***REMOVED*** = (a[name***REMOVED***, b[name***REMOVED******REMOVED***
                                if af.dtype.names:
                                    _recursive_or(af, bf***REMOVED***
                                else:
                                    af |= bf
                            return
                        _recursive_or(_data._mask, mask***REMOVED***
                    else:
                        _data._mask = np.logical_or(mask, _data._mask***REMOVED***
                    _data._sharedmask = False
        # Update fill_value.
        if fill_value is None:
            fill_value = getattr(data, '_fill_value', None***REMOVED***
        # But don't run the check unless we have something to check.
        if fill_value is not None:
            _data._fill_value = _check_fill_value(fill_value, _data.dtype***REMOVED***
        # Process extra options ..
        if hard_mask is None:
            _data._hardmask = getattr(data, '_hardmask', False***REMOVED***
        else:
            _data._hardmask = hard_mask
        _data._baseclass = _baseclass
        return _data


    def _update_from(self, obj***REMOVED***:
        ***REMOVED***
        Copies some attributes of obj to self.

        ***REMOVED***
        if obj is not None and isinstance(obj, ndarray***REMOVED***:
            _baseclass = type(obj***REMOVED***
        else:
            _baseclass = ndarray
        # We need to copy the _basedict to avoid backward propagation
        _optinfo = {***REMOVED***
        _optinfo.update(getattr(obj, '_optinfo', {***REMOVED******REMOVED******REMOVED***
        _optinfo.update(getattr(obj, '_basedict', {***REMOVED******REMOVED******REMOVED***
        if not isinstance(obj, MaskedArray***REMOVED***:
            _optinfo.update(getattr(obj, '__dict__', {***REMOVED******REMOVED******REMOVED***
        _dict = dict(_fill_value=getattr(obj, '_fill_value', None***REMOVED***,
                     _hardmask=getattr(obj, '_hardmask', False***REMOVED***,
                     _sharedmask=getattr(obj, '_sharedmask', False***REMOVED***,
                     _isfield=getattr(obj, '_isfield', False***REMOVED***,
                     _baseclass=getattr(obj, '_baseclass', _baseclass***REMOVED***,
                     _optinfo=_optinfo,
                     _basedict=_optinfo***REMOVED***
        self.__dict__.update(_dict***REMOVED***
        self.__dict__.update(_optinfo***REMOVED***
        return

    def __array_finalize__(self, obj***REMOVED***:
        ***REMOVED***
        Finalizes the masked array.

        ***REMOVED***
        # Get main attributes.
        self._update_from(obj***REMOVED***

        # We have to decide how to initialize self.mask, based on
        # obj.mask. This is very difficult.  There might be some
        # correspondence between the elements in the array we are being
        # created from (= obj***REMOVED*** and us. Or there might not. This method can
        # be called in all kinds of places for all kinds of reasons -- could
        # be empty_like, could be slicing, could be a ufunc, could be a view.
        # The numpy subclassing interface simply doesn't give us any way
        # to know, which means that at best this method will be based on
        # guesswork and heuristics. To make things worse, there isn't even any
        # clear consensus about what the desired behavior is. For instance,
        # most users think that np.empty_like(marr***REMOVED*** -- which goes via this
        # method -- should return a masked array with an empty mask (see
        # gh-3404 and linked discussions***REMOVED***, but others disagree, and they have
        # existing code which depends on empty_like returning an array that
        # matches the input mask.
        #
        # Historically our algorithm was: if the template object mask had the
        # same *number of elements* as us, then we used *it's mask object
        # itself* as our mask, so that writes to us would also write to the
        # original array. This is horribly broken in multiple ways.
        #
        # Now what we do instead is, if the template object mask has the same
        # number of elements as us, and we do not have the same base pointer
        # as the template object (b/c views like arr[...***REMOVED*** should keep the same
        # mask***REMOVED***, then we make a copy of the template object mask and use
        # that. This is also horribly broken but somewhat less so. Maybe.
        if isinstance(obj, ndarray***REMOVED***:
            # XX: This looks like a bug -- shouldn't it check self.dtype
            # instead?
            if obj.dtype.names:
                _mask = getattr(obj, '_mask',
                                make_mask_none(obj.shape, obj.dtype***REMOVED******REMOVED***
            else:
                _mask = getattr(obj, '_mask', nomask***REMOVED***

            # If self and obj point to exactly the same data, then probably
            # self is a simple view of obj (e.g., self = obj[...***REMOVED******REMOVED***, so they
            # should share the same mask. (This isn't 100% reliable, e.g. self
            # could be the first row of obj, or have strange strides, but as a
            # heuristic it's not bad.***REMOVED*** In all other cases, we make a copy of
            # the mask, so that future modifications to 'self' do not end up
            # side-effecting 'obj' as well.
            if (obj.__array_interface__["data"***REMOVED***[0***REMOVED***
                    != self.__array_interface__["data"***REMOVED***[0***REMOVED******REMOVED***:
                _mask = _mask.copy(***REMOVED***
        else:
            _mask = nomask
        self._mask = _mask
        # Finalize the mask
        if self._mask is not nomask:
            ***REMOVED***
                self._mask.shape = self.shape
            except ValueError:
                self._mask = nomask
            except (TypeError, AttributeError***REMOVED***:
                # When _mask.shape is not writable (because it's a void***REMOVED***
                pass
        # Finalize the fill_value for structured arrays
        if self.dtype.names:
            if self._fill_value is None:
                self._fill_value = _check_fill_value(None, self.dtype***REMOVED***
        return

    def __array_wrap__(self, obj, context=None***REMOVED***:
        ***REMOVED***
        Special hook for ufuncs.

        Wraps the numpy array and sets the mask according to context.

        ***REMOVED***
        result = obj.view(type(self***REMOVED******REMOVED***
        result._update_from(self***REMOVED***

        if context is not None:
            result._mask = result._mask.copy(***REMOVED***
            (func, args, _***REMOVED*** = context
            m = reduce(mask_or, [getmaskarray(arg***REMOVED*** for arg in args***REMOVED******REMOVED***
            # Get the domain mask
            domain = ufunc_domain.get(func, None***REMOVED***
            if domain is not None:
                # Take the domain, and make sure it's a ndarray
                if len(args***REMOVED*** > 2:
                    d = filled(reduce(domain, args***REMOVED***, True***REMOVED***
                else:
                    d = filled(domain(*args***REMOVED***, True***REMOVED***
                # Fill the result where the domain is wrong
                ***REMOVED***
                    # Binary domain: take the last value
                    fill_value = ufunc_fills[func***REMOVED***[-1***REMOVED***
                except TypeError:
                    # Unary domain: just use this one
                    fill_value = ufunc_fills[func***REMOVED***
                except KeyError:
                    # Domain not recognized, use fill_value instead
                    fill_value = self.fill_value
                result = result.copy(***REMOVED***
                np.copyto(result, fill_value, where=d***REMOVED***
                # Update the mask
                if m is nomask:
                    if d is not nomask:
                        m = d
                else:
                    # Don't modify inplace, we risk back-propagation
                    m = (m | d***REMOVED***
            # Make sure the mask has the proper size
            if result.shape == (***REMOVED*** and m:
                return masked
            else:
                result._mask = m
                result._sharedmask = False

        return result

    def view(self, dtype=None, type=None, fill_value=None***REMOVED***:
        ***REMOVED***
        Return a view of the MaskedArray data

        Parameters
        ----------
        dtype : data-type or ndarray sub-class, optional
            Data-type descriptor of the returned view, e.g., float32 or int16.
            The default, None, results in the view having the same data-type
            as `a`. As with ``ndarray.view``, dtype can also be specified as
            an ndarray sub-class, which then specifies the type of the
            returned object (this is equivalent to setting the ``type``
            parameter***REMOVED***.
        type : Python type, optional
            Type of the returned view, e.g., ndarray or matrix.  Again, the
            default None results in type preservation.

        Notes
        -----

        ``a.view(***REMOVED***`` is used two different ways:

        ``a.view(some_dtype***REMOVED***`` or ``a.view(dtype=some_dtype***REMOVED***`` constructs a view
        of the array's memory with a different data-type.  This can cause a
        reinterpretation of the bytes of memory.

        ``a.view(ndarray_subclass***REMOVED***`` or ``a.view(type=ndarray_subclass***REMOVED***`` just
        returns an instance of `ndarray_subclass` that looks at the same array
        (same shape, dtype, etc.***REMOVED***  This does not cause a reinterpretation of the
        memory.

        If `fill_value` is not specified, but `dtype` is specified (and is not
        an ndarray sub-class***REMOVED***, the `fill_value` of the MaskedArray will be
        reset. If neither `fill_value` nor `dtype` are specified (or if
        `dtype` is an ndarray sub-class***REMOVED***, then the fill value is preserved.
        Finally, if `fill_value` is specified, but `dtype` is not, the fill
        value is set to the specified value.

        For ``a.view(some_dtype***REMOVED***``, if ``some_dtype`` has a different number of
        bytes per entry than the previous dtype (for example, converting a
        regular array to a structured array***REMOVED***, then the behavior of the view
        cannot be predicted just from the superficial appearance of ``a`` (shown
        by ``print(a***REMOVED***``***REMOVED***. It also depends on exactly how ``a`` is stored in
        memory. Therefore if ``a`` is C-ordered versus fortran-ordered, versus
        defined as a slice or transpose, etc., the view may give different
        results.
        ***REMOVED***

        if dtype is None:
            if type is None:
                output = ndarray.view(self***REMOVED***
            else:
                output = ndarray.view(self, type***REMOVED***
        elif type is None:
            ***REMOVED***
                if issubclass(dtype, ndarray***REMOVED***:
                    output = ndarray.view(self, dtype***REMOVED***
                    dtype = None
                else:
                    output = ndarray.view(self, dtype***REMOVED***
            except TypeError:
                output = ndarray.view(self, dtype***REMOVED***
        else:
            output = ndarray.view(self, dtype, type***REMOVED***

        # also make the mask be a view (so attr changes to the view's
        # mask do no affect original object's mask***REMOVED***
        # (especially important to avoid affecting np.masked singleton***REMOVED***
        if (getattr(output, '_mask', nomask***REMOVED*** is not nomask***REMOVED***:
            output._mask = output._mask.view(***REMOVED***

        # Make sure to reset the _fill_value if needed
        if getattr(output, '_fill_value', None***REMOVED*** is not None:
            if fill_value is None:
                if dtype is None:
                    pass  # leave _fill_value as is
                else:
                    output._fill_value = None
            else:
                output.fill_value = fill_value
        return output
    view.__doc__ = ndarray.view.__doc__

    def astype(self, newtype***REMOVED***:
        ***REMOVED***
        Returns a copy of the MaskedArray cast to given newtype.

        Returns
        -------
        output : MaskedArray
            A copy of self cast to input newtype.
            The returned record shape matches self.shape.

        Examples
        --------
        >>> x = np.ma.array([[1,2,3.1***REMOVED***,[4,5,6***REMOVED***,[7,8,9***REMOVED******REMOVED***, mask=[0***REMOVED*** + [1,0***REMOVED****4***REMOVED***
        >>> print(x***REMOVED***
        [[1.0 -- 3.1***REMOVED***
         [-- 5.0 --***REMOVED***
         [7.0 -- 9.0***REMOVED******REMOVED***
        >>> print(x.astype(int32***REMOVED******REMOVED***
        [[1 -- 3***REMOVED***
         [-- 5 --***REMOVED***
         [7 -- 9***REMOVED******REMOVED***

        ***REMOVED***
        newtype = np.dtype(newtype***REMOVED***
        output = self._data.astype(newtype***REMOVED***.view(type(self***REMOVED******REMOVED***
        output._update_from(self***REMOVED***
        names = output.dtype.names
        if names is None:
            output._mask = self._mask.astype(bool***REMOVED***
        else:
            if self._mask is nomask:
                output._mask = nomask
            else:
                output._mask = self._mask.astype([(n, bool***REMOVED*** for n in names***REMOVED******REMOVED***
        # Don't check _fill_value if it's None, that'll speed things up
        if self._fill_value is not None:
            output._fill_value = _check_fill_value(self._fill_value, newtype***REMOVED***
        return output

    def __getitem__(self, indx***REMOVED***:
        ***REMOVED***
        x.__getitem__(y***REMOVED*** <==> x[y***REMOVED***

        Return the item described by i, as a masked array.

        ***REMOVED***
        dout = self.data[indx***REMOVED***
        # We could directly use ndarray.__getitem__ on self.
        # But then we would have to modify __array_finalize__ to prevent the
        # mask of being reshaped if it hasn't been set up properly yet
        # So it's easier to stick to the current version
        _mask = self._mask
        # Did we extract a single item?
        if not getattr(dout, 'ndim', False***REMOVED***:
            # A record
            if isinstance(dout, np.void***REMOVED***:
                mask = _mask[indx***REMOVED***
                # We should always re-cast to mvoid, otherwise users can
                # change masks on rows that already have masked values, but not
                # on rows that have no masked values, which is inconsistent.
                dout = mvoid(dout, mask=mask, hardmask=self._hardmask***REMOVED***
            # Just a scalar
            elif _mask is not nomask and _mask[indx***REMOVED***:
                return masked
        elif self.dtype.type is np.object_ and self.dtype is not dout.dtype:
            # self contains an object array of arrays (yes, that happens***REMOVED***.
            # If masked, turn into a MaskedArray, with everything masked.
            if _mask is not nomask and _mask[indx***REMOVED***:
                return MaskedArray(dout, mask=True***REMOVED***
        else:
            # Force dout to MA
            dout = dout.view(type(self***REMOVED******REMOVED***
            # Inherit attributes from self
            dout._update_from(self***REMOVED***
            # Check the fill_value
            if isinstance(indx, basestring***REMOVED***:
                if self._fill_value is not None:
                    dout._fill_value = self._fill_value[indx***REMOVED***

                    # If we're indexing a multidimensional field in a 
                    # structured array (such as dtype("(2,***REMOVED***i2,(2,***REMOVED***i1"***REMOVED******REMOVED***,
                    # dimensionality goes up (M[field***REMOVED***.ndim == M.ndim +
                    # len(M.dtype[field***REMOVED***.shape***REMOVED******REMOVED***.  That's fine for 
                    # M[field***REMOVED*** but problematic for M[field***REMOVED***.fill_value 
                    # which should have shape (***REMOVED*** to avoid breaking several
                    # methods. There is no great way out, so set to
                    # first element.  See issue #6723.
                    if dout._fill_value.ndim > 0:
                        if not (dout._fill_value ==
                                dout._fill_value.flat[0***REMOVED******REMOVED***.all(***REMOVED***:
                            warnings.warn(
                                "Upon accessing multidimensional field "
                                "{indx:s***REMOVED***, need to keep dimensionality "
                                "of fill_value at 0. Discarding "
                                "heterogeneous fill_value and setting "
                                "all to {fv!s***REMOVED***.".format(indx=indx,
                                    fv=dout._fill_value[0***REMOVED******REMOVED******REMOVED***
                        dout._fill_value = dout._fill_value.flat[0***REMOVED***
                dout._isfield = True
            # Update the mask if needed
            if _mask is not nomask:
                dout._mask = _mask[indx***REMOVED***
                # set shape to match that of data; this is needed for matrices
                dout._mask.shape = dout.shape
                dout._sharedmask = True
                # Note: Don't try to check for m.any(***REMOVED***, that'll take too long
        return dout

    def __setitem__(self, indx, value***REMOVED***:
        ***REMOVED***
        x.__setitem__(i, y***REMOVED*** <==> x[i***REMOVED***=y

        Set item described by index. If value is masked, masks those
        locations.

        ***REMOVED***
        if self is masked:
            raise MaskError('Cannot alter the masked element.'***REMOVED***
        _data = self._data
        _mask = self._mask
        if isinstance(indx, basestring***REMOVED***:
            _data[indx***REMOVED*** = value
            if _mask is nomask:
                self._mask = _mask = make_mask_none(self.shape, self.dtype***REMOVED***
            _mask[indx***REMOVED*** = getmask(value***REMOVED***
            return

        _dtype = _data.dtype
        nbfields = len(_dtype.names or (***REMOVED******REMOVED***

        if value is masked:
            # The mask wasn't set: create a full version.
            if _mask is nomask:
                _mask = self._mask = make_mask_none(self.shape, _dtype***REMOVED***
            # Now, set the mask to its value.
            if nbfields:
                _mask[indx***REMOVED*** = tuple([True***REMOVED*** * nbfields***REMOVED***
            else:
                _mask[indx***REMOVED*** = True
            if not self._isfield:
                self._sharedmask = False
            return

        # Get the _data part of the new value
        dval = value
        # Get the _mask part of the new value
        mval = getattr(value, '_mask', nomask***REMOVED***
        if nbfields and mval is nomask:
            mval = tuple([False***REMOVED*** * nbfields***REMOVED***
        if _mask is nomask:
            # Set the data, then the mask
            _data[indx***REMOVED*** = dval
            if mval is not nomask:
                _mask = self._mask = make_mask_none(self.shape, _dtype***REMOVED***
                _mask[indx***REMOVED*** = mval
        elif not self._hardmask:
            # Unshare the mask if necessary to avoid propagation
            # We want to remove the unshare logic from this place in the
            # future. Note that _sharedmask has lots of false positives.
            if not self._isfield:
                if self._sharedmask and not (
                        # If no one else holds a reference (we have two
                        # references (_mask and self._mask***REMOVED*** -- add one for
                        # getrefcount***REMOVED*** and the array owns its own data
                        # copying the mask should do nothing.
                        (sys.getrefcount(_mask***REMOVED*** == 3***REMOVED*** and _mask.flags.owndata***REMOVED***:
                    # 2016.01.15 -- v1.11.0
                    warnings.warn(
                       "setting an item on a masked array which has a shared "
                       "mask will not copy the mask and also change the "
                       "original mask array in the future.\n"
                       "Check the NumPy 1.11 release notes for more "
                       "information.",
                       MaskedArrayFutureWarning, stacklevel=2***REMOVED***
                self.unshare_mask(***REMOVED***
                _mask = self._mask
            # Set the data, then the mask
            _data[indx***REMOVED*** = dval
            _mask[indx***REMOVED*** = mval
        elif hasattr(indx, 'dtype'***REMOVED*** and (indx.dtype == MaskType***REMOVED***:
            indx = indx * umath.logical_not(_mask***REMOVED***
            _data[indx***REMOVED*** = dval
        else:
            if nbfields:
                err_msg = "Flexible 'hard' masks are not yet supported."
                raise NotImplementedError(err_msg***REMOVED***
            mindx = mask_or(_mask[indx***REMOVED***, mval, copy=True***REMOVED***
            dindx = self._data[indx***REMOVED***
            if dindx.size > 1:
                np.copyto(dindx, dval, where=~mindx***REMOVED***
            elif mindx is nomask:
                dindx = dval
            _data[indx***REMOVED*** = dindx
            _mask[indx***REMOVED*** = mindx
        return

    def __setattr__(self, attr, value***REMOVED***:
        super(MaskedArray, self***REMOVED***.__setattr__(attr, value***REMOVED***
        if attr == 'dtype' and self._mask is not nomask:
            self._mask = self._mask.view(make_mask_descr(value***REMOVED***, ndarray***REMOVED***
            # Try to reset the shape of the mask (if we don't have a void***REMOVED***
            # This raises a ValueError if the dtype change won't work
            ***REMOVED***
                self._mask.shape = self.shape
            except (AttributeError, TypeError***REMOVED***:
                pass

    def __getslice__(self, i, j***REMOVED***:
        ***REMOVED***
        x.__getslice__(i, j***REMOVED*** <==> x[i:j***REMOVED***

        Return the slice described by (i, j***REMOVED***.  The use of negative indices
        is not supported.

        ***REMOVED***
        return self.__getitem__(slice(i, j***REMOVED******REMOVED***

    def __setslice__(self, i, j, value***REMOVED***:
        ***REMOVED***
        x.__setslice__(i, j, value***REMOVED*** <==> x[i:j***REMOVED***=value

        Set the slice (i,j***REMOVED*** of a to value. If value is masked, mask those
        locations.

        ***REMOVED***
        self.__setitem__(slice(i, j***REMOVED***, value***REMOVED***

    def __setmask__(self, mask, copy=False***REMOVED***:
        ***REMOVED***
        Set the mask.

        ***REMOVED***
        idtype = self.dtype
        current_mask = self._mask
        if mask is masked:
            mask = True

        if (current_mask is nomask***REMOVED***:
            # Make sure the mask is set
            # Just don't do anything if there's nothing to do.
            if mask is nomask:
                return
            current_mask = self._mask = make_mask_none(self.shape, idtype***REMOVED***

        if idtype.names is None:
            # No named fields.
            # Hardmask: don't unmask the data
            if self._hardmask:
                current_mask |= mask
            # Softmask: set everything to False
            # If it's obviously a compatible scalar, use a quick update
            # method.
            elif isinstance(mask, (int, float, np.bool_, np.number***REMOVED******REMOVED***:
                current_mask[...***REMOVED*** = mask
            # Otherwise fall back to the slower, general purpose way.
            else:
                current_mask.flat = mask
        else:
            # Named fields w/
            mdtype = current_mask.dtype
            mask = np.array(mask, copy=False***REMOVED***
            # Mask is a singleton
            if not mask.ndim:
                # It's a boolean : make a record
                if mask.dtype.kind == 'b':
                    mask = np.array(tuple([mask.item(***REMOVED******REMOVED*** * len(mdtype***REMOVED******REMOVED***,
                                    dtype=mdtype***REMOVED***
                # It's a record: make sure the dtype is correct
                else:
                    mask = mask.astype(mdtype***REMOVED***
            # Mask is a sequence
            else:
                # Make sure the new mask is a ndarray with the proper dtype
                ***REMOVED***
                    mask = np.array(mask, copy=copy, dtype=mdtype***REMOVED***
                # Or assume it's a sequence of bool/int
                except TypeError:
                    mask = np.array([tuple([m***REMOVED*** * len(mdtype***REMOVED******REMOVED*** for m in mask***REMOVED***,
                                    dtype=mdtype***REMOVED***
            # Hardmask: don't unmask the data
            if self._hardmask:
                for n in idtype.names:
                    current_mask[n***REMOVED*** |= mask[n***REMOVED***
            # Softmask: set everything to False
            # If it's obviously a compatible scalar, use a quick update
            # method.
            elif isinstance(mask, (int, float, np.bool_, np.number***REMOVED******REMOVED***:
                current_mask[...***REMOVED*** = mask
            # Otherwise fall back to the slower, general purpose way.
            else:
                current_mask.flat = mask
        # Reshape if needed
        if current_mask.shape:
            current_mask.shape = self.shape
        return

    _set_mask = __setmask__

    def _get_mask(self***REMOVED***:
        ***REMOVED***Return the current mask.

        ***REMOVED***
        # We could try to force a reshape, but that wouldn't work in some
        # cases.
        return self._mask

    mask = property(fget=_get_mask, fset=__setmask__, doc="Mask"***REMOVED***

    def _get_recordmask(self***REMOVED***:
        ***REMOVED***
        Return the mask of the records.

        A record is masked when all the fields are masked.

        ***REMOVED***
        _mask = self._mask.view(ndarray***REMOVED***
        if _mask.dtype.names is None:
            return _mask
        return np.all(flatten_structured_array(_mask***REMOVED***, axis=-1***REMOVED***

    def _set_recordmask(self***REMOVED***:
        ***REMOVED***
        Return the mask of the records.

        A record is masked when all the fields are masked.

        ***REMOVED***
        raise NotImplementedError("Coming soon: setting the mask per records!"***REMOVED***

    recordmask = property(fget=_get_recordmask***REMOVED***

    def harden_mask(self***REMOVED***:
        ***REMOVED***
        Force the mask to hard.

        Whether the mask of a masked array is hard or soft is determined by
        its `hardmask` property. `harden_mask` sets `hardmask` to True.

        See Also
        --------
        hardmask

        ***REMOVED***
        self._hardmask = True
        return self

    def soften_mask(self***REMOVED***:
        ***REMOVED***
        Force the mask to soft.

        Whether the mask of a masked array is hard or soft is determined by
        its `hardmask` property. `soften_mask` sets `hardmask` to False.

        See Also
        --------
        hardmask

        ***REMOVED***
        self._hardmask = False
        return self

    hardmask = property(fget=lambda self: self._hardmask,
                        doc="Hardness of the mask"***REMOVED***

    def unshare_mask(self***REMOVED***:
        ***REMOVED***
        Copy the mask and set the sharedmask flag to False.

        Whether the mask is shared between masked arrays can be seen from
        the `sharedmask` property. `unshare_mask` ensures the mask is not shared.
        A copy of the mask is only made if it was shared.

        See Also
        --------
        sharedmask

        ***REMOVED***
        if self._sharedmask:
            self._mask = self._mask.copy(***REMOVED***
            self._sharedmask = False
        return self

    sharedmask = property(fget=lambda self: self._sharedmask,
                          doc="Share status of the mask (read-only***REMOVED***."***REMOVED***

    def shrink_mask(self***REMOVED***:
        ***REMOVED***
        Reduce a mask to nomask when possible.

        Parameters
        ----------
        None

        Returns
        -------
        None

        Examples
        --------
        >>> x = np.ma.array([[1,2 ***REMOVED***, [3, 4***REMOVED******REMOVED***, mask=[0***REMOVED****4***REMOVED***
        >>> x.mask
        array([[False, False***REMOVED***,
               [False, False***REMOVED******REMOVED***, dtype=bool***REMOVED***
        >>> x.shrink_mask(***REMOVED***
        >>> x.mask
        False

        ***REMOVED***
        m = self._mask
        if m.ndim and not m.any(***REMOVED***:
            self._mask = nomask
        return self

    baseclass = property(fget=lambda self: self._baseclass,
                         doc="Class of the underlying data (read-only***REMOVED***."***REMOVED***

    def _get_data(self***REMOVED***:
        ***REMOVED***Return the current data, as a view of the original
        underlying data.

        ***REMOVED***
        return ndarray.view(self, self._baseclass***REMOVED***

    _data = property(fget=_get_data***REMOVED***
    data = property(fget=_get_data***REMOVED***

    def _get_flat(self***REMOVED***:
        "Return a flat iterator."
        return MaskedIterator(self***REMOVED***

    def _set_flat(self, value***REMOVED***:
        "Set a flattened version of self to value."
        y = self.ravel(***REMOVED***
        y[:***REMOVED*** = value

    flat = property(fget=_get_flat, fset=_set_flat,
                    doc="Flat version of the array."***REMOVED***

    def get_fill_value(self***REMOVED***:
        ***REMOVED***
        Return the filling value of the masked array.

        Returns
        -------
        fill_value : scalar
            The filling value.

        Examples
        --------
        >>> for dt in [np.int32, np.int64, np.float64, np.complex128***REMOVED***:
        ...     np.ma.array([0, 1***REMOVED***, dtype=dt***REMOVED***.get_fill_value(***REMOVED***
        ...
        999999
        999999
        1e+20
        (1e+20+0j***REMOVED***

        >>> x = np.ma.array([0, 1.***REMOVED***, fill_value=-np.inf***REMOVED***
        >>> x.get_fill_value(***REMOVED***
        -inf

        ***REMOVED***
        if self._fill_value is None:
            self._fill_value = _check_fill_value(None, self.dtype***REMOVED***
        return self._fill_value[(***REMOVED******REMOVED***

    def set_fill_value(self, value=None***REMOVED***:
        ***REMOVED***
        Set the filling value of the masked array.

        Parameters
        ----------
        value : scalar, optional
            The new filling value. Default is None, in which case a default
            based on the data type is used.

        See Also
        --------
        ma.set_fill_value : Equivalent function.

        Examples
        --------
        >>> x = np.ma.array([0, 1.***REMOVED***, fill_value=-np.inf***REMOVED***
        >>> x.fill_value
        -inf
        >>> x.set_fill_value(np.pi***REMOVED***
        >>> x.fill_value
        3.1415926535897931

        Reset to default:

        >>> x.set_fill_value(***REMOVED***
        >>> x.fill_value
        1e+20

        ***REMOVED***
        target = _check_fill_value(value, self.dtype***REMOVED***
        _fill_value = self._fill_value
        if _fill_value is None:
            # Create the attribute if it was undefined
            self._fill_value = target
        else:
            # Don't overwrite the attribute, just fill it (for propagation***REMOVED***
            _fill_value[(***REMOVED******REMOVED*** = target

    fill_value = property(fget=get_fill_value, fset=set_fill_value,
                          doc="Filling value."***REMOVED***

    def filled(self, fill_value=None***REMOVED***:
        ***REMOVED***
        Return a copy of self, with masked values filled with a given value.
        **However**, if there are no masked values to fill, self will be
        returned instead as an ndarray.

        Parameters
        ----------
        fill_value : scalar, optional
            The value to use for invalid entries (None by default***REMOVED***.
            If None, the `fill_value` attribute of the array is used instead.

        Returns
        -------
        filled_array : ndarray
            A copy of ``self`` with invalid entries replaced by *fill_value*
            (be it the function argument or the attribute of ``self``***REMOVED***, or
            ``self`` itself as an ndarray if there are no invalid entries to
            be replaced.

        Notes
        -----
        The result is **not** a MaskedArray!

        Examples
        --------
        >>> x = np.ma.array([1,2,3,4,5***REMOVED***, mask=[0,0,1,0,1***REMOVED***, fill_value=-999***REMOVED***
        >>> x.filled(***REMOVED***
        array([1, 2, -999, 4, -999***REMOVED******REMOVED***
        >>> type(x.filled(***REMOVED******REMOVED***
        <type 'numpy.ndarray'>

        Subclassing is preserved. This means that if the data part of the masked
        array is a matrix, `filled` returns a matrix:

        >>> x = np.ma.array(np.matrix([[1, 2***REMOVED***, [3, 4***REMOVED******REMOVED******REMOVED***, mask=[[0, 1***REMOVED***, [1, 0***REMOVED******REMOVED******REMOVED***
        >>> x.filled(***REMOVED***
        matrix([[     1, 999999***REMOVED***,
                [999999,      4***REMOVED******REMOVED******REMOVED***

        ***REMOVED***
        m = self._mask
        if m is nomask:
            return self._data

        if fill_value is None:
            fill_value = self.fill_value
        else:
            fill_value = _check_fill_value(fill_value, self.dtype***REMOVED***

        if self is masked_singleton:
            return np.asanyarray(fill_value***REMOVED***

        if m.dtype.names:
            result = self._data.copy('K'***REMOVED***
            _recursive_filled(result, self._mask, fill_value***REMOVED***
        elif not m.any(***REMOVED***:
            return self._data
        else:
            result = self._data.copy('K'***REMOVED***
            ***REMOVED***
                np.copyto(result, fill_value, where=m***REMOVED***
            except (TypeError, AttributeError***REMOVED***:
                fill_value = narray(fill_value, dtype=object***REMOVED***
                d = result.astype(object***REMOVED***
                result = np.choose(m, (d, fill_value***REMOVED******REMOVED***
            except IndexError:
                # ok, if scalar
                if self._data.shape:
                    raise
                elif m:
                    result = np.array(fill_value, dtype=self.dtype***REMOVED***
                else:
                    result = self._data
        return result

    def compressed(self***REMOVED***:
        ***REMOVED***
        Return all the non-masked data as a 1-D array.

        Returns
        -------
        data : ndarray
            A new `ndarray` holding the non-masked data is returned.

        Notes
        -----
        The result is **not** a MaskedArray!

        Examples
        --------
        >>> x = np.ma.array(np.arange(5***REMOVED***, mask=[0***REMOVED****2 + [1***REMOVED****3***REMOVED***
        >>> x.compressed(***REMOVED***
        array([0, 1***REMOVED******REMOVED***
        >>> type(x.compressed(***REMOVED******REMOVED***
        <type 'numpy.ndarray'>

        ***REMOVED***
        data = ndarray.ravel(self._data***REMOVED***
        if self._mask is not nomask:
            data = data.compress(np.logical_not(ndarray.ravel(self._mask***REMOVED******REMOVED******REMOVED***
        return data

    def compress(self, condition, axis=None, out=None***REMOVED***:
        ***REMOVED***
        Return `a` where condition is ``True``.

        If condition is a `MaskedArray`, missing values are considered
        as ``False``.

        Parameters
        ----------
        condition : var
            Boolean 1-d array selecting which entries to return. If len(condition***REMOVED***
            is less than the size of a along the axis, then output is truncated
            to length of condition array.
        axis : {None, int***REMOVED***, optional
            Axis along which the operation must be performed.
        out : {None, ndarray***REMOVED***, optional
            Alternative output array in which to place the result. It must have
            the same shape as the expected output but the type will be cast if
            necessary.

        Returns
        -------
        result : MaskedArray
            A :class:`MaskedArray` object.

        Notes
        -----
        Please note the difference with :meth:`compressed` !
        The output of :meth:`compress` has a mask, the output of
        :meth:`compressed` does not.

        Examples
        --------
        >>> x = np.ma.array([[1,2,3***REMOVED***,[4,5,6***REMOVED***,[7,8,9***REMOVED******REMOVED***, mask=[0***REMOVED*** + [1,0***REMOVED****4***REMOVED***
        >>> print(x***REMOVED***
        [[1 -- 3***REMOVED***
         [-- 5 --***REMOVED***
         [7 -- 9***REMOVED******REMOVED***
        >>> x.compress([1, 0, 1***REMOVED******REMOVED***
        masked_array(data = [1 3***REMOVED***,
              mask = [False False***REMOVED***,
              fill_value=999999***REMOVED***

        >>> x.compress([1, 0, 1***REMOVED***, axis=1***REMOVED***
        masked_array(data =
         [[1 3***REMOVED***
         [-- --***REMOVED***
         [7 9***REMOVED******REMOVED***,
              mask =
         [[False False***REMOVED***
         [ True  True***REMOVED***
         [False False***REMOVED******REMOVED***,
              fill_value=999999***REMOVED***

        ***REMOVED***
        # Get the basic components
        (_data, _mask***REMOVED*** = (self._data, self._mask***REMOVED***

        # Force the condition to a regular ndarray and forget the missing
        # values.
        condition = np.array(condition, copy=False, subok=False***REMOVED***

        _new = _data.compress(condition, axis=axis, out=out***REMOVED***.view(type(self***REMOVED******REMOVED***
        _new._update_from(self***REMOVED***
        if _mask is not nomask:
            _new._mask = _mask.compress(condition, axis=axis***REMOVED***
        return _new

    def __str__(self***REMOVED***:
        ***REMOVED***
        String representation.

        ***REMOVED***
        if masked_print_option.enabled(***REMOVED***:
            f = masked_print_option
            if self is masked:
                return str(f***REMOVED***
            m = self._mask
            if m is nomask:
                res = self._data
            else:
                if m.shape == (***REMOVED*** and m.itemsize==len(m.dtype***REMOVED***:
                    if m.dtype.names:
                        m = m.view((bool, len(m.dtype***REMOVED******REMOVED******REMOVED***
                        if m.any(***REMOVED***:
                            return str(tuple((f if _m else _d***REMOVED*** for _d, _m in
                                             zip(self._data.tolist(***REMOVED***, m***REMOVED******REMOVED******REMOVED***
                        else:
                            return str(self._data***REMOVED***
                    elif m:
                        return str(f***REMOVED***
                    else:
                        return str(self._data***REMOVED***
                # convert to object array to make filled work
                names = self.dtype.names
                if names is None:
                    data = self._data
                    mask = m
                    # For big arrays, to avoid a costly conversion to the
                    # object dtype, extract the corners before the conversion.
                    print_width = (self._print_width if self.ndim > 1
                                   else self._print_width_1d***REMOVED***
                    for axis in range(self.ndim***REMOVED***:
                        if data.shape[axis***REMOVED*** > print_width:
                            ind = print_width // 2
                            arr = np.split(data, (ind, -ind***REMOVED***, axis=axis***REMOVED***
                            data = np.concatenate((arr[0***REMOVED***, arr[2***REMOVED******REMOVED***, axis=axis***REMOVED***
                            arr = np.split(mask, (ind, -ind***REMOVED***, axis=axis***REMOVED***
                            mask = np.concatenate((arr[0***REMOVED***, arr[2***REMOVED******REMOVED***, axis=axis***REMOVED***
                    res = data.astype("O"***REMOVED***
                    res.view(ndarray***REMOVED***[mask***REMOVED*** = f
                else:
                    rdtype = _recursive_make_descr(self.dtype, "O"***REMOVED***
                    res = self._data.astype(rdtype***REMOVED***
                    _recursive_printoption(res, m, f***REMOVED***
        else:
            res = self.filled(self.fill_value***REMOVED***
        return str(res***REMOVED***

    def __repr__(self***REMOVED***:
        ***REMOVED***
        Literal string representation.

        ***REMOVED***
        n = len(self.shape***REMOVED***
        if self._baseclass is np.ndarray:
            name = 'array'
        else:
            name = self._baseclass.__name__

        parameters = dict(name=name, nlen=" " * len(name***REMOVED***,
                          data=str(self***REMOVED***, mask=str(self._mask***REMOVED***,
                          fill=str(self.fill_value***REMOVED***, dtype=str(self.dtype***REMOVED******REMOVED***
        if self.dtype.names:
            if n <= 1:
                return _print_templates['short_flx'***REMOVED*** % parameters
            return _print_templates['long_flx'***REMOVED*** % parameters
        elif n <= 1:
            return _print_templates['short_std'***REMOVED*** % parameters
        return _print_templates['long_std'***REMOVED*** % parameters

    def _delegate_binop(self, other***REMOVED***:
        # This emulates the logic in
        # multiarray/number.c:PyArray_GenericBinaryFunction
        if (not isinstance(other, np.ndarray***REMOVED***
                and not hasattr(other, "__numpy_ufunc__"***REMOVED******REMOVED***:
            other_priority = getattr(other, "__array_priority__", -1000000***REMOVED***
            if self.__array_priority__ < other_priority:
                return True
        return False

    def __eq__(self, other***REMOVED***:
        ***REMOVED***
        Check whether other equals self elementwise.

        ***REMOVED***
        if self is masked:
            return masked
        omask = getattr(other, '_mask', nomask***REMOVED***
        if omask is nomask:
            check = self.filled(0***REMOVED***.__eq__(other***REMOVED***
            ***REMOVED***
                check = check.view(type(self***REMOVED******REMOVED***
                check._mask = self._mask
            except AttributeError:
                # Dang, we have a bool instead of an array: return the bool
                return check
        else:
            odata = filled(other, 0***REMOVED***
            check = self.filled(0***REMOVED***.__eq__(odata***REMOVED***.view(type(self***REMOVED******REMOVED***
            if self._mask is nomask:
                check._mask = omask
            else:
                mask = mask_or(self._mask, omask***REMOVED***
                if mask.dtype.names:
                    if mask.size > 1:
                        axis = 1
                    else:
                        axis = None
                    ***REMOVED***
                        mask = mask.view((bool_, len(self.dtype***REMOVED******REMOVED******REMOVED***.all(axis***REMOVED***
                    except ValueError:
                        mask = np.all([[f[n***REMOVED***.all(***REMOVED*** for n in mask.dtype.names***REMOVED***
                                       for f in mask***REMOVED***, axis=axis***REMOVED***
                check._mask = mask
        return check

    def __ne__(self, other***REMOVED***:
        ***REMOVED***
        Check whether other doesn't equal self elementwise

        ***REMOVED***
        if self is masked:
            return masked
        omask = getattr(other, '_mask', nomask***REMOVED***
        if omask is nomask:
            check = self.filled(0***REMOVED***.__ne__(other***REMOVED***
            ***REMOVED***
                check = check.view(type(self***REMOVED******REMOVED***
                check._mask = self._mask
            except AttributeError:
                # In case check is a boolean (or a numpy.bool***REMOVED***
                return check
        else:
            odata = filled(other, 0***REMOVED***
            check = self.filled(0***REMOVED***.__ne__(odata***REMOVED***.view(type(self***REMOVED******REMOVED***
            if self._mask is nomask:
                check._mask = omask
            else:
                mask = mask_or(self._mask, omask***REMOVED***
                if mask.dtype.names:
                    if mask.size > 1:
                        axis = 1
                    else:
                        axis = None
                    ***REMOVED***
                        mask = mask.view((bool_, len(self.dtype***REMOVED******REMOVED******REMOVED***.all(axis***REMOVED***
                    except ValueError:
                        mask = np.all([[f[n***REMOVED***.all(***REMOVED*** for n in mask.dtype.names***REMOVED***
                                       for f in mask***REMOVED***, axis=axis***REMOVED***
                check._mask = mask
        return check

    def __add__(self, other***REMOVED***:
        ***REMOVED***
        Add self to other, and return a new masked array.

        ***REMOVED***
        if self._delegate_binop(other***REMOVED***:
            return NotImplemented
        return add(self, other***REMOVED***

    def __radd__(self, other***REMOVED***:
        ***REMOVED***
        Add other to self, and return a new masked array.

        ***REMOVED***
        # In analogy with __rsub__ and __rdiv__, use original order:
        # we get here from `other + self`.
        return add(other, self***REMOVED***

    def __sub__(self, other***REMOVED***:
        ***REMOVED***
        Subtract other from self, and return a new masked array.

        ***REMOVED***
        if self._delegate_binop(other***REMOVED***:
            return NotImplemented
        return subtract(self, other***REMOVED***

    def __rsub__(self, other***REMOVED***:
        ***REMOVED***
        Subtract self from other, and return a new masked array.

        ***REMOVED***
        return subtract(other, self***REMOVED***

    def __mul__(self, other***REMOVED***:
        "Multiply self by other, and return a new masked array."
        if self._delegate_binop(other***REMOVED***:
            return NotImplemented
        return multiply(self, other***REMOVED***

    def __rmul__(self, other***REMOVED***:
        ***REMOVED***
        Multiply other by self, and return a new masked array.

        ***REMOVED***
        # In analogy with __rsub__ and __rdiv__, use original order:
        # we get here from `other * self`.
        return multiply(other, self***REMOVED***

    def __div__(self, other***REMOVED***:
        ***REMOVED***
        Divide other into self, and return a new masked array.

        ***REMOVED***
        if self._delegate_binop(other***REMOVED***:
            return NotImplemented
        return divide(self, other***REMOVED***

    def __truediv__(self, other***REMOVED***:
        ***REMOVED***
        Divide other into self, and return a new masked array.

        ***REMOVED***
        if self._delegate_binop(other***REMOVED***:
            return NotImplemented
        return true_divide(self, other***REMOVED***

    def __rtruediv__(self, other***REMOVED***:
        ***REMOVED***
        Divide self into other, and return a new masked array.

        ***REMOVED***
        return true_divide(other, self***REMOVED***

    def __floordiv__(self, other***REMOVED***:
        ***REMOVED***
        Divide other into self, and return a new masked array.

        ***REMOVED***
        if self._delegate_binop(other***REMOVED***:
            return NotImplemented
        return floor_divide(self, other***REMOVED***

    def __rfloordiv__(self, other***REMOVED***:
        ***REMOVED***
        Divide self into other, and return a new masked array.

        ***REMOVED***
        return floor_divide(other, self***REMOVED***

    def __pow__(self, other***REMOVED***:
        ***REMOVED***
        Raise self to the power other, masking the potential NaNs/Infs

        ***REMOVED***
        if self._delegate_binop(other***REMOVED***:
            return NotImplemented
        return power(self, other***REMOVED***

    def __rpow__(self, other***REMOVED***:
        ***REMOVED***
        Raise other to the power self, masking the potential NaNs/Infs

        ***REMOVED***
        return power(other, self***REMOVED***

    def __iadd__(self, other***REMOVED***:
        ***REMOVED***
        Add other to self in-place.

        ***REMOVED***
        m = getmask(other***REMOVED***
        if self._mask is nomask:
            if m is not nomask and m.any(***REMOVED***:
                self._mask = make_mask_none(self.shape, self.dtype***REMOVED***
                self._mask += m
        else:
            if m is not nomask:
                self._mask += m
        self._data.__iadd__(np.where(self._mask, self.dtype.type(0***REMOVED***,
                                     getdata(other***REMOVED******REMOVED******REMOVED***
        return self

    def __isub__(self, other***REMOVED***:
        ***REMOVED***
        Subtract other from self in-place.

        ***REMOVED***
        m = getmask(other***REMOVED***
        if self._mask is nomask:
            if m is not nomask and m.any(***REMOVED***:
                self._mask = make_mask_none(self.shape, self.dtype***REMOVED***
                self._mask += m
        elif m is not nomask:
            self._mask += m
        self._data.__isub__(np.where(self._mask, self.dtype.type(0***REMOVED***,
                                     getdata(other***REMOVED******REMOVED******REMOVED***
        return self

    def __imul__(self, other***REMOVED***:
        ***REMOVED***
        Multiply self by other in-place.

        ***REMOVED***
        m = getmask(other***REMOVED***
        if self._mask is nomask:
            if m is not nomask and m.any(***REMOVED***:
                self._mask = make_mask_none(self.shape, self.dtype***REMOVED***
                self._mask += m
        elif m is not nomask:
            self._mask += m
        self._data.__imul__(np.where(self._mask, self.dtype.type(1***REMOVED***,
                                     getdata(other***REMOVED******REMOVED******REMOVED***
        return self

    def __idiv__(self, other***REMOVED***:
        ***REMOVED***
        Divide self by other in-place.

        ***REMOVED***
        other_data = getdata(other***REMOVED***
        dom_mask = _DomainSafeDivide(***REMOVED***.__call__(self._data, other_data***REMOVED***
        other_mask = getmask(other***REMOVED***
        new_mask = mask_or(other_mask, dom_mask***REMOVED***
        # The following 3 lines control the domain filling
        if dom_mask.any(***REMOVED***:
            (_, fval***REMOVED*** = ufunc_fills[np.divide***REMOVED***
            other_data = np.where(dom_mask, fval, other_data***REMOVED***
        self._mask |= new_mask
        self._data.__idiv__(np.where(self._mask, self.dtype.type(1***REMOVED***,
                                     other_data***REMOVED******REMOVED***
        return self

    def __ifloordiv__(self, other***REMOVED***:
        ***REMOVED***
        Floor divide self by other in-place.

        ***REMOVED***
        other_data = getdata(other***REMOVED***
        dom_mask = _DomainSafeDivide(***REMOVED***.__call__(self._data, other_data***REMOVED***
        other_mask = getmask(other***REMOVED***
        new_mask = mask_or(other_mask, dom_mask***REMOVED***
        # The following 3 lines control the domain filling
        if dom_mask.any(***REMOVED***:
            (_, fval***REMOVED*** = ufunc_fills[np.floor_divide***REMOVED***
            other_data = np.where(dom_mask, fval, other_data***REMOVED***
        self._mask |= new_mask
        self._data.__ifloordiv__(np.where(self._mask, self.dtype.type(1***REMOVED***,
                                          other_data***REMOVED******REMOVED***
        return self

    def __itruediv__(self, other***REMOVED***:
        ***REMOVED***
        True divide self by other in-place.

        ***REMOVED***
        other_data = getdata(other***REMOVED***
        dom_mask = _DomainSafeDivide(***REMOVED***.__call__(self._data, other_data***REMOVED***
        other_mask = getmask(other***REMOVED***
        new_mask = mask_or(other_mask, dom_mask***REMOVED***
        # The following 3 lines control the domain filling
        if dom_mask.any(***REMOVED***:
            (_, fval***REMOVED*** = ufunc_fills[np.true_divide***REMOVED***
            other_data = np.where(dom_mask, fval, other_data***REMOVED***
        self._mask |= new_mask
        self._data.__itruediv__(np.where(self._mask, self.dtype.type(1***REMOVED***,
                                         other_data***REMOVED******REMOVED***
        return self

    def __ipow__(self, other***REMOVED***:
        ***REMOVED***
        Raise self to the power other, in place.

        ***REMOVED***
        other_data = getdata(other***REMOVED***
        other_mask = getmask(other***REMOVED***
        with np.errstate(divide='ignore', invalid='ignore'***REMOVED***:
            self._data.__ipow__(np.where(self._mask, self.dtype.type(1***REMOVED***,
                                         other_data***REMOVED******REMOVED***
        invalid = np.logical_not(np.isfinite(self._data***REMOVED******REMOVED***
        if invalid.any(***REMOVED***:
            if self._mask is not nomask:
                self._mask |= invalid
            else:
                self._mask = invalid
            np.copyto(self._data, self.fill_value, where=invalid***REMOVED***
        new_mask = mask_or(other_mask, invalid***REMOVED***
        self._mask = mask_or(self._mask, new_mask***REMOVED***
        return self

    def __float__(self***REMOVED***:
        ***REMOVED***
        Convert to float.

        ***REMOVED***
        if self.size > 1:
            raise TypeError("Only length-1 arrays can be converted "
                            "to Python scalars"***REMOVED***
        elif self._mask:
            warnings.warn("Warning: converting a masked element to nan."***REMOVED***
            return np.nan
        return float(self.item(***REMOVED******REMOVED***

    def __int__(self***REMOVED***:
        ***REMOVED***
        Convert to int.

        ***REMOVED***
        if self.size > 1:
            raise TypeError("Only length-1 arrays can be converted "
                            "to Python scalars"***REMOVED***
        elif self._mask:
            raise MaskError('Cannot convert masked element to a Python int.'***REMOVED***
        return int(self.item(***REMOVED******REMOVED***

    def get_imag(self***REMOVED***:
        ***REMOVED***
        Return the imaginary part of the masked array.

        The returned array is a view on the imaginary part of the `MaskedArray`
        whose `get_imag` method is called.

        Parameters
        ----------
        None

        Returns
        -------
        result : MaskedArray
            The imaginary part of the masked array.

        See Also
        --------
        get_real, real, imag

        Examples
        --------
        >>> x = np.ma.array([1+1.j, -2j, 3.45+1.6j***REMOVED***, mask=[False, True, False***REMOVED******REMOVED***
        >>> x.get_imag(***REMOVED***
        masked_array(data = [1.0 -- 1.6***REMOVED***,
                     mask = [False  True False***REMOVED***,
               fill_value = 1e+20***REMOVED***

        ***REMOVED***
        result = self._data.imag.view(type(self***REMOVED******REMOVED***
        result.__setmask__(self._mask***REMOVED***
        return result

    imag = property(fget=get_imag, doc="Imaginary part."***REMOVED***

    def get_real(self***REMOVED***:
        ***REMOVED***
        Return the real part of the masked array.

        The returned array is a view on the real part of the `MaskedArray`
        whose `get_real` method is called.

        Parameters
        ----------
        None

        Returns
        -------
        result : MaskedArray
            The real part of the masked array.

        See Also
        --------
        get_imag, real, imag

        Examples
        --------
        >>> x = np.ma.array([1+1.j, -2j, 3.45+1.6j***REMOVED***, mask=[False, True, False***REMOVED******REMOVED***
        >>> x.get_real(***REMOVED***
        masked_array(data = [1.0 -- 3.45***REMOVED***,
                     mask = [False  True False***REMOVED***,
               fill_value = 1e+20***REMOVED***

        ***REMOVED***
        result = self._data.real.view(type(self***REMOVED******REMOVED***
        result.__setmask__(self._mask***REMOVED***
        return result
    real = property(fget=get_real, doc="Real part"***REMOVED***

    def count(self, axis=None, keepdims=np._NoValue***REMOVED***:
        ***REMOVED***
        Count the non-masked elements of the array along the given axis.

        Parameters
        ----------
        axis : None or int or tuple of ints, optional
            Axis or axes along which the count is performed.
            The default (`axis` = `None`***REMOVED*** performs the count over all
            the dimensions of the input array. `axis` may be negative, in
            which case it counts from the last to the first axis.

            .. versionadded:: 1.10.0

            If this is a tuple of ints, the count is performed on multiple
            axes, instead of a single axis or all the axes as before.
        keepdims : bool, optional
            If this is set to True, the axes which are reduced are left
            in the result as dimensions with size one. With this option,
            the result will broadcast correctly against the array.

        Returns
        -------
        result : ndarray or scalar
            An array with the same shape as the input array, with the specified
            axis removed. If the array is a 0-d array, or if `axis` is None, a
            scalar is returned.

        See Also
        --------
        count_masked : Count masked elements in array or along a given axis.

        Examples
        --------
        >>> import numpy.ma as ma
        >>> a = ma.arange(6***REMOVED***.reshape((2, 3***REMOVED******REMOVED***
        >>> a[1, :***REMOVED*** = ma.masked
        >>> a
        masked_array(data =
         [[0 1 2***REMOVED***
         [-- -- --***REMOVED******REMOVED***,
                     mask =
         [[False False False***REMOVED***
         [ True  True  True***REMOVED******REMOVED***,
               fill_value = 999999***REMOVED***
        >>> a.count(***REMOVED***
        3

        When the `axis` keyword is specified an array of appropriate size is
        returned.

        >>> a.count(axis=0***REMOVED***
        array([1, 1, 1***REMOVED******REMOVED***
        >>> a.count(axis=1***REMOVED***
        array([3, 0***REMOVED******REMOVED***

        ***REMOVED***
        kwargs = {***REMOVED*** if keepdims is np._NoValue else {'keepdims': keepdims***REMOVED***

        m = self._mask
        # special case for matrices (we assume no other subclasses modify
        # their dimensions***REMOVED***
        if isinstance(self.data, np.matrix***REMOVED***:
            if m is nomask:
                m = np.zeros(self.shape, dtype=np.bool_***REMOVED***
            m = m.view(type(self.data***REMOVED******REMOVED***

        if m is nomask:
            # compare to _count_reduce_items in _methods.py

            if self.shape is (***REMOVED***:
                if axis not in (None, 0***REMOVED***:
                    raise ValueError("'axis' entry is out of bounds"***REMOVED***
                return 1
            elif axis is None:
                if kwargs.get('keepdims', False***REMOVED***:
                    return np.array(self.size, dtype=np.intp, ndmin=self.ndim***REMOVED***
                return self.size

            axes = axis if isinstance(axis, tuple***REMOVED*** else (axis,***REMOVED***
            axes = tuple(a if a >= 0 else self.ndim + a for a in axes***REMOVED***
            if len(axes***REMOVED*** != len(set(axes***REMOVED******REMOVED***:
                raise ValueError("duplicate value in 'axis'"***REMOVED***
            if builtins.any(a < 0 or a >= self.ndim for a in axes***REMOVED***:
                raise ValueError("'axis' entry is out of bounds"***REMOVED***
            items = 1
            for ax in axes:
                items *= self.shape[ax***REMOVED***

            if kwargs.get('keepdims', False***REMOVED***:
                out_dims = list(self.shape***REMOVED***
                for a in axes:
                    out_dims[a***REMOVED*** = 1
            else:
                out_dims = [d for n, d in enumerate(self.shape***REMOVED***
                            if n not in axes***REMOVED***
            # make sure to return a 0-d array if axis is supplied
            return np.full(out_dims, items, dtype=np.intp***REMOVED***

        # take care of the masked singleton
        if self is masked:
            return 0

        return (~m***REMOVED***.sum(axis=axis, dtype=np.intp, **kwargs***REMOVED***

    flatten = _arraymethod('flatten'***REMOVED***

    def ravel(self, order='C'***REMOVED***:
        ***REMOVED***
        Returns a 1D version of self, as a view.

        Parameters
        ----------
        order : {'C', 'F', 'A', 'K'***REMOVED***, optional
            The elements of `a` are read using this index order. 'C' means to
            index the elements in C-like order, with the last axis index
            changing fastest, back to the first axis index changing slowest.
            'F' means to index the elements in Fortran-like index order, with
            the first index changing fastest, and the last index changing
            slowest. Note that the 'C' and 'F' options take no account of the
            memory layout of the underlying array, and only refer to the order
            of axis indexing.  'A' means to read the elements in Fortran-like
            index order if `m` is Fortran *contiguous* in memory, C-like order
            otherwise.  'K' means to read the elements in the order they occur
            in memory, except for reversing the data when strides are negative.
            By default, 'C' index order is used.

        Returns
        -------
        MaskedArray
            Output view is of shape ``(self.size,***REMOVED***`` (or
            ``(np.ma.product(self.shape***REMOVED***,***REMOVED***``***REMOVED***.

        Examples
        --------
        >>> x = np.ma.array([[1,2,3***REMOVED***,[4,5,6***REMOVED***,[7,8,9***REMOVED******REMOVED***, mask=[0***REMOVED*** + [1,0***REMOVED****4***REMOVED***
        >>> print(x***REMOVED***
        [[1 -- 3***REMOVED***
         [-- 5 --***REMOVED***
         [7 -- 9***REMOVED******REMOVED***
        >>> print(x.ravel(***REMOVED******REMOVED***
        [1 -- 3 -- 5 -- 7 -- 9***REMOVED***

        ***REMOVED***
        r = ndarray.ravel(self._data, order=order***REMOVED***.view(type(self***REMOVED******REMOVED***
        r._update_from(self***REMOVED***
        if self._mask is not nomask:
            r._mask = ndarray.ravel(self._mask, order=order***REMOVED***.reshape(r.shape***REMOVED***
        else:
            r._mask = nomask
        return r

    repeat = _arraymethod('repeat'***REMOVED***


    def reshape(self, *s, **kwargs***REMOVED***:
        ***REMOVED***
        Give a new shape to the array without changing its data.

        Returns a masked array containing the same data, but with a new shape.
        The result is a view on the original array; if this is not possible, a
        ValueError is raised.

        Parameters
        ----------
        shape : int or tuple of ints
            The new shape should be compatible with the original shape. If an
            integer is supplied, then the result will be a 1-D array of that
            length.
        order : {'C', 'F'***REMOVED***, optional
            Determines whether the array data should be viewed as in C
            (row-major***REMOVED*** or FORTRAN (column-major***REMOVED*** order.

        Returns
        -------
        reshaped_array : array
            A new view on the array.

        See Also
        --------
        reshape : Equivalent function in the masked array module.
        numpy.ndarray.reshape : Equivalent method on ndarray object.
        numpy.reshape : Equivalent function in the NumPy module.

        Notes
        -----
        The reshaping operation cannot guarantee that a copy will not be made,
        to modify the shape in place, use ``a.shape = s``

        Examples
        --------
        >>> x = np.ma.array([[1,2***REMOVED***,[3,4***REMOVED******REMOVED***, mask=[1,0,0,1***REMOVED******REMOVED***
        >>> print(x***REMOVED***
        [[-- 2***REMOVED***
         [3 --***REMOVED******REMOVED***
        >>> x = x.reshape((4,1***REMOVED******REMOVED***
        >>> print(x***REMOVED***
        [[--***REMOVED***
         [2***REMOVED***
         [3***REMOVED***
         [--***REMOVED******REMOVED***

        ***REMOVED***
        kwargs.update(order=kwargs.get('order', 'C'***REMOVED******REMOVED***
        result = self._data.reshape(*s, **kwargs***REMOVED***.view(type(self***REMOVED******REMOVED***
        result._update_from(self***REMOVED***
        mask = self._mask
        if mask is not nomask:
            result._mask = mask.reshape(*s, **kwargs***REMOVED***
        return result

    def resize(self, newshape, refcheck=True, order=False***REMOVED***:
        ***REMOVED***
        .. warning::

            This method does nothing, except raise a ValueError exception. A
            masked array does not own its data and therefore cannot safely be
            resized in place. Use the `numpy.ma.resize` function instead.

        This method is difficult to implement safely and may be deprecated in
        future releases of NumPy.

        ***REMOVED***
        # Note : the 'order' keyword looks broken, let's just drop it
        errmsg = "A masked array does not own its data "\
                 "and therefore cannot be resized.\n" \
                 "Use the numpy.ma.resize function instead."
        raise ValueError(errmsg***REMOVED***

    def put(self, indices, values, mode='raise'***REMOVED***:
        ***REMOVED***
        Set storage-indexed locations to corresponding values.

        Sets self._data.flat[n***REMOVED*** = values[n***REMOVED*** for each n in indices.
        If `values` is shorter than `indices` then it will repeat.
        If `values` has some masked values, the initial mask is updated
        in consequence, else the corresponding values are unmasked.

        Parameters
        ----------
        indices : 1-D array_like
            Target indices, interpreted as integers.
        values : array_like
            Values to place in self._data copy at target indices.
        mode : {'raise', 'wrap', 'clip'***REMOVED***, optional
            Specifies how out-of-bounds indices will behave.
            'raise' : raise an error.
            'wrap' : wrap around.
            'clip' : clip to the range.

        Notes
        -----
        `values` can be a scalar or length 1 array.

        Examples
        --------
        >>> x = np.ma.array([[1,2,3***REMOVED***,[4,5,6***REMOVED***,[7,8,9***REMOVED******REMOVED***, mask=[0***REMOVED*** + [1,0***REMOVED****4***REMOVED***
        >>> print(x***REMOVED***
        [[1 -- 3***REMOVED***
         [-- 5 --***REMOVED***
         [7 -- 9***REMOVED******REMOVED***
        >>> x.put([0,4,8***REMOVED***,[10,20,30***REMOVED******REMOVED***
        >>> print(x***REMOVED***
        [[10 -- 3***REMOVED***
         [-- 20 --***REMOVED***
         [7 -- 30***REMOVED******REMOVED***

        >>> x.put(4,999***REMOVED***
        >>> print(x***REMOVED***
        [[10 -- 3***REMOVED***
         [-- 999 --***REMOVED***
         [7 -- 30***REMOVED******REMOVED***

        ***REMOVED***
        # Hard mask: Get rid of the values/indices that fall on masked data
        if self._hardmask and self._mask is not nomask:
            mask = self._mask[indices***REMOVED***
            indices = narray(indices, copy=False***REMOVED***
            values = narray(values, copy=False, subok=True***REMOVED***
            values.resize(indices.shape***REMOVED***
            indices = indices[~mask***REMOVED***
            values = values[~mask***REMOVED***

        self._data.put(indices, values, mode=mode***REMOVED***

        # short circut if neither self nor values are masked
        if self._mask is nomask and getmask(values***REMOVED*** is nomask:
            return

        m = getmaskarray(self***REMOVED***.copy(***REMOVED***

        if getmask(values***REMOVED*** is nomask:
            m.put(indices, False, mode=mode***REMOVED***
        else:
            m.put(indices, values._mask, mode=mode***REMOVED***
        m = make_mask(m, copy=False, shrink=True***REMOVED***
        self._mask = m
        return

    def ids(self***REMOVED***:
        ***REMOVED***
        Return the addresses of the data and mask areas.

        Parameters
        ----------
        None

        Examples
        --------
        >>> x = np.ma.array([1, 2, 3***REMOVED***, mask=[0, 1, 1***REMOVED******REMOVED***
        >>> x.ids(***REMOVED***
        (166670640, 166659832***REMOVED***

        If the array has no mask, the address of `nomask` is returned. This address
        is typically not close to the data in memory:

        >>> x = np.ma.array([1, 2, 3***REMOVED******REMOVED***
        >>> x.ids(***REMOVED***
        (166691080, 3083169284L***REMOVED***

        ***REMOVED***
        if self._mask is nomask:
            return (self.ctypes.data, id(nomask***REMOVED******REMOVED***
        return (self.ctypes.data, self._mask.ctypes.data***REMOVED***

    def iscontiguous(self***REMOVED***:
        ***REMOVED***
        Return a boolean indicating whether the data is contiguous.

        Parameters
        ----------
        None

        Examples
        --------
        >>> x = np.ma.array([1, 2, 3***REMOVED******REMOVED***
        >>> x.iscontiguous(***REMOVED***
        True

        `iscontiguous` returns one of the flags of the masked array:

        >>> x.flags
          C_CONTIGUOUS : True
          F_CONTIGUOUS : True
          OWNDATA : False
          WRITEABLE : True
          ALIGNED : True
          UPDATEIFCOPY : False

        ***REMOVED***
        return self.flags['CONTIGUOUS'***REMOVED***

    def all(self, axis=None, out=None, keepdims=np._NoValue***REMOVED***:
        ***REMOVED***
        Returns True if all elements evaluate to True.

        The output array is masked where all the values along the given axis
        are masked: if the output would have been a scalar and that all the
        values are masked, then the output is `masked`.

        Refer to `numpy.all` for full documentation.

        See Also
        --------
        ndarray.all : corresponding function for ndarrays
        numpy.all : equivalent function

        Examples
        --------
        >>> np.ma.array([1,2,3***REMOVED******REMOVED***.all(***REMOVED***
        True
        >>> a = np.ma.array([1,2,3***REMOVED***, mask=True***REMOVED***
        >>> (a.all(***REMOVED*** is np.ma.masked***REMOVED***
        True

        ***REMOVED***
        kwargs = {***REMOVED*** if keepdims is np._NoValue else {'keepdims': keepdims***REMOVED***

        mask = _check_mask_axis(self._mask, axis, **kwargs***REMOVED***
        if out is None:
            d = self.filled(True***REMOVED***.all(axis=axis, **kwargs***REMOVED***.view(type(self***REMOVED******REMOVED***
            if d.ndim:
                d.__setmask__(mask***REMOVED***
            elif mask:
                return masked
            return d
        self.filled(True***REMOVED***.all(axis=axis, out=out, **kwargs***REMOVED***
        if isinstance(out, MaskedArray***REMOVED***:
            if out.ndim or mask:
                out.__setmask__(mask***REMOVED***
        return out

    def any(self, axis=None, out=None, keepdims=np._NoValue***REMOVED***:
        ***REMOVED***
        Returns True if any of the elements of `a` evaluate to True.

        Masked values are considered as False during computation.

        Refer to `numpy.any` for full documentation.

        See Also
        --------
        ndarray.any : corresponding function for ndarrays
        numpy.any : equivalent function

        ***REMOVED***
        kwargs = {***REMOVED*** if keepdims is np._NoValue else {'keepdims': keepdims***REMOVED***

        mask = _check_mask_axis(self._mask, axis, **kwargs***REMOVED***
        if out is None:
            d = self.filled(False***REMOVED***.any(axis=axis, **kwargs***REMOVED***.view(type(self***REMOVED******REMOVED***
            if d.ndim:
                d.__setmask__(mask***REMOVED***
            elif mask:
                d = masked
            return d
        self.filled(False***REMOVED***.any(axis=axis, out=out, **kwargs***REMOVED***
        if isinstance(out, MaskedArray***REMOVED***:
            if out.ndim or mask:
                out.__setmask__(mask***REMOVED***
        return out

    def nonzero(self***REMOVED***:
        ***REMOVED***
        Return the indices of unmasked elements that are not zero.

        Returns a tuple of arrays, one for each dimension, containing the
        indices of the non-zero elements in that dimension. The corresponding
        non-zero values can be obtained with::

            a[a.nonzero(***REMOVED******REMOVED***

        To group the indices by element, rather than dimension, use
        instead::

            np.transpose(a.nonzero(***REMOVED******REMOVED***

        The result of this is always a 2d array, with a row for each non-zero
        element.

        Parameters
        ----------
        None

        Returns
        -------
        tuple_of_arrays : tuple
            Indices of elements that are non-zero.

        See Also
        --------
        numpy.nonzero :
            Function operating on ndarrays.
        flatnonzero :
            Return indices that are non-zero in the flattened version of the input
            array.
        ndarray.nonzero :
            Equivalent ndarray method.
        count_nonzero :
            Counts the number of non-zero elements in the input array.

        Examples
        --------
        >>> import numpy.ma as ma
        >>> x = ma.array(np.eye(3***REMOVED******REMOVED***
        >>> x
        masked_array(data =
         [[ 1.  0.  0.***REMOVED***
         [ 0.  1.  0.***REMOVED***
         [ 0.  0.  1.***REMOVED******REMOVED***,
              mask =
         False,
              fill_value=1e+20***REMOVED***
        >>> x.nonzero(***REMOVED***
        (array([0, 1, 2***REMOVED******REMOVED***, array([0, 1, 2***REMOVED******REMOVED******REMOVED***

        Masked elements are ignored.

        >>> x[1, 1***REMOVED*** = ma.masked
        >>> x
        masked_array(data =
         [[1.0 0.0 0.0***REMOVED***
         [0.0 -- 0.0***REMOVED***
         [0.0 0.0 1.0***REMOVED******REMOVED***,
              mask =
         [[False False False***REMOVED***
         [False  True False***REMOVED***
         [False False False***REMOVED******REMOVED***,
              fill_value=1e+20***REMOVED***
        >>> x.nonzero(***REMOVED***
        (array([0, 2***REMOVED******REMOVED***, array([0, 2***REMOVED******REMOVED******REMOVED***

        Indices can also be grouped by element.

        >>> np.transpose(x.nonzero(***REMOVED******REMOVED***
        array([[0, 0***REMOVED***,
               [2, 2***REMOVED******REMOVED******REMOVED***

        A common use for ``nonzero`` is to find the indices of an array, where
        a condition is True.  Given an array `a`, the condition `a` > 3 is a
        boolean array and since False is interpreted as 0, ma.nonzero(a > 3***REMOVED***
        yields the indices of the `a` where the condition is true.

        >>> a = ma.array([[1,2,3***REMOVED***,[4,5,6***REMOVED***,[7,8,9***REMOVED******REMOVED******REMOVED***
        >>> a > 3
        masked_array(data =
         [[False False False***REMOVED***
         [ True  True  True***REMOVED***
         [ True  True  True***REMOVED******REMOVED***,
              mask =
         False,
              fill_value=999999***REMOVED***
        >>> ma.nonzero(a > 3***REMOVED***
        (array([1, 1, 1, 2, 2, 2***REMOVED******REMOVED***, array([0, 1, 2, 0, 1, 2***REMOVED******REMOVED******REMOVED***

        The ``nonzero`` method of the condition array can also be called.

        >>> (a > 3***REMOVED***.nonzero(***REMOVED***
        (array([1, 1, 1, 2, 2, 2***REMOVED******REMOVED***, array([0, 1, 2, 0, 1, 2***REMOVED******REMOVED******REMOVED***

        ***REMOVED***
        return narray(self.filled(0***REMOVED***, copy=False***REMOVED***.nonzero(***REMOVED***

    def trace(self, offset=0, axis1=0, axis2=1, dtype=None, out=None***REMOVED***:
        ***REMOVED***
        (this docstring should be overwritten***REMOVED***
        ***REMOVED***
        #!!!: implement out + test!
        m = self._mask
        if m is nomask:
            result = super(MaskedArray, self***REMOVED***.trace(offset=offset, axis1=axis1,
                                                    axis2=axis2, out=out***REMOVED***
            return result.astype(dtype***REMOVED***
        else:
            D = self.diagonal(offset=offset, axis1=axis1, axis2=axis2***REMOVED***
            return D.astype(dtype***REMOVED***.filled(0***REMOVED***.sum(axis=None, out=out***REMOVED***
    trace.__doc__ = ndarray.trace.__doc__

    def dot(self, b, out=None, strict=False***REMOVED***:
        ***REMOVED***
        a.dot(b, out=None***REMOVED***

        Masked dot product of two arrays. Note that `out` and `strict` are
        located in different positions than in `ma.dot`. In order to
        maintain compatibility with the functional version, it is
        recommended that the optional arguments be treated as keyword only.
        At some point that may be mandatory.

        .. versionadded:: 1.10.0

        Parameters
        ----------
        b : masked_array_like
            Inputs array.
        out : masked_array, optional
            Output argument. This must have the exact kind that would be
            returned if it was not used. In particular, it must have the
            right type, must be C-contiguous, and its dtype must be the
            dtype that would be returned for `ma.dot(a,b***REMOVED***`. This is a
            performance feature. Therefore, if these conditions are not
            met, an exception is raised, instead of attempting to be
            flexible.
        strict : bool, optional
            Whether masked data are propagated (True***REMOVED*** or set to 0 (False***REMOVED***
            for the computation. Default is False.  Propagating the mask
            means that if a masked value appears in a row or column, the
            whole row or column is considered masked.

            .. versionadded:: 1.10.2

        See Also
        --------
        numpy.ma.dot : equivalent function

        ***REMOVED***
        return dot(self, b, out=out, strict=strict***REMOVED***

    def sum(self, axis=None, dtype=None, out=None, keepdims=np._NoValue***REMOVED***:
        ***REMOVED***
        Return the sum of the array elements over the given axis.

        Masked elements are set to 0 internally.

        Refer to `numpy.sum` for full documentation.

        See Also
        --------
        ndarray.sum : corresponding function for ndarrays
        numpy.sum : equivalent function

        Examples
        --------
        >>> x = np.ma.array([[1,2,3***REMOVED***,[4,5,6***REMOVED***,[7,8,9***REMOVED******REMOVED***, mask=[0***REMOVED*** + [1,0***REMOVED****4***REMOVED***
        >>> print(x***REMOVED***
        [[1 -- 3***REMOVED***
         [-- 5 --***REMOVED***
         [7 -- 9***REMOVED******REMOVED***
        >>> print(x.sum(***REMOVED******REMOVED***
        25
        >>> print(x.sum(axis=1***REMOVED******REMOVED***
        [4 5 16***REMOVED***
        >>> print(x.sum(axis=0***REMOVED******REMOVED***
        [8 5 12***REMOVED***
        >>> print(type(x.sum(axis=0, dtype=np.int64***REMOVED***[0***REMOVED******REMOVED******REMOVED***
        <type 'numpy.int64'>

        ***REMOVED***
        kwargs = {***REMOVED*** if keepdims is np._NoValue else {'keepdims': keepdims***REMOVED***

        _mask = self._mask
        newmask = _check_mask_axis(_mask, axis, **kwargs***REMOVED***
        # No explicit output
        if out is None:
            result = self.filled(0***REMOVED***.sum(axis, dtype=dtype, **kwargs***REMOVED***
            rndim = getattr(result, 'ndim', 0***REMOVED***
            if rndim:
                result = result.view(type(self***REMOVED******REMOVED***
                result.__setmask__(newmask***REMOVED***
            elif newmask:
                result = masked
            return result
        # Explicit output
        result = self.filled(0***REMOVED***.sum(axis, dtype=dtype, out=out, **kwargs***REMOVED***
        if isinstance(out, MaskedArray***REMOVED***:
            outmask = getattr(out, '_mask', nomask***REMOVED***
            if (outmask is nomask***REMOVED***:
                outmask = out._mask = make_mask_none(out.shape***REMOVED***
            outmask.flat = newmask
        return out

    def cumsum(self, axis=None, dtype=None, out=None***REMOVED***:
        ***REMOVED***
        Return the cumulative sum of the array elements over the given axis.

        Masked values are set to 0 internally during the computation.
        However, their position is saved, and the result will be masked at
        the same locations.

        Refer to `numpy.cumsum` for full documentation.

        Notes
        -----
        The mask is lost if `out` is not a valid :class:`MaskedArray` !

        Arithmetic is modular when using integer types, and no error is
        raised on overflow.

        See Also
        --------
        ndarray.cumsum : corresponding function for ndarrays
        numpy.cumsum : equivalent function

        Examples
        --------
        >>> marr = np.ma.array(np.arange(10***REMOVED***, mask=[0,0,0,1,1,1,0,0,0,0***REMOVED******REMOVED***
        >>> print(marr.cumsum(***REMOVED******REMOVED***
        [0 1 3 -- -- -- 9 16 24 33***REMOVED***

        ***REMOVED***
        result = self.filled(0***REMOVED***.cumsum(axis=axis, dtype=dtype, out=out***REMOVED***
        if out is not None:
            if isinstance(out, MaskedArray***REMOVED***:
                out.__setmask__(self.mask***REMOVED***
            return out
        result = result.view(type(self***REMOVED******REMOVED***
        result.__setmask__(self._mask***REMOVED***
        return result

    def prod(self, axis=None, dtype=None, out=None, keepdims=np._NoValue***REMOVED***:
        ***REMOVED***
        Return the product of the array elements over the given axis.

        Masked elements are set to 1 internally for computation.

        Refer to `numpy.prod` for full documentation.

        Notes
        -----
        Arithmetic is modular when using integer types, and no error is raised
        on overflow.

        See Also
        --------
        ndarray.prod : corresponding function for ndarrays
        numpy.prod : equivalent function
        ***REMOVED***
        kwargs = {***REMOVED*** if keepdims is np._NoValue else {'keepdims': keepdims***REMOVED***

        _mask = self._mask
        newmask = _check_mask_axis(_mask, axis, **kwargs***REMOVED***
        # No explicit output
        if out is None:
            result = self.filled(1***REMOVED***.prod(axis, dtype=dtype, **kwargs***REMOVED***
            rndim = getattr(result, 'ndim', 0***REMOVED***
            if rndim:
                result = result.view(type(self***REMOVED******REMOVED***
                result.__setmask__(newmask***REMOVED***
            elif newmask:
                result = masked
            return result
        # Explicit output
        result = self.filled(1***REMOVED***.prod(axis, dtype=dtype, out=out, **kwargs***REMOVED***
        if isinstance(out, MaskedArray***REMOVED***:
            outmask = getattr(out, '_mask', nomask***REMOVED***
            if (outmask is nomask***REMOVED***:
                outmask = out._mask = make_mask_none(out.shape***REMOVED***
            outmask.flat = newmask
        return out
    product = prod

    def cumprod(self, axis=None, dtype=None, out=None***REMOVED***:
        ***REMOVED***
        Return the cumulative product of the array elements over the given axis.

        Masked values are set to 1 internally during the computation.
        However, their position is saved, and the result will be masked at
        the same locations.

        Refer to `numpy.cumprod` for full documentation.

        Notes
        -----
        The mask is lost if `out` is not a valid MaskedArray !

        Arithmetic is modular when using integer types, and no error is
        raised on overflow.

        See Also
        --------
        ndarray.cumprod : corresponding function for ndarrays
        numpy.cumprod : equivalent function
        ***REMOVED***
        result = self.filled(1***REMOVED***.cumprod(axis=axis, dtype=dtype, out=out***REMOVED***
        if out is not None:
            if isinstance(out, MaskedArray***REMOVED***:
                out.__setmask__(self._mask***REMOVED***
            return out
        result = result.view(type(self***REMOVED******REMOVED***
        result.__setmask__(self._mask***REMOVED***
        return result

    def mean(self, axis=None, dtype=None, out=None, keepdims=np._NoValue***REMOVED***:
        ***REMOVED***
        Returns the average of the array elements along given axis.

        Masked entries are ignored, and result elements which are not
        finite will be masked.

        Refer to `numpy.mean` for full documentation.

        See Also
        --------
        ndarray.mean : corresponding function for ndarrays
        numpy.mean : Equivalent function
        numpy.ma.average: Weighted average.

        Examples
        --------
        >>> a = np.ma.array([1,2,3***REMOVED***, mask=[False, False, True***REMOVED******REMOVED***
        >>> a
        masked_array(data = [1 2 --***REMOVED***,
                     mask = [False False  True***REMOVED***,
               fill_value = 999999***REMOVED***
        >>> a.mean(***REMOVED***
        1.5

        ***REMOVED***
        kwargs = {***REMOVED*** if keepdims is np._NoValue else {'keepdims': keepdims***REMOVED***

        if self._mask is nomask:
            result = super(MaskedArray, self***REMOVED***.mean(axis=axis,
                                                   dtype=dtype, **kwargs***REMOVED***
        else:
            dsum = self.sum(axis=axis, dtype=dtype, **kwargs***REMOVED***
            cnt = self.count(axis=axis, **kwargs***REMOVED***
            if cnt.shape == (***REMOVED*** and (cnt == 0***REMOVED***:
                result = masked
            else:
                result = dsum * 1. / cnt
        if out is not None:
            out.flat = result
            if isinstance(out, MaskedArray***REMOVED***:
                outmask = getattr(out, '_mask', nomask***REMOVED***
                if (outmask is nomask***REMOVED***:
                    outmask = out._mask = make_mask_none(out.shape***REMOVED***
                outmask.flat = getattr(result, '_mask', nomask***REMOVED***
            return out
        return result

    def anom(self, axis=None, dtype=None***REMOVED***:
        ***REMOVED***
        Compute the anomalies (deviations from the arithmetic mean***REMOVED***
        along the given axis.

        Returns an array of anomalies, with the same shape as the input and
        where the arithmetic mean is computed along the given axis.

        Parameters
        ----------
        axis : int, optional
            Axis over which the anomalies are taken.
            The default is to use the mean of the flattened array as reference.
        dtype : dtype, optional
            Type to use in computing the variance. For arrays of integer type
             the default is float32; for arrays of float types it is the same as
             the array type.

        See Also
        --------
        mean : Compute the mean of the array.

        Examples
        --------
        >>> a = np.ma.array([1,2,3***REMOVED******REMOVED***
        >>> a.anom(***REMOVED***
        masked_array(data = [-1.  0.  1.***REMOVED***,
                     mask = False,
               fill_value = 1e+20***REMOVED***

        ***REMOVED***
        m = self.mean(axis, dtype***REMOVED***
        if m is masked:
            return m

        if not axis:
            return (self - m***REMOVED***
        else:
            return (self - expand_dims(m, axis***REMOVED******REMOVED***

    def var(self, axis=None, dtype=None, out=None, ddof=0,
            keepdims=np._NoValue***REMOVED***:
        ***REMOVED***
        Returns the variance of the array elements along given axis.

        Masked entries are ignored, and result elements which are not
        finite will be masked.

        Refer to `numpy.var` for full documentation.

        See Also
        --------
        ndarray.var : corresponding function for ndarrays
        numpy.var : Equivalent function
        ***REMOVED***
        kwargs = {***REMOVED*** if keepdims is np._NoValue else {'keepdims': keepdims***REMOVED***

        # Easy case: nomask, business as usual
        if self._mask is nomask:
            return self._data.var(axis=axis, dtype=dtype, out=out,
                                  ddof=ddof, **kwargs***REMOVED***
        # Some data are masked, yay!
        cnt = self.count(axis=axis, **kwargs***REMOVED*** - ddof
        danom = self - self.mean(axis, dtype, keepdims=True***REMOVED***
        if iscomplexobj(self***REMOVED***:
            danom = umath.absolute(danom***REMOVED*** ** 2
        else:
            danom *= danom
        dvar = divide(danom.sum(axis, **kwargs***REMOVED***, cnt***REMOVED***.view(type(self***REMOVED******REMOVED***
        # Apply the mask if it's not a scalar
        if dvar.ndim:
            dvar._mask = mask_or(self._mask.all(axis, **kwargs***REMOVED***, (cnt <= 0***REMOVED******REMOVED***
            dvar._update_from(self***REMOVED***
        elif getattr(dvar, '_mask', False***REMOVED***:
            # Make sure that masked is returned when the scalar is masked.
            dvar = masked
            if out is not None:
                if isinstance(out, MaskedArray***REMOVED***:
                    out.flat = 0
                    out.__setmask__(True***REMOVED***
                elif out.dtype.kind in 'biu':
                    errmsg = "Masked data information would be lost in one or "\
                             "more location."
                    raise MaskError(errmsg***REMOVED***
                else:
                    out.flat = np.nan
                return out
        # In case with have an explicit output
        if out is not None:
            # Set the data
            out.flat = dvar
            # Set the mask if needed
            if isinstance(out, MaskedArray***REMOVED***:
                out.__setmask__(dvar.mask***REMOVED***
            return out
        return dvar
    var.__doc__ = np.var.__doc__

    def std(self, axis=None, dtype=None, out=None, ddof=0,
            keepdims=np._NoValue***REMOVED***:
        ***REMOVED***
        Returns the standard deviation of the array elements along given axis.

        Masked entries are ignored.

        Refer to `numpy.std` for full documentation.

        See Also
        --------
        ndarray.std : corresponding function for ndarrays
        numpy.std : Equivalent function
        ***REMOVED***
        kwargs = {***REMOVED*** if keepdims is np._NoValue else {'keepdims': keepdims***REMOVED***

        dvar = self.var(axis, dtype, out, ddof, **kwargs***REMOVED***
        if dvar is not masked:
            if out is not None:
                np.power(out, 0.5, out=out, casting='unsafe'***REMOVED***
                return out
            dvar = sqrt(dvar***REMOVED***
        return dvar

    def round(self, decimals=0, out=None***REMOVED***:
        ***REMOVED***
        Return each element rounded to the given number of decimals.

        Refer to `numpy.around` for full documentation.

        See Also
        --------
        ndarray.around : corresponding function for ndarrays
        numpy.around : equivalent function
        ***REMOVED***
        result = self._data.round(decimals=decimals, out=out***REMOVED***.view(type(self***REMOVED******REMOVED***
        if result.ndim > 0:
            result._mask = self._mask
            result._update_from(self***REMOVED***
        elif self._mask:
            # Return masked when the scalar is masked
            result = masked
        # No explicit output: we're done
        if out is None:
            return result
        if isinstance(out, MaskedArray***REMOVED***:
            out.__setmask__(self._mask***REMOVED***
        return out

    def argsort(self, axis=None, kind='quicksort', order=None, fill_value=None***REMOVED***:
        ***REMOVED***
        Return an ndarray of indices that sort the array along the
        specified axis.  Masked values are filled beforehand to
        `fill_value`.

        Parameters
        ----------
        axis : int, optional
            Axis along which to sort.  The default is -1 (last axis***REMOVED***.
            If None, the flattened array is used.
        fill_value : var, optional
            Value used to fill the array before sorting.
            The default is the `fill_value` attribute of the input array.
        kind : {'quicksort', 'mergesort', 'heapsort'***REMOVED***, optional
            Sorting algorithm.
        order : list, optional
            When `a` is an array with fields defined, this argument specifies
            which fields to compare first, second, etc.  Not all fields need be
            specified.

        Returns
        -------
        index_array : ndarray, int
            Array of indices that sort `a` along the specified axis.
            In other words, ``a[index_array***REMOVED***`` yields a sorted `a`.

        See Also
        --------
        sort : Describes sorting algorithms used.
        lexsort : Indirect stable sort with multiple keys.
        ndarray.sort : Inplace sort.

        Notes
        -----
        See `sort` for notes on the different sorting algorithms.

        Examples
        --------
        >>> a = np.ma.array([3,2,1***REMOVED***, mask=[False, False, True***REMOVED******REMOVED***
        >>> a
        masked_array(data = [3 2 --***REMOVED***,
                     mask = [False False  True***REMOVED***,
               fill_value = 999999***REMOVED***
        >>> a.argsort(***REMOVED***
        array([1, 0, 2***REMOVED******REMOVED***

        ***REMOVED***
        if fill_value is None:
            fill_value = default_fill_value(self***REMOVED***
        d = self.filled(fill_value***REMOVED***.view(ndarray***REMOVED***
        return d.argsort(axis=axis, kind=kind, order=order***REMOVED***

    def argmin(self, axis=None, fill_value=None, out=None***REMOVED***:
        ***REMOVED***
        Return array of indices to the minimum values along the given axis.

        Parameters
        ----------
        axis : {None, integer***REMOVED***
            If None, the index is into the flattened array, otherwise along
            the specified axis
        fill_value : {var***REMOVED***, optional
            Value used to fill in the masked values.  If None, the output of
            minimum_fill_value(self._data***REMOVED*** is used instead.
        out : {None, array***REMOVED***, optional
            Array into which the result can be placed. Its type is preserved
            and it must be of the right shape to hold the output.

        Returns
        -------
        ndarray or scalar
            If multi-dimension input, returns a new ndarray of indices to the
            minimum values along the given axis.  Otherwise, returns a scalar
            of index to the minimum values along the given axis.

        Examples
        --------
        >>> x = np.ma.array(arange(4***REMOVED***, mask=[1,1,0,0***REMOVED******REMOVED***
        >>> x.shape = (2,2***REMOVED***
        >>> print(x***REMOVED***
        [[-- --***REMOVED***
         [2 3***REMOVED******REMOVED***
        >>> print(x.argmin(axis=0, fill_value=-1***REMOVED******REMOVED***
        [0 0***REMOVED***
        >>> print(x.argmin(axis=0, fill_value=9***REMOVED******REMOVED***
        [1 1***REMOVED***

        ***REMOVED***
        if fill_value is None:
            fill_value = minimum_fill_value(self***REMOVED***
        d = self.filled(fill_value***REMOVED***.view(ndarray***REMOVED***
        return d.argmin(axis, out=out***REMOVED***

    def argmax(self, axis=None, fill_value=None, out=None***REMOVED***:
        ***REMOVED***
        Returns array of indices of the maximum values along the given axis.
        Masked values are treated as if they had the value fill_value.

        Parameters
        ----------
        axis : {None, integer***REMOVED***
            If None, the index is into the flattened array, otherwise along
            the specified axis
        fill_value : {var***REMOVED***, optional
            Value used to fill in the masked values.  If None, the output of
            maximum_fill_value(self._data***REMOVED*** is used instead.
        out : {None, array***REMOVED***, optional
            Array into which the result can be placed. Its type is preserved
            and it must be of the right shape to hold the output.

        Returns
        -------
        index_array : {integer_array***REMOVED***

        Examples
        --------
        >>> a = np.arange(6***REMOVED***.reshape(2,3***REMOVED***
        >>> a.argmax(***REMOVED***
        5
        >>> a.argmax(0***REMOVED***
        array([1, 1, 1***REMOVED******REMOVED***
        >>> a.argmax(1***REMOVED***
        array([2, 2***REMOVED******REMOVED***

        ***REMOVED***
        if fill_value is None:
            fill_value = maximum_fill_value(self._data***REMOVED***
        d = self.filled(fill_value***REMOVED***.view(ndarray***REMOVED***
        return d.argmax(axis, out=out***REMOVED***

    def sort(self, axis=-1, kind='quicksort', order=None,
             endwith=True, fill_value=None***REMOVED***:
        ***REMOVED***
        Sort the array, in-place

        Parameters
        ----------
        a : array_like
            Array to be sorted.
        axis : int, optional
            Axis along which to sort. If None, the array is flattened before
            sorting. The default is -1, which sorts along the last axis.
        kind : {'quicksort', 'mergesort', 'heapsort'***REMOVED***, optional
            Sorting algorithm. Default is 'quicksort'.
        order : list, optional
            When `a` is a structured array, this argument specifies which fields
            to compare first, second, and so on.  This list does not need to
            include all of the fields.
        endwith : {True, False***REMOVED***, optional
            Whether missing values (if any***REMOVED*** should be forced in the upper indices
            (at the end of the array***REMOVED*** (True***REMOVED*** or lower indices (at the beginning***REMOVED***.
            When the array contains unmasked values of the largest (or smallest if
            False***REMOVED*** representable value of the datatype the ordering of these values
            and the masked values is undefined.  To enforce the masked values are
            at the end (beginning***REMOVED*** in this case one must sort the mask.
        fill_value : {var***REMOVED***, optional
            Value used internally for the masked values.
            If ``fill_value`` is not None, it supersedes ``endwith``.

        Returns
        -------
        sorted_array : ndarray
            Array of the same type and shape as `a`.

        See Also
        --------
        ndarray.sort : Method to sort an array in-place.
        argsort : Indirect sort.
        lexsort : Indirect stable sort on multiple keys.
        searchsorted : Find elements in a sorted array.

        Notes
        -----
        See ``sort`` for notes on the different sorting algorithms.

        Examples
        --------
        >>> a = ma.array([1, 2, 5, 4, 3***REMOVED***,mask=[0, 1, 0, 1, 0***REMOVED******REMOVED***
        >>> # Default
        >>> a.sort(***REMOVED***
        >>> print(a***REMOVED***
        [1 3 5 -- --***REMOVED***

        >>> a = ma.array([1, 2, 5, 4, 3***REMOVED***,mask=[0, 1, 0, 1, 0***REMOVED******REMOVED***
        >>> # Put missing values in the front
        >>> a.sort(endwith=False***REMOVED***
        >>> print(a***REMOVED***
        [-- -- 1 3 5***REMOVED***

        >>> a = ma.array([1, 2, 5, 4, 3***REMOVED***,mask=[0, 1, 0, 1, 0***REMOVED******REMOVED***
        >>> # fill_value takes over endwith
        >>> a.sort(endwith=False, fill_value=3***REMOVED***
        >>> print(a***REMOVED***
        [1 -- -- 3 5***REMOVED***

        ***REMOVED***
        if self._mask is nomask:
            ndarray.sort(self, axis=axis, kind=kind, order=order***REMOVED***
        else:
            if self is masked:
                return self
            if fill_value is None:
                if endwith:
                    # nan > inf
                    if np.issubdtype(self.dtype, np.floating***REMOVED***:
                        filler = np.nan
                    else:
                        filler = minimum_fill_value(self***REMOVED***
                else:
                    filler = maximum_fill_value(self***REMOVED***
            else:
                filler = fill_value

            sidx = self.filled(filler***REMOVED***.argsort(axis=axis, kind=kind,
                                               order=order***REMOVED***
            # save meshgrid memory for 1d arrays
            if self.ndim == 1:
                idx = sidx
            else:
                idx = np.meshgrid(*[np.arange(x***REMOVED*** for x in self.shape***REMOVED***, sparse=True,
                                  indexing='ij'***REMOVED***
                idx[axis***REMOVED*** = sidx
            tmp_mask = self._mask[idx***REMOVED***.flat
            tmp_data = self._data[idx***REMOVED***.flat
            self._data.flat = tmp_data
            self._mask.flat = tmp_mask
        return

    def min(self, axis=None, out=None, fill_value=None, keepdims=np._NoValue***REMOVED***:
        ***REMOVED***
        Return the minimum along a given axis.

        Parameters
        ----------
        axis : {None, int***REMOVED***, optional
            Axis along which to operate.  By default, ``axis`` is None and the
            flattened input is used.
        out : array_like, optional
            Alternative output array in which to place the result.  Must be of
            the same shape and buffer length as the expected output.
        fill_value : {var***REMOVED***, optional
            Value used to fill in the masked values.
            If None, use the output of `minimum_fill_value`.

        Returns
        -------
        amin : array_like
            New array holding the result.
            If ``out`` was specified, ``out`` is returned.

        See Also
        --------
        minimum_fill_value
            Returns the minimum filling value for a given datatype.

        ***REMOVED***
        kwargs = {***REMOVED*** if keepdims is np._NoValue else {'keepdims': keepdims***REMOVED***

        _mask = self._mask
        newmask = _check_mask_axis(_mask, axis, **kwargs***REMOVED***
        if fill_value is None:
            fill_value = minimum_fill_value(self***REMOVED***
        # No explicit output
        if out is None:
            result = self.filled(fill_value***REMOVED***.min(
                axis=axis, out=out, **kwargs***REMOVED***.view(type(self***REMOVED******REMOVED***
            if result.ndim:
                # Set the mask
                result.__setmask__(newmask***REMOVED***
                # Get rid of Infs
                if newmask.ndim:
                    np.copyto(result, result.fill_value, where=newmask***REMOVED***
            elif newmask:
                result = masked
            return result
        # Explicit output
        result = self.filled(fill_value***REMOVED***.min(axis=axis, out=out, **kwargs***REMOVED***
        if isinstance(out, MaskedArray***REMOVED***:
            outmask = getattr(out, '_mask', nomask***REMOVED***
            if (outmask is nomask***REMOVED***:
                outmask = out._mask = make_mask_none(out.shape***REMOVED***
            outmask.flat = newmask
        else:
            if out.dtype.kind in 'biu':
                errmsg = "Masked data information would be lost in one or more"\
                         " location."
                raise MaskError(errmsg***REMOVED***
            np.copyto(out, np.nan, where=newmask***REMOVED***
        return out

    # unique to masked arrays
    def mini(self, axis=None***REMOVED***:
        ***REMOVED***
        Return the array minimum along the specified axis.

        Parameters
        ----------
        axis : int, optional
            The axis along which to find the minima. Default is None, in which case
            the minimum value in the whole array is returned.

        Returns
        -------
        min : scalar or MaskedArray
            If `axis` is None, the result is a scalar. Otherwise, if `axis` is
            given and the array is at least 2-D, the result is a masked array with
            dimension one smaller than the array on which `mini` is called.

        Examples
        --------
        >>> x = np.ma.array(np.arange(6***REMOVED***, mask=[0 ,1, 0, 0, 0 ,1***REMOVED******REMOVED***.reshape(3, 2***REMOVED***
        >>> print(x***REMOVED***
        [[0 --***REMOVED***
         [2 3***REMOVED***
         [4 --***REMOVED******REMOVED***
        >>> x.mini(***REMOVED***
        0
        >>> x.mini(axis=0***REMOVED***
        masked_array(data = [0 3***REMOVED***,
                     mask = [False False***REMOVED***,
               fill_value = 999999***REMOVED***
        >>> print(x.mini(axis=1***REMOVED******REMOVED***
        [0 2 4***REMOVED***

        ***REMOVED***
        if axis is None:
            return minimum(self***REMOVED***
        else:
            return minimum.reduce(self, axis***REMOVED***

    def max(self, axis=None, out=None, fill_value=None, keepdims=np._NoValue***REMOVED***:
        ***REMOVED***
        Return the maximum along a given axis.

        Parameters
        ----------
        axis : {None, int***REMOVED***, optional
            Axis along which to operate.  By default, ``axis`` is None and the
            flattened input is used.
        out : array_like, optional
            Alternative output array in which to place the result.  Must
            be of the same shape and buffer length as the expected output.
        fill_value : {var***REMOVED***, optional
            Value used to fill in the masked values.
            If None, use the output of maximum_fill_value(***REMOVED***.

        Returns
        -------
        amax : array_like
            New array holding the result.
            If ``out`` was specified, ``out`` is returned.

        See Also
        --------
        maximum_fill_value
            Returns the maximum filling value for a given datatype.

        ***REMOVED***
        kwargs = {***REMOVED*** if keepdims is np._NoValue else {'keepdims': keepdims***REMOVED***

        _mask = self._mask
        newmask = _check_mask_axis(_mask, axis, **kwargs***REMOVED***
        if fill_value is None:
            fill_value = maximum_fill_value(self***REMOVED***
        # No explicit output
        if out is None:
            result = self.filled(fill_value***REMOVED***.max(
                axis=axis, out=out, **kwargs***REMOVED***.view(type(self***REMOVED******REMOVED***
            if result.ndim:
                # Set the mask
                result.__setmask__(newmask***REMOVED***
                # Get rid of Infs
                if newmask.ndim:
                    np.copyto(result, result.fill_value, where=newmask***REMOVED***
            elif newmask:
                result = masked
            return result
        # Explicit output
        result = self.filled(fill_value***REMOVED***.max(axis=axis, out=out, **kwargs***REMOVED***
        if isinstance(out, MaskedArray***REMOVED***:
            outmask = getattr(out, '_mask', nomask***REMOVED***
            if (outmask is nomask***REMOVED***:
                outmask = out._mask = make_mask_none(out.shape***REMOVED***
            outmask.flat = newmask
        else:

            if out.dtype.kind in 'biu':
                errmsg = "Masked data information would be lost in one or more"\
                         " location."
                raise MaskError(errmsg***REMOVED***
            np.copyto(out, np.nan, where=newmask***REMOVED***
        return out

    def ptp(self, axis=None, out=None, fill_value=None***REMOVED***:
        ***REMOVED***
        Return (maximum - minimum***REMOVED*** along the the given dimension
        (i.e. peak-to-peak value***REMOVED***.

        Parameters
        ----------
        axis : {None, int***REMOVED***, optional
            Axis along which to find the peaks.  If None (default***REMOVED*** the
            flattened array is used.
        out : {None, array_like***REMOVED***, optional
            Alternative output array in which to place the result. It must
            have the same shape and buffer length as the expected output
            but the type will be cast if necessary.
        fill_value : {var***REMOVED***, optional
            Value used to fill in the masked values.

        Returns
        -------
        ptp : ndarray.
            A new array holding the result, unless ``out`` was
            specified, in which case a reference to ``out`` is returned.

        ***REMOVED***
        if out is None:
            result = self.max(axis=axis, fill_value=fill_value***REMOVED***
            result -= self.min(axis=axis, fill_value=fill_value***REMOVED***
            return result
        out.flat = self.max(axis=axis, out=out, fill_value=fill_value***REMOVED***
        min_value = self.min(axis=axis, fill_value=fill_value***REMOVED***
        np.subtract(out, min_value, out=out, casting='unsafe'***REMOVED***
        return out

    def take(self, indices, axis=None, out=None, mode='raise'***REMOVED***:
        ***REMOVED***
        ***REMOVED***
        (_data, _mask***REMOVED*** = (self._data, self._mask***REMOVED***
        cls = type(self***REMOVED***
        # Make sure the indices are not masked
        maskindices = getattr(indices, '_mask', nomask***REMOVED***
        if maskindices is not nomask:
            indices = indices.filled(0***REMOVED***
        # Get the data, promoting scalars to 0d arrays with [...***REMOVED*** so that
        # .view works correctly
        if out is None:
            out = _data.take(indices, axis=axis, mode=mode***REMOVED***[...***REMOVED***.view(cls***REMOVED***
        else:
            np.take(_data, indices, axis=axis, mode=mode, out=out***REMOVED***
        # Get the mask
        if isinstance(out, MaskedArray***REMOVED***:
            if _mask is nomask:
                outmask = maskindices
            else:
                outmask = _mask.take(indices, axis=axis, mode=mode***REMOVED***
                outmask |= maskindices
            out.__setmask__(outmask***REMOVED***
        # demote 0d arrays back to scalars, for consistency with ndarray.take
        return out[(***REMOVED******REMOVED***

    # Array methods
    copy = _arraymethod('copy'***REMOVED***
    diagonal = _arraymethod('diagonal'***REMOVED***
    transpose = _arraymethod('transpose'***REMOVED***
    T = property(fget=lambda self: self.transpose(***REMOVED******REMOVED***
    swapaxes = _arraymethod('swapaxes'***REMOVED***
    clip = _arraymethod('clip', onmask=False***REMOVED***
    copy = _arraymethod('copy'***REMOVED***
    squeeze = _arraymethod('squeeze'***REMOVED***

    def tolist(self, fill_value=None***REMOVED***:
        ***REMOVED***
        Return the data portion of the masked array as a hierarchical Python list.

        Data items are converted to the nearest compatible Python type.
        Masked values are converted to `fill_value`. If `fill_value` is None,
        the corresponding entries in the output list will be ``None``.

        Parameters
        ----------
        fill_value : scalar, optional
            The value to use for invalid entries. Default is None.

        Returns
        -------
        result : list
            The Python list representation of the masked array.

        Examples
        --------
        >>> x = np.ma.array([[1,2,3***REMOVED***, [4,5,6***REMOVED***, [7,8,9***REMOVED******REMOVED***, mask=[0***REMOVED*** + [1,0***REMOVED****4***REMOVED***
        >>> x.tolist(***REMOVED***
        [[1, None, 3***REMOVED***, [None, 5, None***REMOVED***, [7, None, 9***REMOVED******REMOVED***
        >>> x.tolist(-999***REMOVED***
        [[1, -999, 3***REMOVED***, [-999, 5, -999***REMOVED***, [7, -999, 9***REMOVED******REMOVED***

        ***REMOVED***
        _mask = self._mask
        # No mask ? Just return .data.tolist ?
        if _mask is nomask:
            return self._data.tolist(***REMOVED***
        # Explicit fill_value: fill the array and get the list
        if fill_value is not None:
            return self.filled(fill_value***REMOVED***.tolist(***REMOVED***
        # Structured array.
        names = self.dtype.names
        if names:
            result = self._data.astype([(_, object***REMOVED*** for _ in names***REMOVED******REMOVED***
            for n in names:
                result[n***REMOVED***[_mask[n***REMOVED******REMOVED*** = None
            return result.tolist(***REMOVED***
        # Standard arrays.
        if _mask is nomask:
            return [None***REMOVED***
        # Set temps to save time when dealing w/ marrays.
        inishape = self.shape
        result = np.array(self._data.ravel(***REMOVED***, dtype=object***REMOVED***
        result[_mask.ravel(***REMOVED******REMOVED*** = None
        result.shape = inishape
        return result.tolist(***REMOVED***

    def tostring(self, fill_value=None, order='C'***REMOVED***:
        ***REMOVED***
        This function is a compatibility alias for tobytes. Despite its name it
        returns bytes not strings.
        ***REMOVED***

        return self.tobytes(fill_value, order='C'***REMOVED***

    def tobytes(self, fill_value=None, order='C'***REMOVED***:
        ***REMOVED***
        Return the array data as a string containing the raw bytes in the array.

        The array is filled with a fill value before the string conversion.

        .. versionadded:: 1.9.0

        Parameters
        ----------
        fill_value : scalar, optional
            Value used to fill in the masked values. Deafult is None, in which
            case `MaskedArray.fill_value` is used.
        order : {'C','F','A'***REMOVED***, optional
            Order of the data item in the copy. Default is 'C'.

            - 'C'   -- C order (row major***REMOVED***.
            - 'F'   -- Fortran order (column major***REMOVED***.
            - 'A'   -- Any, current order of array.
            - None  -- Same as 'A'.

        See Also
        --------
        ndarray.tobytes
        tolist, tofile

        Notes
        -----
        As for `ndarray.tobytes`, information about the shape, dtype, etc.,
        but also about `fill_value`, will be lost.

        Examples
        --------
        >>> x = np.ma.array(np.array([[1, 2***REMOVED***, [3, 4***REMOVED******REMOVED******REMOVED***, mask=[[0, 1***REMOVED***, [1, 0***REMOVED******REMOVED******REMOVED***
        >>> x.tobytes(***REMOVED***
        '\\x01\\x00\\x00\\x00?B\\x0f\\x00?B\\x0f\\x00\\x04\\x00\\x00\\x00'

        ***REMOVED***
        return self.filled(fill_value***REMOVED***.tobytes(order=order***REMOVED***

    def tofile(self, fid, sep="", format="%s"***REMOVED***:
        ***REMOVED***
        Save a masked array to a file in binary format.

        .. warning::
          This function is not implemented yet.

        Raises
        ------
        NotImplementedError
            When `tofile` is called.

        ***REMOVED***
        raise NotImplementedError("MaskedArray.tofile(***REMOVED*** not implemented yet."***REMOVED***

    def toflex(self***REMOVED***:
        ***REMOVED***
        Transforms a masked array into a flexible-type array.

        The flexible type array that is returned will have two fields:

        * the ``_data`` field stores the ``_data`` part of the array.
        * the ``_mask`` field stores the ``_mask`` part of the array.

        Parameters
        ----------
        None

        Returns
        -------
        record : ndarray
            A new flexible-type `ndarray` with two fields: the first element
            containing a value, the second element containing the corresponding
            mask boolean. The returned record shape matches self.shape.

        Notes
        -----
        A side-effect of transforming a masked array into a flexible `ndarray` is
        that meta information (``fill_value``, ...***REMOVED*** will be lost.

        Examples
        --------
        >>> x = np.ma.array([[1,2,3***REMOVED***,[4,5,6***REMOVED***,[7,8,9***REMOVED******REMOVED***, mask=[0***REMOVED*** + [1,0***REMOVED****4***REMOVED***
        >>> print(x***REMOVED***
        [[1 -- 3***REMOVED***
         [-- 5 --***REMOVED***
         [7 -- 9***REMOVED******REMOVED***
        >>> print(x.toflex(***REMOVED******REMOVED***
        [[(1, False***REMOVED*** (2, True***REMOVED*** (3, False***REMOVED******REMOVED***
         [(4, True***REMOVED*** (5, False***REMOVED*** (6, True***REMOVED******REMOVED***
         [(7, False***REMOVED*** (8, True***REMOVED*** (9, False***REMOVED******REMOVED******REMOVED***

        ***REMOVED***
        # Get the basic dtype.
        ddtype = self.dtype
        # Make sure we have a mask
        _mask = self._mask
        if _mask is None:
            _mask = make_mask_none(self.shape, ddtype***REMOVED***
        # And get its dtype
        mdtype = self._mask.dtype

        record = np.ndarray(shape=self.shape,
                            dtype=[('_data', ddtype***REMOVED***, ('_mask', mdtype***REMOVED******REMOVED******REMOVED***
        record['_data'***REMOVED*** = self._data
        record['_mask'***REMOVED*** = self._mask
        return record
    torecords = toflex

    # Pickling
    def __getstate__(self***REMOVED***:
        ***REMOVED***Return the internal state of the masked array, for pickling
        purposes.

        ***REMOVED***
        cf = 'CF'[self.flags.fnc***REMOVED***
        state = (1,
                 self.shape,
                 self.dtype,
                 self.flags.fnc,
                 self._data.tobytes(cf***REMOVED***,
                 # self._data.tolist(***REMOVED***,
                 getmaskarray(self***REMOVED***.tobytes(cf***REMOVED***,
                 # getmaskarray(self***REMOVED***.tolist(***REMOVED***,
                 self._fill_value,
                 ***REMOVED***
        return state

    def __setstate__(self, state***REMOVED***:
        ***REMOVED***Restore the internal state of the masked array, for
        pickling purposes.  ``state`` is typically the output of the
        ``__getstate__`` output, and is a 5-tuple:

        - class name
        - a tuple giving the shape of the data
        - a typecode for the data
        - a binary string for the data
        - a binary string for the mask.

        ***REMOVED***
        (_, shp, typ, isf, raw, msk, flv***REMOVED*** = state
        super(MaskedArray, self***REMOVED***.__setstate__((shp, typ, isf, raw***REMOVED******REMOVED***
        self._mask.__setstate__((shp, make_mask_descr(typ***REMOVED***, isf, msk***REMOVED******REMOVED***
        self.fill_value = flv

    def __reduce__(self***REMOVED***:
        ***REMOVED***Return a 3-tuple for pickling a MaskedArray.

        ***REMOVED***
        return (_mareconstruct,
                (self.__class__, self._baseclass, (0,***REMOVED***, 'b',***REMOVED***,
                self.__getstate__(***REMOVED******REMOVED***

    def __deepcopy__(self, memo=None***REMOVED***:
        from copy import deepcopy
        copied = MaskedArray.__new__(type(self***REMOVED***, self, copy=True***REMOVED***
        if memo is None:
            memo = {***REMOVED***
        memo[id(self***REMOVED******REMOVED*** = copied
        for (k, v***REMOVED*** in self.__dict__.items(***REMOVED***:
            copied.__dict__[k***REMOVED*** = deepcopy(v, memo***REMOVED***
        return copied


def _mareconstruct(subtype, baseclass, baseshape, basetype,***REMOVED***:
    ***REMOVED***Internal function that builds a new MaskedArray from the
    information stored in a pickle.

    ***REMOVED***
    _data = ndarray.__new__(baseclass, baseshape, basetype***REMOVED***
    _mask = ndarray.__new__(ndarray, baseshape, make_mask_descr(basetype***REMOVED******REMOVED***
    return subtype.__new__(subtype, _data, mask=_mask, dtype=basetype,***REMOVED***


class mvoid(MaskedArray***REMOVED***:
    ***REMOVED***
    Fake a 'void' object to use for masked array with structured dtypes.
    ***REMOVED***

    def __new__(self, data, mask=nomask, dtype=None, fill_value=None,
                hardmask=False, copy=False, subok=True***REMOVED***:
        _data = np.array(data, copy=copy, subok=subok, dtype=dtype***REMOVED***
        _data = _data.view(self***REMOVED***
        _data._hardmask = hardmask
        if mask is not nomask:
            if isinstance(mask, np.void***REMOVED***:
                _data._mask = mask
            else:
                ***REMOVED***
                    # Mask is already a 0D array
                    _data._mask = np.void(mask***REMOVED***
                except TypeError:
                    # Transform the mask to a void
                    mdtype = make_mask_descr(dtype***REMOVED***
                    _data._mask = np.array(mask, dtype=mdtype***REMOVED***[(***REMOVED******REMOVED***
        if fill_value is not None:
            _data.fill_value = fill_value
        return _data

    def _get_data(self***REMOVED***:
        # Make sure that the _data part is a np.void
        return self.view(ndarray***REMOVED***[(***REMOVED******REMOVED***

    _data = property(fget=_get_data***REMOVED***

    def __getitem__(self, indx***REMOVED***:
        ***REMOVED***
        Get the index.

        ***REMOVED***
        m = self._mask
        if isinstance(m[indx***REMOVED***, ndarray***REMOVED***:
            # Can happen when indx is a multi-dimensional field:
            # A = ma.masked_array(data=[([0,1***REMOVED***,***REMOVED******REMOVED***, mask=[([True,
            #                     False***REMOVED***,***REMOVED******REMOVED***, dtype=[("A", ">i2", (2,***REMOVED******REMOVED******REMOVED******REMOVED***
            # x = A[0***REMOVED***; y = x["A"***REMOVED***; then y.mask["A"***REMOVED***.size==2
            # and we can not say masked/unmasked.
            # The result is no longer mvoid!
            # See also issue #6724.
            return masked_array(
                data=self._data[indx***REMOVED***, mask=m[indx***REMOVED***,
                fill_value=self._fill_value[indx***REMOVED***,
                hard_mask=self._hardmask***REMOVED***
        if m is not nomask and m[indx***REMOVED***:
            return masked
        return self._data[indx***REMOVED***

    def __setitem__(self, indx, value***REMOVED***:
        self._data[indx***REMOVED*** = value
        if self._hardmask:
            self._mask[indx***REMOVED*** |= getattr(value, "_mask", False***REMOVED***
        else:
            self._mask[indx***REMOVED*** = getattr(value, "_mask", False***REMOVED***

    def __str__(self***REMOVED***:
        m = self._mask
        if m is nomask:
            return self._data.__str__(***REMOVED***
        printopt = masked_print_option
        rdtype = _recursive_make_descr(self._data.dtype, "O"***REMOVED***

        # temporary hack to fix gh-7493. A more permanent fix
        # is proposed in gh-6053, after which the next two
        # lines should be changed to
        # res = np.array([self._data***REMOVED***, dtype=rdtype***REMOVED***
        res = np.empty(1, rdtype***REMOVED***
        res[:1***REMOVED*** = self._data

        _recursive_printoption(res, self._mask, printopt***REMOVED***
        return str(res[0***REMOVED******REMOVED***

    __repr__ = __str__

    def __iter__(self***REMOVED***:
        "Defines an iterator for mvoid"
        (_data, _mask***REMOVED*** = (self._data, self._mask***REMOVED***
        if _mask is nomask:
            for d in _data:
                yield d
        else:
            for (d, m***REMOVED*** in zip(_data, _mask***REMOVED***:
                if m:
                    yield masked
                else:
                    yield d

    def __len__(self***REMOVED***:
        return self._data.__len__(***REMOVED***

    def filled(self, fill_value=None***REMOVED***:
        ***REMOVED***
        Return a copy with masked fields filled with a given value.

        Parameters
        ----------
        fill_value : scalar, optional
            The value to use for invalid entries (None by default***REMOVED***.
            If None, the `fill_value` attribute is used instead.

        Returns
        -------
        filled_void
            A `np.void` object

        See Also
        --------
        MaskedArray.filled

        ***REMOVED***
        return asarray(self***REMOVED***.filled(fill_value***REMOVED***[(***REMOVED******REMOVED***

    def tolist(self***REMOVED***:
        ***REMOVED***
    Transforms the mvoid object into a tuple.

    Masked fields are replaced by None.

    Returns
    -------
    returned_tuple
        Tuple of fields
        ***REMOVED***
        _mask = self._mask
        if _mask is nomask:
            return self._data.tolist(***REMOVED***
        result = [***REMOVED***
        for (d, m***REMOVED*** in zip(self._data, self._mask***REMOVED***:
            if m:
                result.append(None***REMOVED***
            else:
                # .item(***REMOVED*** makes sure we return a standard Python object
                result.append(d.item(***REMOVED******REMOVED***
        return tuple(result***REMOVED***


##############################################################################
#                                Shortcuts                                   #
##############################################################################


def isMaskedArray(x***REMOVED***:
    ***REMOVED***
    Test whether input is an instance of MaskedArray.

    This function returns True if `x` is an instance of MaskedArray
    and returns False otherwise.  Any object is accepted as input.

    Parameters
    ----------
    x : object
        Object to test.

    Returns
    -------
    result : bool
        True if `x` is a MaskedArray.

    See Also
    --------
    isMA : Alias to isMaskedArray.
    isarray : Alias to isMaskedArray.

    Examples
    --------
    >>> import numpy.ma as ma
    >>> a = np.eye(3, 3***REMOVED***
    >>> a
    array([[ 1.,  0.,  0.***REMOVED***,
           [ 0.,  1.,  0.***REMOVED***,
           [ 0.,  0.,  1.***REMOVED******REMOVED******REMOVED***
    >>> m = ma.masked_values(a, 0***REMOVED***
    >>> m
    masked_array(data =
     [[1.0 -- --***REMOVED***
     [-- 1.0 --***REMOVED***
     [-- -- 1.0***REMOVED******REMOVED***,
          mask =
     [[False  True  True***REMOVED***
     [ True False  True***REMOVED***
     [ True  True False***REMOVED******REMOVED***,
          fill_value=0.0***REMOVED***
    >>> ma.isMaskedArray(a***REMOVED***
    False
    >>> ma.isMaskedArray(m***REMOVED***
    True
    >>> ma.isMaskedArray([0, 1, 2***REMOVED******REMOVED***
    False

    ***REMOVED***
    return isinstance(x, MaskedArray***REMOVED***


isarray = isMaskedArray
isMA = isMaskedArray  # backward compatibility


class MaskedConstant(MaskedArray***REMOVED***:
    # We define the masked singleton as a float for higher precedence.
    # Note that it can be tricky sometimes w/ type comparison
    _data = data = np.array(0.***REMOVED***
    _mask = mask = np.array(True***REMOVED***
    _baseclass = ndarray

    def __new__(self***REMOVED***:
        return self._data.view(self***REMOVED***

    def __array_finalize__(self, obj***REMOVED***:
        return

    def __array_wrap__(self, obj***REMOVED***:
        return self

    def __str__(self***REMOVED***:
        return str(masked_print_option._display***REMOVED***

    def __repr__(self***REMOVED***:
        return 'masked'

    def flatten(self***REMOVED***:
        return masked_array([self._data***REMOVED***, dtype=float, mask=[True***REMOVED******REMOVED***

    def __reduce__(self***REMOVED***:
        ***REMOVED***Override of MaskedArray's __reduce__.
        ***REMOVED***
        return (self.__class__, (***REMOVED******REMOVED***


masked = masked_singleton = MaskedConstant(***REMOVED***
masked_array = MaskedArray


def array(data, dtype=None, copy=False, order=None,
          mask=nomask, fill_value=None, keep_mask=True,
          hard_mask=False, shrink=True, subok=True, ndmin=0***REMOVED***:
    ***REMOVED***
    Shortcut to MaskedArray.

    The options are in a different order for convenience and backwards
    compatibility.

    ***REMOVED***
    return MaskedArray(data, mask=mask, dtype=dtype, copy=copy,
                       subok=subok, keep_mask=keep_mask,
                       hard_mask=hard_mask, fill_value=fill_value,
                       ndmin=ndmin, shrink=shrink, order=order***REMOVED***
array.__doc__ = masked_array.__doc__


def is_masked(x***REMOVED***:
    ***REMOVED***
    Determine whether input has masked values.

    Accepts any object as input, but always returns False unless the
    input is a MaskedArray containing masked values.

    Parameters
    ----------
    x : array_like
        Array to check for masked values.

    Returns
    -------
    result : bool
        True if `x` is a MaskedArray with masked values, False otherwise.

    Examples
    --------
    >>> import numpy.ma as ma
    >>> x = ma.masked_equal([0, 1, 0, 2, 3***REMOVED***, 0***REMOVED***
    >>> x
    masked_array(data = [-- 1 -- 2 3***REMOVED***,
          mask = [ True False  True False False***REMOVED***,
          fill_value=999999***REMOVED***
    >>> ma.is_masked(x***REMOVED***
    True
    >>> x = ma.masked_equal([0, 1, 0, 2, 3***REMOVED***, 42***REMOVED***
    >>> x
    masked_array(data = [0 1 0 2 3***REMOVED***,
          mask = False,
          fill_value=999999***REMOVED***
    >>> ma.is_masked(x***REMOVED***
    False

    Always returns False if `x` isn't a MaskedArray.

    >>> x = [False, True, False***REMOVED***
    >>> ma.is_masked(x***REMOVED***
    False
    >>> x = 'a string'
    >>> ma.is_masked(x***REMOVED***
    False

    ***REMOVED***
    m = getmask(x***REMOVED***
    if m is nomask:
        return False
    elif m.any(***REMOVED***:
        return True
    return False


##############################################################################
#                             Extrema functions                              #
##############################################################################


class _extrema_operation(object***REMOVED***:
    ***REMOVED***
    Generic class for maximum/minimum functions.

    .. note::
      This is the base class for `_maximum_operation` and
      `_minimum_operation`.

    ***REMOVED***

    def __call__(self, a, b=None***REMOVED***:
        "Executes the call behavior."
        if b is None:
            return self.reduce(a***REMOVED***
        return where(self.compare(a, b***REMOVED***, a, b***REMOVED***

    def reduce(self, target, axis=None***REMOVED***:
        "Reduce target along the given axis."
        target = narray(target, copy=False, subok=True***REMOVED***
        m = getmask(target***REMOVED***
        if axis is not None:
            kargs = {'axis': axis***REMOVED***
        else:
            kargs = {***REMOVED***
            target = target.ravel(***REMOVED***
            if not (m is nomask***REMOVED***:
                m = m.ravel(***REMOVED***
        if m is nomask:
            t = self.ufunc.reduce(target, **kargs***REMOVED***
        else:
            target = target.filled(
                self.fill_value_func(target***REMOVED******REMOVED***.view(type(target***REMOVED******REMOVED***
            t = self.ufunc.reduce(target, **kargs***REMOVED***
            m = umath.logical_and.reduce(m, **kargs***REMOVED***
            if hasattr(t, '_mask'***REMOVED***:
                t._mask = m
            elif m:
                t = masked
        return t

    def outer(self, a, b***REMOVED***:
        "Return the function applied to the outer product of a and b."
        ma = getmask(a***REMOVED***
        mb = getmask(b***REMOVED***
        if ma is nomask and mb is nomask:
            m = nomask
        else:
            ma = getmaskarray(a***REMOVED***
            mb = getmaskarray(b***REMOVED***
            m = logical_or.outer(ma, mb***REMOVED***
        result = self.ufunc.outer(filled(a***REMOVED***, filled(b***REMOVED******REMOVED***
        if not isinstance(result, MaskedArray***REMOVED***:
            result = result.view(MaskedArray***REMOVED***
        result._mask = m
        return result


class _minimum_operation(_extrema_operation***REMOVED***:

    "Object to calculate minima"

    def __init__(self***REMOVED***:
        ***REMOVED***minimum(a, b***REMOVED*** or minimum(a***REMOVED***
In one argument case, returns the scalar minimum.
        ***REMOVED***
        self.ufunc = umath.minimum
        self.afunc = amin
        self.compare = less
        self.fill_value_func = minimum_fill_value


class _maximum_operation(_extrema_operation***REMOVED***:

    "Object to calculate maxima"

    def __init__(self***REMOVED***:
        ***REMOVED***maximum(a, b***REMOVED*** or maximum(a***REMOVED***
           In one argument case returns the scalar maximum.
        ***REMOVED***
        self.ufunc = umath.maximum
        self.afunc = amax
        self.compare = greater
        self.fill_value_func = maximum_fill_value

def min(obj, axis=None, out=None, fill_value=None, keepdims=np._NoValue***REMOVED***:
    kwargs = {***REMOVED*** if keepdims is np._NoValue else {'keepdims': keepdims***REMOVED***

    ***REMOVED***
        return obj.min(axis=axis, fill_value=fill_value, out=out, **kwargs***REMOVED***
    except (AttributeError, TypeError***REMOVED***:
        # If obj doesn't have a min method, or if the method doesn't accept a
        # fill_value argument
        return asanyarray(obj***REMOVED***.min(axis=axis, fill_value=fill_value,
                                   out=out, **kwargs***REMOVED***
min.__doc__ = MaskedArray.min.__doc__

def max(obj, axis=None, out=None, fill_value=None, keepdims=np._NoValue***REMOVED***:
    kwargs = {***REMOVED*** if keepdims is np._NoValue else {'keepdims': keepdims***REMOVED***

    ***REMOVED***
        return obj.max(axis=axis, fill_value=fill_value, out=out, **kwargs***REMOVED***
    except (AttributeError, TypeError***REMOVED***:
        # If obj doesn't have a max method, or if the method doesn't accept a
        # fill_value argument
        return asanyarray(obj***REMOVED***.max(axis=axis, fill_value=fill_value,
                                   out=out, **kwargs***REMOVED***
max.__doc__ = MaskedArray.max.__doc__


def ptp(obj, axis=None, out=None, fill_value=None***REMOVED***:
    ***REMOVED***
    a.ptp(axis=None***REMOVED*** =  a.max(axis***REMOVED*** - a.min(axis***REMOVED***

    ***REMOVED***
    ***REMOVED***
        return obj.ptp(axis, out=out, fill_value=fill_value***REMOVED***
    except (AttributeError, TypeError***REMOVED***:
        # If obj doesn't have a ptp method or if the method doesn't accept
        # a fill_value argument
        return asanyarray(obj***REMOVED***.ptp(axis=axis, fill_value=fill_value, out=out***REMOVED***
ptp.__doc__ = MaskedArray.ptp.__doc__


##############################################################################
#           Definition of functions from the corresponding methods           #
##############################################################################


class _frommethod:
    ***REMOVED***
    Define functions from existing MaskedArray methods.

    Parameters
    ----------
    methodname : str
        Name of the method to transform.

    ***REMOVED***

    def __init__(self, methodname, reversed=False***REMOVED***:
        self.__name__ = methodname
        self.__doc__ = self.getdoc(***REMOVED***
        self.reversed = reversed

    def getdoc(self***REMOVED***:
        "Return the doc of the function (from the doc of the method***REMOVED***."
        meth = getattr(MaskedArray, self.__name__, None***REMOVED*** or\
            getattr(np, self.__name__, None***REMOVED***
        signature = self.__name__ + get_object_signature(meth***REMOVED***
        if meth is not None:
            doc = ***REMOVED***    %s\n%s***REMOVED*** % (
                signature, getattr(meth, '__doc__', None***REMOVED******REMOVED***
            return doc

    def __call__(self, a, *args, **params***REMOVED***:
        if self.reversed:
            args = list(args***REMOVED***
            arr = args[0***REMOVED***
            args[0***REMOVED*** = a
            a = arr
        # Get the method from the array (if possible***REMOVED***
        method_name = self.__name__
        method = getattr(a, method_name, None***REMOVED***
        if method is not None:
            return method(*args, **params***REMOVED***
        # Still here ? Then a is not a MaskedArray
        method = getattr(MaskedArray, method_name, None***REMOVED***
        if method is not None:
            return method(MaskedArray(a***REMOVED***, *args, **params***REMOVED***
        # Still here ? OK, let's call the corresponding np function
        method = getattr(np, method_name***REMOVED***
        return method(a, *args, **params***REMOVED***


all = _frommethod('all'***REMOVED***
anomalies = anom = _frommethod('anom'***REMOVED***
any = _frommethod('any'***REMOVED***
compress = _frommethod('compress', reversed=True***REMOVED***
cumprod = _frommethod('cumprod'***REMOVED***
cumsum = _frommethod('cumsum'***REMOVED***
copy = _frommethod('copy'***REMOVED***
diagonal = _frommethod('diagonal'***REMOVED***
harden_mask = _frommethod('harden_mask'***REMOVED***
ids = _frommethod('ids'***REMOVED***
maximum = _maximum_operation(***REMOVED***
mean = _frommethod('mean'***REMOVED***
minimum = _minimum_operation(***REMOVED***
nonzero = _frommethod('nonzero'***REMOVED***
prod = _frommethod('prod'***REMOVED***
product = _frommethod('prod'***REMOVED***
ravel = _frommethod('ravel'***REMOVED***
repeat = _frommethod('repeat'***REMOVED***
shrink_mask = _frommethod('shrink_mask'***REMOVED***
soften_mask = _frommethod('soften_mask'***REMOVED***
std = _frommethod('std'***REMOVED***
sum = _frommethod('sum'***REMOVED***
swapaxes = _frommethod('swapaxes'***REMOVED***
#take = _frommethod('take'***REMOVED***
trace = _frommethod('trace'***REMOVED***
var = _frommethod('var'***REMOVED***

count = _frommethod('count'***REMOVED***

def take(a, indices, axis=None, out=None, mode='raise'***REMOVED***:
    ***REMOVED***
    ***REMOVED***
    a = masked_array(a***REMOVED***
    return a.take(indices, axis=axis, out=out, mode=mode***REMOVED***


def power(a, b, third=None***REMOVED***:
    ***REMOVED***
    Returns element-wise base array raised to power from second array.

    This is the masked array version of `numpy.power`. For details see
    `numpy.power`.

    See Also
    --------
    numpy.power

    Notes
    -----
    The *out* argument to `numpy.power` is not supported, `third` has to be
    None.

    ***REMOVED***
    if third is not None:
        raise MaskError("3-argument power not supported."***REMOVED***
    # Get the masks
    ma = getmask(a***REMOVED***
    mb = getmask(b***REMOVED***
    m = mask_or(ma, mb***REMOVED***
    # Get the rawdata
    fa = getdata(a***REMOVED***
    fb = getdata(b***REMOVED***
    # Get the type of the result (so that we preserve subclasses***REMOVED***
    if isinstance(a, MaskedArray***REMOVED***:
        basetype = type(a***REMOVED***
    else:
        basetype = MaskedArray
    # Get the result and view it as a (subclass of***REMOVED*** MaskedArray
    with np.errstate(divide='ignore', invalid='ignore'***REMOVED***:
        result = np.where(m, fa, umath.power(fa, fb***REMOVED******REMOVED***.view(basetype***REMOVED***
    result._update_from(a***REMOVED***
    # Find where we're in trouble w/ NaNs and Infs
    invalid = np.logical_not(np.isfinite(result.view(ndarray***REMOVED******REMOVED******REMOVED***
    # Add the initial mask
    if m is not nomask:
        if not (result.ndim***REMOVED***:
            return masked
        result._mask = np.logical_or(m, invalid***REMOVED***
    # Fix the invalid parts
    if invalid.any(***REMOVED***:
        if not result.ndim:
            return masked
        elif result._mask is nomask:
            result._mask = invalid
        result._data[invalid***REMOVED*** = result.fill_value
    return result


def argsort(a, axis=None, kind='quicksort', order=None, fill_value=None***REMOVED***:
    "Function version of the eponymous method."
    if fill_value is None:
        fill_value = default_fill_value(a***REMOVED***
    d = filled(a, fill_value***REMOVED***
    if axis is None:
        return d.argsort(kind=kind, order=order***REMOVED***
    return d.argsort(axis, kind=kind, order=order***REMOVED***
argsort.__doc__ = MaskedArray.argsort.__doc__

argmin = _frommethod('argmin'***REMOVED***
argmax = _frommethod('argmax'***REMOVED***


def sort(a, axis=-1, kind='quicksort', order=None, endwith=True, fill_value=None***REMOVED***:
    "Function version of the eponymous method."
    a = narray(a, copy=True, subok=True***REMOVED***
    if axis is None:
        a = a.flatten(***REMOVED***
        axis = 0
    if fill_value is None:
        if endwith:
            # nan > inf
            if np.issubdtype(a.dtype, np.floating***REMOVED***:
                filler = np.nan
            else:
                filler = minimum_fill_value(a***REMOVED***
        else:
            filler = maximum_fill_value(a***REMOVED***
    else:
        filler = fill_value

    sindx = filled(a, filler***REMOVED***.argsort(axis=axis, kind=kind, order=order***REMOVED***

    # save meshgrid memory for 1d arrays
    if a.ndim == 1:
        indx = sindx
    else:
        indx = np.meshgrid(*[np.arange(x***REMOVED*** for x in a.shape***REMOVED***, sparse=True,
                           indexing='ij'***REMOVED***
        indx[axis***REMOVED*** = sindx
    return a[indx***REMOVED***
sort.__doc__ = MaskedArray.sort.__doc__


def compressed(x***REMOVED***:
    ***REMOVED***
    Return all the non-masked data as a 1-D array.

    This function is equivalent to calling the "compressed" method of a
    `MaskedArray`, see `MaskedArray.compressed` for details.

    See Also
    --------
    MaskedArray.compressed
        Equivalent method.

    ***REMOVED***
    if not isinstance(x, MaskedArray***REMOVED***:
        x = asanyarray(x***REMOVED***
    return x.compressed(***REMOVED***


def concatenate(arrays, axis=0***REMOVED***:
    ***REMOVED***
    Concatenate a sequence of arrays along the given axis.

    Parameters
    ----------
    arrays : sequence of array_like
        The arrays must have the same shape, except in the dimension
        corresponding to `axis` (the first, by default***REMOVED***.
    axis : int, optional
        The axis along which the arrays will be joined. Default is 0.

    Returns
    -------
    result : MaskedArray
        The concatenated array with any masked entries preserved.

    See Also
    --------
    numpy.concatenate : Equivalent function in the top-level NumPy module.

    Examples
    --------
    >>> import numpy.ma as ma
    >>> a = ma.arange(3***REMOVED***
    >>> a[1***REMOVED*** = ma.masked
    >>> b = ma.arange(2, 5***REMOVED***
    >>> a
    masked_array(data = [0 -- 2***REMOVED***,
                 mask = [False  True False***REMOVED***,
           fill_value = 999999***REMOVED***
    >>> b
    masked_array(data = [2 3 4***REMOVED***,
                 mask = False,
           fill_value = 999999***REMOVED***
    >>> ma.concatenate([a, b***REMOVED******REMOVED***
    masked_array(data = [0 -- 2 2 3 4***REMOVED***,
                 mask = [False  True False False False False***REMOVED***,
           fill_value = 999999***REMOVED***

    ***REMOVED***
    d = np.concatenate([getdata(a***REMOVED*** for a in arrays***REMOVED***, axis***REMOVED***
    rcls = get_masked_subclass(*arrays***REMOVED***
    data = d.view(rcls***REMOVED***
    # Check whether one of the arrays has a non-empty mask.
    for x in arrays:
        if getmask(x***REMOVED*** is not nomask:
            break
    else:
        return data
    # OK, so we have to concatenate the masks
    dm = np.concatenate([getmaskarray(a***REMOVED*** for a in arrays***REMOVED***, axis***REMOVED***
    # If we decide to keep a '_shrinkmask' option, we want to check that
    # all of them are True, and then check for dm.any(***REMOVED***
    if not dm.dtype.fields and not dm.any(***REMOVED***:
        data._mask = nomask
    else:
        data._mask = dm.reshape(d.shape***REMOVED***
    return data


def diag(v, k=0***REMOVED***:
    ***REMOVED***
    Extract a diagonal or construct a diagonal array.

    This function is the equivalent of `numpy.diag` that takes masked
    values into account, see `numpy.diag` for details.

    See Also
    --------
    numpy.diag : Equivalent function for ndarrays.

    ***REMOVED***
    output = np.diag(v, k***REMOVED***.view(MaskedArray***REMOVED***
    if getmask(v***REMOVED*** is not nomask:
        output._mask = np.diag(v._mask, k***REMOVED***
    return output


def expand_dims(x, axis***REMOVED***:
    ***REMOVED***
    Expand the shape of an array.

    Expands the shape of the array by including a new axis before the one
    specified by the `axis` parameter. This function behaves the same as
    `numpy.expand_dims` but preserves masked elements.

    See Also
    --------
    numpy.expand_dims : Equivalent function in top-level NumPy module.

    Examples
    --------
    >>> import numpy.ma as ma
    >>> x = ma.array([1, 2, 4***REMOVED******REMOVED***
    >>> x[1***REMOVED*** = ma.masked
    >>> x
    masked_array(data = [1 -- 4***REMOVED***,
                 mask = [False  True False***REMOVED***,
           fill_value = 999999***REMOVED***
    >>> np.expand_dims(x, axis=0***REMOVED***
    array([[1, 2, 4***REMOVED******REMOVED******REMOVED***
    >>> ma.expand_dims(x, axis=0***REMOVED***
    masked_array(data =
     [[1 -- 4***REMOVED******REMOVED***,
                 mask =
     [[False  True False***REMOVED******REMOVED***,
           fill_value = 999999***REMOVED***

    The same result can be achieved using slicing syntax with `np.newaxis`.

    >>> x[np.newaxis, :***REMOVED***
    masked_array(data =
     [[1 -- 4***REMOVED******REMOVED***,
                 mask =
     [[False  True False***REMOVED******REMOVED***,
           fill_value = 999999***REMOVED***

    ***REMOVED***
    result = n_expand_dims(x, axis***REMOVED***
    if isinstance(x, MaskedArray***REMOVED***:
        new_shape = result.shape
        result = x.view(***REMOVED***
        result.shape = new_shape
        if result._mask is not nomask:
            result._mask.shape = new_shape
    return result


def left_shift(a, n***REMOVED***:
    ***REMOVED***
    Shift the bits of an integer to the left.

    This is the masked array version of `numpy.left_shift`, for details
    see that function.

    See Also
    --------
    numpy.left_shift

    ***REMOVED***
    m = getmask(a***REMOVED***
    if m is nomask:
        d = umath.left_shift(filled(a***REMOVED***, n***REMOVED***
        return masked_array(d***REMOVED***
    else:
        d = umath.left_shift(filled(a, 0***REMOVED***, n***REMOVED***
        return masked_array(d, mask=m***REMOVED***


def right_shift(a, n***REMOVED***:
    ***REMOVED***
    Shift the bits of an integer to the right.

    This is the masked array version of `numpy.right_shift`, for details
    see that function.

    See Also
    --------
    numpy.right_shift

    ***REMOVED***
    m = getmask(a***REMOVED***
    if m is nomask:
        d = umath.right_shift(filled(a***REMOVED***, n***REMOVED***
        return masked_array(d***REMOVED***
    else:
        d = umath.right_shift(filled(a, 0***REMOVED***, n***REMOVED***
        return masked_array(d, mask=m***REMOVED***


def put(a, indices, values, mode='raise'***REMOVED***:
    ***REMOVED***
    Set storage-indexed locations to corresponding values.

    This function is equivalent to `MaskedArray.put`, see that method
    for details.

    See Also
    --------
    MaskedArray.put

    ***REMOVED***
    # We can't use 'frommethod', the order of arguments is different
    ***REMOVED***
        return a.put(indices, values, mode=mode***REMOVED***
    except AttributeError:
        return narray(a, copy=False***REMOVED***.put(indices, values, mode=mode***REMOVED***


def putmask(a, mask, values***REMOVED***:  # , mode='raise'***REMOVED***:
    ***REMOVED***
    Changes elements of an array based on conditional and input values.

    This is the masked array version of `numpy.putmask`, for details see
    `numpy.putmask`.

    See Also
    --------
    numpy.putmask

    Notes
    -----
    Using a masked array as `values` will **not** transform a `ndarray` into
    a `MaskedArray`.

    ***REMOVED***
    # We can't use 'frommethod', the order of arguments is different
    if not isinstance(a, MaskedArray***REMOVED***:
        a = a.view(MaskedArray***REMOVED***
    (valdata, valmask***REMOVED*** = (getdata(values***REMOVED***, getmask(values***REMOVED******REMOVED***
    if getmask(a***REMOVED*** is nomask:
        if valmask is not nomask:
            a._sharedmask = True
            a._mask = make_mask_none(a.shape, a.dtype***REMOVED***
            np.copyto(a._mask, valmask, where=mask***REMOVED***
    elif a._hardmask:
        if valmask is not nomask:
            m = a._mask.copy(***REMOVED***
            np.copyto(m, valmask, where=mask***REMOVED***
            a.mask |= m
    else:
        if valmask is nomask:
            valmask = getmaskarray(values***REMOVED***
        np.copyto(a._mask, valmask, where=mask***REMOVED***
    np.copyto(a._data, valdata, where=mask***REMOVED***
    return


def transpose(a, axes=None***REMOVED***:
    ***REMOVED***
    Permute the dimensions of an array.

    This function is exactly equivalent to `numpy.transpose`.

    See Also
    --------
    numpy.transpose : Equivalent function in top-level NumPy module.

    Examples
    --------
    >>> import numpy.ma as ma
    >>> x = ma.arange(4***REMOVED***.reshape((2,2***REMOVED******REMOVED***
    >>> x[1, 1***REMOVED*** = ma.masked
    >>>> x
    masked_array(data =
     [[0 1***REMOVED***
     [2 --***REMOVED******REMOVED***,
                 mask =
     [[False False***REMOVED***
     [False  True***REMOVED******REMOVED***,
           fill_value = 999999***REMOVED***
    >>> ma.transpose(x***REMOVED***
    masked_array(data =
     [[0 2***REMOVED***
     [1 --***REMOVED******REMOVED***,
                 mask =
     [[False False***REMOVED***
     [False  True***REMOVED******REMOVED***,
           fill_value = 999999***REMOVED***

    ***REMOVED***
    # We can't use 'frommethod', as 'transpose' doesn't take keywords
    ***REMOVED***
        return a.transpose(axes***REMOVED***
    except AttributeError:
        return narray(a, copy=False***REMOVED***.transpose(axes***REMOVED***.view(MaskedArray***REMOVED***


def reshape(a, new_shape, order='C'***REMOVED***:
    ***REMOVED***
    Returns an array containing the same data with a new shape.

    Refer to `MaskedArray.reshape` for full documentation.

    See Also
    --------
    MaskedArray.reshape : equivalent function

    ***REMOVED***
    # We can't use 'frommethod', it whine about some parameters. Dmmit.
    ***REMOVED***
        return a.reshape(new_shape, order=order***REMOVED***
    except AttributeError:
        _tmp = narray(a, copy=False***REMOVED***.reshape(new_shape, order=order***REMOVED***
        return _tmp.view(MaskedArray***REMOVED***


def resize(x, new_shape***REMOVED***:
    ***REMOVED***
    Return a new masked array with the specified size and shape.

    This is the masked equivalent of the `numpy.resize` function. The new
    array is filled with repeated copies of `x` (in the order that the
    data are stored in memory***REMOVED***. If `x` is masked, the new array will be
    masked, and the new mask will be a repetition of the old one.

    See Also
    --------
    numpy.resize : Equivalent function in the top level NumPy module.

    Examples
    --------
    >>> import numpy.ma as ma
    >>> a = ma.array([[1, 2***REMOVED*** ,[3, 4***REMOVED******REMOVED******REMOVED***
    >>> a[0, 1***REMOVED*** = ma.masked
    >>> a
    masked_array(data =
     [[1 --***REMOVED***
     [3 4***REMOVED******REMOVED***,
                 mask =
     [[False  True***REMOVED***
     [False False***REMOVED******REMOVED***,
           fill_value = 999999***REMOVED***
    >>> np.resize(a, (3, 3***REMOVED******REMOVED***
    array([[1, 2, 3***REMOVED***,
           [4, 1, 2***REMOVED***,
           [3, 4, 1***REMOVED******REMOVED******REMOVED***
    >>> ma.resize(a, (3, 3***REMOVED******REMOVED***
    masked_array(data =
     [[1 -- 3***REMOVED***
     [4 1 --***REMOVED***
     [3 4 1***REMOVED******REMOVED***,
                 mask =
     [[False  True False***REMOVED***
     [False False  True***REMOVED***
     [False False False***REMOVED******REMOVED***,
           fill_value = 999999***REMOVED***

    A MaskedArray is always returned, regardless of the input type.

    >>> a = np.array([[1, 2***REMOVED*** ,[3, 4***REMOVED******REMOVED******REMOVED***
    >>> ma.resize(a, (3, 3***REMOVED******REMOVED***
    masked_array(data =
     [[1 2 3***REMOVED***
     [4 1 2***REMOVED***
     [3 4 1***REMOVED******REMOVED***,
                 mask =
     False,
           fill_value = 999999***REMOVED***

    ***REMOVED***
    # We can't use _frommethods here, as N.resize is notoriously whiny.
    m = getmask(x***REMOVED***
    if m is not nomask:
        m = np.resize(m, new_shape***REMOVED***
    result = np.resize(x, new_shape***REMOVED***.view(get_masked_subclass(x***REMOVED******REMOVED***
    if result.ndim:
        result._mask = m
    return result


def rank(obj***REMOVED***:
    ***REMOVED***
    maskedarray version of the numpy function.

    .. note::
        Deprecated since 1.10.0

    ***REMOVED***
    # 2015-04-12, 1.10.0
    warnings.warn(
        "`rank` is deprecated; use the `ndim` function instead. ",
        np.VisibleDeprecationWarning***REMOVED***
    return np.ndim(getdata(obj***REMOVED******REMOVED***

rank.__doc__ = np.rank.__doc__


def ndim(obj***REMOVED***:
    ***REMOVED***
    maskedarray version of the numpy function.

    ***REMOVED***
    return np.ndim(getdata(obj***REMOVED******REMOVED***

ndim.__doc__ = np.ndim.__doc__


def shape(obj***REMOVED***:
    "maskedarray version of the numpy function."
    return np.shape(getdata(obj***REMOVED******REMOVED***
shape.__doc__ = np.shape.__doc__


def size(obj, axis=None***REMOVED***:
    "maskedarray version of the numpy function."
    return np.size(getdata(obj***REMOVED***, axis***REMOVED***
size.__doc__ = np.size.__doc__


##############################################################################
#                            Extra functions                                 #
##############################################################################


def where(condition, x=_NoValue, y=_NoValue***REMOVED***:
    ***REMOVED***
    Return a masked array with elements from x or y, depending on condition.

    Returns a masked array, shaped like condition, where the elements
    are from `x` when `condition` is True, and from `y` otherwise.
    If neither `x` nor `y` are given, the function returns a tuple of
    indices where `condition` is True (the result of
    ``condition.nonzero(***REMOVED***``***REMOVED***.

    Parameters
    ----------
    condition : array_like, bool
        The condition to meet. For each True element, yield the corresponding
        element from `x`, otherwise from `y`.
    x, y : array_like, optional
        Values from which to choose. `x` and `y` need to have the same shape
        as condition, or be broadcast-able to that shape.

    Returns
    -------
    out : MaskedArray or tuple of ndarrays
        The resulting masked array if `x` and `y` were given, otherwise
        the result of ``condition.nonzero(***REMOVED***``.

    See Also
    --------
    numpy.where : Equivalent function in the top-level NumPy module.

    Examples
    --------
    >>> x = np.ma.array(np.arange(9.***REMOVED***.reshape(3, 3***REMOVED***, mask=[[0, 1, 0***REMOVED***,
    ...                                                    [1, 0, 1***REMOVED***,
    ...                                                    [0, 1, 0***REMOVED******REMOVED******REMOVED***
    >>> print(x***REMOVED***
    [[0.0 -- 2.0***REMOVED***
     [-- 4.0 --***REMOVED***
     [6.0 -- 8.0***REMOVED******REMOVED***
    >>> np.ma.where(x > 5***REMOVED***    # return the indices where x > 5
    (array([2, 2***REMOVED******REMOVED***, array([0, 2***REMOVED******REMOVED******REMOVED***

    >>> print(np.ma.where(x > 5, x, -3.1416***REMOVED******REMOVED***
    [[-3.1416 -- -3.1416***REMOVED***
     [-- -3.1416 --***REMOVED***
     [6.0 -- 8.0***REMOVED******REMOVED***

    ***REMOVED***
    missing = (x is _NoValue, y is _NoValue***REMOVED***.count(True***REMOVED***

    if missing == 1:
        raise ValueError("Must provide both 'x' and 'y' or neither."***REMOVED***
    if missing == 2:
        return filled(condition, 0***REMOVED***.nonzero(***REMOVED***

    # Both x and y are provided

    # Get the condition
    fc = filled(condition, 0***REMOVED***.astype(MaskType***REMOVED***
    notfc = np.logical_not(fc***REMOVED***

    # Get the data
    xv = getdata(x***REMOVED***
    yv = getdata(y***REMOVED***
    if x is masked:
        ndtype = yv.dtype
    elif y is masked:
        ndtype = xv.dtype
    else:
        ndtype = np.find_common_type([xv.dtype, yv.dtype***REMOVED***, [***REMOVED******REMOVED***

    # Construct an empty array and fill it
    d = np.empty(fc.shape, dtype=ndtype***REMOVED***.view(MaskedArray***REMOVED***
    np.copyto(d._data, xv.astype(ndtype***REMOVED***, where=fc***REMOVED***
    np.copyto(d._data, yv.astype(ndtype***REMOVED***, where=notfc***REMOVED***

    # Create an empty mask and fill it
    mask = np.zeros(fc.shape, dtype=MaskType***REMOVED***
    np.copyto(mask, getmask(x***REMOVED***, where=fc***REMOVED***
    np.copyto(mask, getmask(y***REMOVED***, where=notfc***REMOVED***
    mask |= getmaskarray(condition***REMOVED***

    # Use d._mask instead of d.mask to avoid copies
    d._mask = mask if mask.any(***REMOVED*** else nomask

    return d


def choose(indices, choices, out=None, mode='raise'***REMOVED***:
    ***REMOVED***
    Use an index array to construct a new array from a set of choices.

    Given an array of integers and a set of n choice arrays, this method
    will create a new array that merges each of the choice arrays.  Where a
    value in `a` is i, the new array will have the value that choices[i***REMOVED***
    contains in the same place.

    Parameters
    ----------
    a : ndarray of ints
        This array must contain integers in ``[0, n-1***REMOVED***``, where n is the
        number of choices.
    choices : sequence of arrays
        Choice arrays. The index array and all of the choices should be
        broadcastable to the same shape.
    out : array, optional
        If provided, the result will be inserted into this array. It should
        be of the appropriate shape and `dtype`.
    mode : {'raise', 'wrap', 'clip'***REMOVED***, optional
        Specifies how out-of-bounds indices will behave.

        * 'raise' : raise an error
        * 'wrap' : wrap around
        * 'clip' : clip to the range

    Returns
    -------
    merged_array : array

    See Also
    --------
    choose : equivalent function

    Examples
    --------
    >>> choice = np.array([[1,1,1***REMOVED***, [2,2,2***REMOVED***, [3,3,3***REMOVED******REMOVED******REMOVED***
    >>> a = np.array([2, 1, 0***REMOVED******REMOVED***
    >>> np.ma.choose(a, choice***REMOVED***
    masked_array(data = [3 2 1***REMOVED***,
          mask = False,
          fill_value=999999***REMOVED***

    ***REMOVED***
    def fmask(x***REMOVED***:
        "Returns the filled array, or True if masked."
        if x is masked:
            return True
        return filled(x***REMOVED***

    def nmask(x***REMOVED***:
        "Returns the mask, True if ``masked``, False if ``nomask``."
        if x is masked:
            return True
        return getmask(x***REMOVED***
    # Get the indices.
    c = filled(indices, 0***REMOVED***
    # Get the masks.
    masks = [nmask(x***REMOVED*** for x in choices***REMOVED***
    data = [fmask(x***REMOVED*** for x in choices***REMOVED***
    # Construct the mask
    outputmask = np.choose(c, masks, mode=mode***REMOVED***
    outputmask = make_mask(mask_or(outputmask, getmask(indices***REMOVED******REMOVED***,
                           copy=0, shrink=True***REMOVED***
    # Get the choices.
    d = np.choose(c, data, mode=mode, out=out***REMOVED***.view(MaskedArray***REMOVED***
    if out is not None:
        if isinstance(out, MaskedArray***REMOVED***:
            out.__setmask__(outputmask***REMOVED***
        return out
    d.__setmask__(outputmask***REMOVED***
    return d


def round_(a, decimals=0, out=None***REMOVED***:
    ***REMOVED***
    Return a copy of a, rounded to 'decimals' places.

    When 'decimals' is negative, it specifies the number of positions
    to the left of the decimal point.  The real and imaginary parts of
    complex numbers are rounded separately. Nothing is done if the
    array is not of float type and 'decimals' is greater than or equal
    to 0.

    Parameters
    ----------
    decimals : int
        Number of decimals to round to. May be negative.
    out : array_like
        Existing array to use for output.
        If not given, returns a default copy of a.

    Notes
    -----
    If out is given and does not have a mask attribute, the mask of a
    is lost!

    ***REMOVED***
    if out is None:
        return np.round_(a, decimals, out***REMOVED***
    else:
        np.round_(getdata(a***REMOVED***, decimals, out***REMOVED***
        if hasattr(out, '_mask'***REMOVED***:
            out._mask = getmask(a***REMOVED***
        return out
round = round_


# Needed by dot, so move here from extras.py. It will still be exported
# from extras.py for compatibility.
def mask_rowcols(a, axis=None***REMOVED***:
    ***REMOVED***
    Mask rows and/or columns of a 2D array that contain masked values.

    Mask whole rows and/or columns of a 2D array that contain
    masked values.  The masking behavior is selected using the
    `axis` parameter.

      - If `axis` is None, rows *and* columns are masked.
      - If `axis` is 0, only rows are masked.
      - If `axis` is 1 or -1, only columns are masked.

    Parameters
    ----------
    a : array_like, MaskedArray
        The array to mask.  If not a MaskedArray instance (or if no array
        elements are masked***REMOVED***.  The result is a MaskedArray with `mask` set
        to `nomask` (False***REMOVED***. Must be a 2D array.
    axis : int, optional
        Axis along which to perform the operation. If None, applies to a
        flattened version of the array.

    Returns
    -------
    a : MaskedArray
        A modified version of the input array, masked depending on the value
        of the `axis` parameter.

    Raises
    ------
    NotImplementedError
        If input array `a` is not 2D.

    See Also
    --------
    mask_rows : Mask rows of a 2D array that contain masked values.
    mask_cols : Mask cols of a 2D array that contain masked values.
    masked_where : Mask where a condition is met.

    Notes
    -----
    The input array's mask is modified by this function.

    Examples
    --------
    >>> import numpy.ma as ma
    >>> a = np.zeros((3, 3***REMOVED***, dtype=np.int***REMOVED***
    >>> a[1, 1***REMOVED*** = 1
    >>> a
    array([[0, 0, 0***REMOVED***,
           [0, 1, 0***REMOVED***,
           [0, 0, 0***REMOVED******REMOVED******REMOVED***
    >>> a = ma.masked_equal(a, 1***REMOVED***
    >>> a
    masked_array(data =
     [[0 0 0***REMOVED***
     [0 -- 0***REMOVED***
     [0 0 0***REMOVED******REMOVED***,
          mask =
     [[False False False***REMOVED***
     [False  True False***REMOVED***
     [False False False***REMOVED******REMOVED***,
          fill_value=999999***REMOVED***
    >>> ma.mask_rowcols(a***REMOVED***
    masked_array(data =
     [[0 -- 0***REMOVED***
     [-- -- --***REMOVED***
     [0 -- 0***REMOVED******REMOVED***,
          mask =
     [[False  True False***REMOVED***
     [ True  True  True***REMOVED***
     [False  True False***REMOVED******REMOVED***,
          fill_value=999999***REMOVED***

    ***REMOVED***
    a = array(a, subok=False***REMOVED***
    if a.ndim != 2:
        raise NotImplementedError("mask_rowcols works for 2D arrays only."***REMOVED***
    m = getmask(a***REMOVED***
    # Nothing is masked: return a
    if m is nomask or not m.any(***REMOVED***:
        return a
    maskedval = m.nonzero(***REMOVED***
    a._mask = a._mask.copy(***REMOVED***
    if not axis:
        a[np.unique(maskedval[0***REMOVED******REMOVED******REMOVED*** = masked
    if axis in [None, 1, -1***REMOVED***:
        a[:, np.unique(maskedval[1***REMOVED******REMOVED******REMOVED*** = masked
    return a


# Include masked dot here to avoid import problems in getting it from
# extras.py. Note that it is not included in __all__, but rather exported
# from extras in order to avoid backward compatibility problems.
def dot(a, b, strict=False, out=None***REMOVED***:
    ***REMOVED***
    Return the dot product of two arrays.

    This function is the equivalent of `numpy.dot` that takes masked values
    into account. Note that `strict` and `out` are in different position
    than in the method version. In order to maintain compatibility with the
    corresponding method, it is recommended that the optional arguments be
    treated as keyword only.  At some point that may be mandatory.

    .. note::
      Works only with 2-D arrays at the moment.


    Parameters
    ----------
    a, b : masked_array_like
        Inputs arrays.
    strict : bool, optional
        Whether masked data are propagated (True***REMOVED*** or set to 0 (False***REMOVED*** for
        the computation. Default is False.  Propagating the mask means that
        if a masked value appears in a row or column, the whole row or
        column is considered masked.
    out : masked_array, optional
        Output argument. This must have the exact kind that would be returned
        if it was not used. In particular, it must have the right type, must be
        C-contiguous, and its dtype must be the dtype that would be returned
        for `dot(a,b***REMOVED***`. This is a performance feature. Therefore, if these
        conditions are not met, an exception is raised, instead of attempting
        to be flexible.

        .. versionadded:: 1.10.2

    See Also
    --------
    numpy.dot : Equivalent function for ndarrays.

    Examples
    --------
    >>> a = ma.array([[1, 2, 3***REMOVED***, [4, 5, 6***REMOVED******REMOVED***, mask=[[1, 0, 0***REMOVED***, [0, 0, 0***REMOVED******REMOVED******REMOVED***
    >>> b = ma.array([[1, 2***REMOVED***, [3, 4***REMOVED***, [5, 6***REMOVED******REMOVED***, mask=[[1, 0***REMOVED***, [0, 0***REMOVED***, [0, 0***REMOVED******REMOVED******REMOVED***
    >>> np.ma.dot(a, b***REMOVED***
    masked_array(data =
     [[21 26***REMOVED***
     [45 64***REMOVED******REMOVED***,
                 mask =
     [[False False***REMOVED***
     [False False***REMOVED******REMOVED***,
           fill_value = 999999***REMOVED***
    >>> np.ma.dot(a, b, strict=True***REMOVED***
    masked_array(data =
     [[-- --***REMOVED***
     [-- 64***REMOVED******REMOVED***,
                 mask =
     [[ True  True***REMOVED***
     [ True False***REMOVED******REMOVED***,
           fill_value = 999999***REMOVED***

    ***REMOVED***
    # !!!: Works only with 2D arrays. There should be a way to get it to run
    # with higher dimension
    if strict and (a.ndim == 2***REMOVED*** and (b.ndim == 2***REMOVED***:
        a = mask_rowcols(a, 0***REMOVED***
        b = mask_rowcols(b, 1***REMOVED***
    am = ~getmaskarray(a***REMOVED***
    bm = ~getmaskarray(b***REMOVED***

    if out is None:
        d = np.dot(filled(a, 0***REMOVED***, filled(b, 0***REMOVED******REMOVED***
        m = ~np.dot(am, bm***REMOVED***
        if d.ndim == 0:
            d = np.asarray(d***REMOVED***
        r = d.view(get_masked_subclass(a, b***REMOVED******REMOVED***
        r.__setmask__(m***REMOVED***
        return r
    else:
        d = np.dot(filled(a, 0***REMOVED***, filled(b, 0***REMOVED***, out._data***REMOVED***
        if out.mask.shape != d.shape:
            out._mask = np.empty(d.shape, MaskType***REMOVED***
        np.dot(am, bm, out._mask***REMOVED***
        np.logical_not(out._mask, out._mask***REMOVED***
        return out


def inner(a, b***REMOVED***:
    ***REMOVED***
    Returns the inner product of a and b for arrays of floating point types.

    Like the generic NumPy equivalent the product sum is over the last dimension
    of a and b.

    Notes
    -----
    The first argument is not conjugated.

    ***REMOVED***
    fa = filled(a, 0***REMOVED***
    fb = filled(b, 0***REMOVED***
    if len(fa.shape***REMOVED*** == 0:
        fa.shape = (1,***REMOVED***
    if len(fb.shape***REMOVED*** == 0:
        fb.shape = (1,***REMOVED***
    return np.inner(fa, fb***REMOVED***.view(MaskedArray***REMOVED***
inner.__doc__ = doc_note(np.inner.__doc__,
                         "Masked values are replaced by 0."***REMOVED***
innerproduct = inner


def outer(a, b***REMOVED***:
    "maskedarray version of the numpy function."
    fa = filled(a, 0***REMOVED***.ravel(***REMOVED***
    fb = filled(b, 0***REMOVED***.ravel(***REMOVED***
    d = np.outer(fa, fb***REMOVED***
    ma = getmask(a***REMOVED***
    mb = getmask(b***REMOVED***
    if ma is nomask and mb is nomask:
        return masked_array(d***REMOVED***
    ma = getmaskarray(a***REMOVED***
    mb = getmaskarray(b***REMOVED***
    m = make_mask(1 - np.outer(1 - ma, 1 - mb***REMOVED***, copy=0***REMOVED***
    return masked_array(d, mask=m***REMOVED***
outer.__doc__ = doc_note(np.outer.__doc__,
                         "Masked values are replaced by 0."***REMOVED***
outerproduct = outer


def allequal(a, b, fill_value=True***REMOVED***:
    ***REMOVED***
    Return True if all entries of a and b are equal, using
    fill_value as a truth value where either or both are masked.

    Parameters
    ----------
    a, b : array_like
        Input arrays to compare.
    fill_value : bool, optional
        Whether masked values in a or b are considered equal (True***REMOVED*** or not
        (False***REMOVED***.

    Returns
    -------
    y : bool
        Returns True if the two arrays are equal within the given
        tolerance, False otherwise. If either array contains NaN,
        then False is returned.

    See Also
    --------
    all, any
    numpy.ma.allclose

    Examples
    --------
    >>> a = ma.array([1e10, 1e-7, 42.0***REMOVED***, mask=[0, 0, 1***REMOVED******REMOVED***
    >>> a
    masked_array(data = [10000000000.0 1e-07 --***REMOVED***,
          mask = [False False  True***REMOVED***,
          fill_value=1e+20***REMOVED***

    >>> b = array([1e10, 1e-7, -42.0***REMOVED******REMOVED***
    >>> b
    array([  1.00000000e+10,   1.00000000e-07,  -4.20000000e+01***REMOVED******REMOVED***
    >>> ma.allequal(a, b, fill_value=False***REMOVED***
    False
    >>> ma.allequal(a, b***REMOVED***
    True

    ***REMOVED***
    m = mask_or(getmask(a***REMOVED***, getmask(b***REMOVED******REMOVED***
    if m is nomask:
        x = getdata(a***REMOVED***
        y = getdata(b***REMOVED***
        d = umath.equal(x, y***REMOVED***
        return d.all(***REMOVED***
    elif fill_value:
        x = getdata(a***REMOVED***
        y = getdata(b***REMOVED***
        d = umath.equal(x, y***REMOVED***
        dm = array(d, mask=m, copy=False***REMOVED***
        return dm.filled(True***REMOVED***.all(None***REMOVED***
    else:
        return False


def allclose(a, b, masked_equal=True, rtol=1e-5, atol=1e-8***REMOVED***:
    ***REMOVED***
    Returns True if two arrays are element-wise equal within a tolerance.

    This function is equivalent to `allclose` except that masked values
    are treated as equal (default***REMOVED*** or unequal, depending on the `masked_equal`
    argument.

    Parameters
    ----------
    a, b : array_like
        Input arrays to compare.
    masked_equal : bool, optional
        Whether masked values in `a` and `b` are considered equal (True***REMOVED*** or not
        (False***REMOVED***. They are considered equal by default.
    rtol : float, optional
        Relative tolerance. The relative difference is equal to ``rtol * b``.
        Default is 1e-5.
    atol : float, optional
        Absolute tolerance. The absolute difference is equal to `atol`.
        Default is 1e-8.

    Returns
    -------
    y : bool
        Returns True if the two arrays are equal within the given
        tolerance, False otherwise. If either array contains NaN, then
        False is returned.

    See Also
    --------
    all, any
    numpy.allclose : the non-masked `allclose`.

    Notes
    -----
    If the following equation is element-wise True, then `allclose` returns
    True::

      absolute(`a` - `b`***REMOVED*** <= (`atol` + `rtol` * absolute(`b`***REMOVED******REMOVED***

    Return True if all elements of `a` and `b` are equal subject to
    given tolerances.

    Examples
    --------
    >>> a = ma.array([1e10, 1e-7, 42.0***REMOVED***, mask=[0, 0, 1***REMOVED******REMOVED***
    >>> a
    masked_array(data = [10000000000.0 1e-07 --***REMOVED***,
                 mask = [False False  True***REMOVED***,
           fill_value = 1e+20***REMOVED***
    >>> b = ma.array([1e10, 1e-8, -42.0***REMOVED***, mask=[0, 0, 1***REMOVED******REMOVED***
    >>> ma.allclose(a, b***REMOVED***
    False

    >>> a = ma.array([1e10, 1e-8, 42.0***REMOVED***, mask=[0, 0, 1***REMOVED******REMOVED***
    >>> b = ma.array([1.00001e10, 1e-9, -42.0***REMOVED***, mask=[0, 0, 1***REMOVED******REMOVED***
    >>> ma.allclose(a, b***REMOVED***
    True
    >>> ma.allclose(a, b, masked_equal=False***REMOVED***
    False

    Masked values are not compared directly.

    >>> a = ma.array([1e10, 1e-8, 42.0***REMOVED***, mask=[0, 0, 1***REMOVED******REMOVED***
    >>> b = ma.array([1.00001e10, 1e-9, 42.0***REMOVED***, mask=[0, 0, 1***REMOVED******REMOVED***
    >>> ma.allclose(a, b***REMOVED***
    True
    >>> ma.allclose(a, b, masked_equal=False***REMOVED***
    False

    ***REMOVED***
    x = masked_array(a, copy=False***REMOVED***
    y = masked_array(b, copy=False***REMOVED***

    # make sure y is an inexact type to avoid abs(MIN_INT***REMOVED***; will cause
    # casting of x later.
    dtype = np.result_type(y, 1.***REMOVED***
    if y.dtype != dtype:
        y = masked_array(y, dtype=dtype, copy=False***REMOVED***

    m = mask_or(getmask(x***REMOVED***, getmask(y***REMOVED******REMOVED***
    xinf = np.isinf(masked_array(x, copy=False, mask=m***REMOVED******REMOVED***.filled(False***REMOVED***
    # If we have some infs, they should fall at the same place.
    if not np.all(xinf == filled(np.isinf(y***REMOVED***, False***REMOVED******REMOVED***:
        return False
    # No infs at all
    if not np.any(xinf***REMOVED***:
        d = filled(umath.less_equal(umath.absolute(x - y***REMOVED***,
                                    atol + rtol * umath.absolute(y***REMOVED******REMOVED***,
                   masked_equal***REMOVED***
        return np.all(d***REMOVED***

    if not np.all(filled(x[xinf***REMOVED*** == y[xinf***REMOVED***, masked_equal***REMOVED******REMOVED***:
        return False
    x = x[~xinf***REMOVED***
    y = y[~xinf***REMOVED***

    d = filled(umath.less_equal(umath.absolute(x - y***REMOVED***,
                                atol + rtol * umath.absolute(y***REMOVED******REMOVED***,
               masked_equal***REMOVED***

    return np.all(d***REMOVED***


def asarray(a, dtype=None, order=None***REMOVED***:
    ***REMOVED***
    Convert the input to a masked array of the given data-type.

    No copy is performed if the input is already an `ndarray`. If `a` is
    a subclass of `MaskedArray`, a base class `MaskedArray` is returned.

    Parameters
    ----------
    a : array_like
        Input data, in any form that can be converted to a masked array. This
        includes lists, lists of tuples, tuples, tuples of tuples, tuples
        of lists, ndarrays and masked arrays.
    dtype : dtype, optional
        By default, the data-type is inferred from the input data.
    order : {'C', 'F'***REMOVED***, optional
        Whether to use row-major ('C'***REMOVED*** or column-major ('FORTRAN'***REMOVED*** memory
        representation.  Default is 'C'.

    Returns
    -------
    out : MaskedArray
        Masked array interpretation of `a`.

    See Also
    --------
    asanyarray : Similar to `asarray`, but conserves subclasses.

    Examples
    --------
    >>> x = np.arange(10.***REMOVED***.reshape(2, 5***REMOVED***
    >>> x
    array([[ 0.,  1.,  2.,  3.,  4.***REMOVED***,
           [ 5.,  6.,  7.,  8.,  9.***REMOVED******REMOVED******REMOVED***
    >>> np.ma.asarray(x***REMOVED***
    masked_array(data =
     [[ 0.  1.  2.  3.  4.***REMOVED***
     [ 5.  6.  7.  8.  9.***REMOVED******REMOVED***,
                 mask =
     False,
           fill_value = 1e+20***REMOVED***
    >>> type(np.ma.asarray(x***REMOVED******REMOVED***
    <class 'numpy.ma.core.MaskedArray'>

    ***REMOVED***
    order = order or 'C'
    return masked_array(a, dtype=dtype, copy=False, keep_mask=True,
                        subok=False, order=order***REMOVED***


def asanyarray(a, dtype=None***REMOVED***:
    ***REMOVED***
    Convert the input to a masked array, conserving subclasses.

    If `a` is a subclass of `MaskedArray`, its class is conserved.
    No copy is performed if the input is already an `ndarray`.

    Parameters
    ----------
    a : array_like
        Input data, in any form that can be converted to an array.
    dtype : dtype, optional
        By default, the data-type is inferred from the input data.
    order : {'C', 'F'***REMOVED***, optional
        Whether to use row-major ('C'***REMOVED*** or column-major ('FORTRAN'***REMOVED*** memory
        representation.  Default is 'C'.

    Returns
    -------
    out : MaskedArray
        MaskedArray interpretation of `a`.

    See Also
    --------
    asarray : Similar to `asanyarray`, but does not conserve subclass.

    Examples
    --------
    >>> x = np.arange(10.***REMOVED***.reshape(2, 5***REMOVED***
    >>> x
    array([[ 0.,  1.,  2.,  3.,  4.***REMOVED***,
           [ 5.,  6.,  7.,  8.,  9.***REMOVED******REMOVED******REMOVED***
    >>> np.ma.asanyarray(x***REMOVED***
    masked_array(data =
     [[ 0.  1.  2.  3.  4.***REMOVED***
     [ 5.  6.  7.  8.  9.***REMOVED******REMOVED***,
                 mask =
     False,
           fill_value = 1e+20***REMOVED***
    >>> type(np.ma.asanyarray(x***REMOVED******REMOVED***
    <class 'numpy.ma.core.MaskedArray'>

    ***REMOVED***
    return masked_array(a, dtype=dtype, copy=False, keep_mask=True, subok=True***REMOVED***


##############################################################################
#                               Pickling                                     #
##############################################################################
def dump(a, F***REMOVED***:
    ***REMOVED***
    Pickle a masked array to a file.

    This is a wrapper around ``cPickle.dump``.

    Parameters
    ----------
    a : MaskedArray
        The array to be pickled.
    F : str or file-like object
        The file to pickle `a` to. If a string, the full path to the file.

    ***REMOVED***
    if not hasattr(F, 'readline'***REMOVED***:
        F = open(F, 'w'***REMOVED***
    return pickle.dump(a, F***REMOVED***


def dumps(a***REMOVED***:
    ***REMOVED***
    Return a string corresponding to the pickling of a masked array.

    This is a wrapper around ``cPickle.dumps``.

    Parameters
    ----------
    a : MaskedArray
        The array for which the string representation of the pickle is
        returned.

    ***REMOVED***
    return pickle.dumps(a***REMOVED***


def load(F***REMOVED***:
    ***REMOVED***
    Wrapper around ``cPickle.load`` which accepts either a file-like object
    or a filename.

    Parameters
    ----------
    F : str or file
        The file or file name to load.

    See Also
    --------
    dump : Pickle an array

    Notes
    -----
    This is different from `numpy.load`, which does not use cPickle but loads
    the NumPy binary .npy format.

    ***REMOVED***
    if not hasattr(F, 'readline'***REMOVED***:
        F = open(F, 'r'***REMOVED***
    return pickle.load(F***REMOVED***


def loads(strg***REMOVED***:
    ***REMOVED***
    Load a pickle from the current string.

    The result of ``cPickle.loads(strg***REMOVED***`` is returned.

    Parameters
    ----------
    strg : str
        The string to load.

    See Also
    --------
    dumps : Return a string corresponding to the pickling of a masked array.

    ***REMOVED***
    return pickle.loads(strg***REMOVED***


def fromfile(file, dtype=float, count=-1, sep=''***REMOVED***:
    raise NotImplementedError(
        "fromfile(***REMOVED*** not yet implemented for a MaskedArray."***REMOVED***


def fromflex(fxarray***REMOVED***:
    ***REMOVED***
    Build a masked array from a suitable flexible-type array.

    The input array has to have a data-type with ``_data`` and ``_mask``
    fields. This type of array is output by `MaskedArray.toflex`.

    Parameters
    ----------
    fxarray : ndarray
        The structured input array, containing ``_data`` and ``_mask``
        fields. If present, other fields are discarded.

    Returns
    -------
    result : MaskedArray
        The constructed masked array.

    See Also
    --------
    MaskedArray.toflex : Build a flexible-type array from a masked array.

    Examples
    --------
    >>> x = np.ma.array(np.arange(9***REMOVED***.reshape(3, 3***REMOVED***, mask=[0***REMOVED*** + [1, 0***REMOVED*** * 4***REMOVED***
    >>> rec = x.toflex(***REMOVED***
    >>> rec
    array([[(0, False***REMOVED***, (1, True***REMOVED***, (2, False***REMOVED******REMOVED***,
           [(3, True***REMOVED***, (4, False***REMOVED***, (5, True***REMOVED******REMOVED***,
           [(6, False***REMOVED***, (7, True***REMOVED***, (8, False***REMOVED******REMOVED******REMOVED***,
          dtype=[('_data', '<i4'***REMOVED***, ('_mask', '|b1'***REMOVED******REMOVED******REMOVED***
    >>> x2 = np.ma.fromflex(rec***REMOVED***
    >>> x2
    masked_array(data =
     [[0 -- 2***REMOVED***
     [-- 4 --***REMOVED***
     [6 -- 8***REMOVED******REMOVED***,
                 mask =
     [[False  True False***REMOVED***
     [ True False  True***REMOVED***
     [False  True False***REMOVED******REMOVED***,
           fill_value = 999999***REMOVED***

    Extra fields can be present in the structured array but are discarded:

    >>> dt = [('_data', '<i4'***REMOVED***, ('_mask', '|b1'***REMOVED***, ('field3', '<f4'***REMOVED******REMOVED***
    >>> rec2 = np.zeros((2, 2***REMOVED***, dtype=dt***REMOVED***
    >>> rec2
    array([[(0, False, 0.0***REMOVED***, (0, False, 0.0***REMOVED******REMOVED***,
           [(0, False, 0.0***REMOVED***, (0, False, 0.0***REMOVED******REMOVED******REMOVED***,
          dtype=[('_data', '<i4'***REMOVED***, ('_mask', '|b1'***REMOVED***, ('field3', '<f4'***REMOVED******REMOVED******REMOVED***
    >>> y = np.ma.fromflex(rec2***REMOVED***
    >>> y
    masked_array(data =
     [[0 0***REMOVED***
     [0 0***REMOVED******REMOVED***,
                 mask =
     [[False False***REMOVED***
     [False False***REMOVED******REMOVED***,
           fill_value = 999999***REMOVED***

    ***REMOVED***
    return masked_array(fxarray['_data'***REMOVED***, mask=fxarray['_mask'***REMOVED******REMOVED***


class _convert2ma:

    ***REMOVED***
    Convert functions from numpy to numpy.ma.

    Parameters
    ----------
        _methodname : string
            Name of the method to transform.

    ***REMOVED***
    __doc__ = None

    def __init__(self, funcname, params=None***REMOVED***:
        self._func = getattr(np, funcname***REMOVED***
        self.__doc__ = self.getdoc(***REMOVED***
        self._extras = params or {***REMOVED***

    def getdoc(self***REMOVED***:
        "Return the doc of the function (from the doc of the method***REMOVED***."
        doc = getattr(self._func, '__doc__', None***REMOVED***
        sig = get_object_signature(self._func***REMOVED***
        if doc:
            # Add the signature of the function at the beginning of the doc
            if sig:
                sig = "%s%s\n" % (self._func.__name__, sig***REMOVED***
            doc = sig + doc
        return doc

    def __call__(self, *args, **params***REMOVED***:
        # Find the common parameters to the call and the definition
        _extras = self._extras
        common_params = set(params***REMOVED***.intersection(_extras***REMOVED***
        # Drop the common parameters from the call
        for p in common_params:
            _extras[p***REMOVED*** = params.pop(p***REMOVED***
        # Get the result
        result = self._func.__call__(*args, **params***REMOVED***.view(MaskedArray***REMOVED***
        if "fill_value" in common_params:
            result.fill_value = _extras.get("fill_value", None***REMOVED***
        if "hardmask" in common_params:
            result._hardmask = bool(_extras.get("hard_mask", False***REMOVED******REMOVED***
        return result

arange = _convert2ma('arange', params=dict(fill_value=None, hardmask=False***REMOVED******REMOVED***
clip = np.clip
diff = np.diff
empty = _convert2ma('empty', params=dict(fill_value=None, hardmask=False***REMOVED******REMOVED***
empty_like = _convert2ma('empty_like'***REMOVED***
frombuffer = _convert2ma('frombuffer'***REMOVED***
fromfunction = _convert2ma('fromfunction'***REMOVED***
identity = _convert2ma(
    'identity', params=dict(fill_value=None, hardmask=False***REMOVED******REMOVED***
indices = np.indices
ones = _convert2ma('ones', params=dict(fill_value=None, hardmask=False***REMOVED******REMOVED***
ones_like = np.ones_like
squeeze = np.squeeze
zeros = _convert2ma('zeros', params=dict(fill_value=None, hardmask=False***REMOVED******REMOVED***
zeros_like = np.zeros_like


def append(a, b, axis=None***REMOVED***:
    ***REMOVED***Append values to the end of an array.

    .. versionadded:: 1.9.0

    Parameters
    ----------
    a : array_like
        Values are appended to a copy of this array.
    b : array_like
        These values are appended to a copy of `a`.  It must be of the
        correct shape (the same shape as `a`, excluding `axis`***REMOVED***.  If `axis`
        is not specified, `b` can be any shape and will be flattened
        before use.
    axis : int, optional
        The axis along which `v` are appended.  If `axis` is not given,
        both `a` and `b` are flattened before use.

    Returns
    -------
    append : MaskedArray
        A copy of `a` with `b` appended to `axis`.  Note that `append`
        does not occur in-place: a new array is allocated and filled.  If
        `axis` is None, the result is a flattened array.

    See Also
    --------
    numpy.append : Equivalent function in the top-level NumPy module.

    Examples
    --------
    >>> import numpy.ma as ma
    >>> a = ma.masked_values([1, 2, 3***REMOVED***, 2***REMOVED***
    >>> b = ma.masked_values([[4, 5, 6***REMOVED***, [7, 8, 9***REMOVED******REMOVED***, 7***REMOVED***
    >>> print(ma.append(a, b***REMOVED******REMOVED***
    [1 -- 3 4 5 6 -- 8 9***REMOVED***
    ***REMOVED***
    return concatenate([a, b***REMOVED***, axis***REMOVED***
