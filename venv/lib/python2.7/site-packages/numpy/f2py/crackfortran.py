#!/usr/bin/env python
***REMOVED***
crackfortran --- read fortran (77,90***REMOVED*** code and extract declaration information.

Copyright 1999-2004 Pearu Peterson all rights reserved,
Pearu Peterson <pearu@ioc.ee>
Permission to use, modify, and distribute this software is given under the
terms of the NumPy License.

NO WARRANTY IS EXPRESSED OR IMPLIED.  USE AT YOUR OWN RISK.
$Date: 2005/09/27 07:13:49 $
Pearu Peterson


Usage of crackfortran:
======================
Command line keys: -quiet,-verbose,-fix,-f77,-f90,-show,-h <pyffilename>
                   -m <module name for f77 routines>,--ignore-contains
Functions: crackfortran, crack2fortran
The following Fortran statements/constructions are supported
(or will be if needed***REMOVED***:
   block data,byte,call,character,common,complex,contains,data,
   dimension,double complex,double precision,end,external,function,
   implicit,integer,intent,interface,intrinsic,
   logical,module,optional,parameter,private,public,
   program,real,(sequence?***REMOVED***,subroutine,type,use,virtual,
   include,pythonmodule
Note: 'virtual' is mapped to 'dimension'.
Note: 'implicit integer (z***REMOVED*** static (z***REMOVED***' is 'implicit static (z***REMOVED***' (this is minor bug***REMOVED***.
Note: code after 'contains' will be ignored until its scope ends.
Note: 'common' statement is extended: dimensions are moved to variable definitions
Note: f2py directive: <commentchar>f2py<line> is read as <line>
Note: pythonmodule is introduced to represent Python module

Usage:
  `postlist=crackfortran(files,funcs***REMOVED***`
  `postlist` contains declaration information read from the list of files `files`.
  `crack2fortran(postlist***REMOVED***` returns a fortran code to be saved to pyf-file

  `postlist` has the following structure:
 *** it is a list of dictionaries containing `blocks':
     B = {'block','body','vars','parent_block'[,'name','prefix','args','result',
          'implicit','externals','interfaced','common','sortvars',
          'commonvars','note'***REMOVED******REMOVED***
     B['block'***REMOVED*** = 'interface' | 'function' | 'subroutine' | 'module' |
                  'program' | 'block data' | 'type' | 'pythonmodule'
     B['body'***REMOVED*** --- list containing `subblocks' with the same structure as `blocks'
     B['parent_block'***REMOVED*** --- dictionary of a parent block:
                             C['body'***REMOVED***[<index>***REMOVED***['parent_block'***REMOVED*** is C
     B['vars'***REMOVED*** --- dictionary of variable definitions
     B['sortvars'***REMOVED*** --- dictionary of variable definitions sorted by dependence (independent first***REMOVED***
     B['name'***REMOVED*** --- name of the block (not if B['block'***REMOVED***=='interface'***REMOVED***
     B['prefix'***REMOVED*** --- prefix string (only if B['block'***REMOVED***=='function'***REMOVED***
     B['args'***REMOVED*** --- list of argument names if B['block'***REMOVED***== 'function' | 'subroutine'
     B['result'***REMOVED*** --- name of the return value (only if B['block'***REMOVED***=='function'***REMOVED***
     B['implicit'***REMOVED*** --- dictionary {'a':<variable definition>,'b':...***REMOVED*** | None
     B['externals'***REMOVED*** --- list of variables being external
     B['interfaced'***REMOVED*** --- list of variables being external and defined
     B['common'***REMOVED*** --- dictionary of common blocks (list of objects***REMOVED***
     B['commonvars'***REMOVED*** --- list of variables used in common blocks (dimensions are moved to variable definitions***REMOVED***
     B['from'***REMOVED*** --- string showing the 'parents' of the current block
     B['use'***REMOVED*** --- dictionary of modules used in current block:
     ***REMOVED***<modulename>:{['only':<0|1>***REMOVED***,['map':{<local_name1>:<use_name1>,...***REMOVED******REMOVED******REMOVED******REMOVED***
     B['note'***REMOVED*** --- list of LaTeX comments on the block
     B['f2pyenhancements'***REMOVED*** --- optional dictionary
      ***REMOVED***'threadsafe':'','fortranname':<name>,
           'callstatement':<C-expr>|<multi-line block>,
           'callprotoargument':<C-expr-list>,
           'usercode':<multi-line block>|<list of multi-line blocks>,
           'pymethoddef:<multi-line block>'
       ***REMOVED***
     B['entry'***REMOVED*** --- dictionary {entryname:argslist,..***REMOVED***
     B['varnames'***REMOVED*** --- list of variable names given in the order of reading the
                       Fortran code, useful for derived types.
     B['saved_interface'***REMOVED*** --- a string of scanned routine signature, defines explicit interface
 *** Variable definition is a dictionary
     D = B['vars'***REMOVED***[<variable name>***REMOVED*** =
 ***REMOVED***'typespec'[,'attrspec','kindselector','charselector','=','typename'***REMOVED******REMOVED***
     D['typespec'***REMOVED*** = 'byte' | 'character' | 'complex' | 'double complex' |
                     'double precision' | 'integer' | 'logical' | 'real' | 'type'
     D['attrspec'***REMOVED*** --- list of attributes (e.g. 'dimension(<arrayspec>***REMOVED***',
                       'external','intent(in|out|inout|hide|c|callback|cache|aligned4|aligned8|aligned16***REMOVED***',
                       'optional','required', etc***REMOVED***
     K = D['kindselector'***REMOVED*** = {['*','kind'***REMOVED******REMOVED*** (only if D['typespec'***REMOVED*** =
                         'complex' | 'integer' | 'logical' | 'real' ***REMOVED***
     C = D['charselector'***REMOVED*** = {['*','len','kind'***REMOVED******REMOVED***
                             (only if D['typespec'***REMOVED***=='character'***REMOVED***
     D['='***REMOVED*** --- initialization expression string
     D['typename'***REMOVED*** --- name of the type if D['typespec'***REMOVED***=='type'
     D['dimension'***REMOVED*** --- list of dimension bounds
     D['intent'***REMOVED*** --- list of intent specifications
     D['depend'***REMOVED*** --- list of variable names on which current variable depends on
     D['check'***REMOVED*** --- list of C-expressions; if C-expr returns zero, exception is raised
     D['note'***REMOVED*** --- list of LaTeX comments on the variable
 *** Meaning of kind/char selectors (few examples***REMOVED***:
     D['typespec>'***REMOVED****K['*'***REMOVED***
     D['typespec'***REMOVED***(kind=K['kind'***REMOVED******REMOVED***
     character*C['*'***REMOVED***
     character(len=C['len'***REMOVED***,kind=C['kind'***REMOVED******REMOVED***
     (see also fortran type declaration statement formats below***REMOVED***

Fortran 90 type declaration statement format (F77 is subset of F90***REMOVED***
====================================================================
(Main source: IBM XL Fortran 5.1 Language Reference Manual***REMOVED***
type declaration = <typespec> [[<attrspec>***REMOVED***::***REMOVED*** <entitydecl>
<typespec> = byte                          |
             character[<charselector>***REMOVED***     |
             complex[<kindselector>***REMOVED***       |
             double complex                |
             double precision              |
             integer[<kindselector>***REMOVED***       |
             logical[<kindselector>***REMOVED***       |
             real[<kindselector>***REMOVED***          |
             type(<typename>***REMOVED***
<charselector> = * <charlen>               |
             ([len=***REMOVED***<len>[,[kind=***REMOVED***<kind>***REMOVED******REMOVED*** |
             (kind=<kind>[,len=<len>***REMOVED******REMOVED***
<kindselector> = * <intlen>                |
             ([kind=***REMOVED***<kind>***REMOVED***
<attrspec> = comma separated list of attributes.
             Only the following attributes are used in
             building up the interface:
                external
                (parameter --- affects '=' key***REMOVED***
                optional
                intent
             Other attributes are ignored.
<intentspec> = in | out | inout
<arrayspec> = comma separated list of dimension bounds.
<entitydecl> = <name> [[*<charlen>***REMOVED***[(<arrayspec>***REMOVED******REMOVED*** | [(<arrayspec>***REMOVED******REMOVED****<charlen>***REMOVED***
                      [/<init_expr>/ | =<init_expr>***REMOVED*** [,<entitydecl>***REMOVED***

In addition, the following attributes are used: check,depend,note

TODO:
    * Apply 'parameter' attribute (e.g. 'integer parameter :: i=2' 'real x(i***REMOVED***'
                                   -> 'real x(2***REMOVED***'***REMOVED***
    The above may be solved by creating appropriate preprocessor program, for example.

***REMOVED***
from __future__ import division, absolute_import, print_function

import sys
import string
import fileinput
import re
***REMOVED***
import copy
import platform

from . import __version__

# The eviroment provided by auxfuncs.py is needed for some calls to eval.
# As the needed functions cannot be determined by static inspection of the
# code, it is safest to use import * pending a major refactoring of f2py.
from .auxfuncs import *


f2py_version = __version__.version

# Global flags:
strictf77 = 1          # Ignore `!' comments unless line[0***REMOVED***=='!'
sourcecodeform = 'fix'  # 'fix','free'
quiet = 0              # Be verbose if 0 (Obsolete: not used any more***REMOVED***
verbose = 1            # Be quiet if 0, extra verbose if > 1.
tabchar = 4 * ' '
pyffilename = ''
f77modulename = ''
skipemptyends = 0      # for old F77 programs without 'program' statement
ignorecontains = 1
dolowercase = 1
debug = [***REMOVED***

# Global variables
beginpattern = ''
currentfilename = ''
expectbegin = 1
f90modulevars = {***REMOVED***
filepositiontext = ''
gotnextfile = 1
groupcache = None
groupcounter = 0
grouplist = {groupcounter: [***REMOVED******REMOVED***
groupname = ''
include_paths = [***REMOVED***
neededmodule = -1
onlyfuncs = [***REMOVED***
previous_context = None
skipblocksuntil = -1
skipfuncs = [***REMOVED***
skipfunctions = [***REMOVED***
usermodules = [***REMOVED***


def reset_global_f2py_vars(***REMOVED***:
    global groupcounter, grouplist, neededmodule, expectbegin
    global skipblocksuntil, usermodules, f90modulevars, gotnextfile
    global filepositiontext, currentfilename, skipfunctions, skipfuncs
    global onlyfuncs, include_paths, previous_context
    global strictf77, sourcecodeform, quiet, verbose, tabchar, pyffilename
    global f77modulename, skipemptyends, ignorecontains, dolowercase, debug

    # flags
    strictf77 = 1
    sourcecodeform = 'fix'
    quiet = 0
    verbose = 1
    tabchar = 4 * ' '
    pyffilename = ''
    f77modulename = ''
    skipemptyends = 0
    ignorecontains = 1
    dolowercase = 1
    debug = [***REMOVED***
    # variables
    groupcounter = 0
    grouplist = {groupcounter: [***REMOVED******REMOVED***
    neededmodule = -1
    expectbegin = 1
    skipblocksuntil = -1
    usermodules = [***REMOVED***
    f90modulevars = {***REMOVED***
    gotnextfile = 1
    filepositiontext = ''
    currentfilename = ''
    skipfunctions = [***REMOVED***
    skipfuncs = [***REMOVED***
    onlyfuncs = [***REMOVED***
    include_paths = [***REMOVED***
    previous_context = None


def outmess(line, flag=1***REMOVED***:
    global filepositiontext

    if not verbose:
        return
    if not quiet:
        if flag:
            sys.stdout.write(filepositiontext***REMOVED***
        sys.stdout.write(line***REMOVED***

re._MAXCACHE = 50
defaultimplicitrules = {***REMOVED***
for c in "abcdefghopqrstuvwxyz$_":
    defaultimplicitrules[c***REMOVED*** = {'typespec': 'real'***REMOVED***
for c in "ijklmn":
    defaultimplicitrules[c***REMOVED*** = {'typespec': 'integer'***REMOVED***
del c
badnames = {***REMOVED***
invbadnames = {***REMOVED***
for n in ['int', 'double', 'float', 'char', 'short', 'long', 'void', 'case', 'while',
          'return', 'signed', 'unsigned', 'if', 'for', 'typedef', 'sizeof', 'union',
          'struct', 'static', 'register', 'new', 'break', 'do', 'goto', 'switch',
          'continue', 'else', 'inline', 'extern', 'delete', 'const', 'auto',
          'len', 'rank', 'shape', 'index', 'slen', 'size', '_i',
          'max', 'min',
          'flen', 'fshape',
          'string', 'complex_double', 'float_double', 'stdin', 'stderr', 'stdout',
          'type', 'default'***REMOVED***:
    badnames[n***REMOVED*** = n + '_bn'
    invbadnames[n + '_bn'***REMOVED*** = n


def rmbadname1(name***REMOVED***:
    if name in badnames:
        errmess('rmbadname1: Replacing "%s" with "%s".\n' %
                (name, badnames[name***REMOVED******REMOVED******REMOVED***
        return badnames[name***REMOVED***
    return name


def rmbadname(names***REMOVED***:
    return [rmbadname1(_m***REMOVED*** for _m in names***REMOVED***


def undo_rmbadname1(name***REMOVED***:
    if name in invbadnames:
        errmess('undo_rmbadname1: Replacing "%s" with "%s".\n'
                % (name, invbadnames[name***REMOVED******REMOVED******REMOVED***
        return invbadnames[name***REMOVED***
    return name


def undo_rmbadname(names***REMOVED***:
    return [undo_rmbadname1(_m***REMOVED*** for _m in names***REMOVED***


def getextension(name***REMOVED***:
    i = name.rfind('.'***REMOVED***
    if i == -1:
        return ''
    if '\\' in name[i:***REMOVED***:
        return ''
    if '/' in name[i:***REMOVED***:
        return ''
    return name[i + 1:***REMOVED***

is_f_file = re.compile(r'.*[.***REMOVED***(for|ftn|f77|f***REMOVED***\Z', re.I***REMOVED***.match
_has_f_header = re.compile(r'-[****REMOVED***-\s*fortran\s*-[****REMOVED***-', re.I***REMOVED***.search
_has_f90_header = re.compile(r'-[****REMOVED***-\s*f90\s*-[****REMOVED***-', re.I***REMOVED***.search
_has_fix_header = re.compile(r'-[****REMOVED***-\s*fix\s*-[****REMOVED***-', re.I***REMOVED***.search
_free_f90_start = re.compile(r'[^c****REMOVED***\s*[^\s\d\t***REMOVED***', re.I***REMOVED***.match


def is_free_format(file***REMOVED***:
    ***REMOVED***Check if file is in free format Fortran.***REMOVED***
    # f90 allows both fixed and free format, assuming fixed unless
    # signs of free format are detected.
    result = 0
    f = open(file, 'r'***REMOVED***
    line = f.readline(***REMOVED***
    n = 15  # the number of non-comment lines to scan for hints
    if _has_f_header(line***REMOVED***:
        n = 0
    elif _has_f90_header(line***REMOVED***:
        n = 0
        result = 1
    while n > 0 and line:
        if line[0***REMOVED*** != '!' and line.strip(***REMOVED***:
            n -= 1
            if (line[0***REMOVED*** != '\t' and _free_f90_start(line[:5***REMOVED******REMOVED******REMOVED*** or line[-2:-1***REMOVED*** == '&':
                result = 1
                break
        line = f.readline(***REMOVED***
    f.close(***REMOVED***
    return result


# Read fortran (77,90***REMOVED*** code
def readfortrancode(ffile, dowithline=show, istop=1***REMOVED***:
    ***REMOVED***
    Read fortran codes from files and
     1***REMOVED*** Get rid of comments, line continuations, and empty lines; lower cases.
     2***REMOVED*** Call dowithline(line***REMOVED*** on every line.
     3***REMOVED*** Recursively call itself when statement \"include '<filename>'\" is met.
    ***REMOVED***
    global gotnextfile, filepositiontext, currentfilename, sourcecodeform, strictf77
    global beginpattern, quiet, verbose, dolowercase, include_paths

    if not istop:
        saveglobals = gotnextfile, filepositiontext, currentfilename, sourcecodeform, strictf77,\
            beginpattern, quiet, verbose, dolowercase
    if ffile == [***REMOVED***:
        return
    localdolowercase = dolowercase
    cont = 0
    finalline = ''
    ll = ''
    commentline = re.compile(
        r'(?P<line>([^"***REMOVED****["***REMOVED***[^"***REMOVED****["***REMOVED***[^"!***REMOVED****|[^\'***REMOVED****\'[^\'***REMOVED****\'[^\'!***REMOVED****|[^!\'"***REMOVED*******REMOVED******REMOVED***!{1***REMOVED***(?P<rest>.****REMOVED***'***REMOVED***
    includeline = re.compile(
        r'\s*include\s*(\'|"***REMOVED***(?P<name>[^\'"***REMOVED*******REMOVED***(\'|"***REMOVED***', re.I***REMOVED***
    cont1 = re.compile(r'(?P<line>.****REMOVED***&\s*\Z'***REMOVED***
    cont2 = re.compile(r'(\s*&|***REMOVED***(?P<line>.****REMOVED***'***REMOVED***
    mline_mark = re.compile(r".*?'''"***REMOVED***
    if istop:
        dowithline('', -1***REMOVED***
    ll, l1 = '', ''
    spacedigits = [' '***REMOVED*** + [str(_m***REMOVED*** for _m in range(10***REMOVED******REMOVED***
    filepositiontext = ''
    fin = fileinput.FileInput(ffile***REMOVED***
    while True:
        l = fin.readline(***REMOVED***
        if not l:
            break
        if fin.isfirstline(***REMOVED***:
            filepositiontext = ''
            currentfilename = fin.filename(***REMOVED***
            gotnextfile = 1
            l1 = l
            strictf77 = 0
            sourcecodeform = 'fix'
            ext = os.path.splitext(currentfilename***REMOVED***[1***REMOVED***
            if is_f_file(currentfilename***REMOVED*** and \
                    not (_has_f90_header(l***REMOVED*** or _has_fix_header(l***REMOVED******REMOVED***:
                strictf77 = 1
            elif is_free_format(currentfilename***REMOVED*** and not _has_fix_header(l***REMOVED***:
                sourcecodeform = 'free'
            if strictf77:
                beginpattern = beginpattern77
            else:
                beginpattern = beginpattern90
            outmess('\tReading file %s (format:%s%s***REMOVED***\n'
                    % (repr(currentfilename***REMOVED***, sourcecodeform,
                       strictf77 and ',strict' or ''***REMOVED******REMOVED***

        l = l.expandtabs(***REMOVED***.replace('\xa0', ' '***REMOVED***
        # Get rid of newline characters
        while not l == '':
            if l[-1***REMOVED*** not in "\n\r\f":
                break
            l = l[:-1***REMOVED***
        if not strictf77:
            r = commentline.match(l***REMOVED***
            if r:
                l = r.group('line'***REMOVED*** + ' '  # Strip comments starting with `!'
                rl = r.group('rest'***REMOVED***
                if rl[:4***REMOVED***.lower(***REMOVED*** == 'f2py':  # f2py directive
                    l = l + 4 * ' '
                    r = commentline.match(rl[4:***REMOVED******REMOVED***
                    if r:
                        l = l + r.group('line'***REMOVED***
                    else:
                        l = l + rl[4:***REMOVED***
        if l.strip(***REMOVED*** == '':  # Skip empty line
            cont = 0
            continue
        if sourcecodeform == 'fix':
            if l[0***REMOVED*** in ['*', 'c', '!', 'C', '#'***REMOVED***:
                if l[1:5***REMOVED***.lower(***REMOVED*** == 'f2py':  # f2py directive
                    l = '     ' + l[5:***REMOVED***
                else:  # Skip comment line
                    cont = 0
                    continue
            elif strictf77:
                if len(l***REMOVED*** > 72:
                    l = l[:72***REMOVED***
            if not (l[0***REMOVED*** in spacedigits***REMOVED***:
                raise Exception('readfortrancode: Found non-(space,digit***REMOVED*** char '
                                'in the first column.\n\tAre you sure that '
                                'this code is in fix form?\n\tline=%s' % repr(l***REMOVED******REMOVED***

            if (not cont or strictf77***REMOVED*** and (len(l***REMOVED*** > 5 and not l[5***REMOVED*** == ' '***REMOVED***:
                # Continuation of a previous line
                ll = ll + l[6:***REMOVED***
                finalline = ''
                origfinalline = ''
            else:
                if not strictf77:
                    # F90 continuation
                    r = cont1.match(l***REMOVED***
                    if r:
                        l = r.group('line'***REMOVED***  # Continuation follows ..
                    if cont:
                        ll = ll + cont2.match(l***REMOVED***.group('line'***REMOVED***
                        finalline = ''
                        origfinalline = ''
                    else:
                        # clean up line beginning from possible digits.
                        l = '     ' + l[5:***REMOVED***
                        if localdolowercase:
                            finalline = ll.lower(***REMOVED***
                        else:
                            finalline = ll
                        origfinalline = ll
                        ll = l
                    cont = (r is not None***REMOVED***
                else:
                    # clean up line beginning from possible digits.
                    l = '     ' + l[5:***REMOVED***
                    if localdolowercase:
                        finalline = ll.lower(***REMOVED***
                    else:
                        finalline = ll
                    origfinalline = ll
                    ll = l

        elif sourcecodeform == 'free':
            if not cont and ext == '.pyf' and mline_mark.match(l***REMOVED***:
                l = l + '\n'
                while True:
                    lc = fin.readline(***REMOVED***
                    if not lc:
                        errmess(
                            'Unexpected end of file when reading multiline\n'***REMOVED***
                        break
                    l = l + lc
                    if mline_mark.match(lc***REMOVED***:
                        break
                l = l.rstrip(***REMOVED***
            r = cont1.match(l***REMOVED***
            if r:
                l = r.group('line'***REMOVED***  # Continuation follows ..
            if cont:
                ll = ll + cont2.match(l***REMOVED***.group('line'***REMOVED***
                finalline = ''
                origfinalline = ''
            else:
                if localdolowercase:
                    finalline = ll.lower(***REMOVED***
                else:
                    finalline = ll
                origfinalline = ll
                ll = l
            cont = (r is not None***REMOVED***
        else:
            raise ValueError(
                "Flag sourcecodeform must be either 'fix' or 'free': %s" % repr(sourcecodeform***REMOVED******REMOVED***
        filepositiontext = 'Line #%d in %s:"%s"\n\t' % (
            fin.filelineno(***REMOVED*** - 1, currentfilename, l1***REMOVED***
        m = includeline.match(origfinalline***REMOVED***
        if m:
            fn = m.group('name'***REMOVED***
            if os.path.isfile(fn***REMOVED***:
                readfortrancode(fn, dowithline=dowithline, istop=0***REMOVED***
            else:
                include_dirs = [
                    os.path.dirname(currentfilename***REMOVED******REMOVED*** + include_paths
                foundfile = 0
                for inc_dir in include_dirs:
                    fn1 = os.path.join(inc_dir, fn***REMOVED***
                    if os.path.isfile(fn1***REMOVED***:
                        foundfile = 1
                        readfortrancode(fn1, dowithline=dowithline, istop=0***REMOVED***
                        break
                if not foundfile:
                    outmess('readfortrancode: could not find include file %s in %s. Ignoring.\n' % (
                        repr(fn***REMOVED***, os.pathsep.join(include_dirs***REMOVED******REMOVED******REMOVED***
        else:
            dowithline(finalline***REMOVED***
        l1 = ll
    if localdolowercase:
        finalline = ll.lower(***REMOVED***
    else:
        finalline = ll
    origfinalline = ll
    filepositiontext = 'Line #%d in %s:"%s"\n\t' % (
        fin.filelineno(***REMOVED*** - 1, currentfilename, l1***REMOVED***
    m = includeline.match(origfinalline***REMOVED***
    if m:
        fn = m.group('name'***REMOVED***
        if os.path.isfile(fn***REMOVED***:
            readfortrancode(fn, dowithline=dowithline, istop=0***REMOVED***
        else:
            include_dirs = [os.path.dirname(currentfilename***REMOVED******REMOVED*** + include_paths
            foundfile = 0
            for inc_dir in include_dirs:
                fn1 = os.path.join(inc_dir, fn***REMOVED***
                if os.path.isfile(fn1***REMOVED***:
                    foundfile = 1
                    readfortrancode(fn1, dowithline=dowithline, istop=0***REMOVED***
                    break
            if not foundfile:
                outmess('readfortrancode: could not find include file %s in %s. Ignoring.\n' % (
                    repr(fn***REMOVED***, os.pathsep.join(include_dirs***REMOVED******REMOVED******REMOVED***
    else:
        dowithline(finalline***REMOVED***
    filepositiontext = ''
    fin.close(***REMOVED***
    if istop:
        dowithline('', 1***REMOVED***
    else:
        gotnextfile, filepositiontext, currentfilename, sourcecodeform, strictf77,\
            beginpattern, quiet, verbose, dolowercase = saveglobals

# Crack line
beforethisafter = r'\s*(?P<before>%s(?=\s*(\b(%s***REMOVED***\b***REMOVED******REMOVED******REMOVED***' + \
    r'\s*(?P<this>(\b(%s***REMOVED***\b***REMOVED******REMOVED***' + \
    r'\s*(?P<after>%s***REMOVED***\s*\Z'
##
fortrantypes = 'character|logical|integer|real|complex|double\s*(precision\s*(complex|***REMOVED***|complex***REMOVED***|type(?=\s*\([\w\s,=(****REMOVED******REMOVED****\***REMOVED******REMOVED***|byte'
typespattern = re.compile(
    beforethisafter % ('', fortrantypes, fortrantypes, '.*'***REMOVED***, re.I***REMOVED***, 'type'
typespattern4implicit = re.compile(beforethisafter % (
    '', fortrantypes + '|static|automatic|undefined', fortrantypes + '|static|automatic|undefined', '.*'***REMOVED***, re.I***REMOVED***
#
functionpattern = re.compile(beforethisafter % (
    '([a-z***REMOVED***+[\w\s(=*+-/***REMOVED******REMOVED****?|***REMOVED***', 'function', 'function', '.*'***REMOVED***, re.I***REMOVED***, 'begin'
subroutinepattern = re.compile(beforethisafter % (
    '[a-z\s***REMOVED****?', 'subroutine', 'subroutine', '.*'***REMOVED***, re.I***REMOVED***, 'begin'
# modulepattern=re.compile(beforethisafter%('[a-z\s***REMOVED****?','module','module','.*'***REMOVED***,re.I***REMOVED***,'begin'
#
groupbegins77 = r'program|block\s*data'
beginpattern77 = re.compile(
    beforethisafter % ('', groupbegins77, groupbegins77, '.*'***REMOVED***, re.I***REMOVED***, 'begin'
groupbegins90 = groupbegins77 + \
    r'|module(?!\s*procedure***REMOVED***|python\s*module|interface|type(?!\s*\(***REMOVED***'
beginpattern90 = re.compile(
    beforethisafter % ('', groupbegins90, groupbegins90, '.*'***REMOVED***, re.I***REMOVED***, 'begin'
groupends = r'end|endprogram|endblockdata|endmodule|endpythonmodule|endinterface'
endpattern = re.compile(
    beforethisafter % ('', groupends, groupends, '[\w\s***REMOVED****'***REMOVED***, re.I***REMOVED***, 'end'
# endifs='end\s*(if|do|where|select|while|forall***REMOVED***'
endifs = '(end\s*(if|do|where|select|while|forall***REMOVED******REMOVED***|(module\s*procedure***REMOVED***'
endifpattern = re.compile(
    beforethisafter % ('[\w***REMOVED****?', endifs, endifs, '[\w\s***REMOVED****'***REMOVED***, re.I***REMOVED***, 'endif'
#
implicitpattern = re.compile(
    beforethisafter % ('', 'implicit', 'implicit', '.*'***REMOVED***, re.I***REMOVED***, 'implicit'
dimensionpattern = re.compile(beforethisafter % (
    '', 'dimension|virtual', 'dimension|virtual', '.*'***REMOVED***, re.I***REMOVED***, 'dimension'
externalpattern = re.compile(
    beforethisafter % ('', 'external', 'external', '.*'***REMOVED***, re.I***REMOVED***, 'external'
optionalpattern = re.compile(
    beforethisafter % ('', 'optional', 'optional', '.*'***REMOVED***, re.I***REMOVED***, 'optional'
requiredpattern = re.compile(
    beforethisafter % ('', 'required', 'required', '.*'***REMOVED***, re.I***REMOVED***, 'required'
publicpattern = re.compile(
    beforethisafter % ('', 'public', 'public', '.*'***REMOVED***, re.I***REMOVED***, 'public'
privatepattern = re.compile(
    beforethisafter % ('', 'private', 'private', '.*'***REMOVED***, re.I***REMOVED***, 'private'
intrisicpattern = re.compile(
    beforethisafter % ('', 'intrisic', 'intrisic', '.*'***REMOVED***, re.I***REMOVED***, 'intrisic'
intentpattern = re.compile(beforethisafter % (
    '', 'intent|depend|note|check', 'intent|depend|note|check', '\s*\(.*?\***REMOVED***.*'***REMOVED***, re.I***REMOVED***, 'intent'
parameterpattern = re.compile(
    beforethisafter % ('', 'parameter', 'parameter', '\s*\(.*'***REMOVED***, re.I***REMOVED***, 'parameter'
datapattern = re.compile(
    beforethisafter % ('', 'data', 'data', '.*'***REMOVED***, re.I***REMOVED***, 'data'
callpattern = re.compile(
    beforethisafter % ('', 'call', 'call', '.*'***REMOVED***, re.I***REMOVED***, 'call'
entrypattern = re.compile(
    beforethisafter % ('', 'entry', 'entry', '.*'***REMOVED***, re.I***REMOVED***, 'entry'
callfunpattern = re.compile(
    beforethisafter % ('', 'callfun', 'callfun', '.*'***REMOVED***, re.I***REMOVED***, 'callfun'
commonpattern = re.compile(
    beforethisafter % ('', 'common', 'common', '.*'***REMOVED***, re.I***REMOVED***, 'common'
usepattern = re.compile(
    beforethisafter % ('', 'use', 'use', '.*'***REMOVED***, re.I***REMOVED***, 'use'
containspattern = re.compile(
    beforethisafter % ('', 'contains', 'contains', ''***REMOVED***, re.I***REMOVED***, 'contains'
formatpattern = re.compile(
    beforethisafter % ('', 'format', 'format', '.*'***REMOVED***, re.I***REMOVED***, 'format'
# Non-fortran and f2py-specific statements
f2pyenhancementspattern = re.compile(beforethisafter % ('', 'threadsafe|fortranname|callstatement|callprotoargument|usercode|pymethoddef',
                                                        'threadsafe|fortranname|callstatement|callprotoargument|usercode|pymethoddef', '.*'***REMOVED***, re.I | re.S***REMOVED***, 'f2pyenhancements'
multilinepattern = re.compile(
    r"\s*(?P<before>'''***REMOVED***(?P<this>.*?***REMOVED***(?P<after>'''***REMOVED***\s*\Z", re.S***REMOVED***, 'multiline'
##


def _simplifyargs(argsline***REMOVED***:
    a = [***REMOVED***
    for n in markoutercomma(argsline***REMOVED***.split('@,@'***REMOVED***:
        for r in '(***REMOVED***,':
            n = n.replace(r, '_'***REMOVED***
        a.append(n***REMOVED***
    return ','.join(a***REMOVED***

crackline_re_1 = re.compile(r'\s*(?P<result>\b[a-z***REMOVED***+[\w***REMOVED****\b***REMOVED***\s*[=***REMOVED***.*', re.I***REMOVED***


def crackline(line, reset=0***REMOVED***:
    ***REMOVED***
    reset=-1  --- initialize
    reset=0   --- crack the line
    reset=1   --- final check if mismatch of blocks occured

    Cracked data is saved in grouplist[0***REMOVED***.
    ***REMOVED***
    global beginpattern, groupcounter, groupname, groupcache, grouplist
    global filepositiontext, currentfilename, neededmodule, expectbegin
    global skipblocksuntil, skipemptyends, previous_context, gotnextfile

    if ';' in line and not (f2pyenhancementspattern[0***REMOVED***.match(line***REMOVED*** or
                            multilinepattern[0***REMOVED***.match(line***REMOVED******REMOVED***:
        for l in line.split(';'***REMOVED***:
            # XXX: non-zero reset values need testing
            assert reset == 0, repr(reset***REMOVED***
            crackline(l, reset***REMOVED***
        return
    if reset < 0:
        groupcounter = 0
        groupname = {groupcounter: ''***REMOVED***
        groupcache = {groupcounter: {***REMOVED******REMOVED***
        grouplist = {groupcounter: [***REMOVED******REMOVED***
        groupcache[groupcounter***REMOVED***['body'***REMOVED*** = [***REMOVED***
        groupcache[groupcounter***REMOVED***['vars'***REMOVED*** = {***REMOVED***
        groupcache[groupcounter***REMOVED***['block'***REMOVED*** = ''
        groupcache[groupcounter***REMOVED***['name'***REMOVED*** = ''
        neededmodule = -1
        skipblocksuntil = -1
        return
    if reset > 0:
        fl = 0
        if f77modulename and neededmodule == groupcounter:
            fl = 2
        while groupcounter > fl:
            outmess('crackline: groupcounter=%s groupname=%s\n' %
                    (repr(groupcounter***REMOVED***, repr(groupname***REMOVED******REMOVED******REMOVED***
            outmess(
                'crackline: Mismatch of blocks encountered. Trying to fix it by assuming "end" statement.\n'***REMOVED***
            grouplist[groupcounter - 1***REMOVED***.append(groupcache[groupcounter***REMOVED******REMOVED***
            grouplist[groupcounter - 1***REMOVED***[-1***REMOVED***['body'***REMOVED*** = grouplist[groupcounter***REMOVED***
            del grouplist[groupcounter***REMOVED***
            groupcounter = groupcounter - 1
        if f77modulename and neededmodule == groupcounter:
            grouplist[groupcounter - 1***REMOVED***.append(groupcache[groupcounter***REMOVED******REMOVED***
            grouplist[groupcounter - 1***REMOVED***[-1***REMOVED***['body'***REMOVED*** = grouplist[groupcounter***REMOVED***
            del grouplist[groupcounter***REMOVED***
            groupcounter = groupcounter - 1  # end interface
            grouplist[groupcounter - 1***REMOVED***.append(groupcache[groupcounter***REMOVED******REMOVED***
            grouplist[groupcounter - 1***REMOVED***[-1***REMOVED***['body'***REMOVED*** = grouplist[groupcounter***REMOVED***
            del grouplist[groupcounter***REMOVED***
            groupcounter = groupcounter - 1  # end module
            neededmodule = -1
        return
    if line == '':
        return
    flag = 0
    for pat in [dimensionpattern, externalpattern, intentpattern, optionalpattern,
                requiredpattern,
                parameterpattern, datapattern, publicpattern, privatepattern,
                intrisicpattern,
                endifpattern, endpattern,
                formatpattern,
                beginpattern, functionpattern, subroutinepattern,
                implicitpattern, typespattern, commonpattern,
                callpattern, usepattern, containspattern,
                entrypattern,
                f2pyenhancementspattern,
                multilinepattern
                ***REMOVED***:
        m = pat[0***REMOVED***.match(line***REMOVED***
        if m:
            break
        flag = flag + 1
    if not m:
        re_1 = crackline_re_1
        if 0 <= skipblocksuntil <= groupcounter:
            return
        if 'externals' in groupcache[groupcounter***REMOVED***:
            for name in groupcache[groupcounter***REMOVED***['externals'***REMOVED***:
                if name in invbadnames:
                    name = invbadnames[name***REMOVED***
                if 'interfaced' in groupcache[groupcounter***REMOVED*** and name in groupcache[groupcounter***REMOVED***['interfaced'***REMOVED***:
                    continue
                m1 = re.match(
                    r'(?P<before>[^"***REMOVED*******REMOVED***\b%s\b\s*@\(@(?P<args>[^@***REMOVED*******REMOVED***@\***REMOVED***@.*\Z' % name, markouterparen(line***REMOVED***, re.I***REMOVED***
                if m1:
                    m2 = re_1.match(m1.group('before'***REMOVED******REMOVED***
                    a = _simplifyargs(m1.group('args'***REMOVED******REMOVED***
                    if m2:
                        line = 'callfun %s(%s***REMOVED*** result (%s***REMOVED***' % (
                            name, a, m2.group('result'***REMOVED******REMOVED***
                    else:
                        line = 'callfun %s(%s***REMOVED***' % (name, a***REMOVED***
                    m = callfunpattern[0***REMOVED***.match(line***REMOVED***
                    if not m:
                        outmess(
                            'crackline: could not resolve function call for line=%s.\n' % repr(line***REMOVED******REMOVED***
                        return
                    analyzeline(m, 'callfun', line***REMOVED***
                    return
        if verbose > 1 or (verbose == 1 and currentfilename.lower(***REMOVED***.endswith('.pyf'***REMOVED******REMOVED***:
            previous_context = None
            outmess('crackline:%d: No pattern for line\n' % (groupcounter***REMOVED******REMOVED***
        return
    elif pat[1***REMOVED*** == 'end':
        if 0 <= skipblocksuntil < groupcounter:
            groupcounter = groupcounter - 1
            if skipblocksuntil <= groupcounter:
                return
        if groupcounter <= 0:
            raise Exception('crackline: groupcounter(=%s***REMOVED*** is nonpositive. '
                            'Check the blocks.'
                            % (groupcounter***REMOVED******REMOVED***
        m1 = beginpattern[0***REMOVED***.match((line***REMOVED******REMOVED***
        if (m1***REMOVED*** and (not m1.group('this'***REMOVED*** == groupname[groupcounter***REMOVED******REMOVED***:
            raise Exception('crackline: End group %s does not match with '
                            'previous Begin group %s\n\t%s' %
                            (repr(m1.group('this'***REMOVED******REMOVED***, repr(groupname[groupcounter***REMOVED******REMOVED***,
                             filepositiontext***REMOVED***
                            ***REMOVED***
        if skipblocksuntil == groupcounter:
            skipblocksuntil = -1
        grouplist[groupcounter - 1***REMOVED***.append(groupcache[groupcounter***REMOVED******REMOVED***
        grouplist[groupcounter - 1***REMOVED***[-1***REMOVED***['body'***REMOVED*** = grouplist[groupcounter***REMOVED***
        del grouplist[groupcounter***REMOVED***
        groupcounter = groupcounter - 1
        if not skipemptyends:
            expectbegin = 1
    elif pat[1***REMOVED*** == 'begin':
        if 0 <= skipblocksuntil <= groupcounter:
            groupcounter = groupcounter + 1
            return
        gotnextfile = 0
        analyzeline(m, pat[1***REMOVED***, line***REMOVED***
        expectbegin = 0
    elif pat[1***REMOVED*** == 'endif':
        pass
    elif pat[1***REMOVED*** == 'contains':
        if ignorecontains:
            return
        if 0 <= skipblocksuntil <= groupcounter:
            return
        skipblocksuntil = groupcounter
    else:
        if 0 <= skipblocksuntil <= groupcounter:
            return
        analyzeline(m, pat[1***REMOVED***, line***REMOVED***


def markouterparen(line***REMOVED***:
    l = ''
    f = 0
    for c in line:
        if c == '(':
            f = f + 1
            if f == 1:
                l = l + '@(@'
                continue
        elif c == '***REMOVED***':
            f = f - 1
            if f == 0:
                l = l + '@***REMOVED***@'
                continue
        l = l + c
    return l


def markoutercomma(line, comma=','***REMOVED***:
    l = ''
    f = 0
    cc = ''
    for c in line:
        if (not cc or cc == '***REMOVED***'***REMOVED*** and c == '(':
            f = f + 1
            cc = '***REMOVED***'
        elif not cc and c == '\'' and (not l or l[-1***REMOVED*** != '\\'***REMOVED***:
            f = f + 1
            cc = '\''
        elif c == cc:
            f = f - 1
            if f == 0:
                cc = ''
        elif c == comma and f == 0:
            l = l + '@' + comma + '@'
            continue
        l = l + c
    assert not f, repr((f, line, l, cc***REMOVED******REMOVED***
    return l


def unmarkouterparen(line***REMOVED***:
    r = line.replace('@(@', '('***REMOVED***.replace('@***REMOVED***@', '***REMOVED***'***REMOVED***
    return r


def appenddecl(decl, decl2, force=1***REMOVED***:
    if not decl:
        decl = {***REMOVED***
    if not decl2:
        return decl
    if decl is decl2:
        return decl
    for k in list(decl2.keys(***REMOVED******REMOVED***:
        if k == 'typespec':
            if force or k not in decl:
                decl[k***REMOVED*** = decl2[k***REMOVED***
        elif k == 'attrspec':
            for l in decl2[k***REMOVED***:
                decl = setattrspec(decl, l, force***REMOVED***
        elif k == 'kindselector':
            decl = setkindselector(decl, decl2[k***REMOVED***, force***REMOVED***
        elif k == 'charselector':
            decl = setcharselector(decl, decl2[k***REMOVED***, force***REMOVED***
        elif k in ['=', 'typename'***REMOVED***:
            if force or k not in decl:
                decl[k***REMOVED*** = decl2[k***REMOVED***
        elif k == 'note':
            pass
        elif k in ['intent', 'check', 'dimension', 'optional', 'required'***REMOVED***:
            errmess('appenddecl: "%s" not implemented.\n' % k***REMOVED***
        else:
            raise Exception('appenddecl: Unknown variable definition key:' +
                            str(k***REMOVED******REMOVED***
    return decl

selectpattern = re.compile(
    r'\s*(?P<this>(@\(@.*?@\***REMOVED***@|[****REMOVED***[\d****REMOVED***+|[****REMOVED***\s*@\(@.*?@\***REMOVED***@|***REMOVED******REMOVED***(?P<after>.****REMOVED***\Z', re.I***REMOVED***
nameargspattern = re.compile(
    r'\s*(?P<name>\b[\w$***REMOVED***+\b***REMOVED***\s*(@\(@\s*(?P<args>[\w\s,***REMOVED*******REMOVED***\s*@\***REMOVED***@|***REMOVED***\s*((result(\s*@\(@\s*(?P<result>\b[\w$***REMOVED***+\b***REMOVED***\s*@\***REMOVED***@|***REMOVED******REMOVED***|(bind\s*@\(@\s*(?P<bind>.****REMOVED***\s*@\***REMOVED***@***REMOVED******REMOVED****\s*\Z', re.I***REMOVED***
callnameargspattern = re.compile(
    r'\s*(?P<name>\b[\w$***REMOVED***+\b***REMOVED***\s*@\(@\s*(?P<args>.****REMOVED***\s*@\***REMOVED***@\s*\Z', re.I***REMOVED***
real16pattern = re.compile(
    r'([-+***REMOVED***?(?:\d+(?:\.\d****REMOVED***?|\d*\.\d+***REMOVED******REMOVED***[dD***REMOVED***((?:[-+***REMOVED***?\d+***REMOVED***?***REMOVED***'***REMOVED***
real8pattern = re.compile(
    r'([-+***REMOVED***?((?:\d+(?:\.\d****REMOVED***?|\d*\.\d+***REMOVED******REMOVED***[eE***REMOVED***((?:[-+***REMOVED***?\d+***REMOVED***?***REMOVED***|(\d+\.\d****REMOVED******REMOVED***'***REMOVED***

_intentcallbackpattern = re.compile(r'intent\s*\(.*?\bcallback\b', re.I***REMOVED***


def _is_intent_callback(vdecl***REMOVED***:
    for a in vdecl.get('attrspec', [***REMOVED******REMOVED***:
        if _intentcallbackpattern.match(a***REMOVED***:
            return 1
    return 0


def _resolvenameargspattern(line***REMOVED***:
    line = markouterparen(line***REMOVED***
    m1 = nameargspattern.match(line***REMOVED***
    if m1:
        return m1.group('name'***REMOVED***, m1.group('args'***REMOVED***, m1.group('result'***REMOVED***, m1.group('bind'***REMOVED***
    m1 = callnameargspattern.match(line***REMOVED***
    if m1:
        return m1.group('name'***REMOVED***, m1.group('args'***REMOVED***, None, None
    return None, [***REMOVED***, None, None


def analyzeline(m, case, line***REMOVED***:
    global groupcounter, groupname, groupcache, grouplist, filepositiontext
    global currentfilename, f77modulename, neededinterface, neededmodule
    global expectbegin, gotnextfile, previous_context

    block = m.group('this'***REMOVED***
    if case != 'multiline':
        previous_context = None
    if expectbegin and case not in ['begin', 'call', 'callfun', 'type'***REMOVED*** \
       and not skipemptyends and groupcounter < 1:
        newname = os.path.basename(currentfilename***REMOVED***.split('.'***REMOVED***[0***REMOVED***
        outmess(
            'analyzeline: no group yet. Creating program group with name "%s".\n' % newname***REMOVED***
        gotnextfile = 0
        groupcounter = groupcounter + 1
        groupname[groupcounter***REMOVED*** = 'program'
        groupcache[groupcounter***REMOVED*** = {***REMOVED***
        grouplist[groupcounter***REMOVED*** = [***REMOVED***
        groupcache[groupcounter***REMOVED***['body'***REMOVED*** = [***REMOVED***
        groupcache[groupcounter***REMOVED***['vars'***REMOVED*** = {***REMOVED***
        groupcache[groupcounter***REMOVED***['block'***REMOVED*** = 'program'
        groupcache[groupcounter***REMOVED***['name'***REMOVED*** = newname
        groupcache[groupcounter***REMOVED***['from'***REMOVED*** = 'fromsky'
        expectbegin = 0
    if case in ['begin', 'call', 'callfun'***REMOVED***:
        # Crack line => block,name,args,result
        block = block.lower(***REMOVED***
        if re.match(r'block\s*data', block, re.I***REMOVED***:
            block = 'block data'
        if re.match(r'python\s*module', block, re.I***REMOVED***:
            block = 'python module'
        name, args, result, bind = _resolvenameargspattern(m.group('after'***REMOVED******REMOVED***
        if name is None:
            if block == 'block data':
                name = '_BLOCK_DATA_'
            else:
                name = ''
            if block not in ['interface', 'block data'***REMOVED***:
                outmess('analyzeline: No name/args pattern found for line.\n'***REMOVED***

        previous_context = (block, name, groupcounter***REMOVED***
        if args:
            args = rmbadname([x.strip(***REMOVED***
                              for x in markoutercomma(args***REMOVED***.split('@,@'***REMOVED******REMOVED******REMOVED***
        else:
            args = [***REMOVED***
        if '' in args:
            while '' in args:
                args.remove(''***REMOVED***
            outmess(
                'analyzeline: argument list is malformed (missing argument***REMOVED***.\n'***REMOVED***

        # end of crack line => block,name,args,result
        needmodule = 0
        needinterface = 0

        if case in ['call', 'callfun'***REMOVED***:
            needinterface = 1
            if 'args' not in groupcache[groupcounter***REMOVED***:
                return
            if name not in groupcache[groupcounter***REMOVED***['args'***REMOVED***:
                return
            for it in grouplist[groupcounter***REMOVED***:
                if it['name'***REMOVED*** == name:
                    return
            if name in groupcache[groupcounter***REMOVED***['interfaced'***REMOVED***:
                return
            block = {'call': 'subroutine', 'callfun': 'function'***REMOVED***[case***REMOVED***
        if f77modulename and neededmodule == -1 and groupcounter <= 1:
            neededmodule = groupcounter + 2
            needmodule = 1
            if block != 'interface':
                needinterface = 1
        # Create new block(s***REMOVED***
        groupcounter = groupcounter + 1
        groupcache[groupcounter***REMOVED*** = {***REMOVED***
        grouplist[groupcounter***REMOVED*** = [***REMOVED***
        if needmodule:
            if verbose > 1:
                outmess('analyzeline: Creating module block %s\n' %
                        repr(f77modulename***REMOVED***, 0***REMOVED***
            groupname[groupcounter***REMOVED*** = 'module'
            groupcache[groupcounter***REMOVED***['block'***REMOVED*** = 'python module'
            groupcache[groupcounter***REMOVED***['name'***REMOVED*** = f77modulename
            groupcache[groupcounter***REMOVED***['from'***REMOVED*** = ''
            groupcache[groupcounter***REMOVED***['body'***REMOVED*** = [***REMOVED***
            groupcache[groupcounter***REMOVED***['externals'***REMOVED*** = [***REMOVED***
            groupcache[groupcounter***REMOVED***['interfaced'***REMOVED*** = [***REMOVED***
            groupcache[groupcounter***REMOVED***['vars'***REMOVED*** = {***REMOVED***
            groupcounter = groupcounter + 1
            groupcache[groupcounter***REMOVED*** = {***REMOVED***
            grouplist[groupcounter***REMOVED*** = [***REMOVED***
        if needinterface:
            if verbose > 1:
                outmess('analyzeline: Creating additional interface block (groupcounter=%s***REMOVED***.\n' % (
                    groupcounter***REMOVED***, 0***REMOVED***
            groupname[groupcounter***REMOVED*** = 'interface'
            groupcache[groupcounter***REMOVED***['block'***REMOVED*** = 'interface'
            groupcache[groupcounter***REMOVED***['name'***REMOVED*** = 'unknown_interface'
            groupcache[groupcounter***REMOVED***['from'***REMOVED*** = '%s:%s' % (
                groupcache[groupcounter - 1***REMOVED***['from'***REMOVED***, groupcache[groupcounter - 1***REMOVED***['name'***REMOVED******REMOVED***
            groupcache[groupcounter***REMOVED***['body'***REMOVED*** = [***REMOVED***
            groupcache[groupcounter***REMOVED***['externals'***REMOVED*** = [***REMOVED***
            groupcache[groupcounter***REMOVED***['interfaced'***REMOVED*** = [***REMOVED***
            groupcache[groupcounter***REMOVED***['vars'***REMOVED*** = {***REMOVED***
            groupcounter = groupcounter + 1
            groupcache[groupcounter***REMOVED*** = {***REMOVED***
            grouplist[groupcounter***REMOVED*** = [***REMOVED***
        groupname[groupcounter***REMOVED*** = block
        groupcache[groupcounter***REMOVED***['block'***REMOVED*** = block
        if not name:
            name = 'unknown_' + block
        groupcache[groupcounter***REMOVED***['prefix'***REMOVED*** = m.group('before'***REMOVED***
        groupcache[groupcounter***REMOVED***['name'***REMOVED*** = rmbadname1(name***REMOVED***
        groupcache[groupcounter***REMOVED***['result'***REMOVED*** = result
        if groupcounter == 1:
            groupcache[groupcounter***REMOVED***['from'***REMOVED*** = currentfilename
        else:
            if f77modulename and groupcounter == 3:
                groupcache[groupcounter***REMOVED***['from'***REMOVED*** = '%s:%s' % (
                    groupcache[groupcounter - 1***REMOVED***['from'***REMOVED***, currentfilename***REMOVED***
            else:
                groupcache[groupcounter***REMOVED***['from'***REMOVED*** = '%s:%s' % (
                    groupcache[groupcounter - 1***REMOVED***['from'***REMOVED***, groupcache[groupcounter - 1***REMOVED***['name'***REMOVED******REMOVED***
        for k in list(groupcache[groupcounter***REMOVED***.keys(***REMOVED******REMOVED***:
            if not groupcache[groupcounter***REMOVED***[k***REMOVED***:
                del groupcache[groupcounter***REMOVED***[k***REMOVED***

        groupcache[groupcounter***REMOVED***['args'***REMOVED*** = args
        groupcache[groupcounter***REMOVED***['body'***REMOVED*** = [***REMOVED***
        groupcache[groupcounter***REMOVED***['externals'***REMOVED*** = [***REMOVED***
        groupcache[groupcounter***REMOVED***['interfaced'***REMOVED*** = [***REMOVED***
        groupcache[groupcounter***REMOVED***['vars'***REMOVED*** = {***REMOVED***
        groupcache[groupcounter***REMOVED***['entry'***REMOVED*** = {***REMOVED***
        # end of creation
        if block == 'type':
            groupcache[groupcounter***REMOVED***['varnames'***REMOVED*** = [***REMOVED***

        if case in ['call', 'callfun'***REMOVED***:  # set parents variables
            if name not in groupcache[groupcounter - 2***REMOVED***['externals'***REMOVED***:
                groupcache[groupcounter - 2***REMOVED***['externals'***REMOVED***.append(name***REMOVED***
            groupcache[groupcounter***REMOVED***['vars'***REMOVED*** = copy.deepcopy(
                groupcache[groupcounter - 2***REMOVED***['vars'***REMOVED******REMOVED***
            ***REMOVED***
                del groupcache[groupcounter***REMOVED***['vars'***REMOVED***[name***REMOVED***[
                    groupcache[groupcounter***REMOVED***['vars'***REMOVED***[name***REMOVED***['attrspec'***REMOVED***.index('external'***REMOVED******REMOVED***
            ***REMOVED***
                pass
        if block in ['function', 'subroutine'***REMOVED***:  # set global attributes
            ***REMOVED***
                groupcache[groupcounter***REMOVED***['vars'***REMOVED***[name***REMOVED*** = appenddecl(
                    groupcache[groupcounter***REMOVED***['vars'***REMOVED***[name***REMOVED***, groupcache[groupcounter - 2***REMOVED***['vars'***REMOVED***[''***REMOVED******REMOVED***
            ***REMOVED***
                pass
            if case == 'callfun':  # return type
                if result and result in groupcache[groupcounter***REMOVED***['vars'***REMOVED***:
                    if not name == result:
                        groupcache[groupcounter***REMOVED***['vars'***REMOVED***[name***REMOVED*** = appenddecl(
                            groupcache[groupcounter***REMOVED***['vars'***REMOVED***[name***REMOVED***, groupcache[groupcounter***REMOVED***['vars'***REMOVED***[result***REMOVED******REMOVED***
            # if groupcounter>1: # name is interfaced
            ***REMOVED***
                groupcache[groupcounter - 2***REMOVED***['interfaced'***REMOVED***.append(name***REMOVED***
            ***REMOVED***
                pass
        if block == 'function':
            t = typespattern[0***REMOVED***.match(m.group('before'***REMOVED*** + ' ' + name***REMOVED***
            if t:
                typespec, selector, attr, edecl = cracktypespec0(
                    t.group('this'***REMOVED***, t.group('after'***REMOVED******REMOVED***
                updatevars(typespec, selector, attr, edecl***REMOVED***

        if case in ['call', 'callfun'***REMOVED***:
            grouplist[groupcounter - 1***REMOVED***.append(groupcache[groupcounter***REMOVED******REMOVED***
            grouplist[groupcounter - 1***REMOVED***[-1***REMOVED***['body'***REMOVED*** = grouplist[groupcounter***REMOVED***
            del grouplist[groupcounter***REMOVED***
            groupcounter = groupcounter - 1  # end routine
            grouplist[groupcounter - 1***REMOVED***.append(groupcache[groupcounter***REMOVED******REMOVED***
            grouplist[groupcounter - 1***REMOVED***[-1***REMOVED***['body'***REMOVED*** = grouplist[groupcounter***REMOVED***
            del grouplist[groupcounter***REMOVED***
            groupcounter = groupcounter - 1  # end interface

    elif case == 'entry':
        name, args, result, bind = _resolvenameargspattern(m.group('after'***REMOVED******REMOVED***
        if name is not None:
            if args:
                args = rmbadname([x.strip(***REMOVED***
                                  for x in markoutercomma(args***REMOVED***.split('@,@'***REMOVED******REMOVED******REMOVED***
            else:
                args = [***REMOVED***
            assert result is None, repr(result***REMOVED***
            groupcache[groupcounter***REMOVED***['entry'***REMOVED***[name***REMOVED*** = args
            previous_context = ('entry', name, groupcounter***REMOVED***
    elif case == 'type':
        typespec, selector, attr, edecl = cracktypespec0(
            block, m.group('after'***REMOVED******REMOVED***
        last_name = updatevars(typespec, selector, attr, edecl***REMOVED***
        if last_name is not None:
            previous_context = ('variable', last_name, groupcounter***REMOVED***
    elif case in ['dimension', 'intent', 'optional', 'required', 'external', 'public', 'private', 'intrisic'***REMOVED***:
        edecl = groupcache[groupcounter***REMOVED***['vars'***REMOVED***
        ll = m.group('after'***REMOVED***.strip(***REMOVED***
        i = ll.find('::'***REMOVED***
        if i < 0 and case == 'intent':
            i = markouterparen(ll***REMOVED***.find('@***REMOVED***@'***REMOVED*** - 2
            ll = ll[:i + 1***REMOVED*** + '::' + ll[i + 1:***REMOVED***
            i = ll.find('::'***REMOVED***
            if ll[i:***REMOVED*** == '::' and 'args' in groupcache[groupcounter***REMOVED***:
                outmess('All arguments will have attribute %s%s\n' %
                        (m.group('this'***REMOVED***, ll[:i***REMOVED******REMOVED******REMOVED***
                ll = ll + ','.join(groupcache[groupcounter***REMOVED***['args'***REMOVED******REMOVED***
        if i < 0:
            i = 0
            pl = ''
        else:
            pl = ll[:i***REMOVED***.strip(***REMOVED***
            ll = ll[i + 2:***REMOVED***
        ch = markoutercomma(pl***REMOVED***.split('@,@'***REMOVED***
        if len(ch***REMOVED*** > 1:
            pl = ch[0***REMOVED***
            outmess('analyzeline: cannot handle multiple attributes without type specification. Ignoring %r.\n' % (
                ','.join(ch[1:***REMOVED******REMOVED******REMOVED******REMOVED***
        last_name = None

        for e in [x.strip(***REMOVED*** for x in markoutercomma(ll***REMOVED***.split('@,@'***REMOVED******REMOVED***:
            m1 = namepattern.match(e***REMOVED***
            if not m1:
                if case in ['public', 'private'***REMOVED***:
                    k = ''
                else:
                    print(m.groupdict(***REMOVED******REMOVED***
                    outmess('analyzeline: no name pattern found in %s statement for %s. Skipping.\n' % (
                        case, repr(e***REMOVED******REMOVED******REMOVED***
                    continue
            else:
                k = rmbadname1(m1.group('name'***REMOVED******REMOVED***
            if k not in edecl:
                edecl[k***REMOVED*** = {***REMOVED***
            if case == 'dimension':
                ap = case + m1.group('after'***REMOVED***
            if case == 'intent':
                ap = m.group('this'***REMOVED*** + pl
                if _intentcallbackpattern.match(ap***REMOVED***:
                    if k not in groupcache[groupcounter***REMOVED***['args'***REMOVED***:
                        if groupcounter > 1:
                            if '__user__' not in groupcache[groupcounter - 2***REMOVED***['name'***REMOVED***:
                                outmess(
                                    'analyzeline: missing __user__ module (could be nothing***REMOVED***\n'***REMOVED***
                            # fixes ticket 1693
                            if k != groupcache[groupcounter***REMOVED***['name'***REMOVED***:
                                outmess('analyzeline: appending intent(callback***REMOVED*** %s'
                                        ' to %s arguments\n' % (k, groupcache[groupcounter***REMOVED***['name'***REMOVED******REMOVED******REMOVED***
                                groupcache[groupcounter***REMOVED***['args'***REMOVED***.append(k***REMOVED***
                        else:
                            errmess(
                                'analyzeline: intent(callback***REMOVED*** %s is ignored' % (k***REMOVED******REMOVED***
                    else:
                        errmess('analyzeline: intent(callback***REMOVED*** %s is already'
                                ' in argument list' % (k***REMOVED******REMOVED***
            if case in ['optional', 'required', 'public', 'external', 'private', 'intrisic'***REMOVED***:
                ap = case
            if 'attrspec' in edecl[k***REMOVED***:
                edecl[k***REMOVED***['attrspec'***REMOVED***.append(ap***REMOVED***
            else:
                edecl[k***REMOVED***['attrspec'***REMOVED*** = [ap***REMOVED***
            if case == 'external':
                if groupcache[groupcounter***REMOVED***['block'***REMOVED*** == 'program':
                    outmess('analyzeline: ignoring program arguments\n'***REMOVED***
                    continue
                if k not in groupcache[groupcounter***REMOVED***['args'***REMOVED***:
                    continue
                if 'externals' not in groupcache[groupcounter***REMOVED***:
                    groupcache[groupcounter***REMOVED***['externals'***REMOVED*** = [***REMOVED***
                groupcache[groupcounter***REMOVED***['externals'***REMOVED***.append(k***REMOVED***
            last_name = k
        groupcache[groupcounter***REMOVED***['vars'***REMOVED*** = edecl
        if last_name is not None:
            previous_context = ('variable', last_name, groupcounter***REMOVED***
    elif case == 'parameter':
        edecl = groupcache[groupcounter***REMOVED***['vars'***REMOVED***
        ll = m.group('after'***REMOVED***.strip(***REMOVED***[1:-1***REMOVED***
        last_name = None
        for e in markoutercomma(ll***REMOVED***.split('@,@'***REMOVED***:
            ***REMOVED***
                k, initexpr = [x.strip(***REMOVED*** for x in e.split('='***REMOVED******REMOVED***
            ***REMOVED***
                outmess(
                    'analyzeline: could not extract name,expr in parameter statement "%s" of "%s"\n' % (e, ll***REMOVED******REMOVED***
                continue
            params = get_parameters(edecl***REMOVED***
            k = rmbadname1(k***REMOVED***
            if k not in edecl:
                edecl[k***REMOVED*** = {***REMOVED***
            if '=' in edecl[k***REMOVED*** and (not edecl[k***REMOVED***['='***REMOVED*** == initexpr***REMOVED***:
                outmess('analyzeline: Overwriting the value of parameter "%s" ("%s"***REMOVED*** with "%s".\n' % (
                    k, edecl[k***REMOVED***['='***REMOVED***, initexpr***REMOVED******REMOVED***
            t = determineexprtype(initexpr, params***REMOVED***
            if t:
                if t.get('typespec'***REMOVED*** == 'real':
                    tt = list(initexpr***REMOVED***
                    for m in real16pattern.finditer(initexpr***REMOVED***:
                        tt[m.start(***REMOVED***:m.end(***REMOVED******REMOVED*** = list(
                            initexpr[m.start(***REMOVED***:m.end(***REMOVED******REMOVED***.lower(***REMOVED***.replace('d', 'e'***REMOVED******REMOVED***
                    initexpr = ''.join(tt***REMOVED***
                elif t.get('typespec'***REMOVED*** == 'complex':
                    initexpr = initexpr[1:***REMOVED***.lower(***REMOVED***.replace('d', 'e'***REMOVED***.\
                        replace(',', '+1j*('***REMOVED***
            ***REMOVED***
                v = eval(initexpr, {***REMOVED***, params***REMOVED***
            except (SyntaxError, NameError, TypeError***REMOVED*** as msg:
                errmess('analyzeline: Failed to evaluate %r. Ignoring: %s\n'
                        % (initexpr, msg***REMOVED******REMOVED***
                continue
            edecl[k***REMOVED***['='***REMOVED*** = repr(v***REMOVED***
            if 'attrspec' in edecl[k***REMOVED***:
                edecl[k***REMOVED***['attrspec'***REMOVED***.append('parameter'***REMOVED***
            else:
                edecl[k***REMOVED***['attrspec'***REMOVED*** = ['parameter'***REMOVED***
            last_name = k
        groupcache[groupcounter***REMOVED***['vars'***REMOVED*** = edecl
        if last_name is not None:
            previous_context = ('variable', last_name, groupcounter***REMOVED***
    elif case == 'implicit':
        if m.group('after'***REMOVED***.strip(***REMOVED***.lower(***REMOVED*** == 'none':
            groupcache[groupcounter***REMOVED***['implicit'***REMOVED*** = None
        elif m.group('after'***REMOVED***:
            if 'implicit' in groupcache[groupcounter***REMOVED***:
                impl = groupcache[groupcounter***REMOVED***['implicit'***REMOVED***
            else:
                impl = {***REMOVED***
            if impl is None:
                outmess(
                    'analyzeline: Overwriting earlier "implicit none" statement.\n'***REMOVED***
                impl = {***REMOVED***
            for e in markoutercomma(m.group('after'***REMOVED******REMOVED***.split('@,@'***REMOVED***:
                decl = {***REMOVED***
                m1 = re.match(
                    r'\s*(?P<this>.*?***REMOVED***\s*(\(\s*(?P<after>[a-z-, ***REMOVED***+***REMOVED***\s*\***REMOVED***\s*|***REMOVED***\Z', e, re.I***REMOVED***
                if not m1:
                    outmess(
                        'analyzeline: could not extract info of implicit statement part "%s"\n' % (e***REMOVED******REMOVED***
                    continue
                m2 = typespattern4implicit.match(m1.group('this'***REMOVED******REMOVED***
                if not m2:
                    outmess(
                        'analyzeline: could not extract types pattern of implicit statement part "%s"\n' % (e***REMOVED******REMOVED***
                    continue
                typespec, selector, attr, edecl = cracktypespec0(
                    m2.group('this'***REMOVED***, m2.group('after'***REMOVED******REMOVED***
                kindselect, charselect, typename = cracktypespec(
                    typespec, selector***REMOVED***
                decl['typespec'***REMOVED*** = typespec
                decl['kindselector'***REMOVED*** = kindselect
                decl['charselector'***REMOVED*** = charselect
                decl['typename'***REMOVED*** = typename
                for k in list(decl.keys(***REMOVED******REMOVED***:
                    if not decl[k***REMOVED***:
                        del decl[k***REMOVED***
                for r in markoutercomma(m1.group('after'***REMOVED******REMOVED***.split('@,@'***REMOVED***:
                    if '-' in r:
                        ***REMOVED***
                            begc, endc = [x.strip(***REMOVED*** for x in r.split('-'***REMOVED******REMOVED***
                        ***REMOVED***
                            outmess(
                                'analyzeline: expected "<char>-<char>" instead of "%s" in range list of implicit statement\n' % r***REMOVED***
                            continue
                    else:
                        begc = endc = r.strip(***REMOVED***
                    if not len(begc***REMOVED*** == len(endc***REMOVED*** == 1:
                        outmess(
                            'analyzeline: expected "<char>-<char>" instead of "%s" in range list of implicit statement (2***REMOVED***\n' % r***REMOVED***
                        continue
                    for o in range(ord(begc***REMOVED***, ord(endc***REMOVED*** + 1***REMOVED***:
                        impl[chr(o***REMOVED******REMOVED*** = decl
            groupcache[groupcounter***REMOVED***['implicit'***REMOVED*** = impl
    elif case == 'data':
        ll = [***REMOVED***
        dl = ''
        il = ''
        f = 0
        fc = 1
        inp = 0
        for c in m.group('after'***REMOVED***:
            if not inp:
                if c == "'":
                    fc = not fc
                if c == '/' and fc:
                    f = f + 1
                    continue
            if c == '(':
                inp = inp + 1
            elif c == '***REMOVED***':
                inp = inp - 1
            if f == 0:
                dl = dl + c
            elif f == 1:
                il = il + c
            elif f == 2:
                dl = dl.strip(***REMOVED***
                if dl.startswith(','***REMOVED***:
                    dl = dl[1:***REMOVED***.strip(***REMOVED***
                ll.append([dl, il***REMOVED******REMOVED***
                dl = c
                il = ''
                f = 0
        if f == 2:
            dl = dl.strip(***REMOVED***
            if dl.startswith(','***REMOVED***:
                dl = dl[1:***REMOVED***.strip(***REMOVED***
            ll.append([dl, il***REMOVED******REMOVED***
        vars = {***REMOVED***
        if 'vars' in groupcache[groupcounter***REMOVED***:
            vars = groupcache[groupcounter***REMOVED***['vars'***REMOVED***
        last_name = None
        for l in ll:
            l = [x.strip(***REMOVED*** for x in l***REMOVED***
            if l[0***REMOVED***[0***REMOVED*** == ',':
                l[0***REMOVED*** = l[0***REMOVED***[1:***REMOVED***
            if l[0***REMOVED***[0***REMOVED*** == '(':
                outmess(
                    'analyzeline: implied-DO list "%s" is not supported. Skipping.\n' % l[0***REMOVED******REMOVED***
                continue
            i = 0
            j = 0
            llen = len(l[1***REMOVED******REMOVED***
            for v in rmbadname([x.strip(***REMOVED*** for x in markoutercomma(l[0***REMOVED******REMOVED***.split('@,@'***REMOVED******REMOVED******REMOVED***:
                if v[0***REMOVED*** == '(':
                    outmess(
                        'analyzeline: implied-DO list "%s" is not supported. Skipping.\n' % v***REMOVED***
                    # XXX: subsequent init expressions may get wrong values.
                    # Ignoring since data statements are irrelevant for
                    # wrapping.
                    continue
                fc = 0
                while (i < llen***REMOVED*** and (fc or not l[1***REMOVED***[i***REMOVED*** == ','***REMOVED***:
                    if l[1***REMOVED***[i***REMOVED*** == "'":
                        fc = not fc
                    i = i + 1
                i = i + 1
                if v not in vars:
                    vars[v***REMOVED*** = {***REMOVED***
                if '=' in vars[v***REMOVED*** and not vars[v***REMOVED***['='***REMOVED*** == l[1***REMOVED***[j:i - 1***REMOVED***:
                    outmess('analyzeline: changing init expression of "%s" ("%s"***REMOVED*** to "%s"\n' % (
                        v, vars[v***REMOVED***['='***REMOVED***, l[1***REMOVED***[j:i - 1***REMOVED******REMOVED******REMOVED***
                vars[v***REMOVED***['='***REMOVED*** = l[1***REMOVED***[j:i - 1***REMOVED***
                j = i
                last_name = v
        groupcache[groupcounter***REMOVED***['vars'***REMOVED*** = vars
        if last_name is not None:
            previous_context = ('variable', last_name, groupcounter***REMOVED***
    elif case == 'common':
        line = m.group('after'***REMOVED***.strip(***REMOVED***
        if not line[0***REMOVED*** == '/':
            line = '//' + line
        cl = [***REMOVED***
        f = 0
        bn = ''
        ol = ''
        for c in line:
            if c == '/':
                f = f + 1
                continue
            if f >= 3:
                bn = bn.strip(***REMOVED***
                if not bn:
                    bn = '_BLNK_'
                cl.append([bn, ol***REMOVED******REMOVED***
                f = f - 2
                bn = ''
                ol = ''
            if f % 2:
                bn = bn + c
            else:
                ol = ol + c
        bn = bn.strip(***REMOVED***
        if not bn:
            bn = '_BLNK_'
        cl.append([bn, ol***REMOVED******REMOVED***
        commonkey = {***REMOVED***
        if 'common' in groupcache[groupcounter***REMOVED***:
            commonkey = groupcache[groupcounter***REMOVED***['common'***REMOVED***
        for c in cl:
            if c[0***REMOVED*** not in commonkey:
                commonkey[c[0***REMOVED******REMOVED*** = [***REMOVED***
            for i in [x.strip(***REMOVED*** for x in markoutercomma(c[1***REMOVED******REMOVED***.split('@,@'***REMOVED******REMOVED***:
                if i:
                    commonkey[c[0***REMOVED******REMOVED***.append(i***REMOVED***
        groupcache[groupcounter***REMOVED***['common'***REMOVED*** = commonkey
        previous_context = ('common', bn, groupcounter***REMOVED***
    elif case == 'use':
        m1 = re.match(
            r'\A\s*(?P<name>\b[\w***REMOVED***+\b***REMOVED***\s*((,(\s*\bonly\b\s*:|(?P<notonly>***REMOVED******REMOVED***\s*(?P<list>.****REMOVED******REMOVED***|***REMOVED***\s*\Z', m.group('after'***REMOVED***, re.I***REMOVED***
        if m1:
            mm = m1.groupdict(***REMOVED***
            if 'use' not in groupcache[groupcounter***REMOVED***:
                groupcache[groupcounter***REMOVED***['use'***REMOVED*** = {***REMOVED***
            name = m1.group('name'***REMOVED***
            groupcache[groupcounter***REMOVED***['use'***REMOVED***[name***REMOVED*** = {***REMOVED***
            isonly = 0
            if 'list' in mm and mm['list'***REMOVED*** is not None:
                if 'notonly' in mm and mm['notonly'***REMOVED*** is None:
                    isonly = 1
                groupcache[groupcounter***REMOVED***['use'***REMOVED***[name***REMOVED***['only'***REMOVED*** = isonly
                ll = [x.strip(***REMOVED*** for x in mm['list'***REMOVED***.split(','***REMOVED******REMOVED***
                rl = {***REMOVED***
                for l in ll:
                    if '=' in l:
                        m2 = re.match(
                            r'\A\s*(?P<local>\b[\w***REMOVED***+\b***REMOVED***\s*=\s*>\s*(?P<use>\b[\w***REMOVED***+\b***REMOVED***\s*\Z', l, re.I***REMOVED***
                        if m2:
                            rl[m2.group('local'***REMOVED***.strip(***REMOVED******REMOVED*** = m2.group(
                                'use'***REMOVED***.strip(***REMOVED***
                        else:
                            outmess(
                                'analyzeline: Not local=>use pattern found in %s\n' % repr(l***REMOVED******REMOVED***
                    else:
                        rl[l***REMOVED*** = l
                    groupcache[groupcounter***REMOVED***['use'***REMOVED***[name***REMOVED***['map'***REMOVED*** = rl
            else:
                pass
        else:
            print(m.groupdict(***REMOVED******REMOVED***
            outmess('analyzeline: Could not crack the use statement.\n'***REMOVED***
    elif case in ['f2pyenhancements'***REMOVED***:
        if 'f2pyenhancements' not in groupcache[groupcounter***REMOVED***:
            groupcache[groupcounter***REMOVED***['f2pyenhancements'***REMOVED*** = {***REMOVED***
        d = groupcache[groupcounter***REMOVED***['f2pyenhancements'***REMOVED***
        if m.group('this'***REMOVED*** == 'usercode' and 'usercode' in d:
            if isinstance(d['usercode'***REMOVED***, str***REMOVED***:
                d['usercode'***REMOVED*** = [d['usercode'***REMOVED******REMOVED***
            d['usercode'***REMOVED***.append(m.group('after'***REMOVED******REMOVED***
        else:
            d[m.group('this'***REMOVED******REMOVED*** = m.group('after'***REMOVED***
    elif case == 'multiline':
        if previous_context is None:
            if verbose:
                outmess('analyzeline: No context for multiline block.\n'***REMOVED***
            return
        gc = groupcounter
        appendmultiline(groupcache[gc***REMOVED***,
                        previous_context[:2***REMOVED***,
                        m.group('this'***REMOVED******REMOVED***
    else:
        if verbose > 1:
            print(m.groupdict(***REMOVED******REMOVED***
            outmess('analyzeline: No code implemented for line.\n'***REMOVED***


def appendmultiline(group, context_name, ml***REMOVED***:
    if 'f2pymultilines' not in group:
        group['f2pymultilines'***REMOVED*** = {***REMOVED***
    d = group['f2pymultilines'***REMOVED***
    if context_name not in d:
        d[context_name***REMOVED*** = [***REMOVED***
    d[context_name***REMOVED***.append(ml***REMOVED***
    return


def cracktypespec0(typespec, ll***REMOVED***:
    selector = None
    attr = None
    if re.match(r'double\s*complex', typespec, re.I***REMOVED***:
        typespec = 'double complex'
    elif re.match(r'double\s*precision', typespec, re.I***REMOVED***:
        typespec = 'double precision'
    else:
        typespec = typespec.strip(***REMOVED***.lower(***REMOVED***
    m1 = selectpattern.match(markouterparen(ll***REMOVED******REMOVED***
    if not m1:
        outmess(
            'cracktypespec0: no kind/char_selector pattern found for line.\n'***REMOVED***
        return
    d = m1.groupdict(***REMOVED***
    for k in list(d.keys(***REMOVED******REMOVED***:
        d[k***REMOVED*** = unmarkouterparen(d[k***REMOVED******REMOVED***
    if typespec in ['complex', 'integer', 'logical', 'real', 'character', 'type'***REMOVED***:
        selector = d['this'***REMOVED***
        ll = d['after'***REMOVED***
    i = ll.find('::'***REMOVED***
    if i >= 0:
        attr = ll[:i***REMOVED***.strip(***REMOVED***
        ll = ll[i + 2:***REMOVED***
    return typespec, selector, attr, ll
#####
namepattern = re.compile(r'\s*(?P<name>\b[\w***REMOVED***+\b***REMOVED***\s*(?P<after>.****REMOVED***\s*\Z', re.I***REMOVED***
kindselector = re.compile(
    r'\s*(\(\s*(kind\s*=***REMOVED***?\s*(?P<kind>.****REMOVED***\s*\***REMOVED***|[****REMOVED***\s*(?P<kind2>.*?***REMOVED******REMOVED***\s*\Z', re.I***REMOVED***
charselector = re.compile(
    r'\s*(\((?P<lenkind>.****REMOVED***\***REMOVED***|[****REMOVED***\s*(?P<charlen>.****REMOVED******REMOVED***\s*\Z', re.I***REMOVED***
lenkindpattern = re.compile(
    r'\s*(kind\s*=\s*(?P<kind>.*?***REMOVED***\s*(@,@\s*len\s*=\s*(?P<len>.****REMOVED***|***REMOVED***|(len\s*=\s*|***REMOVED***(?P<len2>.*?***REMOVED***\s*(@,@\s*(kind\s*=\s*|***REMOVED***(?P<kind2>.****REMOVED***|***REMOVED******REMOVED***\s*\Z', re.I***REMOVED***
lenarraypattern = re.compile(
    r'\s*(@\(@\s*(?!/***REMOVED***\s*(?P<array>.*?***REMOVED***\s*@\***REMOVED***@\s*[****REMOVED***\s*(?P<len>.*?***REMOVED***|([****REMOVED***\s*(?P<len2>.*?***REMOVED***|***REMOVED***\s*(@\(@\s*(?!/***REMOVED***\s*(?P<array2>.*?***REMOVED***\s*@\***REMOVED***@|***REMOVED******REMOVED***\s*(=\s*(?P<init>.*?***REMOVED***|(@\(@|***REMOVED***/\s*(?P<init2>.*?***REMOVED***\s*/(@\***REMOVED***@|***REMOVED***|***REMOVED***\s*\Z', re.I***REMOVED***


def removespaces(expr***REMOVED***:
    expr = expr.strip(***REMOVED***
    if len(expr***REMOVED*** <= 1:
        return expr
    expr2 = expr[0***REMOVED***
    for i in range(1, len(expr***REMOVED*** - 1***REMOVED***:
        if (expr[i***REMOVED*** == ' ' and
            ((expr[i + 1***REMOVED*** in "(***REMOVED***[***REMOVED***{***REMOVED***=+-/* "***REMOVED*** or
                (expr[i - 1***REMOVED*** in "(***REMOVED***[***REMOVED***{***REMOVED***=+-/* "***REMOVED******REMOVED******REMOVED***:
            continue
        expr2 = expr2 + expr[i***REMOVED***
    expr2 = expr2 + expr[-1***REMOVED***
    return expr2


def markinnerspaces(line***REMOVED***:
    l = ''
    f = 0
    cc = '\''
    cb = ''
    for c in line:
        if cb == '\\' and c in ['\\', '\'', '"'***REMOVED***:
            l = l + c
            cb = c
            continue
        if f == 0 and c in ['\'', '"'***REMOVED***:
            cc = c
        if c == cc:
            f = f + 1
        elif c == cc:
            f = f - 1
        elif c == ' ' and f == 1:
            l = l + '@_@'
            continue
        l = l + c
        cb = c
    return l


def updatevars(typespec, selector, attrspec, entitydecl***REMOVED***:
    global groupcache, groupcounter

    last_name = None
    kindselect, charselect, typename = cracktypespec(typespec, selector***REMOVED***
    if attrspec:
        attrspec = [x.strip(***REMOVED*** for x in markoutercomma(attrspec***REMOVED***.split('@,@'***REMOVED******REMOVED***
        l = [***REMOVED***
        c = re.compile(r'(?P<start>[a-zA-Z***REMOVED***+***REMOVED***'***REMOVED***
        for a in attrspec:
            if not a:
                continue
            m = c.match(a***REMOVED***
            if m:
                s = m.group('start'***REMOVED***.lower(***REMOVED***
                a = s + a[len(s***REMOVED***:***REMOVED***
            l.append(a***REMOVED***
        attrspec = l
    el = [x.strip(***REMOVED*** for x in markoutercomma(entitydecl***REMOVED***.split('@,@'***REMOVED******REMOVED***
    el1 = [***REMOVED***
    for e in el:
        for e1 in [x.strip(***REMOVED*** for x in markoutercomma(removespaces(markinnerspaces(e***REMOVED******REMOVED***, comma=' '***REMOVED***.split('@ @'***REMOVED******REMOVED***:
            if e1:
                el1.append(e1.replace('@_@', ' '***REMOVED******REMOVED***
    for e in el1:
        m = namepattern.match(e***REMOVED***
        if not m:
            outmess(
                'updatevars: no name pattern found for entity=%s. Skipping.\n' % (repr(e***REMOVED******REMOVED******REMOVED***
            continue
        ename = rmbadname1(m.group('name'***REMOVED******REMOVED***
        edecl = {***REMOVED***
        if ename in groupcache[groupcounter***REMOVED***['vars'***REMOVED***:
            edecl = groupcache[groupcounter***REMOVED***['vars'***REMOVED***[ename***REMOVED***.copy(***REMOVED***
            not_has_typespec = 'typespec' not in edecl
            if not_has_typespec:
                edecl['typespec'***REMOVED*** = typespec
            elif typespec and (not typespec == edecl['typespec'***REMOVED******REMOVED***:
                outmess('updatevars: attempt to change the type of "%s" ("%s"***REMOVED*** to "%s". Ignoring.\n' % (
                    ename, edecl['typespec'***REMOVED***, typespec***REMOVED******REMOVED***
            if 'kindselector' not in edecl:
                edecl['kindselector'***REMOVED*** = copy.copy(kindselect***REMOVED***
            elif kindselect:
                for k in list(kindselect.keys(***REMOVED******REMOVED***:
                    if k in edecl['kindselector'***REMOVED*** and (not kindselect[k***REMOVED*** == edecl['kindselector'***REMOVED***[k***REMOVED******REMOVED***:
                        outmess('updatevars: attempt to change the kindselector "%s" of "%s" ("%s"***REMOVED*** to "%s". Ignoring.\n' % (
                            k, ename, edecl['kindselector'***REMOVED***[k***REMOVED***, kindselect[k***REMOVED******REMOVED******REMOVED***
                    else:
                        edecl['kindselector'***REMOVED***[k***REMOVED*** = copy.copy(kindselect[k***REMOVED******REMOVED***
            if 'charselector' not in edecl and charselect:
                if not_has_typespec:
                    edecl['charselector'***REMOVED*** = charselect
                else:
                    errmess('updatevars:%s: attempt to change empty charselector to %r. Ignoring.\n'
                            % (ename, charselect***REMOVED******REMOVED***
            elif charselect:
                for k in list(charselect.keys(***REMOVED******REMOVED***:
                    if k in edecl['charselector'***REMOVED*** and (not charselect[k***REMOVED*** == edecl['charselector'***REMOVED***[k***REMOVED******REMOVED***:
                        outmess('updatevars: attempt to change the charselector "%s" of "%s" ("%s"***REMOVED*** to "%s". Ignoring.\n' % (
                            k, ename, edecl['charselector'***REMOVED***[k***REMOVED***, charselect[k***REMOVED******REMOVED******REMOVED***
                    else:
                        edecl['charselector'***REMOVED***[k***REMOVED*** = copy.copy(charselect[k***REMOVED******REMOVED***
            if 'typename' not in edecl:
                edecl['typename'***REMOVED*** = typename
            elif typename and (not edecl['typename'***REMOVED*** == typename***REMOVED***:
                outmess('updatevars: attempt to change the typename of "%s" ("%s"***REMOVED*** to "%s". Ignoring.\n' % (
                    ename, edecl['typename'***REMOVED***, typename***REMOVED******REMOVED***
            if 'attrspec' not in edecl:
                edecl['attrspec'***REMOVED*** = copy.copy(attrspec***REMOVED***
            elif attrspec:
                for a in attrspec:
                    if a not in edecl['attrspec'***REMOVED***:
                        edecl['attrspec'***REMOVED***.append(a***REMOVED***
        else:
            edecl['typespec'***REMOVED*** = copy.copy(typespec***REMOVED***
            edecl['kindselector'***REMOVED*** = copy.copy(kindselect***REMOVED***
            edecl['charselector'***REMOVED*** = copy.copy(charselect***REMOVED***
            edecl['typename'***REMOVED*** = typename
            edecl['attrspec'***REMOVED*** = copy.copy(attrspec***REMOVED***
        if m.group('after'***REMOVED***:
            m1 = lenarraypattern.match(markouterparen(m.group('after'***REMOVED******REMOVED******REMOVED***
            if m1:
                d1 = m1.groupdict(***REMOVED***
                for lk in ['len', 'array', 'init'***REMOVED***:
                    if d1[lk + '2'***REMOVED*** is not None:
                        d1[lk***REMOVED*** = d1[lk + '2'***REMOVED***
                        del d1[lk + '2'***REMOVED***
                for k in list(d1.keys(***REMOVED******REMOVED***:
                    if d1[k***REMOVED*** is not None:
                        d1[k***REMOVED*** = unmarkouterparen(d1[k***REMOVED******REMOVED***
                    else:
                        del d1[k***REMOVED***
                if 'len' in d1 and 'array' in d1:
                    if d1['len'***REMOVED*** == '':
                        d1['len'***REMOVED*** = d1['array'***REMOVED***
                        del d1['array'***REMOVED***
                    else:
                        d1['array'***REMOVED*** = d1['array'***REMOVED*** + ',' + d1['len'***REMOVED***
                        del d1['len'***REMOVED***
                        errmess('updatevars: "%s %s" is mapped to "%s %s(%s***REMOVED***"\n' % (
                            typespec, e, typespec, ename, d1['array'***REMOVED******REMOVED******REMOVED***
                if 'array' in d1:
                    dm = 'dimension(%s***REMOVED***' % d1['array'***REMOVED***
                    if 'attrspec' not in edecl or (not edecl['attrspec'***REMOVED******REMOVED***:
                        edecl['attrspec'***REMOVED*** = [dm***REMOVED***
                    else:
                        edecl['attrspec'***REMOVED***.append(dm***REMOVED***
                        for dm1 in edecl['attrspec'***REMOVED***:
                            if dm1[:9***REMOVED*** == 'dimension' and dm1 != dm:
                                del edecl['attrspec'***REMOVED***[-1***REMOVED***
                                errmess('updatevars:%s: attempt to change %r to %r. Ignoring.\n'
                                        % (ename, dm1, dm***REMOVED******REMOVED***
                                break

                if 'len' in d1:
                    if typespec in ['complex', 'integer', 'logical', 'real'***REMOVED***:
                        if ('kindselector' not in edecl***REMOVED*** or (not edecl['kindselector'***REMOVED******REMOVED***:
                            edecl['kindselector'***REMOVED*** = {***REMOVED***
                        edecl['kindselector'***REMOVED***['*'***REMOVED*** = d1['len'***REMOVED***
                    elif typespec == 'character':
                        if ('charselector' not in edecl***REMOVED*** or (not edecl['charselector'***REMOVED******REMOVED***:
                            edecl['charselector'***REMOVED*** = {***REMOVED***
                        if 'len' in edecl['charselector'***REMOVED***:
                            del edecl['charselector'***REMOVED***['len'***REMOVED***
                        edecl['charselector'***REMOVED***['*'***REMOVED*** = d1['len'***REMOVED***
                if 'init' in d1:
                    if '=' in edecl and (not edecl['='***REMOVED*** == d1['init'***REMOVED******REMOVED***:
                        outmess('updatevars: attempt to change the init expression of "%s" ("%s"***REMOVED*** to "%s". Ignoring.\n' % (
                            ename, edecl['='***REMOVED***, d1['init'***REMOVED******REMOVED******REMOVED***
                    else:
                        edecl['='***REMOVED*** = d1['init'***REMOVED***
            else:
                outmess('updatevars: could not crack entity declaration "%s". Ignoring.\n' % (
                    ename + m.group('after'***REMOVED******REMOVED******REMOVED***
        for k in list(edecl.keys(***REMOVED******REMOVED***:
            if not edecl[k***REMOVED***:
                del edecl[k***REMOVED***
        groupcache[groupcounter***REMOVED***['vars'***REMOVED***[ename***REMOVED*** = edecl
        if 'varnames' in groupcache[groupcounter***REMOVED***:
            groupcache[groupcounter***REMOVED***['varnames'***REMOVED***.append(ename***REMOVED***
        last_name = ename
    return last_name


def cracktypespec(typespec, selector***REMOVED***:
    kindselect = None
    charselect = None
    typename = None
    if selector:
        if typespec in ['complex', 'integer', 'logical', 'real'***REMOVED***:
            kindselect = kindselector.match(selector***REMOVED***
            if not kindselect:
                outmess(
                    'cracktypespec: no kindselector pattern found for %s\n' % (repr(selector***REMOVED******REMOVED******REMOVED***
                return
            kindselect = kindselect.groupdict(***REMOVED***
            kindselect['*'***REMOVED*** = kindselect['kind2'***REMOVED***
            del kindselect['kind2'***REMOVED***
            for k in list(kindselect.keys(***REMOVED******REMOVED***:
                if not kindselect[k***REMOVED***:
                    del kindselect[k***REMOVED***
            for k, i in list(kindselect.items(***REMOVED******REMOVED***:
                kindselect[k***REMOVED*** = rmbadname1(i***REMOVED***
        elif typespec == 'character':
            charselect = charselector.match(selector***REMOVED***
            if not charselect:
                outmess(
                    'cracktypespec: no charselector pattern found for %s\n' % (repr(selector***REMOVED******REMOVED******REMOVED***
                return
            charselect = charselect.groupdict(***REMOVED***
            charselect['*'***REMOVED*** = charselect['charlen'***REMOVED***
            del charselect['charlen'***REMOVED***
            if charselect['lenkind'***REMOVED***:
                lenkind = lenkindpattern.match(
                    markoutercomma(charselect['lenkind'***REMOVED******REMOVED******REMOVED***
                lenkind = lenkind.groupdict(***REMOVED***
                for lk in ['len', 'kind'***REMOVED***:
                    if lenkind[lk + '2'***REMOVED***:
                        lenkind[lk***REMOVED*** = lenkind[lk + '2'***REMOVED***
                    charselect[lk***REMOVED*** = lenkind[lk***REMOVED***
                    del lenkind[lk + '2'***REMOVED***
            del charselect['lenkind'***REMOVED***
            for k in list(charselect.keys(***REMOVED******REMOVED***:
                if not charselect[k***REMOVED***:
                    del charselect[k***REMOVED***
            for k, i in list(charselect.items(***REMOVED******REMOVED***:
                charselect[k***REMOVED*** = rmbadname1(i***REMOVED***
        elif typespec == 'type':
            typename = re.match(r'\s*\(\s*(?P<name>\w+***REMOVED***\s*\***REMOVED***', selector, re.I***REMOVED***
            if typename:
                typename = typename.group('name'***REMOVED***
            else:
                outmess('cracktypespec: no typename found in %s\n' %
                        (repr(typespec + selector***REMOVED******REMOVED******REMOVED***
        else:
            outmess('cracktypespec: no selector used for %s\n' %
                    (repr(selector***REMOVED******REMOVED******REMOVED***
    return kindselect, charselect, typename
######


def setattrspec(decl, attr, force=0***REMOVED***:
    if not decl:
        decl = {***REMOVED***
    if not attr:
        return decl
    if 'attrspec' not in decl:
        decl['attrspec'***REMOVED*** = [attr***REMOVED***
        return decl
    if force:
        decl['attrspec'***REMOVED***.append(attr***REMOVED***
    if attr in decl['attrspec'***REMOVED***:
        return decl
    if attr == 'static' and 'automatic' not in decl['attrspec'***REMOVED***:
        decl['attrspec'***REMOVED***.append(attr***REMOVED***
    elif attr == 'automatic' and 'static' not in decl['attrspec'***REMOVED***:
        decl['attrspec'***REMOVED***.append(attr***REMOVED***
    elif attr == 'public' and 'private' not in decl['attrspec'***REMOVED***:
        decl['attrspec'***REMOVED***.append(attr***REMOVED***
    elif attr == 'private' and 'public' not in decl['attrspec'***REMOVED***:
        decl['attrspec'***REMOVED***.append(attr***REMOVED***
    else:
        decl['attrspec'***REMOVED***.append(attr***REMOVED***
    return decl


def setkindselector(decl, sel, force=0***REMOVED***:
    if not decl:
        decl = {***REMOVED***
    if not sel:
        return decl
    if 'kindselector' not in decl:
        decl['kindselector'***REMOVED*** = sel
        return decl
    for k in list(sel.keys(***REMOVED******REMOVED***:
        if force or k not in decl['kindselector'***REMOVED***:
            decl['kindselector'***REMOVED***[k***REMOVED*** = sel[k***REMOVED***
    return decl


def setcharselector(decl, sel, force=0***REMOVED***:
    if not decl:
        decl = {***REMOVED***
    if not sel:
        return decl
    if 'charselector' not in decl:
        decl['charselector'***REMOVED*** = sel
        return decl
    for k in list(sel.keys(***REMOVED******REMOVED***:
        if force or k not in decl['charselector'***REMOVED***:
            decl['charselector'***REMOVED***[k***REMOVED*** = sel[k***REMOVED***
    return decl


def getblockname(block, unknown='unknown'***REMOVED***:
    if 'name' in block:
        return block['name'***REMOVED***
    return unknown

# post processing


def setmesstext(block***REMOVED***:
    global filepositiontext

    ***REMOVED***
        filepositiontext = 'In: %s:%s\n' % (block['from'***REMOVED***, block['name'***REMOVED******REMOVED***
    ***REMOVED***
        pass


def get_usedict(block***REMOVED***:
    usedict = {***REMOVED***
    if 'parent_block' in block:
        usedict = get_usedict(block['parent_block'***REMOVED******REMOVED***
    if 'use' in block:
        usedict.update(block['use'***REMOVED******REMOVED***
    return usedict


def get_useparameters(block, param_map=None***REMOVED***:
    global f90modulevars

    if param_map is None:
        param_map = {***REMOVED***
    usedict = get_usedict(block***REMOVED***
    if not usedict:
        return param_map
    for usename, mapping in list(usedict.items(***REMOVED******REMOVED***:
        usename = usename.lower(***REMOVED***
        if usename not in f90modulevars:
            outmess('get_useparameters: no module %s info used by %s\n' %
                    (usename, block.get('name'***REMOVED******REMOVED******REMOVED***
            continue
        mvars = f90modulevars[usename***REMOVED***
        params = get_parameters(mvars***REMOVED***
        if not params:
            continue
        # XXX: apply mapping
        if mapping:
            errmess('get_useparameters: mapping for %s not impl.' % (mapping***REMOVED******REMOVED***
        for k, v in list(params.items(***REMOVED******REMOVED***:
            if k in param_map:
                outmess('get_useparameters: overriding parameter %s with'
                        ' value from module %s' % (repr(k***REMOVED***, repr(usename***REMOVED******REMOVED******REMOVED***
            param_map[k***REMOVED*** = v

    return param_map


def postcrack2(block, tab='', param_map=None***REMOVED***:
    global f90modulevars

    if not f90modulevars:
        return block
    if isinstance(block, list***REMOVED***:
        ret = [***REMOVED***
        for g in block:
            g = postcrack2(g, tab=tab + '\t', param_map=param_map***REMOVED***
            ret.append(g***REMOVED***
        return ret
    setmesstext(block***REMOVED***
    outmess('%sBlock: %s\n' % (tab, block['name'***REMOVED******REMOVED***, 0***REMOVED***

    if param_map is None:
        param_map = get_useparameters(block***REMOVED***

    if param_map is not None and 'vars' in block:
        vars = block['vars'***REMOVED***
        for n in list(vars.keys(***REMOVED******REMOVED***:
            var = vars[n***REMOVED***
            if 'kindselector' in var:
                kind = var['kindselector'***REMOVED***
                if 'kind' in kind:
                    val = kind['kind'***REMOVED***
                    if val in param_map:
                        kind['kind'***REMOVED*** = param_map[val***REMOVED***
    new_body = [***REMOVED***
    for b in block['body'***REMOVED***:
        b = postcrack2(b, tab=tab + '\t', param_map=param_map***REMOVED***
        new_body.append(b***REMOVED***
    block['body'***REMOVED*** = new_body

    return block


def postcrack(block, args=None, tab=''***REMOVED***:
    ***REMOVED***
    TODO:
          function return values
          determine expression types if in argument list
    ***REMOVED***
    global usermodules, onlyfunctions

    if isinstance(block, list***REMOVED***:
        gret = [***REMOVED***
        uret = [***REMOVED***
        for g in block:
            setmesstext(g***REMOVED***
            g = postcrack(g, tab=tab + '\t'***REMOVED***
            # sort user routines to appear first
            if 'name' in g and '__user__' in g['name'***REMOVED***:
                uret.append(g***REMOVED***
            else:
                gret.append(g***REMOVED***
        return uret + gret
    setmesstext(block***REMOVED***
    if not isinstance(block, dict***REMOVED*** and 'block' not in block:
        raise Exception('postcrack: Expected block dictionary instead of ' +
                        str(block***REMOVED******REMOVED***
    if 'name' in block and not block['name'***REMOVED*** == 'unknown_interface':
        outmess('%sBlock: %s\n' % (tab, block['name'***REMOVED******REMOVED***, 0***REMOVED***
    block = analyzeargs(block***REMOVED***
    block = analyzecommon(block***REMOVED***
    block['vars'***REMOVED*** = analyzevars(block***REMOVED***
    block['sortvars'***REMOVED*** = sortvarnames(block['vars'***REMOVED******REMOVED***
    if 'args' in block and block['args'***REMOVED***:
        args = block['args'***REMOVED***
    block['body'***REMOVED*** = analyzebody(block, args, tab=tab***REMOVED***

    userisdefined = [***REMOVED***
    if 'use' in block:
        useblock = block['use'***REMOVED***
        for k in list(useblock.keys(***REMOVED******REMOVED***:
            if '__user__' in k:
                userisdefined.append(k***REMOVED***
    else:
        useblock = {***REMOVED***
    name = ''
    if 'name' in block:
        name = block['name'***REMOVED***
    # and not userisdefined: # Build a __user__ module
    if 'externals' in block and block['externals'***REMOVED***:
        interfaced = [***REMOVED***
        if 'interfaced' in block:
            interfaced = block['interfaced'***REMOVED***
        mvars = copy.copy(block['vars'***REMOVED******REMOVED***
        if name:
            mname = name + '__user__routines'
        else:
            mname = 'unknown__user__routines'
        if mname in userisdefined:
            i = 1
            while '%s_%i' % (mname, i***REMOVED*** in userisdefined:
                i = i + 1
            mname = '%s_%i' % (mname, i***REMOVED***
        interface = {'block': 'interface', 'body': [***REMOVED***,
                     'vars': {***REMOVED***, 'name': name + '_user_interface'***REMOVED***
        for e in block['externals'***REMOVED***:
            if e in interfaced:
                edef = [***REMOVED***
                j = -1
                for b in block['body'***REMOVED***:
                    j = j + 1
                    if b['block'***REMOVED*** == 'interface':
                        i = -1
                        for bb in b['body'***REMOVED***:
                            i = i + 1
                            if 'name' in bb and bb['name'***REMOVED*** == e:
                                edef = copy.copy(bb***REMOVED***
                                del b['body'***REMOVED***[i***REMOVED***
                                break
                        if edef:
                            if not b['body'***REMOVED***:
                                del block['body'***REMOVED***[j***REMOVED***
                            del interfaced[interfaced.index(e***REMOVED******REMOVED***
                            break
                interface['body'***REMOVED***.append(edef***REMOVED***
            else:
                if e in mvars and not isexternal(mvars[e***REMOVED******REMOVED***:
                    interface['vars'***REMOVED***[e***REMOVED*** = mvars[e***REMOVED***
        if interface['vars'***REMOVED*** or interface['body'***REMOVED***:
            block['interfaced'***REMOVED*** = interfaced
            mblock = {'block': 'python module', 'body': [
                interface***REMOVED***, 'vars': {***REMOVED***, 'name': mname, 'interfaced': block['externals'***REMOVED******REMOVED***
            useblock[mname***REMOVED*** = {***REMOVED***
            usermodules.append(mblock***REMOVED***
    if useblock:
        block['use'***REMOVED*** = useblock
    return block


def sortvarnames(vars***REMOVED***:
    indep = [***REMOVED***
    dep = [***REMOVED***
    for v in list(vars.keys(***REMOVED******REMOVED***:
        if 'depend' in vars[v***REMOVED*** and vars[v***REMOVED***['depend'***REMOVED***:
            dep.append(v***REMOVED***
        else:
            indep.append(v***REMOVED***
    n = len(dep***REMOVED***
    i = 0
    while dep:  # XXX: How to catch dependence cycles correctly?
        v = dep[0***REMOVED***
        fl = 0
        for w in dep[1:***REMOVED***:
            if w in vars[v***REMOVED***['depend'***REMOVED***:
                fl = 1
                break
        if fl:
            dep = dep[1:***REMOVED*** + [v***REMOVED***
            i = i + 1
            if i > n:
                errmess('sortvarnames: failed to compute dependencies because'
                        ' of cyclic dependencies between '
                        + ', '.join(dep***REMOVED*** + '\n'***REMOVED***
                indep = indep + dep
                break
        else:
            indep.append(v***REMOVED***
            dep = dep[1:***REMOVED***
            n = len(dep***REMOVED***
            i = 0
    return indep


def analyzecommon(block***REMOVED***:
    if not hascommon(block***REMOVED***:
        return block
    commonvars = [***REMOVED***
    for k in list(block['common'***REMOVED***.keys(***REMOVED******REMOVED***:
        comvars = [***REMOVED***
        for e in block['common'***REMOVED***[k***REMOVED***:
            m = re.match(
                r'\A\s*\b(?P<name>.*?***REMOVED***\b\s*(\((?P<dims>.*?***REMOVED***\***REMOVED***|***REMOVED***\s*\Z', e, re.I***REMOVED***
            if m:
                dims = [***REMOVED***
                if m.group('dims'***REMOVED***:
                    dims = [x.strip(***REMOVED***
                            for x in markoutercomma(m.group('dims'***REMOVED******REMOVED***.split('@,@'***REMOVED******REMOVED***
                n = m.group('name'***REMOVED***.strip(***REMOVED***
                if n in block['vars'***REMOVED***:
                    if 'attrspec' in block['vars'***REMOVED***[n***REMOVED***:
                        block['vars'***REMOVED***[n***REMOVED***['attrspec'***REMOVED***.append(
                            'dimension(%s***REMOVED***' % (','.join(dims***REMOVED******REMOVED******REMOVED***
                    else:
                        block['vars'***REMOVED***[n***REMOVED***['attrspec'***REMOVED*** = [
                            'dimension(%s***REMOVED***' % (','.join(dims***REMOVED******REMOVED******REMOVED***
                else:
                    if dims:
                        block['vars'***REMOVED***[n***REMOVED*** = {
                            'attrspec': ['dimension(%s***REMOVED***' % (','.join(dims***REMOVED******REMOVED******REMOVED******REMOVED***
                    else:
                        block['vars'***REMOVED***[n***REMOVED*** = {***REMOVED***
                if n not in commonvars:
                    commonvars.append(n***REMOVED***
            else:
                n = e
                errmess(
                    'analyzecommon: failed to extract "<name>[(<dims>***REMOVED******REMOVED***" from "%s" in common /%s/.\n' % (e, k***REMOVED******REMOVED***
            comvars.append(n***REMOVED***
        block['common'***REMOVED***[k***REMOVED*** = comvars
    if 'commonvars' not in block:
        block['commonvars'***REMOVED*** = commonvars
    else:
        block['commonvars'***REMOVED*** = block['commonvars'***REMOVED*** + commonvars
    return block


def analyzebody(block, args, tab=''***REMOVED***:
    global usermodules, skipfuncs, onlyfuncs, f90modulevars

    setmesstext(block***REMOVED***
    body = [***REMOVED***
    for b in block['body'***REMOVED***:
        b['parent_block'***REMOVED*** = block
        if b['block'***REMOVED*** in ['function', 'subroutine'***REMOVED***:
            if args is not None and b['name'***REMOVED*** not in args:
                continue
            else:
                as_ = b['args'***REMOVED***
            if b['name'***REMOVED*** in skipfuncs:
                continue
            if onlyfuncs and b['name'***REMOVED*** not in onlyfuncs:
                continue
            b['saved_interface'***REMOVED*** = crack2fortrangen(
                b, '\n' + ' ' * 6, as_interface=True***REMOVED***

        else:
            as_ = args
        b = postcrack(b, as_, tab=tab + '\t'***REMOVED***
        if b['block'***REMOVED*** == 'interface' and not b['body'***REMOVED***:
            if 'f2pyenhancements' not in b:
                continue
        if b['block'***REMOVED***.replace(' ', ''***REMOVED*** == 'pythonmodule':
            usermodules.append(b***REMOVED***
        else:
            if b['block'***REMOVED*** == 'module':
                f90modulevars[b['name'***REMOVED******REMOVED*** = b['vars'***REMOVED***
            body.append(b***REMOVED***
    return body


def buildimplicitrules(block***REMOVED***:
    setmesstext(block***REMOVED***
    implicitrules = defaultimplicitrules
    attrrules = {***REMOVED***
    if 'implicit' in block:
        if block['implicit'***REMOVED*** is None:
            implicitrules = None
            if verbose > 1:
                outmess(
                    'buildimplicitrules: no implicit rules for routine %s.\n' % repr(block['name'***REMOVED******REMOVED******REMOVED***
        else:
            for k in list(block['implicit'***REMOVED***.keys(***REMOVED******REMOVED***:
                if block['implicit'***REMOVED***[k***REMOVED***.get('typespec'***REMOVED*** not in ['static', 'automatic'***REMOVED***:
                    implicitrules[k***REMOVED*** = block['implicit'***REMOVED***[k***REMOVED***
                else:
                    attrrules[k***REMOVED*** = block['implicit'***REMOVED***[k***REMOVED***['typespec'***REMOVED***
    return implicitrules, attrrules


def myeval(e, g=None, l=None***REMOVED***:
    r = eval(e, g, l***REMOVED***
    if type(r***REMOVED*** in [type(0***REMOVED***, type(0.0***REMOVED******REMOVED***:
        return r
    raise ValueError('r=%r' % (r***REMOVED******REMOVED***

getlincoef_re_1 = re.compile(r'\A\b\w+\b\Z', re.I***REMOVED***


def getlincoef(e, xset***REMOVED***:  # e = a*x+b ; x in xset
    ***REMOVED***
        c = int(myeval(e, {***REMOVED***, {***REMOVED******REMOVED******REMOVED***
        return 0, c, None
    ***REMOVED***
        pass
    if getlincoef_re_1.match(e***REMOVED***:
        return 1, 0, e
    len_e = len(e***REMOVED***
    for x in xset:
        if len(x***REMOVED*** > len_e:
            continue
        if re.search(r'\w\s*\([^***REMOVED******REMOVED****\b' + x + r'\b', e***REMOVED***:
            # skip function calls having x as an argument, e.g max(1, x***REMOVED***
            continue
        re_1 = re.compile(r'(?P<before>.*?***REMOVED***\b' + x + r'\b(?P<after>.****REMOVED***', re.I***REMOVED***
        m = re_1.match(e***REMOVED***
        if m:
            ***REMOVED***
                m1 = re_1.match(e***REMOVED***
                while m1:
                    ee = '%s(%s***REMOVED***%s' % (
                        m1.group('before'***REMOVED***, 0, m1.group('after'***REMOVED******REMOVED***
                    m1 = re_1.match(ee***REMOVED***
                b = myeval(ee, {***REMOVED***, {***REMOVED******REMOVED***
                m1 = re_1.match(e***REMOVED***
                while m1:
                    ee = '%s(%s***REMOVED***%s' % (
                        m1.group('before'***REMOVED***, 1, m1.group('after'***REMOVED******REMOVED***
                    m1 = re_1.match(ee***REMOVED***
                a = myeval(ee, {***REMOVED***, {***REMOVED******REMOVED*** - b
                m1 = re_1.match(e***REMOVED***
                while m1:
                    ee = '%s(%s***REMOVED***%s' % (
                        m1.group('before'***REMOVED***, 0.5, m1.group('after'***REMOVED******REMOVED***
                    m1 = re_1.match(ee***REMOVED***
                c = myeval(ee, {***REMOVED***, {***REMOVED******REMOVED***
                # computing another point to be sure that expression is linear
                m1 = re_1.match(e***REMOVED***
                while m1:
                    ee = '%s(%s***REMOVED***%s' % (
                        m1.group('before'***REMOVED***, 1.5, m1.group('after'***REMOVED******REMOVED***
                    m1 = re_1.match(ee***REMOVED***
                c2 = myeval(ee, {***REMOVED***, {***REMOVED******REMOVED***
                if (a * 0.5 + b == c and a * 1.5 + b == c2***REMOVED***:
                    return a, b, x
            ***REMOVED***
                pass
            break
    return None, None, None

_varname_match = re.compile(r'\A[a-z***REMOVED***\w*\Z'***REMOVED***.match


def getarrlen(dl, args, star='*'***REMOVED***:
    edl = [***REMOVED***
    ***REMOVED***
        edl.append(myeval(dl[0***REMOVED***, {***REMOVED***, {***REMOVED******REMOVED******REMOVED***
    ***REMOVED***
        edl.append(dl[0***REMOVED******REMOVED***
    ***REMOVED***
        edl.append(myeval(dl[1***REMOVED***, {***REMOVED***, {***REMOVED******REMOVED******REMOVED***
    ***REMOVED***
        edl.append(dl[1***REMOVED******REMOVED***
    if isinstance(edl[0***REMOVED***, int***REMOVED***:
        p1 = 1 - edl[0***REMOVED***
        if p1 == 0:
            d = str(dl[1***REMOVED******REMOVED***
        elif p1 < 0:
            d = '%s-%s' % (dl[1***REMOVED***, -p1***REMOVED***
        else:
            d = '%s+%s' % (dl[1***REMOVED***, p1***REMOVED***
    elif isinstance(edl[1***REMOVED***, int***REMOVED***:
        p1 = 1 + edl[1***REMOVED***
        if p1 == 0:
            d = '-(%s***REMOVED***' % (dl[0***REMOVED******REMOVED***
        else:
            d = '%s-(%s***REMOVED***' % (p1, dl[0***REMOVED******REMOVED***
    else:
        d = '%s-(%s***REMOVED***+1' % (dl[1***REMOVED***, dl[0***REMOVED******REMOVED***
    ***REMOVED***
        return repr(myeval(d, {***REMOVED***, {***REMOVED******REMOVED******REMOVED***, None, None
    ***REMOVED***
        pass
    d1, d2 = getlincoef(dl[0***REMOVED***, args***REMOVED***, getlincoef(dl[1***REMOVED***, args***REMOVED***
    if None not in [d1[0***REMOVED***, d2[0***REMOVED******REMOVED***:
        if (d1[0***REMOVED***, d2[0***REMOVED******REMOVED*** == (0, 0***REMOVED***:
            return repr(d2[1***REMOVED*** - d1[1***REMOVED*** + 1***REMOVED***, None, None
        b = d2[1***REMOVED*** - d1[1***REMOVED*** + 1
        d1 = (d1[0***REMOVED***, 0, d1[2***REMOVED******REMOVED***
        d2 = (d2[0***REMOVED***, b, d2[2***REMOVED******REMOVED***
        if d1[0***REMOVED*** == 0 and d2[2***REMOVED*** in args:
            if b < 0:
                return '%s * %s - %s' % (d2[0***REMOVED***, d2[2***REMOVED***, -b***REMOVED***, d2[2***REMOVED***, '+%s***REMOVED***/(%s***REMOVED***' % (-b, d2[0***REMOVED******REMOVED***
            elif b:
                return '%s * %s + %s' % (d2[0***REMOVED***, d2[2***REMOVED***, b***REMOVED***, d2[2***REMOVED***, '-%s***REMOVED***/(%s***REMOVED***' % (b, d2[0***REMOVED******REMOVED***
            else:
                return '%s * %s' % (d2[0***REMOVED***, d2[2***REMOVED******REMOVED***, d2[2***REMOVED***, '***REMOVED***/(%s***REMOVED***' % (d2[0***REMOVED******REMOVED***
        if d2[0***REMOVED*** == 0 and d1[2***REMOVED*** in args:

            if b < 0:
                return '%s * %s - %s' % (-d1[0***REMOVED***, d1[2***REMOVED***, -b***REMOVED***, d1[2***REMOVED***, '+%s***REMOVED***/(%s***REMOVED***' % (-b, -d1[0***REMOVED******REMOVED***
            elif b:
                return '%s * %s + %s' % (-d1[0***REMOVED***, d1[2***REMOVED***, b***REMOVED***, d1[2***REMOVED***, '-%s***REMOVED***/(%s***REMOVED***' % (b, -d1[0***REMOVED******REMOVED***
            else:
                return '%s * %s' % (-d1[0***REMOVED***, d1[2***REMOVED******REMOVED***, d1[2***REMOVED***, '***REMOVED***/(%s***REMOVED***' % (-d1[0***REMOVED******REMOVED***
        if d1[2***REMOVED*** == d2[2***REMOVED*** and d1[2***REMOVED*** in args:
            a = d2[0***REMOVED*** - d1[0***REMOVED***
            if not a:
                return repr(b***REMOVED***, None, None
            if b < 0:
                return '%s * %s - %s' % (a, d1[2***REMOVED***, -b***REMOVED***, d2[2***REMOVED***, '+%s***REMOVED***/(%s***REMOVED***' % (-b, a***REMOVED***
            elif b:
                return '%s * %s + %s' % (a, d1[2***REMOVED***, b***REMOVED***, d2[2***REMOVED***, '-%s***REMOVED***/(%s***REMOVED***' % (b, a***REMOVED***
            else:
                return '%s * %s' % (a, d1[2***REMOVED******REMOVED***, d2[2***REMOVED***, '***REMOVED***/(%s***REMOVED***' % (a***REMOVED***
        if d1[0***REMOVED*** == d2[0***REMOVED*** == 1:
            c = str(d1[2***REMOVED******REMOVED***
            if c not in args:
                if _varname_match(c***REMOVED***:
                    outmess('\tgetarrlen:variable "%s" undefined\n' % (c***REMOVED******REMOVED***
                c = '(%s***REMOVED***' % c
            if b == 0:
                d = '%s-%s' % (d2[2***REMOVED***, c***REMOVED***
            elif b < 0:
                d = '%s-%s-%s' % (d2[2***REMOVED***, c, -b***REMOVED***
            else:
                d = '%s-%s+%s' % (d2[2***REMOVED***, c, b***REMOVED***
        elif d1[0***REMOVED*** == 0:
            c2 = str(d2[2***REMOVED******REMOVED***
            if c2 not in args:
                if _varname_match(c2***REMOVED***:
                    outmess('\tgetarrlen:variable "%s" undefined\n' % (c2***REMOVED******REMOVED***
                c2 = '(%s***REMOVED***' % c2
            if d2[0***REMOVED*** == 1:
                pass
            elif d2[0***REMOVED*** == -1:
                c2 = '-%s' % c2
            else:
                c2 = '%s*%s' % (d2[0***REMOVED***, c2***REMOVED***

            if b == 0:
                d = c2
            elif b < 0:
                d = '%s-%s' % (c2, -b***REMOVED***
            else:
                d = '%s+%s' % (c2, b***REMOVED***
        elif d2[0***REMOVED*** == 0:
            c1 = str(d1[2***REMOVED******REMOVED***
            if c1 not in args:
                if _varname_match(c1***REMOVED***:
                    outmess('\tgetarrlen:variable "%s" undefined\n' % (c1***REMOVED******REMOVED***
                c1 = '(%s***REMOVED***' % c1
            if d1[0***REMOVED*** == 1:
                c1 = '-%s' % c1
            elif d1[0***REMOVED*** == -1:
                c1 = '+%s' % c1
            elif d1[0***REMOVED*** < 0:
                c1 = '+%s*%s' % (-d1[0***REMOVED***, c1***REMOVED***
            else:
                c1 = '-%s*%s' % (d1[0***REMOVED***, c1***REMOVED***

            if b == 0:
                d = c1
            elif b < 0:
                d = '%s-%s' % (c1, -b***REMOVED***
            else:
                d = '%s+%s' % (c1, b***REMOVED***
        else:
            c1 = str(d1[2***REMOVED******REMOVED***
            if c1 not in args:
                if _varname_match(c1***REMOVED***:
                    outmess('\tgetarrlen:variable "%s" undefined\n' % (c1***REMOVED******REMOVED***
                c1 = '(%s***REMOVED***' % c1
            if d1[0***REMOVED*** == 1:
                c1 = '-%s' % c1
            elif d1[0***REMOVED*** == -1:
                c1 = '+%s' % c1
            elif d1[0***REMOVED*** < 0:
                c1 = '+%s*%s' % (-d1[0***REMOVED***, c1***REMOVED***
            else:
                c1 = '-%s*%s' % (d1[0***REMOVED***, c1***REMOVED***

            c2 = str(d2[2***REMOVED******REMOVED***
            if c2 not in args:
                if _varname_match(c2***REMOVED***:
                    outmess('\tgetarrlen:variable "%s" undefined\n' % (c2***REMOVED******REMOVED***
                c2 = '(%s***REMOVED***' % c2
            if d2[0***REMOVED*** == 1:
                pass
            elif d2[0***REMOVED*** == -1:
                c2 = '-%s' % c2
            else:
                c2 = '%s*%s' % (d2[0***REMOVED***, c2***REMOVED***

            if b == 0:
                d = '%s%s' % (c2, c1***REMOVED***
            elif b < 0:
                d = '%s%s-%s' % (c2, c1, -b***REMOVED***
            else:
                d = '%s%s+%s' % (c2, c1, b***REMOVED***
    return d, None, None

word_pattern = re.compile(r'\b[a-z***REMOVED***[\w$***REMOVED****\b', re.I***REMOVED***


def _get_depend_dict(name, vars, deps***REMOVED***:
    if name in vars:
        words = vars[name***REMOVED***.get('depend', [***REMOVED******REMOVED***

        if '=' in vars[name***REMOVED*** and not isstring(vars[name***REMOVED******REMOVED***:
            for word in word_pattern.findall(vars[name***REMOVED***['='***REMOVED******REMOVED***:
                if word not in words and word in vars:
                    words.append(word***REMOVED***
        for word in words[:***REMOVED***:
            for w in deps.get(word, [***REMOVED******REMOVED*** \
                    or _get_depend_dict(word, vars, deps***REMOVED***:
                if w not in words:
                    words.append(w***REMOVED***
    else:
        outmess('_get_depend_dict: no dependence info for %s\n' % (repr(name***REMOVED******REMOVED******REMOVED***
        words = [***REMOVED***
    deps[name***REMOVED*** = words
    return words


def _calc_depend_dict(vars***REMOVED***:
    names = list(vars.keys(***REMOVED******REMOVED***
    depend_dict = {***REMOVED***
    for n in names:
        _get_depend_dict(n, vars, depend_dict***REMOVED***
    return depend_dict


def get_sorted_names(vars***REMOVED***:
    ***REMOVED***
    ***REMOVED***
    depend_dict = _calc_depend_dict(vars***REMOVED***
    names = [***REMOVED***
    for name in list(depend_dict.keys(***REMOVED******REMOVED***:
        if not depend_dict[name***REMOVED***:
            names.append(name***REMOVED***
            del depend_dict[name***REMOVED***
    while depend_dict:
        for name, lst in list(depend_dict.items(***REMOVED******REMOVED***:
            new_lst = [n for n in lst if n in depend_dict***REMOVED***
            if not new_lst:
                names.append(name***REMOVED***
                del depend_dict[name***REMOVED***
            else:
                depend_dict[name***REMOVED*** = new_lst
    return [name for name in names if name in vars***REMOVED***


def _kind_func(string***REMOVED***:
    # XXX: return something sensible.
    if string[0***REMOVED*** in "'\"":
        string = string[1:-1***REMOVED***
    if real16pattern.match(string***REMOVED***:
        return 8
    elif real8pattern.match(string***REMOVED***:
        return 4
    return 'kind(' + string + '***REMOVED***'


def _selected_int_kind_func(r***REMOVED***:
    # XXX: This should be processor dependent
    m = 10 ** r
    if m <= 2 ** 8:
        return 1
    if m <= 2 ** 16:
        return 2
    if m <= 2 ** 32:
        return 4
    if m <= 2 ** 63:
        return 8
    if m <= 2 ** 128:
        return 16
    return -1


def _selected_real_kind_func(p, r=0, radix=0***REMOVED***:
    # XXX: This should be processor dependent
    # This is only good for 0 <= p <= 20
    if p < 7:
        return 4
    if p < 16:
        return 8
    if platform.machine(***REMOVED***.lower(***REMOVED***.startswith('power'***REMOVED***:
        if p <= 20:
            return 16
    else:
        if p < 19:
            return 10
        elif p <= 20:
            return 16
    return -1


def get_parameters(vars, global_params={***REMOVED******REMOVED***:
    params = copy.copy(global_params***REMOVED***
    g_params = copy.copy(global_params***REMOVED***
    for name, func in [('kind', _kind_func***REMOVED***,
                       ('selected_int_kind', _selected_int_kind_func***REMOVED***,
                       ('selected_real_kind', _selected_real_kind_func***REMOVED***, ***REMOVED***:
        if name not in g_params:
            g_params[name***REMOVED*** = func
    param_names = [***REMOVED***
    for n in get_sorted_names(vars***REMOVED***:
        if 'attrspec' in vars[n***REMOVED*** and 'parameter' in vars[n***REMOVED***['attrspec'***REMOVED***:
            param_names.append(n***REMOVED***
    kind_re = re.compile(r'\bkind\s*\(\s*(?P<value>.****REMOVED***\s*\***REMOVED***', re.I***REMOVED***
    selected_int_kind_re = re.compile(
        r'\bselected_int_kind\s*\(\s*(?P<value>.****REMOVED***\s*\***REMOVED***', re.I***REMOVED***
    selected_kind_re = re.compile(
        r'\bselected_(int|real***REMOVED***_kind\s*\(\s*(?P<value>.****REMOVED***\s*\***REMOVED***', re.I***REMOVED***
    for n in param_names:
        if '=' in vars[n***REMOVED***:
            v = vars[n***REMOVED***['='***REMOVED***
            if islogical(vars[n***REMOVED******REMOVED***:
                v = v.lower(***REMOVED***
                for repl in [
                    ('.false.', 'False'***REMOVED***,
                    ('.true.', 'True'***REMOVED***,
                    # TODO: test .eq., .neq., etc replacements.
                ***REMOVED***:
                    v = v.replace(*repl***REMOVED***
            v = kind_re.sub(r'kind("\1"***REMOVED***', v***REMOVED***
            v = selected_int_kind_re.sub(r'selected_int_kind(\1***REMOVED***', v***REMOVED***
            if isinteger(vars[n***REMOVED******REMOVED*** and not selected_kind_re.match(v***REMOVED***:
                v = v.split('_'***REMOVED***[0***REMOVED***
            if isdouble(vars[n***REMOVED******REMOVED***:
                tt = list(v***REMOVED***
                for m in real16pattern.finditer(v***REMOVED***:
                    tt[m.start(***REMOVED***:m.end(***REMOVED******REMOVED*** = list(
                        v[m.start(***REMOVED***:m.end(***REMOVED******REMOVED***.lower(***REMOVED***.replace('d', 'e'***REMOVED******REMOVED***
                v = ''.join(tt***REMOVED***
            if iscomplex(vars[n***REMOVED******REMOVED***:
                if v[0***REMOVED*** == '(' and v[-1***REMOVED*** == '***REMOVED***':
                    # FIXME, unused l looks like potential bug
                    l = markoutercomma(v[1:-1***REMOVED******REMOVED***.split('@,@'***REMOVED***
            ***REMOVED***
                params[n***REMOVED*** = eval(v, g_params, params***REMOVED***
            except Exception as msg:
                params[n***REMOVED*** = v
                outmess('get_parameters: got "%s" on %s\n' % (msg, repr(v***REMOVED******REMOVED******REMOVED***
            if isstring(vars[n***REMOVED******REMOVED*** and isinstance(params[n***REMOVED***, int***REMOVED***:
                params[n***REMOVED*** = chr(params[n***REMOVED******REMOVED***
            nl = n.lower(***REMOVED***
            if nl != n:
                params[nl***REMOVED*** = params[n***REMOVED***
        else:
            print(vars[n***REMOVED******REMOVED***
            outmess(
                'get_parameters:parameter %s does not have value?!\n' % (repr(n***REMOVED******REMOVED******REMOVED***
    return params


def _eval_length(length, params***REMOVED***:
    if length in ['(:***REMOVED***', '(****REMOVED***', '*'***REMOVED***:
        return '(****REMOVED***'
    return _eval_scalar(length, params***REMOVED***

_is_kind_number = re.compile(r'\d+_'***REMOVED***.match


def _eval_scalar(value, params***REMOVED***:
    if _is_kind_number(value***REMOVED***:
        value = value.split('_'***REMOVED***[0***REMOVED***
    ***REMOVED***
        value = str(eval(value, {***REMOVED***, params***REMOVED******REMOVED***
    except (NameError, SyntaxError***REMOVED***:
        return value
    except Exception as msg:
        errmess('"%s" in evaluating %r '
                '(available names: %s***REMOVED***\n'
                % (msg, value, list(params.keys(***REMOVED******REMOVED******REMOVED******REMOVED***
    return value


def analyzevars(block***REMOVED***:
    global f90modulevars

    setmesstext(block***REMOVED***
    implicitrules, attrrules = buildimplicitrules(block***REMOVED***
    vars = copy.copy(block['vars'***REMOVED******REMOVED***
    if block['block'***REMOVED*** == 'function' and block['name'***REMOVED*** not in vars:
        vars[block['name'***REMOVED******REMOVED*** = {***REMOVED***
    if '' in block['vars'***REMOVED***:
        del vars[''***REMOVED***
        if 'attrspec' in block['vars'***REMOVED***[''***REMOVED***:
            gen = block['vars'***REMOVED***[''***REMOVED***['attrspec'***REMOVED***
            for n in list(vars.keys(***REMOVED******REMOVED***:
                for k in ['public', 'private'***REMOVED***:
                    if k in gen:
                        vars[n***REMOVED*** = setattrspec(vars[n***REMOVED***, k***REMOVED***
    svars = [***REMOVED***
    args = block['args'***REMOVED***
    for a in args:
        ***REMOVED***
            vars[a***REMOVED***
            svars.append(a***REMOVED***
        except KeyError:
            pass
    for n in list(vars.keys(***REMOVED******REMOVED***:
        if n not in args:
            svars.append(n***REMOVED***

    params = get_parameters(vars, get_useparameters(block***REMOVED******REMOVED***

    dep_matches = {***REMOVED***
    name_match = re.compile(r'\w[\w\d_$***REMOVED****'***REMOVED***.match
    for v in list(vars.keys(***REMOVED******REMOVED***:
        m = name_match(v***REMOVED***
        if m:
            n = v[m.start(***REMOVED***:m.end(***REMOVED******REMOVED***
            ***REMOVED***
                dep_matches[n***REMOVED***
            except KeyError:
                dep_matches[n***REMOVED*** = re.compile(r'.*\b%s\b' % (v***REMOVED***, re.I***REMOVED***.match
    for n in svars:
        if n[0***REMOVED*** in list(attrrules.keys(***REMOVED******REMOVED***:
            vars[n***REMOVED*** = setattrspec(vars[n***REMOVED***, attrrules[n[0***REMOVED******REMOVED******REMOVED***
        if 'typespec' not in vars[n***REMOVED***:
            if not('attrspec' in vars[n***REMOVED*** and 'external' in vars[n***REMOVED***['attrspec'***REMOVED******REMOVED***:
                if implicitrules:
                    ln0 = n[0***REMOVED***.lower(***REMOVED***
                    for k in list(implicitrules[ln0***REMOVED***.keys(***REMOVED******REMOVED***:
                        if k == 'typespec' and implicitrules[ln0***REMOVED***[k***REMOVED*** == 'undefined':
                            continue
                        if k not in vars[n***REMOVED***:
                            vars[n***REMOVED***[k***REMOVED*** = implicitrules[ln0***REMOVED***[k***REMOVED***
                        elif k == 'attrspec':
                            for l in implicitrules[ln0***REMOVED***[k***REMOVED***:
                                vars[n***REMOVED*** = setattrspec(vars[n***REMOVED***, l***REMOVED***
                elif n in block['args'***REMOVED***:
                    outmess('analyzevars: typespec of variable %s is not defined in routine %s.\n' % (
                        repr(n***REMOVED***, block['name'***REMOVED******REMOVED******REMOVED***

        if 'charselector' in vars[n***REMOVED***:
            if 'len' in vars[n***REMOVED***['charselector'***REMOVED***:
                l = vars[n***REMOVED***['charselector'***REMOVED***['len'***REMOVED***
                ***REMOVED***
                    l = str(eval(l, {***REMOVED***, params***REMOVED******REMOVED***
                ***REMOVED***
                    pass
                vars[n***REMOVED***['charselector'***REMOVED***['len'***REMOVED*** = l

        if 'kindselector' in vars[n***REMOVED***:
            if 'kind' in vars[n***REMOVED***['kindselector'***REMOVED***:
                l = vars[n***REMOVED***['kindselector'***REMOVED***['kind'***REMOVED***
                ***REMOVED***
                    l = str(eval(l, {***REMOVED***, params***REMOVED******REMOVED***
                ***REMOVED***
                    pass
                vars[n***REMOVED***['kindselector'***REMOVED***['kind'***REMOVED*** = l

        savelindims = {***REMOVED***
        if 'attrspec' in vars[n***REMOVED***:
            attr = vars[n***REMOVED***['attrspec'***REMOVED***
            attr.reverse(***REMOVED***
            vars[n***REMOVED***['attrspec'***REMOVED*** = [***REMOVED***
            dim, intent, depend, check, note = None, None, None, None, None
            for a in attr:
                if a[:9***REMOVED*** == 'dimension':
                    dim = (a[9:***REMOVED***.strip(***REMOVED******REMOVED***[1:-1***REMOVED***
                elif a[:6***REMOVED*** == 'intent':
                    intent = (a[6:***REMOVED***.strip(***REMOVED******REMOVED***[1:-1***REMOVED***
                elif a[:6***REMOVED*** == 'depend':
                    depend = (a[6:***REMOVED***.strip(***REMOVED******REMOVED***[1:-1***REMOVED***
                elif a[:5***REMOVED*** == 'check':
                    check = (a[5:***REMOVED***.strip(***REMOVED******REMOVED***[1:-1***REMOVED***
                elif a[:4***REMOVED*** == 'note':
                    note = (a[4:***REMOVED***.strip(***REMOVED******REMOVED***[1:-1***REMOVED***
                else:
                    vars[n***REMOVED*** = setattrspec(vars[n***REMOVED***, a***REMOVED***
                if intent:
                    if 'intent' not in vars[n***REMOVED***:
                        vars[n***REMOVED***['intent'***REMOVED*** = [***REMOVED***
                    for c in [x.strip(***REMOVED*** for x in markoutercomma(intent***REMOVED***.split('@,@'***REMOVED******REMOVED***:
                        # Remove spaces so that 'in out' becomes 'inout'
                        tmp = c.replace(' ', ''***REMOVED***
                        if tmp not in vars[n***REMOVED***['intent'***REMOVED***:
                            vars[n***REMOVED***['intent'***REMOVED***.append(tmp***REMOVED***
                    intent = None
                if note:
                    note = note.replace('\\n\\n', '\n\n'***REMOVED***
                    note = note.replace('\\n ', '\n'***REMOVED***
                    if 'note' not in vars[n***REMOVED***:
                        vars[n***REMOVED***['note'***REMOVED*** = [note***REMOVED***
                    else:
                        vars[n***REMOVED***['note'***REMOVED***.append(note***REMOVED***
                    note = None
                if depend is not None:
                    if 'depend' not in vars[n***REMOVED***:
                        vars[n***REMOVED***['depend'***REMOVED*** = [***REMOVED***
                    for c in rmbadname([x.strip(***REMOVED*** for x in markoutercomma(depend***REMOVED***.split('@,@'***REMOVED******REMOVED******REMOVED***:
                        if c not in vars[n***REMOVED***['depend'***REMOVED***:
                            vars[n***REMOVED***['depend'***REMOVED***.append(c***REMOVED***
                    depend = None
                if check is not None:
                    if 'check' not in vars[n***REMOVED***:
                        vars[n***REMOVED***['check'***REMOVED*** = [***REMOVED***
                    for c in [x.strip(***REMOVED*** for x in markoutercomma(check***REMOVED***.split('@,@'***REMOVED******REMOVED***:
                        if c not in vars[n***REMOVED***['check'***REMOVED***:
                            vars[n***REMOVED***['check'***REMOVED***.append(c***REMOVED***
                    check = None
            if dim and 'dimension' not in vars[n***REMOVED***:
                vars[n***REMOVED***['dimension'***REMOVED*** = [***REMOVED***
                for d in rmbadname([x.strip(***REMOVED*** for x in markoutercomma(dim***REMOVED***.split('@,@'***REMOVED******REMOVED******REMOVED***:
                    star = '*'
                    if d == ':':
                        star = ':'
                    if d in params:
                        d = str(params[d***REMOVED******REMOVED***
                    for p in list(params.keys(***REMOVED******REMOVED***:
                        re_1 = re.compile(r'(?P<before>.*?***REMOVED***\b' + p + r'\b(?P<after>.****REMOVED***', re.I***REMOVED***
                        m = re_1.match(d***REMOVED***
                        while m:
                            d = m.group('before'***REMOVED*** + \
                                str(params[p***REMOVED******REMOVED*** + m.group('after'***REMOVED***
                            m = re_1.match(d***REMOVED***
                    if d == star:
                        dl = [star***REMOVED***
                    else:
                        dl = markoutercomma(d, ':'***REMOVED***.split('@:@'***REMOVED***
                    if len(dl***REMOVED*** == 2 and '*' in dl:  # e.g. dimension(5:****REMOVED***
                        dl = ['*'***REMOVED***
                        d = '*'
                    if len(dl***REMOVED*** == 1 and not dl[0***REMOVED*** == star:
                        dl = ['1', dl[0***REMOVED******REMOVED***
                    if len(dl***REMOVED*** == 2:
                        d, v, di = getarrlen(dl, list(block['vars'***REMOVED***.keys(***REMOVED******REMOVED******REMOVED***
                        if d[:4***REMOVED*** == '1 * ':
                            d = d[4:***REMOVED***
                        if di and di[-4:***REMOVED*** == '/(1***REMOVED***':
                            di = di[:-4***REMOVED***
                        if v:
                            savelindims[d***REMOVED*** = v, di
                    vars[n***REMOVED***['dimension'***REMOVED***.append(d***REMOVED***
        if 'dimension' in vars[n***REMOVED***:
            if isintent_c(vars[n***REMOVED******REMOVED***:
                shape_macro = 'shape'
            else:
                shape_macro = 'shape'  # 'fshape'
            if isstringarray(vars[n***REMOVED******REMOVED***:
                if 'charselector' in vars[n***REMOVED***:
                    d = vars[n***REMOVED***['charselector'***REMOVED***
                    if '*' in d:
                        d = d['*'***REMOVED***
                        errmess('analyzevars: character array "character*%s %s(%s***REMOVED***" is considered as "character %s(%s***REMOVED***"; "intent(c***REMOVED***" is forced.\n'
                                % (d, n,
                                   ','.join(vars[n***REMOVED***['dimension'***REMOVED******REMOVED***,
                                   n, ','.join(vars[n***REMOVED***['dimension'***REMOVED*** + [d***REMOVED******REMOVED******REMOVED******REMOVED***
                        vars[n***REMOVED***['dimension'***REMOVED***.append(d***REMOVED***
                        del vars[n***REMOVED***['charselector'***REMOVED***
                        if 'intent' not in vars[n***REMOVED***:
                            vars[n***REMOVED***['intent'***REMOVED*** = [***REMOVED***
                        if 'c' not in vars[n***REMOVED***['intent'***REMOVED***:
                            vars[n***REMOVED***['intent'***REMOVED***.append('c'***REMOVED***
                    else:
                        errmess(
                            "analyzevars: charselector=%r unhandled." % (d***REMOVED******REMOVED***
        if 'check' not in vars[n***REMOVED*** and 'args' in block and n in block['args'***REMOVED***:
            flag = 'depend' not in vars[n***REMOVED***
            if flag:
                vars[n***REMOVED***['depend'***REMOVED*** = [***REMOVED***
            vars[n***REMOVED***['check'***REMOVED*** = [***REMOVED***
            if 'dimension' in vars[n***REMOVED***:
                #/----< no check
                i = -1
                ni = len(vars[n***REMOVED***['dimension'***REMOVED******REMOVED***
                for d in vars[n***REMOVED***['dimension'***REMOVED***:
                    ddeps = [***REMOVED***  # dependecies of 'd'
                    ad = ''
                    pd = ''
                    if d not in vars:
                        if d in savelindims:
                            pd, ad = '(', savelindims[d***REMOVED***[1***REMOVED***
                            d = savelindims[d***REMOVED***[0***REMOVED***
                        else:
                            for r in block['args'***REMOVED***:
                                if r not in vars:
                                    continue
                                if re.match(r'.*?\b' + r + r'\b', d, re.I***REMOVED***:
                                    ddeps.append(r***REMOVED***
                    if d in vars:
                        if 'attrspec' in vars[d***REMOVED***:
                            for aa in vars[d***REMOVED***['attrspec'***REMOVED***:
                                if aa[:6***REMOVED*** == 'depend':
                                    ddeps += aa[6:***REMOVED***.strip(***REMOVED***[1:-1***REMOVED***.split(','***REMOVED***
                        if 'depend' in vars[d***REMOVED***:
                            ddeps = ddeps + vars[d***REMOVED***['depend'***REMOVED***
                    i = i + 1
                    if d in vars and ('depend' not in vars[d***REMOVED******REMOVED*** \
                       and ('=' not in vars[d***REMOVED******REMOVED*** and (d not in vars[n***REMOVED***['depend'***REMOVED******REMOVED*** \
                       and l_or(isintent_in, isintent_inout, isintent_inplace***REMOVED***(vars[n***REMOVED******REMOVED***:
                        vars[d***REMOVED***['depend'***REMOVED*** = [n***REMOVED***
                        if ni > 1:
                            vars[d***REMOVED***['='***REMOVED*** = '%s%s(%s,%s***REMOVED***%s' % (
                                pd, shape_macro, n, i, ad***REMOVED***
                        else:
                            vars[d***REMOVED***['='***REMOVED*** = '%slen(%s***REMOVED***%s' % (pd, n, ad***REMOVED***
                        #  /---< no check
                        if 1 and 'check' not in vars[d***REMOVED***:
                            if ni > 1:
                                vars[d***REMOVED***['check'***REMOVED*** = ['%s%s(%s,%i***REMOVED***%s==%s'
                                                    % (pd, shape_macro, n, i, ad, d***REMOVED******REMOVED***
                            else:
                                vars[d***REMOVED***['check'***REMOVED*** = [
                                    '%slen(%s***REMOVED***%s>=%s' % (pd, n, ad, d***REMOVED******REMOVED***
                        if 'attrspec' not in vars[d***REMOVED***:
                            vars[d***REMOVED***['attrspec'***REMOVED*** = ['optional'***REMOVED***
                        if ('optional' not in vars[d***REMOVED***['attrspec'***REMOVED******REMOVED*** and\
                           ('required' not in vars[d***REMOVED***['attrspec'***REMOVED******REMOVED***:
                            vars[d***REMOVED***['attrspec'***REMOVED***.append('optional'***REMOVED***
                    elif d not in ['*', ':'***REMOVED***:
                        #/----< no check
                        if flag:
                            if d in vars:
                                if n not in ddeps:
                                    vars[n***REMOVED***['depend'***REMOVED***.append(d***REMOVED***
                            else:
                                vars[n***REMOVED***['depend'***REMOVED*** = vars[n***REMOVED***['depend'***REMOVED*** + ddeps
            elif isstring(vars[n***REMOVED******REMOVED***:
                length = '1'
                if 'charselector' in vars[n***REMOVED***:
                    if '*' in vars[n***REMOVED***['charselector'***REMOVED***:
                        length = _eval_length(vars[n***REMOVED***['charselector'***REMOVED***['*'***REMOVED***,
                                              params***REMOVED***
                        vars[n***REMOVED***['charselector'***REMOVED***['*'***REMOVED*** = length
                    elif 'len' in vars[n***REMOVED***['charselector'***REMOVED***:
                        length = _eval_length(vars[n***REMOVED***['charselector'***REMOVED***['len'***REMOVED***,
                                              params***REMOVED***
                        del vars[n***REMOVED***['charselector'***REMOVED***['len'***REMOVED***
                        vars[n***REMOVED***['charselector'***REMOVED***['*'***REMOVED*** = length

            if not vars[n***REMOVED***['check'***REMOVED***:
                del vars[n***REMOVED***['check'***REMOVED***
            if flag and not vars[n***REMOVED***['depend'***REMOVED***:
                del vars[n***REMOVED***['depend'***REMOVED***
        if '=' in vars[n***REMOVED***:
            if 'attrspec' not in vars[n***REMOVED***:
                vars[n***REMOVED***['attrspec'***REMOVED*** = [***REMOVED***
            if ('optional' not in vars[n***REMOVED***['attrspec'***REMOVED******REMOVED*** and \
               ('required' not in vars[n***REMOVED***['attrspec'***REMOVED******REMOVED***:
                vars[n***REMOVED***['attrspec'***REMOVED***.append('optional'***REMOVED***
            if 'depend' not in vars[n***REMOVED***:
                vars[n***REMOVED***['depend'***REMOVED*** = [***REMOVED***
                for v, m in list(dep_matches.items(***REMOVED******REMOVED***:
                    if m(vars[n***REMOVED***['='***REMOVED******REMOVED***:
                        vars[n***REMOVED***['depend'***REMOVED***.append(v***REMOVED***
                if not vars[n***REMOVED***['depend'***REMOVED***:
                    del vars[n***REMOVED***['depend'***REMOVED***
            if isscalar(vars[n***REMOVED******REMOVED***:
                vars[n***REMOVED***['='***REMOVED*** = _eval_scalar(vars[n***REMOVED***['='***REMOVED***, params***REMOVED***

    for n in list(vars.keys(***REMOVED******REMOVED***:
        if n == block['name'***REMOVED***:  # n is block name
            if 'note' in vars[n***REMOVED***:
                block['note'***REMOVED*** = vars[n***REMOVED***['note'***REMOVED***
            if block['block'***REMOVED*** == 'function':
                if 'result' in block and block['result'***REMOVED*** in vars:
                    vars[n***REMOVED*** = appenddecl(vars[n***REMOVED***, vars[block['result'***REMOVED******REMOVED******REMOVED***
                if 'prefix' in block:
                    pr = block['prefix'***REMOVED***
                    ispure = 0
                    isrec = 1
                    pr1 = pr.replace('pure', ''***REMOVED***
                    ispure = (not pr == pr1***REMOVED***
                    pr = pr1.replace('recursive', ''***REMOVED***
                    isrec = (not pr == pr1***REMOVED***
                    m = typespattern[0***REMOVED***.match(pr***REMOVED***
                    if m:
                        typespec, selector, attr, edecl = cracktypespec0(
                            m.group('this'***REMOVED***, m.group('after'***REMOVED******REMOVED***
                        kindselect, charselect, typename = cracktypespec(
                            typespec, selector***REMOVED***
                        vars[n***REMOVED***['typespec'***REMOVED*** = typespec
                        if kindselect:
                            if 'kind' in kindselect:
                                ***REMOVED***
                                    kindselect['kind'***REMOVED*** = eval(
                                        kindselect['kind'***REMOVED***, {***REMOVED***, params***REMOVED***
                                ***REMOVED***
                                    pass
                            vars[n***REMOVED***['kindselector'***REMOVED*** = kindselect
                        if charselect:
                            vars[n***REMOVED***['charselector'***REMOVED*** = charselect
                        if typename:
                            vars[n***REMOVED***['typename'***REMOVED*** = typename
                        if ispure:
                            vars[n***REMOVED*** = setattrspec(vars[n***REMOVED***, 'pure'***REMOVED***
                        if isrec:
                            vars[n***REMOVED*** = setattrspec(vars[n***REMOVED***, 'recursive'***REMOVED***
                    else:
                        outmess(
                            'analyzevars: prefix (%s***REMOVED*** were not used\n' % repr(block['prefix'***REMOVED******REMOVED******REMOVED***
    if not block['block'***REMOVED*** in ['module', 'pythonmodule', 'python module', 'block data'***REMOVED***:
        if 'commonvars' in block:
            neededvars = copy.copy(block['args'***REMOVED*** + block['commonvars'***REMOVED******REMOVED***
        else:
            neededvars = copy.copy(block['args'***REMOVED******REMOVED***
        for n in list(vars.keys(***REMOVED******REMOVED***:
            if l_or(isintent_callback, isintent_aux***REMOVED***(vars[n***REMOVED******REMOVED***:
                neededvars.append(n***REMOVED***
        if 'entry' in block:
            neededvars.extend(list(block['entry'***REMOVED***.keys(***REMOVED******REMOVED******REMOVED***
            for k in list(block['entry'***REMOVED***.keys(***REMOVED******REMOVED***:
                for n in block['entry'***REMOVED***[k***REMOVED***:
                    if n not in neededvars:
                        neededvars.append(n***REMOVED***
        if block['block'***REMOVED*** == 'function':
            if 'result' in block:
                neededvars.append(block['result'***REMOVED******REMOVED***
            else:
                neededvars.append(block['name'***REMOVED******REMOVED***
        if block['block'***REMOVED*** in ['subroutine', 'function'***REMOVED***:
            name = block['name'***REMOVED***
            if name in vars and 'intent' in vars[name***REMOVED***:
                block['intent'***REMOVED*** = vars[name***REMOVED***['intent'***REMOVED***
        if block['block'***REMOVED*** == 'type':
            neededvars.extend(list(vars.keys(***REMOVED******REMOVED******REMOVED***
        for n in list(vars.keys(***REMOVED******REMOVED***:
            if n not in neededvars:
                del vars[n***REMOVED***
    return vars

analyzeargs_re_1 = re.compile(r'\A[a-z***REMOVED***+[\w$***REMOVED****\Z', re.I***REMOVED***


def expr2name(a, block, args=[***REMOVED******REMOVED***:
    orig_a = a
    a_is_expr = not analyzeargs_re_1.match(a***REMOVED***
    if a_is_expr:  # `a` is an expression
        implicitrules, attrrules = buildimplicitrules(block***REMOVED***
        at = determineexprtype(a, block['vars'***REMOVED***, implicitrules***REMOVED***
        na = 'e_'
        for c in a:
            c = c.lower(***REMOVED***
            if c not in string.ascii_lowercase + string.digits:
                c = '_'
            na = na + c
        if na[-1***REMOVED*** == '_':
            na = na + 'e'
        else:
            na = na + '_e'
        a = na
        while a in block['vars'***REMOVED*** or a in block['args'***REMOVED***:
            a = a + 'r'
    if a in args:
        k = 1
        while a + str(k***REMOVED*** in args:
            k = k + 1
        a = a + str(k***REMOVED***
    if a_is_expr:
        block['vars'***REMOVED***[a***REMOVED*** = at
    else:
        if a not in block['vars'***REMOVED***:
            if orig_a in block['vars'***REMOVED***:
                block['vars'***REMOVED***[a***REMOVED*** = block['vars'***REMOVED***[orig_a***REMOVED***
            else:
                block['vars'***REMOVED***[a***REMOVED*** = {***REMOVED***
        if 'externals' in block and orig_a in block['externals'***REMOVED*** + block['interfaced'***REMOVED***:
            block['vars'***REMOVED***[a***REMOVED*** = setattrspec(block['vars'***REMOVED***[a***REMOVED***, 'external'***REMOVED***
    return a


def analyzeargs(block***REMOVED***:
    setmesstext(block***REMOVED***
    implicitrules, attrrules = buildimplicitrules(block***REMOVED***
    if 'args' not in block:
        block['args'***REMOVED*** = [***REMOVED***
    args = [***REMOVED***
    for a in block['args'***REMOVED***:
        a = expr2name(a, block, args***REMOVED***
        args.append(a***REMOVED***
    block['args'***REMOVED*** = args
    if 'entry' in block:
        for k, args1 in list(block['entry'***REMOVED***.items(***REMOVED******REMOVED***:
            for a in args1:
                if a not in block['vars'***REMOVED***:
                    block['vars'***REMOVED***[a***REMOVED*** = {***REMOVED***

    for b in block['body'***REMOVED***:
        if b['name'***REMOVED*** in args:
            if 'externals' not in block:
                block['externals'***REMOVED*** = [***REMOVED***
            if b['name'***REMOVED*** not in block['externals'***REMOVED***:
                block['externals'***REMOVED***.append(b['name'***REMOVED******REMOVED***
    if 'result' in block and block['result'***REMOVED*** not in block['vars'***REMOVED***:
        block['vars'***REMOVED***[block['result'***REMOVED******REMOVED*** = {***REMOVED***
    return block

determineexprtype_re_1 = re.compile(r'\A\(.+?[,***REMOVED***.+?\***REMOVED***\Z', re.I***REMOVED***
determineexprtype_re_2 = re.compile(r'\A[+-***REMOVED***?\d+(_(P<name>[\w***REMOVED***+***REMOVED***|***REMOVED***\Z', re.I***REMOVED***
determineexprtype_re_3 = re.compile(
    r'\A[+-***REMOVED***?[\d.***REMOVED***+[\d+-de.***REMOVED****(_(P<name>[\w***REMOVED***+***REMOVED***|***REMOVED***\Z', re.I***REMOVED***
determineexprtype_re_4 = re.compile(r'\A\(.*\***REMOVED***\Z', re.I***REMOVED***
determineexprtype_re_5 = re.compile(r'\A(?P<name>\w+***REMOVED***\s*\(.*?\***REMOVED***\s*\Z', re.I***REMOVED***


def _ensure_exprdict(r***REMOVED***:
    if isinstance(r, int***REMOVED***:
        return {'typespec': 'integer'***REMOVED***
    if isinstance(r, float***REMOVED***:
        return {'typespec': 'real'***REMOVED***
    if isinstance(r, complex***REMOVED***:
        return {'typespec': 'complex'***REMOVED***
    if isinstance(r, dict***REMOVED***:
        return r
    raise AssertionError(repr(r***REMOVED******REMOVED***


def determineexprtype(expr, vars, rules={***REMOVED******REMOVED***:
    if expr in vars:
        return _ensure_exprdict(vars[expr***REMOVED******REMOVED***
    expr = expr.strip(***REMOVED***
    if determineexprtype_re_1.match(expr***REMOVED***:
        return {'typespec': 'complex'***REMOVED***
    m = determineexprtype_re_2.match(expr***REMOVED***
    if m:
        if 'name' in m.groupdict(***REMOVED*** and m.group('name'***REMOVED***:
            outmess(
                'determineexprtype: selected kind types not supported (%s***REMOVED***\n' % repr(expr***REMOVED******REMOVED***
        return {'typespec': 'integer'***REMOVED***
    m = determineexprtype_re_3.match(expr***REMOVED***
    if m:
        if 'name' in m.groupdict(***REMOVED*** and m.group('name'***REMOVED***:
            outmess(
                'determineexprtype: selected kind types not supported (%s***REMOVED***\n' % repr(expr***REMOVED******REMOVED***
        return {'typespec': 'real'***REMOVED***
    for op in ['+', '-', '*', '/'***REMOVED***:
        for e in [x.strip(***REMOVED*** for x in markoutercomma(expr, comma=op***REMOVED***.split('@' + op + '@'***REMOVED******REMOVED***:
            if e in vars:
                return _ensure_exprdict(vars[e***REMOVED******REMOVED***
    t = {***REMOVED***
    if determineexprtype_re_4.match(expr***REMOVED***:  # in parenthesis
        t = determineexprtype(expr[1:-1***REMOVED***, vars, rules***REMOVED***
    else:
        m = determineexprtype_re_5.match(expr***REMOVED***
        if m:
            rn = m.group('name'***REMOVED***
            t = determineexprtype(m.group('name'***REMOVED***, vars, rules***REMOVED***
            if t and 'attrspec' in t:
                del t['attrspec'***REMOVED***
            if not t:
                if rn[0***REMOVED*** in rules:
                    return _ensure_exprdict(rules[rn[0***REMOVED******REMOVED******REMOVED***
    if expr[0***REMOVED*** in '\'"':
        return {'typespec': 'character', 'charselector': {'*': '*'***REMOVED******REMOVED***
    if not t:
        outmess(
            'determineexprtype: could not determine expressions (%s***REMOVED*** type.\n' % (repr(expr***REMOVED******REMOVED******REMOVED***
    return t

######


def crack2fortrangen(block, tab='\n', as_interface=False***REMOVED***:
    global skipfuncs, onlyfuncs

    setmesstext(block***REMOVED***
    ret = ''
    if isinstance(block, list***REMOVED***:
        for g in block:
            if g and g['block'***REMOVED*** in ['function', 'subroutine'***REMOVED***:
                if g['name'***REMOVED*** in skipfuncs:
                    continue
                if onlyfuncs and g['name'***REMOVED*** not in onlyfuncs:
                    continue
            ret = ret + crack2fortrangen(g, tab, as_interface=as_interface***REMOVED***
        return ret
    prefix = ''
    name = ''
    args = ''
    blocktype = block['block'***REMOVED***
    if blocktype == 'program':
        return ''
    argsl = [***REMOVED***
    if 'name' in block:
        name = block['name'***REMOVED***
    if 'args' in block:
        vars = block['vars'***REMOVED***
        for a in block['args'***REMOVED***:
            a = expr2name(a, block, argsl***REMOVED***
            if not isintent_callback(vars[a***REMOVED******REMOVED***:
                argsl.append(a***REMOVED***
        if block['block'***REMOVED*** == 'function' or argsl:
            args = '(%s***REMOVED***' % ','.join(argsl***REMOVED***
    f2pyenhancements = ''
    if 'f2pyenhancements' in block:
        for k in list(block['f2pyenhancements'***REMOVED***.keys(***REMOVED******REMOVED***:
            f2pyenhancements = '%s%s%s %s' % (
                f2pyenhancements, tab + tabchar, k, block['f2pyenhancements'***REMOVED***[k***REMOVED******REMOVED***
    intent_lst = block.get('intent', [***REMOVED******REMOVED***[:***REMOVED***
    if blocktype == 'function' and 'callback' in intent_lst:
        intent_lst.remove('callback'***REMOVED***
    if intent_lst:
        f2pyenhancements = '%s%sintent(%s***REMOVED*** %s' %\
                           (f2pyenhancements, tab + tabchar,
                            ','.join(intent_lst***REMOVED***, name***REMOVED***
    use = ''
    if 'use' in block:
        use = use2fortran(block['use'***REMOVED***, tab + tabchar***REMOVED***
    common = ''
    if 'common' in block:
        common = common2fortran(block['common'***REMOVED***, tab + tabchar***REMOVED***
    if name == 'unknown_interface':
        name = ''
    result = ''
    if 'result' in block:
        result = ' result (%s***REMOVED***' % block['result'***REMOVED***
        if block['result'***REMOVED*** not in argsl:
            argsl.append(block['result'***REMOVED******REMOVED***
    body = crack2fortrangen(block['body'***REMOVED***, tab + tabchar***REMOVED***
    vars = vars2fortran(
        block, block['vars'***REMOVED***, argsl, tab + tabchar, as_interface=as_interface***REMOVED***
    mess = ''
    if 'from' in block and not as_interface:
        mess = '! in %s' % block['from'***REMOVED***
    if 'entry' in block:
        entry_stmts = ''
        for k, i in list(block['entry'***REMOVED***.items(***REMOVED******REMOVED***:
            entry_stmts = '%s%sentry %s(%s***REMOVED***' \
                          % (entry_stmts, tab + tabchar, k, ','.join(i***REMOVED******REMOVED***
        body = body + entry_stmts
    if blocktype == 'block data' and name == '_BLOCK_DATA_':
        name = ''
    ret = '%s%s%s %s%s%s %s%s%s%s%s%s%send %s %s' % (
        tab, prefix, blocktype, name, args, result, mess, f2pyenhancements, use, vars, common, body, tab, blocktype, name***REMOVED***
    return ret


def common2fortran(common, tab=''***REMOVED***:
    ret = ''
    for k in list(common.keys(***REMOVED******REMOVED***:
        if k == '_BLNK_':
            ret = '%s%scommon %s' % (ret, tab, ','.join(common[k***REMOVED******REMOVED******REMOVED***
        else:
            ret = '%s%scommon /%s/ %s' % (ret, tab, k, ','.join(common[k***REMOVED******REMOVED******REMOVED***
    return ret


def use2fortran(use, tab=''***REMOVED***:
    ret = ''
    for m in list(use.keys(***REMOVED******REMOVED***:
        ret = '%s%suse %s,' % (ret, tab, m***REMOVED***
        if use[m***REMOVED*** == {***REMOVED***:
            if ret and ret[-1***REMOVED*** == ',':
                ret = ret[:-1***REMOVED***
            continue
        if 'only' in use[m***REMOVED*** and use[m***REMOVED***['only'***REMOVED***:
            ret = '%s only:' % (ret***REMOVED***
        if 'map' in use[m***REMOVED*** and use[m***REMOVED***['map'***REMOVED***:
            c = ' '
            for k in list(use[m***REMOVED***['map'***REMOVED***.keys(***REMOVED******REMOVED***:
                if k == use[m***REMOVED***['map'***REMOVED***[k***REMOVED***:
                    ret = '%s%s%s' % (ret, c, k***REMOVED***
                    c = ','
                else:
                    ret = '%s%s%s=>%s' % (ret, c, k, use[m***REMOVED***['map'***REMOVED***[k***REMOVED******REMOVED***
                    c = ','
        if ret and ret[-1***REMOVED*** == ',':
            ret = ret[:-1***REMOVED***
    return ret


def true_intent_list(var***REMOVED***:
    lst = var['intent'***REMOVED***
    ret = [***REMOVED***
    for intent in lst:
        ***REMOVED***
            c = eval('isintent_%s(var***REMOVED***' % intent***REMOVED***
        except NameError:
            c = 0
        if c:
            ret.append(intent***REMOVED***
    return ret


def vars2fortran(block, vars, args, tab='', as_interface=False***REMOVED***:
    ***REMOVED***
    TODO:
    public sub
    ...
    ***REMOVED***
    setmesstext(block***REMOVED***
    ret = ''
    nout = [***REMOVED***
    for a in args:
        if a in block['vars'***REMOVED***:
            nout.append(a***REMOVED***
    if 'commonvars' in block:
        for a in block['commonvars'***REMOVED***:
            if a in vars:
                if a not in nout:
                    nout.append(a***REMOVED***
            else:
                errmess(
                    'vars2fortran: Confused?!: "%s" is not defined in vars.\n' % a***REMOVED***
    if 'varnames' in block:
        nout.extend(block['varnames'***REMOVED******REMOVED***
    if not as_interface:
        for a in list(vars.keys(***REMOVED******REMOVED***:
            if a not in nout:
                nout.append(a***REMOVED***
    for a in nout:
        if 'depend' in vars[a***REMOVED***:
            for d in vars[a***REMOVED***['depend'***REMOVED***:
                if d in vars and 'depend' in vars[d***REMOVED*** and a in vars[d***REMOVED***['depend'***REMOVED***:
                    errmess(
                        'vars2fortran: Warning: cross-dependence between variables "%s" and "%s"\n' % (a, d***REMOVED******REMOVED***
        if 'externals' in block and a in block['externals'***REMOVED***:
            if isintent_callback(vars[a***REMOVED******REMOVED***:
                ret = '%s%sintent(callback***REMOVED*** %s' % (ret, tab, a***REMOVED***
            ret = '%s%sexternal %s' % (ret, tab, a***REMOVED***
            if isoptional(vars[a***REMOVED******REMOVED***:
                ret = '%s%soptional %s' % (ret, tab, a***REMOVED***
            if a in vars and 'typespec' not in vars[a***REMOVED***:
                continue
            cont = 1
            for b in block['body'***REMOVED***:
                if a == b['name'***REMOVED*** and b['block'***REMOVED*** == 'function':
                    cont = 0
                    break
            if cont:
                continue
        if a not in vars:
            show(vars***REMOVED***
            outmess('vars2fortran: No definition for argument "%s".\n' % a***REMOVED***
            continue
        if a == block['name'***REMOVED*** and not block['block'***REMOVED*** == 'function':
            continue
        if 'typespec' not in vars[a***REMOVED***:
            if 'attrspec' in vars[a***REMOVED*** and 'external' in vars[a***REMOVED***['attrspec'***REMOVED***:
                if a in args:
                    ret = '%s%sexternal %s' % (ret, tab, a***REMOVED***
                continue
            show(vars[a***REMOVED******REMOVED***
            outmess('vars2fortran: No typespec for argument "%s".\n' % a***REMOVED***
            continue
        vardef = vars[a***REMOVED***['typespec'***REMOVED***
        if vardef == 'type' and 'typename' in vars[a***REMOVED***:
            vardef = '%s(%s***REMOVED***' % (vardef, vars[a***REMOVED***['typename'***REMOVED******REMOVED***
        selector = {***REMOVED***
        if 'kindselector' in vars[a***REMOVED***:
            selector = vars[a***REMOVED***['kindselector'***REMOVED***
        elif 'charselector' in vars[a***REMOVED***:
            selector = vars[a***REMOVED***['charselector'***REMOVED***
        if '*' in selector:
            if selector['*'***REMOVED*** in ['*', ':'***REMOVED***:
                vardef = '%s*(%s***REMOVED***' % (vardef, selector['*'***REMOVED******REMOVED***
            else:
                vardef = '%s*%s' % (vardef, selector['*'***REMOVED******REMOVED***
        else:
            if 'len' in selector:
                vardef = '%s(len=%s' % (vardef, selector['len'***REMOVED******REMOVED***
                if 'kind' in selector:
                    vardef = '%s,kind=%s***REMOVED***' % (vardef, selector['kind'***REMOVED******REMOVED***
                else:
                    vardef = '%s***REMOVED***' % (vardef***REMOVED***
            elif 'kind' in selector:
                vardef = '%s(kind=%s***REMOVED***' % (vardef, selector['kind'***REMOVED******REMOVED***
        c = ' '
        if 'attrspec' in vars[a***REMOVED***:
            attr = [***REMOVED***
            for l in vars[a***REMOVED***['attrspec'***REMOVED***:
                if l not in ['external'***REMOVED***:
                    attr.append(l***REMOVED***
            if attr:
                vardef = '%s, %s' % (vardef, ','.join(attr***REMOVED******REMOVED***
                c = ','
        if 'dimension' in vars[a***REMOVED***:
            vardef = '%s%sdimension(%s***REMOVED***' % (
                vardef, c, ','.join(vars[a***REMOVED***['dimension'***REMOVED******REMOVED******REMOVED***
            c = ','
        if 'intent' in vars[a***REMOVED***:
            lst = true_intent_list(vars[a***REMOVED******REMOVED***
            if lst:
                vardef = '%s%sintent(%s***REMOVED***' % (vardef, c, ','.join(lst***REMOVED******REMOVED***
            c = ','
        if 'check' in vars[a***REMOVED***:
            vardef = '%s%scheck(%s***REMOVED***' % (vardef, c, ','.join(vars[a***REMOVED***['check'***REMOVED******REMOVED******REMOVED***
            c = ','
        if 'depend' in vars[a***REMOVED***:
            vardef = '%s%sdepend(%s***REMOVED***' % (
                vardef, c, ','.join(vars[a***REMOVED***['depend'***REMOVED******REMOVED******REMOVED***
            c = ','
        if '=' in vars[a***REMOVED***:
            v = vars[a***REMOVED***['='***REMOVED***
            if vars[a***REMOVED***['typespec'***REMOVED*** in ['complex', 'double complex'***REMOVED***:
                ***REMOVED***
                    v = eval(v***REMOVED***
                    v = '(%s,%s***REMOVED***' % (v.real, v.imag***REMOVED***
                ***REMOVED***
                    pass
            vardef = '%s :: %s=%s' % (vardef, a, v***REMOVED***
        else:
            vardef = '%s :: %s' % (vardef, a***REMOVED***
        ret = '%s%s%s' % (ret, tab, vardef***REMOVED***
    return ret
######


def crackfortran(files***REMOVED***:
    global usermodules

    outmess('Reading fortran codes...\n', 0***REMOVED***
    readfortrancode(files, crackline***REMOVED***
    outmess('Post-processing...\n', 0***REMOVED***
    usermodules = [***REMOVED***
    postlist = postcrack(grouplist[0***REMOVED******REMOVED***
    outmess('Post-processing (stage 2***REMOVED***...\n', 0***REMOVED***
    postlist = postcrack2(postlist***REMOVED***
    return usermodules + postlist


def crack2fortran(block***REMOVED***:
    global f2py_version

    pyf = crack2fortrangen(block***REMOVED*** + '\n'
    header = ***REMOVED***!    -*- f90 -*-
! Note: the context of this file is case sensitive.
***REMOVED***
    footer = ***REMOVED***
! This file was auto-generated with f2py (version:%s***REMOVED***.
! See http://cens.ioc.ee/projects/f2py2e/
***REMOVED*** % (f2py_version***REMOVED***
    return header + pyf + footer

if __name__ == "__main__":
    files = [***REMOVED***
    funcs = [***REMOVED***
    f = 1
    f2 = 0
    f3 = 0
    showblocklist = 0
    for l in sys.argv[1:***REMOVED***:
        if l == '':
            pass
        elif l[0***REMOVED*** == ':':
            f = 0
        elif l == '-quiet':
            quiet = 1
            verbose = 0
        elif l == '-verbose':
            verbose = 2
            quiet = 0
        elif l == '-fix':
            if strictf77:
                outmess(
                    'Use option -f90 before -fix if Fortran 90 code is in fix form.\n', 0***REMOVED***
            skipemptyends = 1
            sourcecodeform = 'fix'
        elif l == '-skipemptyends':
            skipemptyends = 1
        elif l == '--ignore-contains':
            ignorecontains = 1
        elif l == '-f77':
            strictf77 = 1
            sourcecodeform = 'fix'
        elif l == '-f90':
            strictf77 = 0
            sourcecodeform = 'free'
            skipemptyends = 1
        elif l == '-h':
            f2 = 1
        elif l == '-show':
            showblocklist = 1
        elif l == '-m':
            f3 = 1
        elif l[0***REMOVED*** == '-':
            errmess('Unknown option %s\n' % repr(l***REMOVED******REMOVED***
        elif f2:
            f2 = 0
            pyffilename = l
        elif f3:
            f3 = 0
            f77modulename = l
        elif f:
            ***REMOVED***
                open(l***REMOVED***.close(***REMOVED***
                files.append(l***REMOVED***
            except IOError as detail:
                errmess('IOError: %s\n' % str(detail***REMOVED******REMOVED***
        else:
            funcs.append(l***REMOVED***
    if not strictf77 and f77modulename and not skipemptyends:
        outmess(***REMOVED***\
  Warning: You have specifyied module name for non Fortran 77 code
  that should not need one (expect if you are scanning F90 code
  for non module blocks but then you should use flag -skipemptyends
  and also be sure that the files do not contain programs without program statement***REMOVED***.
***REMOVED***, 0***REMOVED***

    postlist = crackfortran(files, funcs***REMOVED***
    if pyffilename:
        outmess('Writing fortran code to file %s\n' % repr(pyffilename***REMOVED***, 0***REMOVED***
        pyf = crack2fortran(postlist***REMOVED***
        f = open(pyffilename, 'w'***REMOVED***
        f.write(pyf***REMOVED***
        f.close(***REMOVED***
    if showblocklist:
        show(postlist***REMOVED***
