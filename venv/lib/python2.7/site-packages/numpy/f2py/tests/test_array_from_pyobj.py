from __future__ import division, absolute_import, print_function

import unittest
***REMOVED***
import sys
import copy

from numpy import (
    array, alltrue, ndarray, zeros, dtype, intp, clongdouble
***REMOVED***
from numpy.testing import (
    run_module_suite, assert_, assert_equal, SkipTest
***REMOVED***
from numpy.core.multiarray import typeinfo
import util

wrap = None


def setup(***REMOVED***:
    ***REMOVED***
    Build the required testing extension module

    ***REMOVED***
    global wrap

    # Check compiler availability first
    if not util.has_c_compiler(***REMOVED***:
        raise SkipTest("No C compiler available"***REMOVED***

    if wrap is None:
        config_code = ***REMOVED***
        config.add_extension('test_array_from_pyobj_ext',
                             sources=['wrapmodule.c', 'fortranobject.c'***REMOVED***,
                             define_macros=[***REMOVED******REMOVED***
        ***REMOVED***
        d = os.path.dirname(__file__***REMOVED***
        src = [os.path.join(d, 'src', 'array_from_pyobj', 'wrapmodule.c'***REMOVED***,
               os.path.join(d, '..', 'src', 'fortranobject.c'***REMOVED***,
               os.path.join(d, '..', 'src', 'fortranobject.h'***REMOVED******REMOVED***
        wrap = util.build_module_distutils(src, config_code,
                                           'test_array_from_pyobj_ext'***REMOVED***


def flags_info(arr***REMOVED***:
    flags = wrap.array_attrs(arr***REMOVED***[6***REMOVED***
    return flags2names(flags***REMOVED***


def flags2names(flags***REMOVED***:
    info = [***REMOVED***
    for flagname in ['CONTIGUOUS', 'FORTRAN', 'OWNDATA', 'ENSURECOPY',
                     'ENSUREARRAY', 'ALIGNED', 'NOTSWAPPED', 'WRITEABLE',
                     'UPDATEIFCOPY', 'BEHAVED', 'BEHAVED_RO',
                     'CARRAY', 'FARRAY'
                     ***REMOVED***:
        if abs(flags***REMOVED*** & getattr(wrap, flagname, 0***REMOVED***:
            info.append(flagname***REMOVED***
    return info


class Intent(object***REMOVED***:

    def __init__(self, intent_list=[***REMOVED******REMOVED***:
        self.intent_list = intent_list[:***REMOVED***
        flags = 0
        for i in intent_list:
            if i == 'optional':
                flags |= wrap.F2PY_OPTIONAL
            else:
                flags |= getattr(wrap, 'F2PY_INTENT_' + i.upper(***REMOVED******REMOVED***
        self.flags = flags

    def __getattr__(self, name***REMOVED***:
        name = name.lower(***REMOVED***
        if name == 'in_':
            name = 'in'
        return self.__class__(self.intent_list + [name***REMOVED******REMOVED***

    def __str__(self***REMOVED***:
        return 'intent(%s***REMOVED***' % (','.join(self.intent_list***REMOVED******REMOVED***

    def __repr__(self***REMOVED***:
        return 'Intent(%r***REMOVED***' % (self.intent_list***REMOVED***

    def is_intent(self, *names***REMOVED***:
        for name in names:
            if name not in self.intent_list:
                return False
        return True

    def is_intent_exact(self, *names***REMOVED***:
        return len(self.intent_list***REMOVED*** == len(names***REMOVED*** and self.is_intent(*names***REMOVED***

intent = Intent(***REMOVED***

_type_names = ['BOOL', 'BYTE', 'UBYTE', 'SHORT', 'USHORT', 'INT', 'UINT',
               'LONG', 'ULONG', 'LONGLONG', 'ULONGLONG',
               'FLOAT', 'DOUBLE', 'CFLOAT'***REMOVED***

_cast_dict = {'BOOL': ['BOOL'***REMOVED******REMOVED***
_cast_dict['BYTE'***REMOVED*** = _cast_dict['BOOL'***REMOVED*** + ['BYTE'***REMOVED***
_cast_dict['UBYTE'***REMOVED*** = _cast_dict['BOOL'***REMOVED*** + ['UBYTE'***REMOVED***
_cast_dict['BYTE'***REMOVED*** = ['BYTE'***REMOVED***
_cast_dict['UBYTE'***REMOVED*** = ['UBYTE'***REMOVED***
_cast_dict['SHORT'***REMOVED*** = _cast_dict['BYTE'***REMOVED*** + ['UBYTE', 'SHORT'***REMOVED***
_cast_dict['USHORT'***REMOVED*** = _cast_dict['UBYTE'***REMOVED*** + ['BYTE', 'USHORT'***REMOVED***
_cast_dict['INT'***REMOVED*** = _cast_dict['SHORT'***REMOVED*** + ['USHORT', 'INT'***REMOVED***
_cast_dict['UINT'***REMOVED*** = _cast_dict['USHORT'***REMOVED*** + ['SHORT', 'UINT'***REMOVED***

_cast_dict['LONG'***REMOVED*** = _cast_dict['INT'***REMOVED*** + ['LONG'***REMOVED***
_cast_dict['ULONG'***REMOVED*** = _cast_dict['UINT'***REMOVED*** + ['ULONG'***REMOVED***

_cast_dict['LONGLONG'***REMOVED*** = _cast_dict['LONG'***REMOVED*** + ['LONGLONG'***REMOVED***
_cast_dict['ULONGLONG'***REMOVED*** = _cast_dict['ULONG'***REMOVED*** + ['ULONGLONG'***REMOVED***

_cast_dict['FLOAT'***REMOVED*** = _cast_dict['SHORT'***REMOVED*** + ['USHORT', 'FLOAT'***REMOVED***
_cast_dict['DOUBLE'***REMOVED*** = _cast_dict['INT'***REMOVED*** + ['UINT', 'FLOAT', 'DOUBLE'***REMOVED***

_cast_dict['CFLOAT'***REMOVED*** = _cast_dict['FLOAT'***REMOVED*** + ['CFLOAT'***REMOVED***

# 32 bit system malloc typically does not provide the alignment required by
# 16 byte long double types this means the inout intent cannot be satisfied
# and several tests fail as the alignment flag can be randomly true or fals
# when numpy gains an aligned allocator the tests could be enabled again
if ((intp(***REMOVED***.dtype.itemsize != 4 or clongdouble(***REMOVED***.dtype.alignment <= 8***REMOVED*** and
        sys.platform != 'win32'***REMOVED***:
    _type_names.extend(['LONGDOUBLE', 'CDOUBLE', 'CLONGDOUBLE'***REMOVED******REMOVED***
    _cast_dict['LONGDOUBLE'***REMOVED*** = _cast_dict['LONG'***REMOVED*** + \
        ['ULONG', 'FLOAT', 'DOUBLE', 'LONGDOUBLE'***REMOVED***
    _cast_dict['CLONGDOUBLE'***REMOVED*** = _cast_dict['LONGDOUBLE'***REMOVED*** + \
        ['CFLOAT', 'CDOUBLE', 'CLONGDOUBLE'***REMOVED***
    _cast_dict['CDOUBLE'***REMOVED*** = _cast_dict['DOUBLE'***REMOVED*** + ['CFLOAT', 'CDOUBLE'***REMOVED***


class Type(object***REMOVED***:
    _type_cache = {***REMOVED***

    def __new__(cls, name***REMOVED***:
        if isinstance(name, dtype***REMOVED***:
            dtype0 = name
            name = None
            for n, i in typeinfo.items(***REMOVED***:
                if isinstance(i, tuple***REMOVED*** and dtype0.type is i[-1***REMOVED***:
                    name = n
                    break
        obj = cls._type_cache.get(name.upper(***REMOVED***, None***REMOVED***
        if obj is not None:
            return obj
        obj = object.__new__(cls***REMOVED***
        obj._init(name***REMOVED***
        cls._type_cache[name.upper(***REMOVED******REMOVED*** = obj
        return obj

    def _init(self, name***REMOVED***:
        self.NAME = name.upper(***REMOVED***
        self.type_num = getattr(wrap, 'NPY_' + self.NAME***REMOVED***
        assert_equal(self.type_num, typeinfo[self.NAME***REMOVED***[1***REMOVED******REMOVED***
        self.dtype = typeinfo[self.NAME***REMOVED***[-1***REMOVED***
        self.elsize = typeinfo[self.NAME***REMOVED***[2***REMOVED*** / 8
        self.dtypechar = typeinfo[self.NAME***REMOVED***[0***REMOVED***

    def cast_types(self***REMOVED***:
        return [self.__class__(_m***REMOVED*** for _m in _cast_dict[self.NAME***REMOVED******REMOVED***

    def all_types(self***REMOVED***:
        return [self.__class__(_m***REMOVED*** for _m in _type_names***REMOVED***

    def smaller_types(self***REMOVED***:
        bits = typeinfo[self.NAME***REMOVED***[3***REMOVED***
        types = [***REMOVED***
        for name in _type_names:
            if typeinfo[name***REMOVED***[3***REMOVED*** < bits:
                types.append(Type(name***REMOVED******REMOVED***
        return types

    def equal_types(self***REMOVED***:
        bits = typeinfo[self.NAME***REMOVED***[3***REMOVED***
        types = [***REMOVED***
        for name in _type_names:
            if name == self.NAME:
                continue
            if typeinfo[name***REMOVED***[3***REMOVED*** == bits:
                types.append(Type(name***REMOVED******REMOVED***
        return types

    def larger_types(self***REMOVED***:
        bits = typeinfo[self.NAME***REMOVED***[3***REMOVED***
        types = [***REMOVED***
        for name in _type_names:
            if typeinfo[name***REMOVED***[3***REMOVED*** > bits:
                types.append(Type(name***REMOVED******REMOVED***
        return types


class Array(object***REMOVED***:

    def __init__(self, typ, dims, intent, obj***REMOVED***:
        self.type = typ
        self.dims = dims
        self.intent = intent
        self.obj_copy = copy.deepcopy(obj***REMOVED***
        self.obj = obj

        # arr.dtypechar may be different from typ.dtypechar
        self.arr = wrap.call(typ.type_num, dims, intent.flags, obj***REMOVED***

        assert_(isinstance(self.arr, ndarray***REMOVED***, repr(type(self.arr***REMOVED******REMOVED******REMOVED***

        self.arr_attr = wrap.array_attrs(self.arr***REMOVED***

        if len(dims***REMOVED*** > 1:
            if self.intent.is_intent('c'***REMOVED***:
                assert_(intent.flags & wrap.F2PY_INTENT_C***REMOVED***
                assert_(not self.arr.flags['FORTRAN'***REMOVED***,
                        repr((self.arr.flags, getattr(obj, 'flags', None***REMOVED******REMOVED******REMOVED******REMOVED***
                assert_(self.arr.flags['CONTIGUOUS'***REMOVED******REMOVED***
                assert_(not self.arr_attr[6***REMOVED*** & wrap.FORTRAN***REMOVED***
            else:
                assert_(not intent.flags & wrap.F2PY_INTENT_C***REMOVED***
                assert_(self.arr.flags['FORTRAN'***REMOVED******REMOVED***
                assert_(not self.arr.flags['CONTIGUOUS'***REMOVED******REMOVED***
                assert_(self.arr_attr[6***REMOVED*** & wrap.FORTRAN***REMOVED***

        if obj is None:
            self.pyarr = None
            self.pyarr_attr = None
            return

        if intent.is_intent('cache'***REMOVED***:
            assert_(isinstance(obj, ndarray***REMOVED***, repr(type(obj***REMOVED******REMOVED******REMOVED***
            self.pyarr = array(obj***REMOVED***.reshape(*dims***REMOVED***.copy(***REMOVED***
        else:
            self.pyarr = array(array(obj, dtype=typ.dtypechar***REMOVED***.reshape(*dims***REMOVED***,
                               order=self.intent.is_intent('c'***REMOVED*** and 'C' or 'F'***REMOVED***
            assert_(self.pyarr.dtype == typ,
                    repr((self.pyarr.dtype, typ***REMOVED******REMOVED******REMOVED***
        assert_(self.pyarr.flags['OWNDATA'***REMOVED***, (obj, intent***REMOVED******REMOVED***
        self.pyarr_attr = wrap.array_attrs(self.pyarr***REMOVED***

        if len(dims***REMOVED*** > 1:
            if self.intent.is_intent('c'***REMOVED***:
                assert_(not self.pyarr.flags['FORTRAN'***REMOVED******REMOVED***
                assert_(self.pyarr.flags['CONTIGUOUS'***REMOVED******REMOVED***
                assert_(not self.pyarr_attr[6***REMOVED*** & wrap.FORTRAN***REMOVED***
            else:
                assert_(self.pyarr.flags['FORTRAN'***REMOVED******REMOVED***
                assert_(not self.pyarr.flags['CONTIGUOUS'***REMOVED******REMOVED***
                assert_(self.pyarr_attr[6***REMOVED*** & wrap.FORTRAN***REMOVED***

        assert_(self.arr_attr[1***REMOVED*** == self.pyarr_attr[1***REMOVED******REMOVED***  # nd
        assert_(self.arr_attr[2***REMOVED*** == self.pyarr_attr[2***REMOVED******REMOVED***  # dimensions
        if self.arr_attr[1***REMOVED*** <= 1:
            assert_(self.arr_attr[3***REMOVED*** == self.pyarr_attr[3***REMOVED***,
                    repr((self.arr_attr[3***REMOVED***, self.pyarr_attr[3***REMOVED***,
                          self.arr.tobytes(***REMOVED***, self.pyarr.tobytes(***REMOVED******REMOVED******REMOVED******REMOVED***  # strides
        assert_(self.arr_attr[5***REMOVED***[-2:***REMOVED*** == self.pyarr_attr[5***REMOVED***[-2:***REMOVED***,
                repr((self.arr_attr[5***REMOVED***, self.pyarr_attr[5***REMOVED******REMOVED******REMOVED******REMOVED***  # descr
        assert_(self.arr_attr[6***REMOVED*** == self.pyarr_attr[6***REMOVED***,
                repr((self.arr_attr[6***REMOVED***, self.pyarr_attr[6***REMOVED***,
                      flags2names(0 * self.arr_attr[6***REMOVED*** - self.pyarr_attr[6***REMOVED******REMOVED***,
                      flags2names(self.arr_attr[6***REMOVED******REMOVED***, intent***REMOVED******REMOVED******REMOVED***  # flags

        if intent.is_intent('cache'***REMOVED***:
            assert_(self.arr_attr[5***REMOVED***[3***REMOVED*** >= self.type.elsize,
                    repr((self.arr_attr[5***REMOVED***[3***REMOVED***, self.type.elsize***REMOVED******REMOVED******REMOVED***
        else:
            assert_(self.arr_attr[5***REMOVED***[3***REMOVED*** == self.type.elsize,
                    repr((self.arr_attr[5***REMOVED***[3***REMOVED***, self.type.elsize***REMOVED******REMOVED******REMOVED***
        assert_(self.arr_equal(self.pyarr, self.arr***REMOVED******REMOVED***

        if isinstance(self.obj, ndarray***REMOVED***:
            if typ.elsize == Type(obj.dtype***REMOVED***.elsize:
                if not intent.is_intent('copy'***REMOVED*** and self.arr_attr[1***REMOVED*** <= 1:
                    assert_(self.has_shared_memory(***REMOVED******REMOVED***

    def arr_equal(self, arr1, arr2***REMOVED***:
        if arr1.shape != arr2.shape:
            return False
        s = arr1 == arr2
        return alltrue(s.flatten(***REMOVED******REMOVED***

    def __str__(self***REMOVED***:
        return str(self.arr***REMOVED***

    def has_shared_memory(self***REMOVED***:
        ***REMOVED***Check that created array shares data with input array.
        ***REMOVED***
        if self.obj is self.arr:
            return True
        if not isinstance(self.obj, ndarray***REMOVED***:
            return False
        obj_attr = wrap.array_attrs(self.obj***REMOVED***
        return obj_attr[0***REMOVED*** == self.arr_attr[0***REMOVED***


class test_intent(unittest.TestCase***REMOVED***:

    def test_in_out(self***REMOVED***:
        assert_equal(str(intent.in_.out***REMOVED***, 'intent(in,out***REMOVED***'***REMOVED***
        assert_(intent.in_.c.is_intent('c'***REMOVED******REMOVED***
        assert_(not intent.in_.c.is_intent_exact('c'***REMOVED******REMOVED***
        assert_(intent.in_.c.is_intent_exact('c', 'in'***REMOVED******REMOVED***
        assert_(intent.in_.c.is_intent_exact('in', 'c'***REMOVED******REMOVED***
        assert_(not intent.in_.is_intent('c'***REMOVED******REMOVED***


class _test_shared_memory:
    num2seq = [1, 2***REMOVED***
    num23seq = [[1, 2, 3***REMOVED***, [4, 5, 6***REMOVED******REMOVED***

    def test_in_from_2seq(self***REMOVED***:
        a = self.array([2***REMOVED***, intent.in_, self.num2seq***REMOVED***
        assert_(not a.has_shared_memory(***REMOVED******REMOVED***

    def test_in_from_2casttype(self***REMOVED***:
        for t in self.type.cast_types(***REMOVED***:
            obj = array(self.num2seq, dtype=t.dtype***REMOVED***
            a = self.array([len(self.num2seq***REMOVED******REMOVED***, intent.in_, obj***REMOVED***
            if t.elsize == self.type.elsize:
                assert_(
                    a.has_shared_memory(***REMOVED***, repr((self.type.dtype, t.dtype***REMOVED******REMOVED******REMOVED***
            else:
                assert_(not a.has_shared_memory(***REMOVED***, repr(t.dtype***REMOVED******REMOVED***

    def test_inout_2seq(self***REMOVED***:
        obj = array(self.num2seq, dtype=self.type.dtype***REMOVED***
        a = self.array([len(self.num2seq***REMOVED******REMOVED***, intent.inout, obj***REMOVED***
        assert_(a.has_shared_memory(***REMOVED******REMOVED***

        ***REMOVED***
            a = self.array([2***REMOVED***, intent.in_.inout, self.num2seq***REMOVED***
        except TypeError as msg:
            if not str(msg***REMOVED***.startswith('failed to initialize intent'
                                       '(inout|inplace|cache***REMOVED*** array'***REMOVED***:
                raise
        else:
            raise SystemError('intent(inout***REMOVED*** should have failed on sequence'***REMOVED***

    def test_f_inout_23seq(self***REMOVED***:
        obj = array(self.num23seq, dtype=self.type.dtype, order='F'***REMOVED***
        shape = (len(self.num23seq***REMOVED***, len(self.num23seq[0***REMOVED******REMOVED******REMOVED***
        a = self.array(shape, intent.in_.inout, obj***REMOVED***
        assert_(a.has_shared_memory(***REMOVED******REMOVED***

        obj = array(self.num23seq, dtype=self.type.dtype, order='C'***REMOVED***
        shape = (len(self.num23seq***REMOVED***, len(self.num23seq[0***REMOVED******REMOVED******REMOVED***
        ***REMOVED***
            a = self.array(shape, intent.in_.inout, obj***REMOVED***
        except ValueError as msg:
            if not str(msg***REMOVED***.startswith('failed to initialize intent'
                                       '(inout***REMOVED*** array'***REMOVED***:
                raise
        else:
            raise SystemError(
                'intent(inout***REMOVED*** should have failed on improper array'***REMOVED***

    def test_c_inout_23seq(self***REMOVED***:
        obj = array(self.num23seq, dtype=self.type.dtype***REMOVED***
        shape = (len(self.num23seq***REMOVED***, len(self.num23seq[0***REMOVED******REMOVED******REMOVED***
        a = self.array(shape, intent.in_.c.inout, obj***REMOVED***
        assert_(a.has_shared_memory(***REMOVED******REMOVED***

    def test_in_copy_from_2casttype(self***REMOVED***:
        for t in self.type.cast_types(***REMOVED***:
            obj = array(self.num2seq, dtype=t.dtype***REMOVED***
            a = self.array([len(self.num2seq***REMOVED******REMOVED***, intent.in_.copy, obj***REMOVED***
            assert_(not a.has_shared_memory(***REMOVED***, repr(t.dtype***REMOVED******REMOVED***

    def test_c_in_from_23seq(self***REMOVED***:
        a = self.array([len(self.num23seq***REMOVED***, len(self.num23seq[0***REMOVED******REMOVED******REMOVED***,
                       intent.in_, self.num23seq***REMOVED***
        assert_(not a.has_shared_memory(***REMOVED******REMOVED***

    def test_in_from_23casttype(self***REMOVED***:
        for t in self.type.cast_types(***REMOVED***:
            obj = array(self.num23seq, dtype=t.dtype***REMOVED***
            a = self.array([len(self.num23seq***REMOVED***, len(self.num23seq[0***REMOVED******REMOVED******REMOVED***,
                           intent.in_, obj***REMOVED***
            assert_(not a.has_shared_memory(***REMOVED***, repr(t.dtype***REMOVED******REMOVED***

    def test_f_in_from_23casttype(self***REMOVED***:
        for t in self.type.cast_types(***REMOVED***:
            obj = array(self.num23seq, dtype=t.dtype, order='F'***REMOVED***
            a = self.array([len(self.num23seq***REMOVED***, len(self.num23seq[0***REMOVED******REMOVED******REMOVED***,
                           intent.in_, obj***REMOVED***
            if t.elsize == self.type.elsize:
                assert_(a.has_shared_memory(***REMOVED***, repr(t.dtype***REMOVED******REMOVED***
            else:
                assert_(not a.has_shared_memory(***REMOVED***, repr(t.dtype***REMOVED******REMOVED***

    def test_c_in_from_23casttype(self***REMOVED***:
        for t in self.type.cast_types(***REMOVED***:
            obj = array(self.num23seq, dtype=t.dtype***REMOVED***
            a = self.array([len(self.num23seq***REMOVED***, len(self.num23seq[0***REMOVED******REMOVED******REMOVED***,
                           intent.in_.c, obj***REMOVED***
            if t.elsize == self.type.elsize:
                assert_(a.has_shared_memory(***REMOVED***, repr(t.dtype***REMOVED******REMOVED***
            else:
                assert_(not a.has_shared_memory(***REMOVED***, repr(t.dtype***REMOVED******REMOVED***

    def test_f_copy_in_from_23casttype(self***REMOVED***:
        for t in self.type.cast_types(***REMOVED***:
            obj = array(self.num23seq, dtype=t.dtype, order='F'***REMOVED***
            a = self.array([len(self.num23seq***REMOVED***, len(self.num23seq[0***REMOVED******REMOVED******REMOVED***,
                           intent.in_.copy, obj***REMOVED***
            assert_(not a.has_shared_memory(***REMOVED***, repr(t.dtype***REMOVED******REMOVED***

    def test_c_copy_in_from_23casttype(self***REMOVED***:
        for t in self.type.cast_types(***REMOVED***:
            obj = array(self.num23seq, dtype=t.dtype***REMOVED***
            a = self.array([len(self.num23seq***REMOVED***, len(self.num23seq[0***REMOVED******REMOVED******REMOVED***,
                           intent.in_.c.copy, obj***REMOVED***
            assert_(not a.has_shared_memory(***REMOVED***, repr(t.dtype***REMOVED******REMOVED***

    def test_in_cache_from_2casttype(self***REMOVED***:
        for t in self.type.all_types(***REMOVED***:
            if t.elsize != self.type.elsize:
                continue
            obj = array(self.num2seq, dtype=t.dtype***REMOVED***
            shape = (len(self.num2seq***REMOVED***,***REMOVED***
            a = self.array(shape, intent.in_.c.cache, obj***REMOVED***
            assert_(a.has_shared_memory(***REMOVED***, repr(t.dtype***REMOVED******REMOVED***

            a = self.array(shape, intent.in_.cache, obj***REMOVED***
            assert_(a.has_shared_memory(***REMOVED***, repr(t.dtype***REMOVED******REMOVED***

            obj = array(self.num2seq, dtype=t.dtype, order='F'***REMOVED***
            a = self.array(shape, intent.in_.c.cache, obj***REMOVED***
            assert_(a.has_shared_memory(***REMOVED***, repr(t.dtype***REMOVED******REMOVED***

            a = self.array(shape, intent.in_.cache, obj***REMOVED***
            assert_(a.has_shared_memory(***REMOVED***, repr(t.dtype***REMOVED******REMOVED***

            ***REMOVED***
                a = self.array(shape, intent.in_.cache, obj[::-1***REMOVED******REMOVED***
            except ValueError as msg:
                if not str(msg***REMOVED***.startswith('failed to initialize'
                                           ' intent(cache***REMOVED*** array'***REMOVED***:
                    raise
            else:
                raise SystemError(
                    'intent(cache***REMOVED*** should have failed on multisegmented array'***REMOVED***

    def test_in_cache_from_2casttype_failure(self***REMOVED***:
        for t in self.type.all_types(***REMOVED***:
            if t.elsize >= self.type.elsize:
                continue
            obj = array(self.num2seq, dtype=t.dtype***REMOVED***
            shape = (len(self.num2seq***REMOVED***,***REMOVED***
            ***REMOVED***
                self.array(shape, intent.in_.cache, obj***REMOVED***  # Should succeed
            except ValueError as msg:
                if not str(msg***REMOVED***.startswith('failed to initialize'
                                           ' intent(cache***REMOVED*** array'***REMOVED***:
                    raise
            else:
                raise SystemError(
                    'intent(cache***REMOVED*** should have failed on smaller array'***REMOVED***

    def test_cache_hidden(self***REMOVED***:
        shape = (2,***REMOVED***
        a = self.array(shape, intent.cache.hide, None***REMOVED***
        assert_(a.arr.shape == shape***REMOVED***

        shape = (2, 3***REMOVED***
        a = self.array(shape, intent.cache.hide, None***REMOVED***
        assert_(a.arr.shape == shape***REMOVED***

        shape = (-1, 3***REMOVED***
        ***REMOVED***
            a = self.array(shape, intent.cache.hide, None***REMOVED***
        except ValueError as msg:
            if not str(msg***REMOVED***.startswith('failed to create intent'
                                       '(cache|hide***REMOVED***|optional array'***REMOVED***:
                raise
        else:
            raise SystemError(
                'intent(cache***REMOVED*** should have failed on undefined dimensions'***REMOVED***

    def test_hidden(self***REMOVED***:
        shape = (2,***REMOVED***
        a = self.array(shape, intent.hide, None***REMOVED***
        assert_(a.arr.shape == shape***REMOVED***
        assert_(a.arr_equal(a.arr, zeros(shape, dtype=self.type.dtype***REMOVED******REMOVED******REMOVED***

        shape = (2, 3***REMOVED***
        a = self.array(shape, intent.hide, None***REMOVED***
        assert_(a.arr.shape == shape***REMOVED***
        assert_(a.arr_equal(a.arr, zeros(shape, dtype=self.type.dtype***REMOVED******REMOVED******REMOVED***
        assert_(a.arr.flags['FORTRAN'***REMOVED*** and not a.arr.flags['CONTIGUOUS'***REMOVED******REMOVED***

        shape = (2, 3***REMOVED***
        a = self.array(shape, intent.c.hide, None***REMOVED***
        assert_(a.arr.shape == shape***REMOVED***
        assert_(a.arr_equal(a.arr, zeros(shape, dtype=self.type.dtype***REMOVED******REMOVED******REMOVED***
        assert_(not a.arr.flags['FORTRAN'***REMOVED*** and a.arr.flags['CONTIGUOUS'***REMOVED******REMOVED***

        shape = (-1, 3***REMOVED***
        ***REMOVED***
            a = self.array(shape, intent.hide, None***REMOVED***
        except ValueError as msg:
            if not str(msg***REMOVED***.startswith('failed to create intent'
                                       '(cache|hide***REMOVED***|optional array'***REMOVED***:
                raise
        else:
            raise SystemError('intent(hide***REMOVED*** should have failed'
                              ' on undefined dimensions'***REMOVED***

    def test_optional_none(self***REMOVED***:
        shape = (2,***REMOVED***
        a = self.array(shape, intent.optional, None***REMOVED***
        assert_(a.arr.shape == shape***REMOVED***
        assert_(a.arr_equal(a.arr, zeros(shape, dtype=self.type.dtype***REMOVED******REMOVED******REMOVED***

        shape = (2, 3***REMOVED***
        a = self.array(shape, intent.optional, None***REMOVED***
        assert_(a.arr.shape == shape***REMOVED***
        assert_(a.arr_equal(a.arr, zeros(shape, dtype=self.type.dtype***REMOVED******REMOVED******REMOVED***
        assert_(a.arr.flags['FORTRAN'***REMOVED*** and not a.arr.flags['CONTIGUOUS'***REMOVED******REMOVED***

        shape = (2, 3***REMOVED***
        a = self.array(shape, intent.c.optional, None***REMOVED***
        assert_(a.arr.shape == shape***REMOVED***
        assert_(a.arr_equal(a.arr, zeros(shape, dtype=self.type.dtype***REMOVED******REMOVED******REMOVED***
        assert_(not a.arr.flags['FORTRAN'***REMOVED*** and a.arr.flags['CONTIGUOUS'***REMOVED******REMOVED***

    def test_optional_from_2seq(self***REMOVED***:
        obj = self.num2seq
        shape = (len(obj***REMOVED***,***REMOVED***
        a = self.array(shape, intent.optional, obj***REMOVED***
        assert_(a.arr.shape == shape***REMOVED***
        assert_(not a.has_shared_memory(***REMOVED******REMOVED***

    def test_optional_from_23seq(self***REMOVED***:
        obj = self.num23seq
        shape = (len(obj***REMOVED***, len(obj[0***REMOVED******REMOVED******REMOVED***
        a = self.array(shape, intent.optional, obj***REMOVED***
        assert_(a.arr.shape == shape***REMOVED***
        assert_(not a.has_shared_memory(***REMOVED******REMOVED***

        a = self.array(shape, intent.optional.c, obj***REMOVED***
        assert_(a.arr.shape == shape***REMOVED***
        assert_(not a.has_shared_memory(***REMOVED******REMOVED***

    def test_inplace(self***REMOVED***:
        obj = array(self.num23seq, dtype=self.type.dtype***REMOVED***
        assert_(not obj.flags['FORTRAN'***REMOVED*** and obj.flags['CONTIGUOUS'***REMOVED******REMOVED***
        shape = obj.shape
        a = self.array(shape, intent.inplace, obj***REMOVED***
        assert_(obj[1***REMOVED***[2***REMOVED*** == a.arr[1***REMOVED***[2***REMOVED***, repr((obj, a.arr***REMOVED******REMOVED******REMOVED***
        a.arr[1***REMOVED***[2***REMOVED*** = 54
        assert_(obj[1***REMOVED***[2***REMOVED*** == a.arr[1***REMOVED***[2***REMOVED*** ==
                array(54, dtype=self.type.dtype***REMOVED***, repr((obj, a.arr***REMOVED******REMOVED******REMOVED***
        assert_(a.arr is obj***REMOVED***
        assert_(obj.flags['FORTRAN'***REMOVED******REMOVED***  # obj attributes are changed inplace!
        assert_(not obj.flags['CONTIGUOUS'***REMOVED******REMOVED***

    def test_inplace_from_casttype(self***REMOVED***:
        for t in self.type.cast_types(***REMOVED***:
            if t is self.type:
                continue
            obj = array(self.num23seq, dtype=t.dtype***REMOVED***
            assert_(obj.dtype.type == t.dtype***REMOVED***
            assert_(obj.dtype.type is not self.type.dtype***REMOVED***
            assert_(not obj.flags['FORTRAN'***REMOVED*** and obj.flags['CONTIGUOUS'***REMOVED******REMOVED***
            shape = obj.shape
            a = self.array(shape, intent.inplace, obj***REMOVED***
            assert_(obj[1***REMOVED***[2***REMOVED*** == a.arr[1***REMOVED***[2***REMOVED***, repr((obj, a.arr***REMOVED******REMOVED******REMOVED***
            a.arr[1***REMOVED***[2***REMOVED*** = 54
            assert_(obj[1***REMOVED***[2***REMOVED*** == a.arr[1***REMOVED***[2***REMOVED*** ==
                    array(54, dtype=self.type.dtype***REMOVED***, repr((obj, a.arr***REMOVED******REMOVED******REMOVED***
            assert_(a.arr is obj***REMOVED***
            assert_(obj.flags['FORTRAN'***REMOVED******REMOVED***  # obj attributes changed inplace!
            assert_(not obj.flags['CONTIGUOUS'***REMOVED******REMOVED***
            assert_(obj.dtype.type is self.type.dtype***REMOVED***  # obj changed inplace!


for t in _type_names:
    exec('''\
class test_%s_gen(unittest.TestCase,
              _test_shared_memory
              ***REMOVED***:
    def setUp(self***REMOVED***:
        self.type = Type(%r***REMOVED***
    array = lambda self,dims,intent,obj: Array(Type(%r***REMOVED***,dims,intent,obj***REMOVED***
''' % (t, t, t***REMOVED******REMOVED***

if __name__ == "__main__":
    setup(***REMOVED***
    run_module_suite(***REMOVED***
