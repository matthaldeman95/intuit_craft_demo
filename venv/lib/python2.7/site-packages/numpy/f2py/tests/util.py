***REMOVED***
Utility functions for

- building and importing modules on test time, using a temporary location
- detecting if compilers are present

***REMOVED***
from __future__ import division, absolute_import, print_function

***REMOVED***
import sys
import subprocess
import tempfile
import shutil
import atexit
import textwrap
import re
import random

from numpy.compat import asbytes, asstr
import numpy.f2py
from numpy.testing import SkipTest, temppath

***REMOVED***
    from hashlib import md5
except ImportError:
    from md5 import new as md5

#
# Maintaining a temporary module directory
#

_module_dir = None


def _cleanup(***REMOVED***:
    global _module_dir
    if _module_dir is not None:
        ***REMOVED***
            sys.path.remove(_module_dir***REMOVED***
        except ValueError:
            pass
        ***REMOVED***
            shutil.rmtree(_module_dir***REMOVED***
        except (IOError, OSError***REMOVED***:
            pass
        _module_dir = None


def get_module_dir(***REMOVED***:
    global _module_dir
    if _module_dir is None:
        _module_dir = tempfile.mkdtemp(***REMOVED***
        atexit.register(_cleanup***REMOVED***
        if _module_dir not in sys.path:
            sys.path.insert(0, _module_dir***REMOVED***
    return _module_dir


def get_temp_module_name(***REMOVED***:
    # Assume single-threaded, and the module dir usable only by this thread
    d = get_module_dir(***REMOVED***
    for j in range(5403, 9999999***REMOVED***:
        name = "_test_ext_module_%d" % j
        fn = os.path.join(d, name***REMOVED***
        if name not in sys.modules and not os.path.isfile(fn + '.py'***REMOVED***:
            return name
    raise RuntimeError("Failed to create a temporary module name"***REMOVED***


def _memoize(func***REMOVED***:
    memo = {***REMOVED***

    def wrapper(*a, **kw***REMOVED***:
        key = repr((a, kw***REMOVED******REMOVED***
        if key not in memo:
            ***REMOVED***
                memo[key***REMOVED*** = func(*a, **kw***REMOVED***
            except Exception as e:
                memo[key***REMOVED*** = e
                raise
        ret = memo[key***REMOVED***
        if isinstance(ret, Exception***REMOVED***:
            raise ret
        return ret
    wrapper.__name__ = func.__name__
    return wrapper

#
# Building modules
#


@_memoize
def build_module(source_files, options=[***REMOVED***, skip=[***REMOVED***, only=[***REMOVED***, module_name=None***REMOVED***:
    ***REMOVED***
    Compile and import a f2py module, built from the given files.

    ***REMOVED***

    code = ("import sys; sys.path = %s; import numpy.f2py as f2py2e; "
            "f2py2e.main(***REMOVED***" % repr(sys.path***REMOVED******REMOVED***

    d = get_module_dir(***REMOVED***

    # Copy files
    dst_sources = [***REMOVED***
    for fn in source_files:
        if not os.path.isfile(fn***REMOVED***:
            raise RuntimeError("%s is not a file" % fn***REMOVED***
        dst = os.path.join(d, os.path.basename(fn***REMOVED******REMOVED***
        shutil.copyfile(fn, dst***REMOVED***
        dst_sources.append(dst***REMOVED***

        fn = os.path.join(os.path.dirname(fn***REMOVED***, '.f2py_f2cmap'***REMOVED***
        if os.path.isfile(fn***REMOVED***:
            dst = os.path.join(d, os.path.basename(fn***REMOVED******REMOVED***
            if not os.path.isfile(dst***REMOVED***:
                shutil.copyfile(fn, dst***REMOVED***

    # Prepare options
    if module_name is None:
        module_name = get_temp_module_name(***REMOVED***
    f2py_opts = ['-c', '-m', module_name***REMOVED*** + options + dst_sources
    if skip:
        f2py_opts += ['skip:'***REMOVED*** + skip
    if only:
        f2py_opts += ['only:'***REMOVED*** + only

    # Build
    cwd = os.getcwd(***REMOVED***
    ***REMOVED***
        os.chdir(d***REMOVED***
        cmd = [sys.executable, '-c', code***REMOVED*** + f2py_opts
        p = subprocess.Popen(cmd, stdout=subprocess.PIPE,
                             stderr=subprocess.STDOUT***REMOVED***
        out, err = p.communicate(***REMOVED***
        if p.returncode != 0:
            raise RuntimeError("Running f2py failed: %s\n%s"
                               % (cmd[4:***REMOVED***, asstr(out***REMOVED******REMOVED******REMOVED***
    finally:
        os.chdir(cwd***REMOVED***

        # Partial cleanup
        for fn in dst_sources:
            os.unlink(fn***REMOVED***

    # Import
    __import__(module_name***REMOVED***
    return sys.modules[module_name***REMOVED***


@_memoize
def build_code(source_code, options=[***REMOVED***, skip=[***REMOVED***, only=[***REMOVED***, suffix=None,
               module_name=None***REMOVED***:
    ***REMOVED***
    Compile and import Fortran code using f2py.

    ***REMOVED***
    if suffix is None:
        suffix = '.f'
    with temppath(suffix=suffix***REMOVED*** as path:
        with open(path, 'w'***REMOVED*** as f:
            f.write(source_code***REMOVED***
        return build_module([path***REMOVED***, options=options, skip=skip, only=only,
                            module_name=module_name***REMOVED***

#
# Check if compilers are available at all...
#

_compiler_status = None


def _get_compiler_status(***REMOVED***:
    global _compiler_status
    if _compiler_status is not None:
        return _compiler_status

    _compiler_status = (False, False, False***REMOVED***

    # XXX: this is really ugly. But I don't know how to invoke Distutils
    #      in a safer way...
    code = ***REMOVED***
***REMOVED***
import sys
sys.path = %(syspath***REMOVED***s

def configuration(parent_name='',top_path=None***REMOVED***:
    global config
    from numpy.distutils.misc_util import Configuration
    config = Configuration('', parent_name, top_path***REMOVED***
    return config

from numpy.distutils.core import setup
setup(configuration=configuration***REMOVED***

config_cmd = config.get_config_cmd(***REMOVED***
have_c = config_cmd.try_compile('void foo(***REMOVED*** {***REMOVED***'***REMOVED***
print('COMPILERS:%%d,%%d,%%d' %% (have_c,
                                  config.have_f77c(***REMOVED***,
                                  config.have_f90c(***REMOVED******REMOVED******REMOVED***
sys.exit(99***REMOVED***
***REMOVED***
    code = code % dict(syspath=repr(sys.path***REMOVED******REMOVED***

    with temppath(suffix='.py'***REMOVED*** as script:
        with open(script, 'w'***REMOVED*** as f:
            f.write(code***REMOVED***

        cmd = [sys.executable, script, 'config'***REMOVED***
        p = subprocess.Popen(cmd, stdout=subprocess.PIPE,
                             stderr=subprocess.STDOUT***REMOVED***
        out, err = p.communicate(***REMOVED***

    m = re.search(asbytes(r'COMPILERS:(\d+***REMOVED***,(\d+***REMOVED***,(\d+***REMOVED***'***REMOVED***, out***REMOVED***
    if m:
        _compiler_status = (bool(int(m.group(1***REMOVED******REMOVED******REMOVED***, bool(int(m.group(2***REMOVED******REMOVED******REMOVED***,
                            bool(int(m.group(3***REMOVED******REMOVED******REMOVED******REMOVED***
    # Finished
    return _compiler_status


def has_c_compiler(***REMOVED***:
    return _get_compiler_status(***REMOVED***[0***REMOVED***


def has_f77_compiler(***REMOVED***:
    return _get_compiler_status(***REMOVED***[1***REMOVED***


def has_f90_compiler(***REMOVED***:
    return _get_compiler_status(***REMOVED***[2***REMOVED***

#
# Building with distutils
#


@_memoize
def build_module_distutils(source_files, config_code, module_name, **kw***REMOVED***:
    ***REMOVED***
    Build a module via distutils and import it.

    ***REMOVED***
    from numpy.distutils.misc_util import Configuration
    from numpy.distutils.core import setup

    d = get_module_dir(***REMOVED***

    # Copy files
    dst_sources = [***REMOVED***
    for fn in source_files:
        if not os.path.isfile(fn***REMOVED***:
            raise RuntimeError("%s is not a file" % fn***REMOVED***
        dst = os.path.join(d, os.path.basename(fn***REMOVED******REMOVED***
        shutil.copyfile(fn, dst***REMOVED***
        dst_sources.append(dst***REMOVED***

    # Build script
    config_code = textwrap.dedent(config_code***REMOVED***.replace("\n", "\n    "***REMOVED***

    code = ***REMOVED***\
***REMOVED***
import sys
sys.path = %(syspath***REMOVED***s

def configuration(parent_name='',top_path=None***REMOVED***:
    from numpy.distutils.misc_util import Configuration
    config = Configuration('', parent_name, top_path***REMOVED***
    %(config_code***REMOVED***s
    return config

if __name__ == "__main__":
    from numpy.distutils.core import setup
    setup(configuration=configuration***REMOVED***
***REMOVED*** % dict(config_code=config_code, syspath=repr(sys.path***REMOVED******REMOVED***

    script = os.path.join(d, get_temp_module_name(***REMOVED*** + '.py'***REMOVED***
    dst_sources.append(script***REMOVED***
    f = open(script, 'wb'***REMOVED***
    f.write(asbytes(code***REMOVED******REMOVED***
    f.close(***REMOVED***

    # Build
    cwd = os.getcwd(***REMOVED***
    ***REMOVED***
        os.chdir(d***REMOVED***
        cmd = [sys.executable, script, 'build_ext', '-i'***REMOVED***
        p = subprocess.Popen(cmd, stdout=subprocess.PIPE,
                             stderr=subprocess.STDOUT***REMOVED***
        out, err = p.communicate(***REMOVED***
        if p.returncode != 0:
            raise RuntimeError("Running distutils build failed: %s\n%s"
                               % (cmd[4:***REMOVED***, asstr(out***REMOVED******REMOVED******REMOVED***
    finally:
        os.chdir(cwd***REMOVED***

        # Partial cleanup
        for fn in dst_sources:
            os.unlink(fn***REMOVED***

    # Import
    __import__(module_name***REMOVED***
    return sys.modules[module_name***REMOVED***

#
# Unittest convenience
#


class F2PyTest(object***REMOVED***:
    code = None
    sources = None
    options = [***REMOVED***
    skip = [***REMOVED***
    only = [***REMOVED***
    suffix = '.f'
    module = None
    module_name = None

    def setUp(self***REMOVED***:
        if self.module is not None:
            return

        # Check compiler availability first
        if not has_c_compiler(***REMOVED***:
            raise SkipTest("No C compiler available"***REMOVED***

        codes = [***REMOVED***
        if self.sources:
            codes.extend(self.sources***REMOVED***
        if self.code is not None:
            codes.append(self.suffix***REMOVED***

        needs_f77 = False
        needs_f90 = False
        for fn in codes:
            if fn.endswith('.f'***REMOVED***:
                needs_f77 = True
            elif fn.endswith('.f90'***REMOVED***:
                needs_f90 = True
        if needs_f77 and not has_f77_compiler(***REMOVED***:
            raise SkipTest("No Fortran 77 compiler available"***REMOVED***
        if needs_f90 and not has_f90_compiler(***REMOVED***:
            raise SkipTest("No Fortran 90 compiler available"***REMOVED***

        # Build the module
        if self.code is not None:
            self.module = build_code(self.code, options=self.options,
                                     skip=self.skip, only=self.only,
                                     suffix=self.suffix,
                                     module_name=self.module_name***REMOVED***

        if self.sources is not None:
            self.module = build_module(self.sources, options=self.options,
                                       skip=self.skip, only=self.only,
                                       module_name=self.module_name***REMOVED***
