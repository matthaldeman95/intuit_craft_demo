#!/usr/bin/env python
***REMOVED***

Copyright 1999,2000 Pearu Peterson all rights reserved,
Pearu Peterson <pearu@ioc.ee>
Permission to use, modify, and distribute this software is given under the
terms of the NumPy License.

NO WARRANTY IS EXPRESSED OR IMPLIED.  USE AT YOUR OWN RISK.
$Date: 2005/05/06 10:57:33 $
Pearu Peterson

***REMOVED***
from __future__ import division, absolute_import, print_function

__version__ = "$Revision: 1.60 $"[10:-1***REMOVED***

from . import __version__
f2py_version = __version__.version

import copy
import re
***REMOVED***
import sys
from .crackfortran import markoutercomma
from . import cb_rules

# The eviroment provided by auxfuncs.py is needed for some calls to eval.
# As the needed functions cannot be determined by static inspection of the
# code, it is safest to use import * pending a major refactoring of f2py.
from .auxfuncs import *

__all__ = [
    'getctype', 'getstrlength', 'getarrdims', 'getpydocsign',
    'getarrdocsign', 'getinit', 'sign2map', 'routsign2map', 'modsign2map',
    'cb_sign2map', 'cb_routsign2map', 'common_sign2map'
***REMOVED***


# Numarray and Numeric users should set this False
using_newcore = True

depargs = [***REMOVED***
lcb_map = {***REMOVED***
lcb2_map = {***REMOVED***
# forced casting: mainly caused by the fact that Python or Numeric
#                 C/APIs do not support the corresponding C types.
c2py_map = {'double': 'float',
            'float': 'float',                          # forced casting
            'long_double': 'float',                    # forced casting
            'char': 'int',                             # forced casting
            'signed_char': 'int',                      # forced casting
            'unsigned_char': 'int',                    # forced casting
            'short': 'int',                            # forced casting
            'unsigned_short': 'int',                   # forced casting
            'int': 'int',                              # (forced casting***REMOVED***
            'long': 'int',
            'long_long': 'long',
            'unsigned': 'int',                         # forced casting
            'complex_float': 'complex',                # forced casting
            'complex_double': 'complex',
            'complex_long_double': 'complex',          # forced casting
            'string': 'string',
        ***REMOVED***
c2capi_map = {'double': 'NPY_DOUBLE',
              'float': 'NPY_FLOAT',
              'long_double': 'NPY_DOUBLE',           # forced casting
              'char': 'NPY_CHAR',
              'unsigned_char': 'NPY_UBYTE',
              'signed_char': 'NPY_BYTE',
              'short': 'NPY_SHORT',
              'unsigned_short': 'NPY_USHORT',
              'int': 'NPY_INT',
              'unsigned': 'NPY_UINT',
              'long': 'NPY_LONG',
              'long_long': 'NPY_LONG',                # forced casting
              'complex_float': 'NPY_CFLOAT',
              'complex_double': 'NPY_CDOUBLE',
              'complex_long_double': 'NPY_CDOUBLE',   # forced casting
              'string': 'NPY_CHAR'***REMOVED***

# These new maps aren't used anyhere yet, but should be by default
#  unless building numeric or numarray extensions.
if using_newcore:
    c2capi_map = {'double': 'NPY_DOUBLE',
                  'float': 'NPY_FLOAT',
                  'long_double': 'NPY_LONGDOUBLE',
                  'char': 'NPY_BYTE',
                  'unsigned_char': 'NPY_UBYTE',
                  'signed_char': 'NPY_BYTE',
                  'short': 'NPY_SHORT',
                  'unsigned_short': 'NPY_USHORT',
                  'int': 'NPY_INT',
                  'unsigned': 'NPY_UINT',
                  'long': 'NPY_LONG',
                  'unsigned_long': 'NPY_ULONG',
                  'long_long': 'NPY_LONGLONG',
                  'unsigned_long_long': 'NPY_ULONGLONG',
                  'complex_float': 'NPY_CFLOAT',
                  'complex_double': 'NPY_CDOUBLE',
                  'complex_long_double': 'NPY_CDOUBLE',
                  # f2py 2e is not ready for NPY_STRING (must set itemisize
                  # etc***REMOVED***
                  'string': 'NPY_CHAR',
                  #'string':'NPY_STRING'

              ***REMOVED***
c2pycode_map = {'double': 'd',
                'float': 'f',
                'long_double': 'd',                       # forced casting
                'char': '1',
                'signed_char': '1',
                'unsigned_char': 'b',
                'short': 's',
                'unsigned_short': 'w',
                'int': 'i',
                'unsigned': 'u',
                'long': 'l',
                'long_long': 'L',
                'complex_float': 'F',
                'complex_double': 'D',
                'complex_long_double': 'D',               # forced casting
                'string': 'c'
            ***REMOVED***
if using_newcore:
    c2pycode_map = {'double': 'd',
                    'float': 'f',
                    'long_double': 'g',
                    'char': 'b',
                    'unsigned_char': 'B',
                    'signed_char': 'b',
                    'short': 'h',
                    'unsigned_short': 'H',
                    'int': 'i',
                    'unsigned': 'I',
                    'long': 'l',
                    'unsigned_long': 'L',
                    'long_long': 'q',
                    'unsigned_long_long': 'Q',
                    'complex_float': 'F',
                    'complex_double': 'D',
                    'complex_long_double': 'G',
                    'string': 'S'***REMOVED***
c2buildvalue_map = {'double': 'd',
                    'float': 'f',
                    'char': 'b',
                    'signed_char': 'b',
                    'short': 'h',
                    'int': 'i',
                    'long': 'l',
                    'long_long': 'L',
                    'complex_float': 'N',
                    'complex_double': 'N',
                    'complex_long_double': 'N',
                    'string': 'z'***REMOVED***

if sys.version_info[0***REMOVED*** >= 3:
    # Bytes, not Unicode strings
    c2buildvalue_map['string'***REMOVED*** = 'y'

if using_newcore:
    # c2buildvalue_map=???
    pass

f2cmap_all = {'real': {'': 'float', '4': 'float', '8': 'double',
                       '12': 'long_double', '16': 'long_double'***REMOVED***,
              'integer': {'': 'int', '1': 'signed_char', '2': 'short',
                          '4': 'int', '8': 'long_long',
                          '-1': 'unsigned_char', '-2': 'unsigned_short',
                          '-4': 'unsigned', '-8': 'unsigned_long_long'***REMOVED***,
              'complex': {'': 'complex_float', '8': 'complex_float',
                          '16': 'complex_double', '24': 'complex_long_double',
                          '32': 'complex_long_double'***REMOVED***,
              'complexkind': {'': 'complex_float', '4': 'complex_float',
                              '8': 'complex_double', '12': 'complex_long_double',
                              '16': 'complex_long_double'***REMOVED***,
              'logical': {'': 'int', '1': 'char', '2': 'short', '4': 'int',
                          '8': 'long_long'***REMOVED***,
              'double complex': {'': 'complex_double'***REMOVED***,
              'double precision': {'': 'double'***REMOVED***,
              'byte': {'': 'char'***REMOVED***,
              'character': {'': 'string'***REMOVED***
          ***REMOVED***

if os.path.isfile('.f2py_f2cmap'***REMOVED***:
    # User defined additions to f2cmap_all.
    # .f2py_f2cmap must contain a dictionary of dictionaries, only.  For
    # example, {'real':{'low':'float'***REMOVED******REMOVED*** means that Fortran 'real(low***REMOVED***' is
    # interpreted as C 'float'.  This feature is useful for F90/95 users if
    # they use PARAMETERSs in type specifications.
    ***REMOVED***
        outmess('Reading .f2py_f2cmap ...\n'***REMOVED***
        f = open('.f2py_f2cmap', 'r'***REMOVED***
        d = eval(f.read(***REMOVED***, {***REMOVED***, {***REMOVED******REMOVED***
        f.close(***REMOVED***
        for k, d1 in list(d.items(***REMOVED******REMOVED***:
            for k1 in list(d1.keys(***REMOVED******REMOVED***:
                d1[k1.lower(***REMOVED******REMOVED*** = d1[k1***REMOVED***
            d[k.lower(***REMOVED******REMOVED*** = d[k***REMOVED***
        for k in list(d.keys(***REMOVED******REMOVED***:
            if k not in f2cmap_all:
                f2cmap_all[k***REMOVED*** = {***REMOVED***
            for k1 in list(d[k***REMOVED***.keys(***REMOVED******REMOVED***:
                if d[k***REMOVED***[k1***REMOVED*** in c2py_map:
                    if k1 in f2cmap_all[k***REMOVED***:
                        outmess(
                            "\tWarning: redefinition of {'%s':{'%s':'%s'->'%s'***REMOVED******REMOVED***\n" % (k, k1, f2cmap_all[k***REMOVED***[k1***REMOVED***, d[k***REMOVED***[k1***REMOVED******REMOVED******REMOVED***
                    f2cmap_all[k***REMOVED***[k1***REMOVED*** = d[k***REMOVED***[k1***REMOVED***
                    outmess('\tMapping "%s(kind=%s***REMOVED***" to "%s"\n' %
                            (k, k1, d[k***REMOVED***[k1***REMOVED******REMOVED******REMOVED***
                else:
                    errmess("\tIgnoring map {'%s':{'%s':'%s'***REMOVED******REMOVED***: '%s' must be in %s\n" % (
                        k, k1, d[k***REMOVED***[k1***REMOVED***, d[k***REMOVED***[k1***REMOVED***, list(c2py_map.keys(***REMOVED******REMOVED******REMOVED******REMOVED***
        outmess('Succesfully applied user defined changes from .f2py_f2cmap\n'***REMOVED***
    except Exception as msg:
        errmess(
            'Failed to apply user defined changes from .f2py_f2cmap: %s. Skipping.\n' % (msg***REMOVED******REMOVED***

cformat_map = {'double': '%g',
               'float': '%g',
               'long_double': '%Lg',
               'char': '%d',
               'signed_char': '%d',
               'unsigned_char': '%hhu',
               'short': '%hd',
               'unsigned_short': '%hu',
               'int': '%d',
               'unsigned': '%u',
               'long': '%ld',
               'unsigned_long': '%lu',
               'long_long': '%ld',
               'complex_float': '(%g,%g***REMOVED***',
               'complex_double': '(%g,%g***REMOVED***',
               'complex_long_double': '(%Lg,%Lg***REMOVED***',
               'string': '%s',
           ***REMOVED***

# Auxiliary functions


def getctype(var***REMOVED***:
    ***REMOVED***
    Determines C type
    ***REMOVED***
    ctype = 'void'
    if isfunction(var***REMOVED***:
        if 'result' in var:
            a = var['result'***REMOVED***
        else:
            a = var['name'***REMOVED***
        if a in var['vars'***REMOVED***:
            return getctype(var['vars'***REMOVED***[a***REMOVED******REMOVED***
        else:
            errmess('getctype: function %s has no return value?!\n' % a***REMOVED***
    elif issubroutine(var***REMOVED***:
        return ctype
    elif 'typespec' in var and var['typespec'***REMOVED***.lower(***REMOVED*** in f2cmap_all:
        typespec = var['typespec'***REMOVED***.lower(***REMOVED***
        f2cmap = f2cmap_all[typespec***REMOVED***
        ctype = f2cmap[''***REMOVED***  # default type
        if 'kindselector' in var:
            if '*' in var['kindselector'***REMOVED***:
                ***REMOVED***
                    ctype = f2cmap[var['kindselector'***REMOVED***['*'***REMOVED******REMOVED***
                except KeyError:
                    errmess('getctype: "%s %s %s" not supported.\n' %
                            (var['typespec'***REMOVED***, '*', var['kindselector'***REMOVED***['*'***REMOVED******REMOVED******REMOVED***
            elif 'kind' in var['kindselector'***REMOVED***:
                if typespec + 'kind' in f2cmap_all:
                    f2cmap = f2cmap_all[typespec + 'kind'***REMOVED***
                ***REMOVED***
                    ctype = f2cmap[var['kindselector'***REMOVED***['kind'***REMOVED******REMOVED***
                except KeyError:
                    if typespec in f2cmap_all:
                        f2cmap = f2cmap_all[typespec***REMOVED***
                    ***REMOVED***
                        ctype = f2cmap[str(var['kindselector'***REMOVED***['kind'***REMOVED******REMOVED******REMOVED***
                    except KeyError:
                        errmess('getctype: "%s(kind=%s***REMOVED***" is mapped to C "%s" (to override define dict(%s = dict(%s="<C typespec>"***REMOVED******REMOVED*** in %s/.f2py_f2cmap file***REMOVED***.\n'
                                % (typespec, var['kindselector'***REMOVED***['kind'***REMOVED***, ctype,
                                   typespec, var['kindselector'***REMOVED***['kind'***REMOVED***, os.getcwd(***REMOVED******REMOVED******REMOVED***

    else:
        if not isexternal(var***REMOVED***:
            errmess(
                'getctype: No C-type found in "%s", assuming void.\n' % var***REMOVED***
    return ctype


def getstrlength(var***REMOVED***:
    if isstringfunction(var***REMOVED***:
        if 'result' in var:
            a = var['result'***REMOVED***
        else:
            a = var['name'***REMOVED***
        if a in var['vars'***REMOVED***:
            return getstrlength(var['vars'***REMOVED***[a***REMOVED******REMOVED***
        else:
            errmess('getstrlength: function %s has no return value?!\n' % a***REMOVED***
    if not isstring(var***REMOVED***:
        errmess(
            'getstrlength: expected a signature of a string but got: %s\n' % (repr(var***REMOVED******REMOVED******REMOVED***
    len = '1'
    if 'charselector' in var:
        a = var['charselector'***REMOVED***
        if '*' in a:
            len = a['*'***REMOVED***
        elif 'len' in a:
            len = a['len'***REMOVED***
    if re.match(r'\(\s*([****REMOVED***|[:***REMOVED******REMOVED***\s*\***REMOVED***', len***REMOVED*** or re.match(r'([****REMOVED***|[:***REMOVED******REMOVED***', len***REMOVED***:
        if isintent_hide(var***REMOVED***:
            errmess('getstrlength:intent(hide***REMOVED***: expected a string with defined length but got: %s\n' % (
                repr(var***REMOVED******REMOVED******REMOVED***
        len = '-1'
    return len


def getarrdims(a, var, verbose=0***REMOVED***:
    global depargs
    ret = {***REMOVED***
    if isstring(var***REMOVED*** and not isarray(var***REMOVED***:
        ret['dims'***REMOVED*** = getstrlength(var***REMOVED***
        ret['size'***REMOVED*** = ret['dims'***REMOVED***
        ret['rank'***REMOVED*** = '1'
    elif isscalar(var***REMOVED***:
        ret['size'***REMOVED*** = '1'
        ret['rank'***REMOVED*** = '0'
        ret['dims'***REMOVED*** = ''
    elif isarray(var***REMOVED***:
        dim = copy.copy(var['dimension'***REMOVED******REMOVED***
        ret['size'***REMOVED*** = '*'.join(dim***REMOVED***
        ***REMOVED***
            ret['size'***REMOVED*** = repr(eval(ret['size'***REMOVED******REMOVED******REMOVED***
        ***REMOVED***
            pass
        ret['dims'***REMOVED*** = ','.join(dim***REMOVED***
        ret['rank'***REMOVED*** = repr(len(dim***REMOVED******REMOVED***
        ret['rank*[-1***REMOVED***'***REMOVED*** = repr(len(dim***REMOVED*** * [-1***REMOVED******REMOVED***[1:-1***REMOVED***
        for i in range(len(dim***REMOVED******REMOVED***:  # solve dim for dependecies
            v = [***REMOVED***
            if dim[i***REMOVED*** in depargs:
                v = [dim[i***REMOVED******REMOVED***
            else:
                for va in depargs:
                    if re.match(r'.*?\b%s\b.*' % va, dim[i***REMOVED******REMOVED***:
                        v.append(va***REMOVED***
            for va in v:
                if depargs.index(va***REMOVED*** > depargs.index(a***REMOVED***:
                    dim[i***REMOVED*** = '*'
                    break
        ret['setdims'***REMOVED***, i = '', -1
        for d in dim:
            i = i + 1
            if d not in ['*', ':', '(****REMOVED***', '(:***REMOVED***'***REMOVED***:
                ret['setdims'***REMOVED*** = '%s#varname#_Dims[%d***REMOVED***=%s,' % (
                    ret['setdims'***REMOVED***, i, d***REMOVED***
        if ret['setdims'***REMOVED***:
            ret['setdims'***REMOVED*** = ret['setdims'***REMOVED***[:-1***REMOVED***
        ret['cbsetdims'***REMOVED***, i = '', -1
        for d in var['dimension'***REMOVED***:
            i = i + 1
            if d not in ['*', ':', '(****REMOVED***', '(:***REMOVED***'***REMOVED***:
                ret['cbsetdims'***REMOVED*** = '%s#varname#_Dims[%d***REMOVED***=%s,' % (
                    ret['cbsetdims'***REMOVED***, i, d***REMOVED***
            elif isintent_in(var***REMOVED***:
                outmess('getarrdims:warning: assumed shape array, using 0 instead of %r\n'
                        % (d***REMOVED******REMOVED***
                ret['cbsetdims'***REMOVED*** = '%s#varname#_Dims[%d***REMOVED***=%s,' % (
                    ret['cbsetdims'***REMOVED***, i, 0***REMOVED***
            elif verbose:
                errmess(
                    'getarrdims: If in call-back function: array argument %s must have bounded dimensions: got %s\n' % (repr(a***REMOVED***, repr(d***REMOVED******REMOVED******REMOVED***
        if ret['cbsetdims'***REMOVED***:
            ret['cbsetdims'***REMOVED*** = ret['cbsetdims'***REMOVED***[:-1***REMOVED***
#         if not isintent_c(var***REMOVED***:
#             var['dimension'***REMOVED***.reverse(***REMOVED***
    return ret


def getpydocsign(a, var***REMOVED***:
    global lcb_map
    if isfunction(var***REMOVED***:
        if 'result' in var:
            af = var['result'***REMOVED***
        else:
            af = var['name'***REMOVED***
        if af in var['vars'***REMOVED***:
            return getpydocsign(af, var['vars'***REMOVED***[af***REMOVED******REMOVED***
        else:
            errmess('getctype: function %s has no return value?!\n' % af***REMOVED***
        return '', ''
    sig, sigout = a, a
    opt = ''
    if isintent_in(var***REMOVED***:
        opt = 'input'
    elif isintent_inout(var***REMOVED***:
        opt = 'in/output'
    out_a = a
    if isintent_out(var***REMOVED***:
        for k in var['intent'***REMOVED***:
            if k[:4***REMOVED*** == 'out=':
                out_a = k[4:***REMOVED***
                break
    init = ''
    ctype = getctype(var***REMOVED***

    if hasinitvalue(var***REMOVED***:
        init, showinit = getinit(a, var***REMOVED***
        init = ', optional\\n    Default: %s' % showinit
    if isscalar(var***REMOVED***:
        if isintent_inout(var***REMOVED***:
            sig = '%s : %s rank-0 array(%s,\'%s\'***REMOVED***%s' % (a, opt, c2py_map[ctype***REMOVED***,
                                                         c2pycode_map[ctype***REMOVED***, init***REMOVED***
        else:
            sig = '%s : %s %s%s' % (a, opt, c2py_map[ctype***REMOVED***, init***REMOVED***
        sigout = '%s : %s' % (out_a, c2py_map[ctype***REMOVED******REMOVED***
    elif isstring(var***REMOVED***:
        if isintent_inout(var***REMOVED***:
            sig = '%s : %s rank-0 array(string(len=%s***REMOVED***,\'c\'***REMOVED***%s' % (
                a, opt, getstrlength(var***REMOVED***, init***REMOVED***
        else:
            sig = '%s : %s string(len=%s***REMOVED***%s' % (
                a, opt, getstrlength(var***REMOVED***, init***REMOVED***
        sigout = '%s : string(len=%s***REMOVED***' % (out_a, getstrlength(var***REMOVED******REMOVED***
    elif isarray(var***REMOVED***:
        dim = var['dimension'***REMOVED***
        rank = repr(len(dim***REMOVED******REMOVED***
        sig = '%s : %s rank-%s array(\'%s\'***REMOVED*** with bounds (%s***REMOVED***%s' % (a, opt, rank,
                                                                    c2pycode_map[
                                                                        ctype***REMOVED***,
                                                                    ','.join(dim***REMOVED***, init***REMOVED***
        if a == out_a:
            sigout = '%s : rank-%s array(\'%s\'***REMOVED*** with bounds (%s***REMOVED***'\
                % (a, rank, c2pycode_map[ctype***REMOVED***, ','.join(dim***REMOVED******REMOVED***
        else:
            sigout = '%s : rank-%s array(\'%s\'***REMOVED*** with bounds (%s***REMOVED*** and %s storage'\
                % (out_a, rank, c2pycode_map[ctype***REMOVED***, ','.join(dim***REMOVED***, a***REMOVED***
    elif isexternal(var***REMOVED***:
        ua = ''
        if a in lcb_map and lcb_map[a***REMOVED*** in lcb2_map and 'argname' in lcb2_map[lcb_map[a***REMOVED******REMOVED***:
            ua = lcb2_map[lcb_map[a***REMOVED******REMOVED***['argname'***REMOVED***
            if not ua == a:
                ua = ' => %s' % ua
            else:
                ua = ''
        sig = '%s : call-back function%s' % (a, ua***REMOVED***
        sigout = sig
    else:
        errmess(
            'getpydocsign: Could not resolve docsignature for "%s".\\n' % a***REMOVED***
    return sig, sigout


def getarrdocsign(a, var***REMOVED***:
    ctype = getctype(var***REMOVED***
    if isstring(var***REMOVED*** and (not isarray(var***REMOVED******REMOVED***:
        sig = '%s : rank-0 array(string(len=%s***REMOVED***,\'c\'***REMOVED***' % (a,
                                                           getstrlength(var***REMOVED******REMOVED***
    elif isscalar(var***REMOVED***:
        sig = '%s : rank-0 array(%s,\'%s\'***REMOVED***' % (a, c2py_map[ctype***REMOVED***,
                                                c2pycode_map[ctype***REMOVED***,***REMOVED***
    elif isarray(var***REMOVED***:
        dim = var['dimension'***REMOVED***
        rank = repr(len(dim***REMOVED******REMOVED***
        sig = '%s : rank-%s array(\'%s\'***REMOVED*** with bounds (%s***REMOVED***' % (a, rank,
                                                               c2pycode_map[
                                                                   ctype***REMOVED***,
                                                               ','.join(dim***REMOVED******REMOVED***
    return sig


def getinit(a, var***REMOVED***:
    if isstring(var***REMOVED***:
        init, showinit = '""', "''"
    else:
        init, showinit = '', ''
    if hasinitvalue(var***REMOVED***:
        init = var['='***REMOVED***
        showinit = init
        if iscomplex(var***REMOVED*** or iscomplexarray(var***REMOVED***:
            ret = {***REMOVED***

            ***REMOVED***
                v = var["="***REMOVED***
                if ',' in v:
                    ret['init.r'***REMOVED***, ret['init.i'***REMOVED*** = markoutercomma(
                        v[1:-1***REMOVED******REMOVED***.split('@,@'***REMOVED***
                else:
                    v = eval(v, {***REMOVED***, {***REMOVED******REMOVED***
                    ret['init.r'***REMOVED***, ret['init.i'***REMOVED*** = str(v.real***REMOVED***, str(v.imag***REMOVED***
            ***REMOVED***
                raise ValueError(
                    'getinit: expected complex number `(r,i***REMOVED***\' but got `%s\' as initial value of %r.' % (init, a***REMOVED******REMOVED***
            if isarray(var***REMOVED***:
                init = '(capi_c.r=%s,capi_c.i=%s,capi_c***REMOVED***' % (
                    ret['init.r'***REMOVED***, ret['init.i'***REMOVED******REMOVED***
        elif isstring(var***REMOVED***:
            if not init:
                init, showinit = '""', "''"
            if init[0***REMOVED*** == "'":
                init = '"%s"' % (init[1:-1***REMOVED***.replace('"', '\\"'***REMOVED******REMOVED***
            if init[0***REMOVED*** == '"':
                showinit = "'%s'" % (init[1:-1***REMOVED******REMOVED***
    return init, showinit


def sign2map(a, var***REMOVED***:
    ***REMOVED***
    varname,ctype,atype
    init,init.r,init.i,pytype
    vardebuginfo,vardebugshowvalue,varshowvalue
    varrfromat
    intent
    ***REMOVED***
    global lcb_map, cb_map
    out_a = a
    if isintent_out(var***REMOVED***:
        for k in var['intent'***REMOVED***:
            if k[:4***REMOVED*** == 'out=':
                out_a = k[4:***REMOVED***
                break
    ret = {'varname': a, 'outvarname': out_a, 'ctype': getctype(var***REMOVED******REMOVED***
    intent_flags = [***REMOVED***
    for f, s in isintent_dict.items(***REMOVED***:
        if f(var***REMOVED***:
            intent_flags.append('F2PY_%s' % s***REMOVED***
    if intent_flags:
        # XXX: Evaluate intent_flags here.
        ret['intent'***REMOVED*** = '|'.join(intent_flags***REMOVED***
    else:
        ret['intent'***REMOVED*** = 'F2PY_INTENT_IN'
    if isarray(var***REMOVED***:
        ret['varrformat'***REMOVED*** = 'N'
    elif ret['ctype'***REMOVED*** in c2buildvalue_map:
        ret['varrformat'***REMOVED*** = c2buildvalue_map[ret['ctype'***REMOVED******REMOVED***
    else:
        ret['varrformat'***REMOVED*** = 'O'
    ret['init'***REMOVED***, ret['showinit'***REMOVED*** = getinit(a, var***REMOVED***
    if hasinitvalue(var***REMOVED*** and iscomplex(var***REMOVED*** and not isarray(var***REMOVED***:
        ret['init.r'***REMOVED***, ret['init.i'***REMOVED*** = markoutercomma(
            ret['init'***REMOVED***[1:-1***REMOVED******REMOVED***.split('@,@'***REMOVED***
    if isexternal(var***REMOVED***:
        ret['cbnamekey'***REMOVED*** = a
        if a in lcb_map:
            ret['cbname'***REMOVED*** = lcb_map[a***REMOVED***
            ret['maxnofargs'***REMOVED*** = lcb2_map[lcb_map[a***REMOVED******REMOVED***['maxnofargs'***REMOVED***
            ret['nofoptargs'***REMOVED*** = lcb2_map[lcb_map[a***REMOVED******REMOVED***['nofoptargs'***REMOVED***
            ret['cbdocstr'***REMOVED*** = lcb2_map[lcb_map[a***REMOVED******REMOVED***['docstr'***REMOVED***
            ret['cblatexdocstr'***REMOVED*** = lcb2_map[lcb_map[a***REMOVED******REMOVED***['latexdocstr'***REMOVED***
        else:
            ret['cbname'***REMOVED*** = a
            errmess('sign2map: Confused: external %s is not in lcb_map%s.\n' % (
                a, list(lcb_map.keys(***REMOVED******REMOVED******REMOVED******REMOVED***
    if isstring(var***REMOVED***:
        ret['length'***REMOVED*** = getstrlength(var***REMOVED***
    if isarray(var***REMOVED***:
        ret = dictappend(ret, getarrdims(a, var***REMOVED******REMOVED***
        dim = copy.copy(var['dimension'***REMOVED******REMOVED***
    if ret['ctype'***REMOVED*** in c2capi_map:
        ret['atype'***REMOVED*** = c2capi_map[ret['ctype'***REMOVED******REMOVED***
    # Debug info
    if debugcapi(var***REMOVED***:
        il = [isintent_in, 'input', isintent_out, 'output',
              isintent_inout, 'inoutput', isrequired, 'required',
              isoptional, 'optional', isintent_hide, 'hidden',
              iscomplex, 'complex scalar',
              l_and(isscalar, l_not(iscomplex***REMOVED******REMOVED***, 'scalar',
              isstring, 'string', isarray, 'array',
              iscomplexarray, 'complex array', isstringarray, 'string array',
              iscomplexfunction, 'complex function',
              l_and(isfunction, l_not(iscomplexfunction***REMOVED******REMOVED***, 'function',
              isexternal, 'callback',
              isintent_callback, 'callback',
              isintent_aux, 'auxiliary',
              ***REMOVED***
        rl = [***REMOVED***
        for i in range(0, len(il***REMOVED***, 2***REMOVED***:
            if il[i***REMOVED***(var***REMOVED***:
                rl.append(il[i + 1***REMOVED******REMOVED***
        if isstring(var***REMOVED***:
            rl.append('slen(%s***REMOVED***=%s' % (a, ret['length'***REMOVED******REMOVED******REMOVED***
        if isarray(var***REMOVED***:
            ddim = ','.join(
                map(lambda x, y: '%s|%s' % (x, y***REMOVED***, var['dimension'***REMOVED***, dim***REMOVED******REMOVED***
            rl.append('dims(%s***REMOVED***' % ddim***REMOVED***
        if isexternal(var***REMOVED***:
            ret['vardebuginfo'***REMOVED*** = 'debug-capi:%s=>%s:%s' % (
                a, ret['cbname'***REMOVED***, ','.join(rl***REMOVED******REMOVED***
        else:
            ret['vardebuginfo'***REMOVED*** = 'debug-capi:%s %s=%s:%s' % (
                ret['ctype'***REMOVED***, a, ret['showinit'***REMOVED***, ','.join(rl***REMOVED******REMOVED***
        if isscalar(var***REMOVED***:
            if ret['ctype'***REMOVED*** in cformat_map:
                ret['vardebugshowvalue'***REMOVED*** = 'debug-capi:%s=%s' % (
                    a, cformat_map[ret['ctype'***REMOVED******REMOVED******REMOVED***
        if isstring(var***REMOVED***:
            ret['vardebugshowvalue'***REMOVED*** = 'debug-capi:slen(%s***REMOVED***=%%d %s=\\"%%s\\"' % (
                a, a***REMOVED***
        if isexternal(var***REMOVED***:
            ret['vardebugshowvalue'***REMOVED*** = 'debug-capi:%s=%%p' % (a***REMOVED***
    if ret['ctype'***REMOVED*** in cformat_map:
        ret['varshowvalue'***REMOVED*** = '#name#:%s=%s' % (a, cformat_map[ret['ctype'***REMOVED******REMOVED******REMOVED***
        ret['showvalueformat'***REMOVED*** = '%s' % (cformat_map[ret['ctype'***REMOVED******REMOVED******REMOVED***
    if isstring(var***REMOVED***:
        ret['varshowvalue'***REMOVED*** = '#name#:slen(%s***REMOVED***=%%d %s=\\"%%s\\"' % (a, a***REMOVED***
    ret['pydocsign'***REMOVED***, ret['pydocsignout'***REMOVED*** = getpydocsign(a, var***REMOVED***
    if hasnote(var***REMOVED***:
        ret['note'***REMOVED*** = var['note'***REMOVED***
    return ret


def routsign2map(rout***REMOVED***:
    ***REMOVED***
    name,NAME,begintitle,endtitle
    rname,ctype,rformat
    routdebugshowvalue
    ***REMOVED***
    global lcb_map
    name = rout['name'***REMOVED***
    fname = getfortranname(rout***REMOVED***
    ret = {'name': name,
           'texname': name.replace('_', '\\_'***REMOVED***,
           'name_lower': name.lower(***REMOVED***,
           'NAME': name.upper(***REMOVED***,
           'begintitle': gentitle(name***REMOVED***,
           'endtitle': gentitle('end of %s' % name***REMOVED***,
           'fortranname': fname,
           'FORTRANNAME': fname.upper(***REMOVED***,
           'callstatement': getcallstatement(rout***REMOVED*** or '',
           'usercode': getusercode(rout***REMOVED*** or '',
           'usercode1': getusercode1(rout***REMOVED*** or '',
       ***REMOVED***
    if '_' in fname:
        ret['F_FUNC'***REMOVED*** = 'F_FUNC_US'
    else:
        ret['F_FUNC'***REMOVED*** = 'F_FUNC'
    if '_' in name:
        ret['F_WRAPPEDFUNC'***REMOVED*** = 'F_WRAPPEDFUNC_US'
    else:
        ret['F_WRAPPEDFUNC'***REMOVED*** = 'F_WRAPPEDFUNC'
    lcb_map = {***REMOVED***
    if 'use' in rout:
        for u in rout['use'***REMOVED***.keys(***REMOVED***:
            if u in cb_rules.cb_map:
                for un in cb_rules.cb_map[u***REMOVED***:
                    ln = un[0***REMOVED***
                    if 'map' in rout['use'***REMOVED***[u***REMOVED***:
                        for k in rout['use'***REMOVED***[u***REMOVED***['map'***REMOVED***.keys(***REMOVED***:
                            if rout['use'***REMOVED***[u***REMOVED***['map'***REMOVED***[k***REMOVED*** == un[0***REMOVED***:
                                ln = k
                                break
                    lcb_map[ln***REMOVED*** = un[1***REMOVED***
    elif 'externals' in rout and rout['externals'***REMOVED***:
        errmess('routsign2map: Confused: function %s has externals %s but no "use" statement.\n' % (
            ret['name'***REMOVED***, repr(rout['externals'***REMOVED******REMOVED******REMOVED******REMOVED***
    ret['callprotoargument'***REMOVED*** = getcallprotoargument(rout, lcb_map***REMOVED*** or ''
    if isfunction(rout***REMOVED***:
        if 'result' in rout:
            a = rout['result'***REMOVED***
        else:
            a = rout['name'***REMOVED***
        ret['rname'***REMOVED*** = a
        ret['pydocsign'***REMOVED***, ret['pydocsignout'***REMOVED*** = getpydocsign(a, rout***REMOVED***
        ret['ctype'***REMOVED*** = getctype(rout['vars'***REMOVED***[a***REMOVED******REMOVED***
        if hasresultnote(rout***REMOVED***:
            ret['resultnote'***REMOVED*** = rout['vars'***REMOVED***[a***REMOVED***['note'***REMOVED***
            rout['vars'***REMOVED***[a***REMOVED***['note'***REMOVED*** = ['See elsewhere.'***REMOVED***
        if ret['ctype'***REMOVED*** in c2buildvalue_map:
            ret['rformat'***REMOVED*** = c2buildvalue_map[ret['ctype'***REMOVED******REMOVED***
        else:
            ret['rformat'***REMOVED*** = 'O'
            errmess('routsign2map: no c2buildvalue key for type %s\n' %
                    (repr(ret['ctype'***REMOVED******REMOVED******REMOVED******REMOVED***
        if debugcapi(rout***REMOVED***:
            if ret['ctype'***REMOVED*** in cformat_map:
                ret['routdebugshowvalue'***REMOVED*** = 'debug-capi:%s=%s' % (
                    a, cformat_map[ret['ctype'***REMOVED******REMOVED******REMOVED***
            if isstringfunction(rout***REMOVED***:
                ret['routdebugshowvalue'***REMOVED*** = 'debug-capi:slen(%s***REMOVED***=%%d %s=\\"%%s\\"' % (
                    a, a***REMOVED***
        if isstringfunction(rout***REMOVED***:
            ret['rlength'***REMOVED*** = getstrlength(rout['vars'***REMOVED***[a***REMOVED******REMOVED***
            if ret['rlength'***REMOVED*** == '-1':
                errmess('routsign2map: expected explicit specification of the length of the string returned by the fortran function %s; taking 10.\n' % (
                    repr(rout['name'***REMOVED******REMOVED******REMOVED******REMOVED***
                ret['rlength'***REMOVED*** = '10'
    if hasnote(rout***REMOVED***:
        ret['note'***REMOVED*** = rout['note'***REMOVED***
        rout['note'***REMOVED*** = ['See elsewhere.'***REMOVED***
    return ret


def modsign2map(m***REMOVED***:
    ***REMOVED***
    modulename
    ***REMOVED***
    if ismodule(m***REMOVED***:
        ret = {'f90modulename': m['name'***REMOVED***,
               'F90MODULENAME': m['name'***REMOVED***.upper(***REMOVED***,
               'texf90modulename': m['name'***REMOVED***.replace('_', '\\_'***REMOVED******REMOVED***
    else:
        ret = {'modulename': m['name'***REMOVED***,
               'MODULENAME': m['name'***REMOVED***.upper(***REMOVED***,
               'texmodulename': m['name'***REMOVED***.replace('_', '\\_'***REMOVED******REMOVED***
    ret['restdoc'***REMOVED*** = getrestdoc(m***REMOVED*** or [***REMOVED***
    if hasnote(m***REMOVED***:
        ret['note'***REMOVED*** = m['note'***REMOVED***
    ret['usercode'***REMOVED*** = getusercode(m***REMOVED*** or ''
    ret['usercode1'***REMOVED*** = getusercode1(m***REMOVED*** or ''
    if m['body'***REMOVED***:
        ret['interface_usercode'***REMOVED*** = getusercode(m['body'***REMOVED***[0***REMOVED******REMOVED*** or ''
    else:
        ret['interface_usercode'***REMOVED*** = ''
    ret['pymethoddef'***REMOVED*** = getpymethoddef(m***REMOVED*** or ''
    if 'coutput' in m:
        ret['coutput'***REMOVED*** = m['coutput'***REMOVED***
    if 'f2py_wrapper_output' in m:
        ret['f2py_wrapper_output'***REMOVED*** = m['f2py_wrapper_output'***REMOVED***
    return ret


def cb_sign2map(a, var, index=None***REMOVED***:
    ret = {'varname': a***REMOVED***
    if index is None or 1:  # disable 7712 patch
        ret['varname_i'***REMOVED*** = ret['varname'***REMOVED***
    else:
        ret['varname_i'***REMOVED*** = ret['varname'***REMOVED*** + '_' + str(index***REMOVED***
    ret['ctype'***REMOVED*** = getctype(var***REMOVED***
    if ret['ctype'***REMOVED*** in c2capi_map:
        ret['atype'***REMOVED*** = c2capi_map[ret['ctype'***REMOVED******REMOVED***
    if ret['ctype'***REMOVED*** in cformat_map:
        ret['showvalueformat'***REMOVED*** = '%s' % (cformat_map[ret['ctype'***REMOVED******REMOVED******REMOVED***
    if isarray(var***REMOVED***:
        ret = dictappend(ret, getarrdims(a, var***REMOVED******REMOVED***
    ret['pydocsign'***REMOVED***, ret['pydocsignout'***REMOVED*** = getpydocsign(a, var***REMOVED***
    if hasnote(var***REMOVED***:
        ret['note'***REMOVED*** = var['note'***REMOVED***
        var['note'***REMOVED*** = ['See elsewhere.'***REMOVED***
    return ret


def cb_routsign2map(rout, um***REMOVED***:
    ***REMOVED***
    name,begintitle,endtitle,argname
    ctype,rctype,maxnofargs,nofoptargs,returncptr
    ***REMOVED***
    ret = {'name': 'cb_%s_in_%s' % (rout['name'***REMOVED***, um***REMOVED***,
           'returncptr': ''***REMOVED***
    if isintent_callback(rout***REMOVED***:
        if '_' in rout['name'***REMOVED***:
            F_FUNC = 'F_FUNC_US'
        else:
            F_FUNC = 'F_FUNC'
        ret['callbackname'***REMOVED*** = '%s(%s,%s***REMOVED***' \
                              % (F_FUNC,
                                 rout['name'***REMOVED***.lower(***REMOVED***,
                                 rout['name'***REMOVED***.upper(***REMOVED***,
                                 ***REMOVED***
        ret['static'***REMOVED*** = 'extern'
    else:
        ret['callbackname'***REMOVED*** = ret['name'***REMOVED***
        ret['static'***REMOVED*** = 'static'
    ret['argname'***REMOVED*** = rout['name'***REMOVED***
    ret['begintitle'***REMOVED*** = gentitle(ret['name'***REMOVED******REMOVED***
    ret['endtitle'***REMOVED*** = gentitle('end of %s' % ret['name'***REMOVED******REMOVED***
    ret['ctype'***REMOVED*** = getctype(rout***REMOVED***
    ret['rctype'***REMOVED*** = 'void'
    if ret['ctype'***REMOVED*** == 'string':
        ret['rctype'***REMOVED*** = 'void'
    else:
        ret['rctype'***REMOVED*** = ret['ctype'***REMOVED***
    if ret['rctype'***REMOVED*** != 'void':
        if iscomplexfunction(rout***REMOVED***:
            ret['returncptr'***REMOVED*** = ***REMOVED***
#ifdef F2PY_CB_RETURNCOMPLEX
return_value=
#endif
***REMOVED***
        else:
            ret['returncptr'***REMOVED*** = 'return_value='
    if ret['ctype'***REMOVED*** in cformat_map:
        ret['showvalueformat'***REMOVED*** = '%s' % (cformat_map[ret['ctype'***REMOVED******REMOVED******REMOVED***
    if isstringfunction(rout***REMOVED***:
        ret['strlength'***REMOVED*** = getstrlength(rout***REMOVED***
    if isfunction(rout***REMOVED***:
        if 'result' in rout:
            a = rout['result'***REMOVED***
        else:
            a = rout['name'***REMOVED***
        if hasnote(rout['vars'***REMOVED***[a***REMOVED******REMOVED***:
            ret['note'***REMOVED*** = rout['vars'***REMOVED***[a***REMOVED***['note'***REMOVED***
            rout['vars'***REMOVED***[a***REMOVED***['note'***REMOVED*** = ['See elsewhere.'***REMOVED***
        ret['rname'***REMOVED*** = a
        ret['pydocsign'***REMOVED***, ret['pydocsignout'***REMOVED*** = getpydocsign(a, rout***REMOVED***
        if iscomplexfunction(rout***REMOVED***:
            ret['rctype'***REMOVED*** = ***REMOVED***
#ifdef F2PY_CB_RETURNCOMPLEX
#ctype#
#else
void
#endif
***REMOVED***
    else:
        if hasnote(rout***REMOVED***:
            ret['note'***REMOVED*** = rout['note'***REMOVED***
            rout['note'***REMOVED*** = ['See elsewhere.'***REMOVED***
    nofargs = 0
    nofoptargs = 0
    if 'args' in rout and 'vars' in rout:
        for a in rout['args'***REMOVED***:
            var = rout['vars'***REMOVED***[a***REMOVED***
            if l_or(isintent_in, isintent_inout***REMOVED***(var***REMOVED***:
                nofargs = nofargs + 1
                if isoptional(var***REMOVED***:
                    nofoptargs = nofoptargs + 1
    ret['maxnofargs'***REMOVED*** = repr(nofargs***REMOVED***
    ret['nofoptargs'***REMOVED*** = repr(nofoptargs***REMOVED***
    if hasnote(rout***REMOVED*** and isfunction(rout***REMOVED*** and 'result' in rout:
        ret['routnote'***REMOVED*** = rout['note'***REMOVED***
        rout['note'***REMOVED*** = ['See elsewhere.'***REMOVED***
    return ret


def common_sign2map(a, var***REMOVED***:  # obsolute
    ret = {'varname': a, 'ctype': getctype(var***REMOVED******REMOVED***
    if isstringarray(var***REMOVED***:
        ret['ctype'***REMOVED*** = 'char'
    if ret['ctype'***REMOVED*** in c2capi_map:
        ret['atype'***REMOVED*** = c2capi_map[ret['ctype'***REMOVED******REMOVED***
    if ret['ctype'***REMOVED*** in cformat_map:
        ret['showvalueformat'***REMOVED*** = '%s' % (cformat_map[ret['ctype'***REMOVED******REMOVED******REMOVED***
    if isarray(var***REMOVED***:
        ret = dictappend(ret, getarrdims(a, var***REMOVED******REMOVED***
    elif isstring(var***REMOVED***:
        ret['size'***REMOVED*** = getstrlength(var***REMOVED***
        ret['rank'***REMOVED*** = '1'
    ret['pydocsign'***REMOVED***, ret['pydocsignout'***REMOVED*** = getpydocsign(a, var***REMOVED***
    if hasnote(var***REMOVED***:
        ret['note'***REMOVED*** = var['note'***REMOVED***
        var['note'***REMOVED*** = ['See elsewhere.'***REMOVED***
    # for strings this returns 0-rank but actually is 1-rank
    ret['arrdocstr'***REMOVED*** = getarrdocsign(a, var***REMOVED***
    return ret
