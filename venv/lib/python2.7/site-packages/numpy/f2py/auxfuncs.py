#!/usr/bin/env python
***REMOVED***

Auxiliary functions for f2py2e.

Copyright 1999,2000 Pearu Peterson all rights reserved,
Pearu Peterson <pearu@ioc.ee>
Permission to use, modify, and distribute this software is given under the
terms of the NumPy (BSD style***REMOVED*** LICENSE.


NO WARRANTY IS EXPRESSED OR IMPLIED.  USE AT YOUR OWN RISK.
$Date: 2005/07/24 19:01:55 $
Pearu Peterson

***REMOVED***
from __future__ import division, absolute_import, print_function

import pprint
import sys
import types
from functools import reduce

from . import __version__
from . import cfuncs

__all__ = [
    'applyrules', 'debugcapi', 'dictappend', 'errmess', 'gentitle',
    'getargs2', 'getcallprotoargument', 'getcallstatement',
    'getfortranname', 'getpymethoddef', 'getrestdoc', 'getusercode',
    'getusercode1', 'hasbody', 'hascallstatement', 'hascommon',
    'hasexternals', 'hasinitvalue', 'hasnote', 'hasresultnote',
    'isallocatable', 'isarray', 'isarrayofstrings', 'iscomplex',
    'iscomplexarray', 'iscomplexfunction', 'iscomplexfunction_warn',
    'isdouble', 'isdummyroutine', 'isexternal', 'isfunction',
    'isfunction_wrap', 'isint1array', 'isinteger', 'isintent_aux',
    'isintent_c', 'isintent_callback', 'isintent_copy', 'isintent_dict',
    'isintent_hide', 'isintent_in', 'isintent_inout', 'isintent_inplace',
    'isintent_nothide', 'isintent_out', 'isintent_overwrite', 'islogical',
    'islogicalfunction', 'islong_complex', 'islong_double',
    'islong_doublefunction', 'islong_long', 'islong_longfunction',
    'ismodule', 'ismoduleroutine', 'isoptional', 'isprivate', 'isrequired',
    'isroutine', 'isscalar', 'issigned_long_longarray', 'isstring',
    'isstringarray', 'isstringfunction', 'issubroutine',
    'issubroutine_wrap', 'isthreadsafe', 'isunsigned', 'isunsigned_char',
    'isunsigned_chararray', 'isunsigned_long_long',
    'isunsigned_long_longarray', 'isunsigned_short',
    'isunsigned_shortarray', 'l_and', 'l_not', 'l_or', 'outmess',
    'replace', 'show', 'stripcomma', 'throw_error',
***REMOVED***


f2py_version = __version__.version


errmess = sys.stderr.write
show = pprint.pprint

options = {***REMOVED***
debugoptions = [***REMOVED***
wrapfuncs = 1


def outmess(t***REMOVED***:
    if options.get('verbose', 1***REMOVED***:
        sys.stdout.write(t***REMOVED***


def debugcapi(var***REMOVED***:
    return 'capi' in debugoptions


def _isstring(var***REMOVED***:
    return 'typespec' in var and var['typespec'***REMOVED*** == 'character' and \
           not isexternal(var***REMOVED***


def isstring(var***REMOVED***:
    return _isstring(var***REMOVED*** and not isarray(var***REMOVED***


def ischaracter(var***REMOVED***:
    return isstring(var***REMOVED*** and 'charselector' not in var


def isstringarray(var***REMOVED***:
    return isarray(var***REMOVED*** and _isstring(var***REMOVED***


def isarrayofstrings(var***REMOVED***:
    # leaving out '*' for now so that `character*(****REMOVED*** a(m***REMOVED***` and `character
    # a(m,****REMOVED***` are treated differently. Luckily `character**` is illegal.
    return isstringarray(var***REMOVED*** and var['dimension'***REMOVED***[-1***REMOVED*** == '(****REMOVED***'


def isarray(var***REMOVED***:
    return 'dimension' in var and not isexternal(var***REMOVED***


def isscalar(var***REMOVED***:
    return not (isarray(var***REMOVED*** or isstring(var***REMOVED*** or isexternal(var***REMOVED******REMOVED***


def iscomplex(var***REMOVED***:
    return isscalar(var***REMOVED*** and \
           var.get('typespec'***REMOVED*** in ['complex', 'double complex'***REMOVED***


def islogical(var***REMOVED***:
    return isscalar(var***REMOVED*** and var.get('typespec'***REMOVED*** == 'logical'


def isinteger(var***REMOVED***:
    return isscalar(var***REMOVED*** and var.get('typespec'***REMOVED*** == 'integer'


def isreal(var***REMOVED***:
    return isscalar(var***REMOVED*** and var.get('typespec'***REMOVED*** == 'real'


def get_kind(var***REMOVED***:
    ***REMOVED***
        return var['kindselector'***REMOVED***['*'***REMOVED***
    except KeyError:
        ***REMOVED***
            return var['kindselector'***REMOVED***['kind'***REMOVED***
        except KeyError:
            pass


def islong_long(var***REMOVED***:
    if not isscalar(var***REMOVED***:
        return 0
    if var.get('typespec'***REMOVED*** not in ['integer', 'logical'***REMOVED***:
        return 0
    return get_kind(var***REMOVED*** == '8'


def isunsigned_char(var***REMOVED***:
    if not isscalar(var***REMOVED***:
        return 0
    if var.get('typespec'***REMOVED*** != 'integer':
        return 0
    return get_kind(var***REMOVED*** == '-1'


def isunsigned_short(var***REMOVED***:
    if not isscalar(var***REMOVED***:
        return 0
    if var.get('typespec'***REMOVED*** != 'integer':
        return 0
    return get_kind(var***REMOVED*** == '-2'


def isunsigned(var***REMOVED***:
    if not isscalar(var***REMOVED***:
        return 0
    if var.get('typespec'***REMOVED*** != 'integer':
        return 0
    return get_kind(var***REMOVED*** == '-4'


def isunsigned_long_long(var***REMOVED***:
    if not isscalar(var***REMOVED***:
        return 0
    if var.get('typespec'***REMOVED*** != 'integer':
        return 0
    return get_kind(var***REMOVED*** == '-8'


def isdouble(var***REMOVED***:
    if not isscalar(var***REMOVED***:
        return 0
    if not var.get('typespec'***REMOVED*** == 'real':
        return 0
    return get_kind(var***REMOVED*** == '8'


def islong_double(var***REMOVED***:
    if not isscalar(var***REMOVED***:
        return 0
    if not var.get('typespec'***REMOVED*** == 'real':
        return 0
    return get_kind(var***REMOVED*** == '16'


def islong_complex(var***REMOVED***:
    if not iscomplex(var***REMOVED***:
        return 0
    return get_kind(var***REMOVED*** == '32'


def iscomplexarray(var***REMOVED***:
    return isarray(var***REMOVED*** and \
           var.get('typespec'***REMOVED*** in ['complex', 'double complex'***REMOVED***


def isint1array(var***REMOVED***:
    return isarray(var***REMOVED*** and var.get('typespec'***REMOVED*** == 'integer' \
        and get_kind(var***REMOVED*** == '1'


def isunsigned_chararray(var***REMOVED***:
    return isarray(var***REMOVED*** and var.get('typespec'***REMOVED*** in ['integer', 'logical'***REMOVED***\
        and get_kind(var***REMOVED*** == '-1'


def isunsigned_shortarray(var***REMOVED***:
    return isarray(var***REMOVED*** and var.get('typespec'***REMOVED*** in ['integer', 'logical'***REMOVED***\
        and get_kind(var***REMOVED*** == '-2'


def isunsignedarray(var***REMOVED***:
    return isarray(var***REMOVED*** and var.get('typespec'***REMOVED*** in ['integer', 'logical'***REMOVED***\
        and get_kind(var***REMOVED*** == '-4'


def isunsigned_long_longarray(var***REMOVED***:
    return isarray(var***REMOVED*** and var.get('typespec'***REMOVED*** in ['integer', 'logical'***REMOVED***\
        and get_kind(var***REMOVED*** == '-8'


def issigned_chararray(var***REMOVED***:
    return isarray(var***REMOVED*** and var.get('typespec'***REMOVED*** in ['integer', 'logical'***REMOVED***\
        and get_kind(var***REMOVED*** == '1'


def issigned_shortarray(var***REMOVED***:
    return isarray(var***REMOVED*** and var.get('typespec'***REMOVED*** in ['integer', 'logical'***REMOVED***\
        and get_kind(var***REMOVED*** == '2'


def issigned_array(var***REMOVED***:
    return isarray(var***REMOVED*** and var.get('typespec'***REMOVED*** in ['integer', 'logical'***REMOVED***\
        and get_kind(var***REMOVED*** == '4'


def issigned_long_longarray(var***REMOVED***:
    return isarray(var***REMOVED*** and var.get('typespec'***REMOVED*** in ['integer', 'logical'***REMOVED***\
        and get_kind(var***REMOVED*** == '8'


def isallocatable(var***REMOVED***:
    return 'attrspec' in var and 'allocatable' in var['attrspec'***REMOVED***


def ismutable(var***REMOVED***:
    return not ('dimension' not in var or isstring(var***REMOVED******REMOVED***


def ismoduleroutine(rout***REMOVED***:
    return 'modulename' in rout


def ismodule(rout***REMOVED***:
    return 'block' in rout and 'module' == rout['block'***REMOVED***


def isfunction(rout***REMOVED***:
    return 'block' in rout and 'function' == rout['block'***REMOVED***

def isfunction_wrap(rout***REMOVED***:
    if isintent_c(rout***REMOVED***:
        return 0
    return wrapfuncs and isfunction(rout***REMOVED*** and (not isexternal(rout***REMOVED******REMOVED***


def issubroutine(rout***REMOVED***:
    return 'block' in rout and 'subroutine' == rout['block'***REMOVED***


def issubroutine_wrap(rout***REMOVED***:
    if isintent_c(rout***REMOVED***:
        return 0
    return issubroutine(rout***REMOVED*** and hasassumedshape(rout***REMOVED***


def hasassumedshape(rout***REMOVED***:
    if rout.get('hasassumedshape'***REMOVED***:
        return True
    for a in rout['args'***REMOVED***:
        for d in rout['vars'***REMOVED***.get(a, {***REMOVED******REMOVED***.get('dimension', [***REMOVED******REMOVED***:
            if d == ':':
                rout['hasassumedshape'***REMOVED*** = True
                return True
    return False


def isroutine(rout***REMOVED***:
    return isfunction(rout***REMOVED*** or issubroutine(rout***REMOVED***


def islogicalfunction(rout***REMOVED***:
    if not isfunction(rout***REMOVED***:
        return 0
    if 'result' in rout:
        a = rout['result'***REMOVED***
    else:
        a = rout['name'***REMOVED***
    if a in rout['vars'***REMOVED***:
        return islogical(rout['vars'***REMOVED***[a***REMOVED******REMOVED***
    return 0


def islong_longfunction(rout***REMOVED***:
    if not isfunction(rout***REMOVED***:
        return 0
    if 'result' in rout:
        a = rout['result'***REMOVED***
    else:
        a = rout['name'***REMOVED***
    if a in rout['vars'***REMOVED***:
        return islong_long(rout['vars'***REMOVED***[a***REMOVED******REMOVED***
    return 0


def islong_doublefunction(rout***REMOVED***:
    if not isfunction(rout***REMOVED***:
        return 0
    if 'result' in rout:
        a = rout['result'***REMOVED***
    else:
        a = rout['name'***REMOVED***
    if a in rout['vars'***REMOVED***:
        return islong_double(rout['vars'***REMOVED***[a***REMOVED******REMOVED***
    return 0


def iscomplexfunction(rout***REMOVED***:
    if not isfunction(rout***REMOVED***:
        return 0
    if 'result' in rout:
        a = rout['result'***REMOVED***
    else:
        a = rout['name'***REMOVED***
    if a in rout['vars'***REMOVED***:
        return iscomplex(rout['vars'***REMOVED***[a***REMOVED******REMOVED***
    return 0


def iscomplexfunction_warn(rout***REMOVED***:
    if iscomplexfunction(rout***REMOVED***:
        outmess(***REMOVED***\
    **************************************************************
        Warning: code with a function returning complex value
        may not work correctly with your Fortran compiler.
        Run the following test before using it in your applications:
        $(f2py install dir***REMOVED***/test-site/{b/runme_scalar,e/runme***REMOVED***
        When using GNU gcc/g77 compilers, codes should work correctly.
    **************************************************************\n***REMOVED******REMOVED***
        return 1
    return 0


def isstringfunction(rout***REMOVED***:
    if not isfunction(rout***REMOVED***:
        return 0
    if 'result' in rout:
        a = rout['result'***REMOVED***
    else:
        a = rout['name'***REMOVED***
    if a in rout['vars'***REMOVED***:
        return isstring(rout['vars'***REMOVED***[a***REMOVED******REMOVED***
    return 0


def hasexternals(rout***REMOVED***:
    return 'externals' in rout and rout['externals'***REMOVED***


def isthreadsafe(rout***REMOVED***:
    return 'f2pyenhancements' in rout and \
           'threadsafe' in rout['f2pyenhancements'***REMOVED***


def hasvariables(rout***REMOVED***:
    return 'vars' in rout and rout['vars'***REMOVED***


def isoptional(var***REMOVED***:
    return ('attrspec' in var and 'optional' in var['attrspec'***REMOVED*** and
            'required' not in var['attrspec'***REMOVED******REMOVED*** and isintent_nothide(var***REMOVED***


def isexternal(var***REMOVED***:
    return 'attrspec' in var and 'external' in var['attrspec'***REMOVED***


def isrequired(var***REMOVED***:
    return not isoptional(var***REMOVED*** and isintent_nothide(var***REMOVED***


def isintent_in(var***REMOVED***:
    if 'intent' not in var:
        return 1
    if 'hide' in var['intent'***REMOVED***:
        return 0
    if 'inplace' in var['intent'***REMOVED***:
        return 0
    if 'in' in var['intent'***REMOVED***:
        return 1
    if 'out' in var['intent'***REMOVED***:
        return 0
    if 'inout' in var['intent'***REMOVED***:
        return 0
    if 'outin' in var['intent'***REMOVED***:
        return 0
    return 1


def isintent_inout(var***REMOVED***:
    return ('intent' in var and ('inout' in var['intent'***REMOVED*** or
            'outin' in var['intent'***REMOVED******REMOVED*** and 'in' not in var['intent'***REMOVED*** and
            'hide' not in var['intent'***REMOVED*** and 'inplace' not in var['intent'***REMOVED******REMOVED***


def isintent_out(var***REMOVED***:
    return 'out' in var.get('intent', [***REMOVED******REMOVED***


def isintent_hide(var***REMOVED***:
    return ('intent' in var and ('hide' in var['intent'***REMOVED*** or
            ('out' in var['intent'***REMOVED*** and 'in' not in var['intent'***REMOVED*** and
                (not l_or(isintent_inout, isintent_inplace***REMOVED***(var***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***

def isintent_nothide(var***REMOVED***:
    return not isintent_hide(var***REMOVED***


def isintent_c(var***REMOVED***:
    return 'c' in var.get('intent', [***REMOVED******REMOVED***


def isintent_cache(var***REMOVED***:
    return 'cache' in var.get('intent', [***REMOVED******REMOVED***


def isintent_copy(var***REMOVED***:
    return 'copy' in var.get('intent', [***REMOVED******REMOVED***


def isintent_overwrite(var***REMOVED***:
    return 'overwrite' in var.get('intent', [***REMOVED******REMOVED***


def isintent_callback(var***REMOVED***:
    return 'callback' in var.get('intent', [***REMOVED******REMOVED***


def isintent_inplace(var***REMOVED***:
    return 'inplace' in var.get('intent', [***REMOVED******REMOVED***


def isintent_aux(var***REMOVED***:
    return 'aux' in var.get('intent', [***REMOVED******REMOVED***


def isintent_aligned4(var***REMOVED***:
    return 'aligned4' in var.get('intent', [***REMOVED******REMOVED***


def isintent_aligned8(var***REMOVED***:
    return 'aligned8' in var.get('intent', [***REMOVED******REMOVED***


def isintent_aligned16(var***REMOVED***:
    return 'aligned16' in var.get('intent', [***REMOVED******REMOVED***

isintent_dict = {isintent_in: 'INTENT_IN', isintent_inout: 'INTENT_INOUT',
                 isintent_out: 'INTENT_OUT', isintent_hide: 'INTENT_HIDE',
                 isintent_cache: 'INTENT_CACHE',
                 isintent_c: 'INTENT_C', isoptional: 'OPTIONAL',
                 isintent_inplace: 'INTENT_INPLACE',
                 isintent_aligned4: 'INTENT_ALIGNED4',
                 isintent_aligned8: 'INTENT_ALIGNED8',
                 isintent_aligned16: 'INTENT_ALIGNED16',
             ***REMOVED***


def isprivate(var***REMOVED***:
    return 'attrspec' in var and 'private' in var['attrspec'***REMOVED***


def hasinitvalue(var***REMOVED***:
    return '=' in var


def hasinitvalueasstring(var***REMOVED***:
    if not hasinitvalue(var***REMOVED***:
        return 0
    return var['='***REMOVED***[0***REMOVED*** in ['"', "'"***REMOVED***


def hasnote(var***REMOVED***:
    return 'note' in var


def hasresultnote(rout***REMOVED***:
    if not isfunction(rout***REMOVED***:
        return 0
    if 'result' in rout:
        a = rout['result'***REMOVED***
    else:
        a = rout['name'***REMOVED***
    if a in rout['vars'***REMOVED***:
        return hasnote(rout['vars'***REMOVED***[a***REMOVED******REMOVED***
    return 0


def hascommon(rout***REMOVED***:
    return 'common' in rout


def containscommon(rout***REMOVED***:
    if hascommon(rout***REMOVED***:
        return 1
    if hasbody(rout***REMOVED***:
        for b in rout['body'***REMOVED***:
            if containscommon(b***REMOVED***:
                return 1
    return 0


def containsmodule(block***REMOVED***:
    if ismodule(block***REMOVED***:
        return 1
    if not hasbody(block***REMOVED***:
        return 0
    for b in block['body'***REMOVED***:
        if containsmodule(b***REMOVED***:
            return 1
    return 0


def hasbody(rout***REMOVED***:
    return 'body' in rout


def hascallstatement(rout***REMOVED***:
    return getcallstatement(rout***REMOVED*** is not None


def istrue(var***REMOVED***:
    return 1


def isfalse(var***REMOVED***:
    return 0


class F2PYError(Exception***REMOVED***:
    pass


class throw_error:

    def __init__(self, mess***REMOVED***:
        self.mess = mess

    def __call__(self, var***REMOVED***:
        mess = '\n\n  var = %s\n  Message: %s\n' % (var, self.mess***REMOVED***
        raise F2PYError(mess***REMOVED***


def l_and(*f***REMOVED***:
    l, l2 = 'lambda v', [***REMOVED***
    for i in range(len(f***REMOVED******REMOVED***:
        l = '%s,f%d=f[%d***REMOVED***' % (l, i, i***REMOVED***
        l2.append('f%d(v***REMOVED***' % (i***REMOVED******REMOVED***
    return eval('%s:%s' % (l, ' and '.join(l2***REMOVED******REMOVED******REMOVED***


def l_or(*f***REMOVED***:
    l, l2 = 'lambda v', [***REMOVED***
    for i in range(len(f***REMOVED******REMOVED***:
        l = '%s,f%d=f[%d***REMOVED***' % (l, i, i***REMOVED***
        l2.append('f%d(v***REMOVED***' % (i***REMOVED******REMOVED***
    return eval('%s:%s' % (l, ' or '.join(l2***REMOVED******REMOVED******REMOVED***


def l_not(f***REMOVED***:
    return eval('lambda v,f=f:not f(v***REMOVED***'***REMOVED***


def isdummyroutine(rout***REMOVED***:
    ***REMOVED***
        return rout['f2pyenhancements'***REMOVED***['fortranname'***REMOVED*** == ''
    except KeyError:
        return 0


def getfortranname(rout***REMOVED***:
    ***REMOVED***
        name = rout['f2pyenhancements'***REMOVED***['fortranname'***REMOVED***
        if name == '':
            raise KeyError
        if not name:
            errmess('Failed to use fortranname from %s\n' %
                    (rout['f2pyenhancements'***REMOVED******REMOVED******REMOVED***
            raise KeyError
    except KeyError:
        name = rout['name'***REMOVED***
    return name


def getmultilineblock(rout, blockname, comment=1, counter=0***REMOVED***:
    ***REMOVED***
        r = rout['f2pyenhancements'***REMOVED***.get(blockname***REMOVED***
    except KeyError:
        return
    if not r:
        return
    if counter > 0 and isinstance(r, str***REMOVED***:
        return
    if isinstance(r, list***REMOVED***:
        if counter >= len(r***REMOVED***:
            return
        r = r[counter***REMOVED***
    if r[:3***REMOVED*** == "'''":
        if comment:
            r = '\t/* start ' + blockname + \
                ' multiline (' + repr(counter***REMOVED*** + '***REMOVED*** */\n' + r[3:***REMOVED***
        else:
            r = r[3:***REMOVED***
        if r[-3:***REMOVED*** == "'''":
            if comment:
                r = r[:-3***REMOVED*** + '\n\t/* end multiline (' + repr(counter***REMOVED*** + '***REMOVED****/'
            else:
                r = r[:-3***REMOVED***
        else:
            errmess("%s multiline block should end with `'''`: %s\n"
                    % (blockname, repr(r***REMOVED******REMOVED******REMOVED***
    return r


def getcallstatement(rout***REMOVED***:
    return getmultilineblock(rout, 'callstatement'***REMOVED***


def getcallprotoargument(rout, cb_map={***REMOVED******REMOVED***:
    r = getmultilineblock(rout, 'callprotoargument', comment=0***REMOVED***
    if r:
        return r
    if hascallstatement(rout***REMOVED***:
        outmess(
            'warning: callstatement is defined without callprotoargument\n'***REMOVED***
        return
    from .capi_maps import getctype
    arg_types, arg_types2 = [***REMOVED***, [***REMOVED***
    if l_and(isstringfunction, l_not(isfunction_wrap***REMOVED******REMOVED***(rout***REMOVED***:
        arg_types.extend(['char*', 'size_t'***REMOVED******REMOVED***
    for n in rout['args'***REMOVED***:
        var = rout['vars'***REMOVED***[n***REMOVED***
        if isintent_callback(var***REMOVED***:
            continue
        if n in cb_map:
            ctype = cb_map[n***REMOVED*** + '_typedef'
        else:
            ctype = getctype(var***REMOVED***
            if l_and(isintent_c, l_or(isscalar, iscomplex***REMOVED******REMOVED***(var***REMOVED***:
                pass
            elif isstring(var***REMOVED***:
                pass
            else:
                ctype = ctype + '*'
            if isstring(var***REMOVED*** or isarrayofstrings(var***REMOVED***:
                arg_types2.append('size_t'***REMOVED***
        arg_types.append(ctype***REMOVED***

    proto_args = ','.join(arg_types + arg_types2***REMOVED***
    if not proto_args:
        proto_args = 'void'
    return proto_args


def getusercode(rout***REMOVED***:
    return getmultilineblock(rout, 'usercode'***REMOVED***


def getusercode1(rout***REMOVED***:
    return getmultilineblock(rout, 'usercode', counter=1***REMOVED***


def getpymethoddef(rout***REMOVED***:
    return getmultilineblock(rout, 'pymethoddef'***REMOVED***


def getargs(rout***REMOVED***:
    sortargs, args = [***REMOVED***, [***REMOVED***
    if 'args' in rout:
        args = rout['args'***REMOVED***
        if 'sortvars' in rout:
            for a in rout['sortvars'***REMOVED***:
                if a in args:
                    sortargs.append(a***REMOVED***
            for a in args:
                if a not in sortargs:
                    sortargs.append(a***REMOVED***
        else:
            sortargs = rout['args'***REMOVED***
    return args, sortargs


def getargs2(rout***REMOVED***:
    sortargs, args = [***REMOVED***, rout.get('args', [***REMOVED******REMOVED***
    auxvars = [a for a in rout['vars'***REMOVED***.keys(***REMOVED*** if isintent_aux(rout['vars'***REMOVED***[a***REMOVED******REMOVED***
               and a not in args***REMOVED***
    args = auxvars + args
    if 'sortvars' in rout:
        for a in rout['sortvars'***REMOVED***:
            if a in args:
                sortargs.append(a***REMOVED***
        for a in args:
            if a not in sortargs:
                sortargs.append(a***REMOVED***
    else:
        sortargs = auxvars + rout['args'***REMOVED***
    return args, sortargs


def getrestdoc(rout***REMOVED***:
    if 'f2pymultilines' not in rout:
        return None
    k = None
    if rout['block'***REMOVED*** == 'python module':
        k = rout['block'***REMOVED***, rout['name'***REMOVED***
    return rout['f2pymultilines'***REMOVED***.get(k, None***REMOVED***


def gentitle(name***REMOVED***:
    l = (80 - len(name***REMOVED*** - 6***REMOVED*** // 2
    return '/*%s %s %s*/' % (l * '*', name, l * '*'***REMOVED***


def flatlist(l***REMOVED***:
    if isinstance(l, list***REMOVED***:
        return reduce(lambda x, y, f=flatlist: x + f(y***REMOVED***, l, [***REMOVED******REMOVED***
    return [l***REMOVED***


def stripcomma(s***REMOVED***:
    if s and s[-1***REMOVED*** == ',':
        return s[:-1***REMOVED***
    return s


def replace(str, d, defaultsep=''***REMOVED***:
    if isinstance(d, list***REMOVED***:
        return [replace(str, _m, defaultsep***REMOVED*** for _m in d***REMOVED***
    if isinstance(str, list***REMOVED***:
        return [replace(_m, d, defaultsep***REMOVED*** for _m in str***REMOVED***
    for k in 2 * list(d.keys(***REMOVED******REMOVED***:
        if k == 'separatorsfor':
            continue
        if 'separatorsfor' in d and k in d['separatorsfor'***REMOVED***:
            sep = d['separatorsfor'***REMOVED***[k***REMOVED***
        else:
            sep = defaultsep
        if isinstance(d[k***REMOVED***, list***REMOVED***:
            str = str.replace('#%s#' % (k***REMOVED***, sep.join(flatlist(d[k***REMOVED******REMOVED******REMOVED******REMOVED***
        else:
            str = str.replace('#%s#' % (k***REMOVED***, d[k***REMOVED******REMOVED***
    return str


def dictappend(rd, ar***REMOVED***:
    if isinstance(ar, list***REMOVED***:
        for a in ar:
            rd = dictappend(rd, a***REMOVED***
        return rd
    for k in ar.keys(***REMOVED***:
        if k[0***REMOVED*** == '_':
            continue
        if k in rd:
            if isinstance(rd[k***REMOVED***, str***REMOVED***:
                rd[k***REMOVED*** = [rd[k***REMOVED******REMOVED***
            if isinstance(rd[k***REMOVED***, list***REMOVED***:
                if isinstance(ar[k***REMOVED***, list***REMOVED***:
                    rd[k***REMOVED*** = rd[k***REMOVED*** + ar[k***REMOVED***
                else:
                    rd[k***REMOVED***.append(ar[k***REMOVED******REMOVED***
            elif isinstance(rd[k***REMOVED***, dict***REMOVED***:
                if isinstance(ar[k***REMOVED***, dict***REMOVED***:
                    if k == 'separatorsfor':
                        for k1 in ar[k***REMOVED***.keys(***REMOVED***:
                            if k1 not in rd[k***REMOVED***:
                                rd[k***REMOVED***[k1***REMOVED*** = ar[k***REMOVED***[k1***REMOVED***
                    else:
                        rd[k***REMOVED*** = dictappend(rd[k***REMOVED***, ar[k***REMOVED******REMOVED***
        else:
            rd[k***REMOVED*** = ar[k***REMOVED***
    return rd


def applyrules(rules, d, var={***REMOVED******REMOVED***:
    ret = {***REMOVED***
    if isinstance(rules, list***REMOVED***:
        for r in rules:
            rr = applyrules(r, d, var***REMOVED***
            ret = dictappend(ret, rr***REMOVED***
            if '_break' in rr:
                break
        return ret
    if '_check' in rules and (not rules['_check'***REMOVED***(var***REMOVED******REMOVED***:
        return ret
    if 'need' in rules:
        res = applyrules({'needs': rules['need'***REMOVED******REMOVED***, d, var***REMOVED***
        if 'needs' in res:
            cfuncs.append_needs(res['needs'***REMOVED******REMOVED***

    for k in rules.keys(***REMOVED***:
        if k == 'separatorsfor':
            ret[k***REMOVED*** = rules[k***REMOVED***
            continue
        if isinstance(rules[k***REMOVED***, str***REMOVED***:
            ret[k***REMOVED*** = replace(rules[k***REMOVED***, d***REMOVED***
        elif isinstance(rules[k***REMOVED***, list***REMOVED***:
            ret[k***REMOVED*** = [***REMOVED***
            for i in rules[k***REMOVED***:
                ar = applyrules({k: i***REMOVED***, d, var***REMOVED***
                if k in ar:
                    ret[k***REMOVED***.append(ar[k***REMOVED******REMOVED***
        elif k[0***REMOVED*** == '_':
            continue
        elif isinstance(rules[k***REMOVED***, dict***REMOVED***:
            ret[k***REMOVED*** = [***REMOVED***
            for k1 in rules[k***REMOVED***.keys(***REMOVED***:
                if isinstance(k1, types.FunctionType***REMOVED*** and k1(var***REMOVED***:
                    if isinstance(rules[k***REMOVED***[k1***REMOVED***, list***REMOVED***:
                        for i in rules[k***REMOVED***[k1***REMOVED***:
                            if isinstance(i, dict***REMOVED***:
                                res = applyrules({'supertext': i***REMOVED***, d, var***REMOVED***
                                if 'supertext' in res:
                                    i = res['supertext'***REMOVED***
                                else:
                                    i = ''
                            ret[k***REMOVED***.append(replace(i, d***REMOVED******REMOVED***
                    else:
                        i = rules[k***REMOVED***[k1***REMOVED***
                        if isinstance(i, dict***REMOVED***:
                            res = applyrules({'supertext': i***REMOVED***, d***REMOVED***
                            if 'supertext' in res:
                                i = res['supertext'***REMOVED***
                            else:
                                i = ''
                        ret[k***REMOVED***.append(replace(i, d***REMOVED******REMOVED***
        else:
            errmess('applyrules: ignoring rule %s.\n' % repr(rules[k***REMOVED******REMOVED******REMOVED***
        if isinstance(ret[k***REMOVED***, list***REMOVED***:
            if len(ret[k***REMOVED******REMOVED*** == 1:
                ret[k***REMOVED*** = ret[k***REMOVED***[0***REMOVED***
            if ret[k***REMOVED*** == [***REMOVED***:
                del ret[k***REMOVED***
    return ret
