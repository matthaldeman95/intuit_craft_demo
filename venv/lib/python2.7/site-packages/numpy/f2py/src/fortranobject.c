#define FORTRANOBJECT_C
#include "fortranobject.h"

#ifdef __cplusplus
extern "C" {
#endif

#include <stdlib.h>
#include <string.h>

/*
  This file implements: FortranObject, array_from_pyobj, copy_ND_array

  Author: Pearu Peterson <pearu@cens.ioc.ee>
  $Revision: 1.52 $
  $Date: 2005/07/11 07:44:20 $
*/

int
F2PyDict_SetItemString(PyObject *dict, char *name, PyObject *obj***REMOVED***
{
    if (obj==NULL***REMOVED*** {
        fprintf(stderr, "Error loading %s\n", name***REMOVED***;
        if (PyErr_Occurred(***REMOVED******REMOVED*** {
            PyErr_Print(***REMOVED***;
            PyErr_Clear(***REMOVED***;
    ***REMOVED***
        return -1;
***REMOVED***
    return PyDict_SetItemString(dict, name, obj***REMOVED***;
***REMOVED***

/************************* FortranObject *******************************/

typedef PyObject *(*fortranfunc***REMOVED***(PyObject *,PyObject *,PyObject *,void ****REMOVED***;

PyObject *
PyFortranObject_New(FortranDataDef* defs, f2py_void_func init***REMOVED*** {
    int i;
    PyFortranObject *fp = NULL;
    PyObject *v = NULL;
    if (init!=NULL***REMOVED***                           /* Initialize F90 module objects */
        (*(init***REMOVED******REMOVED***(***REMOVED***;
    if ((fp = PyObject_New(PyFortranObject, &PyFortran_Type***REMOVED******REMOVED***==NULL***REMOVED*** return NULL;
    if ((fp->dict = PyDict_New(***REMOVED******REMOVED***==NULL***REMOVED*** return NULL;
    fp->len = 0;
    while (defs[fp->len***REMOVED***.name != NULL***REMOVED*** fp->len++;
    if (fp->len == 0***REMOVED*** goto fail;
    fp->defs = defs;
    for (i=0;i<fp->len;i++***REMOVED***
        if (fp->defs[i***REMOVED***.rank == -1***REMOVED*** {                      /* Is Fortran routine */
            v = PyFortranObject_NewAsAttr(&(fp->defs[i***REMOVED******REMOVED******REMOVED***;
            if (v==NULL***REMOVED*** return NULL;
            PyDict_SetItemString(fp->dict,fp->defs[i***REMOVED***.name,v***REMOVED***;
    ***REMOVED*** else
            if ((fp->defs[i***REMOVED***.data***REMOVED***!=NULL***REMOVED*** { /* Is Fortran variable or array (not allocatable***REMOVED*** */
                if (fp->defs[i***REMOVED***.type == NPY_STRING***REMOVED*** {
                    int n = fp->defs[i***REMOVED***.rank-1;
                    v = PyArray_New(&PyArray_Type, n, fp->defs[i***REMOVED***.dims.d,
                                    NPY_STRING, NULL, fp->defs[i***REMOVED***.data, fp->defs[i***REMOVED***.dims.d[n***REMOVED***,
                                    NPY_ARRAY_FARRAY, NULL***REMOVED***;
            ***REMOVED***
                else {
                    v = PyArray_New(&PyArray_Type, fp->defs[i***REMOVED***.rank, fp->defs[i***REMOVED***.dims.d,
                                    fp->defs[i***REMOVED***.type, NULL, fp->defs[i***REMOVED***.data, 0, NPY_ARRAY_FARRAY,
                                    NULL***REMOVED***;
            ***REMOVED***
                if (v==NULL***REMOVED*** return NULL;
                PyDict_SetItemString(fp->dict,fp->defs[i***REMOVED***.name,v***REMOVED***;
        ***REMOVED***
    Py_XDECREF(v***REMOVED***;
    return (PyObject ****REMOVED***fp;
 fail:
    Py_XDECREF(v***REMOVED***;
    return NULL;
***REMOVED***

PyObject *
PyFortranObject_NewAsAttr(FortranDataDef* defs***REMOVED*** { /* used for calling F90 module routines */
    PyFortranObject *fp = NULL;
    fp = PyObject_New(PyFortranObject, &PyFortran_Type***REMOVED***;
    if (fp == NULL***REMOVED*** return NULL;
    if ((fp->dict = PyDict_New(***REMOVED******REMOVED***==NULL***REMOVED*** return NULL;
    fp->len = 1;
    fp->defs = defs;
    return (PyObject ****REMOVED***fp;
***REMOVED***

/* Fortran methods */

static void
fortran_dealloc(PyFortranObject *fp***REMOVED*** {
    Py_XDECREF(fp->dict***REMOVED***;
    PyMem_Del(fp***REMOVED***;
***REMOVED***


#if PY_VERSION_HEX >= 0x03000000
#else
static PyMethodDef fortran_methods[***REMOVED*** = {
***REMOVED***NULL,          NULL***REMOVED***           /* sentinel */
***REMOVED***;
#endif


/* Returns number of bytes consumed from buf, or -1 on error. */
static Py_ssize_t
format_def(char *buf, Py_ssize_t size, FortranDataDef def***REMOVED***
{
    char *p = buf;
    int i, n;

    n = PyOS_snprintf(p, size, "array(%" NPY_INTP_FMT, def.dims.d[0***REMOVED******REMOVED***;
    if (n < 0 || n >= size***REMOVED*** {
        return -1;
***REMOVED***
    p += n;
    size -= n;

    for (i = 1; i < def.rank; i++***REMOVED*** {
        n = PyOS_snprintf(p, size, ",%" NPY_INTP_FMT, def.dims.d[i***REMOVED******REMOVED***;
        if (n < 0 || n >= size***REMOVED*** {
            return -1;
    ***REMOVED***
        p += n;
        size -= n;
***REMOVED***

    if (size <= 0***REMOVED*** {
        return -1;
***REMOVED***

    p[size***REMOVED*** = '***REMOVED***';
    p++;
    size--;

    if (def.data == NULL***REMOVED*** {
        static const char notalloc[***REMOVED*** = ", not allocated";
        if (size < sizeof(notalloc***REMOVED******REMOVED*** {
            return -1;
    ***REMOVED***
        memcpy(p, notalloc, sizeof(notalloc***REMOVED******REMOVED***;
***REMOVED***

    return p - buf;
***REMOVED***

static PyObject *
fortran_doc(FortranDataDef def***REMOVED***
{
    char *buf, *p;
    PyObject *s = NULL;
    Py_ssize_t n, origsize, size = 100;

    if (def.doc != NULL***REMOVED*** {
        size += strlen(def.doc***REMOVED***;
***REMOVED***
    origsize = size;
    buf = p = (char ****REMOVED***PyMem_Malloc(size***REMOVED***;
    if (buf == NULL***REMOVED*** {
        return PyErr_NoMemory(***REMOVED***;
***REMOVED***

    if (def.rank == -1***REMOVED*** {
        if (def.doc***REMOVED*** {
            n = strlen(def.doc***REMOVED***;
            if (n > size***REMOVED*** {
                goto fail;
        ***REMOVED***
            memcpy(p, def.doc, n***REMOVED***;
            p += n;
            size -= n;
    ***REMOVED***
        else {
            n = PyOS_snprintf(p, size, "%s - no docs available", def.name***REMOVED***;
            if (n < 0 || n >= size***REMOVED*** {
                goto fail;
        ***REMOVED***
            p += n;
            size -= n;
    ***REMOVED***
***REMOVED***
    else {
        PyArray_Descr *d = PyArray_DescrFromType(def.type***REMOVED***;
        n = PyOS_snprintf(p, size, "'%c'-", d->type***REMOVED***;
        Py_DECREF(d***REMOVED***;
        if (n < 0 || n >= size***REMOVED*** {
            goto fail;
    ***REMOVED***
        p += n;
        size -= n;

        if (def.data == NULL***REMOVED*** {
            n = format_def(p, size, def***REMOVED*** == -1;
            if (n < 0***REMOVED*** {
                goto fail;
        ***REMOVED***
            p += n;
            size -= n;
    ***REMOVED***
        else if (def.rank > 0***REMOVED*** {
            n = format_def(p, size, def***REMOVED***;
            if (n < 0***REMOVED*** {
                goto fail;
        ***REMOVED***
            p += n;
            size -= n;
    ***REMOVED***
        else {
            n = strlen("scalar"***REMOVED***;
            if (size < n***REMOVED*** {
                goto fail;
        ***REMOVED***
            memcpy(p, "scalar", n***REMOVED***;
            p += n;
            size -= n;
    ***REMOVED***
***REMOVED***
    if (size <= 1***REMOVED*** {
        goto fail;
***REMOVED***
    *p++ = '\n';
    size--;

    /* p now points one beyond the last character of the string in buf */
#if PY_VERSION_HEX >= 0x03000000
    s = PyUnicode_FromStringAndSize(buf, p - buf***REMOVED***;
#else
    s = PyString_FromStringAndSize(buf, p - buf***REMOVED***;
#endif

    PyMem_Free(buf***REMOVED***;
    return s;

 fail:
    fprintf(stderr, "fortranobject.c: fortran_doc: len(p***REMOVED***=%zd>%zd=size:"
                    " too long docstring required, increase size\n",
            p - buf, origsize***REMOVED***;
    PyMem_Free(buf***REMOVED***;
    return NULL;
***REMOVED***

static FortranDataDef *save_def; /* save pointer of an allocatable array */
static void set_data(char *d,npy_intp *f***REMOVED*** {  /* callback from Fortran */
    if (*f***REMOVED***                               /* In fortran f=allocated(d***REMOVED*** */
        save_def->data = d;
    else
        save_def->data = NULL;
    /* printf("set_data: d=%p,f=%d\n",d,*f***REMOVED***; */
***REMOVED***

static PyObject *
fortran_getattr(PyFortranObject *fp, char *name***REMOVED*** {
    int i,j,k,flag;
    if (fp->dict != NULL***REMOVED*** {
        PyObject *v = PyDict_GetItemString(fp->dict, name***REMOVED***;
        if (v != NULL***REMOVED*** {
            Py_INCREF(v***REMOVED***;
            return v;
    ***REMOVED***
***REMOVED***
    for (i=0,j=1;i<fp->len && (j=strcmp(name,fp->defs[i***REMOVED***.name***REMOVED******REMOVED***;i++***REMOVED***;
    if (j==0***REMOVED***
        if (fp->defs[i***REMOVED***.rank!=-1***REMOVED*** {                   /* F90 allocatable array */
            if (fp->defs[i***REMOVED***.func==NULL***REMOVED*** return NULL;
            for(k=0;k<fp->defs[i***REMOVED***.rank;++k***REMOVED***
                fp->defs[i***REMOVED***.dims.d[k***REMOVED***=-1;
            save_def = &fp->defs[i***REMOVED***;
            (*(fp->defs[i***REMOVED***.func***REMOVED******REMOVED***(&fp->defs[i***REMOVED***.rank,fp->defs[i***REMOVED***.dims.d,set_data,&flag***REMOVED***;
            if (flag==2***REMOVED***
                k = fp->defs[i***REMOVED***.rank + 1;
            else
                k = fp->defs[i***REMOVED***.rank;
            if (fp->defs[i***REMOVED***.data !=NULL***REMOVED*** {              /* array is allocated */
                PyObject *v = PyArray_New(&PyArray_Type, k, fp->defs[i***REMOVED***.dims.d,
                                          fp->defs[i***REMOVED***.type, NULL, fp->defs[i***REMOVED***.data, 0, NPY_ARRAY_FARRAY,
                                          NULL***REMOVED***;
                if (v==NULL***REMOVED*** return NULL;
                /* Py_INCREF(v***REMOVED***; */
                return v;
        ***REMOVED*** else {                                    /* array is not allocated */
                Py_RETURN_NONE;
        ***REMOVED***
    ***REMOVED***
    if (strcmp(name,"__dict__"***REMOVED***==0***REMOVED*** {
        Py_INCREF(fp->dict***REMOVED***;
        return fp->dict;
***REMOVED***
    if (strcmp(name,"__doc__"***REMOVED***==0***REMOVED*** {
#if PY_VERSION_HEX >= 0x03000000
        PyObject *s = PyUnicode_FromString(""***REMOVED***, *s2, *s3;
        for (i=0;i<fp->len;i++***REMOVED*** {
            s2 = fortran_doc(fp->defs[i***REMOVED******REMOVED***;
            s3 = PyUnicode_Concat(s, s2***REMOVED***;
            Py_DECREF(s2***REMOVED***;
            Py_DECREF(s***REMOVED***;
            s = s3;
    ***REMOVED***
#else
        PyObject *s = PyString_FromString(""***REMOVED***;
        for (i=0;i<fp->len;i++***REMOVED***
            PyString_ConcatAndDel(&s,fortran_doc(fp->defs[i***REMOVED******REMOVED******REMOVED***;
#endif
        if (PyDict_SetItemString(fp->dict, name, s***REMOVED******REMOVED***
            return NULL;
        return s;
***REMOVED***
    if ((strcmp(name,"_cpointer"***REMOVED***==0***REMOVED*** && (fp->len==1***REMOVED******REMOVED*** {
        PyObject *cobj = F2PyCapsule_FromVoidPtr((void ****REMOVED***(fp->defs[0***REMOVED***.data***REMOVED***,NULL***REMOVED***;
        if (PyDict_SetItemString(fp->dict, name, cobj***REMOVED******REMOVED***
            return NULL;
        return cobj;
***REMOVED***
#if PY_VERSION_HEX >= 0x03000000
    if (1***REMOVED*** {
        PyObject *str, *ret;
        str = PyUnicode_FromString(name***REMOVED***;
        ret = PyObject_GenericGetAttr((PyObject ****REMOVED***fp, str***REMOVED***;
        Py_DECREF(str***REMOVED***;
        return ret;
***REMOVED***
#else
    return Py_FindMethod(fortran_methods, (PyObject ****REMOVED***fp, name***REMOVED***;
#endif
***REMOVED***

static int
fortran_setattr(PyFortranObject *fp, char *name, PyObject *v***REMOVED*** {
    int i,j,flag;
    PyArrayObject *arr = NULL;
    for (i=0,j=1;i<fp->len && (j=strcmp(name,fp->defs[i***REMOVED***.name***REMOVED******REMOVED***;i++***REMOVED***;
    if (j==0***REMOVED*** {
        if (fp->defs[i***REMOVED***.rank==-1***REMOVED*** {
            PyErr_SetString(PyExc_AttributeError,"over-writing fortran routine"***REMOVED***;
            return -1;
    ***REMOVED***
        if (fp->defs[i***REMOVED***.func!=NULL***REMOVED*** { /* is allocatable array */
            npy_intp dims[F2PY_MAX_DIMS***REMOVED***;
            int k;
            save_def = &fp->defs[i***REMOVED***;
            if (v!=Py_None***REMOVED*** {     /* set new value (reallocate if needed --
                                     see f2py generated code for more
                                     details ***REMOVED*** */
                for(k=0;k<fp->defs[i***REMOVED***.rank;k++***REMOVED*** dims[k***REMOVED***=-1;
                if ((arr = array_from_pyobj(fp->defs[i***REMOVED***.type,dims,fp->defs[i***REMOVED***.rank,F2PY_INTENT_IN,v***REMOVED******REMOVED***==NULL***REMOVED***
                    return -1;
                (*(fp->defs[i***REMOVED***.func***REMOVED******REMOVED***(&fp->defs[i***REMOVED***.rank,PyArray_DIMS(arr***REMOVED***,set_data,&flag***REMOVED***;
        ***REMOVED*** else {             /* deallocate */
                for(k=0;k<fp->defs[i***REMOVED***.rank;k++***REMOVED*** dims[k***REMOVED***=0;
                (*(fp->defs[i***REMOVED***.func***REMOVED******REMOVED***(&fp->defs[i***REMOVED***.rank,dims,set_data,&flag***REMOVED***;
                for(k=0;k<fp->defs[i***REMOVED***.rank;k++***REMOVED*** dims[k***REMOVED***=-1;
        ***REMOVED***
            memcpy(fp->defs[i***REMOVED***.dims.d,dims,fp->defs[i***REMOVED***.rank*sizeof(npy_intp***REMOVED******REMOVED***;
    ***REMOVED*** else {                     /* not allocatable array */
            if ((arr = array_from_pyobj(fp->defs[i***REMOVED***.type,fp->defs[i***REMOVED***.dims.d,fp->defs[i***REMOVED***.rank,F2PY_INTENT_IN,v***REMOVED******REMOVED***==NULL***REMOVED***
                return -1;
    ***REMOVED***
        if (fp->defs[i***REMOVED***.data!=NULL***REMOVED*** { /* copy Python object to Fortran array */
            npy_intp s = PyArray_MultiplyList(fp->defs[i***REMOVED***.dims.d,PyArray_NDIM(arr***REMOVED******REMOVED***;
            if (s==-1***REMOVED***
                s = PyArray_MultiplyList(PyArray_DIMS(arr***REMOVED***,PyArray_NDIM(arr***REMOVED******REMOVED***;
            if (s<0 ||
                (memcpy(fp->defs[i***REMOVED***.data,PyArray_DATA(arr***REMOVED***,s*PyArray_ITEMSIZE(arr***REMOVED******REMOVED******REMOVED***==NULL***REMOVED*** {
                if ((PyObject****REMOVED***arr!=v***REMOVED*** {
                    Py_DECREF(arr***REMOVED***;
            ***REMOVED***
                return -1;
        ***REMOVED***
            if ((PyObject****REMOVED***arr!=v***REMOVED*** {
                Py_DECREF(arr***REMOVED***;
        ***REMOVED***
    ***REMOVED*** else return (fp->defs[i***REMOVED***.func==NULL?-1:0***REMOVED***;
        return 0; /* succesful */
***REMOVED***
    if (fp->dict == NULL***REMOVED*** {
        fp->dict = PyDict_New(***REMOVED***;
        if (fp->dict == NULL***REMOVED***
            return -1;
***REMOVED***
    if (v == NULL***REMOVED*** {
        int rv = PyDict_DelItemString(fp->dict, name***REMOVED***;
        if (rv < 0***REMOVED***
            PyErr_SetString(PyExc_AttributeError,"delete non-existing fortran attribute"***REMOVED***;
        return rv;
***REMOVED***
    else
        return PyDict_SetItemString(fp->dict, name, v***REMOVED***;
***REMOVED***

static PyObject*
fortran_call(PyFortranObject *fp, PyObject *arg, PyObject *kw***REMOVED*** {
    int i = 0;
    /*  printf("fortran call
        name=%s,func=%p,data=%p,%p\n",fp->defs[i***REMOVED***.name,
        fp->defs[i***REMOVED***.func,fp->defs[i***REMOVED***.data,&fp->defs[i***REMOVED***.data***REMOVED***; */
    if (fp->defs[i***REMOVED***.rank==-1***REMOVED*** {/* is Fortran routine */
        if (fp->defs[i***REMOVED***.func==NULL***REMOVED*** {
            PyErr_Format(PyExc_RuntimeError, "no function to call"***REMOVED***;
            return NULL;
    ***REMOVED***
        else if (fp->defs[i***REMOVED***.data==NULL***REMOVED***
            /* dummy routine */
            return (*((fortranfunc***REMOVED***(fp->defs[i***REMOVED***.func***REMOVED******REMOVED******REMOVED***((PyObject ****REMOVED***fp,arg,kw,NULL***REMOVED***;
        else
            return (*((fortranfunc***REMOVED***(fp->defs[i***REMOVED***.func***REMOVED******REMOVED******REMOVED***((PyObject ****REMOVED***fp,arg,kw,
                                                        (void ****REMOVED***fp->defs[i***REMOVED***.data***REMOVED***;
***REMOVED***
    PyErr_Format(PyExc_TypeError, "this fortran object is not callable"***REMOVED***;
    return NULL;
***REMOVED***

static PyObject *
fortran_repr(PyFortranObject *fp***REMOVED***
{
    PyObject *name = NULL, *repr = NULL;
    name = PyObject_GetAttrString((PyObject ****REMOVED***fp, "__name__"***REMOVED***;
    PyErr_Clear(***REMOVED***;
#if PY_VERSION_HEX >= 0x03000000
    if (name != NULL && PyUnicode_Check(name***REMOVED******REMOVED*** {
        repr = PyUnicode_FromFormat("<fortran %U>", name***REMOVED***;
***REMOVED***
    else {
        repr = PyUnicode_FromString("<fortran object>"***REMOVED***;
***REMOVED***
#else
    if (name != NULL && PyString_Check(name***REMOVED******REMOVED*** {
        repr = PyString_FromFormat("<fortran %s>", PyString_AsString(name***REMOVED******REMOVED***;
***REMOVED***
    else {
        repr = PyString_FromString("<fortran object>"***REMOVED***;
***REMOVED***
#endif
    Py_XDECREF(name***REMOVED***;
    return repr;
***REMOVED***


PyTypeObject PyFortran_Type = {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0***REMOVED***
#else
    PyObject_HEAD_INIT(0***REMOVED***
    0,                    /*ob_size*/
#endif
    "fortran",                    /*tp_name*/
    sizeof(PyFortranObject***REMOVED***,      /*tp_basicsize*/
    0,                    /*tp_itemsize*/
    /* methods */
    (destructor***REMOVED***fortran_dealloc, /*tp_dealloc*/
    0,                    /*tp_print*/
    (getattrfunc***REMOVED***fortran_getattr, /*tp_getattr*/
    (setattrfunc***REMOVED***fortran_setattr, /*tp_setattr*/
    0,                    /*tp_compare/tp_reserved*/
    (reprfunc***REMOVED***fortran_repr, /*tp_repr*/
    0,                    /*tp_as_number*/
    0,                    /*tp_as_sequence*/
    0,                    /*tp_as_mapping*/
    0,                    /*tp_hash*/
    (ternaryfunc***REMOVED***fortran_call,                    /*tp_call*/
***REMOVED***;

/************************* f2py_report_atexit *******************************/

#ifdef F2PY_REPORT_ATEXIT
static int passed_time = 0;
static int passed_counter = 0;
static int passed_call_time = 0;
static struct timeb start_time;
static struct timeb stop_time;
static struct timeb start_call_time;
static struct timeb stop_call_time;
static int cb_passed_time = 0;
static int cb_passed_counter = 0;
static int cb_passed_call_time = 0;
static struct timeb cb_start_time;
static struct timeb cb_stop_time;
static struct timeb cb_start_call_time;
static struct timeb cb_stop_call_time;

extern void f2py_start_clock(void***REMOVED*** { ftime(&start_time***REMOVED***; ***REMOVED***
extern
void f2py_start_call_clock(void***REMOVED*** {
    f2py_stop_clock(***REMOVED***;
    ftime(&start_call_time***REMOVED***;
***REMOVED***
extern
void f2py_stop_clock(void***REMOVED*** {
    ftime(&stop_time***REMOVED***;
    passed_time += 1000*(stop_time.time - start_time.time***REMOVED***;
    passed_time += stop_time.millitm - start_time.millitm;
***REMOVED***
extern
void f2py_stop_call_clock(void***REMOVED*** {
    ftime(&stop_call_time***REMOVED***;
    passed_call_time += 1000*(stop_call_time.time - start_call_time.time***REMOVED***;
    passed_call_time += stop_call_time.millitm - start_call_time.millitm;
    passed_counter += 1;
    f2py_start_clock(***REMOVED***;
***REMOVED***

extern void f2py_cb_start_clock(void***REMOVED*** { ftime(&cb_start_time***REMOVED***; ***REMOVED***
extern
void f2py_cb_start_call_clock(void***REMOVED*** {
    f2py_cb_stop_clock(***REMOVED***;
    ftime(&cb_start_call_time***REMOVED***;
***REMOVED***
extern
void f2py_cb_stop_clock(void***REMOVED*** {
    ftime(&cb_stop_time***REMOVED***;
    cb_passed_time += 1000*(cb_stop_time.time - cb_start_time.time***REMOVED***;
    cb_passed_time += cb_stop_time.millitm - cb_start_time.millitm;
***REMOVED***
extern
void f2py_cb_stop_call_clock(void***REMOVED*** {
    ftime(&cb_stop_call_time***REMOVED***;
    cb_passed_call_time += 1000*(cb_stop_call_time.time - cb_start_call_time.time***REMOVED***;
    cb_passed_call_time += cb_stop_call_time.millitm - cb_start_call_time.millitm;
    cb_passed_counter += 1;
    f2py_cb_start_clock(***REMOVED***;
***REMOVED***

static int f2py_report_on_exit_been_here = 0;
extern
void f2py_report_on_exit(int exit_flag,void *name***REMOVED*** {
    if (f2py_report_on_exit_been_here***REMOVED*** {
        fprintf(stderr,"             %s\n",(char****REMOVED***name***REMOVED***;
        return;
***REMOVED***
    f2py_report_on_exit_been_here = 1;
    fprintf(stderr,"                      /-----------------------\\\n"***REMOVED***;
    fprintf(stderr,"                     < F2PY performance report >\n"***REMOVED***;
    fprintf(stderr,"                      \\-----------------------/\n"***REMOVED***;
    fprintf(stderr,"Overall time spent in ...\n"***REMOVED***;
    fprintf(stderr,"(a***REMOVED*** wrapped (Fortran/C***REMOVED*** functions           : %8d msec\n",
            passed_call_time***REMOVED***;
    fprintf(stderr,"(b***REMOVED*** f2py interface,           %6d calls  : %8d msec\n",
            passed_counter,passed_time***REMOVED***;
    fprintf(stderr,"(c***REMOVED*** call-back (Python***REMOVED*** functions            : %8d msec\n",
            cb_passed_call_time***REMOVED***;
    fprintf(stderr,"(d***REMOVED*** f2py call-back interface, %6d calls  : %8d msec\n",
            cb_passed_counter,cb_passed_time***REMOVED***;

    fprintf(stderr,"(e***REMOVED*** wrapped (Fortran/C***REMOVED*** functions (acctual***REMOVED*** : %8d msec\n\n",
            passed_call_time-cb_passed_call_time-cb_passed_time***REMOVED***;
    fprintf(stderr,"Use -DF2PY_REPORT_ATEXIT_DISABLE to disable this message.\n"***REMOVED***;
    fprintf(stderr,"Exit status: %d\n",exit_flag***REMOVED***;
    fprintf(stderr,"Modules    : %s\n",(char****REMOVED***name***REMOVED***;
***REMOVED***
#endif

/********************** report on array copy ****************************/

#ifdef F2PY_REPORT_ON_ARRAY_COPY
static void f2py_report_on_array_copy(PyArrayObject* arr***REMOVED*** {
    const npy_intp arr_size = PyArray_Size((PyObject ****REMOVED***arr***REMOVED***;
    if (arr_size>F2PY_REPORT_ON_ARRAY_COPY***REMOVED*** {
        fprintf(stderr,"copied an array: size=%ld, elsize=%"NPY_INTP_FMT"\n",
                arr_size, (npy_intp***REMOVED***PyArray_ITEMSIZE(arr***REMOVED******REMOVED***;
***REMOVED***
***REMOVED***
static void f2py_report_on_array_copy_fromany(void***REMOVED*** {
    fprintf(stderr,"created an array from object\n"***REMOVED***;
***REMOVED***

#define F2PY_REPORT_ON_ARRAY_COPY_FROMARR f2py_report_on_array_copy((PyArrayObject ****REMOVED***arr***REMOVED***
#define F2PY_REPORT_ON_ARRAY_COPY_FROMANY f2py_report_on_array_copy_fromany(***REMOVED***
#else
#define F2PY_REPORT_ON_ARRAY_COPY_FROMARR
#define F2PY_REPORT_ON_ARRAY_COPY_FROMANY
#endif


/************************* array_from_obj *******************************/

/*
 * File: array_from_pyobj.c
 *
 * Description:
 * ------------
 * Provides array_from_pyobj function that returns a contigious array
 * object with the given dimensions and required storage order, either
 * in row-major (C***REMOVED*** or column-major (Fortran***REMOVED*** order. The function
 * array_from_pyobj is very flexible about its Python object argument
 * that can be any number, list, tuple, or array.
 *
 * array_from_pyobj is used in f2py generated Python extension
 * modules.
 *
 * Author: Pearu Peterson <pearu@cens.ioc.ee>
 * Created: 13-16 January 2002
 * $Id: fortranobject.c,v 1.52 2005/07/11 07:44:20 pearu Exp $
 */

static int
count_nonpos(const int rank,
             const npy_intp *dims***REMOVED*** {
    int i=0,r=0;
    while (i<rank***REMOVED*** {
        if (dims[i***REMOVED*** <= 0***REMOVED*** ++r;
        ++i;
***REMOVED***
    return r;
***REMOVED***

static int check_and_fix_dimensions(const PyArrayObject* arr,
                                    const int rank,
                                    npy_intp *dims***REMOVED***;

#ifdef DEBUG_COPY_ND_ARRAY
void dump_dims(int rank, npy_intp* dims***REMOVED*** {
    int i;
    printf("["***REMOVED***;
    for(i=0;i<rank;++i***REMOVED*** {
        printf("%3" NPY_INTP_FMT, dims[i***REMOVED******REMOVED***;
***REMOVED***
    printf("***REMOVED***\n"***REMOVED***;
***REMOVED***
void dump_attrs(const PyArrayObject* obj***REMOVED*** {
    const PyArrayObject_fields *arr = (const PyArrayObject_fields****REMOVED*** obj;
    int rank = PyArray_NDIM(arr***REMOVED***;
    npy_intp size = PyArray_Size((PyObject ****REMOVED***arr***REMOVED***;
    printf("\trank = %d, flags = %d, size = %" NPY_INTP_FMT  "\n",
           rank,arr->flags,size***REMOVED***;
    printf("\tstrides = "***REMOVED***;
    dump_dims(rank,arr->strides***REMOVED***;
    printf("\tdimensions = "***REMOVED***;
    dump_dims(rank,arr->dimensions***REMOVED***;
***REMOVED***
#endif

#define SWAPTYPE(a,b,t***REMOVED*** {t c; c = (a***REMOVED***; (a***REMOVED*** = (b***REMOVED***; (b***REMOVED*** = c; ***REMOVED***

static int swap_arrays(PyArrayObject* obj1, PyArrayObject* obj2***REMOVED*** {
    PyArrayObject_fields *arr1 = (PyArrayObject_fields****REMOVED*** obj1,
                         *arr2 = (PyArrayObject_fields****REMOVED*** obj2;
    SWAPTYPE(arr1->data,arr2->data,char****REMOVED***;
    SWAPTYPE(arr1->nd,arr2->nd,int***REMOVED***;
    SWAPTYPE(arr1->dimensions,arr2->dimensions,npy_intp****REMOVED***;
    SWAPTYPE(arr1->strides,arr2->strides,npy_intp****REMOVED***;
    SWAPTYPE(arr1->base,arr2->base,PyObject****REMOVED***;
    SWAPTYPE(arr1->descr,arr2->descr,PyArray_Descr****REMOVED***;
    SWAPTYPE(arr1->flags,arr2->flags,int***REMOVED***;
    /* SWAPTYPE(arr1->weakreflist,arr2->weakreflist,PyObject****REMOVED***; */
    return 0;
***REMOVED***

#define ARRAY_ISCOMPATIBLE(arr,type_num***REMOVED***                                \
    (  (PyArray_ISINTEGER(arr***REMOVED*** && PyTypeNum_ISINTEGER(type_num***REMOVED******REMOVED***        \
       ||(PyArray_ISFLOAT(arr***REMOVED*** && PyTypeNum_ISFLOAT(type_num***REMOVED******REMOVED***          \
       ||(PyArray_ISCOMPLEX(arr***REMOVED*** && PyTypeNum_ISCOMPLEX(type_num***REMOVED******REMOVED***      \
       ||(PyArray_ISBOOL(arr***REMOVED*** && PyTypeNum_ISBOOL(type_num***REMOVED******REMOVED***            \
       ***REMOVED***

extern
PyArrayObject* array_from_pyobj(const int type_num,
                                npy_intp *dims,
                                const int rank,
                                const int intent,
                                PyObject *obj***REMOVED*** {
    /* Note about reference counting
       -----------------------------
       If the caller returns the array to Python, it must be done with
       Py_BuildValue("N",arr***REMOVED***.
       Otherwise, if obj!=arr then the caller must call Py_DECREF(arr***REMOVED***.

       Note on intent(cache,out,..***REMOVED***
       ---------------------
       Don't expect correct data when returning intent(cache***REMOVED*** array.

    */
    char mess[200***REMOVED***;
    PyArrayObject *arr = NULL;
    PyArray_Descr *descr;
    char typechar;
    int elsize;

    if ((intent & F2PY_INTENT_HIDE***REMOVED***
        || ((intent & F2PY_INTENT_CACHE***REMOVED*** && (obj==Py_None***REMOVED******REMOVED***
        || ((intent & F2PY_OPTIONAL***REMOVED*** && (obj==Py_None***REMOVED******REMOVED***
        ***REMOVED*** {
        /* intent(cache***REMOVED***, optional, intent(hide***REMOVED*** */
        if (count_nonpos(rank,dims***REMOVED******REMOVED*** {
            int i;
            strcpy(mess, "failed to create intent(cache|hide***REMOVED***|optional array"
                   "-- must have defined dimensions but got ("***REMOVED***;
            for(i=0;i<rank;++i***REMOVED***
                sprintf(mess+strlen(mess***REMOVED***,"%" NPY_INTP_FMT ",",dims[i***REMOVED******REMOVED***;
            strcat(mess, "***REMOVED***"***REMOVED***;
            PyErr_SetString(PyExc_ValueError,mess***REMOVED***;
            return NULL;
    ***REMOVED***
        arr = (PyArrayObject ****REMOVED***
            PyArray_New(&PyArray_Type, rank, dims, type_num,
                        NULL,NULL,0,
                        !(intent&F2PY_INTENT_C***REMOVED***,
                        NULL***REMOVED***;
        if (arr==NULL***REMOVED*** return NULL;
        if (!(intent & F2PY_INTENT_CACHE***REMOVED******REMOVED***
            PyArray_FILLWBYTE(arr, 0***REMOVED***;
        return arr;
***REMOVED***

    descr = PyArray_DescrFromType(type_num***REMOVED***;
    elsize = descr->elsize;
    typechar = descr->type;
    Py_DECREF(descr***REMOVED***;
    if (PyArray_Check(obj***REMOVED******REMOVED*** {
        arr = (PyArrayObject ****REMOVED***obj;

        if (intent & F2PY_INTENT_CACHE***REMOVED*** {
            /* intent(cache***REMOVED*** */
            if (PyArray_ISONESEGMENT(arr***REMOVED***
                && PyArray_ITEMSIZE(arr***REMOVED***>=elsize***REMOVED*** {
                if (check_and_fix_dimensions(arr,rank,dims***REMOVED******REMOVED*** {
                    return NULL; /*XXX: set exception */
            ***REMOVED***
                if (intent & F2PY_INTENT_OUT***REMOVED***
                    Py_INCREF(arr***REMOVED***;
                return arr;
        ***REMOVED***
            strcpy(mess, "failed to initialize intent(cache***REMOVED*** array"***REMOVED***;
            if (!PyArray_ISONESEGMENT(arr***REMOVED******REMOVED***
                strcat(mess, " -- input must be in one segment"***REMOVED***;
            if (PyArray_ITEMSIZE(arr***REMOVED***<elsize***REMOVED***
                sprintf(mess+strlen(mess***REMOVED***,
                        " -- expected at least elsize=%d but got %" NPY_INTP_FMT,
                        elsize,
                        (npy_intp***REMOVED***PyArray_ITEMSIZE(arr***REMOVED***
                        ***REMOVED***;
            PyErr_SetString(PyExc_ValueError,mess***REMOVED***;
            return NULL;
    ***REMOVED***

        /* here we have always intent(in***REMOVED*** or intent(inout***REMOVED*** or intent(inplace***REMOVED*** */

        if (check_and_fix_dimensions(arr,rank,dims***REMOVED******REMOVED*** {
            return NULL; /*XXX: set exception */
    ***REMOVED***
	/*
	printf("intent alignement=%d\n", F2PY_GET_ALIGNMENT(intent***REMOVED******REMOVED***;
	printf("alignement check=%d\n", F2PY_CHECK_ALIGNMENT(arr, intent***REMOVED******REMOVED***;
	int i;
	for (i=1;i<=16;i++***REMOVED***
	  printf("i=%d isaligned=%d\n", i, ARRAY_ISALIGNED(arr, i***REMOVED******REMOVED***;
	*/
        if ((! (intent & F2PY_INTENT_COPY***REMOVED******REMOVED***
            && PyArray_ITEMSIZE(arr***REMOVED***==elsize
            && ARRAY_ISCOMPATIBLE(arr,type_num***REMOVED***
	    && F2PY_CHECK_ALIGNMENT(arr, intent***REMOVED***
            ***REMOVED*** {
            if ((intent & F2PY_INTENT_C***REMOVED***?PyArray_ISCARRAY(arr***REMOVED***:PyArray_ISFARRAY(arr***REMOVED******REMOVED*** {
                if ((intent & F2PY_INTENT_OUT***REMOVED******REMOVED*** {
                    Py_INCREF(arr***REMOVED***;
            ***REMOVED***
                /* Returning input array */
                return arr;
        ***REMOVED***
    ***REMOVED***

        if (intent & F2PY_INTENT_INOUT***REMOVED*** {
            strcpy(mess, "failed to initialize intent(inout***REMOVED*** array"***REMOVED***;
            if ((intent & F2PY_INTENT_C***REMOVED*** && !PyArray_ISCARRAY(arr***REMOVED******REMOVED***
                strcat(mess, " -- input not contiguous"***REMOVED***;
            if (!(intent & F2PY_INTENT_C***REMOVED*** && !PyArray_ISFARRAY(arr***REMOVED******REMOVED***
                strcat(mess, " -- input not fortran contiguous"***REMOVED***;
            if (PyArray_ITEMSIZE(arr***REMOVED***!=elsize***REMOVED***
                sprintf(mess+strlen(mess***REMOVED***,
                        " -- expected elsize=%d but got %" NPY_INTP_FMT,
                        elsize,
                        (npy_intp***REMOVED***PyArray_ITEMSIZE(arr***REMOVED***
                        ***REMOVED***;
            if (!(ARRAY_ISCOMPATIBLE(arr,type_num***REMOVED******REMOVED******REMOVED***
                sprintf(mess+strlen(mess***REMOVED***," -- input '%c' not compatible to '%c'",
                        PyArray_DESCR(arr***REMOVED***->type,typechar***REMOVED***;
	    if (!(F2PY_CHECK_ALIGNMENT(arr, intent***REMOVED******REMOVED******REMOVED***
	      sprintf(mess+strlen(mess***REMOVED***," -- input not %d-aligned", F2PY_GET_ALIGNMENT(intent***REMOVED******REMOVED***;
            PyErr_SetString(PyExc_ValueError,mess***REMOVED***;
            return NULL;
    ***REMOVED***

        /* here we have always intent(in***REMOVED*** or intent(inplace***REMOVED*** */

    ***REMOVED***
            PyArrayObject *retarr = (PyArrayObject ****REMOVED*** \
                PyArray_New(&PyArray_Type, PyArray_NDIM(arr***REMOVED***, PyArray_DIMS(arr***REMOVED***, type_num,
                            NULL,NULL,0,
                            !(intent&F2PY_INTENT_C***REMOVED***,
                            NULL***REMOVED***;
            if (retarr==NULL***REMOVED***
                return NULL;
            F2PY_REPORT_ON_ARRAY_COPY_FROMARR;
            if (PyArray_CopyInto(retarr, arr***REMOVED******REMOVED*** {
                Py_DECREF(retarr***REMOVED***;
                return NULL;
        ***REMOVED***
            if (intent & F2PY_INTENT_INPLACE***REMOVED*** {
                if (swap_arrays(arr,retarr***REMOVED******REMOVED***
                    return NULL; /* XXX: set exception */
                Py_XDECREF(retarr***REMOVED***;
                if (intent & F2PY_INTENT_OUT***REMOVED***
                    Py_INCREF(arr***REMOVED***;
        ***REMOVED*** else {
                arr = retarr;
        ***REMOVED***
    ***REMOVED***
        return arr;
***REMOVED***

    if ((intent & F2PY_INTENT_INOUT***REMOVED*** ||
            (intent & F2PY_INTENT_INPLACE***REMOVED*** ||
            (intent & F2PY_INTENT_CACHE***REMOVED******REMOVED*** {
        PyErr_SetString(PyExc_TypeError,
                        "failed to initialize intent(inout|inplace|cache***REMOVED*** "
                        "array, input not an array"***REMOVED***;
        return NULL;
***REMOVED***

***REMOVED***
        F2PY_REPORT_ON_ARRAY_COPY_FROMANY;
        arr = (PyArrayObject ****REMOVED*** \
            PyArray_FromAny(obj,PyArray_DescrFromType(type_num***REMOVED***, 0,0,
                            ((intent & F2PY_INTENT_C***REMOVED***?NPY_ARRAY_CARRAY:NPY_ARRAY_FARRAY***REMOVED*** \
                            | NPY_ARRAY_FORCECAST, NULL***REMOVED***;
        if (arr==NULL***REMOVED***
            return NULL;
        if (check_and_fix_dimensions(arr,rank,dims***REMOVED******REMOVED***
            return NULL; /*XXX: set exception */
        return arr;
***REMOVED***

***REMOVED***

/*****************************************/
/* Helper functions for array_from_pyobj */
/*****************************************/

static
int check_and_fix_dimensions(const PyArrayObject* arr,const int rank,npy_intp *dims***REMOVED*** {
    /*
      This function fills in blanks (that are -1\'s***REMOVED*** in dims list using
      the dimensions from arr. It also checks that non-blank dims will
      match with the corresponding values in arr dimensions.
    */
    const npy_intp arr_size = (PyArray_NDIM(arr***REMOVED******REMOVED***?PyArray_Size((PyObject ****REMOVED***arr***REMOVED***:1;
#ifdef DEBUG_COPY_ND_ARRAY
    dump_attrs(arr***REMOVED***;
    printf("check_and_fix_dimensions:init: dims="***REMOVED***;
    dump_dims(rank,dims***REMOVED***;
#endif
    if (rank > PyArray_NDIM(arr***REMOVED******REMOVED*** { /* [1,2***REMOVED*** -> [[1***REMOVED***,[2***REMOVED******REMOVED***; 1 -> [[1***REMOVED******REMOVED***  */
        npy_intp new_size = 1;
        int free_axe = -1;
        int i;
        npy_intp d;
        /* Fill dims where -1 or 0; check dimensions; calc new_size; */
        for(i=0;i<PyArray_NDIM(arr***REMOVED***;++i***REMOVED*** {
            d = PyArray_DIM(arr,i***REMOVED***;
            if (dims[i***REMOVED*** >= 0***REMOVED*** {
                if (d>1 && dims[i***REMOVED***!=d***REMOVED*** {
                    fprintf(stderr,"%d-th dimension must be fixed to %" NPY_INTP_FMT
                            " but got %" NPY_INTP_FMT "\n",
                            i,dims[i***REMOVED***, d***REMOVED***;
                    return 1;
            ***REMOVED***
                if (!dims[i***REMOVED******REMOVED*** dims[i***REMOVED*** = 1;
        ***REMOVED*** else {
                dims[i***REMOVED*** = d ? d : 1;
        ***REMOVED***
            new_size *= dims[i***REMOVED***;
    ***REMOVED***
        for(i=PyArray_NDIM(arr***REMOVED***;i<rank;++i***REMOVED***
            if (dims[i***REMOVED***>1***REMOVED*** {
                fprintf(stderr,"%d-th dimension must be %" NPY_INTP_FMT
                        " but got 0 (not defined***REMOVED***.\n",
                        i,dims[i***REMOVED******REMOVED***;
                return 1;
        ***REMOVED*** else if (free_axe<0***REMOVED***
                free_axe = i;
            else
                dims[i***REMOVED*** = 1;
        if (free_axe>=0***REMOVED*** {
            dims[free_axe***REMOVED*** = arr_size/new_size;
            new_size *= dims[free_axe***REMOVED***;
    ***REMOVED***
        if (new_size != arr_size***REMOVED*** {
            fprintf(stderr,"unexpected array size: new_size=%" NPY_INTP_FMT
                    ", got array with arr_size=%" NPY_INTP_FMT " (maybe too many free"
                    " indices***REMOVED***\n", new_size,arr_size***REMOVED***;
            return 1;
    ***REMOVED***
***REMOVED*** else if (rank==PyArray_NDIM(arr***REMOVED******REMOVED*** {
        npy_intp new_size = 1;
        int i;
        npy_intp d;
        for (i=0; i<rank; ++i***REMOVED*** {
	    d = PyArray_DIM(arr,i***REMOVED***;
            if (dims[i***REMOVED***>=0***REMOVED*** {
                if (d > 1 && d!=dims[i***REMOVED******REMOVED*** {
                    fprintf(stderr,"%d-th dimension must be fixed to %" NPY_INTP_FMT
                            " but got %" NPY_INTP_FMT "\n",
                            i,dims[i***REMOVED***,d***REMOVED***;
                    return 1;
            ***REMOVED***
                if (!dims[i***REMOVED******REMOVED*** dims[i***REMOVED*** = 1;
        ***REMOVED*** else dims[i***REMOVED*** = d;
            new_size *= dims[i***REMOVED***;
    ***REMOVED***
        if (new_size != arr_size***REMOVED*** {
            fprintf(stderr,"unexpected array size: new_size=%" NPY_INTP_FMT
                    ", got array with arr_size=%" NPY_INTP_FMT "\n", new_size,arr_size***REMOVED***;
            return 1;
    ***REMOVED***
***REMOVED*** else { /* [[1,2***REMOVED******REMOVED*** -> [[1***REMOVED***,[2***REMOVED******REMOVED*** */
        int i,j;
        npy_intp d;
        int effrank;
        npy_intp size;
        for (i=0,effrank=0;i<PyArray_NDIM(arr***REMOVED***;++i***REMOVED***
            if (PyArray_DIM(arr,i***REMOVED***>1***REMOVED*** ++effrank;
        if (dims[rank-1***REMOVED***>=0***REMOVED***
            if (effrank>rank***REMOVED*** {
                fprintf(stderr,"too many axes: %d (effrank=%d***REMOVED***, expected rank=%d\n",
                        PyArray_NDIM(arr***REMOVED***,effrank,rank***REMOVED***;
                return 1;
        ***REMOVED***

        for (i=0,j=0;i<rank;++i***REMOVED*** {
            while (j<PyArray_NDIM(arr***REMOVED*** && PyArray_DIM(arr,j***REMOVED***<2***REMOVED*** ++j;
            if (j>=PyArray_NDIM(arr***REMOVED******REMOVED*** d = 1;
            else d = PyArray_DIM(arr,j++***REMOVED***;
            if (dims[i***REMOVED***>=0***REMOVED*** {
                if (d>1 && d!=dims[i***REMOVED******REMOVED*** {
                    fprintf(stderr,"%d-th dimension must be fixed to %" NPY_INTP_FMT
                            " but got %" NPY_INTP_FMT " (real index=%d***REMOVED***\n",
                            i,dims[i***REMOVED***,d,j-1***REMOVED***;
                    return 1;
            ***REMOVED***
                if (!dims[i***REMOVED******REMOVED*** dims[i***REMOVED*** = 1;
        ***REMOVED*** else
                dims[i***REMOVED*** = d;
    ***REMOVED***

        for (i=rank;i<PyArray_NDIM(arr***REMOVED***;++i***REMOVED*** { /* [[1,2***REMOVED***,[3,4***REMOVED******REMOVED*** -> [1,2,3,4***REMOVED*** */
            while (j<PyArray_NDIM(arr***REMOVED*** && PyArray_DIM(arr,j***REMOVED***<2***REMOVED*** ++j;
            if (j>=PyArray_NDIM(arr***REMOVED******REMOVED*** d = 1;
            else d = PyArray_DIM(arr,j++***REMOVED***;
            dims[rank-1***REMOVED*** *= d;
    ***REMOVED***
        for (i=0,size=1;i<rank;++i***REMOVED*** size *= dims[i***REMOVED***;
        if (size != arr_size***REMOVED*** {
            fprintf(stderr,"unexpected array size: size=%" NPY_INTP_FMT ", arr_size=%" NPY_INTP_FMT
                    ", rank=%d, effrank=%d, arr.nd=%d, dims=[",
                    size,arr_size,rank,effrank,PyArray_NDIM(arr***REMOVED******REMOVED***;
            for (i=0;i<rank;++i***REMOVED*** fprintf(stderr," %" NPY_INTP_FMT,dims[i***REMOVED******REMOVED***;
            fprintf(stderr," ***REMOVED***, arr.dims=["***REMOVED***;
            for (i=0;i<PyArray_NDIM(arr***REMOVED***;++i***REMOVED*** fprintf(stderr," %" NPY_INTP_FMT,PyArray_DIM(arr,i***REMOVED******REMOVED***;
            fprintf(stderr," ***REMOVED***\n"***REMOVED***;
            return 1;
    ***REMOVED***
***REMOVED***
#ifdef DEBUG_COPY_ND_ARRAY
    printf("check_and_fix_dimensions:end: dims="***REMOVED***;
    dump_dims(rank,dims***REMOVED***;
#endif
    return 0;
***REMOVED***

/* End of file: array_from_pyobj.c */

/************************* copy_ND_array *******************************/

extern
int copy_ND_array(const PyArrayObject *arr, PyArrayObject *out***REMOVED***
{
    F2PY_REPORT_ON_ARRAY_COPY_FROMARR;
    return PyArray_CopyInto(out, (PyArrayObject ****REMOVED***arr***REMOVED***;
***REMOVED***

/*********************************************/
/* Compatibility functions for Python >= 3.0 */
/*********************************************/

#if PY_VERSION_HEX >= 0x03000000

PyObject *
F2PyCapsule_FromVoidPtr(void *ptr, void (*dtor***REMOVED***(PyObject ****REMOVED******REMOVED***
{
    PyObject *ret = PyCapsule_New(ptr, NULL, dtor***REMOVED***;
    if (ret == NULL***REMOVED*** {
        PyErr_Clear(***REMOVED***;
***REMOVED***
    return ret;
***REMOVED***

void *
F2PyCapsule_AsVoidPtr(PyObject *obj***REMOVED***
{
    void *ret = PyCapsule_GetPointer(obj, NULL***REMOVED***;
    if (ret == NULL***REMOVED*** {
        PyErr_Clear(***REMOVED***;
***REMOVED***
    return ret;
***REMOVED***

int
F2PyCapsule_Check(PyObject *ptr***REMOVED***
{
    return PyCapsule_CheckExact(ptr***REMOVED***;
***REMOVED***

#else

PyObject *
F2PyCapsule_FromVoidPtr(void *ptr, void (*dtor***REMOVED***(void ****REMOVED******REMOVED***
{
    return PyCObject_FromVoidPtr(ptr, dtor***REMOVED***;
***REMOVED***

void *
F2PyCapsule_AsVoidPtr(PyObject *ptr***REMOVED***
{
    return PyCObject_AsVoidPtr(ptr***REMOVED***;
***REMOVED***

int
F2PyCapsule_Check(PyObject *ptr***REMOVED***
{
    return PyCObject_Check(ptr***REMOVED***;
***REMOVED***

#endif


#ifdef __cplusplus
***REMOVED***
#endif
/************************* EOF fortranobject.c *******************************/
