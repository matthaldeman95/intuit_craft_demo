from __future__ import division, absolute_import, print_function

import warnings
import sys
import collections
import operator

import numpy as np
import numpy.core.numeric as _nx
from numpy.core import linspace, atleast_1d, atleast_2d
from numpy.core.numeric import (
    ones, zeros, arange, concatenate, array, asarray, asanyarray, empty,
    empty_like, ndarray, around, floor, ceil, take, dot, where, intp,
    integer, isscalar
    ***REMOVED***
from numpy.core.umath import (
    pi, multiply, add, arctan2, frompyfunc, cos, less_equal, sqrt, sin,
    mod, exp, log10
    ***REMOVED***
from numpy.core.fromnumeric import (
    ravel, nonzero, sort, partition, mean, any, sum
    ***REMOVED***
from numpy.core.numerictypes import typecodes, number
from numpy.lib.twodim_base import diag
from .utils import deprecate
from numpy.core.multiarray import _insert, add_docstring
from numpy.core.multiarray import digitize, bincount, interp as compiled_interp
from numpy.core.umath import _add_newdoc_ufunc as add_newdoc_ufunc
from numpy.compat import long
from numpy.compat.py3k import basestring

# Force range to be a generator, for np.delete's usage.
if sys.version_info[0***REMOVED*** < 3:
    range = xrange


__all__ = [
    'select', 'piecewise', 'trim_zeros', 'copy', 'iterable', 'percentile',
    'diff', 'gradient', 'angle', 'unwrap', 'sort_complex', 'disp',
    'extract', 'place', 'vectorize', 'asarray_chkfinite', 'average',
    'histogram', 'histogramdd', 'bincount', 'digitize', 'cov', 'corrcoef',
    'msort', 'median', 'sinc', 'hamming', 'hanning', 'bartlett',
    'blackman', 'kaiser', 'trapz', 'i0', 'add_newdoc', 'add_docstring',
    'meshgrid', 'delete', 'insert', 'append', 'interp', 'add_newdoc_ufunc'
    ***REMOVED***


def iterable(y***REMOVED***:
    ***REMOVED***
    Check whether or not an object can be iterated over.

    Parameters
    ----------
    y : object
      Input object.

    Returns
    -------
    b : {0, 1***REMOVED***
      Return 1 if the object has an iterator method or is a sequence,
      and 0 otherwise.


    Examples
    --------
    >>> np.iterable([1, 2, 3***REMOVED******REMOVED***
    1
    >>> np.iterable(2***REMOVED***
    0

    ***REMOVED***
    ***REMOVED***
        iter(y***REMOVED***
    ***REMOVED***
        return 0
    return 1


def _hist_bin_sqrt(x***REMOVED***:
    ***REMOVED***
    Square root histogram bin estimator.

    Bin width is inversely proportional to the data size. Used by many
    programs for its simplicity.

    Parameters
    ----------
    x : array_like
        Input data that is to be histogrammed, trimmed to range. May not
        be empty.

    Returns
    -------
    h : An estimate of the optimal bin width for the given data.
    ***REMOVED***
    return x.ptp(***REMOVED*** / np.sqrt(x.size***REMOVED***


def _hist_bin_sturges(x***REMOVED***:
    ***REMOVED***
    Sturges histogram bin estimator.

    A very simplistic estimator based on the assumption of normality of
    the data. This estimator has poor performance for non-normal data,
    which becomes especially obvious for large data sets. The estimate
    depends only on size of the data.

    Parameters
    ----------
    x : array_like
        Input data that is to be histogrammed, trimmed to range. May not
        be empty.

    Returns
    -------
    h : An estimate of the optimal bin width for the given data.
    ***REMOVED***
    return x.ptp(***REMOVED*** / (np.log2(x.size***REMOVED*** + 1.0***REMOVED***


def _hist_bin_rice(x***REMOVED***:
    ***REMOVED***
    Rice histogram bin estimator.

    Another simple estimator with no normality assumption. It has better
    performance for large data than Sturges, but tends to overestimate
    the number of bins. The number of bins is proportional to the cube
    root of data size (asymptotically optimal***REMOVED***. The estimate depends
    only on size of the data.

    Parameters
    ----------
    x : array_like
        Input data that is to be histogrammed, trimmed to range. May not
        be empty.

    Returns
    -------
    h : An estimate of the optimal bin width for the given data.
    ***REMOVED***
    return x.ptp(***REMOVED*** / (2.0 * x.size ** (1.0 / 3***REMOVED******REMOVED***


def _hist_bin_scott(x***REMOVED***:
    ***REMOVED***
    Scott histogram bin estimator.

    The binwidth is proportional to the standard deviation of the data
    and inversely proportional to the cube root of data size
    (asymptotically optimal***REMOVED***.

    Parameters
    ----------
    x : array_like
        Input data that is to be histogrammed, trimmed to range. May not
        be empty.

    Returns
    -------
    h : An estimate of the optimal bin width for the given data.
    ***REMOVED***
    return (24.0 * np.pi**0.5 / x.size***REMOVED*****(1.0 / 3.0***REMOVED*** * np.std(x***REMOVED***


def _hist_bin_doane(x***REMOVED***:
    ***REMOVED***
    Doane's histogram bin estimator.

    Improved version of Sturges' formula which works better for
    non-normal data. See
    http://stats.stackexchange.com/questions/55134/doanes-formula-for-histogram-binning

    Parameters
    ----------
    x : array_like
        Input data that is to be histogrammed, trimmed to range. May not
        be empty.

    Returns
    -------
    h : An estimate of the optimal bin width for the given data.
    ***REMOVED***
    if x.size > 2:
        sg1 = np.sqrt(6.0 * (x.size - 2***REMOVED*** / ((x.size + 1.0***REMOVED*** * (x.size + 3***REMOVED******REMOVED******REMOVED***
        sigma = np.std(x***REMOVED***
        if sigma > 0.0:
            # These three operations add up to
            # g1 = np.mean(((x - np.mean(x***REMOVED******REMOVED*** / sigma***REMOVED*****3***REMOVED***
            # but use only one temp array instead of three
            temp = x - np.mean(x***REMOVED***
            np.true_divide(temp, sigma, temp***REMOVED***
            np.power(temp, 3, temp***REMOVED***
            g1 = np.mean(temp***REMOVED***
            return x.ptp(***REMOVED*** / (1.0 + np.log2(x.size***REMOVED*** +
                                    np.log2(1.0 + np.absolute(g1***REMOVED*** / sg1***REMOVED******REMOVED***
    return 0.0


def _hist_bin_fd(x***REMOVED***:
    ***REMOVED***
    The Freedman-Diaconis histogram bin estimator.

    The Freedman-Diaconis rule uses interquartile range (IQR***REMOVED*** to
    estimate binwidth. It is considered a variation of the Scott rule
    with more robustness as the IQR is less affected by outliers than
    the standard deviation. However, the IQR depends on fewer points
    than the standard deviation, so it is less accurate, especially for
    long tailed distributions.

    If the IQR is 0, this function returns 1 for the number of bins.
    Binwidth is inversely proportional to the cube root of data size
    (asymptotically optimal***REMOVED***.

    Parameters
    ----------
    x : array_like
        Input data that is to be histogrammed, trimmed to range. May not
        be empty.

    Returns
    -------
    h : An estimate of the optimal bin width for the given data.
    ***REMOVED***
    iqr = np.subtract(*np.percentile(x, [75, 25***REMOVED******REMOVED******REMOVED***
    return 2.0 * iqr * x.size ** (-1.0 / 3.0***REMOVED***


def _hist_bin_auto(x***REMOVED***:
    ***REMOVED***
    Histogram bin estimator that uses the minimum width of the
    Freedman-Diaconis and Sturges estimators.

    The FD estimator is usually the most robust method, but its width
    estimate tends to be too large for small `x`. The Sturges estimator
    is quite good for small (<1000***REMOVED*** datasets and is the default in the R
    language. This method gives good off the shelf behaviour.

    Parameters
    ----------
    x : array_like
        Input data that is to be histogrammed, trimmed to range. May not
        be empty.

    Returns
    -------
    h : An estimate of the optimal bin width for the given data.

    See Also
    --------
    _hist_bin_fd, _hist_bin_sturges
    ***REMOVED***
    # There is no need to check for zero here. If ptp is, so is IQR and
    # vice versa. Either both are zero or neither one is.
    return min(_hist_bin_fd(x***REMOVED***, _hist_bin_sturges(x***REMOVED******REMOVED***


# Private dict initialized at module load time
_hist_bin_selectors = {'auto': _hist_bin_auto,
                       'doane': _hist_bin_doane,
                       'fd': _hist_bin_fd,
                       'rice': _hist_bin_rice,
                       'scott': _hist_bin_scott,
                       'sqrt': _hist_bin_sqrt,
                       'sturges': _hist_bin_sturges***REMOVED***


def histogram(a, bins=10, range=None, normed=False, weights=None,
              density=None***REMOVED***:
    r***REMOVED***
    Compute the histogram of a set of data.

    Parameters
    ----------
    a : array_like
        Input data. The histogram is computed over the flattened array.
    bins : int or sequence of scalars or str, optional
        If `bins` is an int, it defines the number of equal-width
        bins in the given range (10, by default***REMOVED***. If `bins` is a
        sequence, it defines the bin edges, including the rightmost
        edge, allowing for non-uniform bin widths.

        .. versionadded:: 1.11.0

        If `bins` is a string from the list below, `histogram` will use
        the method chosen to calculate the optimal bin width and
        consequently the number of bins (see `Notes` for more detail on
        the estimators***REMOVED*** from the data that falls within the requested
        range. While the bin width will be optimal for the actual data
        in the range, the number of bins will be computed to fill the
        entire range, including the empty portions. For visualisation,
        using the 'auto' option is suggested. Weighted data is not
        supported for automated bin size selection.

        'auto'
            Maximum of the 'sturges' and 'fd' estimators. Provides good
            all round performance

        'fd' (Freedman Diaconis Estimator***REMOVED***
            Robust (resilient to outliers***REMOVED*** estimator that takes into
            account data variability and data size .

        'doane'
            An improved version of Sturges' estimator that works better
            with non-normal datasets.

        'scott'
            Less robust estimator that that takes into account data
            variability and data size.

        'rice'
            Estimator does not take variability into account, only data
            size. Commonly overestimates number of bins required.

        'sturges'
            R's default method, only accounts for data size. Only
            optimal for gaussian data and underestimates number of bins
            for large non-gaussian datasets.

        'sqrt'
            Square root (of data size***REMOVED*** estimator, used by Excel and
            other programs for its speed and simplicity.

    range : (float, float***REMOVED***, optional
        The lower and upper range of the bins.  If not provided, range
        is simply ``(a.min(***REMOVED***, a.max(***REMOVED******REMOVED***``.  Values outside the range are
        ignored. The first element of the range must be less than or
        equal to the second. `range` affects the automatic bin
        computation as well. While bin width is computed to be optimal
        based on the actual data within `range`, the bin count will fill
        the entire range including portions containing no data.
    normed : bool, optional
        This keyword is deprecated in Numpy 1.6 due to confusing/buggy
        behavior. It will be removed in Numpy 2.0. Use the ``density``
        keyword instead. If ``False``, the result will contain the
        number of samples in each bin. If ``True``, the result is the
        value of the probability *density* function at the bin,
        normalized such that the *integral* over the range is 1. Note
        that this latter behavior is known to be buggy with unequal bin
        widths; use ``density`` instead.
    weights : array_like, optional
        An array of weights, of the same shape as `a`.  Each value in
        `a` only contributes its associated weight towards the bin count
        (instead of 1***REMOVED***. If `density` is True, the weights are
        normalized, so that the integral of the density over the range
        remains 1.
    density : bool, optional
        If ``False``, the result will contain the number of samples in
        each bin. If ``True``, the result is the value of the
        probability *density* function at the bin, normalized such that
        the *integral* over the range is 1. Note that the sum of the
        histogram values will not be equal to 1 unless bins of unity
        width are chosen; it is not a probability *mass* function.

        Overrides the ``normed`` keyword if given.

    Returns
    -------
    hist : array
        The values of the histogram. See `density` and `weights` for a
        description of the possible semantics.
    bin_edges : array of dtype float
        Return the bin edges ``(length(hist***REMOVED***+1***REMOVED***``.


    See Also
    --------
    histogramdd, bincount, searchsorted, digitize

    Notes
    -----
    All but the last (righthand-most***REMOVED*** bin is half-open.  In other words,
    if `bins` is::

      [1, 2, 3, 4***REMOVED***

    then the first bin is ``[1, 2***REMOVED***`` (including 1, but excluding 2***REMOVED*** and
    the second ``[2, 3***REMOVED***``.  The last bin, however, is ``[3, 4***REMOVED***``, which
    *includes* 4.

    .. versionadded:: 1.11.0

    The methods to estimate the optimal number of bins are well founded
    in literature, and are inspired by the choices R provides for
    histogram visualisation. Note that having the number of bins
    proportional to :math:`n^{1/3***REMOVED***` is asymptotically optimal, which is
    why it appears in most estimators. These are simply plug-in methods
    that give good starting points for number of bins. In the equations
    below, :math:`h` is the binwidth and :math:`n_h` is the number of
    bins. All estimators that compute bin counts are recast to bin width
    using the `ptp` of the data. The final bin count is obtained from
    ``np.round(np.ceil(range / h***REMOVED******REMOVED***`.

    'Auto' (maximum of the 'Sturges' and 'FD' estimators***REMOVED***
        A compromise to get a good value. For small datasets the Sturges
        value will usually be chosen, while larger datasets will usually
        default to FD.  Avoids the overly conservative behaviour of FD
        and Sturges for small and large datasets respectively.
        Switchover point is usually :math:`a.size \approx 1000`.

    'FD' (Freedman Diaconis Estimator***REMOVED***
        .. math:: h = 2 \frac{IQR***REMOVED***{n^{1/3***REMOVED******REMOVED***

        The binwidth is proportional to the interquartile range (IQR***REMOVED***
        and inversely proportional to cube root of a.size. Can be too
        conservative for small datasets, but is quite good for large
        datasets. The IQR is very robust to outliers.

    'Scott'
        .. math:: h = \sigma \sqrt[3***REMOVED***{\frac{24 * \sqrt{\pi***REMOVED******REMOVED***{n***REMOVED******REMOVED***

        The binwidth is proportional to the standard deviation of the
        data and inversely proportional to cube root of ``x.size``. Can
        be too conservative for small datasets, but is quite good for
        large datasets. The standard deviation is not very robust to
        outliers. Values are very similar to the Freedman-Diaconis
        estimator in the absence of outliers.

    'Rice'
        .. math:: n_h = 2n^{1/3***REMOVED***

        The number of bins is only proportional to cube root of
        ``a.size``. It tends to overestimate the number of bins and it
        does not take into account data variability.

    'Sturges'
        .. math:: n_h = \log _{2***REMOVED***n+1

        The number of bins is the base 2 log of ``a.size``.  This
        estimator assumes normality of data and is too conservative for
        larger, non-normal datasets. This is the default method in R's
        ``hist`` method.

    'Doane'
        .. math:: n_h = 1 + \log_{2***REMOVED***(n***REMOVED*** +
                        \log_{2***REMOVED***(1 + \frac{|g_1|***REMOVED***{\sigma_{g_1***REMOVED******REMOVED******REMOVED***

            g_1 = mean[(\frac{x - \mu***REMOVED***{\sigma***REMOVED******REMOVED***^3***REMOVED***

            \sigma_{g_1***REMOVED*** = \sqrt{\frac{6(n - 2***REMOVED******REMOVED***{(n + 1***REMOVED***(n + 3***REMOVED******REMOVED******REMOVED***

        An improved version of Sturges' formula that produces better
        estimates for non-normal datasets. This estimator attempts to
        account for the skew of the data.

    'Sqrt'
        .. math:: n_h = \sqrt n
        The simplest and fastest estimator. Only takes into account the
        data size.

    Examples
    --------
    >>> np.histogram([1, 2, 1***REMOVED***, bins=[0, 1, 2, 3***REMOVED******REMOVED***
    (array([0, 2, 1***REMOVED******REMOVED***, array([0, 1, 2, 3***REMOVED******REMOVED******REMOVED***
    >>> np.histogram(np.arange(4***REMOVED***, bins=np.arange(5***REMOVED***, density=True***REMOVED***
    (array([ 0.25,  0.25,  0.25,  0.25***REMOVED******REMOVED***, array([0, 1, 2, 3, 4***REMOVED******REMOVED******REMOVED***
    >>> np.histogram([[1, 2, 1***REMOVED***, [1, 0, 1***REMOVED******REMOVED***, bins=[0,1,2,3***REMOVED******REMOVED***
    (array([1, 4, 1***REMOVED******REMOVED***, array([0, 1, 2, 3***REMOVED******REMOVED******REMOVED***

    >>> a = np.arange(5***REMOVED***
    >>> hist, bin_edges = np.histogram(a, density=True***REMOVED***
    >>> hist
    array([ 0.5,  0. ,  0.5,  0. ,  0. ,  0.5,  0. ,  0.5,  0. ,  0.5***REMOVED******REMOVED***
    >>> hist.sum(***REMOVED***
    2.4999999999999996
    >>> np.sum(hist*np.diff(bin_edges***REMOVED******REMOVED***
    1.0

    .. versionadded:: 1.11.0

    Automated Bin Selection Methods example, using 2 peak random data
    with 2000 points:

    >>> import matplotlib.pyplot as plt
    >>> rng = np.random.RandomState(10***REMOVED***  # deterministic random data
    >>> a = np.hstack((rng.normal(size=1000***REMOVED***,
    ...                rng.normal(loc=5, scale=2, size=1000***REMOVED******REMOVED******REMOVED***
    >>> plt.hist(a, bins='auto'***REMOVED***  # plt.hist passes it's arguments to np.histogram
    >>> plt.title("Histogram with 'auto' bins"***REMOVED***
    >>> plt.show(***REMOVED***

    ***REMOVED***
    a = asarray(a***REMOVED***
    if weights is not None:
        weights = asarray(weights***REMOVED***
        if np.any(weights.shape != a.shape***REMOVED***:
            raise ValueError(
                'weights should have the same shape as a.'***REMOVED***
        weights = weights.ravel(***REMOVED***
    a = a.ravel(***REMOVED***

    # Do not modify the original value of range so we can check for `None`
    if range is None:
        if a.size == 0:
            # handle empty arrays. Can't determine range, so use 0-1.
            mn, mx = 0.0, 1.0
        else:
            mn, mx = a.min(***REMOVED*** + 0.0, a.max(***REMOVED*** + 0.0
    else:
        mn, mx = [mi + 0.0 for mi in range***REMOVED***
    if mn > mx:
        raise ValueError(
            'max must be larger than min in range parameter.'***REMOVED***
    if not np.all(np.isfinite([mn, mx***REMOVED******REMOVED******REMOVED***:
        raise ValueError(
            'range parameter must be finite.'***REMOVED***
    if mn == mx:
        mn -= 0.5
        mx += 0.5

    if isinstance(bins, basestring***REMOVED***:
        # if `bins` is a string for an automatic method,
        # this will replace it with the number of bins calculated
        if bins not in _hist_bin_selectors:
            raise ValueError("{0***REMOVED*** not a valid estimator for bins".format(bins***REMOVED******REMOVED***
        if weights is not None:
            raise TypeError("Automated estimation of the number of "
                            "bins is not supported for weighted data"***REMOVED***
        # Make a reference to `a`
        b = a
        # Update the reference if the range needs truncation
        if range is not None:
            keep = (a >= mn***REMOVED***
            keep &= (a <= mx***REMOVED***
            if not np.logical_and.reduce(keep***REMOVED***:
                b = a[keep***REMOVED***

        if b.size == 0:
            bins = 1
        else:
            # Do not call selectors on empty arrays
            width = _hist_bin_selectors[bins***REMOVED***(b***REMOVED***
            if width:
                bins = int(np.ceil((mx - mn***REMOVED*** / width***REMOVED******REMOVED***
            else:
                # Width can be zero for some estimators, e.g. FD when
                # the IQR of the data is zero.
                bins = 1

    # Histogram is an integer or a float array depending on the weights.
    if weights is None:
        ntype = np.dtype(np.intp***REMOVED***
    else:
        ntype = weights.dtype

    # We set a block size, as this allows us to iterate over chunks when
    # computing histograms, to minimize memory usage.
    BLOCK = 65536

    if not iterable(bins***REMOVED***:
        if np.isscalar(bins***REMOVED*** and bins < 1:
            raise ValueError(
                '`bins` should be a positive integer.'***REMOVED***
        # At this point, if the weights are not integer, floating point, or
        # complex, we have to use the slow algorithm.
        if weights is not None and not (np.can_cast(weights.dtype, np.double***REMOVED*** or
                                        np.can_cast(weights.dtype, np.complex***REMOVED******REMOVED***:
            bins = linspace(mn, mx, bins + 1, endpoint=True***REMOVED***

    if not iterable(bins***REMOVED***:
        # We now convert values of a to bin indices, under the assumption of
        # equal bin widths (which is valid here***REMOVED***.

        # Initialize empty histogram
        n = np.zeros(bins, ntype***REMOVED***
        # Pre-compute histogram scaling factor
        norm = bins / (mx - mn***REMOVED***

        # Compute the bin edges for potential correction.
        bin_edges = linspace(mn, mx, bins + 1, endpoint=True***REMOVED***

        # We iterate over blocks here for two reasons: the first is that for
        # large arrays, it is actually faster (for example for a 10^8 array it
        # is 2x as fast***REMOVED*** and it results in a memory footprint 3x lower in the
        # limit of large arrays.
        for i in arange(0, len(a***REMOVED***, BLOCK***REMOVED***:
            tmp_a = a[i:i+BLOCK***REMOVED***
            if weights is None:
                tmp_w = None
            else:
                tmp_w = weights[i:i + BLOCK***REMOVED***

            # Only include values in the right range
            keep = (tmp_a >= mn***REMOVED***
            keep &= (tmp_a <= mx***REMOVED***
            if not np.logical_and.reduce(keep***REMOVED***:
                tmp_a = tmp_a[keep***REMOVED***
                if tmp_w is not None:
                    tmp_w = tmp_w[keep***REMOVED***
            tmp_a_data = tmp_a.astype(float***REMOVED***
            tmp_a = tmp_a_data - mn
            tmp_a *= norm

            # Compute the bin indices, and for values that lie exactly on mx we
            # need to subtract one
            indices = tmp_a.astype(np.intp***REMOVED***
            indices[indices == bins***REMOVED*** -= 1

            # The index computation is not guaranteed to give exactly
            # consistent results within ~1 ULP of the bin edges.
            decrement = tmp_a_data < bin_edges[indices***REMOVED***
            indices[decrement***REMOVED*** -= 1
            # The last bin includes the right edge. The other bins do not.
            increment = (tmp_a_data >= bin_edges[indices + 1***REMOVED******REMOVED*** & (indices != bins - 1***REMOVED***
            indices[increment***REMOVED*** += 1

            # We now compute the histogram using bincount
            if ntype.kind == 'c':
                n.real += np.bincount(indices, weights=tmp_w.real, minlength=bins***REMOVED***
                n.imag += np.bincount(indices, weights=tmp_w.imag, minlength=bins***REMOVED***
            else:
                n += np.bincount(indices, weights=tmp_w, minlength=bins***REMOVED***.astype(ntype***REMOVED***

        # Rename the bin edges for return.
        bins = bin_edges
    else:
        bins = asarray(bins***REMOVED***
        if (np.diff(bins***REMOVED*** < 0***REMOVED***.any(***REMOVED***:
            raise ValueError(
                'bins must increase monotonically.'***REMOVED***

        # Initialize empty histogram
        n = np.zeros(bins.shape, ntype***REMOVED***

        if weights is None:
            for i in arange(0, len(a***REMOVED***, BLOCK***REMOVED***:
                sa = sort(a[i:i+BLOCK***REMOVED******REMOVED***
                n += np.r_[sa.searchsorted(bins[:-1***REMOVED***, 'left'***REMOVED***,
                           sa.searchsorted(bins[-1***REMOVED***, 'right'***REMOVED******REMOVED***
        else:
            zero = array(0, dtype=ntype***REMOVED***
            for i in arange(0, len(a***REMOVED***, BLOCK***REMOVED***:
                tmp_a = a[i:i+BLOCK***REMOVED***
                tmp_w = weights[i:i+BLOCK***REMOVED***
                sorting_index = np.argsort(tmp_a***REMOVED***
                sa = tmp_a[sorting_index***REMOVED***
                sw = tmp_w[sorting_index***REMOVED***
                cw = np.concatenate(([zero, ***REMOVED***, sw.cumsum(***REMOVED******REMOVED******REMOVED***
                bin_index = np.r_[sa.searchsorted(bins[:-1***REMOVED***, 'left'***REMOVED***,
                                  sa.searchsorted(bins[-1***REMOVED***, 'right'***REMOVED******REMOVED***
                n += cw[bin_index***REMOVED***


        n = np.diff(n***REMOVED***

    if density is not None:
        if density:
            db = array(np.diff(bins***REMOVED***, float***REMOVED***
            return n/db/n.sum(***REMOVED***, bins
        else:
            return n, bins
    else:
        # deprecated, buggy behavior. Remove for Numpy 2.0
        if normed:
            db = array(np.diff(bins***REMOVED***, float***REMOVED***
            return n/(n*db***REMOVED***.sum(***REMOVED***, bins
        else:
            return n, bins


def histogramdd(sample, bins=10, range=None, normed=False, weights=None***REMOVED***:
    ***REMOVED***
    Compute the multidimensional histogram of some data.

    Parameters
    ----------
    sample : array_like
        The data to be histogrammed. It must be an (N,D***REMOVED*** array or data
        that can be converted to such. The rows of the resulting array
        are the coordinates of points in a D dimensional polytope.
    bins : sequence or int, optional
        The bin specification:

        * A sequence of arrays describing the bin edges along each dimension.
        * The number of bins for each dimension (nx, ny, ... =bins***REMOVED***
        * The number of bins for all dimensions (nx=ny=...=bins***REMOVED***.

    range : sequence, optional
        A sequence of lower and upper bin edges to be used if the edges are
        not given explicitly in `bins`. Defaults to the minimum and maximum
        values along each dimension.
    normed : bool, optional
        If False, returns the number of samples in each bin. If True,
        returns the bin density ``bin_count / sample_count / bin_volume``.
    weights : (N,***REMOVED*** array_like, optional
        An array of values `w_i` weighing each sample `(x_i, y_i, z_i, ...***REMOVED***`.
        Weights are normalized to 1 if normed is True. If normed is False,
        the values of the returned histogram are equal to the sum of the
        weights belonging to the samples falling into each bin.

    Returns
    -------
    H : ndarray
        The multidimensional histogram of sample x. See normed and weights
        for the different possible semantics.
    edges : list
        A list of D arrays describing the bin edges for each dimension.

    See Also
    --------
    histogram: 1-D histogram
    histogram2d: 2-D histogram

    Examples
    --------
    >>> r = np.random.randn(100,3***REMOVED***
    >>> H, edges = np.histogramdd(r, bins = (5, 8, 4***REMOVED******REMOVED***
    >>> H.shape, edges[0***REMOVED***.size, edges[1***REMOVED***.size, edges[2***REMOVED***.size
    ((5, 8, 4***REMOVED***, 6, 9, 5***REMOVED***

    ***REMOVED***

    ***REMOVED***
        # Sample is an ND-array.
        N, D = sample.shape
    except (AttributeError, ValueError***REMOVED***:
        # Sample is a sequence of 1D arrays.
        sample = atleast_2d(sample***REMOVED***.T
        N, D = sample.shape

    nbin = empty(D, int***REMOVED***
    edges = D*[None***REMOVED***
    dedges = D*[None***REMOVED***
    if weights is not None:
        weights = asarray(weights***REMOVED***

    ***REMOVED***
        M = len(bins***REMOVED***
        if M != D:
            raise ValueError(
                'The dimension of bins must be equal to the dimension of the '
                ' sample x.'***REMOVED***
    except TypeError:
        # bins is an integer
        bins = D*[bins***REMOVED***

    # Select range for each dimension
    # Used only if number of bins is given.
    if range is None:
        # Handle empty input. Range can't be determined in that case, use 0-1.
        if N == 0:
            smin = zeros(D***REMOVED***
            smax = ones(D***REMOVED***
        else:
            smin = atleast_1d(array(sample.min(0***REMOVED***, float***REMOVED******REMOVED***
            smax = atleast_1d(array(sample.max(0***REMOVED***, float***REMOVED******REMOVED***
    else:
        if not np.all(np.isfinite(range***REMOVED******REMOVED***:
            raise ValueError(
                'range parameter must be finite.'***REMOVED***
        smin = zeros(D***REMOVED***
        smax = zeros(D***REMOVED***
        for i in arange(D***REMOVED***:
            smin[i***REMOVED***, smax[i***REMOVED*** = range[i***REMOVED***

    # Make sure the bins have a finite width.
    for i in arange(len(smin***REMOVED******REMOVED***:
        if smin[i***REMOVED*** == smax[i***REMOVED***:
            smin[i***REMOVED*** = smin[i***REMOVED*** - .5
            smax[i***REMOVED*** = smax[i***REMOVED*** + .5

    # avoid rounding issues for comparisons when dealing with inexact types
    if np.issubdtype(sample.dtype, np.inexact***REMOVED***:
        edge_dt = sample.dtype
    else:
        edge_dt = float
    # Create edge arrays
    for i in arange(D***REMOVED***:
        if isscalar(bins[i***REMOVED******REMOVED***:
            if bins[i***REMOVED*** < 1:
                raise ValueError(
                    "Element at index %s in `bins` should be a positive "
                    "integer." % i***REMOVED***
            nbin[i***REMOVED*** = bins[i***REMOVED*** + 2  # +2 for outlier bins
            edges[i***REMOVED*** = linspace(smin[i***REMOVED***, smax[i***REMOVED***, nbin[i***REMOVED***-1, dtype=edge_dt***REMOVED***
        else:
            edges[i***REMOVED*** = asarray(bins[i***REMOVED***, edge_dt***REMOVED***
            nbin[i***REMOVED*** = len(edges[i***REMOVED******REMOVED*** + 1  # +1 for outlier bins
        dedges[i***REMOVED*** = diff(edges[i***REMOVED******REMOVED***
        if np.any(np.asarray(dedges[i***REMOVED******REMOVED*** <= 0***REMOVED***:
            raise ValueError(
                "Found bin edge of size <= 0. Did you specify `bins` with"
                "non-monotonic sequence?"***REMOVED***

    nbin = asarray(nbin***REMOVED***

    # Handle empty input.
    if N == 0:
        return np.zeros(nbin-2***REMOVED***, edges

    # Compute the bin number each sample falls into.
    Ncount = {***REMOVED***
    for i in arange(D***REMOVED***:
        Ncount[i***REMOVED*** = digitize(sample[:, i***REMOVED***, edges[i***REMOVED******REMOVED***

    # Using digitize, values that fall on an edge are put in the right bin.
    # For the rightmost bin, we want values equal to the right edge to be
    # counted in the last bin, and not as an outlier.
    for i in arange(D***REMOVED***:
        # Rounding precision
        mindiff = dedges[i***REMOVED***.min(***REMOVED***
        if not np.isinf(mindiff***REMOVED***:
            decimal = int(-log10(mindiff***REMOVED******REMOVED*** + 6
            # Find which points are on the rightmost edge.
            not_smaller_than_edge = (sample[:, i***REMOVED*** >= edges[i***REMOVED***[-1***REMOVED******REMOVED***
            on_edge = (around(sample[:, i***REMOVED***, decimal***REMOVED*** ==
                       around(edges[i***REMOVED***[-1***REMOVED***, decimal***REMOVED******REMOVED***
            # Shift these points one bin to the left.
            Ncount[i***REMOVED***[where(on_edge & not_smaller_than_edge***REMOVED***[0***REMOVED******REMOVED*** -= 1

    # Flattened histogram matrix (1D***REMOVED***
    # Reshape is used so that overlarge arrays
    # will raise an error.
    hist = zeros(nbin, float***REMOVED***.reshape(-1***REMOVED***

    # Compute the sample indices in the flattened histogram matrix.
    ni = nbin.argsort(***REMOVED***
    xy = zeros(N, int***REMOVED***
    for i in arange(0, D-1***REMOVED***:
        xy += Ncount[ni[i***REMOVED******REMOVED*** * nbin[ni[i+1:***REMOVED******REMOVED***.prod(***REMOVED***
    xy += Ncount[ni[-1***REMOVED******REMOVED***

    # Compute the number of repetitions in xy and assign it to the
    # flattened histmat.
    if len(xy***REMOVED*** == 0:
        return zeros(nbin-2, int***REMOVED***, edges

    flatcount = bincount(xy, weights***REMOVED***
    a = arange(len(flatcount***REMOVED******REMOVED***
    hist[a***REMOVED*** = flatcount

    # Shape into a proper matrix
    hist = hist.reshape(sort(nbin***REMOVED******REMOVED***
    for i in arange(nbin.size***REMOVED***:
        j = ni.argsort(***REMOVED***[i***REMOVED***
        hist = hist.swapaxes(i, j***REMOVED***
        ni[i***REMOVED***, ni[j***REMOVED*** = ni[j***REMOVED***, ni[i***REMOVED***

    # Remove outliers (indices 0 and -1 for each dimension***REMOVED***.
    core = D*[slice(1, -1***REMOVED******REMOVED***
    hist = hist[core***REMOVED***

    # Normalize if normed is True
    if normed:
        s = hist.sum(***REMOVED***
        for i in arange(D***REMOVED***:
            shape = ones(D, int***REMOVED***
            shape[i***REMOVED*** = nbin[i***REMOVED*** - 2
            hist = hist / dedges[i***REMOVED***.reshape(shape***REMOVED***
        hist /= s

    if (hist.shape != nbin - 2***REMOVED***.any(***REMOVED***:
        raise RuntimeError(
            "Internal Shape Error"***REMOVED***
    return hist, edges


def average(a, axis=None, weights=None, returned=False***REMOVED***:
    ***REMOVED***
    Compute the weighted average along the specified axis.

    Parameters
    ----------
    a : array_like
        Array containing data to be averaged. If `a` is not an array, a
        conversion is attempted.
    axis : int, optional
        Axis along which to average `a`. If `None`, averaging is done over
        the flattened array.
    weights : array_like, optional
        An array of weights associated with the values in `a`. Each value in
        `a` contributes to the average according to its associated weight.
        The weights array can either be 1-D (in which case its length must be
        the size of `a` along the given axis***REMOVED*** or of the same shape as `a`.
        If `weights=None`, then all data in `a` are assumed to have a
        weight equal to one.
    returned : bool, optional
        Default is `False`. If `True`, the tuple (`average`, `sum_of_weights`***REMOVED***
        is returned, otherwise only the average is returned.
        If `weights=None`, `sum_of_weights` is equivalent to the number of
        elements over which the average is taken.


    Returns
    -------
    average, [sum_of_weights***REMOVED*** : array_type or double
        Return the average along the specified axis. When returned is `True`,
        return a tuple with the average as the first element and the sum
        of the weights as the second element. The return type is `Float`
        if `a` is of integer type, otherwise it is of the same type as `a`.
        `sum_of_weights` is of the same type as `average`.

    Raises
    ------
    ZeroDivisionError
        When all weights along axis are zero. See `numpy.ma.average` for a
        version robust to this type of error.
    TypeError
        When the length of 1D `weights` is not the same as the shape of `a`
        along axis.

    See Also
    --------
    mean

    ma.average : average for masked arrays -- useful if your data contains
                 "missing" values

    Examples
    --------
    >>> data = range(1,5***REMOVED***
    >>> data
    [1, 2, 3, 4***REMOVED***
    >>> np.average(data***REMOVED***
    2.5
    >>> np.average(range(1,11***REMOVED***, weights=range(10,0,-1***REMOVED******REMOVED***
    4.0

    >>> data = np.arange(6***REMOVED***.reshape((3,2***REMOVED******REMOVED***
    >>> data
    array([[0, 1***REMOVED***,
           [2, 3***REMOVED***,
           [4, 5***REMOVED******REMOVED******REMOVED***
    >>> np.average(data, axis=1, weights=[1./4, 3./4***REMOVED******REMOVED***
    array([ 0.75,  2.75,  4.75***REMOVED******REMOVED***
    >>> np.average(data, weights=[1./4, 3./4***REMOVED******REMOVED***
    Traceback (most recent call last***REMOVED***:
    ...
    TypeError: Axis must be specified when shapes of a and weights differ.

    ***REMOVED***
    if not isinstance(a, np.matrix***REMOVED***:
        a = np.asarray(a***REMOVED***

    if weights is None:
        avg = a.mean(axis***REMOVED***
        scl = avg.dtype.type(a.size/avg.size***REMOVED***
    else:
        a = a + 0.0
        wgt = np.asarray(weights***REMOVED***
        # Sanity checks
        if a.shape != wgt.shape:
            if axis is None:
                raise TypeError(
                    "Axis must be specified when shapes of a and weights "
                    "differ."***REMOVED***
            if wgt.ndim != 1:
                raise TypeError(
                    "1D weights expected when shapes of a and weights differ."***REMOVED***
            if wgt.shape[0***REMOVED*** != a.shape[axis***REMOVED***:
                raise ValueError(
                    "Length of weights not compatible with specified axis."***REMOVED***

            # setup wgt to broadcast along axis
            wgt = np.array(wgt, copy=0, ndmin=a.ndim***REMOVED***.swapaxes(-1, axis***REMOVED***

        scl = wgt.sum(axis=axis, dtype=np.result_type(a.dtype, wgt.dtype***REMOVED******REMOVED***
        if (scl == 0.0***REMOVED***.any(***REMOVED***:
            raise ZeroDivisionError(
                "Weights sum to zero, can't be normalized"***REMOVED***

        avg = np.multiply(a, wgt***REMOVED***.sum(axis***REMOVED***/scl

    if returned:
        scl = np.multiply(avg, 0***REMOVED*** + scl
        return avg, scl
    else:
        return avg


def asarray_chkfinite(a, dtype=None, order=None***REMOVED***:
    ***REMOVED***Convert the input to an array, checking for NaNs or Infs.

    Parameters
    ----------
    a : array_like
        Input data, in any form that can be converted to an array.  This
        includes lists, lists of tuples, tuples, tuples of tuples, tuples
        of lists and ndarrays.  Success requires no NaNs or Infs.
    dtype : data-type, optional
        By default, the data-type is inferred from the input data.
    order : {'C', 'F'***REMOVED***, optional
         Whether to use row-major (C-style***REMOVED*** or
         column-major (Fortran-style***REMOVED*** memory representation.
         Defaults to 'C'.

    Returns
    -------
    out : ndarray
        Array interpretation of `a`.  No copy is performed if the input
        is already an ndarray.  If `a` is a subclass of ndarray, a base
        class ndarray is returned.

    Raises
    ------
    ValueError
        Raises ValueError if `a` contains NaN (Not a Number***REMOVED*** or Inf (Infinity***REMOVED***.

    See Also
    --------
    asarray : Create and array.
    asanyarray : Similar function which passes through subclasses.
    ascontiguousarray : Convert input to a contiguous array.
    asfarray : Convert input to a floating point ndarray.
    asfortranarray : Convert input to an ndarray with column-major
                     memory order.
    fromiter : Create an array from an iterator.
    fromfunction : Construct an array by executing a function on grid
                   positions.

    Examples
    --------
    Convert a list into an array.  If all elements are finite
    ``asarray_chkfinite`` is identical to ``asarray``.

    >>> a = [1, 2***REMOVED***
    >>> np.asarray_chkfinite(a, dtype=float***REMOVED***
    array([1., 2.***REMOVED******REMOVED***

    Raises ValueError if array_like contains Nans or Infs.

    >>> a = [1, 2, np.inf***REMOVED***
    >>> ***REMOVED***
    ...     np.asarray_chkfinite(a***REMOVED***
    ... except ValueError:
    ...     print('ValueError'***REMOVED***
    ...
    ValueError

    ***REMOVED***
    a = asarray(a, dtype=dtype, order=order***REMOVED***
    if a.dtype.char in typecodes['AllFloat'***REMOVED*** and not np.isfinite(a***REMOVED***.all(***REMOVED***:
        raise ValueError(
            "array must not contain infs or NaNs"***REMOVED***
    return a


def piecewise(x, condlist, funclist, *args, **kw***REMOVED***:
    ***REMOVED***
    Evaluate a piecewise-defined function.

    Given a set of conditions and corresponding functions, evaluate each
    function on the input data wherever its condition is true.

    Parameters
    ----------
    x : ndarray
        The input domain.
    condlist : list of bool arrays
        Each boolean array corresponds to a function in `funclist`.  Wherever
        `condlist[i***REMOVED***` is True, `funclist[i***REMOVED***(x***REMOVED***` is used as the output value.

        Each boolean array in `condlist` selects a piece of `x`,
        and should therefore be of the same shape as `x`.

        The length of `condlist` must correspond to that of `funclist`.
        If one extra function is given, i.e. if
        ``len(funclist***REMOVED*** - len(condlist***REMOVED*** == 1``, then that extra function
        is the default value, used wherever all conditions are false.
    funclist : list of callables, f(x,*args,**kw***REMOVED***, or scalars
        Each function is evaluated over `x` wherever its corresponding
        condition is True.  It should take an array as input and give an array
        or a scalar value as output.  If, instead of a callable,
        a scalar is provided then a constant function (``lambda x: scalar``***REMOVED*** is
        assumed.
    args : tuple, optional
        Any further arguments given to `piecewise` are passed to the functions
        upon execution, i.e., if called ``piecewise(..., ..., 1, 'a'***REMOVED***``, then
        each function is called as ``f(x, 1, 'a'***REMOVED***``.
    kw : dict, optional
        Keyword arguments used in calling `piecewise` are passed to the
        functions upon execution, i.e., if called
        ``piecewise(..., ..., lambda=1***REMOVED***``, then each function is called as
        ``f(x, lambda=1***REMOVED***``.

    Returns
    -------
    out : ndarray
        The output is the same shape and type as x and is found by
        calling the functions in `funclist` on the appropriate portions of `x`,
        as defined by the boolean arrays in `condlist`.  Portions not covered
        by any condition have a default value of 0.


    See Also
    --------
    choose, select, where

    Notes
    -----
    This is similar to choose or select, except that functions are
    evaluated on elements of `x` that satisfy the corresponding condition from
    `condlist`.

    The result is::

            |--
            |funclist[0***REMOVED***(x[condlist[0***REMOVED******REMOVED******REMOVED***
      out = |funclist[1***REMOVED***(x[condlist[1***REMOVED******REMOVED******REMOVED***
            |...
            |funclist[n2***REMOVED***(x[condlist[n2***REMOVED******REMOVED******REMOVED***
            |--

    Examples
    --------
    Define the sigma function, which is -1 for ``x < 0`` and +1 for ``x >= 0``.

    >>> x = np.linspace(-2.5, 2.5, 6***REMOVED***
    >>> np.piecewise(x, [x < 0, x >= 0***REMOVED***, [-1, 1***REMOVED******REMOVED***
    array([-1., -1., -1.,  1.,  1.,  1.***REMOVED******REMOVED***

    Define the absolute value, which is ``-x`` for ``x <0`` and ``x`` for
    ``x >= 0``.

    >>> np.piecewise(x, [x < 0, x >= 0***REMOVED***, [lambda x: -x, lambda x: x***REMOVED******REMOVED***
    array([ 2.5,  1.5,  0.5,  0.5,  1.5,  2.5***REMOVED******REMOVED***

    ***REMOVED***
    x = asanyarray(x***REMOVED***
    n2 = len(funclist***REMOVED***
    if (isscalar(condlist***REMOVED*** or not (isinstance(condlist[0***REMOVED***, list***REMOVED*** or
                                   isinstance(condlist[0***REMOVED***, ndarray***REMOVED******REMOVED******REMOVED***:
        condlist = [condlist***REMOVED***
    condlist = array(condlist, dtype=bool***REMOVED***
    n = len(condlist***REMOVED***
    # This is a hack to work around problems with NumPy's
    #  handling of 0-d arrays and boolean indexing with
    #  numpy.bool_ scalars
    zerod = False
    if x.ndim == 0:
        x = x[None***REMOVED***
        zerod = True
        if condlist.shape[-1***REMOVED*** != 1:
            condlist = condlist.T
    if n == n2 - 1:  # compute the "otherwise" condition.
        totlist = np.logical_or.reduce(condlist, axis=0***REMOVED***
        # Only able to stack vertically if the array is 1d or less
        if x.ndim <= 1:
            condlist = np.vstack([condlist, ~totlist***REMOVED******REMOVED***
        else:
            condlist = [asarray(c, dtype=bool***REMOVED*** for c in condlist***REMOVED***
            totlist = condlist[0***REMOVED***
            for k in range(1, n***REMOVED***:
                totlist |= condlist[k***REMOVED***
            condlist.append(~totlist***REMOVED***
        n += 1

    y = zeros(x.shape, x.dtype***REMOVED***
    for k in range(n***REMOVED***:
        item = funclist[k***REMOVED***
        if not isinstance(item, collections.Callable***REMOVED***:
            y[condlist[k***REMOVED******REMOVED*** = item
        else:
            vals = x[condlist[k***REMOVED******REMOVED***
            if vals.size > 0:
                y[condlist[k***REMOVED******REMOVED*** = item(vals, *args, **kw***REMOVED***
    if zerod:
        y = y.squeeze(***REMOVED***
    return y


def select(condlist, choicelist, default=0***REMOVED***:
    ***REMOVED***
    Return an array drawn from elements in choicelist, depending on conditions.

    Parameters
    ----------
    condlist : list of bool ndarrays
        The list of conditions which determine from which array in `choicelist`
        the output elements are taken. When multiple conditions are satisfied,
        the first one encountered in `condlist` is used.
    choicelist : list of ndarrays
        The list of arrays from which the output elements are taken. It has
        to be of the same length as `condlist`.
    default : scalar, optional
        The element inserted in `output` when all conditions evaluate to False.

    Returns
    -------
    output : ndarray
        The output at position m is the m-th element of the array in
        `choicelist` where the m-th element of the corresponding array in
        `condlist` is True.

    See Also
    --------
    where : Return elements from one of two arrays depending on condition.
    take, choose, compress, diag, diagonal

    Examples
    --------
    >>> x = np.arange(10***REMOVED***
    >>> condlist = [x<3, x>5***REMOVED***
    >>> choicelist = [x, x**2***REMOVED***
    >>> np.select(condlist, choicelist***REMOVED***
    array([ 0,  1,  2,  0,  0,  0, 36, 49, 64, 81***REMOVED******REMOVED***

    ***REMOVED***
    # Check the size of condlist and choicelist are the same, or abort.
    if len(condlist***REMOVED*** != len(choicelist***REMOVED***:
        raise ValueError(
            'list of cases must be same length as list of conditions'***REMOVED***

    # Now that the dtype is known, handle the deprecated select([***REMOVED***, [***REMOVED******REMOVED*** case
    if len(condlist***REMOVED*** == 0:
        # 2014-02-24, 1.9
        warnings.warn("select with an empty condition list is not possible"
                      "and will be deprecated",
                      DeprecationWarning***REMOVED***
        return np.asarray(default***REMOVED***[(***REMOVED******REMOVED***

    choicelist = [np.asarray(choice***REMOVED*** for choice in choicelist***REMOVED***
    choicelist.append(np.asarray(default***REMOVED******REMOVED***

    # need to get the result type before broadcasting for correct scalar
    # behaviour
    dtype = np.result_type(*choicelist***REMOVED***

    # Convert conditions to arrays and broadcast conditions and choices
    # as the shape is needed for the result. Doing it separately optimizes
    # for example when all choices are scalars.
    condlist = np.broadcast_arrays(*condlist***REMOVED***
    choicelist = np.broadcast_arrays(*choicelist***REMOVED***

    # If cond array is not an ndarray in boolean format or scalar bool, abort.
    deprecated_ints = False
    for i in range(len(condlist***REMOVED******REMOVED***:
        cond = condlist[i***REMOVED***
        if cond.dtype.type is not np.bool_:
            if np.issubdtype(cond.dtype, np.integer***REMOVED***:
                # A previous implementation accepted int ndarrays accidentally.
                # Supported here deliberately, but deprecated.
                condlist[i***REMOVED*** = condlist[i***REMOVED***.astype(bool***REMOVED***
                deprecated_ints = True
            else:
                raise ValueError(
                    'invalid entry in choicelist: should be boolean ndarray'***REMOVED***

    if deprecated_ints:
        # 2014-02-24, 1.9
        msg = "select condlists containing integer ndarrays is deprecated " \
            "and will be removed in the future. Use `.astype(bool***REMOVED***` to " \
            "convert to bools."
        warnings.warn(msg, DeprecationWarning***REMOVED***

    if choicelist[0***REMOVED***.ndim == 0:
        # This may be common, so avoid the call.
        result_shape = condlist[0***REMOVED***.shape
    else:
        result_shape = np.broadcast_arrays(condlist[0***REMOVED***, choicelist[0***REMOVED******REMOVED***[0***REMOVED***.shape

    result = np.full(result_shape, choicelist[-1***REMOVED***, dtype***REMOVED***

    # Use np.copyto to burn each choicelist array onto result, using the
    # corresponding condlist as a boolean mask. This is done in reverse
    # order since the first choice should take precedence.
    choicelist = choicelist[-2::-1***REMOVED***
    condlist = condlist[::-1***REMOVED***
    for choice, cond in zip(choicelist, condlist***REMOVED***:
        np.copyto(result, choice, where=cond***REMOVED***

    return result


def copy(a, order='K'***REMOVED***:
    ***REMOVED***
    Return an array copy of the given object.

    Parameters
    ----------
    a : array_like
        Input data.
    order : {'C', 'F', 'A', 'K'***REMOVED***, optional
        Controls the memory layout of the copy. 'C' means C-order,
        'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,
        'C' otherwise. 'K' means match the layout of `a` as closely
        as possible. (Note that this function and :meth:ndarray.copy are very
        similar, but have different default values for their order=
        arguments.***REMOVED***

    Returns
    -------
    arr : ndarray
        Array interpretation of `a`.

    Notes
    -----
    This is equivalent to

    >>> np.array(a, copy=True***REMOVED***                              #doctest: +SKIP

    Examples
    --------
    Create an array x, with a reference y and a copy z:

    >>> x = np.array([1, 2, 3***REMOVED******REMOVED***
    >>> y = x
    >>> z = np.copy(x***REMOVED***

    Note that, when we modify x, y changes, but not z:

    >>> x[0***REMOVED*** = 10
    >>> x[0***REMOVED*** == y[0***REMOVED***
    True
    >>> x[0***REMOVED*** == z[0***REMOVED***
    False

    ***REMOVED***
    return array(a, order=order, copy=True***REMOVED***

# Basic operations


def gradient(f, *varargs, **kwargs***REMOVED***:
    ***REMOVED***
    Return the gradient of an N-dimensional array.

    The gradient is computed using second order accurate central differences
    in the interior and either first differences or second order accurate
    one-sides (forward or backwards***REMOVED*** differences at the boundaries. The
    returned gradient hence has the same shape as the input array.

    Parameters
    ----------
    f : array_like
        An N-dimensional array containing samples of a scalar function.
    varargs : scalar or list of scalar, optional
        N scalars specifying the sample distances for each dimension,
        i.e. `dx`, `dy`, `dz`, ... Default distance: 1.
        single scalar specifies sample distance for all dimensions.
        if `axis` is given, the number of varargs must equal the number of axes.
    edge_order : {1, 2***REMOVED***, optional
        Gradient is calculated using N\ :sup:`th` order accurate differences
        at the boundaries. Default: 1.

        .. versionadded:: 1.9.1

    axis : None or int or tuple of ints, optional
        Gradient is calculated only along the given axis or axes
        The default (axis = None***REMOVED*** is to calculate the gradient for all the axes of the input array.
        axis may be negative, in which case it counts from the last to the first axis.

        .. versionadded:: 1.11.0

    Returns
    -------
    gradient : list of ndarray
        Each element of `list` has the same shape as `f` giving the derivative
        of `f` with respect to each dimension.

    Examples
    --------
    >>> x = np.array([1, 2, 4, 7, 11, 16***REMOVED***, dtype=np.float***REMOVED***
    >>> np.gradient(x***REMOVED***
    array([ 1. ,  1.5,  2.5,  3.5,  4.5,  5. ***REMOVED******REMOVED***
    >>> np.gradient(x, 2***REMOVED***
    array([ 0.5 ,  0.75,  1.25,  1.75,  2.25,  2.5 ***REMOVED******REMOVED***

    For two dimensional arrays, the return will be two arrays ordered by
    axis. In this example the first array stands for the gradient in
    rows and the second one in columns direction:

    >>> np.gradient(np.array([[1, 2, 6***REMOVED***, [3, 4, 5***REMOVED******REMOVED***, dtype=np.float***REMOVED******REMOVED***
    [array([[ 2.,  2., -1.***REMOVED***,
            [ 2.,  2., -1.***REMOVED******REMOVED******REMOVED***, array([[ 1. ,  2.5,  4. ***REMOVED***,
            [ 1. ,  1. ,  1. ***REMOVED******REMOVED******REMOVED******REMOVED***

    >>> x = np.array([0, 1, 2, 3, 4***REMOVED******REMOVED***
    >>> dx = np.gradient(x***REMOVED***
    >>> y = x**2
    >>> np.gradient(y, dx, edge_order=2***REMOVED***
    array([-0.,  2.,  4.,  6.,  8.***REMOVED******REMOVED***

    The axis keyword can be used to specify a subset of axes of which the gradient is calculated
    >>> np.gradient(np.array([[1, 2, 6***REMOVED***, [3, 4, 5***REMOVED******REMOVED***, dtype=np.float***REMOVED***, axis=0***REMOVED***
    array([[ 2.,  2., -1.***REMOVED***,
           [ 2.,  2., -1.***REMOVED******REMOVED******REMOVED***
    ***REMOVED***
    f = np.asanyarray(f***REMOVED***
    N = len(f.shape***REMOVED***  # number of dimensions

    axes = kwargs.pop('axis', None***REMOVED***
    if axes is None:
        axes = tuple(range(N***REMOVED******REMOVED***
    # check axes to have correct type and no duplicate entries
    if isinstance(axes, int***REMOVED***:
        axes = (axes,***REMOVED***
    if not isinstance(axes, tuple***REMOVED***:
        raise TypeError("A tuple of integers or a single integer is required"***REMOVED***

    # normalize axis values:
    axes = tuple(x + N if x < 0 else x for x in axes***REMOVED***
    if max(axes***REMOVED*** >= N or min(axes***REMOVED*** < 0:
        raise ValueError("'axis' entry is out of bounds"***REMOVED***

    if len(set(axes***REMOVED******REMOVED*** != len(axes***REMOVED***:
        raise ValueError("duplicate value in 'axis'"***REMOVED***

    n = len(varargs***REMOVED***
    if n == 0:
        dx = [1.0***REMOVED****N
    elif n == 1:
        dx = [varargs[0***REMOVED******REMOVED****N
    elif n == len(axes***REMOVED***:
        dx = list(varargs***REMOVED***
    else:
        raise SyntaxError(
            "invalid number of arguments"***REMOVED***

    edge_order = kwargs.pop('edge_order', 1***REMOVED***
    if kwargs:
        raise TypeError('"{***REMOVED***" are not valid keyword arguments.'.format(
                                                  '", "'.join(kwargs.keys(***REMOVED******REMOVED******REMOVED******REMOVED***
    if edge_order > 2:
        raise ValueError("'edge_order' greater than 2 not supported"***REMOVED***

    # use central differences on interior and one-sided differences on the
    # endpoints. This preserves second order-accuracy over the full domain.

    outvals = [***REMOVED***

    # create slice objects --- initially all are [:, :, ..., :***REMOVED***
    slice1 = [slice(None***REMOVED******REMOVED****N
    slice2 = [slice(None***REMOVED******REMOVED****N
    slice3 = [slice(None***REMOVED******REMOVED****N
    slice4 = [slice(None***REMOVED******REMOVED****N

    otype = f.dtype.char
    if otype not in ['f', 'd', 'F', 'D', 'm', 'M'***REMOVED***:
        otype = 'd'

    # Difference of datetime64 elements results in timedelta64
    if otype == 'M':
        # Need to use the full dtype name because it contains unit information
        otype = f.dtype.name.replace('datetime', 'timedelta'***REMOVED***
    elif otype == 'm':
        # Needs to keep the specific units, can't be a general unit
        otype = f.dtype

    # Convert datetime64 data into ints. Make dummy variable `y`
    # that is a view of ints if the data is datetime64, otherwise
    # just set y equal to the array `f`.
    if f.dtype.char in ["M", "m"***REMOVED***:
        y = f.view('int64'***REMOVED***
    else:
        y = f

    for i, axis in enumerate(axes***REMOVED***:

        if y.shape[axis***REMOVED*** < 2:
            raise ValueError(
                "Shape of array too small to calculate a numerical gradient, "
                "at least two elements are required."***REMOVED***

        # Numerical differentiation: 1st order edges, 2nd order interior
        if y.shape[axis***REMOVED*** == 2 or edge_order == 1:
            # Use first order differences for time data
            out = np.empty_like(y, dtype=otype***REMOVED***

            slice1[axis***REMOVED*** = slice(1, -1***REMOVED***
            slice2[axis***REMOVED*** = slice(2, None***REMOVED***
            slice3[axis***REMOVED*** = slice(None, -2***REMOVED***
            # 1D equivalent -- out[1:-1***REMOVED*** = (y[2:***REMOVED*** - y[:-2***REMOVED******REMOVED***/2.0
            out[slice1***REMOVED*** = (y[slice2***REMOVED*** - y[slice3***REMOVED******REMOVED***/2.0

            slice1[axis***REMOVED*** = 0
            slice2[axis***REMOVED*** = 1
            slice3[axis***REMOVED*** = 0
            # 1D equivalent -- out[0***REMOVED*** = (y[1***REMOVED*** - y[0***REMOVED******REMOVED***
            out[slice1***REMOVED*** = (y[slice2***REMOVED*** - y[slice3***REMOVED******REMOVED***

            slice1[axis***REMOVED*** = -1
            slice2[axis***REMOVED*** = -1
            slice3[axis***REMOVED*** = -2
            # 1D equivalent -- out[-1***REMOVED*** = (y[-1***REMOVED*** - y[-2***REMOVED******REMOVED***
            out[slice1***REMOVED*** = (y[slice2***REMOVED*** - y[slice3***REMOVED******REMOVED***

        # Numerical differentiation: 2st order edges, 2nd order interior
        else:
            # Use second order differences where possible
            out = np.empty_like(y, dtype=otype***REMOVED***

            slice1[axis***REMOVED*** = slice(1, -1***REMOVED***
            slice2[axis***REMOVED*** = slice(2, None***REMOVED***
            slice3[axis***REMOVED*** = slice(None, -2***REMOVED***
            # 1D equivalent -- out[1:-1***REMOVED*** = (y[2:***REMOVED*** - y[:-2***REMOVED******REMOVED***/2.0
            out[slice1***REMOVED*** = (y[slice2***REMOVED*** - y[slice3***REMOVED******REMOVED***/2.0

            slice1[axis***REMOVED*** = 0
            slice2[axis***REMOVED*** = 0
            slice3[axis***REMOVED*** = 1
            slice4[axis***REMOVED*** = 2
            # 1D equivalent -- out[0***REMOVED*** = -(3*y[0***REMOVED*** - 4*y[1***REMOVED*** + y[2***REMOVED******REMOVED*** / 2.0
            out[slice1***REMOVED*** = -(3.0*y[slice2***REMOVED*** - 4.0*y[slice3***REMOVED*** + y[slice4***REMOVED******REMOVED***/2.0

            slice1[axis***REMOVED*** = -1
            slice2[axis***REMOVED*** = -1
            slice3[axis***REMOVED*** = -2
            slice4[axis***REMOVED*** = -3
            # 1D equivalent -- out[-1***REMOVED*** = (3*y[-1***REMOVED*** - 4*y[-2***REMOVED*** + y[-3***REMOVED******REMOVED***
            out[slice1***REMOVED*** = (3.0*y[slice2***REMOVED*** - 4.0*y[slice3***REMOVED*** + y[slice4***REMOVED******REMOVED***/2.0

        # divide by step size
        out /= dx[i***REMOVED***
        outvals.append(out***REMOVED***

        # reset the slice object in this dimension to ":"
        slice1[axis***REMOVED*** = slice(None***REMOVED***
        slice2[axis***REMOVED*** = slice(None***REMOVED***
        slice3[axis***REMOVED*** = slice(None***REMOVED***
        slice4[axis***REMOVED*** = slice(None***REMOVED***

    if len(axes***REMOVED*** == 1:
        return outvals[0***REMOVED***
    else:
        return outvals


def diff(a, n=1, axis=-1***REMOVED***:
    ***REMOVED***
    Calculate the n-th discrete difference along given axis.

    The first difference is given by ``out[n***REMOVED*** = a[n+1***REMOVED*** - a[n***REMOVED***`` along
    the given axis, higher differences are calculated by using `diff`
    recursively.

    Parameters
    ----------
    a : array_like
        Input array
    n : int, optional
        The number of times values are differenced.
    axis : int, optional
        The axis along which the difference is taken, default is the last axis.

    Returns
    -------
    diff : ndarray
        The n-th differences. The shape of the output is the same as `a`
        except along `axis` where the dimension is smaller by `n`.
.

    See Also
    --------
    gradient, ediff1d, cumsum

    Examples
    --------
    >>> x = np.array([1, 2, 4, 7, 0***REMOVED******REMOVED***
    >>> np.diff(x***REMOVED***
    array([ 1,  2,  3, -7***REMOVED******REMOVED***
    >>> np.diff(x, n=2***REMOVED***
    array([  1,   1, -10***REMOVED******REMOVED***

    >>> x = np.array([[1, 3, 6, 10***REMOVED***, [0, 5, 6, 8***REMOVED******REMOVED******REMOVED***
    >>> np.diff(x***REMOVED***
    array([[2, 3, 4***REMOVED***,
           [5, 1, 2***REMOVED******REMOVED******REMOVED***
    >>> np.diff(x, axis=0***REMOVED***
    array([[-1,  2,  0, -2***REMOVED******REMOVED******REMOVED***

    ***REMOVED***
    if n == 0:
        return a
    if n < 0:
        raise ValueError(
            "order must be non-negative but got " + repr(n***REMOVED******REMOVED***
    a = asanyarray(a***REMOVED***
    nd = len(a.shape***REMOVED***
    slice1 = [slice(None***REMOVED******REMOVED****nd
    slice2 = [slice(None***REMOVED******REMOVED****nd
    slice1[axis***REMOVED*** = slice(1, None***REMOVED***
    slice2[axis***REMOVED*** = slice(None, -1***REMOVED***
    slice1 = tuple(slice1***REMOVED***
    slice2 = tuple(slice2***REMOVED***
    if n > 1:
        return diff(a[slice1***REMOVED***-a[slice2***REMOVED***, n-1, axis=axis***REMOVED***
    else:
        return a[slice1***REMOVED***-a[slice2***REMOVED***


def interp(x, xp, fp, left=None, right=None, period=None***REMOVED***:
    ***REMOVED***
    One-dimensional linear interpolation.

    Returns the one-dimensional piecewise linear interpolant to a function
    with given values at discrete data-points.

    Parameters
    ----------
    x : array_like
        The x-coordinates of the interpolated values.

    xp : 1-D sequence of floats
        The x-coordinates of the data points, must be increasing if argument
        `period` is not specified. Otherwise, `xp` is internally sorted after
        normalizing the periodic boundaries with ``xp = xp % period``.

    fp : 1-D sequence of floats
        The y-coordinates of the data points, same length as `xp`.

    left : float, optional
        Value to return for `x < xp[0***REMOVED***`, default is `fp[0***REMOVED***`.

    right : float, optional
        Value to return for `x > xp[-1***REMOVED***`, default is `fp[-1***REMOVED***`.

    period : None or float, optional
        A period for the x-coordinates. This parameter allows the proper
        interpolation of angular x-coordinates. Parameters `left` and `right`
        are ignored if `period` is specified.

        .. versionadded:: 1.10.0

    Returns
    -------
    y : float or ndarray
        The interpolated values, same shape as `x`.

    Raises
    ------
    ValueError
        If `xp` and `fp` have different length
        If `xp` or `fp` are not 1-D sequences
        If `period == 0`

    Notes
    -----
    Does not check that the x-coordinate sequence `xp` is increasing.
    If `xp` is not increasing, the results are nonsense.
    A simple check for increasing is::

        np.all(np.diff(xp***REMOVED*** > 0***REMOVED***

    Examples
    --------
    >>> xp = [1, 2, 3***REMOVED***
    >>> fp = [3, 2, 0***REMOVED***
    >>> np.interp(2.5, xp, fp***REMOVED***
    1.0
    >>> np.interp([0, 1, 1.5, 2.72, 3.14***REMOVED***, xp, fp***REMOVED***
    array([ 3. ,  3. ,  2.5 ,  0.56,  0. ***REMOVED******REMOVED***
    >>> UNDEF = -99.0
    >>> np.interp(3.14, xp, fp, right=UNDEF***REMOVED***
    -99.0

    Plot an interpolant to the sine function:

    >>> x = np.linspace(0, 2*np.pi, 10***REMOVED***
    >>> y = np.sin(x***REMOVED***
    >>> xvals = np.linspace(0, 2*np.pi, 50***REMOVED***
    >>> yinterp = np.interp(xvals, x, y***REMOVED***
    >>> import matplotlib.pyplot as plt
    >>> plt.plot(x, y, 'o'***REMOVED***
    [<matplotlib.lines.Line2D object at 0x...>***REMOVED***
    >>> plt.plot(xvals, yinterp, '-x'***REMOVED***
    [<matplotlib.lines.Line2D object at 0x...>***REMOVED***
    >>> plt.show(***REMOVED***

    Interpolation with periodic x-coordinates:

    >>> x = [-180, -170, -185, 185, -10, -5, 0, 365***REMOVED***
    >>> xp = [190, -190, 350, -350***REMOVED***
    >>> fp = [5, 10, 3, 4***REMOVED***
    >>> np.interp(x, xp, fp, period=360***REMOVED***
    array([7.5, 5., 8.75, 6.25, 3., 3.25, 3.5, 3.75***REMOVED******REMOVED***

    ***REMOVED***
    if period is None:
        if isinstance(x, (float, int, number***REMOVED******REMOVED***:
            return compiled_interp([x***REMOVED***, xp, fp, left, right***REMOVED***.item(***REMOVED***
        elif isinstance(x, np.ndarray***REMOVED*** and x.ndim == 0:
            return compiled_interp([x***REMOVED***, xp, fp, left, right***REMOVED***.item(***REMOVED***
        else:
            return compiled_interp(x, xp, fp, left, right***REMOVED***
    else:
        if period == 0:
            raise ValueError("period must be a non-zero value"***REMOVED***
        period = abs(period***REMOVED***
        left = None
        right = None
        return_array = True
        if isinstance(x, (float, int, number***REMOVED******REMOVED***:
            return_array = False
            x = [x***REMOVED***
        x = np.asarray(x, dtype=np.float64***REMOVED***
        xp = np.asarray(xp, dtype=np.float64***REMOVED***
        fp = np.asarray(fp, dtype=np.float64***REMOVED***
        if xp.ndim != 1 or fp.ndim != 1:
            raise ValueError("Data points must be 1-D sequences"***REMOVED***
        if xp.shape[0***REMOVED*** != fp.shape[0***REMOVED***:
            raise ValueError("fp and xp are not of the same length"***REMOVED***
        # normalizing periodic boundaries
        x = x % period
        xp = xp % period
        asort_xp = np.argsort(xp***REMOVED***
        xp = xp[asort_xp***REMOVED***
        fp = fp[asort_xp***REMOVED***
        xp = np.concatenate((xp[-1:***REMOVED***-period, xp, xp[0:1***REMOVED***+period***REMOVED******REMOVED***
        fp = np.concatenate((fp[-1:***REMOVED***, fp, fp[0:1***REMOVED******REMOVED******REMOVED***
        if return_array:
            return compiled_interp(x, xp, fp, left, right***REMOVED***
        else:
            return compiled_interp(x, xp, fp, left, right***REMOVED***.item(***REMOVED***


def angle(z, deg=0***REMOVED***:
    ***REMOVED***
    Return the angle of the complex argument.

    Parameters
    ----------
    z : array_like
        A complex number or sequence of complex numbers.
    deg : bool, optional
        Return angle in degrees if True, radians if False (default***REMOVED***.

    Returns
    -------
    angle : ndarray or scalar
        The counterclockwise angle from the positive real axis on
        the complex plane, with dtype as numpy.float64.

    See Also
    --------
    arctan2
    absolute



    Examples
    --------
    >>> np.angle([1.0, 1.0j, 1+1j***REMOVED******REMOVED***               # in radians
    array([ 0.        ,  1.57079633,  0.78539816***REMOVED******REMOVED***
    >>> np.angle(1+1j, deg=True***REMOVED***                  # in degrees
    45.0

    ***REMOVED***
    if deg:
        fact = 180/pi
    else:
        fact = 1.0
    z = asarray(z***REMOVED***
    if (issubclass(z.dtype.type, _nx.complexfloating***REMOVED******REMOVED***:
        zimag = z.imag
        zreal = z.real
    else:
        zimag = 0
        zreal = z
    return arctan2(zimag, zreal***REMOVED*** * fact


def unwrap(p, discont=pi, axis=-1***REMOVED***:
    ***REMOVED***
    Unwrap by changing deltas between values to 2*pi complement.

    Unwrap radian phase `p` by changing absolute jumps greater than
    `discont` to their 2*pi complement along the given axis.

    Parameters
    ----------
    p : array_like
        Input array.
    discont : float, optional
        Maximum discontinuity between values, default is ``pi``.
    axis : int, optional
        Axis along which unwrap will operate, default is the last axis.

    Returns
    -------
    out : ndarray
        Output array.

    See Also
    --------
    rad2deg, deg2rad

    Notes
    -----
    If the discontinuity in `p` is smaller than ``pi``, but larger than
    `discont`, no unwrapping is done because taking the 2*pi complement
    would only make the discontinuity larger.

    Examples
    --------
    >>> phase = np.linspace(0, np.pi, num=5***REMOVED***
    >>> phase[3:***REMOVED*** += np.pi
    >>> phase
    array([ 0.        ,  0.78539816,  1.57079633,  5.49778714,  6.28318531***REMOVED******REMOVED***
    >>> np.unwrap(phase***REMOVED***
    array([ 0.        ,  0.78539816,  1.57079633, -0.78539816,  0.        ***REMOVED******REMOVED***

    ***REMOVED***
    p = asarray(p***REMOVED***
    nd = len(p.shape***REMOVED***
    dd = diff(p, axis=axis***REMOVED***
    slice1 = [slice(None, None***REMOVED******REMOVED****nd     # full slices
    slice1[axis***REMOVED*** = slice(1, None***REMOVED***
    ddmod = mod(dd + pi, 2*pi***REMOVED*** - pi
    _nx.copyto(ddmod, pi, where=(ddmod == -pi***REMOVED*** & (dd > 0***REMOVED******REMOVED***
    ph_correct = ddmod - dd
    _nx.copyto(ph_correct, 0, where=abs(dd***REMOVED*** < discont***REMOVED***
    up = array(p, copy=True, dtype='d'***REMOVED***
    up[slice1***REMOVED*** = p[slice1***REMOVED*** + ph_correct.cumsum(axis***REMOVED***
    return up


def sort_complex(a***REMOVED***:
    ***REMOVED***
    Sort a complex array using the real part first, then the imaginary part.

    Parameters
    ----------
    a : array_like
        Input array

    Returns
    -------
    out : complex ndarray
        Always returns a sorted complex array.

    Examples
    --------
    >>> np.sort_complex([5, 3, 6, 2, 1***REMOVED******REMOVED***
    array([ 1.+0.j,  2.+0.j,  3.+0.j,  5.+0.j,  6.+0.j***REMOVED******REMOVED***

    >>> np.sort_complex([1 + 2j, 2 - 1j, 3 - 2j, 3 - 3j, 3 + 5j***REMOVED******REMOVED***
    array([ 1.+2.j,  2.-1.j,  3.-3.j,  3.-2.j,  3.+5.j***REMOVED******REMOVED***

    ***REMOVED***
    b = array(a, copy=True***REMOVED***
    b.sort(***REMOVED***
    if not issubclass(b.dtype.type, _nx.complexfloating***REMOVED***:
        if b.dtype.char in 'bhBH':
            return b.astype('F'***REMOVED***
        elif b.dtype.char == 'g':
            return b.astype('G'***REMOVED***
        else:
            return b.astype('D'***REMOVED***
    else:
        return b


def trim_zeros(filt, trim='fb'***REMOVED***:
    ***REMOVED***
    Trim the leading and/or trailing zeros from a 1-D array or sequence.

    Parameters
    ----------
    filt : 1-D array or sequence
        Input array.
    trim : str, optional
        A string with 'f' representing trim from front and 'b' to trim from
        back. Default is 'fb', trim zeros from both front and back of the
        array.

    Returns
    -------
    trimmed : 1-D array or sequence
        The result of trimming the input. The input data type is preserved.

    Examples
    --------
    >>> a = np.array((0, 0, 0, 1, 2, 3, 0, 2, 1, 0***REMOVED******REMOVED***
    >>> np.trim_zeros(a***REMOVED***
    array([1, 2, 3, 0, 2, 1***REMOVED******REMOVED***

    >>> np.trim_zeros(a, 'b'***REMOVED***
    array([0, 0, 0, 1, 2, 3, 0, 2, 1***REMOVED******REMOVED***

    The input data type is preserved, list/tuple in means list/tuple out.

    >>> np.trim_zeros([0, 1, 2, 0***REMOVED******REMOVED***
    [1, 2***REMOVED***

    ***REMOVED***
    first = 0
    trim = trim.upper(***REMOVED***
    if 'F' in trim:
        for i in filt:
            if i != 0.:
                break
            else:
                first = first + 1
    last = len(filt***REMOVED***
    if 'B' in trim:
        for i in filt[::-1***REMOVED***:
            if i != 0.:
                break
            else:
                last = last - 1
    return filt[first:last***REMOVED***


@deprecate
def unique(x***REMOVED***:
    ***REMOVED***
    This function is deprecated.  Use numpy.lib.arraysetops.unique(***REMOVED***
    instead.
    ***REMOVED***
    ***REMOVED***
        tmp = x.flatten(***REMOVED***
        if tmp.size == 0:
            return tmp
        tmp.sort(***REMOVED***
        idx = concatenate(([True***REMOVED***, tmp[1:***REMOVED*** != tmp[:-1***REMOVED******REMOVED******REMOVED***
        return tmp[idx***REMOVED***
    except AttributeError:
        items = sorted(set(x***REMOVED******REMOVED***
        return asarray(items***REMOVED***


def extract(condition, arr***REMOVED***:
    ***REMOVED***
    Return the elements of an array that satisfy some condition.

    This is equivalent to ``np.compress(ravel(condition***REMOVED***, ravel(arr***REMOVED******REMOVED***``.  If
    `condition` is boolean ``np.extract`` is equivalent to ``arr[condition***REMOVED***``.

    Note that `place` does the exact opposite of `extract`.

    Parameters
    ----------
    condition : array_like
        An array whose nonzero or True entries indicate the elements of `arr`
        to extract.
    arr : array_like
        Input array of the same size as `condition`.

    Returns
    -------
    extract : ndarray
        Rank 1 array of values from `arr` where `condition` is True.

    See Also
    --------
    take, put, copyto, compress, place

    Examples
    --------
    >>> arr = np.arange(12***REMOVED***.reshape((3, 4***REMOVED******REMOVED***
    >>> arr
    array([[ 0,  1,  2,  3***REMOVED***,
           [ 4,  5,  6,  7***REMOVED***,
           [ 8,  9, 10, 11***REMOVED******REMOVED******REMOVED***
    >>> condition = np.mod(arr, 3***REMOVED***==0
    >>> condition
    array([[ True, False, False,  True***REMOVED***,
           [False, False,  True, False***REMOVED***,
           [False,  True, False, False***REMOVED******REMOVED***, dtype=bool***REMOVED***
    >>> np.extract(condition, arr***REMOVED***
    array([0, 3, 6, 9***REMOVED******REMOVED***


    If `condition` is boolean:

    >>> arr[condition***REMOVED***
    array([0, 3, 6, 9***REMOVED******REMOVED***

    ***REMOVED***
    return _nx.take(ravel(arr***REMOVED***, nonzero(ravel(condition***REMOVED******REMOVED***[0***REMOVED******REMOVED***


def place(arr, mask, vals***REMOVED***:
    ***REMOVED***
    Change elements of an array based on conditional and input values.

    Similar to ``np.copyto(arr, vals, where=mask***REMOVED***``, the difference is that
    `place` uses the first N elements of `vals`, where N is the number of
    True values in `mask`, while `copyto` uses the elements where `mask`
    is True.

    Note that `extract` does the exact opposite of `place`.

    Parameters
    ----------
    arr : ndarray
        Array to put data into.
    mask : array_like
        Boolean mask array. Must have the same size as `a`.
    vals : 1-D sequence
        Values to put into `a`. Only the first N elements are used, where
        N is the number of True values in `mask`. If `vals` is smaller
        than N it will be repeated.

    See Also
    --------
    copyto, put, take, extract

    Examples
    --------
    >>> arr = np.arange(6***REMOVED***.reshape(2, 3***REMOVED***
    >>> np.place(arr, arr>2, [44, 55***REMOVED******REMOVED***
    >>> arr
    array([[ 0,  1,  2***REMOVED***,
           [44, 55, 44***REMOVED******REMOVED******REMOVED***

    ***REMOVED***
    if not isinstance(arr, np.ndarray***REMOVED***:
        raise TypeError("argument 1 must be numpy.ndarray, "
                        "not {name***REMOVED***".format(name=type(arr***REMOVED***.__name__***REMOVED******REMOVED***

    return _insert(arr, mask, vals***REMOVED***


def disp(mesg, device=None, linefeed=True***REMOVED***:
    ***REMOVED***
    Display a message on a device.

    Parameters
    ----------
    mesg : str
        Message to display.
    device : object
        Device to write message. If None, defaults to ``sys.stdout`` which is
        very similar to ``print``. `device` needs to have ``write(***REMOVED***`` and
        ``flush(***REMOVED***`` methods.
    linefeed : bool, optional
        Option whether to print a line feed or not. Defaults to True.

    Raises
    ------
    AttributeError
        If `device` does not have a ``write(***REMOVED***`` or ``flush(***REMOVED***`` method.

    Examples
    --------
    Besides ``sys.stdout``, a file-like object can also be used as it has
    both required methods:

    >>> from StringIO import StringIO
    >>> buf = StringIO(***REMOVED***
    >>> np.disp('"Display" in a file', device=buf***REMOVED***
    >>> buf.getvalue(***REMOVED***
    '"Display" in a file\\n'

    ***REMOVED***
    if device is None:
        device = sys.stdout
    if linefeed:
        device.write('%s\n' % mesg***REMOVED***
    else:
        device.write('%s' % mesg***REMOVED***
    device.flush(***REMOVED***
    return


class vectorize(object***REMOVED***:
    ***REMOVED***
    vectorize(pyfunc, otypes='', doc=None, excluded=None, cache=False***REMOVED***

    Generalized function class.

    Define a vectorized function which takes a nested sequence
    of objects or numpy arrays as inputs and returns a
    numpy array as output. The vectorized function evaluates `pyfunc` over
    successive tuples of the input arrays like the python map function,
    except it uses the broadcasting rules of numpy.

    The data type of the output of `vectorized` is determined by calling
    the function with the first element of the input.  This can be avoided
    by specifying the `otypes` argument.

    Parameters
    ----------
    pyfunc : callable
        A python function or method.
    otypes : str or list of dtypes, optional
        The output data type. It must be specified as either a string of
        typecode characters or a list of data type specifiers. There should
        be one data type specifier for each output.
    doc : str, optional
        The docstring for the function. If `None`, the docstring will be the
        ``pyfunc.__doc__``.
    excluded : set, optional
        Set of strings or integers representing the positional or keyword
        arguments for which the function will not be vectorized.  These will be
        passed directly to `pyfunc` unmodified.

        .. versionadded:: 1.7.0

    cache : bool, optional
       If `True`, then cache the first function call that determines the number
       of outputs if `otypes` is not provided.

        .. versionadded:: 1.7.0

    Returns
    -------
    vectorized : callable
        Vectorized function.

    Examples
    --------
    >>> def myfunc(a, b***REMOVED***:
    ...     "Return a-b if a>b, otherwise return a+b"
    ...     if a > b:
    ...         return a - b
    ...     else:
    ...         return a + b

    >>> vfunc = np.vectorize(myfunc***REMOVED***
    >>> vfunc([1, 2, 3, 4***REMOVED***, 2***REMOVED***
    array([3, 4, 1, 2***REMOVED******REMOVED***

    The docstring is taken from the input function to `vectorize` unless it
    is specified

    >>> vfunc.__doc__
    'Return a-b if a>b, otherwise return a+b'
    >>> vfunc = np.vectorize(myfunc, doc='Vectorized `myfunc`'***REMOVED***
    >>> vfunc.__doc__
    'Vectorized `myfunc`'

    The output type is determined by evaluating the first element of the input,
    unless it is specified

    >>> out = vfunc([1, 2, 3, 4***REMOVED***, 2***REMOVED***
    >>> type(out[0***REMOVED******REMOVED***
    <type 'numpy.int32'>
    >>> vfunc = np.vectorize(myfunc, otypes=[np.float***REMOVED******REMOVED***
    >>> out = vfunc([1, 2, 3, 4***REMOVED***, 2***REMOVED***
    >>> type(out[0***REMOVED******REMOVED***
    <type 'numpy.float64'>

    The `excluded` argument can be used to prevent vectorizing over certain
    arguments.  This can be useful for array-like arguments of a fixed length
    such as the coefficients for a polynomial as in `polyval`:

    >>> def mypolyval(p, x***REMOVED***:
    ...     _p = list(p***REMOVED***
    ...     res = _p.pop(0***REMOVED***
    ...     while _p:
    ...         res = res*x + _p.pop(0***REMOVED***
    ...     return res
    >>> vpolyval = np.vectorize(mypolyval, excluded=['p'***REMOVED******REMOVED***
    >>> vpolyval(p=[1, 2, 3***REMOVED***, x=[0, 1***REMOVED******REMOVED***
    array([3, 6***REMOVED******REMOVED***

    Positional arguments may also be excluded by specifying their position:

    >>> vpolyval.excluded.add(0***REMOVED***
    >>> vpolyval([1, 2, 3***REMOVED***, x=[0, 1***REMOVED******REMOVED***
    array([3, 6***REMOVED******REMOVED***

    Notes
    -----
    The `vectorize` function is provided primarily for convenience, not for
    performance. The implementation is essentially a for loop.

    If `otypes` is not specified, then a call to the function with the
    first argument will be used to determine the number of outputs.  The
    results of this call will be cached if `cache` is `True` to prevent
    calling the function twice.  However, to implement the cache, the
    original function must be wrapped which will slow down subsequent
    calls, so only do this if your function is expensive.

    The new keyword argument interface and `excluded` argument support
    further degrades performance.

    ***REMOVED***

    def __init__(self, pyfunc, otypes='', doc=None, excluded=None,
                 cache=False***REMOVED***:
        self.pyfunc = pyfunc
        self.cache = cache
        self._ufunc = None    # Caching to improve default performance

        if doc is None:
            self.__doc__ = pyfunc.__doc__
        else:
            self.__doc__ = doc

        if isinstance(otypes, str***REMOVED***:
            self.otypes = otypes
            for char in self.otypes:
                if char not in typecodes['All'***REMOVED***:
                    raise ValueError(
                        "Invalid otype specified: %s" % (char,***REMOVED******REMOVED***
        elif iterable(otypes***REMOVED***:
            self.otypes = ''.join([_nx.dtype(x***REMOVED***.char for x in otypes***REMOVED******REMOVED***
        else:
            raise ValueError(
                "Invalid otype specification"***REMOVED***

        # Excluded variable support
        if excluded is None:
            excluded = set(***REMOVED***
        self.excluded = set(excluded***REMOVED***

    def __call__(self, *args, **kwargs***REMOVED***:
        ***REMOVED***
        Return arrays with the results of `pyfunc` broadcast (vectorized***REMOVED*** over
        `args` and `kwargs` not in `excluded`.
        ***REMOVED***
        excluded = self.excluded
        if not kwargs and not excluded:
            func = self.pyfunc
            vargs = args
        else:
            # The wrapper accepts only positional arguments: we use `names` and
            # `inds` to mutate `the_args` and `kwargs` to pass to the original
            # function.
            nargs = len(args***REMOVED***

            names = [_n for _n in kwargs if _n not in excluded***REMOVED***
            inds = [_i for _i in range(nargs***REMOVED*** if _i not in excluded***REMOVED***
            the_args = list(args***REMOVED***

            def func(*vargs***REMOVED***:
                for _n, _i in enumerate(inds***REMOVED***:
                    the_args[_i***REMOVED*** = vargs[_n***REMOVED***
                kwargs.update(zip(names, vargs[len(inds***REMOVED***:***REMOVED******REMOVED******REMOVED***
                return self.pyfunc(*the_args, **kwargs***REMOVED***

            vargs = [args[_i***REMOVED*** for _i in inds***REMOVED***
            vargs.extend([kwargs[_n***REMOVED*** for _n in names***REMOVED******REMOVED***

        return self._vectorize_call(func=func, args=vargs***REMOVED***

    def _get_ufunc_and_otypes(self, func, args***REMOVED***:
        ***REMOVED***Return (ufunc, otypes***REMOVED***.***REMOVED***
        # frompyfunc will fail if args is empty
        if not args:
            raise ValueError('args can not be empty'***REMOVED***

        if self.otypes:
            otypes = self.otypes
            nout = len(otypes***REMOVED***

            # Note logic here: We only *use* self._ufunc if func is self.pyfunc
            # even though we set self._ufunc regardless.
            if func is self.pyfunc and self._ufunc is not None:
                ufunc = self._ufunc
            else:
                ufunc = self._ufunc = frompyfunc(func, len(args***REMOVED***, nout***REMOVED***
        else:
            # Get number of outputs and output types by calling the function on
            # the first entries of args.  We also cache the result to prevent
            # the subsequent call when the ufunc is evaluated.
            # Assumes that ufunc first evaluates the 0th elements in the input
            # arrays (the input values are not checked to ensure this***REMOVED***
            inputs = [asarray(_a***REMOVED***.flat[0***REMOVED*** for _a in args***REMOVED***
            outputs = func(*inputs***REMOVED***

            # Performance note: profiling indicates that -- for simple
            # functions at least -- this wrapping can almost double the
            # execution time.
            # Hence we make it optional.
            if self.cache:
                _cache = [outputs***REMOVED***

                def _func(*vargs***REMOVED***:
                    if _cache:
                        return _cache.pop(***REMOVED***
                    else:
                        return func(*vargs***REMOVED***
            else:
                _func = func

            if isinstance(outputs, tuple***REMOVED***:
                nout = len(outputs***REMOVED***
            else:
                nout = 1
                outputs = (outputs,***REMOVED***

            otypes = ''.join([asarray(outputs[_k***REMOVED******REMOVED***.dtype.char
                              for _k in range(nout***REMOVED******REMOVED******REMOVED***

            # Performance note: profiling indicates that creating the ufunc is
            # not a significant cost compared with wrapping so it seems not
            # worth trying to cache this.
            ufunc = frompyfunc(_func, len(args***REMOVED***, nout***REMOVED***

        return ufunc, otypes

    def _vectorize_call(self, func, args***REMOVED***:
        ***REMOVED***Vectorized call to `func` over positional `args`.***REMOVED***
        if not args:
            _res = func(***REMOVED***
        else:
            ufunc, otypes = self._get_ufunc_and_otypes(func=func, args=args***REMOVED***

            # Convert args to object arrays first
            inputs = [array(_a, copy=False, subok=True, dtype=object***REMOVED***
                      for _a in args***REMOVED***

            outputs = ufunc(*inputs***REMOVED***

            if ufunc.nout == 1:
                _res = array(outputs,
                             copy=False, subok=True, dtype=otypes[0***REMOVED******REMOVED***
            else:
                _res = tuple([array(_x, copy=False, subok=True, dtype=_t***REMOVED***
                              for _x, _t in zip(outputs, otypes***REMOVED******REMOVED******REMOVED***
        return _res


def cov(m, y=None, rowvar=True, bias=False, ddof=None, fweights=None,
        aweights=None***REMOVED***:
    ***REMOVED***
    Estimate a covariance matrix, given data and weights.

    Covariance indicates the level to which two variables vary together.
    If we examine N-dimensional samples, :math:`X = [x_1, x_2, ... x_N***REMOVED***^T`,
    then the covariance matrix element :math:`C_{ij***REMOVED***` is the covariance of
    :math:`x_i` and :math:`x_j`. The element :math:`C_{ii***REMOVED***` is the variance
    of :math:`x_i`.

    See the notes for an outline of the algorithm.

    Parameters
    ----------
    m : array_like
        A 1-D or 2-D array containing multiple variables and observations.
        Each row of `m` represents a variable, and each column a single
        observation of all those variables. Also see `rowvar` below.
    y : array_like, optional
        An additional set of variables and observations. `y` has the same form
        as that of `m`.
    rowvar : bool, optional
        If `rowvar` is True (default***REMOVED***, then each row represents a
        variable, with observations in the columns. Otherwise, the relationship
        is transposed: each column represents a variable, while the rows
        contain observations.
    bias : bool, optional
        Default normalization (False***REMOVED*** is by ``(N - 1***REMOVED***``, where ``N`` is the
        number of observations given (unbiased estimate***REMOVED***. If `bias` is True, then
        normalization is by ``N``. These values can be overridden by using the
        keyword ``ddof`` in numpy versions >= 1.5.
    ddof : int, optional
        If not ``None`` the default value implied by `bias` is overridden.
        Note that ``ddof=1`` will return the unbiased estimate, even if both
        `fweights` and `aweights` are specified, and ``ddof=0`` will return
        the simple average. See the notes for the details. The default value
        is ``None``.

        .. versionadded:: 1.5
    fweights : array_like, int, optional
        1-D array of integer freguency weights; the number of times each
        observation vector should be repeated.

        .. versionadded:: 1.10
    aweights : array_like, optional
        1-D array of observation vector weights. These relative weights are
        typically large for observations considered "important" and smaller for
        observations considered less "important". If ``ddof=0`` the array of
        weights can be used to assign probabilities to observation vectors.

        .. versionadded:: 1.10

    Returns
    -------
    out : ndarray
        The covariance matrix of the variables.

    See Also
    --------
    corrcoef : Normalized covariance matrix

    Notes
    -----
    Assume that the observations are in the columns of the observation
    array `m` and let ``f = fweights`` and ``a = aweights`` for brevity. The
    steps to compute the weighted covariance are as follows::

        >>> w = f * a
        >>> v1 = np.sum(w***REMOVED***
        >>> v2 = np.sum(w * a***REMOVED***
        >>> m -= np.sum(m * w, axis=1, keepdims=True***REMOVED*** / v1
        >>> cov = np.dot(m * w, m.T***REMOVED*** * v1 / (v1**2 - ddof * v2***REMOVED***

    Note that when ``a == 1``, the normalization factor
    ``v1 / (v1**2 - ddof * v2***REMOVED***`` goes over to ``1 / (np.sum(f***REMOVED*** - ddof***REMOVED***``
    as it should.

    Examples
    --------
    Consider two variables, :math:`x_0` and :math:`x_1`, which
    correlate perfectly, but in opposite directions:

    >>> x = np.array([[0, 2***REMOVED***, [1, 1***REMOVED***, [2, 0***REMOVED******REMOVED******REMOVED***.T
    >>> x
    array([[0, 1, 2***REMOVED***,
           [2, 1, 0***REMOVED******REMOVED******REMOVED***

    Note how :math:`x_0` increases while :math:`x_1` decreases. The covariance
    matrix shows this clearly:

    >>> np.cov(x***REMOVED***
    array([[ 1., -1.***REMOVED***,
           [-1.,  1.***REMOVED******REMOVED******REMOVED***

    Note that element :math:`C_{0,1***REMOVED***`, which shows the correlation between
    :math:`x_0` and :math:`x_1`, is negative.

    Further, note how `x` and `y` are combined:

    >>> x = [-2.1, -1,  4.3***REMOVED***
    >>> y = [3,  1.1,  0.12***REMOVED***
    >>> X = np.vstack((x,y***REMOVED******REMOVED***
    >>> print(np.cov(X***REMOVED******REMOVED***
    [[ 11.71        -4.286     ***REMOVED***
     [ -4.286        2.14413333***REMOVED******REMOVED***
    >>> print(np.cov(x, y***REMOVED******REMOVED***
    [[ 11.71        -4.286     ***REMOVED***
     [ -4.286        2.14413333***REMOVED******REMOVED***
    >>> print(np.cov(x***REMOVED******REMOVED***
    11.71

    ***REMOVED***
    # Check inputs
    if ddof is not None and ddof != int(ddof***REMOVED***:
        raise ValueError(
            "ddof must be integer"***REMOVED***

    # Handles complex arrays too
    m = np.asarray(m***REMOVED***
    if y is None:
        dtype = np.result_type(m, np.float64***REMOVED***
    else:
        y = np.asarray(y***REMOVED***
        dtype = np.result_type(m, y, np.float64***REMOVED***
    X = array(m, ndmin=2, dtype=dtype***REMOVED***
    if rowvar == 0 and X.shape[0***REMOVED*** != 1:
        X = X.T
    if X.shape[0***REMOVED*** == 0:
        return np.array([***REMOVED******REMOVED***.reshape(0, 0***REMOVED***
    if y is not None:
        y = array(y, copy=False, ndmin=2, dtype=dtype***REMOVED***
        if rowvar == 0 and y.shape[0***REMOVED*** != 1:
            y = y.T
        X = np.vstack((X, y***REMOVED******REMOVED***

    if ddof is None:
        if bias == 0:
            ddof = 1
        else:
            ddof = 0

    # Get the product of frequencies and weights
    w = None
    if fweights is not None:
        fweights = np.asarray(fweights, dtype=np.float***REMOVED***
        if not np.all(fweights == np.around(fweights***REMOVED******REMOVED***:
            raise TypeError(
                "fweights must be integer"***REMOVED***
        if fweights.ndim > 1:
            raise RuntimeError(
                "cannot handle multidimensional fweights"***REMOVED***
        if fweights.shape[0***REMOVED*** != X.shape[1***REMOVED***:
            raise RuntimeError(
                "incompatible numbers of samples and fweights"***REMOVED***
        if any(fweights < 0***REMOVED***:
            raise ValueError(
                "fweights cannot be negative"***REMOVED***
        w = fweights
    if aweights is not None:
        aweights = np.asarray(aweights, dtype=np.float***REMOVED***
        if aweights.ndim > 1:
            raise RuntimeError(
                "cannot handle multidimensional aweights"***REMOVED***
        if aweights.shape[0***REMOVED*** != X.shape[1***REMOVED***:
            raise RuntimeError(
                "incompatible numbers of samples and aweights"***REMOVED***
        if any(aweights < 0***REMOVED***:
            raise ValueError(
                "aweights cannot be negative"***REMOVED***
        if w is None:
            w = aweights
        else:
            w *= aweights

    avg, w_sum = average(X, axis=1, weights=w, returned=True***REMOVED***
    w_sum = w_sum[0***REMOVED***

    # Determine the normalization
    if w is None:
        fact = X.shape[1***REMOVED*** - ddof
    elif ddof == 0:
        fact = w_sum
    elif aweights is None:
        fact = w_sum - ddof
    else:
        fact = w_sum - ddof*sum(w*aweights***REMOVED***/w_sum

    if fact <= 0:
        warnings.warn("Degrees of freedom <= 0 for slice", RuntimeWarning***REMOVED***
        fact = 0.0

    X -= avg[:, None***REMOVED***
    if w is None:
        X_T = X.T
    else:
        X_T = (X*w***REMOVED***.T
    c = dot(X, X_T.conj(***REMOVED******REMOVED***
    c *= 1. / np.float64(fact***REMOVED***
    return c.squeeze(***REMOVED***


def corrcoef(x, y=None, rowvar=1, bias=np._NoValue, ddof=np._NoValue***REMOVED***:
    ***REMOVED***
    Return Pearson product-moment correlation coefficients.

    Please refer to the documentation for `cov` for more detail.  The
    relationship between the correlation coefficient matrix, `R`, and the
    covariance matrix, `C`, is

    .. math:: R_{ij***REMOVED*** = \\frac{ C_{ij***REMOVED*** ***REMOVED*** { \\sqrt{ C_{ii***REMOVED*** * C_{jj***REMOVED*** ***REMOVED*** ***REMOVED***

    The values of `R` are between -1 and 1, inclusive.

    Parameters
    ----------
    x : array_like
        A 1-D or 2-D array containing multiple variables and observations.
        Each row of `x` represents a variable, and each column a single
        observation of all those variables. Also see `rowvar` below.
    y : array_like, optional
        An additional set of variables and observations. `y` has the same
        shape as `x`.
    rowvar : int, optional
        If `rowvar` is non-zero (default***REMOVED***, then each row represents a
        variable, with observations in the columns. Otherwise, the relationship
        is transposed: each column represents a variable, while the rows
        contain observations.
    bias : _NoValue, optional
        Has no effect, do not use.

        .. deprecated:: 1.10.0
    ddof : _NoValue, optional
        Has no effect, do not use.

        .. deprecated:: 1.10.0

    Returns
    -------
    R : ndarray
        The correlation coefficient matrix of the variables.

    See Also
    --------
    cov : Covariance matrix

    Notes
    -----
    Due to floating point rounding the resulting array may not be Hermitian,
    the diagonal elements may not be 1, and the elements may not satisfy the
    inequality abs(a***REMOVED*** <= 1. The real and imaginary parts are clipped to the
    interval [-1,  1***REMOVED*** in an attempt to improve on that situation but is not
    much help in the complex case.

    This function accepts but discards arguments `bias` and `ddof`.  This is
    for backwards compatibility with previous versions of this function.  These
    arguments had no effect on the return values of the function and can be
    safely ignored in this and previous versions of numpy.
    ***REMOVED***
    if bias is not np._NoValue or ddof is not np._NoValue:
        # 2015-03-15, 1.10
        warnings.warn('bias and ddof have no effect and are deprecated',
                      DeprecationWarning***REMOVED***
    c = cov(x, y, rowvar***REMOVED***
    ***REMOVED***
        d = diag(c***REMOVED***
    except ValueError:
        # scalar covariance
        # nan if incorrect value (nan, inf, 0***REMOVED***, 1 otherwise
        return c / c
    stddev = sqrt(d.real***REMOVED***
    c /= stddev[:, None***REMOVED***
    c /= stddev[None, :***REMOVED***

    # Clip real and imaginary parts to [-1, 1***REMOVED***.  This does not guarantee
    # abs(a[i,j***REMOVED******REMOVED*** <= 1 for complex arrays, but is the best we can do without
    # excessive work.
    np.clip(c.real, -1, 1, out=c.real***REMOVED***
    if np.iscomplexobj(c***REMOVED***:
        np.clip(c.imag, -1, 1, out=c.imag***REMOVED***

    return c


def blackman(M***REMOVED***:
    ***REMOVED***
    Return the Blackman window.

    The Blackman window is a taper formed by using the first three
    terms of a summation of cosines. It was designed to have close to the
    minimal leakage possible.  It is close to optimal, only slightly worse
    than a Kaiser window.

    Parameters
    ----------
    M : int
        Number of points in the output window. If zero or less, an empty
        array is returned.

    Returns
    -------
    out : ndarray
        The window, with the maximum value normalized to one (the value one
        appears only if the number of samples is odd***REMOVED***.

    See Also
    --------
    bartlett, hamming, hanning, kaiser

    Notes
    -----
    The Blackman window is defined as

    .. math::  w(n***REMOVED*** = 0.42 - 0.5 \\cos(2\\pi n/M***REMOVED*** + 0.08 \\cos(4\\pi n/M***REMOVED***

    Most references to the Blackman window come from the signal processing
    literature, where it is used as one of many windowing functions for
    smoothing values.  It is also known as an apodization (which means
    "removing the foot", i.e. smoothing discontinuities at the beginning
    and end of the sampled signal***REMOVED*** or tapering function. It is known as a
    "near optimal" tapering function, almost as good (by some measures***REMOVED***
    as the kaiser window.

    References
    ----------
    Blackman, R.B. and Tukey, J.W., (1958***REMOVED*** The measurement of power spectra,
    Dover Publications, New York.

    Oppenheim, A.V., and R.W. Schafer. Discrete-Time Signal Processing.
    Upper Saddle River, NJ: Prentice-Hall, 1999, pp. 468-471.

    Examples
    --------
    >>> np.blackman(12***REMOVED***
    array([ -1.38777878e-17,   3.26064346e-02,   1.59903635e-01,
             4.14397981e-01,   7.36045180e-01,   9.67046769e-01,
             9.67046769e-01,   7.36045180e-01,   4.14397981e-01,
             1.59903635e-01,   3.26064346e-02,  -1.38777878e-17***REMOVED******REMOVED***


    Plot the window and the frequency response:

    >>> from numpy.fft import fft, fftshift
    >>> window = np.blackman(51***REMOVED***
    >>> plt.plot(window***REMOVED***
    [<matplotlib.lines.Line2D object at 0x...>***REMOVED***
    >>> plt.title("Blackman window"***REMOVED***
    <matplotlib.text.Text object at 0x...>
    >>> plt.ylabel("Amplitude"***REMOVED***
    <matplotlib.text.Text object at 0x...>
    >>> plt.xlabel("Sample"***REMOVED***
    <matplotlib.text.Text object at 0x...>
    >>> plt.show(***REMOVED***

    >>> plt.figure(***REMOVED***
    <matplotlib.figure.Figure object at 0x...>
    >>> A = fft(window, 2048***REMOVED*** / 25.5
    >>> mag = np.abs(fftshift(A***REMOVED******REMOVED***
    >>> freq = np.linspace(-0.5, 0.5, len(A***REMOVED******REMOVED***
    >>> response = 20 * np.log10(mag***REMOVED***
    >>> response = np.clip(response, -100, 100***REMOVED***
    >>> plt.plot(freq, response***REMOVED***
    [<matplotlib.lines.Line2D object at 0x...>***REMOVED***
    >>> plt.title("Frequency response of Blackman window"***REMOVED***
    <matplotlib.text.Text object at 0x...>
    >>> plt.ylabel("Magnitude [dB***REMOVED***"***REMOVED***
    <matplotlib.text.Text object at 0x...>
    >>> plt.xlabel("Normalized frequency [cycles per sample***REMOVED***"***REMOVED***
    <matplotlib.text.Text object at 0x...>
    >>> plt.axis('tight'***REMOVED***
    (-0.5, 0.5, -100.0, ...***REMOVED***
    >>> plt.show(***REMOVED***

    ***REMOVED***
    if M < 1:
        return array([***REMOVED******REMOVED***
    if M == 1:
        return ones(1, float***REMOVED***
    n = arange(0, M***REMOVED***
    return 0.42 - 0.5*cos(2.0*pi*n/(M-1***REMOVED******REMOVED*** + 0.08*cos(4.0*pi*n/(M-1***REMOVED******REMOVED***


def bartlett(M***REMOVED***:
    ***REMOVED***
    Return the Bartlett window.

    The Bartlett window is very similar to a triangular window, except
    that the end points are at zero.  It is often used in signal
    processing for tapering a signal, without generating too much
    ripple in the frequency domain.

    Parameters
    ----------
    M : int
        Number of points in the output window. If zero or less, an
        empty array is returned.

    Returns
    -------
    out : array
        The triangular window, with the maximum value normalized to one
        (the value one appears only if the number of samples is odd***REMOVED***, with
        the first and last samples equal to zero.

    See Also
    --------
    blackman, hamming, hanning, kaiser

    Notes
    -----
    The Bartlett window is defined as

    .. math:: w(n***REMOVED*** = \\frac{2***REMOVED***{M-1***REMOVED*** \\left(
              \\frac{M-1***REMOVED***{2***REMOVED*** - \\left|n - \\frac{M-1***REMOVED***{2***REMOVED***\\right|
              \\right***REMOVED***

    Most references to the Bartlett window come from the signal
    processing literature, where it is used as one of many windowing
    functions for smoothing values.  Note that convolution with this
    window produces linear interpolation.  It is also known as an
    apodization (which means"removing the foot", i.e. smoothing
    discontinuities at the beginning and end of the sampled signal***REMOVED*** or
    tapering function. The fourier transform of the Bartlett is the product
    of two sinc functions.
    Note the excellent discussion in Kanasewich.

    References
    ----------
    .. [1***REMOVED*** M.S. Bartlett, "Periodogram Analysis and Continuous Spectra",
           Biometrika 37, 1-16, 1950.
    .. [2***REMOVED*** E.R. Kanasewich, "Time Sequence Analysis in Geophysics",
           The University of Alberta Press, 1975, pp. 109-110.
    .. [3***REMOVED*** A.V. Oppenheim and R.W. Schafer, "Discrete-Time Signal
           Processing", Prentice-Hall, 1999, pp. 468-471.
    .. [4***REMOVED*** Wikipedia, "Window function",
           http://en.wikipedia.org/wiki/Window_function
    .. [5***REMOVED*** W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,
           "Numerical Recipes", Cambridge University Press, 1986, page 429.


    Examples
    --------
    >>> np.bartlett(12***REMOVED***
    array([ 0.        ,  0.18181818,  0.36363636,  0.54545455,  0.72727273,
            0.90909091,  0.90909091,  0.72727273,  0.54545455,  0.36363636,
            0.18181818,  0.        ***REMOVED******REMOVED***

    Plot the window and its frequency response (requires SciPy and matplotlib***REMOVED***:

    >>> from numpy.fft import fft, fftshift
    >>> window = np.bartlett(51***REMOVED***
    >>> plt.plot(window***REMOVED***
    [<matplotlib.lines.Line2D object at 0x...>***REMOVED***
    >>> plt.title("Bartlett window"***REMOVED***
    <matplotlib.text.Text object at 0x...>
    >>> plt.ylabel("Amplitude"***REMOVED***
    <matplotlib.text.Text object at 0x...>
    >>> plt.xlabel("Sample"***REMOVED***
    <matplotlib.text.Text object at 0x...>
    >>> plt.show(***REMOVED***

    >>> plt.figure(***REMOVED***
    <matplotlib.figure.Figure object at 0x...>
    >>> A = fft(window, 2048***REMOVED*** / 25.5
    >>> mag = np.abs(fftshift(A***REMOVED******REMOVED***
    >>> freq = np.linspace(-0.5, 0.5, len(A***REMOVED******REMOVED***
    >>> response = 20 * np.log10(mag***REMOVED***
    >>> response = np.clip(response, -100, 100***REMOVED***
    >>> plt.plot(freq, response***REMOVED***
    [<matplotlib.lines.Line2D object at 0x...>***REMOVED***
    >>> plt.title("Frequency response of Bartlett window"***REMOVED***
    <matplotlib.text.Text object at 0x...>
    >>> plt.ylabel("Magnitude [dB***REMOVED***"***REMOVED***
    <matplotlib.text.Text object at 0x...>
    >>> plt.xlabel("Normalized frequency [cycles per sample***REMOVED***"***REMOVED***
    <matplotlib.text.Text object at 0x...>
    >>> plt.axis('tight'***REMOVED***
    (-0.5, 0.5, -100.0, ...***REMOVED***
    >>> plt.show(***REMOVED***

    ***REMOVED***
    if M < 1:
        return array([***REMOVED******REMOVED***
    if M == 1:
        return ones(1, float***REMOVED***
    n = arange(0, M***REMOVED***
    return where(less_equal(n, (M-1***REMOVED***/2.0***REMOVED***, 2.0*n/(M-1***REMOVED***, 2.0 - 2.0*n/(M-1***REMOVED******REMOVED***


def hanning(M***REMOVED***:
    ***REMOVED***
    Return the Hanning window.

    The Hanning window is a taper formed by using a weighted cosine.

    Parameters
    ----------
    M : int
        Number of points in the output window. If zero or less, an
        empty array is returned.

    Returns
    -------
    out : ndarray, shape(M,***REMOVED***
        The window, with the maximum value normalized to one (the value
        one appears only if `M` is odd***REMOVED***.

    See Also
    --------
    bartlett, blackman, hamming, kaiser

    Notes
    -----
    The Hanning window is defined as

    .. math::  w(n***REMOVED*** = 0.5 - 0.5cos\\left(\\frac{2\\pi{n***REMOVED******REMOVED***{M-1***REMOVED***\\right***REMOVED***
               \\qquad 0 \\leq n \\leq M-1

    The Hanning was named for Julius von Hann, an Austrian meteorologist.
    It is also known as the Cosine Bell. Some authors prefer that it be
    called a Hann window, to help avoid confusion with the very similar
    Hamming window.

    Most references to the Hanning window come from the signal processing
    literature, where it is used as one of many windowing functions for
    smoothing values.  It is also known as an apodization (which means
    "removing the foot", i.e. smoothing discontinuities at the beginning
    and end of the sampled signal***REMOVED*** or tapering function.

    References
    ----------
    .. [1***REMOVED*** Blackman, R.B. and Tukey, J.W., (1958***REMOVED*** The measurement of power
           spectra, Dover Publications, New York.
    .. [2***REMOVED*** E.R. Kanasewich, "Time Sequence Analysis in Geophysics",
           The University of Alberta Press, 1975, pp. 106-108.
    .. [3***REMOVED*** Wikipedia, "Window function",
           http://en.wikipedia.org/wiki/Window_function
    .. [4***REMOVED*** W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,
           "Numerical Recipes", Cambridge University Press, 1986, page 425.

    Examples
    --------
    >>> np.hanning(12***REMOVED***
    array([ 0.        ,  0.07937323,  0.29229249,  0.57115742,  0.82743037,
            0.97974649,  0.97974649,  0.82743037,  0.57115742,  0.29229249,
            0.07937323,  0.        ***REMOVED******REMOVED***

    Plot the window and its frequency response:

    >>> from numpy.fft import fft, fftshift
    >>> window = np.hanning(51***REMOVED***
    >>> plt.plot(window***REMOVED***
    [<matplotlib.lines.Line2D object at 0x...>***REMOVED***
    >>> plt.title("Hann window"***REMOVED***
    <matplotlib.text.Text object at 0x...>
    >>> plt.ylabel("Amplitude"***REMOVED***
    <matplotlib.text.Text object at 0x...>
    >>> plt.xlabel("Sample"***REMOVED***
    <matplotlib.text.Text object at 0x...>
    >>> plt.show(***REMOVED***

    >>> plt.figure(***REMOVED***
    <matplotlib.figure.Figure object at 0x...>
    >>> A = fft(window, 2048***REMOVED*** / 25.5
    >>> mag = np.abs(fftshift(A***REMOVED******REMOVED***
    >>> freq = np.linspace(-0.5, 0.5, len(A***REMOVED******REMOVED***
    >>> response = 20 * np.log10(mag***REMOVED***
    >>> response = np.clip(response, -100, 100***REMOVED***
    >>> plt.plot(freq, response***REMOVED***
    [<matplotlib.lines.Line2D object at 0x...>***REMOVED***
    >>> plt.title("Frequency response of the Hann window"***REMOVED***
    <matplotlib.text.Text object at 0x...>
    >>> plt.ylabel("Magnitude [dB***REMOVED***"***REMOVED***
    <matplotlib.text.Text object at 0x...>
    >>> plt.xlabel("Normalized frequency [cycles per sample***REMOVED***"***REMOVED***
    <matplotlib.text.Text object at 0x...>
    >>> plt.axis('tight'***REMOVED***
    (-0.5, 0.5, -100.0, ...***REMOVED***
    >>> plt.show(***REMOVED***

    ***REMOVED***
    if M < 1:
        return array([***REMOVED******REMOVED***
    if M == 1:
        return ones(1, float***REMOVED***
    n = arange(0, M***REMOVED***
    return 0.5 - 0.5*cos(2.0*pi*n/(M-1***REMOVED******REMOVED***


def hamming(M***REMOVED***:
    ***REMOVED***
    Return the Hamming window.

    The Hamming window is a taper formed by using a weighted cosine.

    Parameters
    ----------
    M : int
        Number of points in the output window. If zero or less, an
        empty array is returned.

    Returns
    -------
    out : ndarray
        The window, with the maximum value normalized to one (the value
        one appears only if the number of samples is odd***REMOVED***.

    See Also
    --------
    bartlett, blackman, hanning, kaiser

    Notes
    -----
    The Hamming window is defined as

    .. math::  w(n***REMOVED*** = 0.54 - 0.46cos\\left(\\frac{2\\pi{n***REMOVED******REMOVED***{M-1***REMOVED***\\right***REMOVED***
               \\qquad 0 \\leq n \\leq M-1

    The Hamming was named for R. W. Hamming, an associate of J. W. Tukey
    and is described in Blackman and Tukey. It was recommended for
    smoothing the truncated autocovariance function in the time domain.
    Most references to the Hamming window come from the signal processing
    literature, where it is used as one of many windowing functions for
    smoothing values.  It is also known as an apodization (which means
    "removing the foot", i.e. smoothing discontinuities at the beginning
    and end of the sampled signal***REMOVED*** or tapering function.

    References
    ----------
    .. [1***REMOVED*** Blackman, R.B. and Tukey, J.W., (1958***REMOVED*** The measurement of power
           spectra, Dover Publications, New York.
    .. [2***REMOVED*** E.R. Kanasewich, "Time Sequence Analysis in Geophysics", The
           University of Alberta Press, 1975, pp. 109-110.
    .. [3***REMOVED*** Wikipedia, "Window function",
           http://en.wikipedia.org/wiki/Window_function
    .. [4***REMOVED*** W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,
           "Numerical Recipes", Cambridge University Press, 1986, page 425.

    Examples
    --------
    >>> np.hamming(12***REMOVED***
    array([ 0.08      ,  0.15302337,  0.34890909,  0.60546483,  0.84123594,
            0.98136677,  0.98136677,  0.84123594,  0.60546483,  0.34890909,
            0.15302337,  0.08      ***REMOVED******REMOVED***

    Plot the window and the frequency response:

    >>> from numpy.fft import fft, fftshift
    >>> window = np.hamming(51***REMOVED***
    >>> plt.plot(window***REMOVED***
    [<matplotlib.lines.Line2D object at 0x...>***REMOVED***
    >>> plt.title("Hamming window"***REMOVED***
    <matplotlib.text.Text object at 0x...>
    >>> plt.ylabel("Amplitude"***REMOVED***
    <matplotlib.text.Text object at 0x...>
    >>> plt.xlabel("Sample"***REMOVED***
    <matplotlib.text.Text object at 0x...>
    >>> plt.show(***REMOVED***

    >>> plt.figure(***REMOVED***
    <matplotlib.figure.Figure object at 0x...>
    >>> A = fft(window, 2048***REMOVED*** / 25.5
    >>> mag = np.abs(fftshift(A***REMOVED******REMOVED***
    >>> freq = np.linspace(-0.5, 0.5, len(A***REMOVED******REMOVED***
    >>> response = 20 * np.log10(mag***REMOVED***
    >>> response = np.clip(response, -100, 100***REMOVED***
    >>> plt.plot(freq, response***REMOVED***
    [<matplotlib.lines.Line2D object at 0x...>***REMOVED***
    >>> plt.title("Frequency response of Hamming window"***REMOVED***
    <matplotlib.text.Text object at 0x...>
    >>> plt.ylabel("Magnitude [dB***REMOVED***"***REMOVED***
    <matplotlib.text.Text object at 0x...>
    >>> plt.xlabel("Normalized frequency [cycles per sample***REMOVED***"***REMOVED***
    <matplotlib.text.Text object at 0x...>
    >>> plt.axis('tight'***REMOVED***
    (-0.5, 0.5, -100.0, ...***REMOVED***
    >>> plt.show(***REMOVED***

    ***REMOVED***
    if M < 1:
        return array([***REMOVED******REMOVED***
    if M == 1:
        return ones(1, float***REMOVED***
    n = arange(0, M***REMOVED***
    return 0.54 - 0.46*cos(2.0*pi*n/(M-1***REMOVED******REMOVED***

## Code from cephes for i0

_i0A = [
    -4.41534164647933937950E-18,
    3.33079451882223809783E-17,
    -2.43127984654795469359E-16,
    1.71539128555513303061E-15,
    -1.16853328779934516808E-14,
    7.67618549860493561688E-14,
    -4.85644678311192946090E-13,
    2.95505266312963983461E-12,
    -1.72682629144155570723E-11,
    9.67580903537323691224E-11,
    -5.18979560163526290666E-10,
    2.65982372468238665035E-9,
    -1.30002500998624804212E-8,
    6.04699502254191894932E-8,
    -2.67079385394061173391E-7,
    1.11738753912010371815E-6,
    -4.41673835845875056359E-6,
    1.64484480707288970893E-5,
    -5.75419501008210370398E-5,
    1.88502885095841655729E-4,
    -5.76375574538582365885E-4,
    1.63947561694133579842E-3,
    -4.32430999505057594430E-3,
    1.05464603945949983183E-2,
    -2.37374148058994688156E-2,
    4.93052842396707084878E-2,
    -9.49010970480476444210E-2,
    1.71620901522208775349E-1,
    -3.04682672343198398683E-1,
    6.76795274409476084995E-1
    ***REMOVED***

_i0B = [
    -7.23318048787475395456E-18,
    -4.83050448594418207126E-18,
    4.46562142029675999901E-17,
    3.46122286769746109310E-17,
    -2.82762398051658348494E-16,
    -3.42548561967721913462E-16,
    1.77256013305652638360E-15,
    3.81168066935262242075E-15,
    -9.55484669882830764870E-15,
    -4.15056934728722208663E-14,
    1.54008621752140982691E-14,
    3.85277838274214270114E-13,
    7.18012445138366623367E-13,
    -1.79417853150680611778E-12,
    -1.32158118404477131188E-11,
    -3.14991652796324136454E-11,
    1.18891471078464383424E-11,
    4.94060238822496958910E-10,
    3.39623202570838634515E-9,
    2.26666899049817806459E-8,
    2.04891858946906374183E-7,
    2.89137052083475648297E-6,
    6.88975834691682398426E-5,
    3.36911647825569408990E-3,
    8.04490411014108831608E-1
    ***REMOVED***


def _chbevl(x, vals***REMOVED***:
    b0 = vals[0***REMOVED***
    b1 = 0.0

    for i in range(1, len(vals***REMOVED******REMOVED***:
        b2 = b1
        b1 = b0
        b0 = x*b1 - b2 + vals[i***REMOVED***

    return 0.5*(b0 - b2***REMOVED***


def _i0_1(x***REMOVED***:
    return exp(x***REMOVED*** * _chbevl(x/2.0-2, _i0A***REMOVED***


def _i0_2(x***REMOVED***:
    return exp(x***REMOVED*** * _chbevl(32.0/x - 2.0, _i0B***REMOVED*** / sqrt(x***REMOVED***


def i0(x***REMOVED***:
    ***REMOVED***
    Modified Bessel function of the first kind, order 0.

    Usually denoted :math:`I_0`.  This function does broadcast, but will *not*
    "up-cast" int dtype arguments unless accompanied by at least one float or
    complex dtype argument (see Raises below***REMOVED***.

    Parameters
    ----------
    x : array_like, dtype float or complex
        Argument of the Bessel function.

    Returns
    -------
    out : ndarray, shape = x.shape, dtype = x.dtype
        The modified Bessel function evaluated at each of the elements of `x`.

    Raises
    ------
    TypeError: array cannot be safely cast to required type
        If argument consists exclusively of int dtypes.

    See Also
    --------
    scipy.special.iv, scipy.special.ive

    Notes
    -----
    We use the algorithm published by Clenshaw [1***REMOVED***_ and referenced by
    Abramowitz and Stegun [2***REMOVED***_, for which the function domain is
    partitioned into the two intervals [0,8***REMOVED*** and (8,inf***REMOVED***, and Chebyshev
    polynomial expansions are employed in each interval. Relative error on
    the domain [0,30***REMOVED*** using IEEE arithmetic is documented [3***REMOVED***_ as having a
    peak of 5.8e-16 with an rms of 1.4e-16 (n = 30000***REMOVED***.

    References
    ----------
    .. [1***REMOVED*** C. W. Clenshaw, "Chebyshev series for mathematical functions", in
           *National Physical Laboratory Mathematical Tables*, vol. 5, London:
           Her Majesty's Stationery Office, 1962.
    .. [2***REMOVED*** M. Abramowitz and I. A. Stegun, *Handbook of Mathematical
           Functions*, 10th printing, New York: Dover, 1964, pp. 379.
           http://www.math.sfu.ca/~cbm/aands/page_379.htm
    .. [3***REMOVED*** http://kobesearch.cpan.org/htdocs/Math-Cephes/Math/Cephes.html

    Examples
    --------
    >>> np.i0([0.***REMOVED******REMOVED***
    array(1.0***REMOVED***
    >>> np.i0([0., 1. + 2j***REMOVED******REMOVED***
    array([ 1.00000000+0.j        ,  0.18785373+0.64616944j***REMOVED******REMOVED***

    ***REMOVED***
    x = atleast_1d(x***REMOVED***.copy(***REMOVED***
    y = empty_like(x***REMOVED***
    ind = (x < 0***REMOVED***
    x[ind***REMOVED*** = -x[ind***REMOVED***
    ind = (x <= 8.0***REMOVED***
    y[ind***REMOVED*** = _i0_1(x[ind***REMOVED******REMOVED***
    ind2 = ~ind
    y[ind2***REMOVED*** = _i0_2(x[ind2***REMOVED******REMOVED***
    return y.squeeze(***REMOVED***

## End of cephes code for i0


def kaiser(M, beta***REMOVED***:
    ***REMOVED***
    Return the Kaiser window.

    The Kaiser window is a taper formed by using a Bessel function.

    Parameters
    ----------
    M : int
        Number of points in the output window. If zero or less, an
        empty array is returned.
    beta : float
        Shape parameter for window.

    Returns
    -------
    out : array
        The window, with the maximum value normalized to one (the value
        one appears only if the number of samples is odd***REMOVED***.

    See Also
    --------
    bartlett, blackman, hamming, hanning

    Notes
    -----
    The Kaiser window is defined as

    .. math::  w(n***REMOVED*** = I_0\\left( \\beta \\sqrt{1-\\frac{4n^2***REMOVED***{(M-1***REMOVED***^2***REMOVED******REMOVED***
               \\right***REMOVED***/I_0(\\beta***REMOVED***

    with

    .. math:: \\quad -\\frac{M-1***REMOVED***{2***REMOVED*** \\leq n \\leq \\frac{M-1***REMOVED***{2***REMOVED***,

    where :math:`I_0` is the modified zeroth-order Bessel function.

    The Kaiser was named for Jim Kaiser, who discovered a simple
    approximation to the DPSS window based on Bessel functions.  The Kaiser
    window is a very good approximation to the Digital Prolate Spheroidal
    Sequence, or Slepian window, which is the transform which maximizes the
    energy in the main lobe of the window relative to total energy.

    The Kaiser can approximate many other windows by varying the beta
    parameter.

    ====  =======================
    beta  Window shape
    ====  =======================
    0     Rectangular
    5     Similar to a Hamming
    6     Similar to a Hanning
    8.6   Similar to a Blackman
    ====  =======================

    A beta value of 14 is probably a good starting point. Note that as beta
    gets large, the window narrows, and so the number of samples needs to be
    large enough to sample the increasingly narrow spike, otherwise NaNs will
    get returned.

    Most references to the Kaiser window come from the signal processing
    literature, where it is used as one of many windowing functions for
    smoothing values.  It is also known as an apodization (which means
    "removing the foot", i.e. smoothing discontinuities at the beginning
    and end of the sampled signal***REMOVED*** or tapering function.

    References
    ----------
    .. [1***REMOVED*** J. F. Kaiser, "Digital Filters" - Ch 7 in "Systems analysis by
           digital computer", Editors: F.F. Kuo and J.F. Kaiser, p 218-285.
           John Wiley and Sons, New York, (1966***REMOVED***.
    .. [2***REMOVED*** E.R. Kanasewich, "Time Sequence Analysis in Geophysics", The
           University of Alberta Press, 1975, pp. 177-178.
    .. [3***REMOVED*** Wikipedia, "Window function",
           http://en.wikipedia.org/wiki/Window_function

    Examples
    --------
    >>> np.kaiser(12, 14***REMOVED***
    array([  7.72686684e-06,   3.46009194e-03,   4.65200189e-02,
             2.29737120e-01,   5.99885316e-01,   9.45674898e-01,
             9.45674898e-01,   5.99885316e-01,   2.29737120e-01,
             4.65200189e-02,   3.46009194e-03,   7.72686684e-06***REMOVED******REMOVED***


    Plot the window and the frequency response:

    >>> from numpy.fft import fft, fftshift
    >>> window = np.kaiser(51, 14***REMOVED***
    >>> plt.plot(window***REMOVED***
    [<matplotlib.lines.Line2D object at 0x...>***REMOVED***
    >>> plt.title("Kaiser window"***REMOVED***
    <matplotlib.text.Text object at 0x...>
    >>> plt.ylabel("Amplitude"***REMOVED***
    <matplotlib.text.Text object at 0x...>
    >>> plt.xlabel("Sample"***REMOVED***
    <matplotlib.text.Text object at 0x...>
    >>> plt.show(***REMOVED***

    >>> plt.figure(***REMOVED***
    <matplotlib.figure.Figure object at 0x...>
    >>> A = fft(window, 2048***REMOVED*** / 25.5
    >>> mag = np.abs(fftshift(A***REMOVED******REMOVED***
    >>> freq = np.linspace(-0.5, 0.5, len(A***REMOVED******REMOVED***
    >>> response = 20 * np.log10(mag***REMOVED***
    >>> response = np.clip(response, -100, 100***REMOVED***
    >>> plt.plot(freq, response***REMOVED***
    [<matplotlib.lines.Line2D object at 0x...>***REMOVED***
    >>> plt.title("Frequency response of Kaiser window"***REMOVED***
    <matplotlib.text.Text object at 0x...>
    >>> plt.ylabel("Magnitude [dB***REMOVED***"***REMOVED***
    <matplotlib.text.Text object at 0x...>
    >>> plt.xlabel("Normalized frequency [cycles per sample***REMOVED***"***REMOVED***
    <matplotlib.text.Text object at 0x...>
    >>> plt.axis('tight'***REMOVED***
    (-0.5, 0.5, -100.0, ...***REMOVED***
    >>> plt.show(***REMOVED***

    ***REMOVED***
    from numpy.dual import i0
    if M == 1:
        return np.array([1.***REMOVED******REMOVED***
    n = arange(0, M***REMOVED***
    alpha = (M-1***REMOVED***/2.0
    return i0(beta * sqrt(1-((n-alpha***REMOVED***/alpha***REMOVED*****2.0***REMOVED******REMOVED***/i0(float(beta***REMOVED******REMOVED***


def sinc(x***REMOVED***:
    ***REMOVED***
    Return the sinc function.

    The sinc function is :math:`\\sin(\\pi x***REMOVED***/(\\pi x***REMOVED***`.

    Parameters
    ----------
    x : ndarray
        Array (possibly multi-dimensional***REMOVED*** of values for which to to
        calculate ``sinc(x***REMOVED***``.

    Returns
    -------
    out : ndarray
        ``sinc(x***REMOVED***``, which has the same shape as the input.

    Notes
    -----
    ``sinc(0***REMOVED***`` is the limit value 1.

    The name sinc is short for "sine cardinal" or "sinus cardinalis".

    The sinc function is used in various signal processing applications,
    including in anti-aliasing, in the construction of a Lanczos resampling
    filter, and in interpolation.

    For bandlimited interpolation of discrete-time signals, the ideal
    interpolation kernel is proportional to the sinc function.

    References
    ----------
    .. [1***REMOVED*** Weisstein, Eric W. "Sinc Function." From MathWorld--A Wolfram Web
           Resource. http://mathworld.wolfram.com/SincFunction.html
    .. [2***REMOVED*** Wikipedia, "Sinc function",
           http://en.wikipedia.org/wiki/Sinc_function

    Examples
    --------
    >>> x = np.linspace(-4, 4, 41***REMOVED***
    >>> np.sinc(x***REMOVED***
    array([ -3.89804309e-17,  -4.92362781e-02,  -8.40918587e-02,
            -8.90384387e-02,  -5.84680802e-02,   3.89804309e-17,
             6.68206631e-02,   1.16434881e-01,   1.26137788e-01,
             8.50444803e-02,  -3.89804309e-17,  -1.03943254e-01,
            -1.89206682e-01,  -2.16236208e-01,  -1.55914881e-01,
             3.89804309e-17,   2.33872321e-01,   5.04551152e-01,
             7.56826729e-01,   9.35489284e-01,   1.00000000e+00,
             9.35489284e-01,   7.56826729e-01,   5.04551152e-01,
             2.33872321e-01,   3.89804309e-17,  -1.55914881e-01,
            -2.16236208e-01,  -1.89206682e-01,  -1.03943254e-01,
            -3.89804309e-17,   8.50444803e-02,   1.26137788e-01,
             1.16434881e-01,   6.68206631e-02,   3.89804309e-17,
            -5.84680802e-02,  -8.90384387e-02,  -8.40918587e-02,
            -4.92362781e-02,  -3.89804309e-17***REMOVED******REMOVED***

    >>> plt.plot(x, np.sinc(x***REMOVED******REMOVED***
    [<matplotlib.lines.Line2D object at 0x...>***REMOVED***
    >>> plt.title("Sinc Function"***REMOVED***
    <matplotlib.text.Text object at 0x...>
    >>> plt.ylabel("Amplitude"***REMOVED***
    <matplotlib.text.Text object at 0x...>
    >>> plt.xlabel("X"***REMOVED***
    <matplotlib.text.Text object at 0x...>
    >>> plt.show(***REMOVED***

    It works in 2-D as well:

    >>> x = np.linspace(-4, 4, 401***REMOVED***
    >>> xx = np.outer(x, x***REMOVED***
    >>> plt.imshow(np.sinc(xx***REMOVED******REMOVED***
    <matplotlib.image.AxesImage object at 0x...>

    ***REMOVED***
    x = np.asanyarray(x***REMOVED***
    y = pi * where(x == 0, 1.0e-20, x***REMOVED***
    return sin(y***REMOVED***/y


def msort(a***REMOVED***:
    ***REMOVED***
    Return a copy of an array sorted along the first axis.

    Parameters
    ----------
    a : array_like
        Array to be sorted.

    Returns
    -------
    sorted_array : ndarray
        Array of the same type and shape as `a`.

    See Also
    --------
    sort

    Notes
    -----
    ``np.msort(a***REMOVED***`` is equivalent to  ``np.sort(a, axis=0***REMOVED***``.

    ***REMOVED***
    b = array(a, subok=True, copy=True***REMOVED***
    b.sort(0***REMOVED***
    return b


def _ureduce(a, func, **kwargs***REMOVED***:
    ***REMOVED***
    Internal Function.
    Call `func` with `a` as first argument swapping the axes to use extended
    axis on functions that don't support it natively.

    Returns result and a.shape with axis dims set to 1.

    Parameters
    ----------
    a : array_like
        Input array or object that can be converted to an array.
    func : callable
        Reduction function Kapable of receiving an axis argument.
        It is is called with `a` as first argument followed by `kwargs`.
     kwargs : keyword arguments
        additional keyword arguments to pass to `func`.

    Returns
    -------
    result : tuple
        Result of func(a, **kwargs***REMOVED*** and a.shape with axis dims set to 1
        which can be used to reshape the result to the same shape a ufunc with
        keepdims=True would produce.

    ***REMOVED***
    a = np.asanyarray(a***REMOVED***
    axis = kwargs.get('axis', None***REMOVED***
    if axis is not None:
        keepdim = list(a.shape***REMOVED***
        nd = a.ndim
        ***REMOVED***
            axis = operator.index(axis***REMOVED***
            if axis >= nd or axis < -nd:
                raise IndexError("axis %d out of bounds (%d***REMOVED***" % (axis, a.ndim***REMOVED******REMOVED***
            keepdim[axis***REMOVED*** = 1
        except TypeError:
            sax = set(***REMOVED***
            for x in axis:
                if x >= nd or x < -nd:
                    raise IndexError("axis %d out of bounds (%d***REMOVED***" % (x, nd***REMOVED******REMOVED***
                if x in sax:
                    raise ValueError("duplicate value in axis"***REMOVED***
                sax.add(x % nd***REMOVED***
                keepdim[x***REMOVED*** = 1
            keep = sax.symmetric_difference(frozenset(range(nd***REMOVED******REMOVED******REMOVED***
            nkeep = len(keep***REMOVED***
            # swap axis that should not be reduced to front
            for i, s in enumerate(sorted(keep***REMOVED******REMOVED***:
                a = a.swapaxes(i, s***REMOVED***
            # merge reduced axis
            a = a.reshape(a.shape[:nkeep***REMOVED*** + (-1,***REMOVED******REMOVED***
            kwargs['axis'***REMOVED*** = -1
    else:
        keepdim = [1***REMOVED*** * a.ndim

    r = func(a, **kwargs***REMOVED***
    return r, keepdim


def median(a, axis=None, out=None, overwrite_input=False, keepdims=False***REMOVED***:
    ***REMOVED***
    Compute the median along the specified axis.

    Returns the median of the array elements.

    Parameters
    ----------
    a : array_like
        Input array or object that can be converted to an array.
    axis : {int, sequence of int, None***REMOVED***, optional
        Axis or axes along which the medians are computed. The default
        is to compute the median along a flattened version of the array.
        A sequence of axes is supported since version 1.9.0.
    out : ndarray, optional
        Alternative output array in which to place the result. It must
        have the same shape and buffer length as the expected output,
        but the type (of the output***REMOVED*** will be cast if necessary.
    overwrite_input : bool, optional
       If True, then allow use of memory of input array `a` for
       calculations. The input array will be modified by the call to
       `median`. This will save memory when you do not need to preserve
       the contents of the input array. Treat the input as undefined,
       but it will probably be fully or partially sorted. Default is
       False. If `overwrite_input` is ``True`` and `a` is not already an
       `ndarray`, an error will be raised.
    keepdims : bool, optional
        If this is set to True, the axes which are reduced are left
        in the result as dimensions with size one. With this option,
        the result will broadcast correctly against the original `arr`.

        .. versionadded:: 1.9.0

    Returns
    -------
    median : ndarray
        A new array holding the result. If the input contains integers
        or floats smaller than ``float64``, then the output data-type is
        ``np.float64``.  Otherwise, the data-type of the output is the
        same as that of the input. If `out` is specified, that array is
        returned instead.

    See Also
    --------
    mean, percentile

    Notes
    -----
    Given a vector ``V`` of length ``N``, the median of ``V`` is the
    middle value of a sorted copy of ``V``, ``V_sorted`` - i
    e., ``V_sorted[(N-1***REMOVED***/2***REMOVED***``, when ``N`` is odd, and the average of the
    two middle values of ``V_sorted`` when ``N`` is even.

    Examples
    --------
    >>> a = np.array([[10, 7, 4***REMOVED***, [3, 2, 1***REMOVED******REMOVED******REMOVED***
    >>> a
    array([[10,  7,  4***REMOVED***,
           [ 3,  2,  1***REMOVED******REMOVED******REMOVED***
    >>> np.median(a***REMOVED***
    3.5
    >>> np.median(a, axis=0***REMOVED***
    array([ 6.5,  4.5,  2.5***REMOVED******REMOVED***
    >>> np.median(a, axis=1***REMOVED***
    array([ 7.,  2.***REMOVED******REMOVED***
    >>> m = np.median(a, axis=0***REMOVED***
    >>> out = np.zeros_like(m***REMOVED***
    >>> np.median(a, axis=0, out=m***REMOVED***
    array([ 6.5,  4.5,  2.5***REMOVED******REMOVED***
    >>> m
    array([ 6.5,  4.5,  2.5***REMOVED******REMOVED***
    >>> b = a.copy(***REMOVED***
    >>> np.median(b, axis=1, overwrite_input=True***REMOVED***
    array([ 7.,  2.***REMOVED******REMOVED***
    >>> assert not np.all(a==b***REMOVED***
    >>> b = a.copy(***REMOVED***
    >>> np.median(b, axis=None, overwrite_input=True***REMOVED***
    3.5
    >>> assert not np.all(a==b***REMOVED***

    ***REMOVED***
    r, k = _ureduce(a, func=_median, axis=axis, out=out,
                    overwrite_input=overwrite_input***REMOVED***
    if keepdims:
        return r.reshape(k***REMOVED***
    else:
        return r

def _median(a, axis=None, out=None, overwrite_input=False***REMOVED***:
    # can't be reasonably be implemented in terms of percentile as we have to
    # call mean to not break astropy
    a = np.asanyarray(a***REMOVED***

    # Set the partition indexes
    if axis is None:
        sz = a.size
    else:
        sz = a.shape[axis***REMOVED***
    if sz % 2 == 0:
        szh = sz // 2
        kth = [szh - 1, szh***REMOVED***
    else:
        kth = [(sz - 1***REMOVED*** // 2***REMOVED***
    # Check if the array contains any nan's
    if np.issubdtype(a.dtype, np.inexact***REMOVED***:
        kth.append(-1***REMOVED***

    if overwrite_input:
        if axis is None:
            part = a.ravel(***REMOVED***
            part.partition(kth***REMOVED***
        else:
            a.partition(kth, axis=axis***REMOVED***
            part = a
    else:
        part = partition(a, kth, axis=axis***REMOVED***

    if part.shape == (***REMOVED***:
        # make 0-D arrays work
        return part.item(***REMOVED***
    if axis is None:
        axis = 0

    indexer = [slice(None***REMOVED******REMOVED*** * part.ndim
    index = part.shape[axis***REMOVED*** // 2
    if part.shape[axis***REMOVED*** % 2 == 1:
        # index with slice to allow mean (below***REMOVED*** to work
        indexer[axis***REMOVED*** = slice(index, index+1***REMOVED***
    else:
        indexer[axis***REMOVED*** = slice(index-1, index+1***REMOVED***

    # Check if the array contains any nan's
    if np.issubdtype(a.dtype, np.inexact***REMOVED*** and sz > 0:
        # warn and return nans like mean would
        rout = mean(part[indexer***REMOVED***, axis=axis, out=out***REMOVED***
        part = np.rollaxis(part, axis, part.ndim***REMOVED***
        n = np.isnan(part[..., -1***REMOVED******REMOVED***
        if rout.ndim == 0:
            if n == True:
                warnings.warn("Invalid value encountered in median",
                              RuntimeWarning***REMOVED***
                if out is not None:
                    out[...***REMOVED*** = a.dtype.type(np.nan***REMOVED***
                    rout = out
                else:
                    rout = a.dtype.type(np.nan***REMOVED***
        elif np.count_nonzero(n.ravel(***REMOVED******REMOVED*** > 0:
            warnings.warn("Invalid value encountered in median for" +
                          " %d results" % np.count_nonzero(n.ravel(***REMOVED******REMOVED***,
                          RuntimeWarning***REMOVED***
            rout[n***REMOVED*** = np.nan
        return rout
    else:
        # if there are no nans
        # Use mean in odd and even case to coerce data type
        # and check, use out array.
        return mean(part[indexer***REMOVED***, axis=axis, out=out***REMOVED***


def percentile(a, q, axis=None, out=None,
               overwrite_input=False, interpolation='linear', keepdims=False***REMOVED***:
    ***REMOVED***
    Compute the qth percentile of the data along the specified axis.

    Returns the qth percentile(s***REMOVED*** of the array elements.

    Parameters
    ----------
    a : array_like
        Input array or object that can be converted to an array.
    q : float in range of [0,100***REMOVED*** (or sequence of floats***REMOVED***
        Percentile to compute, which must be between 0 and 100 inclusive.
    axis : {int, sequence of int, None***REMOVED***, optional
        Axis or axes along which the percentiles are computed. The
        default is to compute the percentile(s***REMOVED*** along a flattened
        version of the array. A sequence of axes is supported since
        version 1.9.0.
    out : ndarray, optional
        Alternative output array in which to place the result. It must
        have the same shape and buffer length as the expected output,
        but the type (of the output***REMOVED*** will be cast if necessary.
    overwrite_input : bool, optional
        If True, then allow use of memory of input array `a` 
        calculations. The input array will be modified by the call to
        `percentile`. This will save memory when you do not need to
        preserve the contents of the input array. In this case you
        should not make any assumptions about the contents of the input
        `a` after this function completes -- treat it as undefined.
        Default is False. If `a` is not already an array, this parameter
        will have no effect as `a` will be converted to an array
        internally regardless of the value of this parameter.
    interpolation : {'linear', 'lower', 'higher', 'midpoint', 'nearest'***REMOVED***
        This optional parameter specifies the interpolation method to
        use when the desired quantile lies between two data points
        ``i < j``:
            * linear: ``i + (j - i***REMOVED*** * fraction``, where ``fraction``
              is the fractional part of the index surrounded by ``i``
              and ``j``.
            * lower: ``i``.
            * higher: ``j``.
            * nearest: ``i`` or ``j``, whichever is nearest.
            * midpoint: ``(i + j***REMOVED*** / 2``.

        .. versionadded:: 1.9.0
    keepdims : bool, optional
        If this is set to True, the axes which are reduced are left in
        the result as dimensions with size one. With this option, the
        result will broadcast correctly against the original array `a`.

        .. versionadded:: 1.9.0

    Returns
    -------
    percentile : scalar or ndarray
        If `q` is a single percentile and `axis=None`, then the result
        is a scalar. If multiple percentiles are given, first axis of
        the result corresponds to the percentiles. The other axes are
        the axes that remain after the reduction of `a`. If the input 
        contains integers or floats smaller than ``float64``, the output
        data-type is ``float64``. Otherwise, the output data-type is the
        same as that of the input. If `out` is specified, that array is
        returned instead.

    See Also
    --------
    mean, median, nanpercentile

    Notes
    -----
    Given a vector ``V`` of length ``N``, the ``q``-th percentile of
    ``V`` is the value ``q/100`` of the way from the mimumum to the
    maximum in in a sorted copy of ``V``. The values and distances of
    the two nearest neighbors as well as the `interpolation` parameter
    will determine the percentile if the normalized ranking does not
    match the location of ``q`` exactly. This function is the same as
    the median if ``q=50``, the same as the minimum if ``q=0`` and the
    same as the maximum if ``q=100``.

    Examples
    --------
    >>> a = np.array([[10, 7, 4***REMOVED***, [3, 2, 1***REMOVED******REMOVED******REMOVED***
    >>> a
    array([[10,  7,  4***REMOVED***,
           [ 3,  2,  1***REMOVED******REMOVED******REMOVED***
    >>> np.percentile(a, 50***REMOVED***
    3.5
    >>> np.percentile(a, 50, axis=0***REMOVED***
    array([[ 6.5,  4.5,  2.5***REMOVED******REMOVED******REMOVED***
    >>> np.percentile(a, 50, axis=1***REMOVED***
    array([ 7.,  2.***REMOVED******REMOVED***
    >>> np.percentile(a, 50, axis=1, keepdims=True***REMOVED***
    array([[ 7.***REMOVED***,
           [ 2.***REMOVED******REMOVED******REMOVED***

    >>> m = np.percentile(a, 50, axis=0***REMOVED***
    >>> out = np.zeros_like(m***REMOVED***
    >>> np.percentile(a, 50, axis=0, out=out***REMOVED***
    array([[ 6.5,  4.5,  2.5***REMOVED******REMOVED******REMOVED***
    >>> m
    array([[ 6.5,  4.5,  2.5***REMOVED******REMOVED******REMOVED***

    >>> b = a.copy(***REMOVED***
    >>> np.percentile(b, 50, axis=1, overwrite_input=True***REMOVED***
    array([ 7.,  2.***REMOVED******REMOVED***
    >>> assert not np.all(a == b***REMOVED***

    ***REMOVED***
    q = array(q, dtype=np.float64, copy=True***REMOVED***
    r, k = _ureduce(a, func=_percentile, q=q, axis=axis, out=out,
                    overwrite_input=overwrite_input,
                    interpolation=interpolation***REMOVED***
    if keepdims:
        if q.ndim == 0:
            return r.reshape(k***REMOVED***
        else:
            return r.reshape([len(q***REMOVED******REMOVED*** + k***REMOVED***
    else:
        return r


def _percentile(a, q, axis=None, out=None,
                overwrite_input=False, interpolation='linear', keepdims=False***REMOVED***:
    a = asarray(a***REMOVED***
    if q.ndim == 0:
        # Do not allow 0-d arrays because following code fails for scalar
        zerod = True
        q = q[None***REMOVED***
    else:
        zerod = False

    # avoid expensive reductions, relevant for arrays with < O(1000***REMOVED*** elements
    if q.size < 10:
        for i in range(q.size***REMOVED***:
            if q[i***REMOVED*** < 0. or q[i***REMOVED*** > 100.:
                raise ValueError("Percentiles must be in the range [0,100***REMOVED***"***REMOVED***
            q[i***REMOVED*** /= 100.
    else:
        # faster than any(***REMOVED***
        if np.count_nonzero(q < 0.***REMOVED*** or np.count_nonzero(q > 100.***REMOVED***:
            raise ValueError("Percentiles must be in the range [0,100***REMOVED***"***REMOVED***
        q /= 100.

    # prepare a for partioning
    if overwrite_input:
        if axis is None:
            ap = a.ravel(***REMOVED***
        else:
            ap = a
    else:
        if axis is None:
            ap = a.flatten(***REMOVED***
        else:
            ap = a.copy(***REMOVED***

    if axis is None:
        axis = 0

    Nx = ap.shape[axis***REMOVED***
    indices = q * (Nx - 1***REMOVED***

    # round fractional indices according to interpolation method
    if interpolation == 'lower':
        indices = floor(indices***REMOVED***.astype(intp***REMOVED***
    elif interpolation == 'higher':
        indices = ceil(indices***REMOVED***.astype(intp***REMOVED***
    elif interpolation == 'midpoint':
        indices = 0.5 * (floor(indices***REMOVED*** + ceil(indices***REMOVED******REMOVED***
    elif interpolation == 'nearest':
        indices = around(indices***REMOVED***.astype(intp***REMOVED***
    elif interpolation == 'linear':
        pass  # keep index as fraction and interpolate
    else:
        raise ValueError(
            "interpolation can only be 'linear', 'lower' 'higher', "
            "'midpoint', or 'nearest'"***REMOVED***

    n = np.array(False, dtype=bool***REMOVED*** # check for nan's flag
    if indices.dtype == intp:  # take the points along axis
        # Check if the array contains any nan's
        if np.issubdtype(a.dtype, np.inexact***REMOVED***:
            indices = concatenate((indices, [-1***REMOVED******REMOVED******REMOVED***

        ap.partition(indices, axis=axis***REMOVED***
        # ensure axis with qth is first
        ap = np.rollaxis(ap, axis, 0***REMOVED***
        axis = 0

        # Check if the array contains any nan's
        if np.issubdtype(a.dtype, np.inexact***REMOVED***:
            indices = indices[:-1***REMOVED***
            n = np.isnan(ap[-1:, ...***REMOVED******REMOVED***

        if zerod:
            indices = indices[0***REMOVED***
        r = take(ap, indices, axis=axis, out=out***REMOVED***


    else:  # weight the points above and below the indices
        indices_below = floor(indices***REMOVED***.astype(intp***REMOVED***
        indices_above = indices_below + 1
        indices_above[indices_above > Nx - 1***REMOVED*** = Nx - 1

        # Check if the array contains any nan's
        if np.issubdtype(a.dtype, np.inexact***REMOVED***:
            indices_above = concatenate((indices_above, [-1***REMOVED******REMOVED******REMOVED***

        weights_above = indices - indices_below
        weights_below = 1.0 - weights_above

        weights_shape = [1, ***REMOVED*** * ap.ndim
        weights_shape[axis***REMOVED*** = len(indices***REMOVED***
        weights_below.shape = weights_shape
        weights_above.shape = weights_shape

        ap.partition(concatenate((indices_below, indices_above***REMOVED******REMOVED***, axis=axis***REMOVED***

        # ensure axis with qth is first
        ap = np.rollaxis(ap, axis, 0***REMOVED***
        weights_below = np.rollaxis(weights_below, axis, 0***REMOVED***
        weights_above = np.rollaxis(weights_above, axis, 0***REMOVED***
        axis = 0

        # Check if the array contains any nan's
        if np.issubdtype(a.dtype, np.inexact***REMOVED***:
            indices_above = indices_above[:-1***REMOVED***
            n = np.isnan(ap[-1:, ...***REMOVED******REMOVED***

        x1 = take(ap, indices_below, axis=axis***REMOVED*** * weights_below
        x2 = take(ap, indices_above, axis=axis***REMOVED*** * weights_above

        # ensure axis with qth is first
        x1 = np.rollaxis(x1, axis, 0***REMOVED***
        x2 = np.rollaxis(x2, axis, 0***REMOVED***

        if zerod:
            x1 = x1.squeeze(0***REMOVED***
            x2 = x2.squeeze(0***REMOVED***

        if out is not None:
            r = add(x1, x2, out=out***REMOVED***
        else:
            r = add(x1, x2***REMOVED***

    if np.any(n***REMOVED***:
        warnings.warn("Invalid value encountered in percentile",
                              RuntimeWarning***REMOVED***
        if zerod:
            if ap.ndim == 1:
                if out is not None:
                    out[...***REMOVED*** = a.dtype.type(np.nan***REMOVED***
                    r = out
                else:
                    r = a.dtype.type(np.nan***REMOVED***
            else:
                r[..., n.squeeze(0***REMOVED******REMOVED*** = a.dtype.type(np.nan***REMOVED***
        else:
            if r.ndim == 1:
                r[:***REMOVED*** = a.dtype.type(np.nan***REMOVED***
            else:
                r[..., n.repeat(q.size, 0***REMOVED******REMOVED*** = a.dtype.type(np.nan***REMOVED***

    return r


def trapz(y, x=None, dx=1.0, axis=-1***REMOVED***:
    ***REMOVED***
    Integrate along the given axis using the composite trapezoidal rule.

    Integrate `y` (`x`***REMOVED*** along given axis.

    Parameters
    ----------
    y : array_like
        Input array to integrate.
    x : array_like, optional
        The sample points corresponding to the `y` values. If `x` is None,
        the sample points are assumed to be evenly spaced `dx` apart. The
        default is None.
    dx : scalar, optional
        The spacing between sample points when `x` is None. The default is 1.
    axis : int, optional
        The axis along which to integrate.

    Returns
    -------
    trapz : float
        Definite integral as approximated by trapezoidal rule.

    See Also
    --------
    sum, cumsum

    Notes
    -----
    Image [2***REMOVED***_ illustrates trapezoidal rule -- y-axis locations of points
    will be taken from `y` array, by default x-axis distances between
    points will be 1.0, alternatively they can be provided with `x` array
    or with `dx` scalar.  Return value will be equal to combined area under
    the red lines.


    References
    ----------
    .. [1***REMOVED*** Wikipedia page: http://en.wikipedia.org/wiki/Trapezoidal_rule

    .. [2***REMOVED*** Illustration image:
           http://en.wikipedia.org/wiki/File:Composite_trapezoidal_rule_illustration.png

    Examples
    --------
    >>> np.trapz([1,2,3***REMOVED******REMOVED***
    4.0
    >>> np.trapz([1,2,3***REMOVED***, x=[4,6,8***REMOVED******REMOVED***
    8.0
    >>> np.trapz([1,2,3***REMOVED***, dx=2***REMOVED***
    8.0
    >>> a = np.arange(6***REMOVED***.reshape(2, 3***REMOVED***
    >>> a
    array([[0, 1, 2***REMOVED***,
           [3, 4, 5***REMOVED******REMOVED******REMOVED***
    >>> np.trapz(a, axis=0***REMOVED***
    array([ 1.5,  2.5,  3.5***REMOVED******REMOVED***
    >>> np.trapz(a, axis=1***REMOVED***
    array([ 2.,  8.***REMOVED******REMOVED***

    ***REMOVED***
    y = asanyarray(y***REMOVED***
    if x is None:
        d = dx
    else:
        x = asanyarray(x***REMOVED***
        if x.ndim == 1:
            d = diff(x***REMOVED***
            # reshape to correct shape
            shape = [1***REMOVED****y.ndim
            shape[axis***REMOVED*** = d.shape[0***REMOVED***
            d = d.reshape(shape***REMOVED***
        else:
            d = diff(x, axis=axis***REMOVED***
    nd = len(y.shape***REMOVED***
    slice1 = [slice(None***REMOVED******REMOVED****nd
    slice2 = [slice(None***REMOVED******REMOVED****nd
    slice1[axis***REMOVED*** = slice(1, None***REMOVED***
    slice2[axis***REMOVED*** = slice(None, -1***REMOVED***
    ***REMOVED***
        ret = (d * (y[slice1***REMOVED*** + y[slice2***REMOVED******REMOVED*** / 2.0***REMOVED***.sum(axis***REMOVED***
    except ValueError:
        # Operations didn't work, cast to ndarray
        d = np.asarray(d***REMOVED***
        y = np.asarray(y***REMOVED***
        ret = add.reduce(d * (y[slice1***REMOVED***+y[slice2***REMOVED******REMOVED***/2.0, axis***REMOVED***
    return ret


#always succeed
def add_newdoc(place, obj, doc***REMOVED***:
    ***REMOVED***
    Adds documentation to obj which is in module place.

    If doc is a string add it to obj as a docstring

    If doc is a tuple, then the first element is interpreted as
       an attribute of obj and the second as the docstring
          (method, docstring***REMOVED***

    If doc is a list, then each element of the list should be a
       sequence of length two --> [(method1, docstring1***REMOVED***,
       (method2, docstring2***REMOVED***, ...***REMOVED***

    This routine never raises an error.

    This routine cannot modify read-only docstrings, as appear
    in new-style classes or built-in functions. Because this
    routine never raises an error the caller must check manually
    that the docstrings were changed.
    ***REMOVED***
    ***REMOVED***
        new = getattr(__import__(place, globals(***REMOVED***, {***REMOVED***, [obj***REMOVED******REMOVED***, obj***REMOVED***
        if isinstance(doc, str***REMOVED***:
            add_docstring(new, doc.strip(***REMOVED******REMOVED***
        elif isinstance(doc, tuple***REMOVED***:
            add_docstring(getattr(new, doc[0***REMOVED******REMOVED***, doc[1***REMOVED***.strip(***REMOVED******REMOVED***
        elif isinstance(doc, list***REMOVED***:
            for val in doc:
                add_docstring(getattr(new, val[0***REMOVED******REMOVED***, val[1***REMOVED***.strip(***REMOVED******REMOVED***
    ***REMOVED***
        pass


# Based on scitools meshgrid
def meshgrid(*xi, **kwargs***REMOVED***:
    ***REMOVED***
    Return coordinate matrices from coordinate vectors.

    Make N-D coordinate arrays for vectorized evaluations of
    N-D scalar/vector fields over N-D grids, given
    one-dimensional coordinate arrays x1, x2,..., xn.

    .. versionchanged:: 1.9
       1-D and 0-D cases are allowed.

    Parameters
    ----------
    x1, x2,..., xn : array_like
        1-D arrays representing the coordinates of a grid.
    indexing : {'xy', 'ij'***REMOVED***, optional
        Cartesian ('xy', default***REMOVED*** or matrix ('ij'***REMOVED*** indexing of output.
        See Notes for more details.

        .. versionadded:: 1.7.0
    sparse : bool, optional
        If True a sparse grid is returned in order to conserve memory.
        Default is False.

        .. versionadded:: 1.7.0
    copy : bool, optional
        If False, a view into the original arrays are returned in order to
        conserve memory.  Default is True.  Please note that
        ``sparse=False, copy=False`` will likely return non-contiguous
        arrays.  Furthermore, more than one element of a broadcast array
        may refer to a single memory location.  If you need to write to the
        arrays, make copies first.

        .. versionadded:: 1.7.0

    Returns
    -------
    X1, X2,..., XN : ndarray
        For vectors `x1`, `x2`,..., 'xn' with lengths ``Ni=len(xi***REMOVED***`` ,
        return ``(N1, N2, N3,...Nn***REMOVED***`` shaped arrays if indexing='ij'
        or ``(N2, N1, N3,...Nn***REMOVED***`` shaped arrays if indexing='xy'
        with the elements of `xi` repeated to fill the matrix along
        the first dimension for `x1`, the second for `x2` and so on.

    Notes
    -----
    This function supports both indexing conventions through the indexing
    keyword argument.  Giving the string 'ij' returns a meshgrid with
    matrix indexing, while 'xy' returns a meshgrid with Cartesian indexing.
    In the 2-D case with inputs of length M and N, the outputs are of shape
    (N, M***REMOVED*** for 'xy' indexing and (M, N***REMOVED*** for 'ij' indexing.  In the 3-D case
    with inputs of length M, N and P, outputs are of shape (N, M, P***REMOVED*** for
    'xy' indexing and (M, N, P***REMOVED*** for 'ij' indexing.  The difference is
    illustrated by the following code snippet::

        xv, yv = meshgrid(x, y, sparse=False, indexing='ij'***REMOVED***
        for i in range(nx***REMOVED***:
            for j in range(ny***REMOVED***:
                # treat xv[i,j***REMOVED***, yv[i,j***REMOVED***

        xv, yv = meshgrid(x, y, sparse=False, indexing='xy'***REMOVED***
        for i in range(nx***REMOVED***:
            for j in range(ny***REMOVED***:
                # treat xv[j,i***REMOVED***, yv[j,i***REMOVED***

    In the 1-D and 0-D case, the indexing and sparse keywords have no effect.

    See Also
    --------
    index_tricks.mgrid : Construct a multi-dimensional "meshgrid"
                     using indexing notation.
    index_tricks.ogrid : Construct an open multi-dimensional "meshgrid"
                     using indexing notation.

    Examples
    --------
    >>> nx, ny = (3, 2***REMOVED***
    >>> x = np.linspace(0, 1, nx***REMOVED***
    >>> y = np.linspace(0, 1, ny***REMOVED***
    >>> xv, yv = meshgrid(x, y***REMOVED***
    >>> xv
    array([[ 0. ,  0.5,  1. ***REMOVED***,
           [ 0. ,  0.5,  1. ***REMOVED******REMOVED******REMOVED***
    >>> yv
    array([[ 0.,  0.,  0.***REMOVED***,
           [ 1.,  1.,  1.***REMOVED******REMOVED******REMOVED***
    >>> xv, yv = meshgrid(x, y, sparse=True***REMOVED***  # make sparse output arrays
    >>> xv
    array([[ 0. ,  0.5,  1. ***REMOVED******REMOVED******REMOVED***
    >>> yv
    array([[ 0.***REMOVED***,
           [ 1.***REMOVED******REMOVED******REMOVED***

    `meshgrid` is very useful to evaluate functions on a grid.

    >>> x = np.arange(-5, 5, 0.1***REMOVED***
    >>> y = np.arange(-5, 5, 0.1***REMOVED***
    >>> xx, yy = meshgrid(x, y, sparse=True***REMOVED***
    >>> z = np.sin(xx**2 + yy**2***REMOVED*** / (xx**2 + yy**2***REMOVED***
    >>> h = plt.contourf(x,y,z***REMOVED***

    ***REMOVED***
    ndim = len(xi***REMOVED***

    copy_ = kwargs.pop('copy', True***REMOVED***
    sparse = kwargs.pop('sparse', False***REMOVED***
    indexing = kwargs.pop('indexing', 'xy'***REMOVED***

    if kwargs:
        raise TypeError("meshgrid(***REMOVED*** got an unexpected keyword argument '%s'"
                        % (list(kwargs***REMOVED***[0***REMOVED***,***REMOVED******REMOVED***

    if indexing not in ['xy', 'ij'***REMOVED***:
        raise ValueError(
            "Valid values for `indexing` are 'xy' and 'ij'."***REMOVED***

    s0 = (1,***REMOVED*** * ndim
    output = [np.asanyarray(x***REMOVED***.reshape(s0[:i***REMOVED*** + (-1,***REMOVED*** + s0[i + 1::***REMOVED******REMOVED***
              for i, x in enumerate(xi***REMOVED******REMOVED***

    shape = [x.size for x in output***REMOVED***

    if indexing == 'xy' and ndim > 1:
        # switch first and second axis
        output[0***REMOVED***.shape = (1, -1***REMOVED*** + (1,***REMOVED****(ndim - 2***REMOVED***
        output[1***REMOVED***.shape = (-1, 1***REMOVED*** + (1,***REMOVED****(ndim - 2***REMOVED***
        shape[0***REMOVED***, shape[1***REMOVED*** = shape[1***REMOVED***, shape[0***REMOVED***

    if sparse:
        if copy_:
            return [x.copy(***REMOVED*** for x in output***REMOVED***
        else:
            return output
    else:
        # Return the full N-D matrix (not only the 1-D vector***REMOVED***
        if copy_:
            mult_fact = np.ones(shape, dtype=int***REMOVED***
            return [x * mult_fact for x in output***REMOVED***
        else:
            return np.broadcast_arrays(*output***REMOVED***


def delete(arr, obj, axis=None***REMOVED***:
    ***REMOVED***
    Return a new array with sub-arrays along an axis deleted. For a one
    dimensional array, this returns those entries not returned by
    `arr[obj***REMOVED***`.

    Parameters
    ----------
    arr : array_like
      Input array.
    obj : slice, int or array of ints
      Indicate which sub-arrays to remove.
    axis : int, optional
      The axis along which to delete the subarray defined by `obj`.
      If `axis` is None, `obj` is applied to the flattened array.

    Returns
    -------
    out : ndarray
        A copy of `arr` with the elements specified by `obj` removed. Note
        that `delete` does not occur in-place. If `axis` is None, `out` is
        a flattened array.

    See Also
    --------
    insert : Insert elements into an array.
    append : Append elements at the end of an array.

    Notes
    -----
    Often it is preferable to use a boolean mask. For example:

    >>> mask = np.ones(len(arr***REMOVED***, dtype=bool***REMOVED***
    >>> mask[[0,2,4***REMOVED******REMOVED*** = False
    >>> result = arr[mask,...***REMOVED***

    Is equivalent to `np.delete(arr, [0,2,4***REMOVED***, axis=0***REMOVED***`, but allows further
    use of `mask`.

    Examples
    --------
    >>> arr = np.array([[1,2,3,4***REMOVED***, [5,6,7,8***REMOVED***, [9,10,11,12***REMOVED******REMOVED******REMOVED***
    >>> arr
    array([[ 1,  2,  3,  4***REMOVED***,
           [ 5,  6,  7,  8***REMOVED***,
           [ 9, 10, 11, 12***REMOVED******REMOVED******REMOVED***
    >>> np.delete(arr, 1, 0***REMOVED***
    array([[ 1,  2,  3,  4***REMOVED***,
           [ 9, 10, 11, 12***REMOVED******REMOVED******REMOVED***

    >>> np.delete(arr, np.s_[::2***REMOVED***, 1***REMOVED***
    array([[ 2,  4***REMOVED***,
           [ 6,  8***REMOVED***,
           [10, 12***REMOVED******REMOVED******REMOVED***
    >>> np.delete(arr, [1,3,5***REMOVED***, None***REMOVED***
    array([ 1,  3,  5,  7,  8,  9, 10, 11, 12***REMOVED******REMOVED***

    ***REMOVED***
    wrap = None
    if type(arr***REMOVED*** is not ndarray:
        ***REMOVED***
            wrap = arr.__array_wrap__
        except AttributeError:
            pass

    arr = asarray(arr***REMOVED***
    ndim = arr.ndim
    arrorder = 'F' if arr.flags.fnc else 'C'
    if axis is None:
        if ndim != 1:
            arr = arr.ravel(***REMOVED***
        ndim = arr.ndim
        axis = ndim - 1
    if ndim == 0:
        # 2013-09-24, 1.9
        warnings.warn(
            "in the future the special handling of scalars will be removed "
            "from delete and raise an error", DeprecationWarning***REMOVED***
        if wrap:
            return wrap(arr***REMOVED***
        else:
            return arr.copy(***REMOVED***

    slobj = [slice(None***REMOVED******REMOVED****ndim
    N = arr.shape[axis***REMOVED***
    newshape = list(arr.shape***REMOVED***

    if isinstance(obj, slice***REMOVED***:
        start, stop, step = obj.indices(N***REMOVED***
        xr = range(start, stop, step***REMOVED***
        numtodel = len(xr***REMOVED***

        if numtodel <= 0:
            if wrap:
                return wrap(arr.copy(***REMOVED******REMOVED***
            else:
                return arr.copy(***REMOVED***

        # Invert if step is negative:
        if step < 0:
            step = -step
            start = xr[-1***REMOVED***
            stop = xr[0***REMOVED*** + 1

        newshape[axis***REMOVED*** -= numtodel
        new = empty(newshape, arr.dtype, arrorder***REMOVED***
        # copy initial chunk
        if start == 0:
            pass
        else:
            slobj[axis***REMOVED*** = slice(None, start***REMOVED***
            new[slobj***REMOVED*** = arr[slobj***REMOVED***
        # copy end chunck
        if stop == N:
            pass
        else:
            slobj[axis***REMOVED*** = slice(stop-numtodel, None***REMOVED***
            slobj2 = [slice(None***REMOVED******REMOVED****ndim
            slobj2[axis***REMOVED*** = slice(stop, None***REMOVED***
            new[slobj***REMOVED*** = arr[slobj2***REMOVED***
        # copy middle pieces
        if step == 1:
            pass
        else:  # use array indexing.
            keep = ones(stop-start, dtype=bool***REMOVED***
            keep[:stop-start:step***REMOVED*** = False
            slobj[axis***REMOVED*** = slice(start, stop-numtodel***REMOVED***
            slobj2 = [slice(None***REMOVED******REMOVED****ndim
            slobj2[axis***REMOVED*** = slice(start, stop***REMOVED***
            arr = arr[slobj2***REMOVED***
            slobj2[axis***REMOVED*** = keep
            new[slobj***REMOVED*** = arr[slobj2***REMOVED***
        if wrap:
            return wrap(new***REMOVED***
        else:
            return new

    _obj = obj
    obj = np.asarray(obj***REMOVED***
    # After removing the special handling of booleans and out of
    # bounds values, the conversion to the array can be removed.
    if obj.dtype == bool:
        warnings.warn(
            "in the future insert will treat boolean arrays and array-likes "
            "as boolean index instead of casting it to integer", FutureWarning***REMOVED***
        obj = obj.astype(intp***REMOVED***
    if isinstance(_obj, (int, long, integer***REMOVED******REMOVED***:
        # optimization for a single value
        obj = obj.item(***REMOVED***
        if (obj < -N or obj >= N***REMOVED***:
            raise IndexError(
                "index %i is out of bounds for axis %i with "
                "size %i" % (obj, axis, N***REMOVED******REMOVED***
        if (obj < 0***REMOVED***:
            obj += N
        newshape[axis***REMOVED*** -= 1
        new = empty(newshape, arr.dtype, arrorder***REMOVED***
        slobj[axis***REMOVED*** = slice(None, obj***REMOVED***
        new[slobj***REMOVED*** = arr[slobj***REMOVED***
        slobj[axis***REMOVED*** = slice(obj, None***REMOVED***
        slobj2 = [slice(None***REMOVED******REMOVED****ndim
        slobj2[axis***REMOVED*** = slice(obj+1, None***REMOVED***
        new[slobj***REMOVED*** = arr[slobj2***REMOVED***
    else:
        if obj.size == 0 and not isinstance(_obj, np.ndarray***REMOVED***:
            obj = obj.astype(intp***REMOVED***
        if not np.can_cast(obj, intp, 'same_kind'***REMOVED***:
            # obj.size = 1 special case always failed and would just
            # give superfluous warnings.
            # 2013-09-24, 1.9
            warnings.warn(
                "using a non-integer array as obj in delete will result in an "
                "error in the future", DeprecationWarning***REMOVED***
            obj = obj.astype(intp***REMOVED***
        keep = ones(N, dtype=bool***REMOVED***

        # Test if there are out of bound indices, this is deprecated
        inside_bounds = (obj < N***REMOVED*** & (obj >= -N***REMOVED***
        if not inside_bounds.all(***REMOVED***:
            # 2013-09-24, 1.9
            warnings.warn(
                "in the future out of bounds indices will raise an error "
                "instead of being ignored by `numpy.delete`.",
                DeprecationWarning***REMOVED***
            obj = obj[inside_bounds***REMOVED***
        positive_indices = obj >= 0
        if not positive_indices.all(***REMOVED***:
            warnings.warn(
                "in the future negative indices will not be ignored by "
                "`numpy.delete`.", FutureWarning***REMOVED***
            obj = obj[positive_indices***REMOVED***

        keep[obj, ***REMOVED*** = False
        slobj[axis***REMOVED*** = keep
        new = arr[slobj***REMOVED***

    if wrap:
        return wrap(new***REMOVED***
    else:
        return new


def insert(arr, obj, values, axis=None***REMOVED***:
    ***REMOVED***
    Insert values along the given axis before the given indices.

    Parameters
    ----------
    arr : array_like
        Input array.
    obj : int, slice or sequence of ints
        Object that defines the index or indices before which `values` is
        inserted.

        .. versionadded:: 1.8.0

        Support for multiple insertions when `obj` is a single scalar or a
        sequence with one element (similar to calling insert multiple
        times***REMOVED***.
    values : array_like
        Values to insert into `arr`. If the type of `values` is different
        from that of `arr`, `values` is converted to the type of `arr`.
        `values` should be shaped so that ``arr[...,obj,...***REMOVED*** = values``
        is legal.
    axis : int, optional
        Axis along which to insert `values`.  If `axis` is None then `arr`
        is flattened first.

    Returns
    -------
    out : ndarray
        A copy of `arr` with `values` inserted.  Note that `insert`
        does not occur in-place: a new array is returned. If
        `axis` is None, `out` is a flattened array.

    See Also
    --------
    append : Append elements at the end of an array.
    concatenate : Join a sequence of arrays along an existing axis.
    delete : Delete elements from an array.

    Notes
    -----
    Note that for higher dimensional inserts `obj=0` behaves very different
    from `obj=[0***REMOVED***` just like `arr[:,0,:***REMOVED*** = values` is different from
    `arr[:,[0***REMOVED***,:***REMOVED*** = values`.

    Examples
    --------
    >>> a = np.array([[1, 1***REMOVED***, [2, 2***REMOVED***, [3, 3***REMOVED******REMOVED******REMOVED***
    >>> a
    array([[1, 1***REMOVED***,
           [2, 2***REMOVED***,
           [3, 3***REMOVED******REMOVED******REMOVED***
    >>> np.insert(a, 1, 5***REMOVED***
    array([1, 5, 1, 2, 2, 3, 3***REMOVED******REMOVED***
    >>> np.insert(a, 1, 5, axis=1***REMOVED***
    array([[1, 5, 1***REMOVED***,
           [2, 5, 2***REMOVED***,
           [3, 5, 3***REMOVED******REMOVED******REMOVED***

    Difference between sequence and scalars:

    >>> np.insert(a, [1***REMOVED***, [[1***REMOVED***,[2***REMOVED***,[3***REMOVED******REMOVED***, axis=1***REMOVED***
    array([[1, 1, 1***REMOVED***,
           [2, 2, 2***REMOVED***,
           [3, 3, 3***REMOVED******REMOVED******REMOVED***
    >>> np.array_equal(np.insert(a, 1, [1, 2, 3***REMOVED***, axis=1***REMOVED***,
    ...                np.insert(a, [1***REMOVED***, [[1***REMOVED***,[2***REMOVED***,[3***REMOVED******REMOVED***, axis=1***REMOVED******REMOVED***
    True

    >>> b = a.flatten(***REMOVED***
    >>> b
    array([1, 1, 2, 2, 3, 3***REMOVED******REMOVED***
    >>> np.insert(b, [2, 2***REMOVED***, [5, 6***REMOVED******REMOVED***
    array([1, 1, 5, 6, 2, 2, 3, 3***REMOVED******REMOVED***

    >>> np.insert(b, slice(2, 4***REMOVED***, [5, 6***REMOVED******REMOVED***
    array([1, 1, 5, 2, 6, 2, 3, 3***REMOVED******REMOVED***

    >>> np.insert(b, [2, 2***REMOVED***, [7.13, False***REMOVED******REMOVED*** # type casting
    array([1, 1, 7, 0, 2, 2, 3, 3***REMOVED******REMOVED***

    >>> x = np.arange(8***REMOVED***.reshape(2, 4***REMOVED***
    >>> idx = (1, 3***REMOVED***
    >>> np.insert(x, idx, 999, axis=1***REMOVED***
    array([[  0, 999,   1,   2, 999,   3***REMOVED***,
           [  4, 999,   5,   6, 999,   7***REMOVED******REMOVED******REMOVED***

    ***REMOVED***
    wrap = None
    if type(arr***REMOVED*** is not ndarray:
        ***REMOVED***
            wrap = arr.__array_wrap__
        except AttributeError:
            pass

    arr = asarray(arr***REMOVED***
    ndim = arr.ndim
    arrorder = 'F' if arr.flags.fnc else 'C'
    if axis is None:
        if ndim != 1:
            arr = arr.ravel(***REMOVED***
        ndim = arr.ndim
        axis = ndim - 1
    else:
        if ndim > 0 and (axis < -ndim or axis >= ndim***REMOVED***:
            raise IndexError(
                "axis %i is out of bounds for an array of "
                "dimension %i" % (axis, ndim***REMOVED******REMOVED***
        if (axis < 0***REMOVED***:
            axis += ndim
    if (ndim == 0***REMOVED***:
        # 2013-09-24, 1.9
        warnings.warn(
            "in the future the special handling of scalars will be removed "
            "from insert and raise an error", DeprecationWarning***REMOVED***
        arr = arr.copy(***REMOVED***
        arr[...***REMOVED*** = values
        if wrap:
            return wrap(arr***REMOVED***
        else:
            return arr
    slobj = [slice(None***REMOVED******REMOVED****ndim
    N = arr.shape[axis***REMOVED***
    newshape = list(arr.shape***REMOVED***

    if isinstance(obj, slice***REMOVED***:
        # turn it into a range object
        indices = arange(*obj.indices(N***REMOVED***, **{'dtype': intp***REMOVED******REMOVED***
    else:
        # need to copy obj, because indices will be changed in-place
        indices = np.array(obj***REMOVED***
        if indices.dtype == bool:
            # See also delete
            warnings.warn(
                "in the future insert will treat boolean arrays and "
                "array-likes as a boolean index instead of casting it to "
                "integer", FutureWarning***REMOVED***
            indices = indices.astype(intp***REMOVED***
            # Code after warning period:
            #if obj.ndim != 1:
            #    raise ValueError('boolean array argument obj to insert '
            #                     'must be one dimensional'***REMOVED***
            #indices = np.flatnonzero(obj***REMOVED***
        elif indices.ndim > 1:
            raise ValueError(
                "index array argument obj to insert must be one dimensional "
                "or scalar"***REMOVED***
    if indices.size == 1:
        index = indices.item(***REMOVED***
        if index < -N or index > N:
            raise IndexError(
                "index %i is out of bounds for axis %i with "
                "size %i" % (obj, axis, N***REMOVED******REMOVED***
        if (index < 0***REMOVED***:
            index += N

        # There are some object array corner cases here, but we cannot avoid
        # that:
        values = array(values, copy=False, ndmin=arr.ndim, dtype=arr.dtype***REMOVED***
        if indices.ndim == 0:
            # broadcasting is very different here, since a[:,0,:***REMOVED*** = ... behaves
            # very different from a[:,[0***REMOVED***,:***REMOVED*** = ...! This changes values so that
            # it works likes the second case. (here a[:,0:1,:***REMOVED******REMOVED***
            values = np.rollaxis(values, 0, (axis % values.ndim***REMOVED*** + 1***REMOVED***
        numnew = values.shape[axis***REMOVED***
        newshape[axis***REMOVED*** += numnew
        new = empty(newshape, arr.dtype, arrorder***REMOVED***
        slobj[axis***REMOVED*** = slice(None, index***REMOVED***
        new[slobj***REMOVED*** = arr[slobj***REMOVED***
        slobj[axis***REMOVED*** = slice(index, index+numnew***REMOVED***
        new[slobj***REMOVED*** = values
        slobj[axis***REMOVED*** = slice(index+numnew, None***REMOVED***
        slobj2 = [slice(None***REMOVED******REMOVED*** * ndim
        slobj2[axis***REMOVED*** = slice(index, None***REMOVED***
        new[slobj***REMOVED*** = arr[slobj2***REMOVED***
        if wrap:
            return wrap(new***REMOVED***
        return new
    elif indices.size == 0 and not isinstance(obj, np.ndarray***REMOVED***:
        # Can safely cast the empty list to intp
        indices = indices.astype(intp***REMOVED***

    if not np.can_cast(indices, intp, 'same_kind'***REMOVED***:
        # 2013-09-24, 1.9
        warnings.warn(
            "using a non-integer array as obj in insert will result in an "
            "error in the future", DeprecationWarning***REMOVED***
        indices = indices.astype(intp***REMOVED***

    indices[indices < 0***REMOVED*** += N

    numnew = len(indices***REMOVED***
    order = indices.argsort(kind='mergesort'***REMOVED***   # stable sort
    indices[order***REMOVED*** += np.arange(numnew***REMOVED***

    newshape[axis***REMOVED*** += numnew
    old_mask = ones(newshape[axis***REMOVED***, dtype=bool***REMOVED***
    old_mask[indices***REMOVED*** = False

    new = empty(newshape, arr.dtype, arrorder***REMOVED***
    slobj2 = [slice(None***REMOVED******REMOVED****ndim
    slobj[axis***REMOVED*** = indices
    slobj2[axis***REMOVED*** = old_mask
    new[slobj***REMOVED*** = values
    new[slobj2***REMOVED*** = arr

    if wrap:
        return wrap(new***REMOVED***
    return new


def append(arr, values, axis=None***REMOVED***:
    ***REMOVED***
    Append values to the end of an array.

    Parameters
    ----------
    arr : array_like
        Values are appended to a copy of this array.
    values : array_like
        These values are appended to a copy of `arr`.  It must be of the
        correct shape (the same shape as `arr`, excluding `axis`***REMOVED***.  If
        `axis` is not specified, `values` can be any shape and will be
        flattened before use.
    axis : int, optional
        The axis along which `values` are appended.  If `axis` is not
        given, both `arr` and `values` are flattened before use.

    Returns
    -------
    append : ndarray
        A copy of `arr` with `values` appended to `axis`.  Note that
        `append` does not occur in-place: a new array is allocated and
        filled.  If `axis` is None, `out` is a flattened array.

    See Also
    --------
    insert : Insert elements into an array.
    delete : Delete elements from an array.

    Examples
    --------
    >>> np.append([1, 2, 3***REMOVED***, [[4, 5, 6***REMOVED***, [7, 8, 9***REMOVED******REMOVED******REMOVED***
    array([1, 2, 3, 4, 5, 6, 7, 8, 9***REMOVED******REMOVED***

    When `axis` is specified, `values` must have the correct shape.

    >>> np.append([[1, 2, 3***REMOVED***, [4, 5, 6***REMOVED******REMOVED***, [[7, 8, 9***REMOVED******REMOVED***, axis=0***REMOVED***
    array([[1, 2, 3***REMOVED***,
           [4, 5, 6***REMOVED***,
           [7, 8, 9***REMOVED******REMOVED******REMOVED***
    >>> np.append([[1, 2, 3***REMOVED***, [4, 5, 6***REMOVED******REMOVED***, [7, 8, 9***REMOVED***, axis=0***REMOVED***
    Traceback (most recent call last***REMOVED***:
    ...
    ValueError: arrays must have same number of dimensions

    ***REMOVED***
    arr = asanyarray(arr***REMOVED***
    if axis is None:
        if arr.ndim != 1:
            arr = arr.ravel(***REMOVED***
        values = ravel(values***REMOVED***
        axis = arr.ndim-1
    return concatenate((arr, values***REMOVED***, axis=axis***REMOVED***

