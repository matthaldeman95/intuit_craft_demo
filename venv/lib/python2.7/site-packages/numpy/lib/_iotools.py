***REMOVED***A collection of functions designed to help I/O with ascii files.

***REMOVED***
from __future__ import division, absolute_import, print_function

__docformat__ = "restructuredtext en"

import sys
import numpy as np
import numpy.core.numeric as nx
from numpy.compat import asbytes, bytes, asbytes_nested, basestring

if sys.version_info[0***REMOVED*** >= 3:
    from builtins import bool, int, float, complex, object, str
    unicode = str
else:
    from __builtin__ import bool, int, float, complex, object, unicode, str


if sys.version_info[0***REMOVED*** >= 3:
    def _bytes_to_complex(s***REMOVED***:
        return complex(s.decode('ascii'***REMOVED******REMOVED***

    def _bytes_to_name(s***REMOVED***:
        return s.decode('ascii'***REMOVED***
else:
    _bytes_to_complex = complex
    _bytes_to_name = str


def _is_string_like(obj***REMOVED***:
    ***REMOVED***
    Check whether obj behaves like a string.
    ***REMOVED***
    ***REMOVED***
        obj + ''
    except (TypeError, ValueError***REMOVED***:
        return False
    return True


def _is_bytes_like(obj***REMOVED***:
    ***REMOVED***
    Check whether obj behaves like a bytes object.
    ***REMOVED***
    ***REMOVED***
        obj + asbytes(''***REMOVED***
    except (TypeError, ValueError***REMOVED***:
        return False
    return True


def _to_filehandle(fname, flag='r', return_opened=False***REMOVED***:
    ***REMOVED***
    Returns the filehandle corresponding to a string or a file.
    If the string ends in '.gz', the file is automatically unzipped.

    Parameters
    ----------
    fname : string, filehandle
        Name of the file whose filehandle must be returned.
    flag : string, optional
        Flag indicating the status of the file ('r' for read, 'w' for write***REMOVED***.
    return_opened : boolean, optional
        Whether to return the opening status of the file.
    ***REMOVED***
    if _is_string_like(fname***REMOVED***:
        if fname.endswith('.gz'***REMOVED***:
            import gzip
            fhd = gzip.open(fname, flag***REMOVED***
        elif fname.endswith('.bz2'***REMOVED***:
            import bz2
            fhd = bz2.BZ2File(fname***REMOVED***
        else:
            fhd = file(fname, flag***REMOVED***
        opened = True
    elif hasattr(fname, 'seek'***REMOVED***:
        fhd = fname
        opened = False
    else:
        raise ValueError('fname must be a string or file handle'***REMOVED***
    if return_opened:
        return fhd, opened
    return fhd


def has_nested_fields(ndtype***REMOVED***:
    ***REMOVED***
    Returns whether one or several fields of a dtype are nested.

    Parameters
    ----------
    ndtype : dtype
        Data-type of a structured array.

    Raises
    ------
    AttributeError
        If `ndtype` does not have a `names` attribute.

    Examples
    --------
    >>> dt = np.dtype([('name', 'S4'***REMOVED***, ('x', float***REMOVED***, ('y', float***REMOVED******REMOVED******REMOVED***
    >>> np.lib._iotools.has_nested_fields(dt***REMOVED***
    False

    ***REMOVED***
    for name in ndtype.names or (***REMOVED***:
        if ndtype[name***REMOVED***.names:
            return True
    return False


def flatten_dtype(ndtype, flatten_base=False***REMOVED***:
    ***REMOVED***
    Unpack a structured data-type by collapsing nested fields and/or fields
    with a shape.

    Note that the field names are lost.

    Parameters
    ----------
    ndtype : dtype
        The datatype to collapse
    flatten_base : {False, True***REMOVED***, optional
        Whether to transform a field with a shape into several fields or not.

    Examples
    --------
    >>> dt = np.dtype([('name', 'S4'***REMOVED***, ('x', float***REMOVED***, ('y', float***REMOVED***,
    ...                ('block', int, (2, 3***REMOVED******REMOVED******REMOVED******REMOVED***
    >>> np.lib._iotools.flatten_dtype(dt***REMOVED***
    [dtype('|S4'***REMOVED***, dtype('float64'***REMOVED***, dtype('float64'***REMOVED***, dtype('int32'***REMOVED******REMOVED***
    >>> np.lib._iotools.flatten_dtype(dt, flatten_base=True***REMOVED***
    [dtype('|S4'***REMOVED***, dtype('float64'***REMOVED***, dtype('float64'***REMOVED***, dtype('int32'***REMOVED***,
     dtype('int32'***REMOVED***, dtype('int32'***REMOVED***, dtype('int32'***REMOVED***, dtype('int32'***REMOVED***,
     dtype('int32'***REMOVED******REMOVED***

    ***REMOVED***
    names = ndtype.names
    if names is None:
        if flatten_base:
            return [ndtype.base***REMOVED*** * int(np.prod(ndtype.shape***REMOVED******REMOVED***
        return [ndtype.base***REMOVED***
    else:
        types = [***REMOVED***
        for field in names:
            info = ndtype.fields[field***REMOVED***
            flat_dt = flatten_dtype(info[0***REMOVED***, flatten_base***REMOVED***
            types.extend(flat_dt***REMOVED***
        return types


class LineSplitter(object***REMOVED***:
    ***REMOVED***
    Object to split a string at a given delimiter or at given places.

    Parameters
    ----------
    delimiter : str, int, or sequence of ints, optional
        If a string, character used to delimit consecutive fields.
        If an integer or a sequence of integers, width(s***REMOVED*** of each field.
    comments : str, optional
        Character used to mark the beginning of a comment. Default is '#'.
    autostrip : bool, optional
        Whether to strip each individual field. Default is True.

    ***REMOVED***

    def autostrip(self, method***REMOVED***:
        ***REMOVED***
        Wrapper to strip each member of the output of `method`.

        Parameters
        ----------
        method : function
            Function that takes a single argument and returns a sequence of
            strings.

        Returns
        -------
        wrapped : function
            The result of wrapping `method`. `wrapped` takes a single input
            argument and returns a list of strings that are stripped of
            white-space.

        ***REMOVED***
        return lambda input: [_.strip(***REMOVED*** for _ in method(input***REMOVED******REMOVED***
    #

    def __init__(self, delimiter=None, comments=asbytes('#'***REMOVED***, autostrip=True***REMOVED***:
        self.comments = comments
        # Delimiter is a character
        if isinstance(delimiter, unicode***REMOVED***:
            delimiter = delimiter.encode('ascii'***REMOVED***
        if (delimiter is None***REMOVED*** or _is_bytes_like(delimiter***REMOVED***:
            delimiter = delimiter or None
            _handyman = self._delimited_splitter
        # Delimiter is a list of field widths
        elif hasattr(delimiter, '__iter__'***REMOVED***:
            _handyman = self._variablewidth_splitter
            idx = np.cumsum([0***REMOVED*** + list(delimiter***REMOVED******REMOVED***
            delimiter = [slice(i, j***REMOVED*** for (i, j***REMOVED*** in zip(idx[:-1***REMOVED***, idx[1:***REMOVED******REMOVED******REMOVED***
        # Delimiter is a single integer
        elif int(delimiter***REMOVED***:
            (_handyman, delimiter***REMOVED*** = (
                    self._fixedwidth_splitter, int(delimiter***REMOVED******REMOVED***
        else:
            (_handyman, delimiter***REMOVED*** = (self._delimited_splitter, None***REMOVED***
        self.delimiter = delimiter
        if autostrip:
            self._handyman = self.autostrip(_handyman***REMOVED***
        else:
            self._handyman = _handyman
    #

    def _delimited_splitter(self, line***REMOVED***:
        if self.comments is not None:
            line = line.split(self.comments***REMOVED***[0***REMOVED***
        line = line.strip(asbytes(" \r\n"***REMOVED******REMOVED***
        if not line:
            return [***REMOVED***
        return line.split(self.delimiter***REMOVED***
    #

    def _fixedwidth_splitter(self, line***REMOVED***:
        if self.comments is not None:
            line = line.split(self.comments***REMOVED***[0***REMOVED***
        line = line.strip(asbytes("\r\n"***REMOVED******REMOVED***
        if not line:
            return [***REMOVED***
        fixed = self.delimiter
        slices = [slice(i, i + fixed***REMOVED*** for i in range(0, len(line***REMOVED***, fixed***REMOVED******REMOVED***
        return [line[s***REMOVED*** for s in slices***REMOVED***
    #

    def _variablewidth_splitter(self, line***REMOVED***:
        if self.comments is not None:
            line = line.split(self.comments***REMOVED***[0***REMOVED***
        if not line:
            return [***REMOVED***
        slices = self.delimiter
        return [line[s***REMOVED*** for s in slices***REMOVED***
    #

    def __call__(self, line***REMOVED***:
        return self._handyman(line***REMOVED***


class NameValidator(object***REMOVED***:
    ***REMOVED***
    Object to validate a list of strings to use as field names.

    The strings are stripped of any non alphanumeric character, and spaces
    are replaced by '_'. During instantiation, the user can define a list
    of names to exclude, as well as a list of invalid characters. Names in
    the exclusion list are appended a '_' character.

    Once an instance has been created, it can be called with a list of
    names, and a list of valid names will be created.  The `__call__`
    method accepts an optional keyword "default" that sets the default name
    in case of ambiguity. By default this is 'f', so that names will
    default to `f0`, `f1`, etc.

    Parameters
    ----------
    excludelist : sequence, optional
        A list of names to exclude. This list is appended to the default
        list ['return', 'file', 'print'***REMOVED***. Excluded names are appended an
        underscore: for example, `file` becomes `file_` if supplied.
    deletechars : str, optional
        A string combining invalid characters that must be deleted from the
        names.
    case_sensitive : {True, False, 'upper', 'lower'***REMOVED***, optional
        * If True, field names are case-sensitive.
        * If False or 'upper', field names are converted to upper case.
        * If 'lower', field names are converted to lower case.

        The default value is True.
    replace_space : '_', optional
        Character(s***REMOVED*** used in replacement of white spaces.

    Notes
    -----
    Calling an instance of `NameValidator` is the same as calling its
    method `validate`.

    Examples
    --------
    >>> validator = np.lib._iotools.NameValidator(***REMOVED***
    >>> validator(['file', 'field2', 'with space', 'CaSe'***REMOVED******REMOVED***
    ['file_', 'field2', 'with_space', 'CaSe'***REMOVED***

    >>> validator = np.lib._iotools.NameValidator(excludelist=['excl'***REMOVED***,
                                                  deletechars='q',
                                                  case_sensitive='False'***REMOVED***
    >>> validator(['excl', 'field2', 'no_q', 'with space', 'CaSe'***REMOVED******REMOVED***
    ['excl_', 'field2', 'no_', 'with_space', 'case'***REMOVED***

    ***REMOVED***
    #
    defaultexcludelist = ['return', 'file', 'print'***REMOVED***
    defaultdeletechars = set(***REMOVED***~!@#$%^&*(***REMOVED***-=+~\|***REMOVED******REMOVED***[{';: /?.>,<***REMOVED******REMOVED***
    #

    def __init__(self, excludelist=None, deletechars=None,
                 case_sensitive=None, replace_space='_'***REMOVED***:
        # Process the exclusion list ..
        if excludelist is None:
            excludelist = [***REMOVED***
        excludelist.extend(self.defaultexcludelist***REMOVED***
        self.excludelist = excludelist
        # Process the list of characters to delete
        if deletechars is None:
            delete = self.defaultdeletechars
        else:
            delete = set(deletechars***REMOVED***
        delete.add('"'***REMOVED***
        self.deletechars = delete
        # Process the case option .....
        if (case_sensitive is None***REMOVED*** or (case_sensitive is True***REMOVED***:
            self.case_converter = lambda x: x
        elif (case_sensitive is False***REMOVED*** or case_sensitive.startswith('u'***REMOVED***:
            self.case_converter = lambda x: x.upper(***REMOVED***
        elif case_sensitive.startswith('l'***REMOVED***:
            self.case_converter = lambda x: x.lower(***REMOVED***
        else:
            msg = 'unrecognized case_sensitive value %s.' % case_sensitive
            raise ValueError(msg***REMOVED***
        #
        self.replace_space = replace_space

    def validate(self, names, defaultfmt="f%i", nbfields=None***REMOVED***:
        ***REMOVED***
        Validate a list of strings as field names for a structured array.

        Parameters
        ----------
        names : sequence of str
            Strings to be validated.
        defaultfmt : str, optional
            Default format string, used if validating a given string
            reduces its length to zero.
        nbfields : integer, optional
            Final number of validated names, used to expand or shrink the
            initial list of names.

        Returns
        -------
        validatednames : list of str
            The list of validated field names.

        Notes
        -----
        A `NameValidator` instance can be called directly, which is the
        same as calling `validate`. For examples, see `NameValidator`.

        ***REMOVED***
        # Initial checks ..............
        if (names is None***REMOVED***:
            if (nbfields is None***REMOVED***:
                return None
            names = [***REMOVED***
        if isinstance(names, basestring***REMOVED***:
            names = [names, ***REMOVED***
        if nbfields is not None:
            nbnames = len(names***REMOVED***
            if (nbnames < nbfields***REMOVED***:
                names = list(names***REMOVED*** + [''***REMOVED*** * (nbfields - nbnames***REMOVED***
            elif (nbnames > nbfields***REMOVED***:
                names = names[:nbfields***REMOVED***
        # Set some shortcuts ...........
        deletechars = self.deletechars
        excludelist = self.excludelist
        case_converter = self.case_converter
        replace_space = self.replace_space
        # Initializes some variables ...
        validatednames = [***REMOVED***
        seen = dict(***REMOVED***
        nbempty = 0
        #
        for item in names:
            item = case_converter(item***REMOVED***.strip(***REMOVED***
            if replace_space:
                item = item.replace(' ', replace_space***REMOVED***
            item = ''.join([c for c in item if c not in deletechars***REMOVED******REMOVED***
            if item == '':
                item = defaultfmt % nbempty
                while item in names:
                    nbempty += 1
                    item = defaultfmt % nbempty
                nbempty += 1
            elif item in excludelist:
                item += '_'
            cnt = seen.get(item, 0***REMOVED***
            if cnt > 0:
                validatednames.append(item + '_%d' % cnt***REMOVED***
            else:
                validatednames.append(item***REMOVED***
            seen[item***REMOVED*** = cnt + 1
        return tuple(validatednames***REMOVED***
    #

    def __call__(self, names, defaultfmt="f%i", nbfields=None***REMOVED***:
        return self.validate(names, defaultfmt=defaultfmt, nbfields=nbfields***REMOVED***


def str2bool(value***REMOVED***:
    ***REMOVED***
    Tries to transform a string supposed to represent a boolean to a boolean.

    Parameters
    ----------
    value : str
        The string that is transformed to a boolean.

    Returns
    -------
    boolval : bool
        The boolean representation of `value`.

    Raises
    ------
    ValueError
        If the string is not 'True' or 'False' (case independent***REMOVED***

    Examples
    --------
    >>> np.lib._iotools.str2bool('TRUE'***REMOVED***
    True
    >>> np.lib._iotools.str2bool('false'***REMOVED***
    False

    ***REMOVED***
    value = value.upper(***REMOVED***
    if value == asbytes('TRUE'***REMOVED***:
        return True
    elif value == asbytes('FALSE'***REMOVED***:
        return False
    else:
        raise ValueError("Invalid boolean"***REMOVED***


class ConverterError(Exception***REMOVED***:
    ***REMOVED***
    Exception raised when an error occurs in a converter for string values.

    ***REMOVED***
    pass


class ConverterLockError(ConverterError***REMOVED***:
    ***REMOVED***
    Exception raised when an attempt is made to upgrade a locked converter.

    ***REMOVED***
    pass


class ConversionWarning(UserWarning***REMOVED***:
    ***REMOVED***
    Warning issued when a string converter has a problem.

    Notes
    -----
    In `genfromtxt` a `ConversionWarning` is issued if raising exceptions
    is explicitly suppressed with the "invalid_raise" keyword.

    ***REMOVED***
    pass


class StringConverter(object***REMOVED***:
    ***REMOVED***
    Factory class for function transforming a string into another object
    (int, float***REMOVED***.

    After initialization, an instance can be called to transform a string
    into another object. If the string is recognized as representing a
    missing value, a default value is returned.

    Attributes
    ----------
    func : function
        Function used for the conversion.
    default : any
        Default value to return when the input corresponds to a missing
        value.
    type : type
        Type of the output.
    _status : int
        Integer representing the order of the conversion.
    _mapper : sequence of tuples
        Sequence of tuples (dtype, function, default value***REMOVED*** to evaluate in
        order.
    _locked : bool
        Holds `locked` parameter.

    Parameters
    ----------
    dtype_or_func : {None, dtype, function***REMOVED***, optional
        If a `dtype`, specifies the input data type, used to define a basic
        function and a default value for missing data. For example, when
        `dtype` is float, the `func` attribute is set to `float` and the
        default value to `np.nan`.  If a function, this function is used to
        convert a string to another object. In this case, it is recommended
        to give an associated default value as input.
    default : any, optional
        Value to return by default, that is, when the string to be
        converted is flagged as missing. If not given, `StringConverter`
        tries to supply a reasonable default value.
    missing_values : sequence of str, optional
        Sequence of strings indicating a missing value.
    locked : bool, optional
        Whether the StringConverter should be locked to prevent automatic
        upgrade or not. Default is False.

    ***REMOVED***
    #
    _mapper = [(nx.bool_, str2bool, False***REMOVED***,
               (nx.integer, int, -1***REMOVED******REMOVED***

    # On 32-bit systems, we need to make sure that we explicitly include
    # nx.int64 since ns.integer is nx.int32.
    if nx.dtype(nx.integer***REMOVED***.itemsize < nx.dtype(nx.int64***REMOVED***.itemsize:
        _mapper.append((nx.int64, int, -1***REMOVED******REMOVED***

    _mapper.extend([(nx.floating, float, nx.nan***REMOVED***,
                    (complex, _bytes_to_complex, nx.nan + 0j***REMOVED***,
                    (nx.longdouble, nx.longdouble, nx.nan***REMOVED***,
                    (nx.string_, bytes, asbytes('???'***REMOVED******REMOVED******REMOVED******REMOVED***

    (_defaulttype, _defaultfunc, _defaultfill***REMOVED*** = zip(*_mapper***REMOVED***

    @classmethod
    def _getdtype(cls, val***REMOVED***:
        ***REMOVED***Returns the dtype of the input variable.***REMOVED***
        return np.array(val***REMOVED***.dtype
    #

    @classmethod
    def _getsubdtype(cls, val***REMOVED***:
        ***REMOVED***Returns the type of the dtype of the input variable.***REMOVED***
        return np.array(val***REMOVED***.dtype.type
    #
    # This is a bit annoying. We want to return the "general" type in most
    # cases (ie. "string" rather than "S10"***REMOVED***, but we want to return the
    # specific type for datetime64 (ie. "datetime64[us***REMOVED***" rather than
    # "datetime64"***REMOVED***.

    @classmethod
    def _dtypeortype(cls, dtype***REMOVED***:
        ***REMOVED***Returns dtype for datetime64 and type of dtype otherwise.***REMOVED***
        if dtype.type == np.datetime64:
            return dtype
        return dtype.type
    #

    @classmethod
    def upgrade_mapper(cls, func, default=None***REMOVED***:
        ***REMOVED***
    Upgrade the mapper of a StringConverter by adding a new function and
    its corresponding default.

    The input function (or sequence of functions***REMOVED*** and its associated
    default value (if any***REMOVED*** is inserted in penultimate position of the
    mapper.  The corresponding type is estimated from the dtype of the
    default value.

    Parameters
    ----------
    func : var
        Function, or sequence of functions

    Examples
    --------
    >>> import dateutil.parser
    >>> import datetime
    >>> dateparser = datetustil.parser.parse
    >>> defaultdate = datetime.date(2000, 1, 1***REMOVED***
    >>> StringConverter.upgrade_mapper(dateparser, default=defaultdate***REMOVED***
        ***REMOVED***
        # Func is a single functions
        if hasattr(func, '__call__'***REMOVED***:
            cls._mapper.insert(-1, (cls._getsubdtype(default***REMOVED***, func, default***REMOVED******REMOVED***
            return
        elif hasattr(func, '__iter__'***REMOVED***:
            if isinstance(func[0***REMOVED***, (tuple, list***REMOVED******REMOVED***:
                for _ in func:
                    cls._mapper.insert(-1, _***REMOVED***
                return
            if default is None:
                default = [None***REMOVED*** * len(func***REMOVED***
            else:
                default = list(default***REMOVED***
                default.append([None***REMOVED*** * (len(func***REMOVED*** - len(default***REMOVED******REMOVED******REMOVED***
            for (fct, dft***REMOVED*** in zip(func, default***REMOVED***:
                cls._mapper.insert(-1, (cls._getsubdtype(dft***REMOVED***, fct, dft***REMOVED******REMOVED***
    #

    def __init__(self, dtype_or_func=None, default=None, missing_values=None,
                 locked=False***REMOVED***:
        # Convert unicode (for Py3***REMOVED***
        if isinstance(missing_values, unicode***REMOVED***:
            missing_values = asbytes(missing_values***REMOVED***
        elif isinstance(missing_values, (list, tuple***REMOVED******REMOVED***:
            missing_values = asbytes_nested(missing_values***REMOVED***
        # Defines a lock for upgrade
        self._locked = bool(locked***REMOVED***
        # No input dtype: minimal initialization
        if dtype_or_func is None:
            self.func = str2bool
            self._status = 0
            self.default = default or False
            dtype = np.dtype('bool'***REMOVED***
        else:
            # Is the input a np.dtype ?
            ***REMOVED***
                self.func = None
                dtype = np.dtype(dtype_or_func***REMOVED***
            except TypeError:
                # dtype_or_func must be a function, then
                if not hasattr(dtype_or_func, '__call__'***REMOVED***:
                    errmsg = ("The input argument `dtype` is neither a"
                              " function nor a dtype (got '%s' instead***REMOVED***"***REMOVED***
                    raise TypeError(errmsg % type(dtype_or_func***REMOVED******REMOVED***
                # Set the function
                self.func = dtype_or_func
                # If we don't have a default, try to guess it or set it to
                # None
                if default is None:
                    ***REMOVED***
                        default = self.func(asbytes('0'***REMOVED******REMOVED***
                    except ValueError:
                        default = None
                dtype = self._getdtype(default***REMOVED***
            # Set the status according to the dtype
            _status = -1
            for (i, (deftype, func, default_def***REMOVED******REMOVED*** in enumerate(self._mapper***REMOVED***:
                if np.issubdtype(dtype.type, deftype***REMOVED***:
                    _status = i
                    if default is None:
                        self.default = default_def
                    else:
                        self.default = default
                    break
            # if a converter for the specific dtype is available use that
            last_func = func
            for (i, (deftype, func, default_def***REMOVED******REMOVED*** in enumerate(self._mapper***REMOVED***:
                if dtype.type == deftype:
                    _status = i
                    last_func = func
                    if default is None:
                        self.default = default_def
                    else:
                        self.default = default
                    break
            func = last_func
            if _status == -1:
                # We never found a match in the _mapper...
                _status = 0
                self.default = default
            self._status = _status
            # If the input was a dtype, set the function to the last we saw
            if self.func is None:
                self.func = func
            # If the status is 1 (int***REMOVED***, change the function to
            # something more robust.
            if self.func == self._mapper[1***REMOVED***[1***REMOVED***:
                if issubclass(dtype.type, np.uint64***REMOVED***:
                    self.func = np.uint64
                elif issubclass(dtype.type, np.int64***REMOVED***:
                    self.func = np.int64
                else:
                    self.func = lambda x: int(float(x***REMOVED******REMOVED***
        # Store the list of strings corresponding to missing values.
        if missing_values is None:
            self.missing_values = set([asbytes(''***REMOVED******REMOVED******REMOVED***
        else:
            if isinstance(missing_values, bytes***REMOVED***:
                missing_values = missing_values.split(asbytes(","***REMOVED******REMOVED***
            self.missing_values = set(list(missing_values***REMOVED*** + [asbytes(''***REMOVED******REMOVED******REMOVED***
        #
        self._callingfunction = self._strict_call
        self.type = self._dtypeortype(dtype***REMOVED***
        self._checked = False
        self._initial_default = default
    #

    def _loose_call(self, value***REMOVED***:
        ***REMOVED***
            return self.func(value***REMOVED***
        except ValueError:
            return self.default
    #

    def _strict_call(self, value***REMOVED***:
        ***REMOVED***

            # We check if we can convert the value using the current function
            new_value = self.func(value***REMOVED***

            # In addition to having to check whether func can convert the
            # value, we also have to make sure that we don't get overflow
            # errors for integers.
            if self.func is int:
                ***REMOVED***
                    np.array(value, dtype=self.type***REMOVED***
                except OverflowError:
                    raise ValueError

            # We're still here so we can now return the new value
            return new_value

        except ValueError:
            if value.strip(***REMOVED*** in self.missing_values:
                if not self._status:
                    self._checked = False
                return self.default
            raise ValueError("Cannot convert string '%s'" % value***REMOVED***
    #

    def __call__(self, value***REMOVED***:
        return self._callingfunction(value***REMOVED***
    #

    def upgrade(self, value***REMOVED***:
        ***REMOVED***
        Find the best converter for a given string, and return the result.

        The supplied string `value` is converted by testing different
        converters in order. First the `func` method of the
        `StringConverter` instance is tried, if this fails other available
        converters are tried.  The order in which these other converters
        are tried is determined by the `_status` attribute of the instance.

        Parameters
        ----------
        value : str
            The string to convert.

        Returns
        -------
        out : any
            The result of converting `value` with the appropriate converter.

        ***REMOVED***
        self._checked = True
        ***REMOVED***
            return self._strict_call(value***REMOVED***
        except ValueError:
            # Raise an exception if we locked the converter...
            if self._locked:
                errmsg = "Converter is locked and cannot be upgraded"
                raise ConverterLockError(errmsg***REMOVED***
            _statusmax = len(self._mapper***REMOVED***
            # Complains if we try to upgrade by the maximum
            _status = self._status
            if _status == _statusmax:
                errmsg = "Could not find a valid conversion function"
                raise ConverterError(errmsg***REMOVED***
            elif _status < _statusmax - 1:
                _status += 1
            (self.type, self.func, default***REMOVED*** = self._mapper[_status***REMOVED***
            self._status = _status
            if self._initial_default is not None:
                self.default = self._initial_default
            else:
                self.default = default
            return self.upgrade(value***REMOVED***

    def iterupgrade(self, value***REMOVED***:
        self._checked = True
        if not hasattr(value, '__iter__'***REMOVED***:
            value = (value,***REMOVED***
        _strict_call = self._strict_call
        ***REMOVED***
            for _m in value:
                _strict_call(_m***REMOVED***
        except ValueError:
            # Raise an exception if we locked the converter...
            if self._locked:
                errmsg = "Converter is locked and cannot be upgraded"
                raise ConverterLockError(errmsg***REMOVED***
            _statusmax = len(self._mapper***REMOVED***
            # Complains if we try to upgrade by the maximum
            _status = self._status
            if _status == _statusmax:
                raise ConverterError(
                    "Could not find a valid conversion function"
                    ***REMOVED***
            elif _status < _statusmax - 1:
                _status += 1
            (self.type, self.func, default***REMOVED*** = self._mapper[_status***REMOVED***
            if self._initial_default is not None:
                self.default = self._initial_default
            else:
                self.default = default
            self._status = _status
            self.iterupgrade(value***REMOVED***

    def update(self, func, default=None, testing_value=None,
               missing_values=asbytes(''***REMOVED***, locked=False***REMOVED***:
        ***REMOVED***
        Set StringConverter attributes directly.

        Parameters
        ----------
        func : function
            Conversion function.
        default : any, optional
            Value to return by default, that is, when the string to be
            converted is flagged as missing. If not given,
            `StringConverter` tries to supply a reasonable default value.
        testing_value : str, optional
            A string representing a standard input value of the converter.
            This string is used to help defining a reasonable default
            value.
        missing_values : sequence of str, optional
            Sequence of strings indicating a missing value.
        locked : bool, optional
            Whether the StringConverter should be locked to prevent
            automatic upgrade or not. Default is False.

        Notes
        -----
        `update` takes the same parameters as the constructor of
        `StringConverter`, except that `func` does not accept a `dtype`
        whereas `dtype_or_func` in the constructor does.

        ***REMOVED***
        self.func = func
        self._locked = locked
        # Don't reset the default to None if we can avoid it
        if default is not None:
            self.default = default
            self.type = self._dtypeortype(self._getdtype(default***REMOVED******REMOVED***
        else:
            ***REMOVED***
                tester = func(testing_value or asbytes('1'***REMOVED******REMOVED***
            except (TypeError, ValueError***REMOVED***:
                tester = None
            self.type = self._dtypeortype(self._getdtype(tester***REMOVED******REMOVED***
        # Add the missing values to the existing set
        if missing_values is not None:
            if _is_bytes_like(missing_values***REMOVED***:
                self.missing_values.add(missing_values***REMOVED***
            elif hasattr(missing_values, '__iter__'***REMOVED***:
                for val in missing_values:
                    self.missing_values.add(val***REMOVED***
        else:
            self.missing_values = [***REMOVED***


def easy_dtype(ndtype, names=None, defaultfmt="f%i", **validationargs***REMOVED***:
    ***REMOVED***
    Convenience function to create a `np.dtype` object.

    The function processes the input `dtype` and matches it with the given
    names.

    Parameters
    ----------
    ndtype : var
        Definition of the dtype. Can be any string or dictionary recognized
        by the `np.dtype` function, or a sequence of types.
    names : str or sequence, optional
        Sequence of strings to use as field names for a structured dtype.
        For convenience, `names` can be a string of a comma-separated list
        of names.
    defaultfmt : str, optional
        Format string used to define missing names, such as ``"f%i"``
        (default***REMOVED*** or ``"fields_%02i"``.
    validationargs : optional
        A series of optional arguments used to initialize a
        `NameValidator`.

    Examples
    --------
    >>> np.lib._iotools.easy_dtype(float***REMOVED***
    dtype('float64'***REMOVED***
    >>> np.lib._iotools.easy_dtype("i4, f8"***REMOVED***
    dtype([('f0', '<i4'***REMOVED***, ('f1', '<f8'***REMOVED******REMOVED******REMOVED***
    >>> np.lib._iotools.easy_dtype("i4, f8", defaultfmt="field_%03i"***REMOVED***
    dtype([('field_000', '<i4'***REMOVED***, ('field_001', '<f8'***REMOVED******REMOVED******REMOVED***

    >>> np.lib._iotools.easy_dtype((int, float, float***REMOVED***, names="a,b,c"***REMOVED***
    dtype([('a', '<i8'***REMOVED***, ('b', '<f8'***REMOVED***, ('c', '<f8'***REMOVED******REMOVED******REMOVED***
    >>> np.lib._iotools.easy_dtype(float, names="a,b,c"***REMOVED***
    dtype([('a', '<f8'***REMOVED***, ('b', '<f8'***REMOVED***, ('c', '<f8'***REMOVED******REMOVED******REMOVED***

    ***REMOVED***
    ***REMOVED***
        ndtype = np.dtype(ndtype***REMOVED***
    except TypeError:
        validate = NameValidator(**validationargs***REMOVED***
        nbfields = len(ndtype***REMOVED***
        if names is None:
            names = [''***REMOVED*** * len(ndtype***REMOVED***
        elif isinstance(names, basestring***REMOVED***:
            names = names.split(","***REMOVED***
        names = validate(names, nbfields=nbfields, defaultfmt=defaultfmt***REMOVED***
        ndtype = np.dtype(dict(formats=ndtype, names=names***REMOVED******REMOVED***
    else:
        nbtypes = len(ndtype***REMOVED***
        # Explicit names
        if names is not None:
            validate = NameValidator(**validationargs***REMOVED***
            if isinstance(names, basestring***REMOVED***:
                names = names.split(","***REMOVED***
            # Simple dtype: repeat to match the nb of names
            if nbtypes == 0:
                formats = tuple([ndtype.type***REMOVED*** * len(names***REMOVED******REMOVED***
                names = validate(names, defaultfmt=defaultfmt***REMOVED***
                ndtype = np.dtype(list(zip(names, formats***REMOVED******REMOVED******REMOVED***
            # Structured dtype: just validate the names as needed
            else:
                ndtype.names = validate(names, nbfields=nbtypes,
                                        defaultfmt=defaultfmt***REMOVED***
        # No implicit names
        elif (nbtypes > 0***REMOVED***:
            validate = NameValidator(**validationargs***REMOVED***
            # Default initial names : should we change the format ?
            if ((ndtype.names == tuple("f%i" % i for i in range(nbtypes***REMOVED******REMOVED******REMOVED*** and
                    (defaultfmt != "f%i"***REMOVED******REMOVED***:
                ndtype.names = validate([''***REMOVED*** * nbtypes, defaultfmt=defaultfmt***REMOVED***
            # Explicit initial names : just validate
            else:
                ndtype.names = validate(ndtype.names, defaultfmt=defaultfmt***REMOVED***
    return ndtype
