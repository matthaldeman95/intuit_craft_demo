***REMOVED***
Utilities that manipulate strides to achieve desirable effects.

An explanation of strides can be found in the "ndarray.rst" file in the
NumPy reference guide.

***REMOVED***
from __future__ import division, absolute_import, print_function

import numpy as np

__all__ = ['broadcast_to', 'broadcast_arrays'***REMOVED***


class DummyArray(object***REMOVED***:
    ***REMOVED***Dummy object that just exists to hang __array_interface__ dictionaries
    and possibly keep alive a reference to a base array.
    ***REMOVED***

    def __init__(self, interface, base=None***REMOVED***:
        self.__array_interface__ = interface
        self.base = base


def _maybe_view_as_subclass(original_array, new_array***REMOVED***:
    if type(original_array***REMOVED*** is not type(new_array***REMOVED***:
        # if input was an ndarray subclass and subclasses were OK,
        # then view the result as that subclass.
        new_array = new_array.view(type=type(original_array***REMOVED******REMOVED***
        # Since we have done something akin to a view from original_array, we
        # should let the subclass finalize (if it has it implemented, i.e., is
        # not None***REMOVED***.
        if new_array.__array_finalize__:
            new_array.__array_finalize__(original_array***REMOVED***
    return new_array


def as_strided(x, shape=None, strides=None, subok=False***REMOVED***:
    ***REMOVED*** Make an ndarray from the given array with the given shape and strides.
    ***REMOVED***
    # first convert input to array, possibly keeping subclass
    x = np.array(x, copy=False, subok=subok***REMOVED***
    interface = dict(x.__array_interface__***REMOVED***
    if shape is not None:
        interface['shape'***REMOVED*** = tuple(shape***REMOVED***
    if strides is not None:
        interface['strides'***REMOVED*** = tuple(strides***REMOVED***
    array = np.asarray(DummyArray(interface, base=x***REMOVED******REMOVED***

    if array.dtype.fields is None and x.dtype.fields is not None:
        # This should only happen if x.dtype is [('', 'Vx'***REMOVED******REMOVED***
        array.dtype = x.dtype

    return _maybe_view_as_subclass(x, array***REMOVED***


def _broadcast_to(array, shape, subok, readonly***REMOVED***:
    shape = tuple(shape***REMOVED*** if np.iterable(shape***REMOVED*** else (shape,***REMOVED***
    array = np.array(array, copy=False, subok=subok***REMOVED***
    if not shape and array.shape:
        raise ValueError('cannot broadcast a non-scalar to a scalar array'***REMOVED***
    if any(size < 0 for size in shape***REMOVED***:
        raise ValueError('all elements of broadcast shape must be non-'
                         'negative'***REMOVED***
    needs_writeable = not readonly and array.flags.writeable
    extras = ['reduce_ok'***REMOVED*** if needs_writeable else [***REMOVED***
    op_flag = 'readwrite' if needs_writeable else 'readonly'
    broadcast = np.nditer(
        (array,***REMOVED***, flags=['multi_index', 'refs_ok', 'zerosize_ok'***REMOVED*** + extras,
        op_flags=[op_flag***REMOVED***, itershape=shape, order='C'***REMOVED***.itviews[0***REMOVED***
    result = _maybe_view_as_subclass(array, broadcast***REMOVED***
    if needs_writeable and not result.flags.writeable:
        result.flags.writeable = True
    return result


def broadcast_to(array, shape, subok=False***REMOVED***:
    ***REMOVED***Broadcast an array to a new shape.

    Parameters
    ----------
    array : array_like
        The array to broadcast.
    shape : tuple
        The shape of the desired array.
    subok : bool, optional
        If True, then sub-classes will be passed-through, otherwise
        the returned array will be forced to be a base-class array (default***REMOVED***.

    Returns
    -------
    broadcast : array
        A readonly view on the original array with the given shape. It is
        typically not contiguous. Furthermore, more than one element of a
        broadcasted array may refer to a single memory location.

    Raises
    ------
    ValueError
        If the array is not compatible with the new shape according to NumPy's
        broadcasting rules.

    Notes
    -----
    .. versionadded:: 1.10.0

    Examples
    --------
    >>> x = np.array([1, 2, 3***REMOVED******REMOVED***
    >>> np.broadcast_to(x, (3, 3***REMOVED******REMOVED***
    array([[1, 2, 3***REMOVED***,
           [1, 2, 3***REMOVED***,
           [1, 2, 3***REMOVED******REMOVED******REMOVED***
    ***REMOVED***
    return _broadcast_to(array, shape, subok=subok, readonly=True***REMOVED***


def _broadcast_shape(*args***REMOVED***:
    ***REMOVED***Returns the shape of the ararys that would result from broadcasting the
    supplied arrays against each other.
    ***REMOVED***
    if not args:
        raise ValueError('must provide at least one argument'***REMOVED***
    # use the old-iterator because np.nditer does not handle size 0 arrays
    # consistently
    b = np.broadcast(*args[:32***REMOVED******REMOVED***
    # unfortunately, it cannot handle 32 or more arguments directly
    for pos in range(32, len(args***REMOVED***, 31***REMOVED***:
        # ironically, np.broadcast does not properly handle np.broadcast
        # objects (it treats them as scalars***REMOVED***
        # use broadcasting to avoid allocating the full array
        b = broadcast_to(0, b.shape***REMOVED***
        b = np.broadcast(b, *args[pos:(pos + 31***REMOVED******REMOVED******REMOVED***
    return b.shape


def broadcast_arrays(*args, **kwargs***REMOVED***:
    ***REMOVED***
    Broadcast any number of arrays against each other.

    Parameters
    ----------
    `*args` : array_likes
        The arrays to broadcast.

    subok : bool, optional
        If True, then sub-classes will be passed-through, otherwise
        the returned arrays will be forced to be a base-class array (default***REMOVED***.

    Returns
    -------
    broadcasted : list of arrays
        These arrays are views on the original arrays.  They are typically
        not contiguous.  Furthermore, more than one element of a
        broadcasted array may refer to a single memory location.  If you
        need to write to the arrays, make copies first.

    Examples
    --------
    >>> x = np.array([[1,2,3***REMOVED******REMOVED******REMOVED***
    >>> y = np.array([[1***REMOVED***,[2***REMOVED***,[3***REMOVED******REMOVED******REMOVED***
    >>> np.broadcast_arrays(x, y***REMOVED***
    [array([[1, 2, 3***REMOVED***,
           [1, 2, 3***REMOVED***,
           [1, 2, 3***REMOVED******REMOVED******REMOVED***, array([[1, 1, 1***REMOVED***,
           [2, 2, 2***REMOVED***,
           [3, 3, 3***REMOVED******REMOVED******REMOVED******REMOVED***

    Here is a useful idiom for getting contiguous copies instead of
    non-contiguous views.

    >>> [np.array(a***REMOVED*** for a in np.broadcast_arrays(x, y***REMOVED******REMOVED***
    [array([[1, 2, 3***REMOVED***,
           [1, 2, 3***REMOVED***,
           [1, 2, 3***REMOVED******REMOVED******REMOVED***, array([[1, 1, 1***REMOVED***,
           [2, 2, 2***REMOVED***,
           [3, 3, 3***REMOVED******REMOVED******REMOVED******REMOVED***

    ***REMOVED***
    # nditer is not used here to avoid the limit of 32 arrays.
    # Otherwise, something like the following one-liner would suffice:
    # return np.nditer(args, flags=['multi_index', 'zerosize_ok'***REMOVED***,
    #                  order='C'***REMOVED***.itviews

    subok = kwargs.pop('subok', False***REMOVED***
    if kwargs:
        raise TypeError('broadcast_arrays(***REMOVED*** got an unexpected keyword '
                        'argument {***REMOVED***'.format(kwargs.pop(***REMOVED******REMOVED******REMOVED***
    args = [np.array(_m, copy=False, subok=subok***REMOVED*** for _m in args***REMOVED***

    shape = _broadcast_shape(*args***REMOVED***

    if all(array.shape == shape for array in args***REMOVED***:
        # Common case where nothing needs to be broadcasted.
        return args

    # TODO: consider making the results of broadcast_arrays readonly to match
    # broadcast_to. This will require a deprecation cycle.
    return [_broadcast_to(array, shape, subok=subok, readonly=False***REMOVED***
            for array in args***REMOVED***
