***REMOVED***
Set operations for 1D numeric arrays based on sorting.

:Contains:
  ediff1d,
  unique,
  intersect1d,
  setxor1d,
  in1d,
  union1d,
  setdiff1d

:Notes:

For floating point arrays, inaccurate results may appear due to usual round-off
and floating point comparison issues.

Speed could be gained in some operations by an implementation of
sort(***REMOVED***, that can provide directly the permutation vectors, avoiding
thus calls to argsort(***REMOVED***.

To do: Optionally return indices analogously to unique for all functions.

:Author: Robert Cimrman

***REMOVED***
from __future__ import division, absolute_import, print_function

import numpy as np


__all__ = [
    'ediff1d', 'intersect1d', 'setxor1d', 'union1d', 'setdiff1d', 'unique',
    'in1d'
    ***REMOVED***


def ediff1d(ary, to_end=None, to_begin=None***REMOVED***:
    ***REMOVED***
    The differences between consecutive elements of an array.

    Parameters
    ----------
    ary : array_like
        If necessary, will be flattened before the differences are taken.
    to_end : array_like, optional
        Number(s***REMOVED*** to append at the end of the returned differences.
    to_begin : array_like, optional
        Number(s***REMOVED*** to prepend at the beginning of the returned differences.

    Returns
    -------
    ediff1d : ndarray
        The differences. Loosely, this is ``ary.flat[1:***REMOVED*** - ary.flat[:-1***REMOVED***``.

    See Also
    --------
    diff, gradient

    Notes
    -----
    When applied to masked arrays, this function drops the mask information
    if the `to_begin` and/or `to_end` parameters are used.

    Examples
    --------
    >>> x = np.array([1, 2, 4, 7, 0***REMOVED******REMOVED***
    >>> np.ediff1d(x***REMOVED***
    array([ 1,  2,  3, -7***REMOVED******REMOVED***

    >>> np.ediff1d(x, to_begin=-99, to_end=np.array([88, 99***REMOVED******REMOVED******REMOVED***
    array([-99,   1,   2,   3,  -7,  88,  99***REMOVED******REMOVED***

    The returned array is always 1D.

    >>> y = [[1, 2, 4***REMOVED***, [1, 6, 24***REMOVED******REMOVED***
    >>> np.ediff1d(y***REMOVED***
    array([ 1,  2, -3,  5, 18***REMOVED******REMOVED***

    ***REMOVED***
    ary = np.asanyarray(ary***REMOVED***.flat
    ed = ary[1:***REMOVED*** - ary[:-1***REMOVED***
    arrays = [ed***REMOVED***
    if to_begin is not None:
        arrays.insert(0, to_begin***REMOVED***
    if to_end is not None:
        arrays.append(to_end***REMOVED***

    if len(arrays***REMOVED*** != 1:
        # We'll save ourselves a copy of a potentially large array in
        # the common case where neither to_begin or to_end was given.
        ed = np.hstack(arrays***REMOVED***

    return ed

def unique(ar, return_index=False, return_inverse=False, return_counts=False***REMOVED***:
    ***REMOVED***
    Find the unique elements of an array.

    Returns the sorted unique elements of an array. There are three optional
    outputs in addition to the unique elements: the indices of the input array
    that give the unique values, the indices of the unique array that
    reconstruct the input array, and the number of times each unique value
    comes up in the input array.

    Parameters
    ----------
    ar : array_like
        Input array. This will be flattened if it is not already 1-D.
    return_index : bool, optional
        If True, also return the indices of `ar` that result in the unique
        array.
    return_inverse : bool, optional
        If True, also return the indices of the unique array that can be used
        to reconstruct `ar`.
    return_counts : bool, optional
        If True, also return the number of times each unique value comes up
        in `ar`.

        .. versionadded:: 1.9.0

    Returns
    -------
    unique : ndarray
        The sorted unique values.
    unique_indices : ndarray, optional
        The indices of the first occurrences of the unique values in the
        (flattened***REMOVED*** original array. Only provided if `return_index` is True.
    unique_inverse : ndarray, optional
        The indices to reconstruct the (flattened***REMOVED*** original array from the
        unique array. Only provided if `return_inverse` is True.
    unique_counts : ndarray, optional
        The number of times each of the unique values comes up in the
        original array. Only provided if `return_counts` is True.

        .. versionadded:: 1.9.0

    See Also
    --------
    numpy.lib.arraysetops : Module with a number of other functions for
                            performing set operations on arrays.

    Examples
    --------
    >>> np.unique([1, 1, 2, 2, 3, 3***REMOVED******REMOVED***
    array([1, 2, 3***REMOVED******REMOVED***
    >>> a = np.array([[1, 1***REMOVED***, [2, 3***REMOVED******REMOVED******REMOVED***
    >>> np.unique(a***REMOVED***
    array([1, 2, 3***REMOVED******REMOVED***

    Return the indices of the original array that give the unique values:

    >>> a = np.array(['a', 'b', 'b', 'c', 'a'***REMOVED******REMOVED***
    >>> u, indices = np.unique(a, return_index=True***REMOVED***
    >>> u
    array(['a', 'b', 'c'***REMOVED***,
           dtype='|S1'***REMOVED***
    >>> indices
    array([0, 1, 3***REMOVED******REMOVED***
    >>> a[indices***REMOVED***
    array(['a', 'b', 'c'***REMOVED***,
           dtype='|S1'***REMOVED***

    Reconstruct the input array from the unique values:

    >>> a = np.array([1, 2, 6, 4, 2, 3, 2***REMOVED******REMOVED***
    >>> u, indices = np.unique(a, return_inverse=True***REMOVED***
    >>> u
    array([1, 2, 3, 4, 6***REMOVED******REMOVED***
    >>> indices
    array([0, 1, 4, 3, 1, 2, 1***REMOVED******REMOVED***
    >>> u[indices***REMOVED***
    array([1, 2, 6, 4, 2, 3, 2***REMOVED******REMOVED***

    ***REMOVED***
    ar = np.asanyarray(ar***REMOVED***.flatten(***REMOVED***

    optional_indices = return_index or return_inverse
    optional_returns = optional_indices or return_counts

    if ar.size == 0:
        if not optional_returns:
            ret = ar
        else:
            ret = (ar,***REMOVED***
            if return_index:
                ret += (np.empty(0, np.bool***REMOVED***,***REMOVED***
            if return_inverse:
                ret += (np.empty(0, np.bool***REMOVED***,***REMOVED***
            if return_counts:
                ret += (np.empty(0, np.intp***REMOVED***,***REMOVED***
        return ret

    if optional_indices:
        perm = ar.argsort(kind='mergesort' if return_index else 'quicksort'***REMOVED***
        aux = ar[perm***REMOVED***
    else:
        ar.sort(***REMOVED***
        aux = ar
    flag = np.concatenate(([True***REMOVED***, aux[1:***REMOVED*** != aux[:-1***REMOVED******REMOVED******REMOVED***

    if not optional_returns:
        ret = aux[flag***REMOVED***
    else:
        ret = (aux[flag***REMOVED***,***REMOVED***
        if return_index:
            ret += (perm[flag***REMOVED***,***REMOVED***
        if return_inverse:
            iflag = np.cumsum(flag***REMOVED*** - 1
            inv_idx = np.empty(ar.shape, dtype=np.intp***REMOVED***
            inv_idx[perm***REMOVED*** = iflag
            ret += (inv_idx,***REMOVED***
        if return_counts:
            idx = np.concatenate(np.nonzero(flag***REMOVED*** + ([ar.size***REMOVED***,***REMOVED******REMOVED***
            ret += (np.diff(idx***REMOVED***,***REMOVED***
    return ret

def intersect1d(ar1, ar2, assume_unique=False***REMOVED***:
    ***REMOVED***
    Find the intersection of two arrays.

    Return the sorted, unique values that are in both of the input arrays.

    Parameters
    ----------
    ar1, ar2 : array_like
        Input arrays.
    assume_unique : bool
        If True, the input arrays are both assumed to be unique, which
        can speed up the calculation.  Default is False.

    Returns
    -------
    intersect1d : ndarray
        Sorted 1D array of common and unique elements.

    See Also
    --------
    numpy.lib.arraysetops : Module with a number of other functions for
                            performing set operations on arrays.

    Examples
    --------
    >>> np.intersect1d([1, 3, 4, 3***REMOVED***, [3, 1, 2, 1***REMOVED******REMOVED***
    array([1, 3***REMOVED******REMOVED***

    To intersect more than two arrays, use functools.reduce:

    >>> from functools import reduce
    >>> reduce(np.intersect1d, ([1, 3, 4, 3***REMOVED***, [3, 1, 2, 1***REMOVED***, [6, 3, 4, 2***REMOVED******REMOVED******REMOVED***
    array([3***REMOVED******REMOVED***
    ***REMOVED***
    if not assume_unique:
        # Might be faster than unique( intersect1d( ar1, ar2 ***REMOVED*** ***REMOVED***?
        ar1 = unique(ar1***REMOVED***
        ar2 = unique(ar2***REMOVED***
    aux = np.concatenate((ar1, ar2***REMOVED******REMOVED***
    aux.sort(***REMOVED***
    return aux[:-1***REMOVED***[aux[1:***REMOVED*** == aux[:-1***REMOVED******REMOVED***

def setxor1d(ar1, ar2, assume_unique=False***REMOVED***:
    ***REMOVED***
    Find the set exclusive-or of two arrays.

    Return the sorted, unique values that are in only one (not both***REMOVED*** of the
    input arrays.

    Parameters
    ----------
    ar1, ar2 : array_like
        Input arrays.
    assume_unique : bool
        If True, the input arrays are both assumed to be unique, which
        can speed up the calculation.  Default is False.

    Returns
    -------
    setxor1d : ndarray
        Sorted 1D array of unique values that are in only one of the input
        arrays.

    Examples
    --------
    >>> a = np.array([1, 2, 3, 2, 4***REMOVED******REMOVED***
    >>> b = np.array([2, 3, 5, 7, 5***REMOVED******REMOVED***
    >>> np.setxor1d(a,b***REMOVED***
    array([1, 4, 5, 7***REMOVED******REMOVED***

    ***REMOVED***
    if not assume_unique:
        ar1 = unique(ar1***REMOVED***
        ar2 = unique(ar2***REMOVED***

    aux = np.concatenate((ar1, ar2***REMOVED******REMOVED***
    if aux.size == 0:
        return aux

    aux.sort(***REMOVED***
#    flag = ediff1d( aux, to_end = 1, to_begin = 1 ***REMOVED*** == 0
    flag = np.concatenate(([True***REMOVED***, aux[1:***REMOVED*** != aux[:-1***REMOVED***, [True***REMOVED******REMOVED******REMOVED***
#    flag2 = ediff1d( flag ***REMOVED*** == 0
    flag2 = flag[1:***REMOVED*** == flag[:-1***REMOVED***
    return aux[flag2***REMOVED***

def in1d(ar1, ar2, assume_unique=False, invert=False***REMOVED***:
    ***REMOVED***
    Test whether each element of a 1-D array is also present in a second array.

    Returns a boolean array the same length as `ar1` that is True
    where an element of `ar1` is in `ar2` and False otherwise.

    Parameters
    ----------
    ar1 : (M,***REMOVED*** array_like
        Input array.
    ar2 : array_like
        The values against which to test each value of `ar1`.
    assume_unique : bool, optional
        If True, the input arrays are both assumed to be unique, which
        can speed up the calculation.  Default is False.
    invert : bool, optional
        If True, the values in the returned array are inverted (that is,
        False where an element of `ar1` is in `ar2` and True otherwise***REMOVED***.
        Default is False. ``np.in1d(a, b, invert=True***REMOVED***`` is equivalent
        to (but is faster than***REMOVED*** ``np.invert(in1d(a, b***REMOVED******REMOVED***``.

        .. versionadded:: 1.8.0

    Returns
    -------
    in1d : (M,***REMOVED*** ndarray, bool
        The values `ar1[in1d***REMOVED***` are in `ar2`.

    See Also
    --------
    numpy.lib.arraysetops : Module with a number of other functions for
                            performing set operations on arrays.

    Notes
    -----
    `in1d` can be considered as an element-wise function version of the
    python keyword `in`, for 1-D sequences. ``in1d(a, b***REMOVED***`` is roughly
    equivalent to ``np.array([item in b for item in a***REMOVED******REMOVED***``.
    However, this idea fails if `ar2` is a set, or similar (non-sequence***REMOVED***
    container:  As ``ar2`` is converted to an array, in those cases
    ``asarray(ar2***REMOVED***`` is an object array rather than the expected array of
    contained values.

    .. versionadded:: 1.4.0

    Examples
    --------
    >>> test = np.array([0, 1, 2, 5, 0***REMOVED******REMOVED***
    >>> states = [0, 2***REMOVED***
    >>> mask = np.in1d(test, states***REMOVED***
    >>> mask
    array([ True, False,  True, False,  True***REMOVED***, dtype=bool***REMOVED***
    >>> test[mask***REMOVED***
    array([0, 2, 0***REMOVED******REMOVED***
    >>> mask = np.in1d(test, states, invert=True***REMOVED***
    >>> mask
    array([False,  True, False,  True, False***REMOVED***, dtype=bool***REMOVED***
    >>> test[mask***REMOVED***
    array([1, 5***REMOVED******REMOVED***
    ***REMOVED***
    # Ravel both arrays, behavior for the first array could be different
    ar1 = np.asarray(ar1***REMOVED***.ravel(***REMOVED***
    ar2 = np.asarray(ar2***REMOVED***.ravel(***REMOVED***

    # This code is significantly faster when the condition is satisfied.
    if len(ar2***REMOVED*** < 10 * len(ar1***REMOVED*** ** 0.145:
        if invert:
            mask = np.ones(len(ar1***REMOVED***, dtype=np.bool***REMOVED***
            for a in ar2:
                mask &= (ar1 != a***REMOVED***
        else:
            mask = np.zeros(len(ar1***REMOVED***, dtype=np.bool***REMOVED***
            for a in ar2:
                mask |= (ar1 == a***REMOVED***
        return mask

    # Otherwise use sorting
    if not assume_unique:
        ar1, rev_idx = np.unique(ar1, return_inverse=True***REMOVED***
        ar2 = np.unique(ar2***REMOVED***

    ar = np.concatenate((ar1, ar2***REMOVED******REMOVED***
    # We need this to be a stable sort, so always use 'mergesort'
    # here. The values from the first array should always come before
    # the values from the second array.
    order = ar.argsort(kind='mergesort'***REMOVED***
    sar = ar[order***REMOVED***
    if invert:
        bool_ar = (sar[1:***REMOVED*** != sar[:-1***REMOVED******REMOVED***
    else:
        bool_ar = (sar[1:***REMOVED*** == sar[:-1***REMOVED******REMOVED***
    flag = np.concatenate((bool_ar, [invert***REMOVED******REMOVED******REMOVED***
    ret = np.empty(ar.shape, dtype=bool***REMOVED***
    ret[order***REMOVED*** = flag

    if assume_unique:
        return ret[:len(ar1***REMOVED******REMOVED***
    else:
        return ret[rev_idx***REMOVED***

def union1d(ar1, ar2***REMOVED***:
    ***REMOVED***
    Find the union of two arrays.

    Return the unique, sorted array of values that are in either of the two
    input arrays.

    Parameters
    ----------
    ar1, ar2 : array_like
        Input arrays. They are flattened if they are not already 1D.

    Returns
    -------
    union1d : ndarray
        Unique, sorted union of the input arrays.

    See Also
    --------
    numpy.lib.arraysetops : Module with a number of other functions for
                            performing set operations on arrays.

    Examples
    --------
    >>> np.union1d([-1, 0, 1***REMOVED***, [-2, 0, 2***REMOVED******REMOVED***
    array([-2, -1,  0,  1,  2***REMOVED******REMOVED***

    To find the union of more than two arrays, use functools.reduce:

    >>> from functools import reduce
    >>> reduce(np.union1d, ([1, 3, 4, 3***REMOVED***, [3, 1, 2, 1***REMOVED***, [6, 3, 4, 2***REMOVED******REMOVED******REMOVED***
    array([1, 2, 3, 4, 6***REMOVED******REMOVED***
    ***REMOVED***
    return unique(np.concatenate((ar1, ar2***REMOVED******REMOVED******REMOVED***

def setdiff1d(ar1, ar2, assume_unique=False***REMOVED***:
    ***REMOVED***
    Find the set difference of two arrays.

    Return the sorted, unique values in `ar1` that are not in `ar2`.

    Parameters
    ----------
    ar1 : array_like
        Input array.
    ar2 : array_like
        Input comparison array.
    assume_unique : bool
        If True, the input arrays are both assumed to be unique, which
        can speed up the calculation.  Default is False.

    Returns
    -------
    setdiff1d : ndarray
        Sorted 1D array of values in `ar1` that are not in `ar2`.

    See Also
    --------
    numpy.lib.arraysetops : Module with a number of other functions for
                            performing set operations on arrays.

    Examples
    --------
    >>> a = np.array([1, 2, 3, 2, 4, 1***REMOVED******REMOVED***
    >>> b = np.array([3, 4, 5, 6***REMOVED******REMOVED***
    >>> np.setdiff1d(a, b***REMOVED***
    array([1, 2***REMOVED******REMOVED***

    ***REMOVED***
    if assume_unique:
        ar1 = np.asarray(ar1***REMOVED***.ravel(***REMOVED***
    else:
        ar1 = unique(ar1***REMOVED***
        ar2 = unique(ar2***REMOVED***
    return ar1[in1d(ar1, ar2, assume_unique=True, invert=True***REMOVED******REMOVED***
