***REMOVED*** Basic functions for manipulating 2d arrays

***REMOVED***
from __future__ import division, absolute_import, print_function

from numpy.core.numeric import (
    asanyarray, arange, zeros, greater_equal, multiply, ones, asarray,
    where, int8, int16, int32, int64, empty, promote_types, diagonal,
    ***REMOVED***
from numpy.core import iinfo


__all__ = [
    'diag', 'diagflat', 'eye', 'fliplr', 'flipud', 'rot90', 'tri', 'triu',
    'tril', 'vander', 'histogram2d', 'mask_indices', 'tril_indices',
    'tril_indices_from', 'triu_indices', 'triu_indices_from', ***REMOVED***


i1 = iinfo(int8***REMOVED***
i2 = iinfo(int16***REMOVED***
i4 = iinfo(int32***REMOVED***


def _min_int(low, high***REMOVED***:
    ***REMOVED*** get small int that fits the range ***REMOVED***
    if high <= i1.max and low >= i1.min:
        return int8
    if high <= i2.max and low >= i2.min:
        return int16
    if high <= i4.max and low >= i4.min:
        return int32
    return int64


def fliplr(m***REMOVED***:
    ***REMOVED***
    Flip array in the left/right direction.

    Flip the entries in each row in the left/right direction.
    Columns are preserved, but appear in a different order than before.

    Parameters
    ----------
    m : array_like
        Input array, must be at least 2-D.

    Returns
    -------
    f : ndarray
        A view of `m` with the columns reversed.  Since a view
        is returned, this operation is :math:`\\mathcal O(1***REMOVED***`.

    See Also
    --------
    flipud : Flip array in the up/down direction.
    rot90 : Rotate array counterclockwise.

    Notes
    -----
    Equivalent to A[:,::-1***REMOVED***. Requires the array to be at least 2-D.

    Examples
    --------
    >>> A = np.diag([1.,2.,3.***REMOVED******REMOVED***
    >>> A
    array([[ 1.,  0.,  0.***REMOVED***,
           [ 0.,  2.,  0.***REMOVED***,
           [ 0.,  0.,  3.***REMOVED******REMOVED******REMOVED***
    >>> np.fliplr(A***REMOVED***
    array([[ 0.,  0.,  1.***REMOVED***,
           [ 0.,  2.,  0.***REMOVED***,
           [ 3.,  0.,  0.***REMOVED******REMOVED******REMOVED***

    >>> A = np.random.randn(2,3,5***REMOVED***
    >>> np.all(np.fliplr(A***REMOVED***==A[:,::-1,...***REMOVED******REMOVED***
    True

    ***REMOVED***
    m = asanyarray(m***REMOVED***
    if m.ndim < 2:
        raise ValueError("Input must be >= 2-d."***REMOVED***
    return m[:, ::-1***REMOVED***


def flipud(m***REMOVED***:
    ***REMOVED***
    Flip array in the up/down direction.

    Flip the entries in each column in the up/down direction.
    Rows are preserved, but appear in a different order than before.

    Parameters
    ----------
    m : array_like
        Input array.

    Returns
    -------
    out : array_like
        A view of `m` with the rows reversed.  Since a view is
        returned, this operation is :math:`\\mathcal O(1***REMOVED***`.

    See Also
    --------
    fliplr : Flip array in the left/right direction.
    rot90 : Rotate array counterclockwise.

    Notes
    -----
    Equivalent to ``A[::-1,...***REMOVED***``.
    Does not require the array to be two-dimensional.

    Examples
    --------
    >>> A = np.diag([1.0, 2, 3***REMOVED******REMOVED***
    >>> A
    array([[ 1.,  0.,  0.***REMOVED***,
           [ 0.,  2.,  0.***REMOVED***,
           [ 0.,  0.,  3.***REMOVED******REMOVED******REMOVED***
    >>> np.flipud(A***REMOVED***
    array([[ 0.,  0.,  3.***REMOVED***,
           [ 0.,  2.,  0.***REMOVED***,
           [ 1.,  0.,  0.***REMOVED******REMOVED******REMOVED***

    >>> A = np.random.randn(2,3,5***REMOVED***
    >>> np.all(np.flipud(A***REMOVED***==A[::-1,...***REMOVED******REMOVED***
    True

    >>> np.flipud([1,2***REMOVED******REMOVED***
    array([2, 1***REMOVED******REMOVED***

    ***REMOVED***
    m = asanyarray(m***REMOVED***
    if m.ndim < 1:
        raise ValueError("Input must be >= 1-d."***REMOVED***
    return m[::-1, ...***REMOVED***


def rot90(m, k=1***REMOVED***:
    ***REMOVED***
    Rotate an array by 90 degrees in the counter-clockwise direction.

    The first two dimensions are rotated; therefore, the array must be at
    least 2-D.

    Parameters
    ----------
    m : array_like
        Array of two or more dimensions.
    k : integer
        Number of times the array is rotated by 90 degrees.

    Returns
    -------
    y : ndarray
        Rotated array.

    See Also
    --------
    fliplr : Flip an array horizontally.
    flipud : Flip an array vertically.

    Examples
    --------
    >>> m = np.array([[1,2***REMOVED***,[3,4***REMOVED******REMOVED***, int***REMOVED***
    >>> m
    array([[1, 2***REMOVED***,
           [3, 4***REMOVED******REMOVED******REMOVED***
    >>> np.rot90(m***REMOVED***
    array([[2, 4***REMOVED***,
           [1, 3***REMOVED******REMOVED******REMOVED***
    >>> np.rot90(m, 2***REMOVED***
    array([[4, 3***REMOVED***,
           [2, 1***REMOVED******REMOVED******REMOVED***

    ***REMOVED***
    m = asanyarray(m***REMOVED***
    if m.ndim < 2:
        raise ValueError("Input must >= 2-d."***REMOVED***
    k = k % 4
    if k == 0:
        return m
    elif k == 1:
        return fliplr(m***REMOVED***.swapaxes(0, 1***REMOVED***
    elif k == 2:
        return fliplr(flipud(m***REMOVED******REMOVED***
    else:
        # k == 3
        return fliplr(m.swapaxes(0, 1***REMOVED******REMOVED***


def eye(N, M=None, k=0, dtype=float***REMOVED***:
    ***REMOVED***
    Return a 2-D array with ones on the diagonal and zeros elsewhere.

    Parameters
    ----------
    N : int
      Number of rows in the output.
    M : int, optional
      Number of columns in the output. If None, defaults to `N`.
    k : int, optional
      Index of the diagonal: 0 (the default***REMOVED*** refers to the main diagonal,
      a positive value refers to an upper diagonal, and a negative value
      to a lower diagonal.
    dtype : data-type, optional
      Data-type of the returned array.

    Returns
    -------
    I : ndarray of shape (N,M***REMOVED***
      An array where all elements are equal to zero, except for the `k`-th
      diagonal, whose values are equal to one.

    See Also
    --------
    identity : (almost***REMOVED*** equivalent function
    diag : diagonal 2-D array from a 1-D array specified by the user.

    Examples
    --------
    >>> np.eye(2, dtype=int***REMOVED***
    array([[1, 0***REMOVED***,
           [0, 1***REMOVED******REMOVED******REMOVED***
    >>> np.eye(3, k=1***REMOVED***
    array([[ 0.,  1.,  0.***REMOVED***,
           [ 0.,  0.,  1.***REMOVED***,
           [ 0.,  0.,  0.***REMOVED******REMOVED******REMOVED***

    ***REMOVED***
    if M is None:
        M = N
    m = zeros((N, M***REMOVED***, dtype=dtype***REMOVED***
    if k >= M:
        return m
    if k >= 0:
        i = k
    else:
        i = (-k***REMOVED*** * M
    m[:M-k***REMOVED***.flat[i::M+1***REMOVED*** = 1
    return m


def diag(v, k=0***REMOVED***:
    ***REMOVED***
    Extract a diagonal or construct a diagonal array.

    See the more detailed documentation for ``numpy.diagonal`` if you use this
    function to extract a diagonal and wish to write to the resulting array;
    whether it returns a copy or a view depends on what version of numpy you
    are using.

    Parameters
    ----------
    v : array_like
        If `v` is a 2-D array, return a copy of its `k`-th diagonal.
        If `v` is a 1-D array, return a 2-D array with `v` on the `k`-th
        diagonal.
    k : int, optional
        Diagonal in question. The default is 0. Use `k>0` for diagonals
        above the main diagonal, and `k<0` for diagonals below the main
        diagonal.

    Returns
    -------
    out : ndarray
        The extracted diagonal or constructed diagonal array.

    See Also
    --------
    diagonal : Return specified diagonals.
    diagflat : Create a 2-D array with the flattened input as a diagonal.
    trace : Sum along diagonals.
    triu : Upper triangle of an array.
    tril : Lower triangle of an array.

    Examples
    --------
    >>> x = np.arange(9***REMOVED***.reshape((3,3***REMOVED******REMOVED***
    >>> x
    array([[0, 1, 2***REMOVED***,
           [3, 4, 5***REMOVED***,
           [6, 7, 8***REMOVED******REMOVED******REMOVED***

    >>> np.diag(x***REMOVED***
    array([0, 4, 8***REMOVED******REMOVED***
    >>> np.diag(x, k=1***REMOVED***
    array([1, 5***REMOVED******REMOVED***
    >>> np.diag(x, k=-1***REMOVED***
    array([3, 7***REMOVED******REMOVED***

    >>> np.diag(np.diag(x***REMOVED******REMOVED***
    array([[0, 0, 0***REMOVED***,
           [0, 4, 0***REMOVED***,
           [0, 0, 8***REMOVED******REMOVED******REMOVED***

    ***REMOVED***
    v = asanyarray(v***REMOVED***
    s = v.shape
    if len(s***REMOVED*** == 1:
        n = s[0***REMOVED***+abs(k***REMOVED***
        res = zeros((n, n***REMOVED***, v.dtype***REMOVED***
        if k >= 0:
            i = k
        else:
            i = (-k***REMOVED*** * n
        res[:n-k***REMOVED***.flat[i::n+1***REMOVED*** = v
        return res
    elif len(s***REMOVED*** == 2:
        return diagonal(v, k***REMOVED***
    else:
        raise ValueError("Input must be 1- or 2-d."***REMOVED***


def diagflat(v, k=0***REMOVED***:
    ***REMOVED***
    Create a two-dimensional array with the flattened input as a diagonal.

    Parameters
    ----------
    v : array_like
        Input data, which is flattened and set as the `k`-th
        diagonal of the output.
    k : int, optional
        Diagonal to set; 0, the default, corresponds to the "main" diagonal,
        a positive (negative***REMOVED*** `k` giving the number of the diagonal above
        (below***REMOVED*** the main.

    Returns
    -------
    out : ndarray
        The 2-D output array.

    See Also
    --------
    diag : MATLAB work-alike for 1-D and 2-D arrays.
    diagonal : Return specified diagonals.
    trace : Sum along diagonals.

    Examples
    --------
    >>> np.diagflat([[1,2***REMOVED***, [3,4***REMOVED******REMOVED******REMOVED***
    array([[1, 0, 0, 0***REMOVED***,
           [0, 2, 0, 0***REMOVED***,
           [0, 0, 3, 0***REMOVED***,
           [0, 0, 0, 4***REMOVED******REMOVED******REMOVED***

    >>> np.diagflat([1,2***REMOVED***, 1***REMOVED***
    array([[0, 1, 0***REMOVED***,
           [0, 0, 2***REMOVED***,
           [0, 0, 0***REMOVED******REMOVED******REMOVED***

    ***REMOVED***
    ***REMOVED***
        wrap = v.__array_wrap__
    except AttributeError:
        wrap = None
    v = asarray(v***REMOVED***.ravel(***REMOVED***
    s = len(v***REMOVED***
    n = s + abs(k***REMOVED***
    res = zeros((n, n***REMOVED***, v.dtype***REMOVED***
    if (k >= 0***REMOVED***:
        i = arange(0, n-k***REMOVED***
        fi = i+k+i*n
    else:
        i = arange(0, n+k***REMOVED***
        fi = i+(i-k***REMOVED****n
    res.flat[fi***REMOVED*** = v
    if not wrap:
        return res
    return wrap(res***REMOVED***


def tri(N, M=None, k=0, dtype=float***REMOVED***:
    ***REMOVED***
    An array with ones at and below the given diagonal and zeros elsewhere.

    Parameters
    ----------
    N : int
        Number of rows in the array.
    M : int, optional
        Number of columns in the array.
        By default, `M` is taken equal to `N`.
    k : int, optional
        The sub-diagonal at and below which the array is filled.
        `k` = 0 is the main diagonal, while `k` < 0 is below it,
        and `k` > 0 is above.  The default is 0.
    dtype : dtype, optional
        Data type of the returned array.  The default is float.

    Returns
    -------
    tri : ndarray of shape (N, M***REMOVED***
        Array with its lower triangle filled with ones and zero elsewhere;
        in other words ``T[i,j***REMOVED*** == 1`` for ``i <= j + k``, 0 otherwise.

    Examples
    --------
    >>> np.tri(3, 5, 2, dtype=int***REMOVED***
    array([[1, 1, 1, 0, 0***REMOVED***,
           [1, 1, 1, 1, 0***REMOVED***,
           [1, 1, 1, 1, 1***REMOVED******REMOVED******REMOVED***

    >>> np.tri(3, 5, -1***REMOVED***
    array([[ 0.,  0.,  0.,  0.,  0.***REMOVED***,
           [ 1.,  0.,  0.,  0.,  0.***REMOVED***,
           [ 1.,  1.,  0.,  0.,  0.***REMOVED******REMOVED******REMOVED***

    ***REMOVED***
    if M is None:
        M = N

    m = greater_equal.outer(arange(N, dtype=_min_int(0, N***REMOVED******REMOVED***,
                            arange(-k, M-k, dtype=_min_int(-k, M - k***REMOVED******REMOVED******REMOVED***

    # Avoid making a copy if the requested type is already bool
    m = m.astype(dtype, copy=False***REMOVED***

    return m


def tril(m, k=0***REMOVED***:
    ***REMOVED***
    Lower triangle of an array.

    Return a copy of an array with elements above the `k`-th diagonal zeroed.

    Parameters
    ----------
    m : array_like, shape (M, N***REMOVED***
        Input array.
    k : int, optional
        Diagonal above which to zero elements.  `k = 0` (the default***REMOVED*** is the
        main diagonal, `k < 0` is below it and `k > 0` is above.

    Returns
    -------
    tril : ndarray, shape (M, N***REMOVED***
        Lower triangle of `m`, of same shape and data-type as `m`.

    See Also
    --------
    triu : same thing, only for the upper triangle

    Examples
    --------
    >>> np.tril([[1,2,3***REMOVED***,[4,5,6***REMOVED***,[7,8,9***REMOVED***,[10,11,12***REMOVED******REMOVED***, -1***REMOVED***
    array([[ 0,  0,  0***REMOVED***,
           [ 4,  0,  0***REMOVED***,
           [ 7,  8,  0***REMOVED***,
           [10, 11, 12***REMOVED******REMOVED******REMOVED***

    ***REMOVED***
    m = asanyarray(m***REMOVED***
    mask = tri(*m.shape[-2:***REMOVED***, k=k, dtype=bool***REMOVED***

    return where(mask, m, zeros(1, m.dtype***REMOVED******REMOVED***


def triu(m, k=0***REMOVED***:
    ***REMOVED***
    Upper triangle of an array.

    Return a copy of a matrix with the elements below the `k`-th diagonal
    zeroed.

    Please refer to the documentation for `tril` for further details.

    See Also
    --------
    tril : lower triangle of an array

    Examples
    --------
    >>> np.triu([[1,2,3***REMOVED***,[4,5,6***REMOVED***,[7,8,9***REMOVED***,[10,11,12***REMOVED******REMOVED***, -1***REMOVED***
    array([[ 1,  2,  3***REMOVED***,
           [ 4,  5,  6***REMOVED***,
           [ 0,  8,  9***REMOVED***,
           [ 0,  0, 12***REMOVED******REMOVED******REMOVED***

    ***REMOVED***
    m = asanyarray(m***REMOVED***
    mask = tri(*m.shape[-2:***REMOVED***, k=k-1, dtype=bool***REMOVED***

    return where(mask, zeros(1, m.dtype***REMOVED***, m***REMOVED***


# Originally borrowed from John Hunter and matplotlib
def vander(x, N=None, increasing=False***REMOVED***:
    ***REMOVED***
    Generate a Vandermonde matrix.

    The columns of the output matrix are powers of the input vector. The
    order of the powers is determined by the `increasing` boolean argument.
    Specifically, when `increasing` is False, the `i`-th output column is
    the input vector raised element-wise to the power of ``N - i - 1``. Such
    a matrix with a geometric progression in each row is named for Alexandre-
    Theophile Vandermonde.

    Parameters
    ----------
    x : array_like
        1-D input array.
    N : int, optional
        Number of columns in the output.  If `N` is not specified, a square
        array is returned (``N = len(x***REMOVED***``***REMOVED***.
    increasing : bool, optional
        Order of the powers of the columns.  If True, the powers increase
        from left to right, if False (the default***REMOVED*** they are reversed.

        .. versionadded:: 1.9.0

    Returns
    -------
    out : ndarray
        Vandermonde matrix.  If `increasing` is False, the first column is
        ``x^(N-1***REMOVED***``, the second ``x^(N-2***REMOVED***`` and so forth. If `increasing` is
        True, the columns are ``x^0, x^1, ..., x^(N-1***REMOVED***``.

    See Also
    --------
    polynomial.polynomial.polyvander

    Examples
    --------
    >>> x = np.array([1, 2, 3, 5***REMOVED******REMOVED***
    >>> N = 3
    >>> np.vander(x, N***REMOVED***
    array([[ 1,  1,  1***REMOVED***,
           [ 4,  2,  1***REMOVED***,
           [ 9,  3,  1***REMOVED***,
           [25,  5,  1***REMOVED******REMOVED******REMOVED***

    >>> np.column_stack([x**(N-1-i***REMOVED*** for i in range(N***REMOVED******REMOVED******REMOVED***
    array([[ 1,  1,  1***REMOVED***,
           [ 4,  2,  1***REMOVED***,
           [ 9,  3,  1***REMOVED***,
           [25,  5,  1***REMOVED******REMOVED******REMOVED***

    >>> x = np.array([1, 2, 3, 5***REMOVED******REMOVED***
    >>> np.vander(x***REMOVED***
    array([[  1,   1,   1,   1***REMOVED***,
           [  8,   4,   2,   1***REMOVED***,
           [ 27,   9,   3,   1***REMOVED***,
           [125,  25,   5,   1***REMOVED******REMOVED******REMOVED***
    >>> np.vander(x, increasing=True***REMOVED***
    array([[  1,   1,   1,   1***REMOVED***,
           [  1,   2,   4,   8***REMOVED***,
           [  1,   3,   9,  27***REMOVED***,
           [  1,   5,  25, 125***REMOVED******REMOVED******REMOVED***

    The determinant of a square Vandermonde matrix is the product
    of the differences between the values of the input vector:

    >>> np.linalg.det(np.vander(x***REMOVED******REMOVED***
    48.000000000000043
    >>> (5-3***REMOVED****(5-2***REMOVED****(5-1***REMOVED****(3-2***REMOVED****(3-1***REMOVED****(2-1***REMOVED***
    48

    ***REMOVED***
    x = asarray(x***REMOVED***
    if x.ndim != 1:
        raise ValueError("x must be a one-dimensional array or sequence."***REMOVED***
    if N is None:
        N = len(x***REMOVED***

    v = empty((len(x***REMOVED***, N***REMOVED***, dtype=promote_types(x.dtype, int***REMOVED******REMOVED***
    tmp = v[:, ::-1***REMOVED*** if not increasing else v

    if N > 0:
        tmp[:, 0***REMOVED*** = 1
    if N > 1:
        tmp[:, 1:***REMOVED*** = x[:, None***REMOVED***
        multiply.accumulate(tmp[:, 1:***REMOVED***, out=tmp[:, 1:***REMOVED***, axis=1***REMOVED***

    return v


def histogram2d(x, y, bins=10, range=None, normed=False, weights=None***REMOVED***:
    ***REMOVED***
    Compute the bi-dimensional histogram of two data samples.

    Parameters
    ----------
    x : array_like, shape (N,***REMOVED***
        An array containing the x coordinates of the points to be
        histogrammed.
    y : array_like, shape (N,***REMOVED***
        An array containing the y coordinates of the points to be
        histogrammed.
    bins : int or array_like or [int, int***REMOVED*** or [array, array***REMOVED***, optional
        The bin specification:

          * If int, the number of bins for the two dimensions (nx=ny=bins***REMOVED***.
          * If array_like, the bin edges for the two dimensions
            (x_edges=y_edges=bins***REMOVED***.
          * If [int, int***REMOVED***, the number of bins in each dimension
            (nx, ny = bins***REMOVED***.
          * If [array, array***REMOVED***, the bin edges in each dimension
            (x_edges, y_edges = bins***REMOVED***.
          * A combination [int, array***REMOVED*** or [array, int***REMOVED***, where int
            is the number of bins and array is the bin edges.

    range : array_like, shape(2,2***REMOVED***, optional
        The leftmost and rightmost edges of the bins along each dimension
        (if not specified explicitly in the `bins` parameters***REMOVED***:
        ``[[xmin, xmax***REMOVED***, [ymin, ymax***REMOVED******REMOVED***``. All values outside of this range
        will be considered outliers and not tallied in the histogram.
    normed : bool, optional
        If False, returns the number of samples in each bin. If True,
        returns the bin density ``bin_count / sample_count / bin_area``.
    weights : array_like, shape(N,***REMOVED***, optional
        An array of values ``w_i`` weighing each sample ``(x_i, y_i***REMOVED***``.
        Weights are normalized to 1 if `normed` is True. If `normed` is
        False, the values of the returned histogram are equal to the sum of
        the weights belonging to the samples falling into each bin.

    Returns
    -------
    H : ndarray, shape(nx, ny***REMOVED***
        The bi-dimensional histogram of samples `x` and `y`. Values in `x`
        are histogrammed along the first dimension and values in `y` are
        histogrammed along the second dimension.
    xedges : ndarray, shape(nx,***REMOVED***
        The bin edges along the first dimension.
    yedges : ndarray, shape(ny,***REMOVED***
        The bin edges along the second dimension.

    See Also
    --------
    histogram : 1D histogram
    histogramdd : Multidimensional histogram

    Notes
    -----
    When `normed` is True, then the returned histogram is the sample
    density, defined such that the sum over bins of the product
    ``bin_value * bin_area`` is 1.

    Please note that the histogram does not follow the Cartesian convention
    where `x` values are on the abscissa and `y` values on the ordinate
    axis.  Rather, `x` is histogrammed along the first dimension of the
    array (vertical***REMOVED***, and `y` along the second dimension of the array
    (horizontal***REMOVED***.  This ensures compatibility with `histogramdd`.

    Examples
    --------
    >>> import matplotlib as mpl
    >>> import matplotlib.pyplot as plt

    Construct a 2D-histogram with variable bin width. First define the bin
    edges:

    >>> xedges = [0, 1, 1.5, 3, 5***REMOVED***
    >>> yedges = [0, 2, 3, 4, 6***REMOVED***

    Next we create a histogram H with random bin content:

    >>> x = np.random.normal(3, 1, 100***REMOVED***
    >>> y = np.random.normal(1, 1, 100***REMOVED***
    >>> H, xedges, yedges = np.histogram2d(y, x, bins=(xedges, yedges***REMOVED******REMOVED***

    Or we fill the histogram H with a determined bin content:

    >>> H = np.ones((4, 4***REMOVED******REMOVED***.cumsum(***REMOVED***.reshape(4, 4***REMOVED***
    >>> print(H[::-1***REMOVED******REMOVED***  # This shows the bin content in the order as plotted
    [[ 13.  14.  15.  16.***REMOVED***
     [  9.  10.  11.  12.***REMOVED***
     [  5.   6.   7.   8.***REMOVED***
     [  1.   2.   3.   4.***REMOVED******REMOVED***

    Imshow can only do an equidistant representation of bins:

    >>> fig = plt.figure(figsize=(7, 3***REMOVED******REMOVED***
    >>> ax = fig.add_subplot(131***REMOVED***
    >>> ax.set_title('imshow: equidistant'***REMOVED***
    >>> im = plt.imshow(H, interpolation='nearest', origin='low',
                    extent=[xedges[0***REMOVED***, xedges[-1***REMOVED***, yedges[0***REMOVED***, yedges[-1***REMOVED******REMOVED******REMOVED***

    pcolormesh can display exact bin edges:

    >>> ax = fig.add_subplot(132***REMOVED***
    >>> ax.set_title('pcolormesh: exact bin edges'***REMOVED***
    >>> X, Y = np.meshgrid(xedges, yedges***REMOVED***
    >>> ax.pcolormesh(X, Y, H***REMOVED***
    >>> ax.set_aspect('equal'***REMOVED***

    NonUniformImage displays exact bin edges with interpolation:

    >>> ax = fig.add_subplot(133***REMOVED***
    >>> ax.set_title('NonUniformImage: interpolated'***REMOVED***
    >>> im = mpl.image.NonUniformImage(ax, interpolation='bilinear'***REMOVED***
    >>> xcenters = xedges[:-1***REMOVED*** + 0.5 * (xedges[1:***REMOVED*** - xedges[:-1***REMOVED******REMOVED***
    >>> ycenters = yedges[:-1***REMOVED*** + 0.5 * (yedges[1:***REMOVED*** - yedges[:-1***REMOVED******REMOVED***
    >>> im.set_data(xcenters, ycenters, H***REMOVED***
    >>> ax.images.append(im***REMOVED***
    >>> ax.set_xlim(xedges[0***REMOVED***, xedges[-1***REMOVED******REMOVED***
    >>> ax.set_ylim(yedges[0***REMOVED***, yedges[-1***REMOVED******REMOVED***
    >>> ax.set_aspect('equal'***REMOVED***
    >>> plt.show(***REMOVED***

    ***REMOVED***
    from numpy import histogramdd

    ***REMOVED***
        N = len(bins***REMOVED***
    except TypeError:
        N = 1

    if N != 1 and N != 2:
        xedges = yedges = asarray(bins, float***REMOVED***
        bins = [xedges, yedges***REMOVED***
    hist, edges = histogramdd([x, y***REMOVED***, bins, range, normed, weights***REMOVED***
    return hist, edges[0***REMOVED***, edges[1***REMOVED***


def mask_indices(n, mask_func, k=0***REMOVED***:
    ***REMOVED***
    Return the indices to access (n, n***REMOVED*** arrays, given a masking function.

    Assume `mask_func` is a function that, for a square array a of size
    ``(n, n***REMOVED***`` with a possible offset argument `k`, when called as
    ``mask_func(a, k***REMOVED***`` returns a new array with zeros in certain locations
    (functions like `triu` or `tril` do precisely this***REMOVED***. Then this function
    returns the indices where the non-zero values would be located.

    Parameters
    ----------
    n : int
        The returned indices will be valid to access arrays of shape (n, n***REMOVED***.
    mask_func : callable
        A function whose call signature is similar to that of `triu`, `tril`.
        That is, ``mask_func(x, k***REMOVED***`` returns a boolean array, shaped like `x`.
        `k` is an optional argument to the function.
    k : scalar
        An optional argument which is passed through to `mask_func`. Functions
        like `triu`, `tril` take a second argument that is interpreted as an
        offset.

    Returns
    -------
    indices : tuple of arrays.
        The `n` arrays of indices corresponding to the locations where
        ``mask_func(np.ones((n, n***REMOVED******REMOVED***, k***REMOVED***`` is True.

    See Also
    --------
    triu, tril, triu_indices, tril_indices

    Notes
    -----
    .. versionadded:: 1.4.0

    Examples
    --------
    These are the indices that would allow you to access the upper triangular
    part of any 3x3 array:

    >>> iu = np.mask_indices(3, np.triu***REMOVED***

    For example, if `a` is a 3x3 array:

    >>> a = np.arange(9***REMOVED***.reshape(3, 3***REMOVED***
    >>> a
    array([[0, 1, 2***REMOVED***,
           [3, 4, 5***REMOVED***,
           [6, 7, 8***REMOVED******REMOVED******REMOVED***
    >>> a[iu***REMOVED***
    array([0, 1, 2, 4, 5, 8***REMOVED******REMOVED***

    An offset can be passed also to the masking function.  This gets us the
    indices starting on the first diagonal right of the main one:

    >>> iu1 = np.mask_indices(3, np.triu, 1***REMOVED***

    with which we now extract only three elements:

    >>> a[iu1***REMOVED***
    array([1, 2, 5***REMOVED******REMOVED***

    ***REMOVED***
    m = ones((n, n***REMOVED***, int***REMOVED***
    a = mask_func(m, k***REMOVED***
    return where(a != 0***REMOVED***


def tril_indices(n, k=0, m=None***REMOVED***:
    ***REMOVED***
    Return the indices for the lower-triangle of an (n, m***REMOVED*** array.

    Parameters
    ----------
    n : int
        The row dimension of the arrays for which the returned
        indices will be valid.
    k : int, optional
        Diagonal offset (see `tril` for details***REMOVED***.
    m : int, optional
        .. versionadded:: 1.9.0

        The column dimension of the arrays for which the returned
        arrays will be valid.
        By default `m` is taken equal to `n`.


    Returns
    -------
    inds : tuple of arrays
        The indices for the triangle. The returned tuple contains two arrays,
        each with the indices along one dimension of the array.

    See also
    --------
    triu_indices : similar function, for upper-triangular.
    mask_indices : generic function accepting an arbitrary mask function.
    tril, triu

    Notes
    -----
    .. versionadded:: 1.4.0

    Examples
    --------
    Compute two different sets of indices to access 4x4 arrays, one for the
    lower triangular part starting at the main diagonal, and one starting two
    diagonals further right:

    >>> il1 = np.tril_indices(4***REMOVED***
    >>> il2 = np.tril_indices(4, 2***REMOVED***

    Here is how they can be used with a sample array:

    >>> a = np.arange(16***REMOVED***.reshape(4, 4***REMOVED***
    >>> a
    array([[ 0,  1,  2,  3***REMOVED***,
           [ 4,  5,  6,  7***REMOVED***,
           [ 8,  9, 10, 11***REMOVED***,
           [12, 13, 14, 15***REMOVED******REMOVED******REMOVED***

    Both for indexing:

    >>> a[il1***REMOVED***
    array([ 0,  4,  5,  8,  9, 10, 12, 13, 14, 15***REMOVED******REMOVED***

    And for assigning values:

    >>> a[il1***REMOVED*** = -1
    >>> a
    array([[-1,  1,  2,  3***REMOVED***,
           [-1, -1,  6,  7***REMOVED***,
           [-1, -1, -1, 11***REMOVED***,
           [-1, -1, -1, -1***REMOVED******REMOVED******REMOVED***

    These cover almost the whole array (two diagonals right of the main one***REMOVED***:

    >>> a[il2***REMOVED*** = -10
    >>> a
    array([[-10, -10, -10,   3***REMOVED***,
           [-10, -10, -10, -10***REMOVED***,
           [-10, -10, -10, -10***REMOVED***,
           [-10, -10, -10, -10***REMOVED******REMOVED******REMOVED***

    ***REMOVED***
    return where(tri(n, m, k=k, dtype=bool***REMOVED******REMOVED***


def tril_indices_from(arr, k=0***REMOVED***:
    ***REMOVED***
    Return the indices for the lower-triangle of arr.

    See `tril_indices` for full details.

    Parameters
    ----------
    arr : array_like
        The indices will be valid for square arrays whose dimensions are
        the same as arr.
    k : int, optional
        Diagonal offset (see `tril` for details***REMOVED***.

    See Also
    --------
    tril_indices, tril

    Notes
    -----
    .. versionadded:: 1.4.0

    ***REMOVED***
    if arr.ndim != 2:
        raise ValueError("input array must be 2-d"***REMOVED***
    return tril_indices(arr.shape[-2***REMOVED***, k=k, m=arr.shape[-1***REMOVED******REMOVED***


def triu_indices(n, k=0, m=None***REMOVED***:
    ***REMOVED***
    Return the indices for the upper-triangle of an (n, m***REMOVED*** array.

    Parameters
    ----------
    n : int
        The size of the arrays for which the returned indices will
        be valid.
    k : int, optional
        Diagonal offset (see `triu` for details***REMOVED***.
    m : int, optional
        .. versionadded:: 1.9.0

        The column dimension of the arrays for which the returned
        arrays will be valid.
        By default `m` is taken equal to `n`.


    Returns
    -------
    inds : tuple, shape(2***REMOVED*** of ndarrays, shape(`n`***REMOVED***
        The indices for the triangle. The returned tuple contains two arrays,
        each with the indices along one dimension of the array.  Can be used
        to slice a ndarray of shape(`n`, `n`***REMOVED***.

    See also
    --------
    tril_indices : similar function, for lower-triangular.
    mask_indices : generic function accepting an arbitrary mask function.
    triu, tril

    Notes
    -----
    .. versionadded:: 1.4.0

    Examples
    --------
    Compute two different sets of indices to access 4x4 arrays, one for the
    upper triangular part starting at the main diagonal, and one starting two
    diagonals further right:

    >>> iu1 = np.triu_indices(4***REMOVED***
    >>> iu2 = np.triu_indices(4, 2***REMOVED***

    Here is how they can be used with a sample array:

    >>> a = np.arange(16***REMOVED***.reshape(4, 4***REMOVED***
    >>> a
    array([[ 0,  1,  2,  3***REMOVED***,
           [ 4,  5,  6,  7***REMOVED***,
           [ 8,  9, 10, 11***REMOVED***,
           [12, 13, 14, 15***REMOVED******REMOVED******REMOVED***

    Both for indexing:

    >>> a[iu1***REMOVED***
    array([ 0,  1,  2,  3,  5,  6,  7, 10, 11, 15***REMOVED******REMOVED***

    And for assigning values:

    >>> a[iu1***REMOVED*** = -1
    >>> a
    array([[-1, -1, -1, -1***REMOVED***,
           [ 4, -1, -1, -1***REMOVED***,
           [ 8,  9, -1, -1***REMOVED***,
           [12, 13, 14, -1***REMOVED******REMOVED******REMOVED***

    These cover only a small part of the whole array (two diagonals right
    of the main one***REMOVED***:

    >>> a[iu2***REMOVED*** = -10
    >>> a
    array([[ -1,  -1, -10, -10***REMOVED***,
           [  4,  -1,  -1, -10***REMOVED***,
           [  8,   9,  -1,  -1***REMOVED***,
           [ 12,  13,  14,  -1***REMOVED******REMOVED******REMOVED***

    ***REMOVED***
    return where(~tri(n, m, k=k-1, dtype=bool***REMOVED******REMOVED***


def triu_indices_from(arr, k=0***REMOVED***:
    ***REMOVED***
    Return the indices for the upper-triangle of arr.

    See `triu_indices` for full details.

    Parameters
    ----------
    arr : ndarray, shape(N, N***REMOVED***
        The indices will be valid for square arrays.
    k : int, optional
        Diagonal offset (see `triu` for details***REMOVED***.

    Returns
    -------
    triu_indices_from : tuple, shape(2***REMOVED*** of ndarray, shape(N***REMOVED***
        Indices for the upper-triangle of `arr`.

    See Also
    --------
    triu_indices, triu

    Notes
    -----
    .. versionadded:: 1.4.0

    ***REMOVED***
    if arr.ndim != 2:
        raise ValueError("input array must be 2-d"***REMOVED***
    return triu_indices(arr.shape[-2***REMOVED***, k=k, m=arr.shape[-1***REMOVED******REMOVED***
