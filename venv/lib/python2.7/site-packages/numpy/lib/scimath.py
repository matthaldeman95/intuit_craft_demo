***REMOVED***
Wrapper functions to more user-friendly calling of certain math functions
whose output data-type is different than the input data-type in certain
domains of the input.

For example, for functions like `log` with branch cuts, the versions in this
module provide the mathematically valid answers in the complex plane::

  >>> import math
  >>> from numpy.lib import scimath
  >>> scimath.log(-math.exp(1***REMOVED******REMOVED*** == (1+1j*math.pi***REMOVED***
  True

Similarly, `sqrt`, other base logarithms, `power` and trig functions are
correctly handled.  See their respective docstrings for specific examples.

***REMOVED***
from __future__ import division, absolute_import, print_function

import numpy.core.numeric as nx
import numpy.core.numerictypes as nt
from numpy.core.numeric import asarray, any
from numpy.lib.type_check import isreal


__all__ = [
    'sqrt', 'log', 'log2', 'logn', 'log10', 'power', 'arccos', 'arcsin',
    'arctanh'
    ***REMOVED***


_ln2 = nx.log(2.0***REMOVED***


def _tocomplex(arr***REMOVED***:
    ***REMOVED***Convert its input `arr` to a complex array.

    The input is returned as a complex array of the smallest type that will fit
    the original data: types like single, byte, short, etc. become csingle,
    while others become cdouble.

    A copy of the input is always made.

    Parameters
    ----------
    arr : array

    Returns
    -------
    array
        An array with the same input data as the input but in complex form.

    Examples
    --------

    First, consider an input of type short:

    >>> a = np.array([1,2,3***REMOVED***,np.short***REMOVED***

    >>> ac = np.lib.scimath._tocomplex(a***REMOVED***; ac
    array([ 1.+0.j,  2.+0.j,  3.+0.j***REMOVED***, dtype=complex64***REMOVED***

    >>> ac.dtype
    dtype('complex64'***REMOVED***

    If the input is of type double, the output is correspondingly of the
    complex double type as well:

    >>> b = np.array([1,2,3***REMOVED***,np.double***REMOVED***

    >>> bc = np.lib.scimath._tocomplex(b***REMOVED***; bc
    array([ 1.+0.j,  2.+0.j,  3.+0.j***REMOVED******REMOVED***

    >>> bc.dtype
    dtype('complex128'***REMOVED***

    Note that even if the input was complex to begin with, a copy is still
    made, since the astype(***REMOVED*** method always copies:

    >>> c = np.array([1,2,3***REMOVED***,np.csingle***REMOVED***

    >>> cc = np.lib.scimath._tocomplex(c***REMOVED***; cc
    array([ 1.+0.j,  2.+0.j,  3.+0.j***REMOVED***, dtype=complex64***REMOVED***

    >>> c *= 2; c
    array([ 2.+0.j,  4.+0.j,  6.+0.j***REMOVED***, dtype=complex64***REMOVED***

    >>> cc
    array([ 1.+0.j,  2.+0.j,  3.+0.j***REMOVED***, dtype=complex64***REMOVED***
    ***REMOVED***
    if issubclass(arr.dtype.type, (nt.single, nt.byte, nt.short, nt.ubyte,
                                   nt.ushort, nt.csingle***REMOVED******REMOVED***:
        return arr.astype(nt.csingle***REMOVED***
    else:
        return arr.astype(nt.cdouble***REMOVED***

def _fix_real_lt_zero(x***REMOVED***:
    ***REMOVED***Convert `x` to complex if it has real, negative components.

    Otherwise, output is just the array version of the input (via asarray***REMOVED***.

    Parameters
    ----------
    x : array_like

    Returns
    -------
    array

    Examples
    --------
    >>> np.lib.scimath._fix_real_lt_zero([1,2***REMOVED******REMOVED***
    array([1, 2***REMOVED******REMOVED***

    >>> np.lib.scimath._fix_real_lt_zero([-1,2***REMOVED******REMOVED***
    array([-1.+0.j,  2.+0.j***REMOVED******REMOVED***

    ***REMOVED***
    x = asarray(x***REMOVED***
    if any(isreal(x***REMOVED*** & (x < 0***REMOVED******REMOVED***:
        x = _tocomplex(x***REMOVED***
    return x

def _fix_int_lt_zero(x***REMOVED***:
    ***REMOVED***Convert `x` to double if it has real, negative components.

    Otherwise, output is just the array version of the input (via asarray***REMOVED***.

    Parameters
    ----------
    x : array_like

    Returns
    -------
    array

    Examples
    --------
    >>> np.lib.scimath._fix_int_lt_zero([1,2***REMOVED******REMOVED***
    array([1, 2***REMOVED******REMOVED***

    >>> np.lib.scimath._fix_int_lt_zero([-1,2***REMOVED******REMOVED***
    array([-1.,  2.***REMOVED******REMOVED***
    ***REMOVED***
    x = asarray(x***REMOVED***
    if any(isreal(x***REMOVED*** & (x < 0***REMOVED******REMOVED***:
        x = x * 1.0
    return x

def _fix_real_abs_gt_1(x***REMOVED***:
    ***REMOVED***Convert `x` to complex if it has real components x_i with abs(x_i***REMOVED***>1.

    Otherwise, output is just the array version of the input (via asarray***REMOVED***.

    Parameters
    ----------
    x : array_like

    Returns
    -------
    array

    Examples
    --------
    >>> np.lib.scimath._fix_real_abs_gt_1([0,1***REMOVED******REMOVED***
    array([0, 1***REMOVED******REMOVED***

    >>> np.lib.scimath._fix_real_abs_gt_1([0,2***REMOVED******REMOVED***
    array([ 0.+0.j,  2.+0.j***REMOVED******REMOVED***
    ***REMOVED***
    x = asarray(x***REMOVED***
    if any(isreal(x***REMOVED*** & (abs(x***REMOVED*** > 1***REMOVED******REMOVED***:
        x = _tocomplex(x***REMOVED***
    return x

def sqrt(x***REMOVED***:
    ***REMOVED***
    Compute the square root of x.

    For negative input elements, a complex value is returned
    (unlike `numpy.sqrt` which returns NaN***REMOVED***.

    Parameters
    ----------
    x : array_like
       The input value(s***REMOVED***.

    Returns
    -------
    out : ndarray or scalar
       The square root of `x`. If `x` was a scalar, so is `out`,
       otherwise an array is returned.

    See Also
    --------
    numpy.sqrt

    Examples
    --------
    For real, non-negative inputs this works just like `numpy.sqrt`:

    >>> np.lib.scimath.sqrt(1***REMOVED***
    1.0
    >>> np.lib.scimath.sqrt([1, 4***REMOVED******REMOVED***
    array([ 1.,  2.***REMOVED******REMOVED***

    But it automatically handles negative inputs:

    >>> np.lib.scimath.sqrt(-1***REMOVED***
    (0.0+1.0j***REMOVED***
    >>> np.lib.scimath.sqrt([-1,4***REMOVED******REMOVED***
    array([ 0.+1.j,  2.+0.j***REMOVED******REMOVED***

    ***REMOVED***
    x = _fix_real_lt_zero(x***REMOVED***
    return nx.sqrt(x***REMOVED***

def log(x***REMOVED***:
    ***REMOVED***
    Compute the natural logarithm of `x`.

    Return the "principal value" (for a description of this, see `numpy.log`***REMOVED***
    of :math:`log_e(x***REMOVED***`. For real `x > 0`, this is a real number (``log(0***REMOVED***``
    returns ``-inf`` and ``log(np.inf***REMOVED***`` returns ``inf``***REMOVED***. Otherwise, the
    complex principle value is returned.

    Parameters
    ----------
    x : array_like
       The value(s***REMOVED*** whose log is (are***REMOVED*** required.

    Returns
    -------
    out : ndarray or scalar
       The log of the `x` value(s***REMOVED***. If `x` was a scalar, so is `out`,
       otherwise an array is returned.

    See Also
    --------
    numpy.log

    Notes
    -----
    For a log(***REMOVED*** that returns ``NAN`` when real `x < 0`, use `numpy.log`
    (note, however, that otherwise `numpy.log` and this `log` are identical,
    i.e., both return ``-inf`` for `x = 0`, ``inf`` for `x = inf`, and,
    notably, the complex principle value if ``x.imag != 0``***REMOVED***.

    Examples
    --------
    >>> np.emath.log(np.exp(1***REMOVED******REMOVED***
    1.0

    Negative arguments are handled "correctly" (recall that
    ``exp(log(x***REMOVED******REMOVED*** == x`` does *not* hold for real ``x < 0``***REMOVED***:

    >>> np.emath.log(-np.exp(1***REMOVED******REMOVED*** == (1 + np.pi * 1j***REMOVED***
    True

    ***REMOVED***
    x = _fix_real_lt_zero(x***REMOVED***
    return nx.log(x***REMOVED***

def log10(x***REMOVED***:
    ***REMOVED***
    Compute the logarithm base 10 of `x`.

    Return the "principal value" (for a description of this, see
    `numpy.log10`***REMOVED*** of :math:`log_{10***REMOVED***(x***REMOVED***`. For real `x > 0`, this
    is a real number (``log10(0***REMOVED***`` returns ``-inf`` and ``log10(np.inf***REMOVED***``
    returns ``inf``***REMOVED***. Otherwise, the complex principle value is returned.

    Parameters
    ----------
    x : array_like or scalar
       The value(s***REMOVED*** whose log base 10 is (are***REMOVED*** required.

    Returns
    -------
    out : ndarray or scalar
       The log base 10 of the `x` value(s***REMOVED***. If `x` was a scalar, so is `out`,
       otherwise an array object is returned.

    See Also
    --------
    numpy.log10

    Notes
    -----
    For a log10(***REMOVED*** that returns ``NAN`` when real `x < 0`, use `numpy.log10`
    (note, however, that otherwise `numpy.log10` and this `log10` are
    identical, i.e., both return ``-inf`` for `x = 0`, ``inf`` for `x = inf`,
    and, notably, the complex principle value if ``x.imag != 0``***REMOVED***.

    Examples
    --------

    (We set the printing precision so the example can be auto-tested***REMOVED***

    >>> np.set_printoptions(precision=4***REMOVED***

    >>> np.emath.log10(10**1***REMOVED***
    1.0

    >>> np.emath.log10([-10**1, -10**2, 10**2***REMOVED******REMOVED***
    array([ 1.+1.3644j,  2.+1.3644j,  2.+0.j    ***REMOVED******REMOVED***

    ***REMOVED***
    x = _fix_real_lt_zero(x***REMOVED***
    return nx.log10(x***REMOVED***

def logn(n, x***REMOVED***:
    ***REMOVED***
    Take log base n of x.

    If `x` contains negative inputs, the answer is computed and returned in the
    complex domain.

    Parameters
    ----------
    n : int
       The base in which the log is taken.
    x : array_like
       The value(s***REMOVED*** whose log base `n` is (are***REMOVED*** required.

    Returns
    -------
    out : ndarray or scalar
       The log base `n` of the `x` value(s***REMOVED***. If `x` was a scalar, so is
       `out`, otherwise an array is returned.

    Examples
    --------
    >>> np.set_printoptions(precision=4***REMOVED***

    >>> np.lib.scimath.logn(2, [4, 8***REMOVED******REMOVED***
    array([ 2.,  3.***REMOVED******REMOVED***
    >>> np.lib.scimath.logn(2, [-4, -8, 8***REMOVED******REMOVED***
    array([ 2.+4.5324j,  3.+4.5324j,  3.+0.j    ***REMOVED******REMOVED***

    ***REMOVED***
    x = _fix_real_lt_zero(x***REMOVED***
    n = _fix_real_lt_zero(n***REMOVED***
    return nx.log(x***REMOVED***/nx.log(n***REMOVED***

def log2(x***REMOVED***:
    ***REMOVED***
    Compute the logarithm base 2 of `x`.

    Return the "principal value" (for a description of this, see
    `numpy.log2`***REMOVED*** of :math:`log_2(x***REMOVED***`. For real `x > 0`, this is
    a real number (``log2(0***REMOVED***`` returns ``-inf`` and ``log2(np.inf***REMOVED***`` returns
    ``inf``***REMOVED***. Otherwise, the complex principle value is returned.

    Parameters
    ----------
    x : array_like
       The value(s***REMOVED*** whose log base 2 is (are***REMOVED*** required.

    Returns
    -------
    out : ndarray or scalar
       The log base 2 of the `x` value(s***REMOVED***. If `x` was a scalar, so is `out`,
       otherwise an array is returned.

    See Also
    --------
    numpy.log2

    Notes
    -----
    For a log2(***REMOVED*** that returns ``NAN`` when real `x < 0`, use `numpy.log2`
    (note, however, that otherwise `numpy.log2` and this `log2` are
    identical, i.e., both return ``-inf`` for `x = 0`, ``inf`` for `x = inf`,
    and, notably, the complex principle value if ``x.imag != 0``***REMOVED***.

    Examples
    --------
    We set the printing precision so the example can be auto-tested:

    >>> np.set_printoptions(precision=4***REMOVED***

    >>> np.emath.log2(8***REMOVED***
    3.0
    >>> np.emath.log2([-4, -8, 8***REMOVED******REMOVED***
    array([ 2.+4.5324j,  3.+4.5324j,  3.+0.j    ***REMOVED******REMOVED***

    ***REMOVED***
    x = _fix_real_lt_zero(x***REMOVED***
    return nx.log2(x***REMOVED***

def power(x, p***REMOVED***:
    ***REMOVED***
    Return x to the power p, (x**p***REMOVED***.

    If `x` contains negative values, the output is converted to the
    complex domain.

    Parameters
    ----------
    x : array_like
        The input value(s***REMOVED***.
    p : array_like of ints
        The power(s***REMOVED*** to which `x` is raised. If `x` contains multiple values,
        `p` has to either be a scalar, or contain the same number of values
        as `x`. In the latter case, the result is
        ``x[0***REMOVED*****p[0***REMOVED***, x[1***REMOVED*****p[1***REMOVED***, ...``.

    Returns
    -------
    out : ndarray or scalar
        The result of ``x**p``. If `x` and `p` are scalars, so is `out`,
        otherwise an array is returned.

    See Also
    --------
    numpy.power

    Examples
    --------
    >>> np.set_printoptions(precision=4***REMOVED***

    >>> np.lib.scimath.power([2, 4***REMOVED***, 2***REMOVED***
    array([ 4, 16***REMOVED******REMOVED***
    >>> np.lib.scimath.power([2, 4***REMOVED***, -2***REMOVED***
    array([ 0.25  ,  0.0625***REMOVED******REMOVED***
    >>> np.lib.scimath.power([-2, 4***REMOVED***, 2***REMOVED***
    array([  4.+0.j,  16.+0.j***REMOVED******REMOVED***

    ***REMOVED***
    x = _fix_real_lt_zero(x***REMOVED***
    p = _fix_int_lt_zero(p***REMOVED***
    return nx.power(x, p***REMOVED***

def arccos(x***REMOVED***:
    ***REMOVED***
    Compute the inverse cosine of x.

    Return the "principal value" (for a description of this, see
    `numpy.arccos`***REMOVED*** of the inverse cosine of `x`. For real `x` such that
    `abs(x***REMOVED*** <= 1`, this is a real number in the closed interval
    :math:`[0, \\pi***REMOVED***`.  Otherwise, the complex principle value is returned.

    Parameters
    ----------
    x : array_like or scalar
       The value(s***REMOVED*** whose arccos is (are***REMOVED*** required.

    Returns
    -------
    out : ndarray or scalar
       The inverse cosine(s***REMOVED*** of the `x` value(s***REMOVED***. If `x` was a scalar, so
       is `out`, otherwise an array object is returned.

    See Also
    --------
    numpy.arccos

    Notes
    -----
    For an arccos(***REMOVED*** that returns ``NAN`` when real `x` is not in the
    interval ``[-1,1***REMOVED***``, use `numpy.arccos`.

    Examples
    --------
    >>> np.set_printoptions(precision=4***REMOVED***

    >>> np.emath.arccos(1***REMOVED*** # a scalar is returned
    0.0

    >>> np.emath.arccos([1,2***REMOVED******REMOVED***
    array([ 0.-0.j   ,  0.+1.317j***REMOVED******REMOVED***

    ***REMOVED***
    x = _fix_real_abs_gt_1(x***REMOVED***
    return nx.arccos(x***REMOVED***

def arcsin(x***REMOVED***:
    ***REMOVED***
    Compute the inverse sine of x.

    Return the "principal value" (for a description of this, see
    `numpy.arcsin`***REMOVED*** of the inverse sine of `x`. For real `x` such that
    `abs(x***REMOVED*** <= 1`, this is a real number in the closed interval
    :math:`[-\\pi/2, \\pi/2***REMOVED***`.  Otherwise, the complex principle value is
    returned.

    Parameters
    ----------
    x : array_like or scalar
       The value(s***REMOVED*** whose arcsin is (are***REMOVED*** required.

    Returns
    -------
    out : ndarray or scalar
       The inverse sine(s***REMOVED*** of the `x` value(s***REMOVED***. If `x` was a scalar, so
       is `out`, otherwise an array object is returned.

    See Also
    --------
    numpy.arcsin

    Notes
    -----
    For an arcsin(***REMOVED*** that returns ``NAN`` when real `x` is not in the
    interval ``[-1,1***REMOVED***``, use `numpy.arcsin`.

    Examples
    --------
    >>> np.set_printoptions(precision=4***REMOVED***

    >>> np.emath.arcsin(0***REMOVED***
    0.0

    >>> np.emath.arcsin([0,1***REMOVED******REMOVED***
    array([ 0.    ,  1.5708***REMOVED******REMOVED***

    ***REMOVED***
    x = _fix_real_abs_gt_1(x***REMOVED***
    return nx.arcsin(x***REMOVED***

def arctanh(x***REMOVED***:
    ***REMOVED***
    Compute the inverse hyperbolic tangent of `x`.

    Return the "principal value" (for a description of this, see
    `numpy.arctanh`***REMOVED*** of `arctanh(x***REMOVED***`. For real `x` such that
    `abs(x***REMOVED*** < 1`, this is a real number.  If `abs(x***REMOVED*** > 1`, or if `x` is
    complex, the result is complex. Finally, `x = 1` returns``inf`` and
    `x=-1` returns ``-inf``.

    Parameters
    ----------
    x : array_like
       The value(s***REMOVED*** whose arctanh is (are***REMOVED*** required.

    Returns
    -------
    out : ndarray or scalar
       The inverse hyperbolic tangent(s***REMOVED*** of the `x` value(s***REMOVED***. If `x` was
       a scalar so is `out`, otherwise an array is returned.


    See Also
    --------
    numpy.arctanh

    Notes
    -----
    For an arctanh(***REMOVED*** that returns ``NAN`` when real `x` is not in the
    interval ``(-1,1***REMOVED***``, use `numpy.arctanh` (this latter, however, does
    return +/-inf for `x = +/-1`***REMOVED***.

    Examples
    --------
    >>> np.set_printoptions(precision=4***REMOVED***

    >>> np.emath.arctanh(np.matrix(np.eye(2***REMOVED******REMOVED******REMOVED***
    array([[ Inf,   0.***REMOVED***,
           [  0.,  Inf***REMOVED******REMOVED******REMOVED***
    >>> np.emath.arctanh([1j***REMOVED******REMOVED***
    array([ 0.+0.7854j***REMOVED******REMOVED***

    ***REMOVED***
    x = _fix_real_abs_gt_1(x***REMOVED***
    return nx.arctanh(x***REMOVED***
