from __future__ import division, absolute_import, print_function

***REMOVED***
import sys
import types
import re
import warnings

from numpy.core.numerictypes import issubclass_, issubsctype, issubdtype
from numpy.core import ndarray, ufunc, asarray

# getargspec and formatargspec were removed in Python 3.6
from numpy.compat import getargspec, formatargspec

__all__ = [
    'issubclass_', 'issubsctype', 'issubdtype', 'deprecate',
    'deprecate_with_doc', 'get_include', 'info', 'source', 'who',
    'lookfor', 'byte_bounds', 'safe_eval'
    ***REMOVED***

def get_include(***REMOVED***:
    ***REMOVED***
    Return the directory that contains the NumPy \\*.h header files.

    Extension modules that need to compile against NumPy should use this
    function to locate the appropriate include directory.

    Notes
    -----
    When using ``distutils``, for example in ``setup.py``.
    ::

        import numpy as np
        ...
        Extension('extension_name', ...
                include_dirs=[np.get_include(***REMOVED******REMOVED******REMOVED***
        ...

    ***REMOVED***
    import numpy
    if numpy.show_config is None:
        # running from numpy source directory
        d = os.path.join(os.path.dirname(numpy.__file__***REMOVED***, 'core', 'include'***REMOVED***
    else:
        # using installed numpy core headers
        import numpy.core as core
        d = os.path.join(os.path.dirname(core.__file__***REMOVED***, 'include'***REMOVED***
    return d


def _set_function_name(func, name***REMOVED***:
    func.__name__ = name
    return func


class _Deprecate(object***REMOVED***:
    ***REMOVED***
    Decorator class to deprecate old functions.

    Refer to `deprecate` for details.

    See Also
    --------
    deprecate

    ***REMOVED***

    def __init__(self, old_name=None, new_name=None, message=None***REMOVED***:
        self.old_name = old_name
        self.new_name = new_name
        self.message = message

    def __call__(self, func, *args, **kwargs***REMOVED***:
        ***REMOVED***
        Decorator call.  Refer to ``decorate``.

        ***REMOVED***
        old_name = self.old_name
        new_name = self.new_name
        message = self.message

        import warnings
        if old_name is None:
            ***REMOVED***
                old_name = func.__name__
            except AttributeError:
                old_name = func.__name__
        if new_name is None:
            depdoc = "`%s` is deprecated!" % old_name
        else:
            depdoc = "`%s` is deprecated, use `%s` instead!" % \
                     (old_name, new_name***REMOVED***

        if message is not None:
            depdoc += "\n" + message

        def newfunc(*args,**kwds***REMOVED***:
            ***REMOVED***`arrayrange` is deprecated, use `arange` instead!***REMOVED***
            warnings.warn(depdoc, DeprecationWarning***REMOVED***
            return func(*args, **kwds***REMOVED***

        newfunc = _set_function_name(newfunc, old_name***REMOVED***
        doc = func.__doc__
        if doc is None:
            doc = depdoc
        else:
            doc = '\n\n'.join([depdoc, doc***REMOVED******REMOVED***
        newfunc.__doc__ = doc
        ***REMOVED***
            d = func.__dict__
        except AttributeError:
            pass
        else:
            newfunc.__dict__.update(d***REMOVED***
        return newfunc

def deprecate(*args, **kwargs***REMOVED***:
    ***REMOVED***
    Issues a DeprecationWarning, adds warning to `old_name`'s
    docstring, rebinds ``old_name.__name__`` and returns the new
    function object.

    This function may also be used as a decorator.

    Parameters
    ----------
    func : function
        The function to be deprecated.
    old_name : str, optional
        The name of the function to be deprecated. Default is None, in
        which case the name of `func` is used.
    new_name : str, optional
        The new name for the function. Default is None, in which case the
        deprecation message is that `old_name` is deprecated. If given, the
        deprecation message is that `old_name` is deprecated and `new_name`
        should be used instead.
    message : str, optional
        Additional explanation of the deprecation.  Displayed in the
        docstring after the warning.

    Returns
    -------
    old_func : function
        The deprecated function.

    Examples
    --------
    Note that ``olduint`` returns a value after printing Deprecation
    Warning:

    >>> olduint = np.deprecate(np.uint***REMOVED***
    >>> olduint(6***REMOVED***
    /usr/lib/python2.5/site-packages/numpy/lib/utils.py:114:
    DeprecationWarning: uint32 is deprecated
      warnings.warn(str1, DeprecationWarning***REMOVED***
    6

    ***REMOVED***
    # Deprecate may be run as a function or as a decorator
    # If run as a function, we initialise the decorator class
    # and execute its __call__ method.

    if args:
        fn = args[0***REMOVED***
        args = args[1:***REMOVED***

        # backward compatibility -- can be removed
        # after next release
        if 'newname' in kwargs:
            kwargs['new_name'***REMOVED*** = kwargs.pop('newname'***REMOVED***
        if 'oldname' in kwargs:
            kwargs['old_name'***REMOVED*** = kwargs.pop('oldname'***REMOVED***

        return _Deprecate(*args, **kwargs***REMOVED***(fn***REMOVED***
    else:
        return _Deprecate(*args, **kwargs***REMOVED***

deprecate_with_doc = lambda msg: _Deprecate(message=msg***REMOVED***


#--------------------------------------------
# Determine if two arrays can share memory
#--------------------------------------------

def byte_bounds(a***REMOVED***:
    ***REMOVED***
    Returns pointers to the end-points of an array.

    Parameters
    ----------
    a : ndarray
        Input array. It must conform to the Python-side of the array
        interface.

    Returns
    -------
    (low, high***REMOVED*** : tuple of 2 integers
        The first integer is the first byte of the array, the second
        integer is just past the last byte of the array.  If `a` is not
        contiguous it will not use every byte between the (`low`, `high`***REMOVED***
        values.

    Examples
    --------
    >>> I = np.eye(2, dtype='f'***REMOVED***; I.dtype
    dtype('float32'***REMOVED***
    >>> low, high = np.byte_bounds(I***REMOVED***
    >>> high - low == I.size*I.itemsize
    True
    >>> I = np.eye(2, dtype='G'***REMOVED***; I.dtype
    dtype('complex192'***REMOVED***
    >>> low, high = np.byte_bounds(I***REMOVED***
    >>> high - low == I.size*I.itemsize
    True

    ***REMOVED***
    ai = a.__array_interface__
    a_data = ai['data'***REMOVED***[0***REMOVED***
    astrides = ai['strides'***REMOVED***
    ashape = ai['shape'***REMOVED***
    bytes_a = asarray(a***REMOVED***.dtype.itemsize

    a_low = a_high = a_data
    if astrides is None:
        # contiguous case
        a_high += a.size * bytes_a
    else:
        for shape, stride in zip(ashape, astrides***REMOVED***:
            if stride < 0:
                a_low += (shape-1***REMOVED****stride
            else:
                a_high += (shape-1***REMOVED****stride
        a_high += bytes_a
    return a_low, a_high


#-----------------------------------------------------------------------------
# Function for output and information on the variables used.
#-----------------------------------------------------------------------------


def who(vardict=None***REMOVED***:
    ***REMOVED***
    Print the Numpy arrays in the given dictionary.

    If there is no dictionary passed in or `vardict` is None then returns
    Numpy arrays in the globals(***REMOVED*** dictionary (all Numpy arrays in the
    namespace***REMOVED***.

    Parameters
    ----------
    vardict : dict, optional
        A dictionary possibly containing ndarrays.  Default is globals(***REMOVED***.

    Returns
    -------
    out : None
        Returns 'None'.

    Notes
    -----
    Prints out the name, shape, bytes and type of all of the ndarrays
    present in `vardict`.

    Examples
    --------
    >>> a = np.arange(10***REMOVED***
    >>> b = np.ones(20***REMOVED***
    >>> np.who(***REMOVED***
    Name            Shape            Bytes            Type
    ===========================================================
    a               10               40               int32
    b               20               160              float64
    Upper bound on total bytes  =       200

    >>> d = {'x': np.arange(2.0***REMOVED***, 'y': np.arange(3.0***REMOVED***, 'txt': 'Some str',
    ... 'idx':5***REMOVED***
    >>> np.who(d***REMOVED***
    Name            Shape            Bytes            Type
    ===========================================================
    y               3                24               float64
    x               2                16               float64
    Upper bound on total bytes  =       40

    ***REMOVED***
    if vardict is None:
        frame = sys._getframe(***REMOVED***.f_back
        vardict = frame.f_globals
    sta = [***REMOVED***
    cache = {***REMOVED***
    for name in vardict.keys(***REMOVED***:
        if isinstance(vardict[name***REMOVED***, ndarray***REMOVED***:
            var = vardict[name***REMOVED***
            idv = id(var***REMOVED***
            if idv in cache.keys(***REMOVED***:
                namestr = name + " (%s***REMOVED***" % cache[idv***REMOVED***
                original = 0
            else:
                cache[idv***REMOVED*** = name
                namestr = name
                original = 1
            shapestr = " x ".join(map(str, var.shape***REMOVED******REMOVED***
            bytestr = str(var.nbytes***REMOVED***
            sta.append([namestr, shapestr, bytestr, var.dtype.name,
                        original***REMOVED******REMOVED***

    maxname = 0
    maxshape = 0
    maxbyte = 0
    totalbytes = 0
    for k in range(len(sta***REMOVED******REMOVED***:
        val = sta[k***REMOVED***
        if maxname < len(val[0***REMOVED******REMOVED***:
            maxname = len(val[0***REMOVED******REMOVED***
        if maxshape < len(val[1***REMOVED******REMOVED***:
            maxshape = len(val[1***REMOVED******REMOVED***
        if maxbyte < len(val[2***REMOVED******REMOVED***:
            maxbyte = len(val[2***REMOVED******REMOVED***
        if val[4***REMOVED***:
            totalbytes += int(val[2***REMOVED******REMOVED***

    if len(sta***REMOVED*** > 0:
        sp1 = max(10, maxname***REMOVED***
        sp2 = max(10, maxshape***REMOVED***
        sp3 = max(10, maxbyte***REMOVED***
        prval = "Name %s Shape %s Bytes %s Type" % (sp1*' ', sp2*' ', sp3*' '***REMOVED***
        print(prval + "\n" + "="*(len(prval***REMOVED***+5***REMOVED*** + "\n"***REMOVED***

    for k in range(len(sta***REMOVED******REMOVED***:
        val = sta[k***REMOVED***
        print("%s %s %s %s %s %s %s" % (val[0***REMOVED***, ' '*(sp1-len(val[0***REMOVED******REMOVED***+4***REMOVED***,
                                        val[1***REMOVED***, ' '*(sp2-len(val[1***REMOVED******REMOVED***+5***REMOVED***,
                                        val[2***REMOVED***, ' '*(sp3-len(val[2***REMOVED******REMOVED***+5***REMOVED***,
                                        val[3***REMOVED******REMOVED******REMOVED***
    print("\nUpper bound on total bytes  =       %d" % totalbytes***REMOVED***
    return

#-----------------------------------------------------------------------------


# NOTE:  pydoc defines a help function which works simliarly to this
#  except it uses a pager to take over the screen.

# combine name and arguments and split to multiple lines of width
# characters.  End lines on a comma and begin argument list indented with
# the rest of the arguments.
def _split_line(name, arguments, width***REMOVED***:
    firstwidth = len(name***REMOVED***
    k = firstwidth
    newstr = name
    sepstr = ", "
    arglist = arguments.split(sepstr***REMOVED***
    for argument in arglist:
        if k == firstwidth:
            addstr = ""
        else:
            addstr = sepstr
        k = k + len(argument***REMOVED*** + len(addstr***REMOVED***
        if k > width:
            k = firstwidth + 1 + len(argument***REMOVED***
            newstr = newstr + ",\n" + " "*(firstwidth+2***REMOVED*** + argument
        else:
            newstr = newstr + addstr + argument
    return newstr

_namedict = None
_dictlist = None

# Traverse all module directories underneath globals
# to see if something is defined
def _makenamedict(module='numpy'***REMOVED***:
    module = __import__(module, globals(***REMOVED***, locals(***REMOVED***, [***REMOVED******REMOVED***
    thedict = {module.__name__:module.__dict__***REMOVED***
    dictlist = [module.__name__***REMOVED***
    totraverse = [module.__dict__***REMOVED***
    while True:
        if len(totraverse***REMOVED*** == 0:
            break
        thisdict = totraverse.pop(0***REMOVED***
        for x in thisdict.keys(***REMOVED***:
            if isinstance(thisdict[x***REMOVED***, types.ModuleType***REMOVED***:
                modname = thisdict[x***REMOVED***.__name__
                if modname not in dictlist:
                    moddict = thisdict[x***REMOVED***.__dict__
                    dictlist.append(modname***REMOVED***
                    totraverse.append(moddict***REMOVED***
                    thedict[modname***REMOVED*** = moddict
    return thedict, dictlist


def _info(obj, output=sys.stdout***REMOVED***:
    ***REMOVED***Provide information about ndarray obj.

    Parameters
    ----------
    obj: ndarray
        Must be ndarray, not checked.
    output:
        Where printed output goes.

    Notes
    -----
    Copied over from the numarray module prior to its removal.
    Adapted somewhat as only numpy is an option now.

    Called by info.

    ***REMOVED***
    extra = ""
    tic = ""
    bp = lambda x: x
    cls = getattr(obj, '__class__', type(obj***REMOVED******REMOVED***
    nm = getattr(cls, '__name__', cls***REMOVED***
    strides = obj.strides
    endian = obj.dtype.byteorder

    print("class: ", nm, file=output***REMOVED***
    print("shape: ", obj.shape, file=output***REMOVED***
    print("strides: ", strides, file=output***REMOVED***
    print("itemsize: ", obj.itemsize, file=output***REMOVED***
    print("aligned: ", bp(obj.flags.aligned***REMOVED***, file=output***REMOVED***
    print("contiguous: ", bp(obj.flags.contiguous***REMOVED***, file=output***REMOVED***
    print("fortran: ", obj.flags.fortran, file=output***REMOVED***
    print(
        "data pointer: %s%s" % (hex(obj.ctypes._as_parameter_.value***REMOVED***, extra***REMOVED***,
        file=output
        ***REMOVED***
    print("byteorder: ", end=' ', file=output***REMOVED***
    if endian in ['|', '='***REMOVED***:
        print("%s%s%s" % (tic, sys.byteorder, tic***REMOVED***, file=output***REMOVED***
        byteswap = False
    elif endian == '>':
        print("%sbig%s" % (tic, tic***REMOVED***, file=output***REMOVED***
        byteswap = sys.byteorder != "big"
    else:
        print("%slittle%s" % (tic, tic***REMOVED***, file=output***REMOVED***
        byteswap = sys.byteorder != "little"
    print("byteswap: ", bp(byteswap***REMOVED***, file=output***REMOVED***
    print("type: %s" % obj.dtype, file=output***REMOVED***


def info(object=None, maxwidth=76, output=sys.stdout, toplevel='numpy'***REMOVED***:
    ***REMOVED***
    Get help information for a function, class, or module.

    Parameters
    ----------
    object : object or str, optional
        Input object or name to get information about. If `object` is a
        numpy object, its docstring is given. If it is a string, available
        modules are searched for matching objects.  If None, information
        about `info` itself is returned.
    maxwidth : int, optional
        Printing width.
    output : file like object, optional
        File like object that the output is written to, default is
        ``stdout``.  The object has to be opened in 'w' or 'a' mode.
    toplevel : str, optional
        Start search at this level.

    See Also
    --------
    source, lookfor

    Notes
    -----
    When used interactively with an object, ``np.info(obj***REMOVED***`` is equivalent
    to ``help(obj***REMOVED***`` on the Python prompt or ``obj?`` on the IPython
    prompt.

    Examples
    --------
    >>> np.info(np.polyval***REMOVED*** # doctest: +SKIP
       polyval(p, x***REMOVED***
         Evaluate the polynomial p at x.
         ...

    When using a string for `object` it is possible to get multiple results.

    >>> np.info('fft'***REMOVED*** # doctest: +SKIP
         *** Found in numpy ***
    Core FFT routines
    ...
         *** Found in numpy.fft ***
     fft(a, n=None, axis=-1***REMOVED***
    ...
         *** Repeat reference found in numpy.fft.fftpack ***
         *** Total of 3 references found. ***

    ***REMOVED***
    global _namedict, _dictlist
    # Local import to speed up numpy's import time.
    import pydoc
    import inspect

    if (hasattr(object, '_ppimport_importer'***REMOVED*** or
           hasattr(object, '_ppimport_module'***REMOVED******REMOVED***:
        object = object._ppimport_module
    elif hasattr(object, '_ppimport_attr'***REMOVED***:
        object = object._ppimport_attr

    if object is None:
        info(info***REMOVED***
    elif isinstance(object, ndarray***REMOVED***:
        _info(object, output=output***REMOVED***
    elif isinstance(object, str***REMOVED***:
        if _namedict is None:
            _namedict, _dictlist = _makenamedict(toplevel***REMOVED***
        numfound = 0
        objlist = [***REMOVED***
        for namestr in _dictlist:
            ***REMOVED***
                obj = _namedict[namestr***REMOVED***[object***REMOVED***
                if id(obj***REMOVED*** in objlist:
                    print("\n     "
                          "*** Repeat reference found in %s *** " % namestr,
                          file=output
                          ***REMOVED***
                else:
                    objlist.append(id(obj***REMOVED******REMOVED***
                    print("     *** Found in %s ***" % namestr, file=output***REMOVED***
                    info(obj***REMOVED***
                    print("-"*maxwidth, file=output***REMOVED***
                numfound += 1
            except KeyError:
                pass
        if numfound == 0:
            print("Help for %s not found." % object, file=output***REMOVED***
        else:
            print("\n     "
                  "*** Total of %d references found. ***" % numfound,
                  file=output
                  ***REMOVED***

    elif inspect.isfunction(object***REMOVED***:
        name = object.__name__
        arguments = formatargspec(*getargspec(object***REMOVED******REMOVED***

        if len(name+arguments***REMOVED*** > maxwidth:
            argstr = _split_line(name, arguments, maxwidth***REMOVED***
        else:
            argstr = name + arguments

        print(" " + argstr + "\n", file=output***REMOVED***
        print(inspect.getdoc(object***REMOVED***, file=output***REMOVED***

    elif inspect.isclass(object***REMOVED***:
        name = object.__name__
        arguments = "(***REMOVED***"
        ***REMOVED***
            if hasattr(object, '__init__'***REMOVED***:
                arguments = formatargspec(
                        *getargspec(object.__init__.__func__***REMOVED***
                        ***REMOVED***
                arglist = arguments.split(', '***REMOVED***
                if len(arglist***REMOVED*** > 1:
                    arglist[1***REMOVED*** = "("+arglist[1***REMOVED***
                    arguments = ", ".join(arglist[1:***REMOVED******REMOVED***
        ***REMOVED***
            pass

        if len(name+arguments***REMOVED*** > maxwidth:
            argstr = _split_line(name, arguments, maxwidth***REMOVED***
        else:
            argstr = name + arguments

        print(" " + argstr + "\n", file=output***REMOVED***
        doc1 = inspect.getdoc(object***REMOVED***
        if doc1 is None:
            if hasattr(object, '__init__'***REMOVED***:
                print(inspect.getdoc(object.__init__***REMOVED***, file=output***REMOVED***
        else:
            print(inspect.getdoc(object***REMOVED***, file=output***REMOVED***

        methods = pydoc.allmethods(object***REMOVED***
        if methods != [***REMOVED***:
            print("\n\nMethods:\n", file=output***REMOVED***
            for meth in methods:
                if meth[0***REMOVED*** == '_':
                    continue
                thisobj = getattr(object, meth, None***REMOVED***
                if thisobj is not None:
                    methstr, other = pydoc.splitdoc(
                            inspect.getdoc(thisobj***REMOVED*** or "None"
                            ***REMOVED***
                print("  %s  --  %s" % (meth, methstr***REMOVED***, file=output***REMOVED***

    elif (sys.version_info[0***REMOVED*** < 3
            and isinstance(object, types.InstanceType***REMOVED******REMOVED***:
        # check for __call__ method
        # types.InstanceType is the type of the instances of oldstyle classes
        print("Instance of class: ", object.__class__.__name__, file=output***REMOVED***
        print(file=output***REMOVED***
        if hasattr(object, '__call__'***REMOVED***:
            arguments = formatargspec(
                    *getargspec(object.__call__.__func__***REMOVED***
                    ***REMOVED***
            arglist = arguments.split(', '***REMOVED***
            if len(arglist***REMOVED*** > 1:
                arglist[1***REMOVED*** = "("+arglist[1***REMOVED***
                arguments = ", ".join(arglist[1:***REMOVED******REMOVED***
            else:
                arguments = "(***REMOVED***"

            if hasattr(object, 'name'***REMOVED***:
                name = "%s" % object.name
            else:
                name = "<name>"
            if len(name+arguments***REMOVED*** > maxwidth:
                argstr = _split_line(name, arguments, maxwidth***REMOVED***
            else:
                argstr = name + arguments

            print(" " + argstr + "\n", file=output***REMOVED***
            doc = inspect.getdoc(object.__call__***REMOVED***
            if doc is not None:
                print(inspect.getdoc(object.__call__***REMOVED***, file=output***REMOVED***
            print(inspect.getdoc(object***REMOVED***, file=output***REMOVED***

        else:
            print(inspect.getdoc(object***REMOVED***, file=output***REMOVED***

    elif inspect.ismethod(object***REMOVED***:
        name = object.__name__
        arguments = formatargspec(
                *getargspec(object.__func__***REMOVED***
                ***REMOVED***
        arglist = arguments.split(', '***REMOVED***
        if len(arglist***REMOVED*** > 1:
            arglist[1***REMOVED*** = "("+arglist[1***REMOVED***
            arguments = ", ".join(arglist[1:***REMOVED******REMOVED***
        else:
            arguments = "(***REMOVED***"

        if len(name+arguments***REMOVED*** > maxwidth:
            argstr = _split_line(name, arguments, maxwidth***REMOVED***
        else:
            argstr = name + arguments

        print(" " + argstr + "\n", file=output***REMOVED***
        print(inspect.getdoc(object***REMOVED***, file=output***REMOVED***

    elif hasattr(object, '__doc__'***REMOVED***:
        print(inspect.getdoc(object***REMOVED***, file=output***REMOVED***


def source(object, output=sys.stdout***REMOVED***:
    ***REMOVED***
    Print or write to a file the source code for a Numpy object.

    The source code is only returned for objects written in Python. Many
    functions and classes are defined in C and will therefore not return
    useful information.

    Parameters
    ----------
    object : numpy object
        Input object. This can be any object (function, class, module,
        ...***REMOVED***.
    output : file object, optional
        If `output` not supplied then source code is printed to screen
        (sys.stdout***REMOVED***.  File object must be created with either write 'w' or
        append 'a' modes.

    See Also
    --------
    lookfor, info

    Examples
    --------
    >>> np.source(np.interp***REMOVED***                        #doctest: +SKIP
    In file: /usr/lib/python2.6/dist-packages/numpy/lib/function_base.py
    def interp(x, xp, fp, left=None, right=None***REMOVED***:
        \"\"\".... (full docstring printed***REMOVED***\"\"\"
        if isinstance(x, (float, int, number***REMOVED******REMOVED***:
            return compiled_interp([x***REMOVED***, xp, fp, left, right***REMOVED***.item(***REMOVED***
        else:
            return compiled_interp(x, xp, fp, left, right***REMOVED***

    The source code is only returned for objects written in Python.

    >>> np.source(np.array***REMOVED***                         #doctest: +SKIP
    Not available for this object.

    ***REMOVED***
    # Local import to speed up numpy's import time.
    import inspect
    ***REMOVED***
        print("In file: %s\n" % inspect.getsourcefile(object***REMOVED***, file=output***REMOVED***
        print(inspect.getsource(object***REMOVED***, file=output***REMOVED***
    ***REMOVED***
        print("Not available for this object.", file=output***REMOVED***


# Cache for lookfor: {id(module***REMOVED***: {name: (docstring, kind, index***REMOVED***, ...***REMOVED***...***REMOVED***
# where kind: "func", "class", "module", "object"
# and index: index in breadth-first namespace traversal
_lookfor_caches = {***REMOVED***

# regexp whose match indicates that the string may contain a function
# signature
_function_signature_re = re.compile(r"[a-z0-9_***REMOVED***+\(.*[,=***REMOVED***.*\***REMOVED***", re.I***REMOVED***

def lookfor(what, module=None, import_modules=True, regenerate=False,
            output=None***REMOVED***:
    ***REMOVED***
    Do a keyword search on docstrings.

    A list of of objects that matched the search is displayed,
    sorted by relevance. All given keywords need to be found in the
    docstring for it to be returned as a result, but the order does
    not matter.

    Parameters
    ----------
    what : str
        String containing words to look for.
    module : str or list, optional
        Name of module(s***REMOVED*** whose docstrings to go through.
    import_modules : bool, optional
        Whether to import sub-modules in packages. Default is True.
    regenerate : bool, optional
        Whether to re-generate the docstring cache. Default is False.
    output : file-like, optional
        File-like object to write the output to. If omitted, use a pager.

    See Also
    --------
    source, info

    Notes
    -----
    Relevance is determined only roughly, by checking if the keywords occur
    in the function name, at the start of a docstring, etc.

    Examples
    --------
    >>> np.lookfor('binary representation'***REMOVED***
    Search results for 'binary representation'
    ------------------------------------------
    numpy.binary_repr
        Return the binary representation of the input number as a string.
    numpy.core.setup_common.long_double_representation
        Given a binary dump as given by GNU od -b, look for long double
    numpy.base_repr
        Return a string representation of a number in the given base system.
    ...

    ***REMOVED***
    import pydoc

    # Cache
    cache = _lookfor_generate_cache(module, import_modules, regenerate***REMOVED***

    # Search
    # XXX: maybe using a real stemming search engine would be better?
    found = [***REMOVED***
    whats = str(what***REMOVED***.lower(***REMOVED***.split(***REMOVED***
    if not whats:
        return

    for name, (docstring, kind, index***REMOVED*** in cache.items(***REMOVED***:
        if kind in ('module', 'object'***REMOVED***:
            # don't show modules or objects
            continue
        ok = True
        doc = docstring.lower(***REMOVED***
        for w in whats:
            if w not in doc:
                ok = False
                break
        if ok:
            found.append(name***REMOVED***

    # Relevance sort
    # XXX: this is full Harrison-Stetson heuristics now,
    # XXX: it probably could be improved

    kind_relevance = {'func': 1000, 'class': 1000,
                      'module': -1000, 'object': -1000***REMOVED***

    def relevance(name, docstr, kind, index***REMOVED***:
        r = 0
        # do the keywords occur within the start of the docstring?
        first_doc = "\n".join(docstr.lower(***REMOVED***.strip(***REMOVED***.split("\n"***REMOVED***[:3***REMOVED******REMOVED***
        r += sum([200 for w in whats if w in first_doc***REMOVED******REMOVED***
        # do the keywords occur in the function name?
        r += sum([30 for w in whats if w in name***REMOVED******REMOVED***
        # is the full name long?
        r += -len(name***REMOVED*** * 5
        # is the object of bad type?
        r += kind_relevance.get(kind, -1000***REMOVED***
        # is the object deep in namespace hierarchy?
        r += -name.count('.'***REMOVED*** * 10
        r += max(-index / 100, -100***REMOVED***
        return r

    def relevance_value(a***REMOVED***:
        return relevance(a, *cache[a***REMOVED******REMOVED***
    found.sort(key=relevance_value***REMOVED***

    # Pretty-print
    s = "Search results for '%s'" % (' '.join(whats***REMOVED******REMOVED***
    help_text = [s, "-"*len(s***REMOVED******REMOVED***
    for name in found[::-1***REMOVED***:
        doc, kind, ix = cache[name***REMOVED***

        doclines = [line.strip(***REMOVED*** for line in doc.strip(***REMOVED***.split("\n"***REMOVED***
                    if line.strip(***REMOVED******REMOVED***

        # find a suitable short description
        ***REMOVED***
            first_doc = doclines[0***REMOVED***.strip(***REMOVED***
            if _function_signature_re.search(first_doc***REMOVED***:
                first_doc = doclines[1***REMOVED***.strip(***REMOVED***
        except IndexError:
            first_doc = ""
        help_text.append("%s\n    %s" % (name, first_doc***REMOVED******REMOVED***

    if not found:
        help_text.append("Nothing found."***REMOVED***

    # Output
    if output is not None:
        output.write("\n".join(help_text***REMOVED******REMOVED***
    elif len(help_text***REMOVED*** > 10:
        pager = pydoc.getpager(***REMOVED***
        pager("\n".join(help_text***REMOVED******REMOVED***
    else:
        print("\n".join(help_text***REMOVED******REMOVED***

def _lookfor_generate_cache(module, import_modules, regenerate***REMOVED***:
    ***REMOVED***
    Generate docstring cache for given module.

    Parameters
    ----------
    module : str, None, module
        Module for which to generate docstring cache
    import_modules : bool
        Whether to import sub-modules in packages.
    regenerate : bool
        Re-generate the docstring cache

    Returns
    -------
    cache : dict {obj_full_name: (docstring, kind, index***REMOVED***, ...***REMOVED***
        Docstring cache for the module, either cached one (regenerate=False***REMOVED***
        or newly generated.

    ***REMOVED***
    global _lookfor_caches
    # Local import to speed up numpy's import time.
    import inspect

    if sys.version_info[0***REMOVED*** >= 3:
        # In Python3 stderr, stdout are text files.
        from io import StringIO
    else:
        from StringIO import StringIO

    if module is None:
        module = "numpy"

    if isinstance(module, str***REMOVED***:
        ***REMOVED***
            __import__(module***REMOVED***
        except ImportError:
            return {***REMOVED***
        module = sys.modules[module***REMOVED***
    elif isinstance(module, list***REMOVED*** or isinstance(module, tuple***REMOVED***:
        cache = {***REMOVED***
        for mod in module:
            cache.update(_lookfor_generate_cache(mod, import_modules,
                                                 regenerate***REMOVED******REMOVED***
        return cache

    if id(module***REMOVED*** in _lookfor_caches and not regenerate:
        return _lookfor_caches[id(module***REMOVED******REMOVED***

    # walk items and collect docstrings
    cache = {***REMOVED***
    _lookfor_caches[id(module***REMOVED******REMOVED*** = cache
    seen = {***REMOVED***
    index = 0
    stack = [(module.__name__, module***REMOVED******REMOVED***
    while stack:
        name, item = stack.pop(0***REMOVED***
        if id(item***REMOVED*** in seen:
            continue
        seen[id(item***REMOVED******REMOVED*** = True

        index += 1
        kind = "object"

        if inspect.ismodule(item***REMOVED***:
            kind = "module"
            ***REMOVED***
                _all = item.__all__
            except AttributeError:
                _all = None

            # import sub-packages
            if import_modules and hasattr(item, '__path__'***REMOVED***:
                for pth in item.__path__:
                    for mod_path in os.listdir(pth***REMOVED***:
                        this_py = os.path.join(pth, mod_path***REMOVED***
                        init_py = os.path.join(pth, mod_path, '__init__.py'***REMOVED***
                        if (os.path.isfile(this_py***REMOVED*** and
                                mod_path.endswith('.py'***REMOVED******REMOVED***:
                            to_import = mod_path[:-3***REMOVED***
                        elif os.path.isfile(init_py***REMOVED***:
                            to_import = mod_path
                        else:
                            continue
                        if to_import == '__init__':
                            continue

                        ***REMOVED***
                            # Catch SystemExit, too
                            base_exc = BaseException
                        except NameError:
                            # Python 2.4 doesn't have BaseException
                            base_exc = Exception

                        ***REMOVED***
                            old_stdout = sys.stdout
                            old_stderr = sys.stderr
                            ***REMOVED***
                                sys.stdout = StringIO(***REMOVED***
                                sys.stderr = StringIO(***REMOVED***
                                __import__("%s.%s" % (name, to_import***REMOVED******REMOVED***
                            finally:
                                sys.stdout = old_stdout
                                sys.stderr = old_stderr
                        except base_exc:
                            continue

            for n, v in _getmembers(item***REMOVED***:
                ***REMOVED***
                    item_name = getattr(v, '__name__', "%s.%s" % (name, n***REMOVED******REMOVED***
                    mod_name = getattr(v, '__module__', None***REMOVED***
                except NameError:
                    # ref. SWIG's global cvars
                    #    NameError: Unknown C global variable
                    item_name = "%s.%s" % (name, n***REMOVED***
                    mod_name = None
                if '.' not in item_name and mod_name:
                    item_name = "%s.%s" % (mod_name, item_name***REMOVED***

                if not item_name.startswith(name + '.'***REMOVED***:
                    # don't crawl "foreign" objects
                    if isinstance(v, ufunc***REMOVED***:
                        # ... unless they are ufuncs
                        pass
                    else:
                        continue
                elif not (inspect.ismodule(v***REMOVED*** or _all is None or n in _all***REMOVED***:
                    continue
                stack.append(("%s.%s" % (name, n***REMOVED***, v***REMOVED******REMOVED***
        elif inspect.isclass(item***REMOVED***:
            kind = "class"
            for n, v in _getmembers(item***REMOVED***:
                stack.append(("%s.%s" % (name, n***REMOVED***, v***REMOVED******REMOVED***
        elif hasattr(item, "__call__"***REMOVED***:
            kind = "func"

        ***REMOVED***
            doc = inspect.getdoc(item***REMOVED***
        except NameError:
            # ref SWIG's NameError: Unknown C global variable
            doc = None
        if doc is not None:
            cache[name***REMOVED*** = (doc, kind, index***REMOVED***

    return cache

def _getmembers(item***REMOVED***:
    import inspect
    ***REMOVED***
        members = inspect.getmembers(item***REMOVED***
    except Exception:
        members = [(x, getattr(item, x***REMOVED******REMOVED*** for x in dir(item***REMOVED***
                   if hasattr(item, x***REMOVED******REMOVED***
    return members

#-----------------------------------------------------------------------------

# The following SafeEval class and company are adapted from Michael Spencer's
# ASPN Python Cookbook recipe:
#   http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/364469
# Accordingly it is mostly Copyright 2006 by Michael Spencer.
# The recipe, like most of the other ASPN Python Cookbook recipes was made
# available under the Python license.
#   http://www.python.org/license

# It has been modified to:
#   * handle unary -/+
#   * support True/False/None
#   * raise SyntaxError instead of a custom exception.

class SafeEval(object***REMOVED***:
    ***REMOVED***
    Object to evaluate constant string expressions.

    This includes strings with lists, dicts and tuples using the abstract
    syntax tree created by ``compiler.parse``.

    .. deprecated:: 1.10.0

    See Also
    --------
    safe_eval

    ***REMOVED***
    def __init__(self***REMOVED***:
        # 2014-10-15, 1.10
        warnings.warn("SafeEval is deprecated in 1.10 and will be removed.",
                      DeprecationWarning***REMOVED***

    def visit(self, node***REMOVED***:
        cls = node.__class__
        meth = getattr(self, 'visit' + cls.__name__, self.default***REMOVED***
        return meth(node***REMOVED***

    def default(self, node***REMOVED***:
        raise SyntaxError("Unsupported source construct: %s"
                          % node.__class__***REMOVED***

    def visitExpression(self, node***REMOVED***:
        return self.visit(node.body***REMOVED***

    def visitNum(self, node***REMOVED***:
        return node.n

    def visitStr(self, node***REMOVED***:
        return node.s

    def visitBytes(self, node***REMOVED***:
        return node.s

    def visitDict(self, node,**kw***REMOVED***:
        return dict([(self.visit(k***REMOVED***, self.visit(v***REMOVED******REMOVED***
                     for k, v in zip(node.keys, node.values***REMOVED******REMOVED******REMOVED***

    def visitTuple(self, node***REMOVED***:
        return tuple([self.visit(i***REMOVED*** for i in node.elts***REMOVED******REMOVED***

    def visitList(self, node***REMOVED***:
        return [self.visit(i***REMOVED*** for i in node.elts***REMOVED***

    def visitUnaryOp(self, node***REMOVED***:
        import ast
        if isinstance(node.op, ast.UAdd***REMOVED***:
            return +self.visit(node.operand***REMOVED***
        elif isinstance(node.op, ast.USub***REMOVED***:
            return -self.visit(node.operand***REMOVED***
        else:
            raise SyntaxError("Unknown unary op: %r" % node.op***REMOVED***

    def visitName(self, node***REMOVED***:
        if node.id == 'False':
            return False
        elif node.id == 'True':
            return True
        elif node.id == 'None':
            return None
        else:
            raise SyntaxError("Unknown name: %s" % node.id***REMOVED***

    def visitNameConstant(self, node***REMOVED***:
        return node.value


def safe_eval(source***REMOVED***:
    ***REMOVED***
    Protected string evaluation.

    Evaluate a string containing a Python literal expression without
    allowing the execution of arbitrary non-literal code.

    Parameters
    ----------
    source : str
        The string to evaluate.

    Returns
    -------
    obj : object
       The result of evaluating `source`.

    Raises
    ------
    SyntaxError
        If the code has invalid Python syntax, or if it contains
        non-literal code.

    Examples
    --------
    >>> np.safe_eval('1'***REMOVED***
    1
    >>> np.safe_eval('[1, 2, 3***REMOVED***'***REMOVED***
    [1, 2, 3***REMOVED***
    >>> np.safe_eval('{"foo": ("bar", 10.0***REMOVED******REMOVED***'***REMOVED***
***REMOVED***'foo': ('bar', 10.0***REMOVED******REMOVED***

    >>> np.safe_eval('***REMOVED***'***REMOVED***
    Traceback (most recent call last***REMOVED***:
      ...
    SyntaxError: invalid syntax

    >>> np.safe_eval('open("/home/user/.ssh/id_dsa"***REMOVED***.read(***REMOVED***'***REMOVED***
    Traceback (most recent call last***REMOVED***:
      ...
    SyntaxError: Unsupported source construct: compiler.ast.CallFunc

    ***REMOVED***
    # Local import to speed up numpy's import time.
    import ast

    return ast.literal_eval(source***REMOVED***
#-----------------------------------------------------------------------------
