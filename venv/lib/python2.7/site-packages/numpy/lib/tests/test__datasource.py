from __future__ import division, absolute_import, print_function

***REMOVED***
import sys
from tempfile import mkdtemp, mkstemp, NamedTemporaryFile
from shutil import rmtree

from numpy.compat import asbytes
from numpy.testing import (
    run_module_suite, TestCase, assert_, SkipTest
    ***REMOVED***
import numpy.lib._datasource as datasource

if sys.version_info[0***REMOVED*** >= 3:
    import urllib.request as urllib_request
    from urllib.parse import urlparse
    from urllib.error import URLError
else:
    import urllib2 as urllib_request
    from urlparse import urlparse
    from urllib2 import URLError


def urlopen_stub(url, data=None***REMOVED***:
    '''Stub to replace urlopen for testing.'''
    if url == valid_httpurl(***REMOVED***:
        tmpfile = NamedTemporaryFile(prefix='urltmp_'***REMOVED***
        return tmpfile
    else:
        raise URLError('Name or service not known'***REMOVED***

# setup and teardown
old_urlopen = None


def setup(***REMOVED***:
    global old_urlopen

    old_urlopen = urllib_request.urlopen
    urllib_request.urlopen = urlopen_stub


def teardown(***REMOVED***:
    urllib_request.urlopen = old_urlopen

# A valid website for more robust testing
http_path = 'http://www.google.com/'
http_file = 'index.html'

http_fakepath = 'http://fake.abc.web/site/'
http_fakefile = 'fake.txt'

malicious_files = ['/etc/shadow', '../../shadow',
                   '..\\system.dat', 'c:\\windows\\system.dat'***REMOVED***

magic_line = asbytes('three is the magic number'***REMOVED***


# Utility functions used by many TestCases
def valid_textfile(filedir***REMOVED***:
    # Generate and return a valid temporary file.
    fd, path = mkstemp(suffix='.txt', prefix='dstmp_', dir=filedir, text=True***REMOVED***
    os.close(fd***REMOVED***
    return path


def invalid_textfile(filedir***REMOVED***:
    # Generate and return an invalid filename.
    fd, path = mkstemp(suffix='.txt', prefix='dstmp_', dir=filedir***REMOVED***
    os.close(fd***REMOVED***
    os.remove(path***REMOVED***
    return path


def valid_httpurl(***REMOVED***:
    return http_path+http_file


def invalid_httpurl(***REMOVED***:
    return http_fakepath+http_fakefile


def valid_baseurl(***REMOVED***:
    return http_path


def invalid_baseurl(***REMOVED***:
    return http_fakepath


def valid_httpfile(***REMOVED***:
    return http_file


def invalid_httpfile(***REMOVED***:
    return http_fakefile


class TestDataSourceOpen(TestCase***REMOVED***:
    def setUp(self***REMOVED***:
        self.tmpdir = mkdtemp(***REMOVED***
        self.ds = datasource.DataSource(self.tmpdir***REMOVED***

    def tearDown(self***REMOVED***:
        rmtree(self.tmpdir***REMOVED***
        del self.ds

    def test_ValidHTTP(self***REMOVED***:
        fh = self.ds.open(valid_httpurl(***REMOVED******REMOVED***
        assert_(fh***REMOVED***
        fh.close(***REMOVED***

    def test_InvalidHTTP(self***REMOVED***:
        url = invalid_httpurl(***REMOVED***
        self.assertRaises(IOError, self.ds.open, url***REMOVED***
        ***REMOVED***
            self.ds.open(url***REMOVED***
        except IOError as e:
            # Regression test for bug fixed in r4342.
            assert_(e.errno is None***REMOVED***

    def test_InvalidHTTPCacheURLError(self***REMOVED***:
        self.assertRaises(URLError, self.ds._cache, invalid_httpurl(***REMOVED******REMOVED***

    def test_ValidFile(self***REMOVED***:
        local_file = valid_textfile(self.tmpdir***REMOVED***
        fh = self.ds.open(local_file***REMOVED***
        assert_(fh***REMOVED***
        fh.close(***REMOVED***

    def test_InvalidFile(self***REMOVED***:
        invalid_file = invalid_textfile(self.tmpdir***REMOVED***
        self.assertRaises(IOError, self.ds.open, invalid_file***REMOVED***

    def test_ValidGzipFile(self***REMOVED***:
        ***REMOVED***
            import gzip
        except ImportError:
            # We don't have the gzip capabilities to test.
            raise SkipTest
        # Test datasource's internal file_opener for Gzip files.
        filepath = os.path.join(self.tmpdir, 'foobar.txt.gz'***REMOVED***
        fp = gzip.open(filepath, 'w'***REMOVED***
        fp.write(magic_line***REMOVED***
        fp.close(***REMOVED***
        fp = self.ds.open(filepath***REMOVED***
        result = fp.readline(***REMOVED***
        fp.close(***REMOVED***
        self.assertEqual(magic_line, result***REMOVED***

    def test_ValidBz2File(self***REMOVED***:
        ***REMOVED***
            import bz2
        except ImportError:
            # We don't have the bz2 capabilities to test.
            raise SkipTest
        # Test datasource's internal file_opener for BZip2 files.
        filepath = os.path.join(self.tmpdir, 'foobar.txt.bz2'***REMOVED***
        fp = bz2.BZ2File(filepath, 'w'***REMOVED***
        fp.write(magic_line***REMOVED***
        fp.close(***REMOVED***
        fp = self.ds.open(filepath***REMOVED***
        result = fp.readline(***REMOVED***
        fp.close(***REMOVED***
        self.assertEqual(magic_line, result***REMOVED***


class TestDataSourceExists(TestCase***REMOVED***:
    def setUp(self***REMOVED***:
        self.tmpdir = mkdtemp(***REMOVED***
        self.ds = datasource.DataSource(self.tmpdir***REMOVED***

    def tearDown(self***REMOVED***:
        rmtree(self.tmpdir***REMOVED***
        del self.ds

    def test_ValidHTTP(self***REMOVED***:
        assert_(self.ds.exists(valid_httpurl(***REMOVED******REMOVED******REMOVED***

    def test_InvalidHTTP(self***REMOVED***:
        self.assertEqual(self.ds.exists(invalid_httpurl(***REMOVED******REMOVED***, False***REMOVED***

    def test_ValidFile(self***REMOVED***:
        # Test valid file in destpath
        tmpfile = valid_textfile(self.tmpdir***REMOVED***
        assert_(self.ds.exists(tmpfile***REMOVED******REMOVED***
        # Test valid local file not in destpath
        localdir = mkdtemp(***REMOVED***
        tmpfile = valid_textfile(localdir***REMOVED***
        assert_(self.ds.exists(tmpfile***REMOVED******REMOVED***
        rmtree(localdir***REMOVED***

    def test_InvalidFile(self***REMOVED***:
        tmpfile = invalid_textfile(self.tmpdir***REMOVED***
        self.assertEqual(self.ds.exists(tmpfile***REMOVED***, False***REMOVED***


class TestDataSourceAbspath(TestCase***REMOVED***:
    def setUp(self***REMOVED***:
        self.tmpdir = os.path.abspath(mkdtemp(***REMOVED******REMOVED***
        self.ds = datasource.DataSource(self.tmpdir***REMOVED***

    def tearDown(self***REMOVED***:
        rmtree(self.tmpdir***REMOVED***
        del self.ds

    def test_ValidHTTP(self***REMOVED***:
        scheme, netloc, upath, pms, qry, frg = urlparse(valid_httpurl(***REMOVED******REMOVED***
        local_path = os.path.join(self.tmpdir, netloc,
                                  upath.strip(os.sep***REMOVED***.strip('/'***REMOVED******REMOVED***
        self.assertEqual(local_path, self.ds.abspath(valid_httpurl(***REMOVED******REMOVED******REMOVED***

    def test_ValidFile(self***REMOVED***:
        tmpfile = valid_textfile(self.tmpdir***REMOVED***
        tmpfilename = os.path.split(tmpfile***REMOVED***[-1***REMOVED***
        # Test with filename only
        self.assertEqual(tmpfile, self.ds.abspath(tmpfilename***REMOVED******REMOVED***
        # Test filename with complete path
        self.assertEqual(tmpfile, self.ds.abspath(tmpfile***REMOVED******REMOVED***

    def test_InvalidHTTP(self***REMOVED***:
        scheme, netloc, upath, pms, qry, frg = urlparse(invalid_httpurl(***REMOVED******REMOVED***
        invalidhttp = os.path.join(self.tmpdir, netloc,
                                   upath.strip(os.sep***REMOVED***.strip('/'***REMOVED******REMOVED***
        self.assertNotEqual(invalidhttp, self.ds.abspath(valid_httpurl(***REMOVED******REMOVED******REMOVED***

    def test_InvalidFile(self***REMOVED***:
        invalidfile = valid_textfile(self.tmpdir***REMOVED***
        tmpfile = valid_textfile(self.tmpdir***REMOVED***
        tmpfilename = os.path.split(tmpfile***REMOVED***[-1***REMOVED***
        # Test with filename only
        self.assertNotEqual(invalidfile, self.ds.abspath(tmpfilename***REMOVED******REMOVED***
        # Test filename with complete path
        self.assertNotEqual(invalidfile, self.ds.abspath(tmpfile***REMOVED******REMOVED***

    def test_sandboxing(self***REMOVED***:
        tmpfile = valid_textfile(self.tmpdir***REMOVED***
        tmpfilename = os.path.split(tmpfile***REMOVED***[-1***REMOVED***

        tmp_path = lambda x: os.path.abspath(self.ds.abspath(x***REMOVED******REMOVED***

        assert_(tmp_path(valid_httpurl(***REMOVED******REMOVED***.startswith(self.tmpdir***REMOVED******REMOVED***
        assert_(tmp_path(invalid_httpurl(***REMOVED******REMOVED***.startswith(self.tmpdir***REMOVED******REMOVED***
        assert_(tmp_path(tmpfile***REMOVED***.startswith(self.tmpdir***REMOVED******REMOVED***
        assert_(tmp_path(tmpfilename***REMOVED***.startswith(self.tmpdir***REMOVED******REMOVED***
        for fn in malicious_files:
            assert_(tmp_path(http_path+fn***REMOVED***.startswith(self.tmpdir***REMOVED******REMOVED***
            assert_(tmp_path(fn***REMOVED***.startswith(self.tmpdir***REMOVED******REMOVED***

    def test_windows_os_sep(self***REMOVED***:
        orig_os_sep = os.sep
        ***REMOVED***
            os.sep = '\\'
            self.test_ValidHTTP(***REMOVED***
            self.test_ValidFile(***REMOVED***
            self.test_InvalidHTTP(***REMOVED***
            self.test_InvalidFile(***REMOVED***
            self.test_sandboxing(***REMOVED***
        finally:
            os.sep = orig_os_sep


class TestRepositoryAbspath(TestCase***REMOVED***:
    def setUp(self***REMOVED***:
        self.tmpdir = os.path.abspath(mkdtemp(***REMOVED******REMOVED***
        self.repos = datasource.Repository(valid_baseurl(***REMOVED***, self.tmpdir***REMOVED***

    def tearDown(self***REMOVED***:
        rmtree(self.tmpdir***REMOVED***
        del self.repos

    def test_ValidHTTP(self***REMOVED***:
        scheme, netloc, upath, pms, qry, frg = urlparse(valid_httpurl(***REMOVED******REMOVED***
        local_path = os.path.join(self.repos._destpath, netloc,
                                  upath.strip(os.sep***REMOVED***.strip('/'***REMOVED******REMOVED***
        filepath = self.repos.abspath(valid_httpfile(***REMOVED******REMOVED***
        self.assertEqual(local_path, filepath***REMOVED***

    def test_sandboxing(self***REMOVED***:
        tmp_path = lambda x: os.path.abspath(self.repos.abspath(x***REMOVED******REMOVED***
        assert_(tmp_path(valid_httpfile(***REMOVED******REMOVED***.startswith(self.tmpdir***REMOVED******REMOVED***
        for fn in malicious_files:
            assert_(tmp_path(http_path+fn***REMOVED***.startswith(self.tmpdir***REMOVED******REMOVED***
            assert_(tmp_path(fn***REMOVED***.startswith(self.tmpdir***REMOVED******REMOVED***

    def test_windows_os_sep(self***REMOVED***:
        orig_os_sep = os.sep
        ***REMOVED***
            os.sep = '\\'
            self.test_ValidHTTP(***REMOVED***
            self.test_sandboxing(***REMOVED***
        finally:
            os.sep = orig_os_sep


class TestRepositoryExists(TestCase***REMOVED***:
    def setUp(self***REMOVED***:
        self.tmpdir = mkdtemp(***REMOVED***
        self.repos = datasource.Repository(valid_baseurl(***REMOVED***, self.tmpdir***REMOVED***

    def tearDown(self***REMOVED***:
        rmtree(self.tmpdir***REMOVED***
        del self.repos

    def test_ValidFile(self***REMOVED***:
        # Create local temp file
        tmpfile = valid_textfile(self.tmpdir***REMOVED***
        assert_(self.repos.exists(tmpfile***REMOVED******REMOVED***

    def test_InvalidFile(self***REMOVED***:
        tmpfile = invalid_textfile(self.tmpdir***REMOVED***
        self.assertEqual(self.repos.exists(tmpfile***REMOVED***, False***REMOVED***

    def test_RemoveHTTPFile(self***REMOVED***:
        assert_(self.repos.exists(valid_httpurl(***REMOVED******REMOVED******REMOVED***

    def test_CachedHTTPFile(self***REMOVED***:
        localfile = valid_httpurl(***REMOVED***
        # Create a locally cached temp file with an URL based
        # directory structure.  This is similar to what Repository.open
        # would do.
        scheme, netloc, upath, pms, qry, frg = urlparse(localfile***REMOVED***
        local_path = os.path.join(self.repos._destpath, netloc***REMOVED***
        os.mkdir(local_path, 0o0700***REMOVED***
        tmpfile = valid_textfile(local_path***REMOVED***
        assert_(self.repos.exists(tmpfile***REMOVED******REMOVED***


class TestOpenFunc(TestCase***REMOVED***:
    def setUp(self***REMOVED***:
        self.tmpdir = mkdtemp(***REMOVED***

    def tearDown(self***REMOVED***:
        rmtree(self.tmpdir***REMOVED***

    def test_DataSourceOpen(self***REMOVED***:
        local_file = valid_textfile(self.tmpdir***REMOVED***
        # Test case where destpath is passed in
        fp = datasource.open(local_file, destpath=self.tmpdir***REMOVED***
        assert_(fp***REMOVED***
        fp.close(***REMOVED***
        # Test case where default destpath is used
        fp = datasource.open(local_file***REMOVED***
        assert_(fp***REMOVED***
        fp.close(***REMOVED***


if __name__ == "__main__":
    run_module_suite(***REMOVED***
