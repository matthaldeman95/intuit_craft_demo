from __future__ import division, absolute_import, print_function

import warnings

import numpy.core.numeric as _nx
from numpy.core.numeric import (
    asarray, zeros, outer, concatenate, isscalar, array, asanyarray
    ***REMOVED***
from numpy.core.fromnumeric import product, reshape
from numpy.core import vstack, atleast_3d


__all__ = [
    'column_stack', 'row_stack', 'dstack', 'array_split', 'split',
    'hsplit', 'vsplit', 'dsplit', 'apply_over_axes', 'expand_dims',
    'apply_along_axis', 'kron', 'tile', 'get_array_wrap'
    ***REMOVED***


def apply_along_axis(func1d, axis, arr, *args, **kwargs***REMOVED***:
    ***REMOVED***
    Apply a function to 1-D slices along the given axis.

    Execute `func1d(a, *args***REMOVED***` where `func1d` operates on 1-D arrays and `a`
    is a 1-D slice of `arr` along `axis`.

    Parameters
    ----------
    func1d : function
        This function should accept 1-D arrays. It is applied to 1-D
        slices of `arr` along the specified axis.
    axis : integer
        Axis along which `arr` is sliced.
    arr : ndarray
        Input array.
    args : any
        Additional arguments to `func1d`.
    kwargs: any
        Additional named arguments to `func1d`.

        .. versionadded:: 1.9.0


    Returns
    -------
    apply_along_axis : ndarray
        The output array. The shape of `outarr` is identical to the shape of
        `arr`, except along the `axis` dimension, where the length of `outarr`
        is equal to the size of the return value of `func1d`.  If `func1d`
        returns a scalar `outarr` will have one fewer dimensions than `arr`.

    See Also
    --------
    apply_over_axes : Apply a function repeatedly over multiple axes.

    Examples
    --------
    >>> def my_func(a***REMOVED***:
    ...     \"\"\"Average first and last element of a 1-D array\"\"\"
    ...     return (a[0***REMOVED*** + a[-1***REMOVED******REMOVED*** * 0.5
    >>> b = np.array([[1,2,3***REMOVED***, [4,5,6***REMOVED***, [7,8,9***REMOVED******REMOVED******REMOVED***
    >>> np.apply_along_axis(my_func, 0, b***REMOVED***
    array([ 4.,  5.,  6.***REMOVED******REMOVED***
    >>> np.apply_along_axis(my_func, 1, b***REMOVED***
    array([ 2.,  5.,  8.***REMOVED******REMOVED***

    For a function that doesn't return a scalar, the number of dimensions in
    `outarr` is the same as `arr`.

    >>> b = np.array([[8,1,7***REMOVED***, [4,3,9***REMOVED***, [5,2,6***REMOVED******REMOVED******REMOVED***
    >>> np.apply_along_axis(sorted, 1, b***REMOVED***
    array([[1, 7, 8***REMOVED***,
           [3, 4, 9***REMOVED***,
           [2, 5, 6***REMOVED******REMOVED******REMOVED***

    ***REMOVED***
    arr = asarray(arr***REMOVED***
    nd = arr.ndim
    if axis < 0:
        axis += nd
    if (axis >= nd***REMOVED***:
        raise ValueError("axis must be less than arr.ndim; axis=%d, rank=%d."
            % (axis, nd***REMOVED******REMOVED***
    ind = [0***REMOVED****(nd-1***REMOVED***
    i = zeros(nd, 'O'***REMOVED***
    indlist = list(range(nd***REMOVED******REMOVED***
    indlist.remove(axis***REMOVED***
    i[axis***REMOVED*** = slice(None, None***REMOVED***
    outshape = asarray(arr.shape***REMOVED***.take(indlist***REMOVED***
    i.put(indlist, ind***REMOVED***
    res = func1d(arr[tuple(i.tolist(***REMOVED******REMOVED******REMOVED***, *args, **kwargs***REMOVED***
    #  if res is a number, then we have a smaller output array
    if isscalar(res***REMOVED***:
        outarr = zeros(outshape, asarray(res***REMOVED***.dtype***REMOVED***
        outarr[tuple(ind***REMOVED******REMOVED*** = res
        Ntot = product(outshape***REMOVED***
        k = 1
        while k < Ntot:
            # increment the index
            ind[-1***REMOVED*** += 1
            n = -1
            while (ind[n***REMOVED*** >= outshape[n***REMOVED******REMOVED*** and (n > (1-nd***REMOVED******REMOVED***:
                ind[n-1***REMOVED*** += 1
                ind[n***REMOVED*** = 0
                n -= 1
            i.put(indlist, ind***REMOVED***
            res = func1d(arr[tuple(i.tolist(***REMOVED******REMOVED******REMOVED***, *args, **kwargs***REMOVED***
            outarr[tuple(ind***REMOVED******REMOVED*** = res
            k += 1
        return outarr
    else:
        Ntot = product(outshape***REMOVED***
        holdshape = outshape
        outshape = list(arr.shape***REMOVED***
        outshape[axis***REMOVED*** = len(res***REMOVED***
        outarr = zeros(outshape, asarray(res***REMOVED***.dtype***REMOVED***
        outarr[tuple(i.tolist(***REMOVED******REMOVED******REMOVED*** = res
        k = 1
        while k < Ntot:
            # increment the index
            ind[-1***REMOVED*** += 1
            n = -1
            while (ind[n***REMOVED*** >= holdshape[n***REMOVED******REMOVED*** and (n > (1-nd***REMOVED******REMOVED***:
                ind[n-1***REMOVED*** += 1
                ind[n***REMOVED*** = 0
                n -= 1
            i.put(indlist, ind***REMOVED***
            res = func1d(arr[tuple(i.tolist(***REMOVED******REMOVED******REMOVED***, *args, **kwargs***REMOVED***
            outarr[tuple(i.tolist(***REMOVED******REMOVED******REMOVED*** = res
            k += 1
        return outarr


def apply_over_axes(func, a, axes***REMOVED***:
    ***REMOVED***
    Apply a function repeatedly over multiple axes.

    `func` is called as `res = func(a, axis***REMOVED***`, where `axis` is the first
    element of `axes`.  The result `res` of the function call must have
    either the same dimensions as `a` or one less dimension.  If `res`
    has one less dimension than `a`, a dimension is inserted before
    `axis`.  The call to `func` is then repeated for each axis in `axes`,
    with `res` as the first argument.

    Parameters
    ----------
    func : function
        This function must take two arguments, `func(a, axis***REMOVED***`.
    a : array_like
        Input array.
    axes : array_like
        Axes over which `func` is applied; the elements must be integers.

    Returns
    -------
    apply_over_axis : ndarray
        The output array.  The number of dimensions is the same as `a`,
        but the shape can be different.  This depends on whether `func`
        changes the shape of its output with respect to its input.

    See Also
    --------
    apply_along_axis :
        Apply a function to 1-D slices of an array along the given axis.

    Notes
    ------
    This function is equivalent to tuple axis arguments to reorderable ufuncs
    with keepdims=True. Tuple axis arguments to ufuncs have been availabe since
    version 1.7.0.

    Examples
    --------
    >>> a = np.arange(24***REMOVED***.reshape(2,3,4***REMOVED***
    >>> a
    array([[[ 0,  1,  2,  3***REMOVED***,
            [ 4,  5,  6,  7***REMOVED***,
            [ 8,  9, 10, 11***REMOVED******REMOVED***,
           [[12, 13, 14, 15***REMOVED***,
            [16, 17, 18, 19***REMOVED***,
            [20, 21, 22, 23***REMOVED******REMOVED******REMOVED******REMOVED***

    Sum over axes 0 and 2. The result has same number of dimensions
    as the original array:

    >>> np.apply_over_axes(np.sum, a, [0,2***REMOVED******REMOVED***
    array([[[ 60***REMOVED***,
            [ 92***REMOVED***,
            [124***REMOVED******REMOVED******REMOVED******REMOVED***

    Tuple axis arguments to ufuncs are equivalent:

    >>> np.sum(a, axis=(0,2***REMOVED***, keepdims=True***REMOVED***
    array([[[ 60***REMOVED***,
            [ 92***REMOVED***,
            [124***REMOVED******REMOVED******REMOVED******REMOVED***

    ***REMOVED***
    val = asarray(a***REMOVED***
    N = a.ndim
    if array(axes***REMOVED***.ndim == 0:
        axes = (axes,***REMOVED***
    for axis in axes:
        if axis < 0:
            axis = N + axis
        args = (val, axis***REMOVED***
        res = func(*args***REMOVED***
        if res.ndim == val.ndim:
            val = res
        else:
            res = expand_dims(res, axis***REMOVED***
            if res.ndim == val.ndim:
                val = res
            else:
                raise ValueError("function is not returning "
                        "an array of the correct shape"***REMOVED***
    return val

def expand_dims(a, axis***REMOVED***:
    ***REMOVED***
    Expand the shape of an array.

    Insert a new axis, corresponding to a given position in the array shape.

    Parameters
    ----------
    a : array_like
        Input array.
    axis : int
        Position (amongst axes***REMOVED*** where new axis is to be inserted.

    Returns
    -------
    res : ndarray
        Output array. The number of dimensions is one greater than that of
        the input array.

    See Also
    --------
    doc.indexing, atleast_1d, atleast_2d, atleast_3d

    Examples
    --------
    >>> x = np.array([1,2***REMOVED******REMOVED***
    >>> x.shape
    (2,***REMOVED***

    The following is equivalent to ``x[np.newaxis,:***REMOVED***`` or ``x[np.newaxis***REMOVED***``:

    >>> y = np.expand_dims(x, axis=0***REMOVED***
    >>> y
    array([[1, 2***REMOVED******REMOVED******REMOVED***
    >>> y.shape
    (1, 2***REMOVED***

    >>> y = np.expand_dims(x, axis=1***REMOVED***  # Equivalent to x[:,newaxis***REMOVED***
    >>> y
    array([[1***REMOVED***,
           [2***REMOVED******REMOVED******REMOVED***
    >>> y.shape
    (2, 1***REMOVED***

    Note that some examples may use ``None`` instead of ``np.newaxis``.  These
    are the same objects:

    >>> np.newaxis is None
    True

    ***REMOVED***
    a = asarray(a***REMOVED***
    shape = a.shape
    if axis < 0:
        axis = axis + len(shape***REMOVED*** + 1
    return a.reshape(shape[:axis***REMOVED*** + (1,***REMOVED*** + shape[axis:***REMOVED******REMOVED***

row_stack = vstack

def column_stack(tup***REMOVED***:
    ***REMOVED***
    Stack 1-D arrays as columns into a 2-D array.

    Take a sequence of 1-D arrays and stack them as columns
    to make a single 2-D array. 2-D arrays are stacked as-is,
    just like with `hstack`.  1-D arrays are turned into 2-D columns
    first.

    Parameters
    ----------
    tup : sequence of 1-D or 2-D arrays.
        Arrays to stack. All of them must have the same first dimension.

    Returns
    -------
    stacked : 2-D array
        The array formed by stacking the given arrays.

    See Also
    --------
    hstack, vstack, concatenate

    Examples
    --------
    >>> a = np.array((1,2,3***REMOVED******REMOVED***
    >>> b = np.array((2,3,4***REMOVED******REMOVED***
    >>> np.column_stack((a,b***REMOVED******REMOVED***
    array([[1, 2***REMOVED***,
           [2, 3***REMOVED***,
           [3, 4***REMOVED******REMOVED******REMOVED***

    ***REMOVED***
    arrays = [***REMOVED***
    for v in tup:
        arr = array(v, copy=False, subok=True***REMOVED***
        if arr.ndim < 2:
            arr = array(arr, copy=False, subok=True, ndmin=2***REMOVED***.T
        arrays.append(arr***REMOVED***
    return _nx.concatenate(arrays, 1***REMOVED***

def dstack(tup***REMOVED***:
    ***REMOVED***
    Stack arrays in sequence depth wise (along third axis***REMOVED***.

    Takes a sequence of arrays and stack them along the third axis
    to make a single array. Rebuilds arrays divided by `dsplit`.
    This is a simple way to stack 2D arrays (images***REMOVED*** into a single
    3D array for processing.

    Parameters
    ----------
    tup : sequence of arrays
        Arrays to stack. All of them must have the same shape along all
        but the third axis.

    Returns
    -------
    stacked : ndarray
        The array formed by stacking the given arrays.

    See Also
    --------
    stack : Join a sequence of arrays along a new axis.
    vstack : Stack along first axis.
    hstack : Stack along second axis.
    concatenate : Join a sequence of arrays along an existing axis.
    dsplit : Split array along third axis.

    Notes
    -----
    Equivalent to ``np.concatenate(tup, axis=2***REMOVED***``.

    Examples
    --------
    >>> a = np.array((1,2,3***REMOVED******REMOVED***
    >>> b = np.array((2,3,4***REMOVED******REMOVED***
    >>> np.dstack((a,b***REMOVED******REMOVED***
    array([[[1, 2***REMOVED***,
            [2, 3***REMOVED***,
            [3, 4***REMOVED******REMOVED******REMOVED******REMOVED***

    >>> a = np.array([[1***REMOVED***,[2***REMOVED***,[3***REMOVED******REMOVED******REMOVED***
    >>> b = np.array([[2***REMOVED***,[3***REMOVED***,[4***REMOVED******REMOVED******REMOVED***
    >>> np.dstack((a,b***REMOVED******REMOVED***
    array([[[1, 2***REMOVED******REMOVED***,
           [[2, 3***REMOVED******REMOVED***,
           [[3, 4***REMOVED******REMOVED******REMOVED******REMOVED***

    ***REMOVED***
    return _nx.concatenate([atleast_3d(_m***REMOVED*** for _m in tup***REMOVED***, 2***REMOVED***

def _replace_zero_by_x_arrays(sub_arys***REMOVED***:
    for i in range(len(sub_arys***REMOVED******REMOVED***:
        if len(_nx.shape(sub_arys[i***REMOVED******REMOVED******REMOVED*** == 0:
            sub_arys[i***REMOVED*** = _nx.empty(0, dtype=sub_arys[i***REMOVED***.dtype***REMOVED***
        elif _nx.sometrue(_nx.equal(_nx.shape(sub_arys[i***REMOVED******REMOVED***, 0***REMOVED******REMOVED***:
            sub_arys[i***REMOVED*** = _nx.empty(0, dtype=sub_arys[i***REMOVED***.dtype***REMOVED***
    return sub_arys

def array_split(ary, indices_or_sections, axis=0***REMOVED***:
    ***REMOVED***
    Split an array into multiple sub-arrays.

    Please refer to the ``split`` documentation.  The only difference
    between these functions is that ``array_split`` allows
    `indices_or_sections` to be an integer that does *not* equally
    divide the axis.

    See Also
    --------
    split : Split array into multiple sub-arrays of equal size.

    Examples
    --------
    >>> x = np.arange(8.0***REMOVED***
    >>> np.array_split(x, 3***REMOVED***
        [array([ 0.,  1.,  2.***REMOVED******REMOVED***, array([ 3.,  4.,  5.***REMOVED******REMOVED***, array([ 6.,  7.***REMOVED******REMOVED******REMOVED***

    ***REMOVED***
    ***REMOVED***
        Ntotal = ary.shape[axis***REMOVED***
    except AttributeError:
        Ntotal = len(ary***REMOVED***
    ***REMOVED***
        # handle scalar case.
        Nsections = len(indices_or_sections***REMOVED*** + 1
        div_points = [0***REMOVED*** + list(indices_or_sections***REMOVED*** + [Ntotal***REMOVED***
    except TypeError:
        # indices_or_sections is a scalar, not an array.
        Nsections = int(indices_or_sections***REMOVED***
        if Nsections <= 0:
            raise ValueError('number sections must be larger than 0.'***REMOVED***
        Neach_section, extras = divmod(Ntotal, Nsections***REMOVED***
        section_sizes = ([0***REMOVED*** +
                         extras * [Neach_section+1***REMOVED*** +
                         (Nsections-extras***REMOVED*** * [Neach_section***REMOVED******REMOVED***
        div_points = _nx.array(section_sizes***REMOVED***.cumsum(***REMOVED***

    sub_arys = [***REMOVED***
    sary = _nx.swapaxes(ary, axis, 0***REMOVED***
    for i in range(Nsections***REMOVED***:
        st = div_points[i***REMOVED***
        end = div_points[i + 1***REMOVED***
        sub_arys.append(_nx.swapaxes(sary[st:end***REMOVED***, axis, 0***REMOVED******REMOVED***

    return sub_arys


def split(ary,indices_or_sections,axis=0***REMOVED***:
    ***REMOVED***
    Split an array into multiple sub-arrays.

    Parameters
    ----------
    ary : ndarray
        Array to be divided into sub-arrays.
    indices_or_sections : int or 1-D array
        If `indices_or_sections` is an integer, N, the array will be divided
        into N equal arrays along `axis`.  If such a split is not possible,
        an error is raised.

        If `indices_or_sections` is a 1-D array of sorted integers, the entries
        indicate where along `axis` the array is split.  For example,
        ``[2, 3***REMOVED***`` would, for ``axis=0``, result in

          - ary[:2***REMOVED***
          - ary[2:3***REMOVED***
          - ary[3:***REMOVED***

        If an index exceeds the dimension of the array along `axis`,
        an empty sub-array is returned correspondingly.
    axis : int, optional
        The axis along which to split, default is 0.

    Returns
    -------
    sub-arrays : list of ndarrays
        A list of sub-arrays.

    Raises
    ------
    ValueError
        If `indices_or_sections` is given as an integer, but
        a split does not result in equal division.

    See Also
    --------
    array_split : Split an array into multiple sub-arrays of equal or
                  near-equal size.  Does not raise an exception if
                  an equal division cannot be made.
    hsplit : Split array into multiple sub-arrays horizontally (column-wise***REMOVED***.
    vsplit : Split array into multiple sub-arrays vertically (row wise***REMOVED***.
    dsplit : Split array into multiple sub-arrays along the 3rd axis (depth***REMOVED***.
    concatenate : Join a sequence of arrays along an existing axis.
    stack : Join a sequence of arrays along a new axis.
    hstack : Stack arrays in sequence horizontally (column wise***REMOVED***.
    vstack : Stack arrays in sequence vertically (row wise***REMOVED***.
    dstack : Stack arrays in sequence depth wise (along third dimension***REMOVED***.

    Examples
    --------
    >>> x = np.arange(9.0***REMOVED***
    >>> np.split(x, 3***REMOVED***
    [array([ 0.,  1.,  2.***REMOVED******REMOVED***, array([ 3.,  4.,  5.***REMOVED******REMOVED***, array([ 6.,  7.,  8.***REMOVED******REMOVED******REMOVED***

    >>> x = np.arange(8.0***REMOVED***
    >>> np.split(x, [3, 5, 6, 10***REMOVED******REMOVED***
    [array([ 0.,  1.,  2.***REMOVED******REMOVED***,
     array([ 3.,  4.***REMOVED******REMOVED***,
     array([ 5.***REMOVED******REMOVED***,
     array([ 6.,  7.***REMOVED******REMOVED***,
     array([***REMOVED***, dtype=float64***REMOVED******REMOVED***

    ***REMOVED***
    ***REMOVED***
        len(indices_or_sections***REMOVED***
    except TypeError:
        sections = indices_or_sections
        N = ary.shape[axis***REMOVED***
        if N % sections:
            raise ValueError(
                'array split does not result in an equal division'***REMOVED***
    res = array_split(ary, indices_or_sections, axis***REMOVED***
    return res

def hsplit(ary, indices_or_sections***REMOVED***:
    ***REMOVED***
    Split an array into multiple sub-arrays horizontally (column-wise***REMOVED***.

    Please refer to the `split` documentation.  `hsplit` is equivalent
    to `split` with ``axis=1``, the array is always split along the second
    axis regardless of the array dimension.

    See Also
    --------
    split : Split an array into multiple sub-arrays of equal size.

    Examples
    --------
    >>> x = np.arange(16.0***REMOVED***.reshape(4, 4***REMOVED***
    >>> x
    array([[  0.,   1.,   2.,   3.***REMOVED***,
           [  4.,   5.,   6.,   7.***REMOVED***,
           [  8.,   9.,  10.,  11.***REMOVED***,
           [ 12.,  13.,  14.,  15.***REMOVED******REMOVED******REMOVED***
    >>> np.hsplit(x, 2***REMOVED***
    [array([[  0.,   1.***REMOVED***,
           [  4.,   5.***REMOVED***,
           [  8.,   9.***REMOVED***,
           [ 12.,  13.***REMOVED******REMOVED******REMOVED***,
     array([[  2.,   3.***REMOVED***,
           [  6.,   7.***REMOVED***,
           [ 10.,  11.***REMOVED***,
           [ 14.,  15.***REMOVED******REMOVED******REMOVED******REMOVED***
    >>> np.hsplit(x, np.array([3, 6***REMOVED******REMOVED******REMOVED***
    [array([[  0.,   1.,   2.***REMOVED***,
           [  4.,   5.,   6.***REMOVED***,
           [  8.,   9.,  10.***REMOVED***,
           [ 12.,  13.,  14.***REMOVED******REMOVED******REMOVED***,
     array([[  3.***REMOVED***,
           [  7.***REMOVED***,
           [ 11.***REMOVED***,
           [ 15.***REMOVED******REMOVED******REMOVED***,
     array([***REMOVED***, dtype=float64***REMOVED******REMOVED***

    With a higher dimensional array the split is still along the second axis.

    >>> x = np.arange(8.0***REMOVED***.reshape(2, 2, 2***REMOVED***
    >>> x
    array([[[ 0.,  1.***REMOVED***,
            [ 2.,  3.***REMOVED******REMOVED***,
           [[ 4.,  5.***REMOVED***,
            [ 6.,  7.***REMOVED******REMOVED******REMOVED******REMOVED***
    >>> np.hsplit(x, 2***REMOVED***
    [array([[[ 0.,  1.***REMOVED******REMOVED***,
           [[ 4.,  5.***REMOVED******REMOVED******REMOVED******REMOVED***,
     array([[[ 2.,  3.***REMOVED******REMOVED***,
           [[ 6.,  7.***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***

    ***REMOVED***
    if len(_nx.shape(ary***REMOVED******REMOVED*** == 0:
        raise ValueError('hsplit only works on arrays of 1 or more dimensions'***REMOVED***
    if len(ary.shape***REMOVED*** > 1:
        return split(ary, indices_or_sections, 1***REMOVED***
    else:
        return split(ary, indices_or_sections, 0***REMOVED***

def vsplit(ary, indices_or_sections***REMOVED***:
    ***REMOVED***
    Split an array into multiple sub-arrays vertically (row-wise***REMOVED***.

    Please refer to the ``split`` documentation.  ``vsplit`` is equivalent
    to ``split`` with `axis=0` (default***REMOVED***, the array is always split along the
    first axis regardless of the array dimension.

    See Also
    --------
    split : Split an array into multiple sub-arrays of equal size.

    Examples
    --------
    >>> x = np.arange(16.0***REMOVED***.reshape(4, 4***REMOVED***
    >>> x
    array([[  0.,   1.,   2.,   3.***REMOVED***,
           [  4.,   5.,   6.,   7.***REMOVED***,
           [  8.,   9.,  10.,  11.***REMOVED***,
           [ 12.,  13.,  14.,  15.***REMOVED******REMOVED******REMOVED***
    >>> np.vsplit(x, 2***REMOVED***
    [array([[ 0.,  1.,  2.,  3.***REMOVED***,
           [ 4.,  5.,  6.,  7.***REMOVED******REMOVED******REMOVED***,
     array([[  8.,   9.,  10.,  11.***REMOVED***,
           [ 12.,  13.,  14.,  15.***REMOVED******REMOVED******REMOVED******REMOVED***
    >>> np.vsplit(x, np.array([3, 6***REMOVED******REMOVED******REMOVED***
    [array([[  0.,   1.,   2.,   3.***REMOVED***,
           [  4.,   5.,   6.,   7.***REMOVED***,
           [  8.,   9.,  10.,  11.***REMOVED******REMOVED******REMOVED***,
     array([[ 12.,  13.,  14.,  15.***REMOVED******REMOVED******REMOVED***,
     array([***REMOVED***, dtype=float64***REMOVED******REMOVED***

    With a higher dimensional array the split is still along the first axis.

    >>> x = np.arange(8.0***REMOVED***.reshape(2, 2, 2***REMOVED***
    >>> x
    array([[[ 0.,  1.***REMOVED***,
            [ 2.,  3.***REMOVED******REMOVED***,
           [[ 4.,  5.***REMOVED***,
            [ 6.,  7.***REMOVED******REMOVED******REMOVED******REMOVED***
    >>> np.vsplit(x, 2***REMOVED***
    [array([[[ 0.,  1.***REMOVED***,
            [ 2.,  3.***REMOVED******REMOVED******REMOVED******REMOVED***,
     array([[[ 4.,  5.***REMOVED***,
            [ 6.,  7.***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***

    ***REMOVED***
    if len(_nx.shape(ary***REMOVED******REMOVED*** < 2:
        raise ValueError('vsplit only works on arrays of 2 or more dimensions'***REMOVED***
    return split(ary, indices_or_sections, 0***REMOVED***

def dsplit(ary, indices_or_sections***REMOVED***:
    ***REMOVED***
    Split array into multiple sub-arrays along the 3rd axis (depth***REMOVED***.

    Please refer to the `split` documentation.  `dsplit` is equivalent
    to `split` with ``axis=2``, the array is always split along the third
    axis provided the array dimension is greater than or equal to 3.

    See Also
    --------
    split : Split an array into multiple sub-arrays of equal size.

    Examples
    --------
    >>> x = np.arange(16.0***REMOVED***.reshape(2, 2, 4***REMOVED***
    >>> x
    array([[[  0.,   1.,   2.,   3.***REMOVED***,
            [  4.,   5.,   6.,   7.***REMOVED******REMOVED***,
           [[  8.,   9.,  10.,  11.***REMOVED***,
            [ 12.,  13.,  14.,  15.***REMOVED******REMOVED******REMOVED******REMOVED***
    >>> np.dsplit(x, 2***REMOVED***
    [array([[[  0.,   1.***REMOVED***,
            [  4.,   5.***REMOVED******REMOVED***,
           [[  8.,   9.***REMOVED***,
            [ 12.,  13.***REMOVED******REMOVED******REMOVED******REMOVED***,
     array([[[  2.,   3.***REMOVED***,
            [  6.,   7.***REMOVED******REMOVED***,
           [[ 10.,  11.***REMOVED***,
            [ 14.,  15.***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***
    >>> np.dsplit(x, np.array([3, 6***REMOVED******REMOVED******REMOVED***
    [array([[[  0.,   1.,   2.***REMOVED***,
            [  4.,   5.,   6.***REMOVED******REMOVED***,
           [[  8.,   9.,  10.***REMOVED***,
            [ 12.,  13.,  14.***REMOVED******REMOVED******REMOVED******REMOVED***,
     array([[[  3.***REMOVED***,
            [  7.***REMOVED******REMOVED***,
           [[ 11.***REMOVED***,
            [ 15.***REMOVED******REMOVED******REMOVED******REMOVED***,
     array([***REMOVED***, dtype=float64***REMOVED******REMOVED***

    ***REMOVED***
    if len(_nx.shape(ary***REMOVED******REMOVED*** < 3:
        raise ValueError('dsplit only works on arrays of 3 or more dimensions'***REMOVED***
    return split(ary, indices_or_sections, 2***REMOVED***

def get_array_prepare(*args***REMOVED***:
    ***REMOVED***Find the wrapper for the array with the highest priority.

    In case of ties, leftmost wins. If no wrapper is found, return None
    ***REMOVED***
    wrappers = sorted((getattr(x, '__array_priority__', 0***REMOVED***, -i,
                 x.__array_prepare__***REMOVED*** for i, x in enumerate(args***REMOVED***
                                   if hasattr(x, '__array_prepare__'***REMOVED******REMOVED***
    if wrappers:
        return wrappers[-1***REMOVED***[-1***REMOVED***
    return None

def get_array_wrap(*args***REMOVED***:
    ***REMOVED***Find the wrapper for the array with the highest priority.

    In case of ties, leftmost wins. If no wrapper is found, return None
    ***REMOVED***
    wrappers = sorted((getattr(x, '__array_priority__', 0***REMOVED***, -i,
                 x.__array_wrap__***REMOVED*** for i, x in enumerate(args***REMOVED***
                                   if hasattr(x, '__array_wrap__'***REMOVED******REMOVED***
    if wrappers:
        return wrappers[-1***REMOVED***[-1***REMOVED***
    return None

def kron(a, b***REMOVED***:
    ***REMOVED***
    Kronecker product of two arrays.

    Computes the Kronecker product, a composite array made of blocks of the
    second array scaled by the first.

    Parameters
    ----------
    a, b : array_like

    Returns
    -------
    out : ndarray

    See Also
    --------
    outer : The outer product

    Notes
    -----
    The function assumes that the number of dimensions of `a` and `b`
    are the same, if necessary prepending the smallest with ones.
    If `a.shape = (r0,r1,..,rN***REMOVED***` and `b.shape = (s0,s1,...,sN***REMOVED***`,
    the Kronecker product has shape `(r0*s0, r1*s1, ..., rN*SN***REMOVED***`.
    The elements are products of elements from `a` and `b`, organized
    explicitly by::

        kron(a,b***REMOVED***[k0,k1,...,kN***REMOVED*** = a[i0,i1,...,iN***REMOVED*** * b[j0,j1,...,jN***REMOVED***

    where::

        kt = it * st + jt,  t = 0,...,N

    In the common 2-D case (N=1***REMOVED***, the block structure can be visualized::

        [[ a[0,0***REMOVED****b,   a[0,1***REMOVED****b,  ... , a[0,-1***REMOVED****b  ***REMOVED***,
         [  ...                              ...   ***REMOVED***,
         [ a[-1,0***REMOVED****b,  a[-1,1***REMOVED****b, ... , a[-1,-1***REMOVED****b ***REMOVED******REMOVED***


    Examples
    --------
    >>> np.kron([1,10,100***REMOVED***, [5,6,7***REMOVED******REMOVED***
    array([  5,   6,   7,  50,  60,  70, 500, 600, 700***REMOVED******REMOVED***
    >>> np.kron([5,6,7***REMOVED***, [1,10,100***REMOVED******REMOVED***
    array([  5,  50, 500,   6,  60, 600,   7,  70, 700***REMOVED******REMOVED***

    >>> np.kron(np.eye(2***REMOVED***, np.ones((2,2***REMOVED******REMOVED******REMOVED***
    array([[ 1.,  1.,  0.,  0.***REMOVED***,
           [ 1.,  1.,  0.,  0.***REMOVED***,
           [ 0.,  0.,  1.,  1.***REMOVED***,
           [ 0.,  0.,  1.,  1.***REMOVED******REMOVED******REMOVED***

    >>> a = np.arange(100***REMOVED***.reshape((2,5,2,5***REMOVED******REMOVED***
    >>> b = np.arange(24***REMOVED***.reshape((2,3,4***REMOVED******REMOVED***
    >>> c = np.kron(a,b***REMOVED***
    >>> c.shape
    (2, 10, 6, 20***REMOVED***
    >>> I = (1,3,0,2***REMOVED***
    >>> J = (0,2,1***REMOVED***
    >>> J1 = (0,***REMOVED*** + J             # extend to ndim=4
    >>> S1 = (1,***REMOVED*** + b.shape
    >>> K = tuple(np.array(I***REMOVED*** * np.array(S1***REMOVED*** + np.array(J1***REMOVED******REMOVED***
    >>> c[K***REMOVED*** == a[I***REMOVED****b[J***REMOVED***
    True

    ***REMOVED***
    b = asanyarray(b***REMOVED***
    a = array(a, copy=False, subok=True, ndmin=b.ndim***REMOVED***
    ndb, nda = b.ndim, a.ndim
    if (nda == 0 or ndb == 0***REMOVED***:
        return _nx.multiply(a, b***REMOVED***
    as_ = a.shape
    bs = b.shape
    if not a.flags.contiguous:
        a = reshape(a, as_***REMOVED***
    if not b.flags.contiguous:
        b = reshape(b, bs***REMOVED***
    nd = ndb
    if (ndb != nda***REMOVED***:
        if (ndb > nda***REMOVED***:
            as_ = (1,***REMOVED****(ndb-nda***REMOVED*** + as_
        else:
            bs = (1,***REMOVED****(nda-ndb***REMOVED*** + bs
            nd = nda
    result = outer(a, b***REMOVED***.reshape(as_+bs***REMOVED***
    axis = nd-1
    for _ in range(nd***REMOVED***:
        result = concatenate(result, axis=axis***REMOVED***
    wrapper = get_array_prepare(a, b***REMOVED***
    if wrapper is not None:
        result = wrapper(result***REMOVED***
    wrapper = get_array_wrap(a, b***REMOVED***
    if wrapper is not None:
        result = wrapper(result***REMOVED***
    return result


def tile(A, reps***REMOVED***:
    ***REMOVED***
    Construct an array by repeating A the number of times given by reps.

    If `reps` has length ``d``, the result will have dimension of
    ``max(d, A.ndim***REMOVED***``.

    If ``A.ndim < d``, `A` is promoted to be d-dimensional by prepending new
    axes. So a shape (3,***REMOVED*** array is promoted to (1, 3***REMOVED*** for 2-D replication,
    or shape (1, 1, 3***REMOVED*** for 3-D replication. If this is not the desired
    behavior, promote `A` to d-dimensions manually before calling this
    function.

    If ``A.ndim > d``, `reps` is promoted to `A`.ndim by pre-pending 1's to it.
    Thus for an `A` of shape (2, 3, 4, 5***REMOVED***, a `reps` of (2, 2***REMOVED*** is treated as
    (1, 1, 2, 2***REMOVED***.

    Note : Although tile may be used for broadcasting, it is strongly
    recommended to use numpy's broadcasting operations and functions.

    Parameters
    ----------
    A : array_like
        The input array.
    reps : array_like
        The number of repetitions of `A` along each axis.

    Returns
    -------
    c : ndarray
        The tiled output array.

    See Also
    --------
    repeat : Repeat elements of an array.
    broadcast_to : Broadcast an array to a new shape

    Examples
    --------
    >>> a = np.array([0, 1, 2***REMOVED******REMOVED***
    >>> np.tile(a, 2***REMOVED***
    array([0, 1, 2, 0, 1, 2***REMOVED******REMOVED***
    >>> np.tile(a, (2, 2***REMOVED******REMOVED***
    array([[0, 1, 2, 0, 1, 2***REMOVED***,
           [0, 1, 2, 0, 1, 2***REMOVED******REMOVED******REMOVED***
    >>> np.tile(a, (2, 1, 2***REMOVED******REMOVED***
    array([[[0, 1, 2, 0, 1, 2***REMOVED******REMOVED***,
           [[0, 1, 2, 0, 1, 2***REMOVED******REMOVED******REMOVED******REMOVED***

    >>> b = np.array([[1, 2***REMOVED***, [3, 4***REMOVED******REMOVED******REMOVED***
    >>> np.tile(b, 2***REMOVED***
    array([[1, 2, 1, 2***REMOVED***,
           [3, 4, 3, 4***REMOVED******REMOVED******REMOVED***
    >>> np.tile(b, (2, 1***REMOVED******REMOVED***
    array([[1, 2***REMOVED***,
           [3, 4***REMOVED***,
           [1, 2***REMOVED***,
           [3, 4***REMOVED******REMOVED******REMOVED***

    >>> c = np.array([1,2,3,4***REMOVED******REMOVED***
    >>> np.tile(c,(4,1***REMOVED******REMOVED***
    array([[1, 2, 3, 4***REMOVED***,
           [1, 2, 3, 4***REMOVED***,
           [1, 2, 3, 4***REMOVED***,
           [1, 2, 3, 4***REMOVED******REMOVED******REMOVED***
    ***REMOVED***
    ***REMOVED***
        tup = tuple(reps***REMOVED***
    except TypeError:
        tup = (reps,***REMOVED***
    d = len(tup***REMOVED***
    if all(x == 1 for x in tup***REMOVED*** and isinstance(A, _nx.ndarray***REMOVED***:
        # Fixes the problem that the function does not make a copy if A is a
        # numpy array and the repetitions are 1 in all dimensions
        return _nx.array(A, copy=True, subok=True, ndmin=d***REMOVED***
    else:
        # Note that no copy of zero-sized arrays is made. However since they
        # have no data there is no risk of an inadvertent overwrite.
        c = _nx.array(A, copy=False, subok=True, ndmin=d***REMOVED***
    if (d < c.ndim***REMOVED***:
        tup = (1,***REMOVED****(c.ndim-d***REMOVED*** + tup
    shape_out = tuple(s*t for s, t in zip(c.shape, tup***REMOVED******REMOVED***
    n = c.size
    if n > 0:
        for dim_in, nrep in zip(c.shape, tup***REMOVED***:
            if nrep != 1:
                c = c.reshape(-1, n***REMOVED***.repeat(nrep, 0***REMOVED***
            n //= dim_in
    return c.reshape(shape_out***REMOVED***
