***REMOVED***
Python 3 compatibility tools.

***REMOVED***
from __future__ import division, absolute_import, print_function

__all__ = ['bytes', 'asbytes', 'isfileobj', 'getexception', 'strchar',
           'unicode', 'asunicode', 'asbytes_nested', 'asunicode_nested',
           'asstr', 'open_latin1', 'long', 'basestring', 'sixu',
           'integer_types', 'npy_load_module'***REMOVED***

import sys

if sys.version_info[0***REMOVED*** >= 3:
    import io

    long = int
    integer_types = (int,***REMOVED***
    basestring = str
    unicode = str
    bytes = bytes

    def asunicode(s***REMOVED***:
        if isinstance(s, bytes***REMOVED***:
            return s.decode('latin1'***REMOVED***
        return str(s***REMOVED***

    def asbytes(s***REMOVED***:
        if isinstance(s, bytes***REMOVED***:
            return s
        return str(s***REMOVED***.encode('latin1'***REMOVED***

    def asstr(s***REMOVED***:
        if isinstance(s, bytes***REMOVED***:
            return s.decode('latin1'***REMOVED***
        return str(s***REMOVED***

    def isfileobj(f***REMOVED***:
        return isinstance(f, (io.FileIO, io.BufferedReader, io.BufferedWriter***REMOVED******REMOVED***

    def open_latin1(filename, mode='r'***REMOVED***:
        return open(filename, mode=mode, encoding='iso-8859-1'***REMOVED***

    def sixu(s***REMOVED***:
        return s

    strchar = 'U'


else:
    bytes = str
    long = long
    basestring = basestring
    unicode = unicode
    integer_types = (int, long***REMOVED***
    asbytes = str
    asstr = str
    strchar = 'S'

    def isfileobj(f***REMOVED***:
        return isinstance(f, file***REMOVED***

    def asunicode(s***REMOVED***:
        if isinstance(s, unicode***REMOVED***:
            return s
        return str(s***REMOVED***.decode('ascii'***REMOVED***

    def open_latin1(filename, mode='r'***REMOVED***:
        return open(filename, mode=mode***REMOVED***

    def sixu(s***REMOVED***:
        return unicode(s, 'unicode_escape'***REMOVED***


def getexception(***REMOVED***:
    return sys.exc_info(***REMOVED***[1***REMOVED***

def asbytes_nested(x***REMOVED***:
    if hasattr(x, '__iter__'***REMOVED*** and not isinstance(x, (bytes, unicode***REMOVED******REMOVED***:
        return [asbytes_nested(y***REMOVED*** for y in x***REMOVED***
    else:
        return asbytes(x***REMOVED***

def asunicode_nested(x***REMOVED***:
    if hasattr(x, '__iter__'***REMOVED*** and not isinstance(x, (bytes, unicode***REMOVED******REMOVED***:
        return [asunicode_nested(y***REMOVED*** for y in x***REMOVED***
    else:
        return asunicode(x***REMOVED***

if sys.version_info[0***REMOVED*** >= 3 and sys.version_info[1***REMOVED*** >= 4:
    def npy_load_module(name, fn, info=None***REMOVED***:
        ***REMOVED***
        Load a module.

        .. versionadded:: 1.11.2

        Parameters
        ----------
        name : str
            Full module name.
        fn : str
            Path to module file.
        info : tuple, optional
            Only here for backward compatibility with Python 2.*.

        Returns
        -------
        mod : module

        ***REMOVED***
        import importlib
        return importlib.machinery.SourceFileLoader(name, fn***REMOVED***.load_module(***REMOVED***
else:
    def npy_load_module(name, fn, info=None***REMOVED***:
        ***REMOVED***
        Load a module.

        .. versionadded:: 1.11.2

        Parameters
        ----------
        name : str
            Full module name.
        fn : str
            Path to module file.
        info : tuple, optional
            Information as returned by `imp.find_module`
            (suffix, mode, type***REMOVED***.

        Returns
        -------
        mod : module

        ***REMOVED***
        import imp
        ***REMOVED***
        if info is None:
            path = os.path.dirname(fn***REMOVED***
            fo, fn, info = imp.find_module(name, [path***REMOVED******REMOVED***
        else:
            fo = open(fn, info[1***REMOVED******REMOVED***
        ***REMOVED***
            mod = imp.load_module(name, fo, fn, info***REMOVED***
        finally:
            fo.close(***REMOVED***
        return mod
