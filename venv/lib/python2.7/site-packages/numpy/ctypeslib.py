***REMOVED***
============================
``ctypes`` Utility Functions
============================

See Also
---------
load_library : Load a C library.
ndpointer : Array restype/argtype with verification.
as_ctypes : Create a ctypes array from an ndarray.
as_array : Create an ndarray from a ctypes array.

References
----------
.. [1***REMOVED*** "SciPy Cookbook: ctypes", http://www.scipy.org/Cookbook/Ctypes

Examples
--------
Load the C library:

>>> _lib = np.ctypeslib.load_library('libmystuff', '.'***REMOVED***     #doctest: +SKIP

Our result type, an ndarray that must be of type double, be 1-dimensional
and is C-contiguous in memory:

>>> array_1d_double = np.ctypeslib.ndpointer(
...                          dtype=np.double,
...                          ndim=1, flags='CONTIGUOUS'***REMOVED***    #doctest: +SKIP

Our C-function typically takes an array and updates its values
in-place.  For example::

    void foo_func(double* x, int length***REMOVED***
***REMOVED***
        int i;
        for (i = 0; i < length; i++***REMOVED*** {
            x[i***REMOVED*** = i*i;
    ***REMOVED***
***REMOVED***

We wrap it using:

>>> _lib.foo_func.restype = None                      #doctest: +SKIP
>>> _lib.foo_func.argtypes = [array_1d_double, c_int***REMOVED*** #doctest: +SKIP

Then, we're ready to call ``foo_func``:

>>> out = np.empty(15, dtype=np.double***REMOVED***
>>> _lib.foo_func(out, len(out***REMOVED******REMOVED***                #doctest: +SKIP

***REMOVED***
from __future__ import division, absolute_import, print_function

__all__ = ['load_library', 'ndpointer', 'test', 'ctypes_load_library',
           'c_intp', 'as_ctypes', 'as_array'***REMOVED***

import sys, os
from numpy import integer, ndarray, dtype as _dtype, deprecate, array
from numpy.core.multiarray import _flagdict, flagsobj

***REMOVED***
    import ctypes
except ImportError:
    ctypes = None

if ctypes is None:
    def _dummy(*args, **kwds***REMOVED***:
        ***REMOVED***
        Dummy object that raises an ImportError if ctypes is not available.

        Raises
        ------
        ImportError
            If ctypes is not available.

        ***REMOVED***
        raise ImportError("ctypes is not available."***REMOVED***
    ctypes_load_library = _dummy
    load_library = _dummy
    as_ctypes = _dummy
    as_array = _dummy
    from numpy import intp as c_intp
    _ndptr_base = object
else:
    import numpy.core._internal as nic
    c_intp = nic._getintp_ctype(***REMOVED***
    del nic
    _ndptr_base = ctypes.c_void_p

    # Adapted from Albert Strasheim
    def load_library(libname, loader_path***REMOVED***:
        ***REMOVED***
        It is possible to load a library using 
        >>> lib = ctypes.cdll[<full_path_name>***REMOVED***

        But there are cross-platform considerations, such as library file extensions,
        plus the fact Windows will just load the first library it finds with that name.  
        Numpy supplies the load_library function as a convenience.

        Parameters
        ----------
        libname : str
            Name of the library, which can have 'lib' as a prefix,
            but without an extension.
        loader_path : str
            Where the library can be found.

        Returns
        -------
        ctypes.cdll[libpath***REMOVED*** : library object
           A ctypes library object 

        Raises
        ------
        OSError
            If there is no library with the expected extension, or the 
            library is defective and cannot be loaded.
        ***REMOVED***
        if ctypes.__version__ < '1.0.1':
            import warnings
            warnings.warn("All features of ctypes interface may not work " \
                          "with ctypes < 1.0.1"***REMOVED***

        ext = os.path.splitext(libname***REMOVED***[1***REMOVED***
        if not ext:
            # Try to load library with platform-specific name, otherwise
            # default to libname.[so|pyd***REMOVED***.  Sometimes, these files are built
            # erroneously on non-linux platforms.
            from numpy.distutils.misc_util import get_shared_lib_extension
            so_ext = get_shared_lib_extension(***REMOVED***
            libname_ext = [libname + so_ext***REMOVED***
            # mac, windows and linux >= py3.2 shared library and loadable
            # module have different extensions so try both
            so_ext2 = get_shared_lib_extension(is_python_ext=True***REMOVED***
            if not so_ext2 == so_ext:
                libname_ext.insert(0, libname + so_ext2***REMOVED***
        else:
            libname_ext = [libname***REMOVED***

        loader_path = os.path.abspath(loader_path***REMOVED***
        if not os.path.isdir(loader_path***REMOVED***:
            libdir = os.path.dirname(loader_path***REMOVED***
        else:
            libdir = loader_path

        for ln in libname_ext:
            libpath = os.path.join(libdir, ln***REMOVED***
            if os.path.exists(libpath***REMOVED***:
                ***REMOVED***
                    return ctypes.cdll[libpath***REMOVED***
                except OSError:
                    ## defective lib file
                    raise
        ## if no successful return in the libname_ext loop:
        raise OSError("no file with expected extension"***REMOVED***

    ctypes_load_library = deprecate(load_library, 'ctypes_load_library',
                                    'load_library'***REMOVED***

def _num_fromflags(flaglist***REMOVED***:
    num = 0
    for val in flaglist:
        num += _flagdict[val***REMOVED***
    return num

_flagnames = ['C_CONTIGUOUS', 'F_CONTIGUOUS', 'ALIGNED', 'WRITEABLE',
              'OWNDATA', 'UPDATEIFCOPY'***REMOVED***
def _flags_fromnum(num***REMOVED***:
    res = [***REMOVED***
    for key in _flagnames:
        value = _flagdict[key***REMOVED***
        if (num & value***REMOVED***:
            res.append(key***REMOVED***
    return res


class _ndptr(_ndptr_base***REMOVED***:

    def _check_retval_(self***REMOVED***:
        ***REMOVED***This method is called when this class is used as the .restype
        asttribute for a shared-library function.   It constructs a numpy
        array from a void pointer.***REMOVED***
        return array(self***REMOVED***

    @property
    def __array_interface__(self***REMOVED***:
        return {'descr': self._dtype_.descr,
                '__ref': self,
                'strides': None,
                'shape': self._shape_,
                'version': 3,
                'typestr': self._dtype_.descr[0***REMOVED***[1***REMOVED***,
                'data': (self.value, False***REMOVED***,
            ***REMOVED***

    @classmethod
    def from_param(cls, obj***REMOVED***:
        if not isinstance(obj, ndarray***REMOVED***:
            raise TypeError("argument must be an ndarray"***REMOVED***
        if cls._dtype_ is not None \
               and obj.dtype != cls._dtype_:
            raise TypeError("array must have data type %s" % cls._dtype_***REMOVED***
        if cls._ndim_ is not None \
               and obj.ndim != cls._ndim_:
            raise TypeError("array must have %d dimension(s***REMOVED***" % cls._ndim_***REMOVED***
        if cls._shape_ is not None \
               and obj.shape != cls._shape_:
            raise TypeError("array must have shape %s" % str(cls._shape_***REMOVED******REMOVED***
        if cls._flags_ is not None \
               and ((obj.flags.num & cls._flags_***REMOVED*** != cls._flags_***REMOVED***:
            raise TypeError("array must have flags %s" %
                    _flags_fromnum(cls._flags_***REMOVED******REMOVED***
        return obj.ctypes


# Factory for an array-checking class with from_param defined for
#  use with ctypes argtypes mechanism
_pointer_type_cache = {***REMOVED***
def ndpointer(dtype=None, ndim=None, shape=None, flags=None***REMOVED***:
    ***REMOVED***
    Array-checking restype/argtypes.

    An ndpointer instance is used to describe an ndarray in restypes
    and argtypes specifications.  This approach is more flexible than
    using, for example, ``POINTER(c_double***REMOVED***``, since several restrictions
    can be specified, which are verified upon calling the ctypes function.
    These include data type, number of dimensions, shape and flags.  If a
    given array does not satisfy the specified restrictions,
    a ``TypeError`` is raised.

    Parameters
    ----------
    dtype : data-type, optional
        Array data-type.
    ndim : int, optional
        Number of array dimensions.
    shape : tuple of ints, optional
        Array shape.
    flags : str or tuple of str
        Array flags; may be one or more of:

          - C_CONTIGUOUS / C / CONTIGUOUS
          - F_CONTIGUOUS / F / FORTRAN
          - OWNDATA / O
          - WRITEABLE / W
          - ALIGNED / A
          - UPDATEIFCOPY / U

    Returns
    -------
    klass : ndpointer type object
        A type object, which is an ``_ndtpr`` instance containing
        dtype, ndim, shape and flags information.

    Raises
    ------
    TypeError
        If a given array does not satisfy the specified restrictions.

    Examples
    --------
    >>> clib.somefunc.argtypes = [np.ctypeslib.ndpointer(dtype=np.float64,
    ...                                                  ndim=1,
    ...                                                  flags='C_CONTIGUOUS'***REMOVED******REMOVED***
    ... #doctest: +SKIP
    >>> clib.somefunc(np.array([1, 2, 3***REMOVED***, dtype=np.float64***REMOVED******REMOVED***
    ... #doctest: +SKIP

    ***REMOVED***

    if dtype is not None:
        dtype = _dtype(dtype***REMOVED***
    num = None
    if flags is not None:
        if isinstance(flags, str***REMOVED***:
            flags = flags.split(','***REMOVED***
        elif isinstance(flags, (int, integer***REMOVED******REMOVED***:
            num = flags
            flags = _flags_fromnum(num***REMOVED***
        elif isinstance(flags, flagsobj***REMOVED***:
            num = flags.num
            flags = _flags_fromnum(num***REMOVED***
        if num is None:
            ***REMOVED***
                flags = [x.strip(***REMOVED***.upper(***REMOVED*** for x in flags***REMOVED***
            ***REMOVED***
                raise TypeError("invalid flags specification"***REMOVED***
            num = _num_fromflags(flags***REMOVED***
    ***REMOVED***
        return _pointer_type_cache[(dtype, ndim, shape, num***REMOVED******REMOVED***
    except KeyError:
        pass
    if dtype is None:
        name = 'any'
    elif dtype.names:
        name = str(id(dtype***REMOVED******REMOVED***
    else:
        name = dtype.str
    if ndim is not None:
        name += "_%dd" % ndim
    if shape is not None:
        ***REMOVED***
            strshape = [str(x***REMOVED*** for x in shape***REMOVED***
        except TypeError:
            strshape = [str(shape***REMOVED******REMOVED***
            shape = (shape,***REMOVED***
        shape = tuple(shape***REMOVED***
        name += "_"+"x".join(strshape***REMOVED***
    if flags is not None:
        name += "_"+"_".join(flags***REMOVED***
    else:
        flags = [***REMOVED***
    klass = type("ndpointer_%s"%name, (_ndptr,***REMOVED***,
             ***REMOVED***"_dtype_": dtype,
                  "_shape_" : shape,
                  "_ndim_" : ndim,
                  "_flags_" : num***REMOVED******REMOVED***
    _pointer_type_cache[dtype***REMOVED*** = klass
    return klass

if ctypes is not None:
    ct = ctypes
    ################################################################
    # simple types

    # maps the numpy typecodes like '<f8' to simple ctypes types like
    # c_double. Filled in by prep_simple.
    _typecodes = {***REMOVED***

    def prep_simple(simple_type, dtype***REMOVED***:
        ***REMOVED***Given a ctypes simple type, construct and attach an
        __array_interface__ property to it if it does not yet have one.
        ***REMOVED***
        ***REMOVED*** simple_type.__array_interface__
        except AttributeError: pass
        else: return

        typestr = _dtype(dtype***REMOVED***.str
        _typecodes[typestr***REMOVED*** = simple_type

        def __array_interface__(self***REMOVED***:
            return {'descr': [('', typestr***REMOVED******REMOVED***,
                    '__ref': self,
                    'strides': None,
                    'shape': (***REMOVED***,
                    'version': 3,
                    'typestr': typestr,
                    'data': (ct.addressof(self***REMOVED***, False***REMOVED***,
                ***REMOVED***

        simple_type.__array_interface__ = property(__array_interface__***REMOVED***

    simple_types = [
        ((ct.c_byte, ct.c_short, ct.c_int, ct.c_long, ct.c_longlong***REMOVED***, "i"***REMOVED***,
        ((ct.c_ubyte, ct.c_ushort, ct.c_uint, ct.c_ulong, ct.c_ulonglong***REMOVED***, "u"***REMOVED***,
        ((ct.c_float, ct.c_double***REMOVED***, "f"***REMOVED***,
    ***REMOVED***

    # Prep that numerical ctypes types:
    for types, code in simple_types:
        for tp in types:
            prep_simple(tp, "%c%d" % (code, ct.sizeof(tp***REMOVED******REMOVED******REMOVED***

    ################################################################
    # array types

    _ARRAY_TYPE = type(ct.c_int * 1***REMOVED***

    def prep_array(array_type***REMOVED***:
        ***REMOVED***Given a ctypes array type, construct and attach an
        __array_interface__ property to it if it does not yet have one.
        ***REMOVED***
        ***REMOVED*** array_type.__array_interface__
        except AttributeError: pass
        else: return

        shape = [***REMOVED***
        ob = array_type
        while type(ob***REMOVED*** is _ARRAY_TYPE:
            shape.append(ob._length_***REMOVED***
            ob = ob._type_
        shape = tuple(shape***REMOVED***
        ai = ob(***REMOVED***.__array_interface__
        descr = ai['descr'***REMOVED***
        typestr = ai['typestr'***REMOVED***

        def __array_interface__(self***REMOVED***:
            return {'descr': descr,
                    '__ref': self,
                    'strides': None,
                    'shape': shape,
                    'version': 3,
                    'typestr': typestr,
                    'data': (ct.addressof(self***REMOVED***, False***REMOVED***,
                ***REMOVED***

        array_type.__array_interface__ = property(__array_interface__***REMOVED***

    def prep_pointer(pointer_obj, shape***REMOVED***:
        ***REMOVED***Given a ctypes pointer object, construct and
        attach an __array_interface__ property to it if it does not
        yet have one.
        ***REMOVED***
        ***REMOVED*** pointer_obj.__array_interface__
        except AttributeError: pass
        else: return

        contents = pointer_obj.contents
        dtype = _dtype(type(contents***REMOVED******REMOVED***

        inter = {'version': 3,
                 'typestr': dtype.str,
                 'data': (ct.addressof(contents***REMOVED***, False***REMOVED***,
                 'shape': shape***REMOVED***

        pointer_obj.__array_interface__ = inter

    ################################################################
    # public functions

    def as_array(obj, shape=None***REMOVED***:
        ***REMOVED***Create a numpy array from a ctypes array or a ctypes POINTER.
        The numpy array shares the memory with the ctypes object.

        The size parameter must be given if converting from a ctypes POINTER.
        The size parameter is ignored if converting from a ctypes array
        ***REMOVED***
        tp = type(obj***REMOVED***
        ***REMOVED*** tp.__array_interface__
        except AttributeError:
            if hasattr(obj, 'contents'***REMOVED***:
                prep_pointer(obj, shape***REMOVED***
            else:
                prep_array(tp***REMOVED***
        return array(obj, copy=False***REMOVED***

    def as_ctypes(obj***REMOVED***:
        ***REMOVED***Create and return a ctypes object from a numpy array.  Actually
        anything that exposes the __array_interface__ is accepted.***REMOVED***
        ai = obj.__array_interface__
        if ai["strides"***REMOVED***:
            raise TypeError("strided arrays not supported"***REMOVED***
        if ai["version"***REMOVED*** != 3:
            raise TypeError("only __array_interface__ version 3 supported"***REMOVED***
        addr, readonly = ai["data"***REMOVED***
        if readonly:
            raise TypeError("readonly arrays unsupported"***REMOVED***
        tp = _typecodes[ai["typestr"***REMOVED******REMOVED***
        for dim in ai["shape"***REMOVED***[::-1***REMOVED***:
            tp = tp * dim
        result = tp.from_address(addr***REMOVED***
        result.__keep = ai
        return result
