from __future__ import division, absolute_import, print_function

__all__ = ['matrix', 'bmat', 'mat', 'asmatrix'***REMOVED***

import sys
import numpy.core.numeric as N
from numpy.core.numeric import concatenate, isscalar, binary_repr, identity, asanyarray
from numpy.core.numerictypes import issubdtype

# make translation table
_numchars = '0123456789.-+jeEL'

if sys.version_info[0***REMOVED*** >= 3:
    class _NumCharTable:
        def __getitem__(self, i***REMOVED***:
            if chr(i***REMOVED*** in _numchars:
                return chr(i***REMOVED***
            else:
                return None
    _table = _NumCharTable(***REMOVED***
    def _eval(astr***REMOVED***:
        str_ = astr.translate(_table***REMOVED***
        if not str_:
            raise TypeError("Invalid data string supplied: " + astr***REMOVED***
        else:
            return eval(str_***REMOVED***

else:
    _table = [None***REMOVED****256
    for k in range(256***REMOVED***:
        _table[k***REMOVED*** = chr(k***REMOVED***
    _table = ''.join(_table***REMOVED***

    _todelete = [***REMOVED***
    for k in _table:
        if k not in _numchars:
            _todelete.append(k***REMOVED***
    _todelete = ''.join(_todelete***REMOVED***
    del k

    def _eval(astr***REMOVED***:
        str_ = astr.translate(_table, _todelete***REMOVED***
        if not str_:
            raise TypeError("Invalid data string supplied: " + astr***REMOVED***
        else:
            return eval(str_***REMOVED***

def _convert_from_string(data***REMOVED***:
    rows = data.split(';'***REMOVED***
    newdata = [***REMOVED***
    count = 0
    for row in rows:
        trow = row.split(','***REMOVED***
        newrow = [***REMOVED***
        for col in trow:
            temp = col.split(***REMOVED***
            newrow.extend(map(_eval, temp***REMOVED******REMOVED***
        if count == 0:
            Ncols = len(newrow***REMOVED***
        elif len(newrow***REMOVED*** != Ncols:
            raise ValueError("Rows not the same size."***REMOVED***
        count += 1
        newdata.append(newrow***REMOVED***
    return newdata

def asmatrix(data, dtype=None***REMOVED***:
    ***REMOVED***
    Interpret the input as a matrix.

    Unlike `matrix`, `asmatrix` does not make a copy if the input is already
    a matrix or an ndarray.  Equivalent to ``matrix(data, copy=False***REMOVED***``.

    Parameters
    ----------
    data : array_like
        Input data.
    dtype : data-type
       Data-type of the output matrix.

    Returns
    -------
    mat : matrix
        `data` interpreted as a matrix.

    Examples
    --------
    >>> x = np.array([[1, 2***REMOVED***, [3, 4***REMOVED******REMOVED******REMOVED***

    >>> m = np.asmatrix(x***REMOVED***

    >>> x[0,0***REMOVED*** = 5

    >>> m
    matrix([[5, 2***REMOVED***,
            [3, 4***REMOVED******REMOVED******REMOVED***

    ***REMOVED***
    return matrix(data, dtype=dtype, copy=False***REMOVED***

def matrix_power(M, n***REMOVED***:
    ***REMOVED***
    Raise a square matrix to the (integer***REMOVED*** power `n`.

    For positive integers `n`, the power is computed by repeated matrix
    squarings and matrix multiplications. If ``n == 0``, the identity matrix
    of the same shape as M is returned. If ``n < 0``, the inverse
    is computed and then raised to the ``abs(n***REMOVED***``.

    Parameters
    ----------
    M : ndarray or matrix object
        Matrix to be "powered."  Must be square, i.e. ``M.shape == (m, m***REMOVED***``,
        with `m` a positive integer.
    n : int
        The exponent can be any integer or long integer, positive,
        negative, or zero.

    Returns
    -------
    M**n : ndarray or matrix object
        The return value is the same shape and type as `M`;
        if the exponent is positive or zero then the type of the
        elements is the same as those of `M`. If the exponent is
        negative the elements are floating-point.

    Raises
    ------
    LinAlgError
        If the matrix is not numerically invertible.

    See Also
    --------
    matrix
        Provides an equivalent function as the exponentiation operator
        (``**``, not ``^``***REMOVED***.

    Examples
    --------
    >>> from numpy import linalg as LA
    >>> i = np.array([[0, 1***REMOVED***, [-1, 0***REMOVED******REMOVED******REMOVED*** # matrix equiv. of the imaginary unit
    >>> LA.matrix_power(i, 3***REMOVED*** # should = -i
    array([[ 0, -1***REMOVED***,
           [ 1,  0***REMOVED******REMOVED******REMOVED***
    >>> LA.matrix_power(np.matrix(i***REMOVED***, 3***REMOVED*** # matrix arg returns matrix
    matrix([[ 0, -1***REMOVED***,
            [ 1,  0***REMOVED******REMOVED******REMOVED***
    >>> LA.matrix_power(i, 0***REMOVED***
    array([[1, 0***REMOVED***,
           [0, 1***REMOVED******REMOVED******REMOVED***
    >>> LA.matrix_power(i, -3***REMOVED*** # should = 1/(-i***REMOVED*** = i, but w/ f.p. elements
    array([[ 0.,  1.***REMOVED***,
           [-1.,  0.***REMOVED******REMOVED******REMOVED***

    Somewhat more sophisticated example

    >>> q = np.zeros((4, 4***REMOVED******REMOVED***
    >>> q[0:2, 0:2***REMOVED*** = -i
    >>> q[2:4, 2:4***REMOVED*** = i
    >>> q # one of the three quarternion units not equal to 1
    array([[ 0., -1.,  0.,  0.***REMOVED***,
           [ 1.,  0.,  0.,  0.***REMOVED***,
           [ 0.,  0.,  0.,  1.***REMOVED***,
           [ 0.,  0., -1.,  0.***REMOVED******REMOVED******REMOVED***
    >>> LA.matrix_power(q, 2***REMOVED*** # = -np.eye(4***REMOVED***
    array([[-1.,  0.,  0.,  0.***REMOVED***,
           [ 0., -1.,  0.,  0.***REMOVED***,
           [ 0.,  0., -1.,  0.***REMOVED***,
           [ 0.,  0.,  0., -1.***REMOVED******REMOVED******REMOVED***

    ***REMOVED***
    M = asanyarray(M***REMOVED***
    if len(M.shape***REMOVED*** != 2 or M.shape[0***REMOVED*** != M.shape[1***REMOVED***:
        raise ValueError("input must be a square array"***REMOVED***
    if not issubdtype(type(n***REMOVED***, int***REMOVED***:
        raise TypeError("exponent must be an integer"***REMOVED***

    from numpy.linalg import inv

    if n==0:
        M = M.copy(***REMOVED***
        M[:***REMOVED*** = identity(M.shape[0***REMOVED******REMOVED***
        return M
    elif n<0:
        M = inv(M***REMOVED***
        n *= -1

    result = M
    if n <= 3:
        for _ in range(n-1***REMOVED***:
            result=N.dot(result, M***REMOVED***
        return result

    # binary decomposition to reduce the number of Matrix
    # multiplications for n > 3.
    beta = binary_repr(n***REMOVED***
    Z, q, t = M, 0, len(beta***REMOVED***
    while beta[t-q-1***REMOVED*** == '0':
        Z = N.dot(Z, Z***REMOVED***
        q += 1
    result = Z
    for k in range(q+1, t***REMOVED***:
        Z = N.dot(Z, Z***REMOVED***
        if beta[t-k-1***REMOVED*** == '1':
            result = N.dot(result, Z***REMOVED***
    return result


class matrix(N.ndarray***REMOVED***:
    ***REMOVED***
    matrix(data, dtype=None, copy=True***REMOVED***

    Returns a matrix from an array-like object, or from a string of data.
    A matrix is a specialized 2-D array that retains its 2-D nature
    through operations.  It has certain special operators, such as ``*``
    (matrix multiplication***REMOVED*** and ``**`` (matrix power***REMOVED***.

    Parameters
    ----------
    data : array_like or string
       If `data` is a string, it is interpreted as a matrix with commas
       or spaces separating columns, and semicolons separating rows.
    dtype : data-type
       Data-type of the output matrix.
    copy : bool
       If `data` is already an `ndarray`, then this flag determines
       whether the data is copied (the default***REMOVED***, or whether a view is
       constructed.

    See Also
    --------
    array

    Examples
    --------
    >>> a = np.matrix('1 2; 3 4'***REMOVED***
    >>> print(a***REMOVED***
    [[1 2***REMOVED***
     [3 4***REMOVED******REMOVED***

    >>> np.matrix([[1, 2***REMOVED***, [3, 4***REMOVED******REMOVED******REMOVED***
    matrix([[1, 2***REMOVED***,
            [3, 4***REMOVED******REMOVED******REMOVED***

    ***REMOVED***
    __array_priority__ = 10.0
    def __new__(subtype, data, dtype=None, copy=True***REMOVED***:
        if isinstance(data, matrix***REMOVED***:
            dtype2 = data.dtype
            if (dtype is None***REMOVED***:
                dtype = dtype2
            if (dtype2 == dtype***REMOVED*** and (not copy***REMOVED***:
                return data
            return data.astype(dtype***REMOVED***

        if isinstance(data, N.ndarray***REMOVED***:
            if dtype is None:
                intype = data.dtype
            else:
                intype = N.dtype(dtype***REMOVED***
            new = data.view(subtype***REMOVED***
            if intype != data.dtype:
                return new.astype(intype***REMOVED***
            if copy: return new.copy(***REMOVED***
            else: return new

        if isinstance(data, str***REMOVED***:
            data = _convert_from_string(data***REMOVED***

        # now convert data to an array
        arr = N.array(data, dtype=dtype, copy=copy***REMOVED***
        ndim = arr.ndim
        shape = arr.shape
        if (ndim > 2***REMOVED***:
            raise ValueError("matrix must be 2-dimensional"***REMOVED***
        elif ndim == 0:
            shape = (1, 1***REMOVED***
        elif ndim == 1:
            shape = (1, shape[0***REMOVED******REMOVED***

        order = 'C'
        if (ndim == 2***REMOVED*** and arr.flags.fortran:
            order = 'F'

        if not (order or arr.flags.contiguous***REMOVED***:
            arr = arr.copy(***REMOVED***

        ret = N.ndarray.__new__(subtype, shape, arr.dtype,
                                buffer=arr,
                                order=order***REMOVED***
        return ret

    def __array_finalize__(self, obj***REMOVED***:
        self._getitem = False
        if (isinstance(obj, matrix***REMOVED*** and obj._getitem***REMOVED***: return
        ndim = self.ndim
        if (ndim == 2***REMOVED***:
            return
        if (ndim > 2***REMOVED***:
            newshape = tuple([x for x in self.shape if x > 1***REMOVED******REMOVED***
            ndim = len(newshape***REMOVED***
            if ndim == 2:
                self.shape = newshape
                return
            elif (ndim > 2***REMOVED***:
                raise ValueError("shape too large to be a matrix."***REMOVED***
        else:
            newshape = self.shape
        if ndim == 0:
            self.shape = (1, 1***REMOVED***
        elif ndim == 1:
            self.shape = (1, newshape[0***REMOVED******REMOVED***
        return

    def __getitem__(self, index***REMOVED***:
        self._getitem = True

        ***REMOVED***
            out = N.ndarray.__getitem__(self, index***REMOVED***
        finally:
            self._getitem = False

        if not isinstance(out, N.ndarray***REMOVED***:
            return out

        if out.ndim == 0:
            return out[(***REMOVED******REMOVED***
        if out.ndim == 1:
            sh = out.shape[0***REMOVED***
            # Determine when we should have a column array
            ***REMOVED***
                n = len(index***REMOVED***
            ***REMOVED***
                n = 0
            if n > 1 and isscalar(index[1***REMOVED******REMOVED***:
                out.shape = (sh, 1***REMOVED***
            else:
                out.shape = (1, sh***REMOVED***
        return out

    def __mul__(self, other***REMOVED***:
        if isinstance(other, (N.ndarray, list, tuple***REMOVED******REMOVED*** :
            # This promotes 1-D vectors to row vectors
            return N.dot(self, asmatrix(other***REMOVED******REMOVED***
        if isscalar(other***REMOVED*** or not hasattr(other, '__rmul__'***REMOVED*** :
            return N.dot(self, other***REMOVED***
        return NotImplemented

    def __rmul__(self, other***REMOVED***:
        return N.dot(other, self***REMOVED***

    def __imul__(self, other***REMOVED***:
        self[:***REMOVED*** = self * other
        return self

    def __pow__(self, other***REMOVED***:
        return matrix_power(self, other***REMOVED***

    def __ipow__(self, other***REMOVED***:
        self[:***REMOVED*** = self ** other
        return self

    def __rpow__(self, other***REMOVED***:
        return NotImplemented

    def __repr__(self***REMOVED***:
        s = repr(self.__array__(***REMOVED******REMOVED***.replace('array', 'matrix'***REMOVED***
        # now, 'matrix' has 6 letters, and 'array' 5, so the columns don't
        # line up anymore. We need to add a space.
        l = s.splitlines(***REMOVED***
        for i in range(1, len(l***REMOVED******REMOVED***:
            if l[i***REMOVED***:
                l[i***REMOVED*** = ' ' + l[i***REMOVED***
        return '\n'.join(l***REMOVED***

    def __str__(self***REMOVED***:
        return str(self.__array__(***REMOVED******REMOVED***

    def _align(self, axis***REMOVED***:
        ***REMOVED***A convenience function for operations that need to preserve axis
        orientation.
        ***REMOVED***
        if axis is None:
            return self[0, 0***REMOVED***
        elif axis==0:
            return self
        elif axis==1:
            return self.transpose(***REMOVED***
        else:
            raise ValueError("unsupported axis"***REMOVED***

    def _collapse(self, axis***REMOVED***:
        ***REMOVED***A convenience function for operations that want to collapse
        to a scalar like _align, but are using keepdims=True
        ***REMOVED***
        if axis is None:
            return self[0, 0***REMOVED***
        else:
            return self

    # Necessary because base-class tolist expects dimension
    #  reduction by x[0***REMOVED***
    def tolist(self***REMOVED***:
        ***REMOVED***
        Return the matrix as a (possibly nested***REMOVED*** list.

        See `ndarray.tolist` for full documentation.

        See Also
        --------
        ndarray.tolist

        Examples
        --------
        >>> x = np.matrix(np.arange(12***REMOVED***.reshape((3,4***REMOVED******REMOVED******REMOVED***; x
        matrix([[ 0,  1,  2,  3***REMOVED***,
                [ 4,  5,  6,  7***REMOVED***,
                [ 8,  9, 10, 11***REMOVED******REMOVED******REMOVED***
        >>> x.tolist(***REMOVED***
        [[0, 1, 2, 3***REMOVED***, [4, 5, 6, 7***REMOVED***, [8, 9, 10, 11***REMOVED******REMOVED***

        ***REMOVED***
        return self.__array__(***REMOVED***.tolist(***REMOVED***

    # To preserve orientation of result...
    def sum(self, axis=None, dtype=None, out=None***REMOVED***:
        ***REMOVED***
        Returns the sum of the matrix elements, along the given axis.

        Refer to `numpy.sum` for full documentation.

        See Also
        --------
        numpy.sum

        Notes
        -----
        This is the same as `ndarray.sum`, except that where an `ndarray` would
        be returned, a `matrix` object is returned instead.

        Examples
        --------
        >>> x = np.matrix([[1, 2***REMOVED***, [4, 3***REMOVED******REMOVED******REMOVED***
        >>> x.sum(***REMOVED***
        10
        >>> x.sum(axis=1***REMOVED***
        matrix([[3***REMOVED***,
                [7***REMOVED******REMOVED******REMOVED***
        >>> x.sum(axis=1, dtype='float'***REMOVED***
        matrix([[ 3.***REMOVED***,
                [ 7.***REMOVED******REMOVED******REMOVED***
        >>> out = np.zeros((1, 2***REMOVED***, dtype='float'***REMOVED***
        >>> x.sum(axis=1, dtype='float', out=out***REMOVED***
        matrix([[ 3.***REMOVED***,
                [ 7.***REMOVED******REMOVED******REMOVED***

        ***REMOVED***
        return N.ndarray.sum(self, axis, dtype, out, keepdims=True***REMOVED***._collapse(axis***REMOVED***


    # To update docstring from array to matrix...
    def squeeze(self, axis=None***REMOVED***:
        ***REMOVED***
        Return a possibly reshaped matrix.

        Refer to `numpy.squeeze` for more documentation.

        Parameters
        ----------
        axis : None or int or tuple of ints, optional
            Selects a subset of the single-dimensional entries in the shape.
            If an axis is selected with shape entry greater than one,
            an error is raised.

        Returns
        -------
        squeezed : matrix
            The matrix, but as a (1, N***REMOVED*** matrix if it had shape (N, 1***REMOVED***.

        See Also
        --------
        numpy.squeeze : related function

        Notes
        -----
        If `m` has a single column then that column is returned
        as the single row of a matrix.  Otherwise `m` is returned.
        The returned matrix is always either `m` itself or a view into `m`.
        Supplying an axis keyword argument will not affect the returned matrix
        but it may cause an error to be raised.

        Examples
        --------
        >>> c = np.matrix([[1***REMOVED***, [2***REMOVED******REMOVED******REMOVED***
        >>> c
        matrix([[1***REMOVED***,
                [2***REMOVED******REMOVED******REMOVED***
        >>> c.squeeze(***REMOVED***
        matrix([[1, 2***REMOVED******REMOVED******REMOVED***
        >>> r = c.T
        >>> r
        matrix([[1, 2***REMOVED******REMOVED******REMOVED***
        >>> r.squeeze(***REMOVED***
        matrix([[1, 2***REMOVED******REMOVED******REMOVED***
        >>> m = np.matrix([[1, 2***REMOVED***, [3, 4***REMOVED******REMOVED******REMOVED***
        >>> m.squeeze(***REMOVED***
        matrix([[1, 2***REMOVED***,
                [3, 4***REMOVED******REMOVED******REMOVED***

        ***REMOVED***
        return N.ndarray.squeeze(self, axis=axis***REMOVED***


    # To update docstring from array to matrix...
    def flatten(self, order='C'***REMOVED***:
        ***REMOVED***
        Return a flattened copy of the matrix.

        All `N` elements of the matrix are placed into a single row.

        Parameters
        ----------
        order : {'C', 'F', 'A', 'K'***REMOVED***, optional
            'C' means to flatten in row-major (C-style***REMOVED*** order. 'F' means to
            flatten in column-major (Fortran-style***REMOVED*** order. 'A' means to
            flatten in column-major order if `m` is Fortran *contiguous* in
            memory, row-major order otherwise. 'K' means to flatten `m` in
            the order the elements occur in memory. The default is 'C'.

        Returns
        -------
        y : matrix
            A copy of the matrix, flattened to a `(1, N***REMOVED***` matrix where `N`
            is the number of elements in the original matrix.

        See Also
        --------
        ravel : Return a flattened array.
        flat : A 1-D flat iterator over the matrix.

        Examples
        --------
        >>> m = np.matrix([[1,2***REMOVED***, [3,4***REMOVED******REMOVED******REMOVED***
        >>> m.flatten(***REMOVED***
        matrix([[1, 2, 3, 4***REMOVED******REMOVED******REMOVED***
        >>> m.flatten('F'***REMOVED***
        matrix([[1, 3, 2, 4***REMOVED******REMOVED******REMOVED***

        ***REMOVED***
        return N.ndarray.flatten(self, order=order***REMOVED***

    def mean(self, axis=None, dtype=None, out=None***REMOVED***:
        ***REMOVED***
        Returns the average of the matrix elements along the given axis.

        Refer to `numpy.mean` for full documentation.

        See Also
        --------
        numpy.mean

        Notes
        -----
        Same as `ndarray.mean` except that, where that returns an `ndarray`,
        this returns a `matrix` object.

        Examples
        --------
        >>> x = np.matrix(np.arange(12***REMOVED***.reshape((3, 4***REMOVED******REMOVED******REMOVED***
        >>> x
        matrix([[ 0,  1,  2,  3***REMOVED***,
                [ 4,  5,  6,  7***REMOVED***,
                [ 8,  9, 10, 11***REMOVED******REMOVED******REMOVED***
        >>> x.mean(***REMOVED***
        5.5
        >>> x.mean(0***REMOVED***
        matrix([[ 4.,  5.,  6.,  7.***REMOVED******REMOVED******REMOVED***
        >>> x.mean(1***REMOVED***
        matrix([[ 1.5***REMOVED***,
                [ 5.5***REMOVED***,
                [ 9.5***REMOVED******REMOVED******REMOVED***

        ***REMOVED***
        return N.ndarray.mean(self, axis, dtype, out, keepdims=True***REMOVED***._collapse(axis***REMOVED***

    def std(self, axis=None, dtype=None, out=None, ddof=0***REMOVED***:
        ***REMOVED***
        Return the standard deviation of the array elements along the given axis.

        Refer to `numpy.std` for full documentation.

        See Also
        --------
        numpy.std

        Notes
        -----
        This is the same as `ndarray.std`, except that where an `ndarray` would
        be returned, a `matrix` object is returned instead.

        Examples
        --------
        >>> x = np.matrix(np.arange(12***REMOVED***.reshape((3, 4***REMOVED******REMOVED******REMOVED***
        >>> x
        matrix([[ 0,  1,  2,  3***REMOVED***,
                [ 4,  5,  6,  7***REMOVED***,
                [ 8,  9, 10, 11***REMOVED******REMOVED******REMOVED***
        >>> x.std(***REMOVED***
        3.4520525295346629
        >>> x.std(0***REMOVED***
        matrix([[ 3.26598632,  3.26598632,  3.26598632,  3.26598632***REMOVED******REMOVED******REMOVED***
        >>> x.std(1***REMOVED***
        matrix([[ 1.11803399***REMOVED***,
                [ 1.11803399***REMOVED***,
                [ 1.11803399***REMOVED******REMOVED******REMOVED***

        ***REMOVED***
        return N.ndarray.std(self, axis, dtype, out, ddof, keepdims=True***REMOVED***._collapse(axis***REMOVED***

    def var(self, axis=None, dtype=None, out=None, ddof=0***REMOVED***:
        ***REMOVED***
        Returns the variance of the matrix elements, along the given axis.

        Refer to `numpy.var` for full documentation.

        See Also
        --------
        numpy.var

        Notes
        -----
        This is the same as `ndarray.var`, except that where an `ndarray` would
        be returned, a `matrix` object is returned instead.

        Examples
        --------
        >>> x = np.matrix(np.arange(12***REMOVED***.reshape((3, 4***REMOVED******REMOVED******REMOVED***
        >>> x
        matrix([[ 0,  1,  2,  3***REMOVED***,
                [ 4,  5,  6,  7***REMOVED***,
                [ 8,  9, 10, 11***REMOVED******REMOVED******REMOVED***
        >>> x.var(***REMOVED***
        11.916666666666666
        >>> x.var(0***REMOVED***
        matrix([[ 10.66666667,  10.66666667,  10.66666667,  10.66666667***REMOVED******REMOVED******REMOVED***
        >>> x.var(1***REMOVED***
        matrix([[ 1.25***REMOVED***,
                [ 1.25***REMOVED***,
                [ 1.25***REMOVED******REMOVED******REMOVED***

        ***REMOVED***
        return N.ndarray.var(self, axis, dtype, out, ddof, keepdims=True***REMOVED***._collapse(axis***REMOVED***

    def prod(self, axis=None, dtype=None, out=None***REMOVED***:
        ***REMOVED***
        Return the product of the array elements over the given axis.

        Refer to `prod` for full documentation.

        See Also
        --------
        prod, ndarray.prod

        Notes
        -----
        Same as `ndarray.prod`, except, where that returns an `ndarray`, this
        returns a `matrix` object instead.

        Examples
        --------
        >>> x = np.matrix(np.arange(12***REMOVED***.reshape((3,4***REMOVED******REMOVED******REMOVED***; x
        matrix([[ 0,  1,  2,  3***REMOVED***,
                [ 4,  5,  6,  7***REMOVED***,
                [ 8,  9, 10, 11***REMOVED******REMOVED******REMOVED***
        >>> x.prod(***REMOVED***
        0
        >>> x.prod(0***REMOVED***
        matrix([[  0,  45, 120, 231***REMOVED******REMOVED******REMOVED***
        >>> x.prod(1***REMOVED***
        matrix([[   0***REMOVED***,
                [ 840***REMOVED***,
                [7920***REMOVED******REMOVED******REMOVED***

        ***REMOVED***
        return N.ndarray.prod(self, axis, dtype, out, keepdims=True***REMOVED***._collapse(axis***REMOVED***

    def any(self, axis=None, out=None***REMOVED***:
        ***REMOVED***
        Test whether any array element along a given axis evaluates to True.

        Refer to `numpy.any` for full documentation.

        Parameters
        ----------
        axis : int, optional
            Axis along which logical OR is performed
        out : ndarray, optional
            Output to existing array instead of creating new one, must have
            same shape as expected output

        Returns
        -------
            any : bool, ndarray
                Returns a single bool if `axis` is ``None``; otherwise,
                returns `ndarray`

        ***REMOVED***
        return N.ndarray.any(self, axis, out, keepdims=True***REMOVED***._collapse(axis***REMOVED***

    def all(self, axis=None, out=None***REMOVED***:
        ***REMOVED***
        Test whether all matrix elements along a given axis evaluate to True.

        Parameters
        ----------
        See `numpy.all` for complete descriptions

        See Also
        --------
        numpy.all

        Notes
        -----
        This is the same as `ndarray.all`, but it returns a `matrix` object.

        Examples
        --------
        >>> x = np.matrix(np.arange(12***REMOVED***.reshape((3,4***REMOVED******REMOVED******REMOVED***; x
        matrix([[ 0,  1,  2,  3***REMOVED***,
                [ 4,  5,  6,  7***REMOVED***,
                [ 8,  9, 10, 11***REMOVED******REMOVED******REMOVED***
        >>> y = x[0***REMOVED***; y
        matrix([[0, 1, 2, 3***REMOVED******REMOVED******REMOVED***
        >>> (x == y***REMOVED***
        matrix([[ True,  True,  True,  True***REMOVED***,
                [False, False, False, False***REMOVED***,
                [False, False, False, False***REMOVED******REMOVED***, dtype=bool***REMOVED***
        >>> (x == y***REMOVED***.all(***REMOVED***
        False
        >>> (x == y***REMOVED***.all(0***REMOVED***
        matrix([[False, False, False, False***REMOVED******REMOVED***, dtype=bool***REMOVED***
        >>> (x == y***REMOVED***.all(1***REMOVED***
        matrix([[ True***REMOVED***,
                [False***REMOVED***,
                [False***REMOVED******REMOVED***, dtype=bool***REMOVED***

        ***REMOVED***
        return N.ndarray.all(self, axis, out, keepdims=True***REMOVED***._collapse(axis***REMOVED***

    def max(self, axis=None, out=None***REMOVED***:
        ***REMOVED***
        Return the maximum value along an axis.

        Parameters
        ----------
        See `amax` for complete descriptions

        See Also
        --------
        amax, ndarray.max

        Notes
        -----
        This is the same as `ndarray.max`, but returns a `matrix` object
        where `ndarray.max` would return an ndarray.

        Examples
        --------
        >>> x = np.matrix(np.arange(12***REMOVED***.reshape((3,4***REMOVED******REMOVED******REMOVED***; x
        matrix([[ 0,  1,  2,  3***REMOVED***,
                [ 4,  5,  6,  7***REMOVED***,
                [ 8,  9, 10, 11***REMOVED******REMOVED******REMOVED***
        >>> x.max(***REMOVED***
        11
        >>> x.max(0***REMOVED***
        matrix([[ 8,  9, 10, 11***REMOVED******REMOVED******REMOVED***
        >>> x.max(1***REMOVED***
        matrix([[ 3***REMOVED***,
                [ 7***REMOVED***,
                [11***REMOVED******REMOVED******REMOVED***

        ***REMOVED***
        return N.ndarray.max(self, axis, out, keepdims=True***REMOVED***._collapse(axis***REMOVED***

    def argmax(self, axis=None, out=None***REMOVED***:
        ***REMOVED***
        Indexes of the maximum values along an axis.

        Return the indexes of the first occurrences of the maximum values
        along the specified axis.  If axis is None, the index is for the
        flattened matrix.

        Parameters
        ----------
        See `numpy.argmax` for complete descriptions

        See Also
        --------
        numpy.argmax

        Notes
        -----
        This is the same as `ndarray.argmax`, but returns a `matrix` object
        where `ndarray.argmax` would return an `ndarray`.

        Examples
        --------
        >>> x = np.matrix(np.arange(12***REMOVED***.reshape((3,4***REMOVED******REMOVED******REMOVED***; x
        matrix([[ 0,  1,  2,  3***REMOVED***,
                [ 4,  5,  6,  7***REMOVED***,
                [ 8,  9, 10, 11***REMOVED******REMOVED******REMOVED***
        >>> x.argmax(***REMOVED***
        11
        >>> x.argmax(0***REMOVED***
        matrix([[2, 2, 2, 2***REMOVED******REMOVED******REMOVED***
        >>> x.argmax(1***REMOVED***
        matrix([[3***REMOVED***,
                [3***REMOVED***,
                [3***REMOVED******REMOVED******REMOVED***

        ***REMOVED***
        return N.ndarray.argmax(self, axis, out***REMOVED***._align(axis***REMOVED***

    def min(self, axis=None, out=None***REMOVED***:
        ***REMOVED***
        Return the minimum value along an axis.

        Parameters
        ----------
        See `amin` for complete descriptions.

        See Also
        --------
        amin, ndarray.min

        Notes
        -----
        This is the same as `ndarray.min`, but returns a `matrix` object
        where `ndarray.min` would return an ndarray.

        Examples
        --------
        >>> x = -np.matrix(np.arange(12***REMOVED***.reshape((3,4***REMOVED******REMOVED******REMOVED***; x
        matrix([[  0,  -1,  -2,  -3***REMOVED***,
                [ -4,  -5,  -6,  -7***REMOVED***,
                [ -8,  -9, -10, -11***REMOVED******REMOVED******REMOVED***
        >>> x.min(***REMOVED***
        -11
        >>> x.min(0***REMOVED***
        matrix([[ -8,  -9, -10, -11***REMOVED******REMOVED******REMOVED***
        >>> x.min(1***REMOVED***
        matrix([[ -3***REMOVED***,
                [ -7***REMOVED***,
                [-11***REMOVED******REMOVED******REMOVED***

        ***REMOVED***
        return N.ndarray.min(self, axis, out, keepdims=True***REMOVED***._collapse(axis***REMOVED***

    def argmin(self, axis=None, out=None***REMOVED***:
        ***REMOVED***
        Indexes of the minimum values along an axis.

        Return the indexes of the first occurrences of the minimum values
        along the specified axis.  If axis is None, the index is for the
        flattened matrix.

        Parameters
        ----------
        See `numpy.argmin` for complete descriptions.

        See Also
        --------
        numpy.argmin

        Notes
        -----
        This is the same as `ndarray.argmin`, but returns a `matrix` object
        where `ndarray.argmin` would return an `ndarray`.

        Examples
        --------
        >>> x = -np.matrix(np.arange(12***REMOVED***.reshape((3,4***REMOVED******REMOVED******REMOVED***; x
        matrix([[  0,  -1,  -2,  -3***REMOVED***,
                [ -4,  -5,  -6,  -7***REMOVED***,
                [ -8,  -9, -10, -11***REMOVED******REMOVED******REMOVED***
        >>> x.argmin(***REMOVED***
        11
        >>> x.argmin(0***REMOVED***
        matrix([[2, 2, 2, 2***REMOVED******REMOVED******REMOVED***
        >>> x.argmin(1***REMOVED***
        matrix([[3***REMOVED***,
                [3***REMOVED***,
                [3***REMOVED******REMOVED******REMOVED***

        ***REMOVED***
        return N.ndarray.argmin(self, axis, out***REMOVED***._align(axis***REMOVED***

    def ptp(self, axis=None, out=None***REMOVED***:
        ***REMOVED***
        Peak-to-peak (maximum - minimum***REMOVED*** value along the given axis.

        Refer to `numpy.ptp` for full documentation.

        See Also
        --------
        numpy.ptp

        Notes
        -----
        Same as `ndarray.ptp`, except, where that would return an `ndarray` object,
        this returns a `matrix` object.

        Examples
        --------
        >>> x = np.matrix(np.arange(12***REMOVED***.reshape((3,4***REMOVED******REMOVED******REMOVED***; x
        matrix([[ 0,  1,  2,  3***REMOVED***,
                [ 4,  5,  6,  7***REMOVED***,
                [ 8,  9, 10, 11***REMOVED******REMOVED******REMOVED***
        >>> x.ptp(***REMOVED***
        11
        >>> x.ptp(0***REMOVED***
        matrix([[8, 8, 8, 8***REMOVED******REMOVED******REMOVED***
        >>> x.ptp(1***REMOVED***
        matrix([[3***REMOVED***,
                [3***REMOVED***,
                [3***REMOVED******REMOVED******REMOVED***

        ***REMOVED***
        return N.ndarray.ptp(self, axis, out***REMOVED***._align(axis***REMOVED***

    def getI(self***REMOVED***:
        ***REMOVED***
        Returns the (multiplicative***REMOVED*** inverse of invertible `self`.

        Parameters
        ----------
        None

        Returns
        -------
        ret : matrix object
            If `self` is non-singular, `ret` is such that ``ret * self`` ==
            ``self * ret`` == ``np.matrix(np.eye(self[0,:***REMOVED***.size***REMOVED***`` all return
            ``True``.

        Raises
        ------
        numpy.linalg.LinAlgError: Singular matrix
            If `self` is singular.

        See Also
        --------
        linalg.inv

        Examples
        --------
        >>> m = np.matrix('[1, 2; 3, 4***REMOVED***'***REMOVED***; m
        matrix([[1, 2***REMOVED***,
                [3, 4***REMOVED******REMOVED******REMOVED***
        >>> m.getI(***REMOVED***
        matrix([[-2. ,  1. ***REMOVED***,
                [ 1.5, -0.5***REMOVED******REMOVED******REMOVED***
        >>> m.getI(***REMOVED*** * m
        matrix([[ 1.,  0.***REMOVED***,
                [ 0.,  1.***REMOVED******REMOVED******REMOVED***

        ***REMOVED***
        M, N = self.shape
        if M == N:
            from numpy.dual import inv as func
        else:
            from numpy.dual import pinv as func
        return asmatrix(func(self***REMOVED******REMOVED***

    def getA(self***REMOVED***:
        ***REMOVED***
        Return `self` as an `ndarray` object.

        Equivalent to ``np.asarray(self***REMOVED***``.

        Parameters
        ----------
        None

        Returns
        -------
        ret : ndarray
            `self` as an `ndarray`

        Examples
        --------
        >>> x = np.matrix(np.arange(12***REMOVED***.reshape((3,4***REMOVED******REMOVED******REMOVED***; x
        matrix([[ 0,  1,  2,  3***REMOVED***,
                [ 4,  5,  6,  7***REMOVED***,
                [ 8,  9, 10, 11***REMOVED******REMOVED******REMOVED***
        >>> x.getA(***REMOVED***
        array([[ 0,  1,  2,  3***REMOVED***,
               [ 4,  5,  6,  7***REMOVED***,
               [ 8,  9, 10, 11***REMOVED******REMOVED******REMOVED***

        ***REMOVED***
        return self.__array__(***REMOVED***

    def getA1(self***REMOVED***:
        ***REMOVED***
        Return `self` as a flattened `ndarray`.

        Equivalent to ``np.asarray(x***REMOVED***.ravel(***REMOVED***``

        Parameters
        ----------
        None

        Returns
        -------
        ret : ndarray
            `self`, 1-D, as an `ndarray`

        Examples
        --------
        >>> x = np.matrix(np.arange(12***REMOVED***.reshape((3,4***REMOVED******REMOVED******REMOVED***; x
        matrix([[ 0,  1,  2,  3***REMOVED***,
                [ 4,  5,  6,  7***REMOVED***,
                [ 8,  9, 10, 11***REMOVED******REMOVED******REMOVED***
        >>> x.getA1(***REMOVED***
        array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11***REMOVED******REMOVED***

        ***REMOVED***
        return self.__array__(***REMOVED***.ravel(***REMOVED***


    def ravel(self, order='C'***REMOVED***:
        ***REMOVED***
        Return a flattened matrix.

        Refer to `numpy.ravel` for more documentation.

        Parameters
        ----------
        order : {'C', 'F', 'A', 'K'***REMOVED***, optional
            The elements of `m` are read using this index order. 'C' means to
            index the elements in C-like order, with the last axis index
            changing fastest, back to the first axis index changing slowest.
            'F' means to index the elements in Fortran-like index order, with
            the first index changing fastest, and the last index changing
            slowest. Note that the 'C' and 'F' options take no account of the
            memory layout of the underlying array, and only refer to the order
            of axis indexing.  'A' means to read the elements in Fortran-like
            index order if `m` is Fortran *contiguous* in memory, C-like order
            otherwise.  'K' means to read the elements in the order they occur
            in memory, except for reversing the data when strides are negative.
            By default, 'C' index order is used.

        Returns
        -------
        ret : matrix
            Return the matrix flattened to shape `(1, N***REMOVED***` where `N`
            is the number of elements in the original matrix.
            A copy is made only if necessary.

        See Also
        --------
        matrix.flatten : returns a similar output matrix but always a copy
        matrix.flat : a flat iterator on the array.
        numpy.ravel : related function which returns an ndarray

        ***REMOVED***
        return N.ndarray.ravel(self, order=order***REMOVED***


    def getT(self***REMOVED***:
        ***REMOVED***
        Returns the transpose of the matrix.

        Does *not* conjugate!  For the complex conjugate transpose, use ``.H``.

        Parameters
        ----------
        None

        Returns
        -------
        ret : matrix object
            The (non-conjugated***REMOVED*** transpose of the matrix.

        See Also
        --------
        transpose, getH

        Examples
        --------
        >>> m = np.matrix('[1, 2; 3, 4***REMOVED***'***REMOVED***
        >>> m
        matrix([[1, 2***REMOVED***,
                [3, 4***REMOVED******REMOVED******REMOVED***
        >>> m.getT(***REMOVED***
        matrix([[1, 3***REMOVED***,
                [2, 4***REMOVED******REMOVED******REMOVED***

        ***REMOVED***
        return self.transpose(***REMOVED***

    def getH(self***REMOVED***:
        ***REMOVED***
        Returns the (complex***REMOVED*** conjugate transpose of `self`.

        Equivalent to ``np.transpose(self***REMOVED***`` if `self` is real-valued.

        Parameters
        ----------
        None

        Returns
        -------
        ret : matrix object
            complex conjugate transpose of `self`

        Examples
        --------
        >>> x = np.matrix(np.arange(12***REMOVED***.reshape((3,4***REMOVED******REMOVED******REMOVED***
        >>> z = x - 1j*x; z
        matrix([[  0. +0.j,   1. -1.j,   2. -2.j,   3. -3.j***REMOVED***,
                [  4. -4.j,   5. -5.j,   6. -6.j,   7. -7.j***REMOVED***,
                [  8. -8.j,   9. -9.j,  10.-10.j,  11.-11.j***REMOVED******REMOVED******REMOVED***
        >>> z.getH(***REMOVED***
        matrix([[  0. +0.j,   4. +4.j,   8. +8.j***REMOVED***,
                [  1. +1.j,   5. +5.j,   9. +9.j***REMOVED***,
                [  2. +2.j,   6. +6.j,  10.+10.j***REMOVED***,
                [  3. +3.j,   7. +7.j,  11.+11.j***REMOVED******REMOVED******REMOVED***

        ***REMOVED***
        if issubclass(self.dtype.type, N.complexfloating***REMOVED***:
            return self.transpose(***REMOVED***.conjugate(***REMOVED***
        else:
            return self.transpose(***REMOVED***

    T = property(getT, None***REMOVED***
    A = property(getA, None***REMOVED***
    A1 = property(getA1, None***REMOVED***
    H = property(getH, None***REMOVED***
    I = property(getI, None***REMOVED***

def _from_string(str, gdict, ldict***REMOVED***:
    rows = str.split(';'***REMOVED***
    rowtup = [***REMOVED***
    for row in rows:
        trow = row.split(','***REMOVED***
        newrow = [***REMOVED***
        for x in trow:
            newrow.extend(x.split(***REMOVED******REMOVED***
        trow = newrow
        coltup = [***REMOVED***
        for col in trow:
            col = col.strip(***REMOVED***
            ***REMOVED***
                thismat = ldict[col***REMOVED***
            except KeyError:
                ***REMOVED***
                    thismat = gdict[col***REMOVED***
                except KeyError:
                    raise KeyError("%s not found" % (col,***REMOVED******REMOVED***

            coltup.append(thismat***REMOVED***
        rowtup.append(concatenate(coltup, axis=-1***REMOVED******REMOVED***
    return concatenate(rowtup, axis=0***REMOVED***


def bmat(obj, ldict=None, gdict=None***REMOVED***:
    ***REMOVED***
    Build a matrix object from a string, nested sequence, or array.

    Parameters
    ----------
    obj : str or array_like
        Input data.  Names of variables in the current scope may be
        referenced, even if `obj` is a string.
    ldict : dict, optional
        A dictionary that replaces local operands in current frame.
        Ignored if `obj` is not a string or `gdict` is `None`.
    gdict : dict, optional
        A dictionary that replaces global operands in current frame.
        Ignored if `obj` is not a string.

    Returns
    -------
    out : matrix
        Returns a matrix object, which is a specialized 2-D array.

    See Also
    --------
    matrix

    Examples
    --------
    >>> A = np.mat('1 1; 1 1'***REMOVED***
    >>> B = np.mat('2 2; 2 2'***REMOVED***
    >>> C = np.mat('3 4; 5 6'***REMOVED***
    >>> D = np.mat('7 8; 9 0'***REMOVED***

    All the following expressions construct the same block matrix:

    >>> np.bmat([[A, B***REMOVED***, [C, D***REMOVED******REMOVED******REMOVED***
    matrix([[1, 1, 2, 2***REMOVED***,
            [1, 1, 2, 2***REMOVED***,
            [3, 4, 7, 8***REMOVED***,
            [5, 6, 9, 0***REMOVED******REMOVED******REMOVED***
    >>> np.bmat(np.r_[np.c_[A, B***REMOVED***, np.c_[C, D***REMOVED******REMOVED******REMOVED***
    matrix([[1, 1, 2, 2***REMOVED***,
            [1, 1, 2, 2***REMOVED***,
            [3, 4, 7, 8***REMOVED***,
            [5, 6, 9, 0***REMOVED******REMOVED******REMOVED***
    >>> np.bmat('A,B; C,D'***REMOVED***
    matrix([[1, 1, 2, 2***REMOVED***,
            [1, 1, 2, 2***REMOVED***,
            [3, 4, 7, 8***REMOVED***,
            [5, 6, 9, 0***REMOVED******REMOVED******REMOVED***

    ***REMOVED***
    if isinstance(obj, str***REMOVED***:
        if gdict is None:
            # get previous frame
            frame = sys._getframe(***REMOVED***.f_back
            glob_dict = frame.f_globals
            loc_dict = frame.f_locals
        else:
            glob_dict = gdict
            loc_dict = ldict

        return matrix(_from_string(obj, glob_dict, loc_dict***REMOVED******REMOVED***

    if isinstance(obj, (tuple, list***REMOVED******REMOVED***:
        # [[A,B***REMOVED***,[C,D***REMOVED******REMOVED***
        arr_rows = [***REMOVED***
        for row in obj:
            if isinstance(row, N.ndarray***REMOVED***:  # not 2-d
                return matrix(concatenate(obj, axis=-1***REMOVED******REMOVED***
            else:
                arr_rows.append(concatenate(row, axis=-1***REMOVED******REMOVED***
        return matrix(concatenate(arr_rows, axis=0***REMOVED******REMOVED***
    if isinstance(obj, N.ndarray***REMOVED***:
        return matrix(obj***REMOVED***

mat = asmatrix
