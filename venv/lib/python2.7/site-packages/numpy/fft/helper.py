***REMOVED***
Discrete Fourier Transforms - helper.py

***REMOVED***
from __future__ import division, absolute_import, print_function

from numpy.compat import integer_types
from numpy.core import (
        asarray, concatenate, arange, take, integer, empty
        ***REMOVED***

# Created by Pearu Peterson, September 2002

__all__ = ['fftshift', 'ifftshift', 'fftfreq', 'rfftfreq'***REMOVED***

integer_types = integer_types + (integer,***REMOVED***


def fftshift(x, axes=None***REMOVED***:
    ***REMOVED***
    Shift the zero-frequency component to the center of the spectrum.

    This function swaps half-spaces for all axes listed (defaults to all***REMOVED***.
    Note that ``y[0***REMOVED***`` is the Nyquist component only if ``len(x***REMOVED***`` is even.

    Parameters
    ----------
    x : array_like
        Input array.
    axes : int or shape tuple, optional
        Axes over which to shift.  Default is None, which shifts all axes.

    Returns
    -------
    y : ndarray
        The shifted array.

    See Also
    --------
    ifftshift : The inverse of `fftshift`.

    Examples
    --------
    >>> freqs = np.fft.fftfreq(10, 0.1***REMOVED***
    >>> freqs
    array([ 0.,  1.,  2.,  3.,  4., -5., -4., -3., -2., -1.***REMOVED******REMOVED***
    >>> np.fft.fftshift(freqs***REMOVED***
    array([-5., -4., -3., -2., -1.,  0.,  1.,  2.,  3.,  4.***REMOVED******REMOVED***

    Shift the zero-frequency component only along the second axis:

    >>> freqs = np.fft.fftfreq(9, d=1./9***REMOVED***.reshape(3, 3***REMOVED***
    >>> freqs
    array([[ 0.,  1.,  2.***REMOVED***,
           [ 3.,  4., -4.***REMOVED***,
           [-3., -2., -1.***REMOVED******REMOVED******REMOVED***
    >>> np.fft.fftshift(freqs, axes=(1,***REMOVED******REMOVED***
    array([[ 2.,  0.,  1.***REMOVED***,
           [-4.,  3.,  4.***REMOVED***,
           [-1., -3., -2.***REMOVED******REMOVED******REMOVED***

    ***REMOVED***
    tmp = asarray(x***REMOVED***
    ndim = len(tmp.shape***REMOVED***
    if axes is None:
        axes = list(range(ndim***REMOVED******REMOVED***
    elif isinstance(axes, integer_types***REMOVED***:
        axes = (axes,***REMOVED***
    y = tmp
    for k in axes:
        n = tmp.shape[k***REMOVED***
        p2 = (n+1***REMOVED***//2
        mylist = concatenate((arange(p2, n***REMOVED***, arange(p2***REMOVED******REMOVED******REMOVED***
        y = take(y, mylist, k***REMOVED***
    return y


def ifftshift(x, axes=None***REMOVED***:
    ***REMOVED***
    The inverse of `fftshift`. Although identical for even-length `x`, the
    functions differ by one sample for odd-length `x`.

    Parameters
    ----------
    x : array_like
        Input array.
    axes : int or shape tuple, optional
        Axes over which to calculate.  Defaults to None, which shifts all axes.

    Returns
    -------
    y : ndarray
        The shifted array.

    See Also
    --------
    fftshift : Shift zero-frequency component to the center of the spectrum.

    Examples
    --------
    >>> freqs = np.fft.fftfreq(9, d=1./9***REMOVED***.reshape(3, 3***REMOVED***
    >>> freqs
    array([[ 0.,  1.,  2.***REMOVED***,
           [ 3.,  4., -4.***REMOVED***,
           [-3., -2., -1.***REMOVED******REMOVED******REMOVED***
    >>> np.fft.ifftshift(np.fft.fftshift(freqs***REMOVED******REMOVED***
    array([[ 0.,  1.,  2.***REMOVED***,
           [ 3.,  4., -4.***REMOVED***,
           [-3., -2., -1.***REMOVED******REMOVED******REMOVED***

    ***REMOVED***
    tmp = asarray(x***REMOVED***
    ndim = len(tmp.shape***REMOVED***
    if axes is None:
        axes = list(range(ndim***REMOVED******REMOVED***
    elif isinstance(axes, integer_types***REMOVED***:
        axes = (axes,***REMOVED***
    y = tmp
    for k in axes:
        n = tmp.shape[k***REMOVED***
        p2 = n-(n+1***REMOVED***//2
        mylist = concatenate((arange(p2, n***REMOVED***, arange(p2***REMOVED******REMOVED******REMOVED***
        y = take(y, mylist, k***REMOVED***
    return y


def fftfreq(n, d=1.0***REMOVED***:
    ***REMOVED***
    Return the Discrete Fourier Transform sample frequencies.

    The returned float array `f` contains the frequency bin centers in cycles
    per unit of the sample spacing (with zero at the start***REMOVED***.  For instance, if
    the sample spacing is in seconds, then the frequency unit is cycles/second.

    Given a window length `n` and a sample spacing `d`::

      f = [0, 1, ...,   n/2-1,     -n/2, ..., -1***REMOVED*** / (d*n***REMOVED***   if n is even
      f = [0, 1, ..., (n-1***REMOVED***/2, -(n-1***REMOVED***/2, ..., -1***REMOVED*** / (d*n***REMOVED***   if n is odd

    Parameters
    ----------
    n : int
        Window length.
    d : scalar, optional
        Sample spacing (inverse of the sampling rate***REMOVED***. Defaults to 1.

    Returns
    -------
    f : ndarray
        Array of length `n` containing the sample frequencies.

    Examples
    --------
    >>> signal = np.array([-2, 8, 6, 4, 1, 0, 3, 5***REMOVED***, dtype=float***REMOVED***
    >>> fourier = np.fft.fft(signal***REMOVED***
    >>> n = signal.size
    >>> timestep = 0.1
    >>> freq = np.fft.fftfreq(n, d=timestep***REMOVED***
    >>> freq
    array([ 0.  ,  1.25,  2.5 ,  3.75, -5.  , -3.75, -2.5 , -1.25***REMOVED******REMOVED***

    ***REMOVED***
    if not isinstance(n, integer_types***REMOVED***:
        raise ValueError("n should be an integer"***REMOVED***
    val = 1.0 / (n * d***REMOVED***
    results = empty(n, int***REMOVED***
    N = (n-1***REMOVED***//2 + 1
    p1 = arange(0, N, dtype=int***REMOVED***
    results[:N***REMOVED*** = p1
    p2 = arange(-(n//2***REMOVED***, 0, dtype=int***REMOVED***
    results[N:***REMOVED*** = p2
    return results * val
    #return hstack((arange(0,(n-1***REMOVED***/2 + 1***REMOVED***, arange(-(n/2***REMOVED***,0***REMOVED******REMOVED******REMOVED*** / (n*d***REMOVED***


def rfftfreq(n, d=1.0***REMOVED***:
    ***REMOVED***
    Return the Discrete Fourier Transform sample frequencies
    (for usage with rfft, irfft***REMOVED***.

    The returned float array `f` contains the frequency bin centers in cycles
    per unit of the sample spacing (with zero at the start***REMOVED***.  For instance, if
    the sample spacing is in seconds, then the frequency unit is cycles/second.

    Given a window length `n` and a sample spacing `d`::

      f = [0, 1, ...,     n/2-1,     n/2***REMOVED*** / (d*n***REMOVED***   if n is even
      f = [0, 1, ..., (n-1***REMOVED***/2-1, (n-1***REMOVED***/2***REMOVED*** / (d*n***REMOVED***   if n is odd

    Unlike `fftfreq` (but like `scipy.fftpack.rfftfreq`***REMOVED***
    the Nyquist frequency component is considered to be positive.

    Parameters
    ----------
    n : int
        Window length.
    d : scalar, optional
        Sample spacing (inverse of the sampling rate***REMOVED***. Defaults to 1.

    Returns
    -------
    f : ndarray
        Array of length ``n//2 + 1`` containing the sample frequencies.

    Examples
    --------
    >>> signal = np.array([-2, 8, 6, 4, 1, 0, 3, 5, -3, 4***REMOVED***, dtype=float***REMOVED***
    >>> fourier = np.fft.rfft(signal***REMOVED***
    >>> n = signal.size
    >>> sample_rate = 100
    >>> freq = np.fft.fftfreq(n, d=1./sample_rate***REMOVED***
    >>> freq
    array([  0.,  10.,  20.,  30.,  40., -50., -40., -30., -20., -10.***REMOVED******REMOVED***
    >>> freq = np.fft.rfftfreq(n, d=1./sample_rate***REMOVED***
    >>> freq
    array([  0.,  10.,  20.,  30.,  40.,  50.***REMOVED******REMOVED***

    ***REMOVED***
    if not isinstance(n, integer_types***REMOVED***:
        raise ValueError("n should be an integer"***REMOVED***
    val = 1.0/(n*d***REMOVED***
    N = n//2 + 1
    results = arange(0, N, dtype=int***REMOVED***
    return results * val
