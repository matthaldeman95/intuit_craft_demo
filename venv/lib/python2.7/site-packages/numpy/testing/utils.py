***REMOVED***
Utility function to facilitate testing.

***REMOVED***
from __future__ import division, absolute_import, print_function

***REMOVED***
import sys
import re
import operator
import warnings
from functools import partial
import shutil
import contextlib
from tempfile import mkdtemp, mkstemp

from .nosetester import import_nose
from numpy.core import float32, empty, arange, array_repr, ndarray
from numpy.lib.utils import deprecate

if sys.version_info[0***REMOVED*** >= 3:
    from io import StringIO
else:
    from StringIO import StringIO

__all__ = ['assert_equal', 'assert_almost_equal', 'assert_approx_equal',
           'assert_array_equal', 'assert_array_less', 'assert_string_equal',
           'assert_array_almost_equal', 'assert_raises', 'build_err_msg',
           'decorate_methods', 'jiffies', 'memusage', 'print_assert_equal',
           'raises', 'rand', 'rundocs', 'runstring', 'verbose', 'measure',
           'assert_', 'assert_array_almost_equal_nulp', 'assert_raises_regex',
           'assert_array_max_ulp', 'assert_warns', 'assert_no_warnings',
           'assert_allclose', 'IgnoreException', 'clear_and_catch_warnings',
           'SkipTest', 'KnownFailureException', 'temppath', 'tempdir'***REMOVED***


class KnownFailureException(Exception***REMOVED***:
    '''Raise this exception to mark a test as a known failing test.'''
    pass

KnownFailureTest = KnownFailureException  # backwards compat


# nose.SkipTest is unittest.case.SkipTest
# import it into the namespace, so that it's available as np.testing.SkipTest
***REMOVED***
    from unittest.case import SkipTest
except ImportError:
    # on py2.6 unittest.case is not available. Ask nose for a replacement.
    ***REMOVED***
        import nose
        SkipTest = nose.SkipTest
    except (ImportError, AttributeError***REMOVED***:
        # If nose is not available, testing won't work anyway,
        # but we need something to import in numpy/testing/decorators.py.
        # See gh-7498.
        SkipTest = None

verbose = 0

def assert_(val, msg=''***REMOVED***:
    ***REMOVED***
    Assert that works in release mode.
    Accepts callable msg to allow deferring evaluation until failure.

    The Python built-in ``assert`` does not work when executing code in
    optimized mode (the ``-O`` flag***REMOVED*** - no byte-code is generated for it.

    For documentation on usage, refer to the Python documentation.

    ***REMOVED***
    if not val:
        ***REMOVED***
            smsg = msg(***REMOVED***
        except TypeError:
            smsg = msg
        raise AssertionError(smsg***REMOVED***

def gisnan(x***REMOVED***:
    ***REMOVED***like isnan, but always raise an error if type not supported instead of
    returning a TypeError object.

    Notes
    -----
    isnan and other ufunc sometimes return a NotImplementedType object instead
    of raising any exception. This function is a wrapper to make sure an
    exception is always raised.

    This should be removed once this problem is solved at the Ufunc level.***REMOVED***
    from numpy.core import isnan
    st = isnan(x***REMOVED***
    if isinstance(st, type(NotImplemented***REMOVED******REMOVED***:
        raise TypeError("isnan not supported for this type"***REMOVED***
    return st

def gisfinite(x***REMOVED***:
    ***REMOVED***like isfinite, but always raise an error if type not supported instead of
    returning a TypeError object.

    Notes
    -----
    isfinite and other ufunc sometimes return a NotImplementedType object instead
    of raising any exception. This function is a wrapper to make sure an
    exception is always raised.

    This should be removed once this problem is solved at the Ufunc level.***REMOVED***
    from numpy.core import isfinite, errstate
    with errstate(invalid='ignore'***REMOVED***:
        st = isfinite(x***REMOVED***
        if isinstance(st, type(NotImplemented***REMOVED******REMOVED***:
            raise TypeError("isfinite not supported for this type"***REMOVED***
    return st

def gisinf(x***REMOVED***:
    ***REMOVED***like isinf, but always raise an error if type not supported instead of
    returning a TypeError object.

    Notes
    -----
    isinf and other ufunc sometimes return a NotImplementedType object instead
    of raising any exception. This function is a wrapper to make sure an
    exception is always raised.

    This should be removed once this problem is solved at the Ufunc level.***REMOVED***
    from numpy.core import isinf, errstate
    with errstate(invalid='ignore'***REMOVED***:
        st = isinf(x***REMOVED***
        if isinstance(st, type(NotImplemented***REMOVED******REMOVED***:
            raise TypeError("isinf not supported for this type"***REMOVED***
    return st

@deprecate(message="numpy.testing.rand is deprecated in numpy 1.11. "
                   "Use numpy.random.rand instead."***REMOVED***
def rand(*args***REMOVED***:
    ***REMOVED***Returns an array of random numbers with the given shape.

    This only uses the standard library, so it is useful for testing purposes.
    ***REMOVED***
    import random
    from numpy.core import zeros, float64
    results = zeros(args, float64***REMOVED***
    f = results.flat
    for i in range(len(f***REMOVED******REMOVED***:
        f[i***REMOVED*** = random.random(***REMOVED***
    return results

if os.name == 'nt':
    # Code "stolen" from enthought/debug/memusage.py
    def GetPerformanceAttributes(object, counter, instance=None,
                                 inum=-1, format=None, machine=None***REMOVED***:
        # NOTE: Many counters require 2 samples to give accurate results,
        # including "% Processor Time" (as by definition, at any instant, a
        # thread's CPU usage is either 0 or 100***REMOVED***.  To read counters like this,
        # you should copy this function, but keep the counter open, and call
        # CollectQueryData(***REMOVED*** each time you need to know.
        # See http://msdn.microsoft.com/library/en-us/dnperfmo/html/perfmonpt2.asp
        # My older explanation for this was that the "AddCounter" process forced
        # the CPU to 100%, but the above makes more sense :***REMOVED***
        import win32pdh
        if format is None:
            format = win32pdh.PDH_FMT_LONG
        path = win32pdh.MakeCounterPath( (machine, object, instance, None, inum, counter***REMOVED******REMOVED***
        hq = win32pdh.OpenQuery(***REMOVED***
        ***REMOVED***
            hc = win32pdh.AddCounter(hq, path***REMOVED***
            ***REMOVED***
                win32pdh.CollectQueryData(hq***REMOVED***
                type, val = win32pdh.GetFormattedCounterValue(hc, format***REMOVED***
                return val
            finally:
                win32pdh.RemoveCounter(hc***REMOVED***
        finally:
            win32pdh.CloseQuery(hq***REMOVED***

    def memusage(processName="python", instance=0***REMOVED***:
        # from win32pdhutil, part of the win32all package
        import win32pdh
        return GetPerformanceAttributes("Process", "Virtual Bytes",
                                        processName, instance,
                                        win32pdh.PDH_FMT_LONG, None***REMOVED***
elif sys.platform[:5***REMOVED*** == 'linux':

    def memusage(_proc_pid_stat='/proc/%s/stat' % (os.getpid(***REMOVED******REMOVED******REMOVED***:
        ***REMOVED***
        Return virtual memory size in bytes of the running python.

        ***REMOVED***
        ***REMOVED***
            f = open(_proc_pid_stat, 'r'***REMOVED***
            l = f.readline(***REMOVED***.split(' '***REMOVED***
            f.close(***REMOVED***
            return int(l[22***REMOVED******REMOVED***
        ***REMOVED***
            return
else:
    def memusage(***REMOVED***:
        ***REMOVED***
        Return memory usage of running python. [Not implemented***REMOVED***

        ***REMOVED***
        raise NotImplementedError


if sys.platform[:5***REMOVED*** == 'linux':
    def jiffies(_proc_pid_stat='/proc/%s/stat' % (os.getpid(***REMOVED******REMOVED***,
                _load_time=[***REMOVED******REMOVED***:
        ***REMOVED***
        Return number of jiffies elapsed.

        Return number of jiffies (1/100ths of a second***REMOVED*** that this
        process has been scheduled in user mode. See man 5 proc.

        ***REMOVED***
        import time
        if not _load_time:
            _load_time.append(time.time(***REMOVED******REMOVED***
        ***REMOVED***
            f = open(_proc_pid_stat, 'r'***REMOVED***
            l = f.readline(***REMOVED***.split(' '***REMOVED***
            f.close(***REMOVED***
            return int(l[13***REMOVED******REMOVED***
        ***REMOVED***
            return int(100*(time.time(***REMOVED***-_load_time[0***REMOVED******REMOVED******REMOVED***
else:
    # os.getpid is not in all platforms available.
    # Using time is safe but inaccurate, especially when process
    # was suspended or sleeping.
    def jiffies(_load_time=[***REMOVED******REMOVED***:
        ***REMOVED***
        Return number of jiffies elapsed.

        Return number of jiffies (1/100ths of a second***REMOVED*** that this
        process has been scheduled in user mode. See man 5 proc.

        ***REMOVED***
        import time
        if not _load_time:
            _load_time.append(time.time(***REMOVED******REMOVED***
        return int(100*(time.time(***REMOVED***-_load_time[0***REMOVED******REMOVED******REMOVED***


def build_err_msg(arrays, err_msg, header='Items are not equal:',
                  verbose=True, names=('ACTUAL', 'DESIRED'***REMOVED***, precision=8***REMOVED***:
    msg = ['\n' + header***REMOVED***
    if err_msg:
        if err_msg.find('\n'***REMOVED*** == -1 and len(err_msg***REMOVED*** < 79-len(header***REMOVED***:
            msg = [msg[0***REMOVED*** + ' ' + err_msg***REMOVED***
        else:
            msg.append(err_msg***REMOVED***
    if verbose:
        for i, a in enumerate(arrays***REMOVED***:

            if isinstance(a, ndarray***REMOVED***:
                # precision argument is only needed if the objects are ndarrays
                r_func = partial(array_repr, precision=precision***REMOVED***
            else:
                r_func = repr

            ***REMOVED***
                r = r_func(a***REMOVED***
            ***REMOVED***
                r = '[repr failed***REMOVED***'
            if r.count('\n'***REMOVED*** > 3:
                r = '\n'.join(r.splitlines(***REMOVED***[:3***REMOVED******REMOVED***
                r += '...'
            msg.append(' %s: %s' % (names[i***REMOVED***, r***REMOVED******REMOVED***
    return '\n'.join(msg***REMOVED***

def assert_equal(actual,desired,err_msg='',verbose=True***REMOVED***:
    ***REMOVED***
    Raises an AssertionError if two objects are not equal.

    Given two objects (scalars, lists, tuples, dictionaries or numpy arrays***REMOVED***,
    check that all elements of these objects are equal. An exception is raised
    at the first conflicting values.

    Parameters
    ----------
    actual : array_like
        The object to check.
    desired : array_like
        The expected object.
    err_msg : str, optional
        The error message to be printed in case of failure.
    verbose : bool, optional
        If True, the conflicting values are appended to the error message.

    Raises
    ------
    AssertionError
        If actual and desired are not equal.

    Examples
    --------
    >>> np.testing.assert_equal([4,5***REMOVED***, [4,6***REMOVED******REMOVED***
    ...
    <type 'exceptions.AssertionError'>:
    Items are not equal:
    item=1
     ACTUAL: 5
     DESIRED: 6

    ***REMOVED***
    __tracebackhide__ = True  # Hide traceback for py.test
    if isinstance(desired, dict***REMOVED***:
        if not isinstance(actual, dict***REMOVED***:
            raise AssertionError(repr(type(actual***REMOVED******REMOVED******REMOVED***
        assert_equal(len(actual***REMOVED***, len(desired***REMOVED***, err_msg, verbose***REMOVED***
        for k, i in desired.items(***REMOVED***:
            if k not in actual:
                raise AssertionError(repr(k***REMOVED******REMOVED***
            assert_equal(actual[k***REMOVED***, desired[k***REMOVED***, 'key=%r\n%s' % (k, err_msg***REMOVED***, verbose***REMOVED***
        return
    if isinstance(desired, (list, tuple***REMOVED******REMOVED*** and isinstance(actual, (list, tuple***REMOVED******REMOVED***:
        assert_equal(len(actual***REMOVED***, len(desired***REMOVED***, err_msg, verbose***REMOVED***
        for k in range(len(desired***REMOVED******REMOVED***:
            assert_equal(actual[k***REMOVED***, desired[k***REMOVED***, 'item=%r\n%s' % (k, err_msg***REMOVED***, verbose***REMOVED***
        return
    from numpy.core import ndarray, isscalar, signbit
    from numpy.lib import iscomplexobj, real, imag
    if isinstance(actual, ndarray***REMOVED*** or isinstance(desired, ndarray***REMOVED***:
        return assert_array_equal(actual, desired, err_msg, verbose***REMOVED***
    msg = build_err_msg([actual, desired***REMOVED***, err_msg, verbose=verbose***REMOVED***

    # Handle complex numbers: separate into real/imag to handle
    # nan/inf/negative zero correctly
    # XXX: catch ValueError for subclasses of ndarray where iscomplex fail
    ***REMOVED***
        usecomplex = iscomplexobj(actual***REMOVED*** or iscomplexobj(desired***REMOVED***
    except ValueError:
        usecomplex = False

    if usecomplex:
        if iscomplexobj(actual***REMOVED***:
            actualr = real(actual***REMOVED***
            actuali = imag(actual***REMOVED***
        else:
            actualr = actual
            actuali = 0
        if iscomplexobj(desired***REMOVED***:
            desiredr = real(desired***REMOVED***
            desiredi = imag(desired***REMOVED***
        else:
            desiredr = desired
            desiredi = 0
        ***REMOVED***
            assert_equal(actualr, desiredr***REMOVED***
            assert_equal(actuali, desiredi***REMOVED***
        except AssertionError:
            raise AssertionError(msg***REMOVED***

    # Inf/nan/negative zero handling
    ***REMOVED***
        # isscalar test to check cases such as [np.nan***REMOVED*** != np.nan
        if isscalar(desired***REMOVED*** != isscalar(actual***REMOVED***:
            raise AssertionError(msg***REMOVED***

        # If one of desired/actual is not finite, handle it specially here:
        # check that both are nan if any is a nan, and test for equality
        # otherwise
        if not (gisfinite(desired***REMOVED*** and gisfinite(actual***REMOVED******REMOVED***:
            isdesnan = gisnan(desired***REMOVED***
            isactnan = gisnan(actual***REMOVED***
            if isdesnan or isactnan:
                if not (isdesnan and isactnan***REMOVED***:
                    raise AssertionError(msg***REMOVED***
            else:
                if not desired == actual:
                    raise AssertionError(msg***REMOVED***
            return
        elif desired == 0 and actual == 0:
            if not signbit(desired***REMOVED*** == signbit(actual***REMOVED***:
                raise AssertionError(msg***REMOVED***
    # If TypeError or ValueError raised while using isnan and co, just handle
    # as before
    except (TypeError, ValueError, NotImplementedError***REMOVED***:
        pass

    # Explicitly use __eq__ for comparison, ticket #2552
    if not (desired == actual***REMOVED***:
        raise AssertionError(msg***REMOVED***

def print_assert_equal(test_string, actual, desired***REMOVED***:
    ***REMOVED***
    Test if two objects are equal, and print an error message if test fails.

    The test is performed with ``actual == desired``.

    Parameters
    ----------
    test_string : str
        The message supplied to AssertionError.
    actual : object
        The object to test for equality against `desired`.
    desired : object
        The expected result.

    Examples
    --------
    >>> np.testing.print_assert_equal('Test XYZ of func xyz', [0, 1***REMOVED***, [0, 1***REMOVED******REMOVED***
    >>> np.testing.print_assert_equal('Test XYZ of func xyz', [0, 1***REMOVED***, [0, 2***REMOVED******REMOVED***
    Traceback (most recent call last***REMOVED***:
    ...
    AssertionError: Test XYZ of func xyz failed
    ACTUAL:
    [0, 1***REMOVED***
    DESIRED:
    [0, 2***REMOVED***

    ***REMOVED***
    __tracebackhide__ = True  # Hide traceback for py.test
    import pprint

    if not (actual == desired***REMOVED***:
        msg = StringIO(***REMOVED***
        msg.write(test_string***REMOVED***
        msg.write(' failed\nACTUAL: \n'***REMOVED***
        pprint.pprint(actual, msg***REMOVED***
        msg.write('DESIRED: \n'***REMOVED***
        pprint.pprint(desired, msg***REMOVED***
        raise AssertionError(msg.getvalue(***REMOVED******REMOVED***

def assert_almost_equal(actual,desired,decimal=7,err_msg='',verbose=True***REMOVED***:
    ***REMOVED***
    Raises an AssertionError if two items are not equal up to desired
    precision.

    .. note:: It is recommended to use one of `assert_allclose`,
              `assert_array_almost_equal_nulp` or `assert_array_max_ulp`
              instead of this function for more consistent floating point
              comparisons.

    The test is equivalent to ``abs(desired-actual***REMOVED*** < 0.5 * 10**(-decimal***REMOVED***``.

    Given two objects (numbers or ndarrays***REMOVED***, check that all elements of these
    objects are almost equal. An exception is raised at conflicting values.
    For ndarrays this delegates to assert_array_almost_equal

    Parameters
    ----------
    actual : array_like
        The object to check.
    desired : array_like
        The expected object.
    decimal : int, optional
        Desired precision, default is 7.
    err_msg : str, optional
        The error message to be printed in case of failure.
    verbose : bool, optional
        If True, the conflicting values are appended to the error message.

    Raises
    ------
    AssertionError
      If actual and desired are not equal up to specified precision.

    See Also
    --------
    assert_allclose: Compare two array_like objects for equality with desired
                     relative and/or absolute precision.
    assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal

    Examples
    --------
    >>> import numpy.testing as npt
    >>> npt.assert_almost_equal(2.3333333333333, 2.33333334***REMOVED***
    >>> npt.assert_almost_equal(2.3333333333333, 2.33333334, decimal=10***REMOVED***
    ...
    <type 'exceptions.AssertionError'>:
    Items are not equal:
     ACTUAL: 2.3333333333333002
     DESIRED: 2.3333333399999998

    >>> npt.assert_almost_equal(np.array([1.0,2.3333333333333***REMOVED******REMOVED***,
    ...                         np.array([1.0,2.33333334***REMOVED******REMOVED***, decimal=9***REMOVED***
    ...
    <type 'exceptions.AssertionError'>:
    Arrays are not almost equal
    <BLANKLINE>
    (mismatch 50.0%***REMOVED***
     x: array([ 1.        ,  2.33333333***REMOVED******REMOVED***
     y: array([ 1.        ,  2.33333334***REMOVED******REMOVED***

    ***REMOVED***
    __tracebackhide__ = True  # Hide traceback for py.test
    from numpy.core import ndarray
    from numpy.lib import iscomplexobj, real, imag

    # Handle complex numbers: separate into real/imag to handle
    # nan/inf/negative zero correctly
    # XXX: catch ValueError for subclasses of ndarray where iscomplex fail
    ***REMOVED***
        usecomplex = iscomplexobj(actual***REMOVED*** or iscomplexobj(desired***REMOVED***
    except ValueError:
        usecomplex = False

    def _build_err_msg(***REMOVED***:
        header = ('Arrays are not almost equal to %d decimals' % decimal***REMOVED***
        return build_err_msg([actual, desired***REMOVED***, err_msg, verbose=verbose,
                             header=header***REMOVED***

    if usecomplex:
        if iscomplexobj(actual***REMOVED***:
            actualr = real(actual***REMOVED***
            actuali = imag(actual***REMOVED***
        else:
            actualr = actual
            actuali = 0
        if iscomplexobj(desired***REMOVED***:
            desiredr = real(desired***REMOVED***
            desiredi = imag(desired***REMOVED***
        else:
            desiredr = desired
            desiredi = 0
        ***REMOVED***
            assert_almost_equal(actualr, desiredr, decimal=decimal***REMOVED***
            assert_almost_equal(actuali, desiredi, decimal=decimal***REMOVED***
        except AssertionError:
            raise AssertionError(_build_err_msg(***REMOVED******REMOVED***

    if isinstance(actual, (ndarray, tuple, list***REMOVED******REMOVED*** \
            or isinstance(desired, (ndarray, tuple, list***REMOVED******REMOVED***:
        return assert_array_almost_equal(actual, desired, decimal, err_msg***REMOVED***
    ***REMOVED***
        # If one of desired/actual is not finite, handle it specially here:
        # check that both are nan if any is a nan, and test for equality
        # otherwise
        if not (gisfinite(desired***REMOVED*** and gisfinite(actual***REMOVED******REMOVED***:
            if gisnan(desired***REMOVED*** or gisnan(actual***REMOVED***:
                if not (gisnan(desired***REMOVED*** and gisnan(actual***REMOVED******REMOVED***:
                    raise AssertionError(_build_err_msg(***REMOVED******REMOVED***
            else:
                if not desired == actual:
                    raise AssertionError(_build_err_msg(***REMOVED******REMOVED***
            return
    except (NotImplementedError, TypeError***REMOVED***:
        pass
    if round(abs(desired - actual***REMOVED***, decimal***REMOVED*** != 0:
        raise AssertionError(_build_err_msg(***REMOVED******REMOVED***


def assert_approx_equal(actual,desired,significant=7,err_msg='',verbose=True***REMOVED***:
    ***REMOVED***
    Raises an AssertionError if two items are not equal up to significant
    digits.

    .. note:: It is recommended to use one of `assert_allclose`,
              `assert_array_almost_equal_nulp` or `assert_array_max_ulp`
              instead of this function for more consistent floating point
              comparisons.

    Given two numbers, check that they are approximately equal.
    Approximately equal is defined as the number of significant digits
    that agree.

    Parameters
    ----------
    actual : scalar
        The object to check.
    desired : scalar
        The expected object.
    significant : int, optional
        Desired precision, default is 7.
    err_msg : str, optional
        The error message to be printed in case of failure.
    verbose : bool, optional
        If True, the conflicting values are appended to the error message.

    Raises
    ------
    AssertionError
      If actual and desired are not equal up to specified precision.

    See Also
    --------
    assert_allclose: Compare two array_like objects for equality with desired
                     relative and/or absolute precision.
    assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal

    Examples
    --------
    >>> np.testing.assert_approx_equal(0.12345677777777e-20, 0.1234567e-20***REMOVED***
    >>> np.testing.assert_approx_equal(0.12345670e-20, 0.12345671e-20,
                                       significant=8***REMOVED***
    >>> np.testing.assert_approx_equal(0.12345670e-20, 0.12345672e-20,
                                       significant=8***REMOVED***
    ...
    <type 'exceptions.AssertionError'>:
    Items are not equal to 8 significant digits:
     ACTUAL: 1.234567e-021
     DESIRED: 1.2345672000000001e-021

    the evaluated condition that raises the exception is

    >>> abs(0.12345670e-20/1e-21 - 0.12345672e-20/1e-21***REMOVED*** >= 10**-(8-1***REMOVED***
    True

    ***REMOVED***
    __tracebackhide__ = True  # Hide traceback for py.test
    import numpy as np

    (actual, desired***REMOVED*** = map(float, (actual, desired***REMOVED******REMOVED***
    if desired == actual:
        return
    # Normalized the numbers to be in range (-10.0,10.0***REMOVED***
    # scale = float(pow(10,math.floor(math.log10(0.5*(abs(desired***REMOVED***+abs(actual***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***
    with np.errstate(invalid='ignore'***REMOVED***:
        scale = 0.5*(np.abs(desired***REMOVED*** + np.abs(actual***REMOVED******REMOVED***
        scale = np.power(10, np.floor(np.log10(scale***REMOVED******REMOVED******REMOVED***
    ***REMOVED***
        sc_desired = desired/scale
    except ZeroDivisionError:
        sc_desired = 0.0
    ***REMOVED***
        sc_actual = actual/scale
    except ZeroDivisionError:
        sc_actual = 0.0
    msg = build_err_msg([actual, desired***REMOVED***, err_msg,
                header='Items are not equal to %d significant digits:' %
                                 significant,
                verbose=verbose***REMOVED***
    ***REMOVED***
        # If one of desired/actual is not finite, handle it specially here:
        # check that both are nan if any is a nan, and test for equality
        # otherwise
        if not (gisfinite(desired***REMOVED*** and gisfinite(actual***REMOVED******REMOVED***:
            if gisnan(desired***REMOVED*** or gisnan(actual***REMOVED***:
                if not (gisnan(desired***REMOVED*** and gisnan(actual***REMOVED******REMOVED***:
                    raise AssertionError(msg***REMOVED***
            else:
                if not desired == actual:
                    raise AssertionError(msg***REMOVED***
            return
    except (TypeError, NotImplementedError***REMOVED***:
        pass
    if np.abs(sc_desired - sc_actual***REMOVED*** >= np.power(10., -(significant-1***REMOVED******REMOVED***:
        raise AssertionError(msg***REMOVED***

def assert_array_compare(comparison, x, y, err_msg='', verbose=True,
                         header='', precision=6***REMOVED***:
    __tracebackhide__ = True  # Hide traceback for py.test
    from numpy.core import array, isnan, isinf, any, all, inf
    x = array(x, copy=False, subok=True***REMOVED***
    y = array(y, copy=False, subok=True***REMOVED***

    def safe_comparison(*args, **kwargs***REMOVED***:
        # There are a number of cases where comparing two arrays hits special
        # cases in array_richcompare, specifically around strings and void
        # dtypes. Basically, we just can't do comparisons involving these
        # types, unless both arrays have exactly the *same* type. So
        # e.g. you can apply == to two string arrays, or two arrays with
        # identical structured dtypes. But if you compare a non-string array
        # to a string array, or two arrays with non-identical structured
        # dtypes, or anything like that, then internally stuff blows up.
        # Currently, when things blow up, we just return a scalar False or
        # True. But we also emit a DeprecationWarning, b/c eventually we
        # should raise an error here. (Ideally we might even make this work
        # properly, but since that will require rewriting a bunch of how
        # ufuncs work then we are not counting on that.***REMOVED***
        #
        # The point of this little function is to let the DeprecationWarning
        # pass (or maybe eventually catch the errors and return False, I
        # dunno, that's a little trickier and we can figure that out when the
        # time comes***REMOVED***.
        with warnings.catch_warnings(***REMOVED***:
            warnings.filterwarnings("ignore", category=DeprecationWarning***REMOVED***
            return comparison(*args, **kwargs***REMOVED***

    def isnumber(x***REMOVED***:
        return x.dtype.char in '?bhilqpBHILQPefdgFDG'

    def chk_same_position(x_id, y_id, hasval='nan'***REMOVED***:
        ***REMOVED***Handling nan/inf: check that x and y have the nan/inf at the same
        locations.***REMOVED***
        ***REMOVED***
            assert_array_equal(x_id, y_id***REMOVED***
        except AssertionError:
            msg = build_err_msg([x, y***REMOVED***,
                                err_msg + '\nx and y %s location mismatch:'
                                % (hasval***REMOVED***, verbose=verbose, header=header,
                                names=('x', 'y'***REMOVED***, precision=precision***REMOVED***
            raise AssertionError(msg***REMOVED***

    ***REMOVED***
        cond = (x.shape == (***REMOVED*** or y.shape == (***REMOVED******REMOVED*** or x.shape == y.shape
        if not cond:
            msg = build_err_msg([x, y***REMOVED***,
                                err_msg
                                + '\n(shapes %s, %s mismatch***REMOVED***' % (x.shape,
                                                                  y.shape***REMOVED***,
                                verbose=verbose, header=header,
                                names=('x', 'y'***REMOVED***, precision=precision***REMOVED***
            if not cond:
                raise AssertionError(msg***REMOVED***

        if isnumber(x***REMOVED*** and isnumber(y***REMOVED***:
            x_isnan, y_isnan = isnan(x***REMOVED***, isnan(y***REMOVED***
            x_isinf, y_isinf = isinf(x***REMOVED***, isinf(y***REMOVED***

            # Validate that the special values are in the same place
            if any(x_isnan***REMOVED*** or any(y_isnan***REMOVED***:
                chk_same_position(x_isnan, y_isnan, hasval='nan'***REMOVED***
            if any(x_isinf***REMOVED*** or any(y_isinf***REMOVED***:
                # Check +inf and -inf separately, since they are different
                chk_same_position(x == +inf, y == +inf, hasval='+inf'***REMOVED***
                chk_same_position(x == -inf, y == -inf, hasval='-inf'***REMOVED***

            # Combine all the special values
            x_id, y_id = x_isnan, y_isnan
            x_id |= x_isinf
            y_id |= y_isinf

            # Only do the comparison if actual values are left
            if all(x_id***REMOVED***:
                return

            if any(x_id***REMOVED***:
                val = safe_comparison(x[~x_id***REMOVED***, y[~y_id***REMOVED******REMOVED***
            else:
                val = safe_comparison(x, y***REMOVED***
        else:
            val = safe_comparison(x, y***REMOVED***

        if isinstance(val, bool***REMOVED***:
            cond = val
            reduced = [0***REMOVED***
        else:
            reduced = val.ravel(***REMOVED***
            cond = reduced.all(***REMOVED***
            reduced = reduced.tolist(***REMOVED***
        if not cond:
            match = 100-100.0*reduced.count(1***REMOVED***/len(reduced***REMOVED***
            msg = build_err_msg([x, y***REMOVED***,
                                err_msg
                                + '\n(mismatch %s%%***REMOVED***' % (match,***REMOVED***,
                                verbose=verbose, header=header,
                                names=('x', 'y'***REMOVED***, precision=precision***REMOVED***
            if not cond:
                raise AssertionError(msg***REMOVED***
    except ValueError:
        import traceback
        efmt = traceback.format_exc(***REMOVED***
        header = 'error during assertion:\n\n%s\n\n%s' % (efmt, header***REMOVED***

        msg = build_err_msg([x, y***REMOVED***, err_msg, verbose=verbose, header=header,
                            names=('x', 'y'***REMOVED***, precision=precision***REMOVED***
        raise ValueError(msg***REMOVED***

def assert_array_equal(x, y, err_msg='', verbose=True***REMOVED***:
    ***REMOVED***
    Raises an AssertionError if two array_like objects are not equal.

    Given two array_like objects, check that the shape is equal and all
    elements of these objects are equal. An exception is raised at
    shape mismatch or conflicting values. In contrast to the standard usage
    in numpy, NaNs are compared like numbers, no assertion is raised if
    both objects have NaNs in the same positions.

    The usual caution for verifying equality with floating point numbers is
    advised.

    Parameters
    ----------
    x : array_like
        The actual object to check.
    y : array_like
        The desired, expected object.
    err_msg : str, optional
        The error message to be printed in case of failure.
    verbose : bool, optional
        If True, the conflicting values are appended to the error message.

    Raises
    ------
    AssertionError
        If actual and desired objects are not equal.

    See Also
    --------
    assert_allclose: Compare two array_like objects for equality with desired
                     relative and/or absolute precision.
    assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal

    Examples
    --------
    The first assert does not raise an exception:

    >>> np.testing.assert_array_equal([1.0,2.33333,np.nan***REMOVED***,
    ...                               [np.exp(0***REMOVED***,2.33333, np.nan***REMOVED******REMOVED***

    Assert fails with numerical inprecision with floats:

    >>> np.testing.assert_array_equal([1.0,np.pi,np.nan***REMOVED***,
    ...                               [1, np.sqrt(np.pi***REMOVED*****2, np.nan***REMOVED******REMOVED***
    ...
    <type 'exceptions.ValueError'>:
    AssertionError:
    Arrays are not equal
    <BLANKLINE>
    (mismatch 50.0%***REMOVED***
     x: array([ 1.        ,  3.14159265,         NaN***REMOVED******REMOVED***
     y: array([ 1.        ,  3.14159265,         NaN***REMOVED******REMOVED***

    Use `assert_allclose` or one of the nulp (number of floating point values***REMOVED***
    functions for these cases instead:

    >>> np.testing.assert_allclose([1.0,np.pi,np.nan***REMOVED***,
    ...                            [1, np.sqrt(np.pi***REMOVED*****2, np.nan***REMOVED***,
    ...                            rtol=1e-10, atol=0***REMOVED***

    ***REMOVED***
    assert_array_compare(operator.__eq__, x, y, err_msg=err_msg,
                         verbose=verbose, header='Arrays are not equal'***REMOVED***

def assert_array_almost_equal(x, y, decimal=6, err_msg='', verbose=True***REMOVED***:
    ***REMOVED***
    Raises an AssertionError if two objects are not equal up to desired
    precision.

    .. note:: It is recommended to use one of `assert_allclose`,
              `assert_array_almost_equal_nulp` or `assert_array_max_ulp`
              instead of this function for more consistent floating point
              comparisons.

    The test verifies identical shapes and verifies values with
    ``abs(desired-actual***REMOVED*** < 0.5 * 10**(-decimal***REMOVED***``.

    Given two array_like objects, check that the shape is equal and all
    elements of these objects are almost equal. An exception is raised at
    shape mismatch or conflicting values. In contrast to the standard usage
    in numpy, NaNs are compared like numbers, no assertion is raised if
    both objects have NaNs in the same positions.

    Parameters
    ----------
    x : array_like
        The actual object to check.
    y : array_like
        The desired, expected object.
    decimal : int, optional
        Desired precision, default is 6.
    err_msg : str, optional
      The error message to be printed in case of failure.
    verbose : bool, optional
        If True, the conflicting values are appended to the error message.

    Raises
    ------
    AssertionError
        If actual and desired are not equal up to specified precision.

    See Also
    --------
    assert_allclose: Compare two array_like objects for equality with desired
                     relative and/or absolute precision.
    assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal

    Examples
    --------
    the first assert does not raise an exception

    >>> np.testing.assert_array_almost_equal([1.0,2.333,np.nan***REMOVED***,
                                             [1.0,2.333,np.nan***REMOVED******REMOVED***

    >>> np.testing.assert_array_almost_equal([1.0,2.33333,np.nan***REMOVED***,
    ...                                      [1.0,2.33339,np.nan***REMOVED***, decimal=5***REMOVED***
    ...
    <type 'exceptions.AssertionError'>:
    AssertionError:
    Arrays are not almost equal
    <BLANKLINE>
    (mismatch 50.0%***REMOVED***
     x: array([ 1.     ,  2.33333,      NaN***REMOVED******REMOVED***
     y: array([ 1.     ,  2.33339,      NaN***REMOVED******REMOVED***

    >>> np.testing.assert_array_almost_equal([1.0,2.33333,np.nan***REMOVED***,
    ...                                      [1.0,2.33333, 5***REMOVED***, decimal=5***REMOVED***
    <type 'exceptions.ValueError'>:
    ValueError:
    Arrays are not almost equal
     x: array([ 1.     ,  2.33333,      NaN***REMOVED******REMOVED***
     y: array([ 1.     ,  2.33333,  5.     ***REMOVED******REMOVED***

    ***REMOVED***
    __tracebackhide__ = True  # Hide traceback for py.test
    from numpy.core import around, number, float_, result_type, array
    from numpy.core.numerictypes import issubdtype
    from numpy.core.fromnumeric import any as npany

    def compare(x, y***REMOVED***:
        ***REMOVED***
            if npany(gisinf(x***REMOVED******REMOVED*** or npany( gisinf(y***REMOVED******REMOVED***:
                xinfid = gisinf(x***REMOVED***
                yinfid = gisinf(y***REMOVED***
                if not xinfid == yinfid:
                    return False
                # if one item, x and y is +- inf
                if x.size == y.size == 1:
                    return x == y
                x = x[~xinfid***REMOVED***
                y = y[~yinfid***REMOVED***
        except (TypeError, NotImplementedError***REMOVED***:
            pass

        # make sure y is an inexact type to avoid abs(MIN_INT***REMOVED***; will cause
        # casting of x later.
        dtype = result_type(y, 1.***REMOVED***
        y = array(y, dtype=dtype, copy=False, subok=True***REMOVED***
        z = abs(x-y***REMOVED***

        if not issubdtype(z.dtype, number***REMOVED***:
            z = z.astype(float_***REMOVED***  # handle object arrays

        return around(z, decimal***REMOVED*** <= 10.0**(-decimal***REMOVED***

    assert_array_compare(compare, x, y, err_msg=err_msg, verbose=verbose,
             header=('Arrays are not almost equal to %d decimals' % decimal***REMOVED***,
             precision=decimal***REMOVED***


def assert_array_less(x, y, err_msg='', verbose=True***REMOVED***:
    ***REMOVED***
    Raises an AssertionError if two array_like objects are not ordered by less
    than.

    Given two array_like objects, check that the shape is equal and all
    elements of the first object are strictly smaller than those of the
    second object. An exception is raised at shape mismatch or incorrectly
    ordered values. Shape mismatch does not raise if an object has zero
    dimension. In contrast to the standard usage in numpy, NaNs are
    compared, no assertion is raised if both objects have NaNs in the same
    positions.



    Parameters
    ----------
    x : array_like
      The smaller object to check.
    y : array_like
      The larger object to compare.
    err_msg : string
      The error message to be printed in case of failure.
    verbose : bool
        If True, the conflicting values are appended to the error message.

    Raises
    ------
    AssertionError
      If actual and desired objects are not equal.

    See Also
    --------
    assert_array_equal: tests objects for equality
    assert_array_almost_equal: test objects for equality up to precision



    Examples
    --------
    >>> np.testing.assert_array_less([1.0, 1.0, np.nan***REMOVED***, [1.1, 2.0, np.nan***REMOVED******REMOVED***
    >>> np.testing.assert_array_less([1.0, 1.0, np.nan***REMOVED***, [1, 2.0, np.nan***REMOVED******REMOVED***
    ...
    <type 'exceptions.ValueError'>:
    Arrays are not less-ordered
    (mismatch 50.0%***REMOVED***
     x: array([  1.,   1.,  NaN***REMOVED******REMOVED***
     y: array([  1.,   2.,  NaN***REMOVED******REMOVED***

    >>> np.testing.assert_array_less([1.0, 4.0***REMOVED***, 3***REMOVED***
    ...
    <type 'exceptions.ValueError'>:
    Arrays are not less-ordered
    (mismatch 50.0%***REMOVED***
     x: array([ 1.,  4.***REMOVED******REMOVED***
     y: array(3***REMOVED***

    >>> np.testing.assert_array_less([1.0, 2.0, 3.0***REMOVED***, [4***REMOVED******REMOVED***
    ...
    <type 'exceptions.ValueError'>:
    Arrays are not less-ordered
    (shapes (3,***REMOVED***, (1,***REMOVED*** mismatch***REMOVED***
     x: array([ 1.,  2.,  3.***REMOVED******REMOVED***
     y: array([4***REMOVED******REMOVED***

    ***REMOVED***
    __tracebackhide__ = True  # Hide traceback for py.test
    assert_array_compare(operator.__lt__, x, y, err_msg=err_msg,
                         verbose=verbose,
                         header='Arrays are not less-ordered'***REMOVED***

def runstring(astr, dict***REMOVED***:
    exec(astr, dict***REMOVED***

def assert_string_equal(actual, desired***REMOVED***:
    ***REMOVED***
    Test if two strings are equal.

    If the given strings are equal, `assert_string_equal` does nothing.
    If they are not equal, an AssertionError is raised, and the diff
    between the strings is shown.

    Parameters
    ----------
    actual : str
        The string to test for equality against the expected string.
    desired : str
        The expected string.

    Examples
    --------
    >>> np.testing.assert_string_equal('abc', 'abc'***REMOVED***
    >>> np.testing.assert_string_equal('abc', 'abcd'***REMOVED***
    Traceback (most recent call last***REMOVED***:
      File "<stdin>", line 1, in <module>
    ...
    AssertionError: Differences in strings:
    - abc+ abcd?    +

    ***REMOVED***
    # delay import of difflib to reduce startup time
    __tracebackhide__ = True  # Hide traceback for py.test
    import difflib

    if not isinstance(actual, str***REMOVED***:
        raise AssertionError(repr(type(actual***REMOVED******REMOVED******REMOVED***
    if not isinstance(desired, str***REMOVED***:
        raise AssertionError(repr(type(desired***REMOVED******REMOVED******REMOVED***
    if re.match(r'\A'+desired+r'\Z', actual, re.M***REMOVED***:
        return

    diff = list(difflib.Differ(***REMOVED***.compare(actual.splitlines(1***REMOVED***, desired.splitlines(1***REMOVED******REMOVED******REMOVED***
    diff_list = [***REMOVED***
    while diff:
        d1 = diff.pop(0***REMOVED***
        if d1.startswith('  '***REMOVED***:
            continue
        if d1.startswith('- '***REMOVED***:
            l = [d1***REMOVED***
            d2 = diff.pop(0***REMOVED***
            if d2.startswith('? '***REMOVED***:
                l.append(d2***REMOVED***
                d2 = diff.pop(0***REMOVED***
            if not d2.startswith('+ '***REMOVED***:
                raise AssertionError(repr(d2***REMOVED******REMOVED***
            l.append(d2***REMOVED***
            if diff:
                d3 = diff.pop(0***REMOVED***
                if d3.startswith('? '***REMOVED***:
                    l.append(d3***REMOVED***
                else:
                    diff.insert(0, d3***REMOVED***
            if re.match(r'\A'+d2[2:***REMOVED***+r'\Z', d1[2:***REMOVED******REMOVED***:
                continue
            diff_list.extend(l***REMOVED***
            continue
        raise AssertionError(repr(d1***REMOVED******REMOVED***
    if not diff_list:
        return
    msg = 'Differences in strings:\n%s' % (''.join(diff_list***REMOVED******REMOVED***.rstrip(***REMOVED***
    if actual != desired:
        raise AssertionError(msg***REMOVED***


def rundocs(filename=None, raise_on_error=True***REMOVED***:
    ***REMOVED***
    Run doctests found in the given file.

    By default `rundocs` raises an AssertionError on failure.

    Parameters
    ----------
    filename : str
        The path to the file for which the doctests are run.
    raise_on_error : bool
        Whether to raise an AssertionError when a doctest fails. Default is
        True.

    Notes
    -----
    The doctests can be run by the user/developer by adding the ``doctests``
    argument to the ``test(***REMOVED***`` call. For example, to run all tests (including
    doctests***REMOVED*** for `numpy.lib`:

    >>> np.lib.test(doctests=True***REMOVED*** #doctest: +SKIP
    ***REMOVED***
    from numpy.compat import npy_load_module
    import doctest
    if filename is None:
        f = sys._getframe(1***REMOVED***
        filename = f.f_globals['__file__'***REMOVED***
    name = os.path.splitext(os.path.basename(filename***REMOVED******REMOVED***[0***REMOVED***
    m = npy_load_module(name, filename***REMOVED***

    tests = doctest.DocTestFinder(***REMOVED***.find(m***REMOVED***
    runner = doctest.DocTestRunner(verbose=False***REMOVED***

    msg = [***REMOVED***
    if raise_on_error:
        out = lambda s: msg.append(s***REMOVED***
    else:
        out = None

    for test in tests:
        runner.run(test, out=out***REMOVED***

    if runner.failures > 0 and raise_on_error:
        raise AssertionError("Some doctests failed:\n%s" % "\n".join(msg***REMOVED******REMOVED***


def raises(*args,**kwargs***REMOVED***:
    nose = import_nose(***REMOVED***
    return nose.tools.raises(*args,**kwargs***REMOVED***


def assert_raises(*args,**kwargs***REMOVED***:
    ***REMOVED***
    assert_raises(exception_class, callable, *args, **kwargs***REMOVED***

    Fail unless an exception of class exception_class is thrown
    by callable when invoked with arguments args and keyword
    arguments kwargs. If a different type of exception is
    thrown, it will not be caught, and the test case will be
    deemed to have suffered an error, exactly as for an
    unexpected exception.

    Alternatively, `assert_raises` can be used as a context manager:

    >>> from numpy.testing import assert_raises
    >>> with assert_raises(ZeroDivisionError***REMOVED***:
    ...   1 / 0

    is equivalent to

    >>> def div(x, y***REMOVED***:
    ...    return x / y
    >>> assert_raises(ZeroDivisionError, div, 1, 0***REMOVED***

    ***REMOVED***
    __tracebackhide__ = True  # Hide traceback for py.test
    nose = import_nose(***REMOVED***
    return nose.tools.assert_raises(*args,**kwargs***REMOVED***


assert_raises_regex_impl = None


def assert_raises_regex(exception_class, expected_regexp,
                        callable_obj=None, *args, **kwargs***REMOVED***:
    ***REMOVED***
    Fail unless an exception of class exception_class and with message that
    matches expected_regexp is thrown by callable when invoked with arguments
    args and keyword arguments kwargs.

    Name of this function adheres to Python 3.2+ reference, but should work in
    all versions down to 2.6.

    ***REMOVED***
    __tracebackhide__ = True  # Hide traceback for py.test
    nose = import_nose(***REMOVED***

    global assert_raises_regex_impl
    if assert_raises_regex_impl is None:
        ***REMOVED***
            # Python 3.2+
            assert_raises_regex_impl = nose.tools.assert_raises_regex
        except AttributeError:
            ***REMOVED***
                # 2.7+
                assert_raises_regex_impl = nose.tools.assert_raises_regexp
            except AttributeError:
                # 2.6

                # This class is copied from Python2.7 stdlib almost verbatim
                class _AssertRaisesContext(object***REMOVED***:
                    ***REMOVED***A context manager used to implement TestCase.assertRaises* methods.***REMOVED***

                    def __init__(self, expected, expected_regexp=None***REMOVED***:
                        self.expected = expected
                        self.expected_regexp = expected_regexp

                    def failureException(self, msg***REMOVED***:
                        return AssertionError(msg***REMOVED***

                    def __enter__(self***REMOVED***:
                        return self

                    def __exit__(self, exc_type, exc_value, tb***REMOVED***:
                        if exc_type is None:
                            ***REMOVED***
                                exc_name = self.expected.__name__
                            except AttributeError:
                                exc_name = str(self.expected***REMOVED***
                            raise self.failureException(
                                "{0***REMOVED*** not raised".format(exc_name***REMOVED******REMOVED***
                        if not issubclass(exc_type, self.expected***REMOVED***:
                            # let unexpected exceptions pass through
                            return False
                        self.exception = exc_value  # store for later retrieval
                        if self.expected_regexp is None:
                            return True

                        expected_regexp = self.expected_regexp
                        if isinstance(expected_regexp, basestring***REMOVED***:
                            expected_regexp = re.compile(expected_regexp***REMOVED***
                        if not expected_regexp.search(str(exc_value***REMOVED******REMOVED***:
                            raise self.failureException(
                                '"%s" does not match "%s"' %
                                (expected_regexp.pattern, str(exc_value***REMOVED******REMOVED******REMOVED***
                        return True

                def impl(cls, regex, callable_obj, *a, **kw***REMOVED***:
                    mgr = _AssertRaisesContext(cls, regex***REMOVED***
                    if callable_obj is None:
                        return mgr
                    with mgr:
                        callable_obj(*a, **kw***REMOVED***
                assert_raises_regex_impl = impl

    return assert_raises_regex_impl(exception_class, expected_regexp,
                                    callable_obj, *args, **kwargs***REMOVED***


def decorate_methods(cls, decorator, testmatch=None***REMOVED***:
    ***REMOVED***
    Apply a decorator to all methods in a class matching a regular expression.

    The given decorator is applied to all public methods of `cls` that are
    matched by the regular expression `testmatch`
    (``testmatch.search(methodname***REMOVED***``***REMOVED***. Methods that are private, i.e. start
    with an underscore, are ignored.

    Parameters
    ----------
    cls : class
        Class whose methods to decorate.
    decorator : function
        Decorator to apply to methods
    testmatch : compiled regexp or str, optional
        The regular expression. Default value is None, in which case the
        nose default (``re.compile(r'(?:^|[\\b_\\.%s-***REMOVED******REMOVED***[Tt***REMOVED***est' % os.sep***REMOVED***``***REMOVED***
        is used.
        If `testmatch` is a string, it is compiled to a regular expression
        first.

    ***REMOVED***
    if testmatch is None:
        testmatch = re.compile(r'(?:^|[\\b_\\.%s-***REMOVED******REMOVED***[Tt***REMOVED***est' % os.sep***REMOVED***
    else:
        testmatch = re.compile(testmatch***REMOVED***
    cls_attr = cls.__dict__

    # delayed import to reduce startup time
    from inspect import isfunction

    methods = [_m for _m in cls_attr.values(***REMOVED*** if isfunction(_m***REMOVED******REMOVED***
    for function in methods:
        ***REMOVED***
            if hasattr(function, 'compat_func_name'***REMOVED***:
                funcname = function.compat_func_name
            else:
                funcname = function.__name__
        except AttributeError:
            # not a function
            continue
        if testmatch.search(funcname***REMOVED*** and not funcname.startswith('_'***REMOVED***:
            setattr(cls, funcname, decorator(function***REMOVED******REMOVED***
    return


def measure(code_str,times=1,label=None***REMOVED***:
    ***REMOVED***
    Return elapsed time for executing code in the namespace of the caller.

    The supplied code string is compiled with the Python builtin ``compile``.
    The precision of the timing is 10 milli-seconds. If the code will execute
    fast on this timescale, it can be executed many times to get reasonable
    timing accuracy.

    Parameters
    ----------
    code_str : str
        The code to be timed.
    times : int, optional
        The number of times the code is executed. Default is 1. The code is
        only compiled once.
    label : str, optional
        A label to identify `code_str` with. This is passed into ``compile``
        as the second argument (for run-time error messages***REMOVED***.

    Returns
    -------
    elapsed : float
        Total elapsed time in seconds for executing `code_str` `times` times.

    Examples
    --------
    >>> etime = np.testing.measure('for i in range(1000***REMOVED***: np.sqrt(i**2***REMOVED***',
    ...                            times=times***REMOVED***
    >>> print("Time for a single execution : ", etime / times, "s"***REMOVED***
    Time for a single execution :  0.005 s

    ***REMOVED***
    frame = sys._getframe(1***REMOVED***
    locs, globs = frame.f_locals, frame.f_globals

    code = compile(code_str,
                   'Test name: %s ' % label,
                   'exec'***REMOVED***
    i = 0
    elapsed = jiffies(***REMOVED***
    while i < times:
        i += 1
        exec(code, globs, locs***REMOVED***
    elapsed = jiffies(***REMOVED*** - elapsed
    return 0.01*elapsed


def _assert_valid_refcount(op***REMOVED***:
    ***REMOVED***
    Check that ufuncs don't mishandle refcount of object `1`.
    Used in a few regression tests.
    ***REMOVED***
    import numpy as np

    b = np.arange(100*100***REMOVED***.reshape(100, 100***REMOVED***
    c = b
    i = 1

    rc = sys.getrefcount(i***REMOVED***
    for j in range(15***REMOVED***:
        d = op(b, c***REMOVED***
    assert_(sys.getrefcount(i***REMOVED*** >= rc***REMOVED***
    del d  # for pyflakes


def assert_allclose(actual, desired, rtol=1e-7, atol=0, equal_nan=False,
                    err_msg='', verbose=True***REMOVED***:
    ***REMOVED***
    Raises an AssertionError if two objects are not equal up to desired
    tolerance.

    The test is equivalent to ``allclose(actual, desired, rtol, atol***REMOVED***``.
    It compares the difference between `actual` and `desired` to
    ``atol + rtol * abs(desired***REMOVED***``.

    .. versionadded:: 1.5.0

    Parameters
    ----------
    actual : array_like
        Array obtained.
    desired : array_like
        Array desired.
    rtol : float, optional
        Relative tolerance.
    atol : float, optional
        Absolute tolerance.
    equal_nan : bool, optional.
        If True, NaNs will compare equal.
    err_msg : str, optional
        The error message to be printed in case of failure.
    verbose : bool, optional
        If True, the conflicting values are appended to the error message.

    Raises
    ------
    AssertionError
        If actual and desired are not equal up to specified precision.

    See Also
    --------
    assert_array_almost_equal_nulp, assert_array_max_ulp

    Examples
    --------
    >>> x = [1e-5, 1e-3, 1e-1***REMOVED***
    >>> y = np.arccos(np.cos(x***REMOVED******REMOVED***
    >>> assert_allclose(x, y, rtol=1e-5, atol=0***REMOVED***

    ***REMOVED***
    __tracebackhide__ = True  # Hide traceback for py.test
    import numpy as np

    def compare(x, y***REMOVED***:
        return np.core.numeric.isclose(x, y, rtol=rtol, atol=atol,
                                       equal_nan=equal_nan***REMOVED***

    actual, desired = np.asanyarray(actual***REMOVED***, np.asanyarray(desired***REMOVED***
    header = 'Not equal to tolerance rtol=%g, atol=%g' % (rtol, atol***REMOVED***
    assert_array_compare(compare, actual, desired, err_msg=str(err_msg***REMOVED***,
                         verbose=verbose, header=header***REMOVED***

def assert_array_almost_equal_nulp(x, y, nulp=1***REMOVED***:
    ***REMOVED***
    Compare two arrays relatively to their spacing.

    This is a relatively robust method to compare two arrays whose amplitude
    is variable.

    Parameters
    ----------
    x, y : array_like
        Input arrays.
    nulp : int, optional
        The maximum number of unit in the last place for tolerance (see Notes***REMOVED***.
        Default is 1.

    Returns
    -------
    None

    Raises
    ------
    AssertionError
        If the spacing between `x` and `y` for one or more elements is larger
        than `nulp`.

    See Also
    --------
    assert_array_max_ulp : Check that all items of arrays differ in at most
        N Units in the Last Place.
    spacing : Return the distance between x and the nearest adjacent number.

    Notes
    -----
    An assertion is raised if the following condition is not met::

        abs(x - y***REMOVED*** <= nulps * spacing(maximum(abs(x***REMOVED***, abs(y***REMOVED******REMOVED******REMOVED***

    Examples
    --------
    >>> x = np.array([1., 1e-10, 1e-20***REMOVED******REMOVED***
    >>> eps = np.finfo(x.dtype***REMOVED***.eps
    >>> np.testing.assert_array_almost_equal_nulp(x, x*eps/2 + x***REMOVED***

    >>> np.testing.assert_array_almost_equal_nulp(x, x*eps + x***REMOVED***
    Traceback (most recent call last***REMOVED***:
      ...
    AssertionError: X and Y are not equal to 1 ULP (max is 2***REMOVED***

    ***REMOVED***
    __tracebackhide__ = True  # Hide traceback for py.test
    import numpy as np
    ax = np.abs(x***REMOVED***
    ay = np.abs(y***REMOVED***
    ref = nulp * np.spacing(np.where(ax > ay, ax, ay***REMOVED******REMOVED***
    if not np.all(np.abs(x-y***REMOVED*** <= ref***REMOVED***:
        if np.iscomplexobj(x***REMOVED*** or np.iscomplexobj(y***REMOVED***:
            msg = "X and Y are not equal to %d ULP" % nulp
        else:
            max_nulp = np.max(nulp_diff(x, y***REMOVED******REMOVED***
            msg = "X and Y are not equal to %d ULP (max is %g***REMOVED***" % (nulp, max_nulp***REMOVED***
        raise AssertionError(msg***REMOVED***

def assert_array_max_ulp(a, b, maxulp=1, dtype=None***REMOVED***:
    ***REMOVED***
    Check that all items of arrays differ in at most N Units in the Last Place.

    Parameters
    ----------
    a, b : array_like
        Input arrays to be compared.
    maxulp : int, optional
        The maximum number of units in the last place that elements of `a` and
        `b` can differ. Default is 1.
    dtype : dtype, optional
        Data-type to convert `a` and `b` to if given. Default is None.

    Returns
    -------
    ret : ndarray
        Array containing number of representable floating point numbers between
        items in `a` and `b`.

    Raises
    ------
    AssertionError
        If one or more elements differ by more than `maxulp`.

    See Also
    --------
    assert_array_almost_equal_nulp : Compare two arrays relatively to their
        spacing.

    Examples
    --------
    >>> a = np.linspace(0., 1., 100***REMOVED***
    >>> res = np.testing.assert_array_max_ulp(a, np.arcsin(np.sin(a***REMOVED******REMOVED******REMOVED***

    ***REMOVED***
    __tracebackhide__ = True  # Hide traceback for py.test
    import numpy as np
    ret = nulp_diff(a, b, dtype***REMOVED***
    if not np.all(ret <= maxulp***REMOVED***:
        raise AssertionError("Arrays are not almost equal up to %g ULP" %
                             maxulp***REMOVED***
    return ret

def nulp_diff(x, y, dtype=None***REMOVED***:
    ***REMOVED***For each item in x and y, return the number of representable floating
    points between them.

    Parameters
    ----------
    x : array_like
        first input array
    y : array_like
        second input array
    dtype : dtype, optional
        Data-type to convert `x` and `y` to if given. Default is None.

    Returns
    -------
    nulp : array_like
        number of representable floating point numbers between each item in x
        and y.

    Examples
    --------
    # By definition, epsilon is the smallest number such as 1 + eps != 1, so
    # there should be exactly one ULP between 1 and 1 + eps
    >>> nulp_diff(1, 1 + np.finfo(x.dtype***REMOVED***.eps***REMOVED***
    1.0
    ***REMOVED***
    import numpy as np
    if dtype:
        x = np.array(x, dtype=dtype***REMOVED***
        y = np.array(y, dtype=dtype***REMOVED***
    else:
        x = np.array(x***REMOVED***
        y = np.array(y***REMOVED***

    t = np.common_type(x, y***REMOVED***
    if np.iscomplexobj(x***REMOVED*** or np.iscomplexobj(y***REMOVED***:
        raise NotImplementedError("_nulp not implemented for complex array"***REMOVED***

    x = np.array(x, dtype=t***REMOVED***
    y = np.array(y, dtype=t***REMOVED***

    if not x.shape == y.shape:
        raise ValueError("x and y do not have the same shape: %s - %s" %
                         (x.shape, y.shape***REMOVED******REMOVED***

    def _diff(rx, ry, vdt***REMOVED***:
        diff = np.array(rx-ry, dtype=vdt***REMOVED***
        return np.abs(diff***REMOVED***

    rx = integer_repr(x***REMOVED***
    ry = integer_repr(y***REMOVED***
    return _diff(rx, ry, t***REMOVED***

def _integer_repr(x, vdt, comp***REMOVED***:
    # Reinterpret binary representation of the float as sign-magnitude:
    # take into account two-complement representation
    # See also
    # http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm
    rx = x.view(vdt***REMOVED***
    if not (rx.size == 1***REMOVED***:
        rx[rx < 0***REMOVED*** = comp - rx[rx < 0***REMOVED***
    else:
        if rx < 0:
            rx = comp - rx

    return rx

def integer_repr(x***REMOVED***:
    ***REMOVED***Return the signed-magnitude interpretation of the binary representation of
    x.***REMOVED***
    import numpy as np
    if x.dtype == np.float32:
        return _integer_repr(x, np.int32, np.int32(-2**31***REMOVED******REMOVED***
    elif x.dtype == np.float64:
        return _integer_repr(x, np.int64, np.int64(-2**63***REMOVED******REMOVED***
    else:
        raise ValueError("Unsupported dtype %s" % x.dtype***REMOVED***

# The following two classes are copied from python 2.6 warnings module (context
# manager***REMOVED***
class WarningMessage(object***REMOVED***:

    ***REMOVED***
    Holds the result of a single showwarning(***REMOVED*** call.

    Deprecated in 1.8.0

    Notes
    -----
    `WarningMessage` is copied from the Python 2.6 warnings module,
    so it can be used in NumPy with older Python versions.

    ***REMOVED***

    _WARNING_DETAILS = ("message", "category", "filename", "lineno", "file",
                        "line"***REMOVED***

    def __init__(self, message, category, filename, lineno, file=None,
                    line=None***REMOVED***:
        local_values = locals(***REMOVED***
        for attr in self._WARNING_DETAILS:
            setattr(self, attr, local_values[attr***REMOVED******REMOVED***
        if category:
            self._category_name = category.__name__
        else:
            self._category_name = None

    def __str__(self***REMOVED***:
        return ("{message : %r, category : %r, filename : %r, lineno : %s, "
                    "line : %r***REMOVED***" % (self.message, self._category_name,
                                    self.filename, self.lineno, self.line***REMOVED******REMOVED***

class WarningManager(object***REMOVED***:
    ***REMOVED***
    A context manager that copies and restores the warnings filter upon
    exiting the context.

    The 'record' argument specifies whether warnings should be captured by a
    custom implementation of ``warnings.showwarning(***REMOVED***`` and be appended to a
    list returned by the context manager. Otherwise None is returned by the
    context manager. The objects appended to the list are arguments whose
    attributes mirror the arguments to ``showwarning(***REMOVED***``.

    The 'module' argument is to specify an alternative module to the module
    named 'warnings' and imported under that name. This argument is only useful
    when testing the warnings module itself.

    Deprecated in 1.8.0

    Notes
    -----
    `WarningManager` is a copy of the ``catch_warnings`` context manager
    from the Python 2.6 warnings module, with slight modifications.
    It is copied so it can be used in NumPy with older Python versions.

    ***REMOVED***

    def __init__(self, record=False, module=None***REMOVED***:
        self._record = record
        if module is None:
            self._module = sys.modules['warnings'***REMOVED***
        else:
            self._module = module
        self._entered = False

    def __enter__(self***REMOVED***:
        if self._entered:
            raise RuntimeError("Cannot enter %r twice" % self***REMOVED***
        self._entered = True
        self._filters = self._module.filters
        self._module.filters = self._filters[:***REMOVED***
        self._showwarning = self._module.showwarning
        if self._record:
            log = [***REMOVED***

            def showwarning(*args, **kwargs***REMOVED***:
                log.append(WarningMessage(*args, **kwargs***REMOVED******REMOVED***
            self._module.showwarning = showwarning
            return log
        else:
            return None

    def __exit__(self***REMOVED***:
        if not self._entered:
            raise RuntimeError("Cannot exit %r without entering first" % self***REMOVED***
        self._module.filters = self._filters
        self._module.showwarning = self._showwarning


@contextlib.contextmanager
def _assert_warns_context(warning_class, name=None***REMOVED***:
    __tracebackhide__ = True  # Hide traceback for py.test
    with warnings.catch_warnings(record=True***REMOVED*** as l:
        warnings.simplefilter('always'***REMOVED***
        yield
        if not len(l***REMOVED*** > 0:
            name_str = " when calling %s" % name if name is not None else ""
            raise AssertionError("No warning raised" + name_str***REMOVED***
        if not l[0***REMOVED***.category is warning_class:
            name_str = "%s " % name if name is not None else ""
            raise AssertionError("First warning %sis not a %s (is %s***REMOVED***"
                                 % (name_str, warning_class, l[0***REMOVED******REMOVED******REMOVED***


def assert_warns(warning_class, *args, **kwargs***REMOVED***:
    ***REMOVED***
    Fail unless the given callable throws the specified warning.

    A warning of class warning_class should be thrown by the callable when
    invoked with arguments args and keyword arguments kwargs.
    If a different type of warning is thrown, it will not be caught, and the
    test case will be deemed to have suffered an error.

    If called with all arguments other than the warning class omitted, may be
    used as a context manager:

        with assert_warns(SomeWarning***REMOVED***:
            do_something(***REMOVED***

    The ability to be used as a context manager is new in NumPy v1.11.0.

    .. versionadded:: 1.4.0

    Parameters
    ----------
    warning_class : class
        The class defining the warning that `func` is expected to throw.
    func : callable
        The callable to test.
    \\*args : Arguments
        Arguments passed to `func`.
    \\*\\*kwargs : Kwargs
        Keyword arguments passed to `func`.

    Returns
    -------
    The value returned by `func`.

    ***REMOVED***
    if not args:
        return _assert_warns_context(warning_class***REMOVED***

    func = args[0***REMOVED***
    args = args[1:***REMOVED***
    with _assert_warns_context(warning_class, name=func.__name__***REMOVED***:
        return func(*args, **kwargs***REMOVED***


@contextlib.contextmanager
def _assert_no_warnings_context(name=None***REMOVED***:
    __tracebackhide__ = True  # Hide traceback for py.test
    with warnings.catch_warnings(record=True***REMOVED*** as l:
        warnings.simplefilter('always'***REMOVED***
        yield
        if len(l***REMOVED*** > 0:
            name_str = " when calling %s" % name if name is not None else ""
            raise AssertionError("Got warnings%s: %s" % (name_str, l***REMOVED******REMOVED***


def assert_no_warnings(*args, **kwargs***REMOVED***:
    ***REMOVED***
    Fail if the given callable produces any warnings.

    If called with all arguments omitted, may be used as a context manager:

        with assert_no_warnings(***REMOVED***:
            do_something(***REMOVED***

    The ability to be used as a context manager is new in NumPy v1.11.0.

    .. versionadded:: 1.7.0

    Parameters
    ----------
    func : callable
        The callable to test.
    \\*args : Arguments
        Arguments passed to `func`.
    \\*\\*kwargs : Kwargs
        Keyword arguments passed to `func`.

    Returns
    -------
    The value returned by `func`.

    ***REMOVED***
    if not args:
        return _assert_no_warnings_context(***REMOVED***

    func = args[0***REMOVED***
    args = args[1:***REMOVED***
    with _assert_no_warnings_context(name=func.__name__***REMOVED***:
        return func(*args, **kwargs***REMOVED***


def _gen_alignment_data(dtype=float32, type='binary', max_size=24***REMOVED***:
    ***REMOVED***
    generator producing data with different alignment and offsets
    to test simd vectorization

    Parameters
    ----------
    dtype : dtype
        data type to produce
    type : string
        'unary': create data for unary operations, creates one input
                 and output array
        'binary': create data for unary operations, creates two input
                 and output array
    max_size : integer
        maximum size of data to produce

    Returns
    -------
    if type is 'unary' yields one output, one input array and a message
    containing information on the data
    if type is 'binary' yields one output array, two input array and a message
    containing information on the data

    ***REMOVED***
    ufmt = 'unary offset=(%d, %d***REMOVED***, size=%d, dtype=%r, %s'
    bfmt = 'binary offset=(%d, %d, %d***REMOVED***, size=%d, dtype=%r, %s'
    for o in range(3***REMOVED***:
        for s in range(o + 2, max(o + 3, max_size***REMOVED******REMOVED***:
            if type == 'unary':
                inp = lambda: arange(s, dtype=dtype***REMOVED***[o:***REMOVED***
                out = empty((s,***REMOVED***, dtype=dtype***REMOVED***[o:***REMOVED***
                yield out, inp(***REMOVED***, ufmt % (o, o, s, dtype, 'out of place'***REMOVED***
                yield inp(***REMOVED***, inp(***REMOVED***, ufmt % (o, o, s, dtype, 'in place'***REMOVED***
                yield out[1:***REMOVED***, inp(***REMOVED***[:-1***REMOVED***, ufmt % \
                    (o + 1, o, s - 1, dtype, 'out of place'***REMOVED***
                yield out[:-1***REMOVED***, inp(***REMOVED***[1:***REMOVED***, ufmt % \
                    (o, o + 1, s - 1, dtype, 'out of place'***REMOVED***
                yield inp(***REMOVED***[:-1***REMOVED***, inp(***REMOVED***[1:***REMOVED***, ufmt % \
                    (o, o + 1, s - 1, dtype, 'aliased'***REMOVED***
                yield inp(***REMOVED***[1:***REMOVED***, inp(***REMOVED***[:-1***REMOVED***, ufmt % \
                    (o + 1, o, s - 1, dtype, 'aliased'***REMOVED***
            if type == 'binary':
                inp1 = lambda: arange(s, dtype=dtype***REMOVED***[o:***REMOVED***
                inp2 = lambda: arange(s, dtype=dtype***REMOVED***[o:***REMOVED***
                out = empty((s,***REMOVED***, dtype=dtype***REMOVED***[o:***REMOVED***
                yield out, inp1(***REMOVED***, inp2(***REMOVED***,  bfmt % \
                    (o, o, o, s, dtype, 'out of place'***REMOVED***
                yield inp1(***REMOVED***, inp1(***REMOVED***, inp2(***REMOVED***, bfmt % \
                    (o, o, o, s, dtype, 'in place1'***REMOVED***
                yield inp2(***REMOVED***, inp1(***REMOVED***, inp2(***REMOVED***, bfmt % \
                    (o, o, o, s, dtype, 'in place2'***REMOVED***
                yield out[1:***REMOVED***, inp1(***REMOVED***[:-1***REMOVED***, inp2(***REMOVED***[:-1***REMOVED***, bfmt % \
                    (o + 1, o, o, s - 1, dtype, 'out of place'***REMOVED***
                yield out[:-1***REMOVED***, inp1(***REMOVED***[1:***REMOVED***, inp2(***REMOVED***[:-1***REMOVED***, bfmt % \
                    (o, o + 1, o, s - 1, dtype, 'out of place'***REMOVED***
                yield out[:-1***REMOVED***, inp1(***REMOVED***[:-1***REMOVED***, inp2(***REMOVED***[1:***REMOVED***, bfmt % \
                    (o, o, o + 1, s - 1, dtype, 'out of place'***REMOVED***
                yield inp1(***REMOVED***[1:***REMOVED***, inp1(***REMOVED***[:-1***REMOVED***, inp2(***REMOVED***[:-1***REMOVED***, bfmt % \
                    (o + 1, o, o, s - 1, dtype, 'aliased'***REMOVED***
                yield inp1(***REMOVED***[:-1***REMOVED***, inp1(***REMOVED***[1:***REMOVED***, inp2(***REMOVED***[:-1***REMOVED***, bfmt % \
                    (o, o + 1, o, s - 1, dtype, 'aliased'***REMOVED***
                yield inp1(***REMOVED***[:-1***REMOVED***, inp1(***REMOVED***[:-1***REMOVED***, inp2(***REMOVED***[1:***REMOVED***, bfmt % \
                    (o, o, o + 1, s - 1, dtype, 'aliased'***REMOVED***


class IgnoreException(Exception***REMOVED***:
    "Ignoring this exception due to disabled feature"


@contextlib.contextmanager
def tempdir(*args, **kwargs***REMOVED***:
    ***REMOVED***Context manager to provide a temporary test folder.

    All arguments are passed as this to the underlying tempfile.mkdtemp
    function.

    ***REMOVED***
    tmpdir = mkdtemp(*args, **kwargs***REMOVED***
    ***REMOVED***
        yield tmpdir
    finally:
        shutil.rmtree(tmpdir***REMOVED***

@contextlib.contextmanager
def temppath(*args, **kwargs***REMOVED***:
    ***REMOVED***Context manager for temporary files.

    Context manager that returns the path to a closed temporary file. Its
    parameters are the same as for tempfile.mkstemp and are passed directly
    to that function. The underlying file is removed when the context is
    exited, so it should be closed at that time.
  
    Windows does not allow a temporary file to be opened if it is already
    open, so the underlying file must be closed after opening before it
    can be opened again.

    ***REMOVED***
    fd, path = mkstemp(*args, **kwargs***REMOVED***
    os.close(fd***REMOVED***
    ***REMOVED***
        yield path
    finally:
        os.remove(path***REMOVED***


class clear_and_catch_warnings(warnings.catch_warnings***REMOVED***:
    ***REMOVED*** Context manager that resets warning registry for catching warnings

    Warnings can be slippery, because, whenever a warning is triggered, Python
    adds a ``__warningregistry__`` member to the *calling* module.  This makes
    it impossible to retrigger the warning in this module, whatever you put in
    the warnings filters.  This context manager accepts a sequence of `modules`
    as a keyword argument to its constructor and:

    * stores and removes any ``__warningregistry__`` entries in given `modules`
      on entry;
    * resets ``__warningregistry__`` to its previous state on exit.

    This makes it possible to trigger any warning afresh inside the context
    manager without disturbing the state of warnings outside.

    For compatibility with Python 3.0, please consider all arguments to be
    keyword-only.

    Parameters
    ----------
    record : bool, optional
        Specifies whether warnings should be captured by a custom
        implementation of ``warnings.showwarning(***REMOVED***`` and be appended to a list
        returned by the context manager. Otherwise None is returned by the
        context manager. The objects appended to the list are arguments whose
        attributes mirror the arguments to ``showwarning(***REMOVED***``.
    modules : sequence, optional
        Sequence of modules for which to reset warnings registry on entry and
        restore on exit

    Examples
    --------
    >>> import warnings
    >>> with clear_and_catch_warnings(modules=[np.core.fromnumeric***REMOVED******REMOVED***:
    ...     warnings.simplefilter('always'***REMOVED***
    ...     # do something that raises a warning in np.core.fromnumeric
    ***REMOVED***
    class_modules = (***REMOVED***

    def __init__(self, record=False, modules=(***REMOVED******REMOVED***:
        self.modules = set(modules***REMOVED***.union(self.class_modules***REMOVED***
        self._warnreg_copies = {***REMOVED***
        super(clear_and_catch_warnings, self***REMOVED***.__init__(record=record***REMOVED***

    def __enter__(self***REMOVED***:
        for mod in self.modules:
            if hasattr(mod, '__warningregistry__'***REMOVED***:
                mod_reg = mod.__warningregistry__
                self._warnreg_copies[mod***REMOVED*** = mod_reg.copy(***REMOVED***
                mod_reg.clear(***REMOVED***
        return super(clear_and_catch_warnings, self***REMOVED***.__enter__(***REMOVED***

    def __exit__(self, *exc_info***REMOVED***:
        super(clear_and_catch_warnings, self***REMOVED***.__exit__(*exc_info***REMOVED***
        for mod in self.modules:
            if hasattr(mod, '__warningregistry__'***REMOVED***:
                mod.__warningregistry__.clear(***REMOVED***
            if mod in self._warnreg_copies:
                mod.__warningregistry__.update(self._warnreg_copies[mod***REMOVED******REMOVED***
