***REMOVED***Machine limits for Float32 and Float64 and (long double***REMOVED*** if available...

***REMOVED***
from __future__ import division, absolute_import, print_function

__all__ = ['finfo', 'iinfo'***REMOVED***

from .machar import MachAr
from . import numeric
from . import numerictypes as ntypes
from .numeric import array

def _frz(a***REMOVED***:
    ***REMOVED***fix rank-0 --> rank-1***REMOVED***
    if a.ndim == 0:
        a.shape = (1,***REMOVED***
    return a

_convert_to_float = {
    ntypes.csingle: ntypes.single,
    ntypes.complex_: ntypes.float_,
    ntypes.clongfloat: ntypes.longfloat
***REMOVED***

class finfo(object***REMOVED***:
    ***REMOVED***
    finfo(dtype***REMOVED***

    Machine limits for floating point types.

    Attributes
    ----------
    eps : float
        The smallest representable positive number such that
        ``1.0 + eps != 1.0``.  Type of `eps` is an appropriate floating
        point type.
    epsneg : floating point number of the appropriate type
        The smallest representable positive number such that
        ``1.0 - epsneg != 1.0``.
    iexp : int
        The number of bits in the exponent portion of the floating point
        representation.
    machar : MachAr
        The object which calculated these parameters and holds more
        detailed information.
    machep : int
        The exponent that yields `eps`.
    max : floating point number of the appropriate type
        The largest representable number.
    maxexp : int
        The smallest positive power of the base (2***REMOVED*** that causes overflow.
    min : floating point number of the appropriate type
        The smallest representable number, typically ``-max``.
    minexp : int
        The most negative power of the base (2***REMOVED*** consistent with there
        being no leading 0's in the mantissa.
    negep : int
        The exponent that yields `epsneg`.
    nexp : int
        The number of bits in the exponent including its sign and bias.
    nmant : int
        The number of bits in the mantissa.
    precision : int
        The approximate number of decimal digits to which this kind of
        float is precise.
    resolution : floating point number of the appropriate type
        The approximate decimal resolution of this type, i.e.,
        ``10**-precision``.
    tiny : float
        The smallest positive usable number.  Type of `tiny` is an
        appropriate floating point type.

    Parameters
    ----------
    dtype : float, dtype, or instance
        Kind of floating point data-type about which to get information.

    See Also
    --------
    MachAr : The implementation of the tests that produce this information.
    iinfo : The equivalent for integer data types.

    Notes
    -----
    For developers of NumPy: do not instantiate this at the module level.
    The initial calculation of these parameters is expensive and negatively
    impacts import times.  These objects are cached, so calling ``finfo(***REMOVED***``
    repeatedly inside your functions is not a problem.

    ***REMOVED***

    _finfo_cache = {***REMOVED***

    def __new__(cls, dtype***REMOVED***:
        ***REMOVED***
            dtype = numeric.dtype(dtype***REMOVED***
        except TypeError:
            # In case a float instance was given
            dtype = numeric.dtype(type(dtype***REMOVED******REMOVED***

        obj = cls._finfo_cache.get(dtype, None***REMOVED***
        if obj is not None:
            return obj
        dtypes = [dtype***REMOVED***
        newdtype = numeric.obj2sctype(dtype***REMOVED***
        if newdtype is not dtype:
            dtypes.append(newdtype***REMOVED***
            dtype = newdtype
        if not issubclass(dtype, numeric.inexact***REMOVED***:
            raise ValueError("data type %r not inexact" % (dtype***REMOVED******REMOVED***
        obj = cls._finfo_cache.get(dtype, None***REMOVED***
        if obj is not None:
            return obj
        if not issubclass(dtype, numeric.floating***REMOVED***:
            newdtype = _convert_to_float[dtype***REMOVED***
            if newdtype is not dtype:
                dtypes.append(newdtype***REMOVED***
                dtype = newdtype
        obj = cls._finfo_cache.get(dtype, None***REMOVED***
        if obj is not None:
            return obj
        obj = object.__new__(cls***REMOVED***._init(dtype***REMOVED***
        for dt in dtypes:
            cls._finfo_cache[dt***REMOVED*** = obj
        return obj

    def _init(self, dtype***REMOVED***:
        self.dtype = numeric.dtype(dtype***REMOVED***
        if dtype is ntypes.double:
            itype = ntypes.int64
            fmt = '%24.16e'
            precname = 'double'
        elif dtype is ntypes.single:
            itype = ntypes.int32
            fmt = '%15.7e'
            precname = 'single'
        elif dtype is ntypes.longdouble:
            itype = ntypes.longlong
            fmt = '%s'
            precname = 'long double'
        elif dtype is ntypes.half:
            itype = ntypes.int16
            fmt = '%12.5e'
            precname = 'half'
        else:
            raise ValueError(repr(dtype***REMOVED******REMOVED***

        machar = MachAr(lambda v:array([v***REMOVED***, dtype***REMOVED***,
                        lambda v:_frz(v.astype(itype***REMOVED******REMOVED***[0***REMOVED***,
                        lambda v:array(_frz(v***REMOVED***[0***REMOVED***, dtype***REMOVED***,
                        lambda v: fmt % array(_frz(v***REMOVED***[0***REMOVED***, dtype***REMOVED***,
                        'numpy %s precision floating point number' % precname***REMOVED***

        for word in ['precision', 'iexp',
                     'maxexp', 'minexp', 'negep',
                     'machep'***REMOVED***:
            setattr(self, word, getattr(machar, word***REMOVED******REMOVED***
        for word in ['tiny', 'resolution', 'epsneg'***REMOVED***:
            setattr(self, word, getattr(machar, word***REMOVED***.flat[0***REMOVED******REMOVED***
        self.max = machar.huge.flat[0***REMOVED***
        self.min = -self.max
        self.eps = machar.eps.flat[0***REMOVED***
        self.nexp = machar.iexp
        self.nmant = machar.it
        self.machar = machar
        self._str_tiny = machar._str_xmin.strip(***REMOVED***
        self._str_max = machar._str_xmax.strip(***REMOVED***
        self._str_epsneg = machar._str_epsneg.strip(***REMOVED***
        self._str_eps = machar._str_eps.strip(***REMOVED***
        self._str_resolution = machar._str_resolution.strip(***REMOVED***
        return self

    def __str__(self***REMOVED***:
        fmt = (
            'Machine parameters for %(dtype***REMOVED***s\n'
            '---------------------------------------------------------------\n'
            'precision=%(precision***REMOVED***3s   resolution= %(_str_resolution***REMOVED***s\n'
            'machep=%(machep***REMOVED***6s   eps=        %(_str_eps***REMOVED***s\n'
            'negep =%(negep***REMOVED***6s   epsneg=     %(_str_epsneg***REMOVED***s\n'
            'minexp=%(minexp***REMOVED***6s   tiny=       %(_str_tiny***REMOVED***s\n'
            'maxexp=%(maxexp***REMOVED***6s   max=        %(_str_max***REMOVED***s\n'
            'nexp  =%(nexp***REMOVED***6s   min=        -max\n'
            '---------------------------------------------------------------\n'
            ***REMOVED***
        return fmt % self.__dict__

    def __repr__(self***REMOVED***:
        c = self.__class__.__name__
        d = self.__dict__.copy(***REMOVED***
        d['klass'***REMOVED*** = c
        return (("%(klass***REMOVED***s(resolution=%(resolution***REMOVED***s, min=-%(_str_max***REMOVED***s,"
                 " max=%(_str_max***REMOVED***s, dtype=%(dtype***REMOVED***s***REMOVED***"***REMOVED*** % d***REMOVED***


class iinfo(object***REMOVED***:
    ***REMOVED***
    iinfo(type***REMOVED***

    Machine limits for integer types.

    Attributes
    ----------
    min : int
        The smallest integer expressible by the type.
    max : int
        The largest integer expressible by the type.

    Parameters
    ----------
    int_type : integer type, dtype, or instance
        The kind of integer data type to get information about.

    See Also
    --------
    finfo : The equivalent for floating point data types.

    Examples
    --------
    With types:

    >>> ii16 = np.iinfo(np.int16***REMOVED***
    >>> ii16.min
    -32768
    >>> ii16.max
    32767
    >>> ii32 = np.iinfo(np.int32***REMOVED***
    >>> ii32.min
    -2147483648
    >>> ii32.max
    2147483647

    With instances:

    >>> ii32 = np.iinfo(np.int32(10***REMOVED******REMOVED***
    >>> ii32.min
    -2147483648
    >>> ii32.max
    2147483647

    ***REMOVED***

    _min_vals = {***REMOVED***
    _max_vals = {***REMOVED***

    def __init__(self, int_type***REMOVED***:
        ***REMOVED***
            self.dtype = numeric.dtype(int_type***REMOVED***
        except TypeError:
            self.dtype = numeric.dtype(type(int_type***REMOVED******REMOVED***
        self.kind = self.dtype.kind
        self.bits = self.dtype.itemsize * 8
        self.key = "%s%d" % (self.kind, self.bits***REMOVED***
        if self.kind not in 'iu':
            raise ValueError("Invalid integer data type."***REMOVED***

    def min(self***REMOVED***:
        ***REMOVED***Minimum value of given dtype.***REMOVED***
        if self.kind == 'u':
            return 0
        else:
            ***REMOVED***
                val = iinfo._min_vals[self.key***REMOVED***
            except KeyError:
                val = int(-(1 << (self.bits-1***REMOVED******REMOVED******REMOVED***
                iinfo._min_vals[self.key***REMOVED*** = val
            return val

    min = property(min***REMOVED***

    def max(self***REMOVED***:
        ***REMOVED***Maximum value of given dtype.***REMOVED***
        ***REMOVED***
            val = iinfo._max_vals[self.key***REMOVED***
        except KeyError:
            if self.kind == 'u':
                val = int((1 << self.bits***REMOVED*** - 1***REMOVED***
            else:
                val = int((1 << (self.bits-1***REMOVED******REMOVED*** - 1***REMOVED***
            iinfo._max_vals[self.key***REMOVED*** = val
        return val

    max = property(max***REMOVED***

    def __str__(self***REMOVED***:
        ***REMOVED***String representation.***REMOVED***
        fmt = (
            'Machine parameters for %(dtype***REMOVED***s\n'
            '---------------------------------------------------------------\n'
            'min = %(min***REMOVED***s\n'
            'max = %(max***REMOVED***s\n'
            '---------------------------------------------------------------\n'
            ***REMOVED***
        return fmt % {'dtype': self.dtype, 'min': self.min, 'max': self.max***REMOVED***

    def __repr__(self***REMOVED***:
        return "%s(min=%s, max=%s, dtype=%s***REMOVED***" % (self.__class__.__name__,
                                    self.min, self.max, self.dtype***REMOVED***

if __name__ == '__main__':
    f = finfo(ntypes.single***REMOVED***
    print('single epsilon:', f.eps***REMOVED***
    print('single tiny:', f.tiny***REMOVED***
    f = finfo(ntypes.float***REMOVED***
    print('float epsilon:', f.eps***REMOVED***
    print('float tiny:', f.tiny***REMOVED***
    f = finfo(ntypes.longfloat***REMOVED***
    print('longfloat epsilon:', f.eps***REMOVED***
    print('longfloat tiny:', f.tiny***REMOVED***
