from __future__ import division, absolute_import, print_function

__all__ = ['logspace', 'linspace'***REMOVED***

from . import numeric as _nx
from .numeric import result_type, NaN, shares_memory, MAY_SHARE_BOUNDS, TooHardError


def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None***REMOVED***:
    ***REMOVED***
    Return evenly spaced numbers over a specified interval.

    Returns `num` evenly spaced samples, calculated over the
    interval [`start`, `stop`***REMOVED***.

    The endpoint of the interval can optionally be excluded.

    Parameters
    ----------
    start : scalar
        The starting value of the sequence.
    stop : scalar
        The end value of the sequence, unless `endpoint` is set to False.
        In that case, the sequence consists of all but the last of ``num + 1``
        evenly spaced samples, so that `stop` is excluded.  Note that the step
        size changes when `endpoint` is False.
    num : int, optional
        Number of samples to generate. Default is 50. Must be non-negative.
    endpoint : bool, optional
        If True, `stop` is the last sample. Otherwise, it is not included.
        Default is True.
    retstep : bool, optional
        If True, return (`samples`, `step`***REMOVED***, where `step` is the spacing
        between samples.
    dtype : dtype, optional
        The type of the output array.  If `dtype` is not given, infer the data
        type from the other input arguments.

        .. versionadded:: 1.9.0

    Returns
    -------
    samples : ndarray
        There are `num` equally spaced samples in the closed interval
        ``[start, stop***REMOVED***`` or the half-open interval ``[start, stop***REMOVED***``
        (depending on whether `endpoint` is True or False***REMOVED***.
    step : float
        Only returned if `retstep` is True

        Size of spacing between samples.


    See Also
    --------
    arange : Similar to `linspace`, but uses a step size (instead of the
             number of samples***REMOVED***.
    logspace : Samples uniformly distributed in log space.

    Examples
    --------
    >>> np.linspace(2.0, 3.0, num=5***REMOVED***
        array([ 2.  ,  2.25,  2.5 ,  2.75,  3.  ***REMOVED******REMOVED***
    >>> np.linspace(2.0, 3.0, num=5, endpoint=False***REMOVED***
        array([ 2. ,  2.2,  2.4,  2.6,  2.8***REMOVED******REMOVED***
    >>> np.linspace(2.0, 3.0, num=5, retstep=True***REMOVED***
        (array([ 2.  ,  2.25,  2.5 ,  2.75,  3.  ***REMOVED******REMOVED***, 0.25***REMOVED***

    Graphical illustration:

    >>> import matplotlib.pyplot as plt
    >>> N = 8
    >>> y = np.zeros(N***REMOVED***
    >>> x1 = np.linspace(0, 10, N, endpoint=True***REMOVED***
    >>> x2 = np.linspace(0, 10, N, endpoint=False***REMOVED***
    >>> plt.plot(x1, y, 'o'***REMOVED***
    [<matplotlib.lines.Line2D object at 0x...>***REMOVED***
    >>> plt.plot(x2, y + 0.5, 'o'***REMOVED***
    [<matplotlib.lines.Line2D object at 0x...>***REMOVED***
    >>> plt.ylim([-0.5, 1***REMOVED******REMOVED***
    (-0.5, 1***REMOVED***
    >>> plt.show(***REMOVED***

    ***REMOVED***
    num = int(num***REMOVED***
    if num < 0:
        raise ValueError("Number of samples, %s, must be non-negative." % num***REMOVED***
    div = (num - 1***REMOVED*** if endpoint else num

    # Convert float/complex array scalars to float, gh-3504
    start = start * 1.
    stop = stop * 1.

    dt = result_type(start, stop, float(num***REMOVED******REMOVED***
    if dtype is None:
        dtype = dt

    y = _nx.arange(0, num, dtype=dt***REMOVED***

    delta = stop - start
    if num > 1:
        step = delta / div
        if step == 0:
            # Special handling for denormal numbers, gh-5437
            y /= div
            y = y * delta
        else:
            # One might be tempted to use faster, in-place multiplication here,
            # but this prevents step from overriding what class is produced,
            # and thus prevents, e.g., use of Quantities; see gh-7142.
            y = y * step
    else:
        # 0 and 1 item long sequences have an undefined step
        step = NaN
        # Multiply with delta to allow possible override of output class.
        y = y * delta

    y += start

    if endpoint and num > 1:
        y[-1***REMOVED*** = stop

    if retstep:
        return y.astype(dtype, copy=False***REMOVED***, step
    else:
        return y.astype(dtype, copy=False***REMOVED***


def logspace(start, stop, num=50, endpoint=True, base=10.0, dtype=None***REMOVED***:
    ***REMOVED***
    Return numbers spaced evenly on a log scale.

    In linear space, the sequence starts at ``base ** start``
    (`base` to the power of `start`***REMOVED*** and ends with ``base ** stop``
    (see `endpoint` below***REMOVED***.

    Parameters
    ----------
    start : float
        ``base ** start`` is the starting value of the sequence.
    stop : float
        ``base ** stop`` is the final value of the sequence, unless `endpoint`
        is False.  In that case, ``num + 1`` values are spaced over the
        interval in log-space, of which all but the last (a sequence of
        length ``num``***REMOVED*** are returned.
    num : integer, optional
        Number of samples to generate.  Default is 50.
    endpoint : boolean, optional
        If true, `stop` is the last sample. Otherwise, it is not included.
        Default is True.
    base : float, optional
        The base of the log space. The step size between the elements in
        ``ln(samples***REMOVED*** / ln(base***REMOVED***`` (or ``log_base(samples***REMOVED***``***REMOVED*** is uniform.
        Default is 10.0.
    dtype : dtype
        The type of the output array.  If `dtype` is not given, infer the data
        type from the other input arguments.

    Returns
    -------
    samples : ndarray
        `num` samples, equally spaced on a log scale.

    See Also
    --------
    arange : Similar to linspace, with the step size specified instead of the
             number of samples. Note that, when used with a float endpoint, the
             endpoint may or may not be included.
    linspace : Similar to logspace, but with the samples uniformly distributed
               in linear space, instead of log space.

    Notes
    -----
    Logspace is equivalent to the code

    >>> y = np.linspace(start, stop, num=num, endpoint=endpoint***REMOVED***
    ... # doctest: +SKIP
    >>> power(base, y***REMOVED***.astype(dtype***REMOVED***
    ... # doctest: +SKIP

    Examples
    --------
    >>> np.logspace(2.0, 3.0, num=4***REMOVED***
        array([  100.        ,   215.443469  ,   464.15888336,  1000.        ***REMOVED******REMOVED***
    >>> np.logspace(2.0, 3.0, num=4, endpoint=False***REMOVED***
        array([ 100.        ,  177.827941  ,  316.22776602,  562.34132519***REMOVED******REMOVED***
    >>> np.logspace(2.0, 3.0, num=4, base=2.0***REMOVED***
        array([ 4.        ,  5.0396842 ,  6.34960421,  8.        ***REMOVED******REMOVED***

    Graphical illustration:

    >>> import matplotlib.pyplot as plt
    >>> N = 10
    >>> x1 = np.logspace(0.1, 1, N, endpoint=True***REMOVED***
    >>> x2 = np.logspace(0.1, 1, N, endpoint=False***REMOVED***
    >>> y = np.zeros(N***REMOVED***
    >>> plt.plot(x1, y, 'o'***REMOVED***
    [<matplotlib.lines.Line2D object at 0x...>***REMOVED***
    >>> plt.plot(x2, y + 0.5, 'o'***REMOVED***
    [<matplotlib.lines.Line2D object at 0x...>***REMOVED***
    >>> plt.ylim([-0.5, 1***REMOVED******REMOVED***
    (-0.5, 1***REMOVED***
    >>> plt.show(***REMOVED***

    ***REMOVED***
    y = linspace(start, stop, num=num, endpoint=endpoint***REMOVED***
    if dtype is None:
        return _nx.power(base, y***REMOVED***
    return _nx.power(base, y***REMOVED***.astype(dtype***REMOVED***
