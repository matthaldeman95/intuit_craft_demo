/*
 * This is a convenience header file providing compatibility utilities
 * for supporting Python 2 and Python 3 in the same code base.
 *
 * If you want to use this for your own projects, it's recommended to make a
 * copy of it. Although the stuff below is unlikely to change, we don't provide
 * strong backwards compatibility guarantees at the moment.
 */

#ifndef _NPY_3KCOMPAT_H_
#define _NPY_3KCOMPAT_H_

#include <Python.h>
#include <stdio.h>

#if PY_VERSION_HEX >= 0x03000000
#ifndef NPY_PY3K
#define NPY_PY3K 1
#endif
#endif

#include "numpy/npy_common.h"
#include "numpy/ndarrayobject.h"

#ifdef __cplusplus
extern "C" {
#endif

/*
 * PyInt -> PyLong
 */

#if defined(NPY_PY3K***REMOVED***
/* Return True only if the long fits in a C long */
static NPY_INLINE int PyInt_Check(PyObject *op***REMOVED*** {
    int overflow = 0;
    if (!PyLong_Check(op***REMOVED******REMOVED*** {
        return 0;
***REMOVED***
    PyLong_AsLongAndOverflow(op, &overflow***REMOVED***;
    return (overflow == 0***REMOVED***;
***REMOVED***

#define PyInt_FromLong PyLong_FromLong
#define PyInt_AsLong PyLong_AsLong
#define PyInt_AS_LONG PyLong_AsLong
#define PyInt_AsSsize_t PyLong_AsSsize_t

/* NOTE:
 *
 * Since the PyLong type is very different from the fixed-range PyInt,
 * we don't define PyInt_Type -> PyLong_Type.
 */
#endif /* NPY_PY3K */

/*
 * PyString -> PyBytes
 */

#if defined(NPY_PY3K***REMOVED***

#define PyString_Type PyBytes_Type
#define PyString_Check PyBytes_Check
#define PyStringObject PyBytesObject
#define PyString_FromString PyBytes_FromString
#define PyString_FromStringAndSize PyBytes_FromStringAndSize
#define PyString_AS_STRING PyBytes_AS_STRING
#define PyString_AsStringAndSize PyBytes_AsStringAndSize
#define PyString_FromFormat PyBytes_FromFormat
#define PyString_Concat PyBytes_Concat
#define PyString_ConcatAndDel PyBytes_ConcatAndDel
#define PyString_AsString PyBytes_AsString
#define PyString_GET_SIZE PyBytes_GET_SIZE
#define PyString_Size PyBytes_Size

#define PyUString_Type PyUnicode_Type
#define PyUString_Check PyUnicode_Check
#define PyUStringObject PyUnicodeObject
#define PyUString_FromString PyUnicode_FromString
#define PyUString_FromStringAndSize PyUnicode_FromStringAndSize
#define PyUString_FromFormat PyUnicode_FromFormat
#define PyUString_Concat PyUnicode_Concat2
#define PyUString_ConcatAndDel PyUnicode_ConcatAndDel
#define PyUString_GET_SIZE PyUnicode_GET_SIZE
#define PyUString_Size PyUnicode_Size
#define PyUString_InternFromString PyUnicode_InternFromString
#define PyUString_Format PyUnicode_Format

#else

#define PyBytes_Type PyString_Type
#define PyBytes_Check PyString_Check
#define PyBytesObject PyStringObject
#define PyBytes_FromString PyString_FromString
#define PyBytes_FromStringAndSize PyString_FromStringAndSize
#define PyBytes_AS_STRING PyString_AS_STRING
#define PyBytes_AsStringAndSize PyString_AsStringAndSize
#define PyBytes_FromFormat PyString_FromFormat
#define PyBytes_Concat PyString_Concat
#define PyBytes_ConcatAndDel PyString_ConcatAndDel
#define PyBytes_AsString PyString_AsString
#define PyBytes_GET_SIZE PyString_GET_SIZE
#define PyBytes_Size PyString_Size

#define PyUString_Type PyString_Type
#define PyUString_Check PyString_Check
#define PyUStringObject PyStringObject
#define PyUString_FromString PyString_FromString
#define PyUString_FromStringAndSize PyString_FromStringAndSize
#define PyUString_FromFormat PyString_FromFormat
#define PyUString_Concat PyString_Concat
#define PyUString_ConcatAndDel PyString_ConcatAndDel
#define PyUString_GET_SIZE PyString_GET_SIZE
#define PyUString_Size PyString_Size
#define PyUString_InternFromString PyString_InternFromString
#define PyUString_Format PyString_Format

#endif /* NPY_PY3K */


static NPY_INLINE void
PyUnicode_ConcatAndDel(PyObject **left, PyObject *right***REMOVED***
{
    PyObject *newobj;
    newobj = PyUnicode_Concat(*left, right***REMOVED***;
    Py_DECREF(*left***REMOVED***;
    Py_DECREF(right***REMOVED***;
    *left = newobj;
***REMOVED***

static NPY_INLINE void
PyUnicode_Concat2(PyObject **left, PyObject *right***REMOVED***
{
    PyObject *newobj;
    newobj = PyUnicode_Concat(*left, right***REMOVED***;
    Py_DECREF(*left***REMOVED***;
    *left = newobj;
***REMOVED***

/*
 * PyFile_* compatibility
 */
#if defined(NPY_PY3K***REMOVED***
/*
 * Get a FILE* handle to the file represented by the Python object
 */
static NPY_INLINE FILE*
npy_PyFile_Dup2(PyObject *file, char *mode, npy_off_t *orig_pos***REMOVED***
{
    int fd, fd2, unbuf;
    PyObject *ret, *os, *io, *io_raw;
    npy_off_t pos;
    FILE *handle;

    /* Flush first to ensure things end up in the file in the correct order */
    ret = PyObject_CallMethod(file, "flush", ""***REMOVED***;
    if (ret == NULL***REMOVED*** {
        return NULL;
***REMOVED***
    Py_DECREF(ret***REMOVED***;
    fd = PyObject_AsFileDescriptor(file***REMOVED***;
    if (fd == -1***REMOVED*** {
        return NULL;
***REMOVED***

    /*
     * The handle needs to be dup'd because we have to call fclose
     * at the end
     */
    os = PyImport_ImportModule("os"***REMOVED***;
    if (os == NULL***REMOVED*** {
        return NULL;
***REMOVED***
    ret = PyObject_CallMethod(os, "dup", "i", fd***REMOVED***;
    Py_DECREF(os***REMOVED***;
    if (ret == NULL***REMOVED*** {
        return NULL;
***REMOVED***
    fd2 = PyNumber_AsSsize_t(ret, NULL***REMOVED***;
    Py_DECREF(ret***REMOVED***;

    /* Convert to FILE* handle */
#ifdef _WIN32
    handle = _fdopen(fd2, mode***REMOVED***;
#else
    handle = fdopen(fd2, mode***REMOVED***;
#endif
    if (handle == NULL***REMOVED*** {
        PyErr_SetString(PyExc_IOError,
                        "Getting a FILE* from a Python file object failed"***REMOVED***;
***REMOVED***

    /* Record the original raw file handle position */
    *orig_pos = npy_ftell(handle***REMOVED***;
    if (*orig_pos == -1***REMOVED*** {
        /* The io module is needed to determine if buffering is used */
        io = PyImport_ImportModule("io"***REMOVED***;
        if (io == NULL***REMOVED*** {
            fclose(handle***REMOVED***;
            return NULL;
    ***REMOVED***
        /* File object instances of RawIOBase are unbuffered */
        io_raw = PyObject_GetAttrString(io, "RawIOBase"***REMOVED***;
        Py_DECREF(io***REMOVED***;
        if (io_raw == NULL***REMOVED*** {
            fclose(handle***REMOVED***;
            return NULL;
    ***REMOVED***
        unbuf = PyObject_IsInstance(file, io_raw***REMOVED***;
        Py_DECREF(io_raw***REMOVED***;
        if (unbuf == 1***REMOVED*** {
            /* Succeed if the IO is unbuffered */
            return handle;
    ***REMOVED***
        else {
            PyErr_SetString(PyExc_IOError, "obtaining file position failed"***REMOVED***;
            fclose(handle***REMOVED***;
            return NULL;
    ***REMOVED***
***REMOVED***

    /* Seek raw handle to the Python-side position */
    ret = PyObject_CallMethod(file, "tell", ""***REMOVED***;
    if (ret == NULL***REMOVED*** {
        fclose(handle***REMOVED***;
        return NULL;
***REMOVED***
    pos = PyLong_AsLongLong(ret***REMOVED***;
    Py_DECREF(ret***REMOVED***;
    if (PyErr_Occurred(***REMOVED******REMOVED*** {
        fclose(handle***REMOVED***;
        return NULL;
***REMOVED***
    if (npy_fseek(handle, pos, SEEK_SET***REMOVED*** == -1***REMOVED*** {
        PyErr_SetString(PyExc_IOError, "seeking file failed"***REMOVED***;
        fclose(handle***REMOVED***;
        return NULL;
***REMOVED***
    return handle;
***REMOVED***

/*
 * Close the dup-ed file handle, and seek the Python one to the current position
 */
static NPY_INLINE int
npy_PyFile_DupClose2(PyObject *file, FILE* handle, npy_off_t orig_pos***REMOVED***
{
    int fd, unbuf;
    PyObject *ret, *io, *io_raw;
    npy_off_t position;

    position = npy_ftell(handle***REMOVED***;

    /* Close the FILE* handle */
    fclose(handle***REMOVED***;

    /*
     * Restore original file handle position, in order to not confuse
     * Python-side data structures
     */
    fd = PyObject_AsFileDescriptor(file***REMOVED***;
    if (fd == -1***REMOVED*** {
        return -1;
***REMOVED***

    if (npy_lseek(fd, orig_pos, SEEK_SET***REMOVED*** == -1***REMOVED*** {

        /* The io module is needed to determine if buffering is used */
        io = PyImport_ImportModule("io"***REMOVED***;
        if (io == NULL***REMOVED*** {
            return -1;
    ***REMOVED***
        /* File object instances of RawIOBase are unbuffered */
        io_raw = PyObject_GetAttrString(io, "RawIOBase"***REMOVED***;
        Py_DECREF(io***REMOVED***;
        if (io_raw == NULL***REMOVED*** {
            return -1;
    ***REMOVED***
        unbuf = PyObject_IsInstance(file, io_raw***REMOVED***;
        Py_DECREF(io_raw***REMOVED***;
        if (unbuf == 1***REMOVED*** {
            /* Succeed if the IO is unbuffered */
            return 0;
    ***REMOVED***
        else {
            PyErr_SetString(PyExc_IOError, "seeking file failed"***REMOVED***;
            return -1;
    ***REMOVED***
***REMOVED***

    if (position == -1***REMOVED*** {
        PyErr_SetString(PyExc_IOError, "obtaining file position failed"***REMOVED***;
        return -1;
***REMOVED***

    /* Seek Python-side handle to the FILE* handle position */
    ret = PyObject_CallMethod(file, "seek", NPY_OFF_T_PYFMT "i", position, 0***REMOVED***;
    if (ret == NULL***REMOVED*** {
        return -1;
***REMOVED***
    Py_DECREF(ret***REMOVED***;
    return 0;
***REMOVED***

static NPY_INLINE int
npy_PyFile_Check(PyObject *file***REMOVED***
{
    int fd;
    fd = PyObject_AsFileDescriptor(file***REMOVED***;
    if (fd == -1***REMOVED*** {
        PyErr_Clear(***REMOVED***;
        return 0;
***REMOVED***
    return 1;
***REMOVED***

#else

static NPY_INLINE FILE *
npy_PyFile_Dup2(PyObject *file,
                const char *NPY_UNUSED(mode***REMOVED***, npy_off_t *NPY_UNUSED(orig_pos***REMOVED******REMOVED***
{
    FILE * fp = PyFile_AsFile(file***REMOVED***;
    if (fp == NULL***REMOVED*** {
        PyErr_SetString(PyExc_IOError,
                        "first argument must be an open file"***REMOVED***;
        return NULL;
***REMOVED***
    return fp;
***REMOVED***

static NPY_INLINE int
npy_PyFile_DupClose2(PyObject *NPY_UNUSED(file***REMOVED***, FILE* NPY_UNUSED(handle***REMOVED***,
                     npy_off_t NPY_UNUSED(orig_pos***REMOVED******REMOVED***
{
    return 0;
***REMOVED***

#define npy_PyFile_Check PyFile_Check

#endif

static NPY_INLINE PyObject*
npy_PyFile_OpenFile(PyObject *filename, const char *mode***REMOVED***
{
    PyObject *open;
    open = PyDict_GetItemString(PyEval_GetBuiltins(***REMOVED***, "open"***REMOVED***;
    if (open == NULL***REMOVED*** {
        return NULL;
***REMOVED***
    return PyObject_CallFunction(open, "Os", filename, mode***REMOVED***;
***REMOVED***

static NPY_INLINE int
npy_PyFile_CloseFile(PyObject *file***REMOVED***
{
    PyObject *ret;

    ret = PyObject_CallMethod(file, "close", NULL***REMOVED***;
    if (ret == NULL***REMOVED*** {
        return -1;
***REMOVED***
    Py_DECREF(ret***REMOVED***;
    return 0;
***REMOVED***

/*
 * PyObject_Cmp
 */
#if defined(NPY_PY3K***REMOVED***
static NPY_INLINE int
PyObject_Cmp(PyObject *i1, PyObject *i2, int *cmp***REMOVED***
{
    int v;
    v = PyObject_RichCompareBool(i1, i2, Py_LT***REMOVED***;
    if (v == 1***REMOVED*** {
        *cmp = -1;
        return 1;
***REMOVED***
    else if (v == -1***REMOVED*** {
        return -1;
***REMOVED***

    v = PyObject_RichCompareBool(i1, i2, Py_GT***REMOVED***;
    if (v == 1***REMOVED*** {
        *cmp = 1;
        return 1;
***REMOVED***
    else if (v == -1***REMOVED*** {
        return -1;
***REMOVED***

    v = PyObject_RichCompareBool(i1, i2, Py_EQ***REMOVED***;
    if (v == 1***REMOVED*** {
        *cmp = 0;
        return 1;
***REMOVED***
    else {
        *cmp = 0;
        return -1;
***REMOVED***
***REMOVED***
#endif

/*
 * PyCObject functions adapted to PyCapsules.
 *
 * The main job here is to get rid of the improved error handling
 * of PyCapsules. It's a shame...
 */
#if PY_VERSION_HEX >= 0x03000000

static NPY_INLINE PyObject *
NpyCapsule_FromVoidPtr(void *ptr, void (*dtor***REMOVED***(PyObject ****REMOVED******REMOVED***
{
    PyObject *ret = PyCapsule_New(ptr, NULL, dtor***REMOVED***;
    if (ret == NULL***REMOVED*** {
        PyErr_Clear(***REMOVED***;
***REMOVED***
    return ret;
***REMOVED***

static NPY_INLINE PyObject *
NpyCapsule_FromVoidPtrAndDesc(void *ptr, void* context, void (*dtor***REMOVED***(PyObject ****REMOVED******REMOVED***
{
    PyObject *ret = NpyCapsule_FromVoidPtr(ptr, dtor***REMOVED***;
    if (ret != NULL && PyCapsule_SetContext(ret, context***REMOVED*** != 0***REMOVED*** {
        PyErr_Clear(***REMOVED***;
        Py_DECREF(ret***REMOVED***;
        ret = NULL;
***REMOVED***
    return ret;
***REMOVED***

static NPY_INLINE void *
NpyCapsule_AsVoidPtr(PyObject *obj***REMOVED***
{
    void *ret = PyCapsule_GetPointer(obj, NULL***REMOVED***;
    if (ret == NULL***REMOVED*** {
        PyErr_Clear(***REMOVED***;
***REMOVED***
    return ret;
***REMOVED***

static NPY_INLINE void *
NpyCapsule_GetDesc(PyObject *obj***REMOVED***
{
    return PyCapsule_GetContext(obj***REMOVED***;
***REMOVED***

static NPY_INLINE int
NpyCapsule_Check(PyObject *ptr***REMOVED***
{
    return PyCapsule_CheckExact(ptr***REMOVED***;
***REMOVED***

#else

static NPY_INLINE PyObject *
NpyCapsule_FromVoidPtr(void *ptr, void (*dtor***REMOVED***(void ****REMOVED******REMOVED***
{
    return PyCObject_FromVoidPtr(ptr, dtor***REMOVED***;
***REMOVED***

static NPY_INLINE PyObject *
NpyCapsule_FromVoidPtrAndDesc(void *ptr, void* context,
        void (*dtor***REMOVED***(void *, void ****REMOVED******REMOVED***
{
    return PyCObject_FromVoidPtrAndDesc(ptr, context, dtor***REMOVED***;
***REMOVED***

static NPY_INLINE void *
NpyCapsule_AsVoidPtr(PyObject *ptr***REMOVED***
{
    return PyCObject_AsVoidPtr(ptr***REMOVED***;
***REMOVED***

static NPY_INLINE void *
NpyCapsule_GetDesc(PyObject *obj***REMOVED***
{
    return PyCObject_GetDesc(obj***REMOVED***;
***REMOVED***

static NPY_INLINE int
NpyCapsule_Check(PyObject *ptr***REMOVED***
{
    return PyCObject_Check(ptr***REMOVED***;
***REMOVED***

#endif

#ifdef __cplusplus
***REMOVED***
#endif

#endif /* _NPY_3KCOMPAT_H_ */
