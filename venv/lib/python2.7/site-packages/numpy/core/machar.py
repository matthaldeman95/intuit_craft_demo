***REMOVED***
Machine arithmetics - determine the parameters of the
floating-point arithmetic system

Author: Pearu Peterson, September 2003

***REMOVED***
from __future__ import division, absolute_import, print_function

__all__ = ['MachAr'***REMOVED***

from numpy.core.fromnumeric import any
from numpy.core.numeric import errstate

# Need to speed this up...especially for longfloat

class MachAr(object***REMOVED***:
    ***REMOVED***
    Diagnosing machine parameters.

    Attributes
    ----------
    ibeta : int
        Radix in which numbers are represented.
    it : int
        Number of base-`ibeta` digits in the floating point mantissa M.
    machep : int
        Exponent of the smallest (most negative***REMOVED*** power of `ibeta` that,
        added to 1.0, gives something different from 1.0
    eps : float
        Floating-point number ``beta**machep`` (floating point precision***REMOVED***
    negep : int
        Exponent of the smallest power of `ibeta` that, substracted
        from 1.0, gives something different from 1.0.
    epsneg : float
        Floating-point number ``beta**negep``.
    iexp : int
        Number of bits in the exponent (including its sign and bias***REMOVED***.
    minexp : int
        Smallest (most negative***REMOVED*** power of `ibeta` consistent with there
        being no leading zeros in the mantissa.
    xmin : float
        Floating point number ``beta**minexp`` (the smallest [in
        magnitude***REMOVED*** usable floating value***REMOVED***.
    maxexp : int
        Smallest (positive***REMOVED*** power of `ibeta` that causes overflow.
    xmax : float
        ``(1-epsneg***REMOVED*** * beta**maxexp`` (the largest [in magnitude***REMOVED***
        usable floating value***REMOVED***.
    irnd : int
        In ``range(6***REMOVED***``, information on what kind of rounding is done
        in addition, and on how underflow is handled.
    ngrd : int
        Number of 'guard digits' used when truncating the product
        of two mantissas to fit the representation.
    epsilon : float
        Same as `eps`.
    tiny : float
        Same as `xmin`.
    huge : float
        Same as `xmax`.
    precision : float
        ``- int(-log10(eps***REMOVED******REMOVED***``
    resolution : float
        ``- 10**(-precision***REMOVED***``

    Parameters
    ----------
    float_conv : function, optional
        Function that converts an integer or integer array to a float
        or float array. Default is `float`.
    int_conv : function, optional
        Function that converts a float or float array to an integer or
        integer array. Default is `int`.
    float_to_float : function, optional
        Function that converts a float array to float. Default is `float`.
        Note that this does not seem to do anything useful in the current
        implementation.
    float_to_str : function, optional
        Function that converts a single float to a string. Default is
        ``lambda v:'%24.16e' %v``.
    title : str, optional
        Title that is printed in the string representation of `MachAr`.

    See Also
    --------
    finfo : Machine limits for floating point types.
    iinfo : Machine limits for integer types.

    References
    ----------
    .. [1***REMOVED*** Press, Teukolsky, Vetterling and Flannery,
           "Numerical Recipes in C++," 2nd ed,
           Cambridge University Press, 2002, p. 31.

    ***REMOVED***

    def __init__(self, float_conv=float,int_conv=int,
                 float_to_float=float,
                 float_to_str=lambda v:'%24.16e' % v,
                 title='Python floating point number'***REMOVED***:
        ***REMOVED***

        float_conv - convert integer to float (array***REMOVED***
        int_conv   - convert float (array***REMOVED*** to integer
        float_to_float - convert float array to float
        float_to_str - convert array float to str
        title        - description of used floating point numbers

        ***REMOVED***
        # We ignore all errors here because we are purposely triggering
        # underflow to detect the properties of the runninng arch.
        with errstate(under='ignore'***REMOVED***:
            self._do_init(float_conv, int_conv, float_to_float, float_to_str, title***REMOVED***

    def _do_init(self, float_conv, int_conv, float_to_float, float_to_str, title***REMOVED***:
        max_iterN = 10000
        msg = "Did not converge after %d tries with %s"
        one = float_conv(1***REMOVED***
        two = one + one
        zero = one - one

        # Do we really need to do this?  Aren't they 2 and 2.0?
        # Determine ibeta and beta
        a = one
        for _ in range(max_iterN***REMOVED***:
            a = a + a
            temp = a + one
            temp1 = temp - a
            if any(temp1 - one != zero***REMOVED***:
                break
        else:
            raise RuntimeError(msg % (_, one.dtype***REMOVED******REMOVED***
        b = one
        for _ in range(max_iterN***REMOVED***:
            b = b + b
            temp = a + b
            itemp = int_conv(temp-a***REMOVED***
            if any(itemp != 0***REMOVED***:
                break
        else:
            raise RuntimeError(msg % (_, one.dtype***REMOVED******REMOVED***
        ibeta = itemp
        beta = float_conv(ibeta***REMOVED***

        # Determine it and irnd
        it = -1
        b = one
        for _ in range(max_iterN***REMOVED***:
            it = it + 1
            b = b * beta
            temp = b + one
            temp1 = temp - b
            if any(temp1 - one != zero***REMOVED***:
                break
        else:
            raise RuntimeError(msg % (_, one.dtype***REMOVED******REMOVED***

        betah = beta / two
        a = one
        for _ in range(max_iterN***REMOVED***:
            a = a + a
            temp = a + one
            temp1 = temp - a
            if any(temp1 - one != zero***REMOVED***:
                break
        else:
            raise RuntimeError(msg % (_, one.dtype***REMOVED******REMOVED***
        temp = a + betah
        irnd = 0
        if any(temp-a != zero***REMOVED***:
            irnd = 1
        tempa = a + beta
        temp = tempa + betah
        if irnd == 0 and any(temp-tempa != zero***REMOVED***:
            irnd = 2

        # Determine negep and epsneg
        negep = it + 3
        betain = one / beta
        a = one
        for i in range(negep***REMOVED***:
            a = a * betain
        b = a
        for _ in range(max_iterN***REMOVED***:
            temp = one - a
            if any(temp-one != zero***REMOVED***:
                break
            a = a * beta
            negep = negep - 1
            # Prevent infinite loop on PPC with gcc 4.0:
            if negep < 0:
                raise RuntimeError("could not determine machine tolerance "
                                   "for 'negep', locals(***REMOVED*** -> %s" % (locals(***REMOVED******REMOVED******REMOVED***
        else:
            raise RuntimeError(msg % (_, one.dtype***REMOVED******REMOVED***
        negep = -negep
        epsneg = a

        # Determine machep and eps
        machep = - it - 3
        a = b

        for _ in range(max_iterN***REMOVED***:
            temp = one + a
            if any(temp-one != zero***REMOVED***:
                break
            a = a * beta
            machep = machep + 1
        else:
            raise RuntimeError(msg % (_, one.dtype***REMOVED******REMOVED***
        eps = a

        # Determine ngrd
        ngrd = 0
        temp = one + eps
        if irnd == 0 and any(temp*one - one != zero***REMOVED***:
            ngrd = 1

        # Determine iexp
        i = 0
        k = 1
        z = betain
        t = one + eps
        nxres = 0
        for _ in range(max_iterN***REMOVED***:
            y = z
            z = y*y
            a = z*one  # Check here for underflow
            temp = z*t
            if any(a+a == zero***REMOVED*** or any(abs(z***REMOVED*** >= y***REMOVED***:
                break
            temp1 = temp * betain
            if any(temp1*beta == z***REMOVED***:
                break
            i = i + 1
            k = k + k
        else:
            raise RuntimeError(msg % (_, one.dtype***REMOVED******REMOVED***
        if ibeta != 10:
            iexp = i + 1
            mx = k + k
        else:
            iexp = 2
            iz = ibeta
            while k >= iz:
                iz = iz * ibeta
                iexp = iexp + 1
            mx = iz + iz - 1

        # Determine minexp and xmin
        for _ in range(max_iterN***REMOVED***:
            xmin = y
            y = y * betain
            a = y * one
            temp = y * t
            if any((a + a***REMOVED*** != zero***REMOVED*** and any(abs(y***REMOVED*** < xmin***REMOVED***:
                k = k + 1
                temp1 = temp * betain
                if any(temp1*beta == y***REMOVED*** and any(temp != y***REMOVED***:
                    nxres = 3
                    xmin = y
                    break
            else:
                break
        else:
            raise RuntimeError(msg % (_, one.dtype***REMOVED******REMOVED***
        minexp = -k

        # Determine maxexp, xmax
        if mx <= k + k - 3 and ibeta != 10:
            mx = mx + mx
            iexp = iexp + 1
        maxexp = mx + minexp
        irnd = irnd + nxres
        if irnd >= 2:
            maxexp = maxexp - 2
        i = maxexp + minexp
        if ibeta == 2 and not i:
            maxexp = maxexp - 1
        if i > 20:
            maxexp = maxexp - 1
        if any(a != y***REMOVED***:
            maxexp = maxexp - 2
        xmax = one - epsneg
        if any(xmax*one != xmax***REMOVED***:
            xmax = one - beta*epsneg
        xmax = xmax / (xmin*beta*beta*beta***REMOVED***
        i = maxexp + minexp + 3
        for j in range(i***REMOVED***:
            if ibeta == 2:
                xmax = xmax + xmax
            else:
                xmax = xmax * beta

        self.ibeta = ibeta
        self.it = it
        self.negep = negep
        self.epsneg = float_to_float(epsneg***REMOVED***
        self._str_epsneg = float_to_str(epsneg***REMOVED***
        self.machep = machep
        self.eps = float_to_float(eps***REMOVED***
        self._str_eps = float_to_str(eps***REMOVED***
        self.ngrd = ngrd
        self.iexp = iexp
        self.minexp = minexp
        self.xmin = float_to_float(xmin***REMOVED***
        self._str_xmin = float_to_str(xmin***REMOVED***
        self.maxexp = maxexp
        self.xmax = float_to_float(xmax***REMOVED***
        self._str_xmax = float_to_str(xmax***REMOVED***
        self.irnd = irnd

        self.title = title
        # Commonly used parameters
        self.epsilon = self.eps
        self.tiny = self.xmin
        self.huge = self.xmax

        import math
        self.precision = int(-math.log10(float_to_float(self.eps***REMOVED******REMOVED******REMOVED***
        ten = two + two + two + two + two
        resolution = ten ** (-self.precision***REMOVED***
        self.resolution = float_to_float(resolution***REMOVED***
        self._str_resolution = float_to_str(resolution***REMOVED***

    def __str__(self***REMOVED***:
        fmt = (
           'Machine parameters for %(title***REMOVED***s\n'
           '---------------------------------------------------------------------\n'
           'ibeta=%(ibeta***REMOVED***s it=%(it***REMOVED***s iexp=%(iexp***REMOVED***s ngrd=%(ngrd***REMOVED***s irnd=%(irnd***REMOVED***s\n'
           'machep=%(machep***REMOVED***s     eps=%(_str_eps***REMOVED***s (beta**machep == epsilon***REMOVED***\n'
           'negep =%(negep***REMOVED***s  epsneg=%(_str_epsneg***REMOVED***s (beta**epsneg***REMOVED***\n'
           'minexp=%(minexp***REMOVED***s   xmin=%(_str_xmin***REMOVED***s (beta**minexp == tiny***REMOVED***\n'
           'maxexp=%(maxexp***REMOVED***s    xmax=%(_str_xmax***REMOVED***s ((1-epsneg***REMOVED****beta**maxexp == huge***REMOVED***\n'
           '---------------------------------------------------------------------\n'
           ***REMOVED***
        return fmt % self.__dict__


if __name__ == '__main__':
    print(MachAr(***REMOVED******REMOVED***
