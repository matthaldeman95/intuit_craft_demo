from __future__ import division, print_function

***REMOVED***
import sys
import pickle
import copy
import warnings
from os.path import join
from numpy.distutils import log
from distutils.dep_util import newer
from distutils.sysconfig import get_config_var
from numpy._build_utils.apple_accelerate import (
    uses_accelerate_framework, get_sgemv_fix
    ***REMOVED***
from numpy.compat import npy_load_module
from setup_common import *

# Set to True to enable relaxed strides checking. This (mostly***REMOVED*** means
# that `strides[dim***REMOVED***` is ignored if `shape[dim***REMOVED*** == 1` when setting flags.
NPY_RELAXED_STRIDES_CHECKING = (os.environ.get('NPY_RELAXED_STRIDES_CHECKING', "0"***REMOVED*** != "0"***REMOVED***

# XXX: ugly, we use a class to avoid calling twice some expensive functions in
# config.h/numpyconfig.h. I don't see a better way because distutils force
# config.h generation inside an Extension class, and as such sharing
# configuration informations between extensions is not easy.
# Using a pickled-based memoize does not work because config_cmd is an instance
# method, which cPickle does not like.
#
# Use pickle in all cases, as cPickle is gone in python3 and the difference
# in time is only in build. -- Charles Harris, 2013-03-30

class CallOnceOnly(object***REMOVED***:
    def __init__(self***REMOVED***:
        self._check_types = None
        self._check_ieee_macros = None
        self._check_complex = None

    def check_types(self, *a, **kw***REMOVED***:
        if self._check_types is None:
            out = check_types(*a, **kw***REMOVED***
            self._check_types = pickle.dumps(out***REMOVED***
        else:
            out = copy.deepcopy(pickle.loads(self._check_types***REMOVED******REMOVED***
        return out

    def check_ieee_macros(self, *a, **kw***REMOVED***:
        if self._check_ieee_macros is None:
            out = check_ieee_macros(*a, **kw***REMOVED***
            self._check_ieee_macros = pickle.dumps(out***REMOVED***
        else:
            out = copy.deepcopy(pickle.loads(self._check_ieee_macros***REMOVED******REMOVED***
        return out

    def check_complex(self, *a, **kw***REMOVED***:
        if self._check_complex is None:
            out = check_complex(*a, **kw***REMOVED***
            self._check_complex = pickle.dumps(out***REMOVED***
        else:
            out = copy.deepcopy(pickle.loads(self._check_complex***REMOVED******REMOVED***
        return out

PYTHON_HAS_UNICODE_WIDE = True

def pythonlib_dir(***REMOVED***:
    ***REMOVED***return path where libpython* is.***REMOVED***
    if sys.platform == 'win32':
        return os.path.join(sys.prefix, "libs"***REMOVED***
    else:
        return get_config_var('LIBDIR'***REMOVED***

def is_npy_no_signal(***REMOVED***:
    ***REMOVED***Return True if the NPY_NO_SIGNAL symbol must be defined in configuration
    header.***REMOVED***
    return sys.platform == 'win32'

def is_npy_no_smp(***REMOVED***:
    ***REMOVED***Return True if the NPY_NO_SMP symbol must be defined in public
    header (when SMP support cannot be reliably enabled***REMOVED***.***REMOVED***
    # Perhaps a fancier check is in order here.
    #  so that threads are only enabled if there
    #  are actually multiple CPUS? -- but
    #  threaded code can be nice even on a single
    #  CPU so that long-calculating code doesn't
    #  block.
    return 'NPY_NOSMP' in os.environ

def win32_checks(deflist***REMOVED***:
    from numpy.distutils.misc_util import get_build_architecture
    a = get_build_architecture(***REMOVED***

    # Distutils hack on AMD64 on windows
    print('BUILD_ARCHITECTURE: %r, os.name=%r, sys.platform=%r' %
          (a, os.name, sys.platform***REMOVED******REMOVED***
    if a == 'AMD64':
        deflist.append('DISTUTILS_USE_SDK'***REMOVED***

    # On win32, force long double format string to be 'g', not
    # 'Lg', since the MS runtime does not support long double whose
    # size is > sizeof(double***REMOVED***
    if a == "Intel" or a == "AMD64":
        deflist.append('FORCE_NO_LONG_DOUBLE_FORMATTING'***REMOVED***

def check_math_capabilities(config, moredefs, mathlibs***REMOVED***:
    def check_func(func_name***REMOVED***:
        return config.check_func(func_name, libraries=mathlibs,
                                 decl=True, call=True***REMOVED***

    def check_funcs_once(funcs_name***REMOVED***:
        decl = dict([(f, True***REMOVED*** for f in funcs_name***REMOVED******REMOVED***
        st = config.check_funcs_once(funcs_name, libraries=mathlibs,
                                     decl=decl, call=decl***REMOVED***
        if st:
            moredefs.extend([(fname2def(f***REMOVED***, 1***REMOVED*** for f in funcs_name***REMOVED******REMOVED***
        return st

    def check_funcs(funcs_name***REMOVED***:
        # Use check_funcs_once first, and if it does not work, test func per
        # func. Return success only if all the functions are available
        if not check_funcs_once(funcs_name***REMOVED***:
            # Global check failed, check func per func
            for f in funcs_name:
                if check_func(f***REMOVED***:
                    moredefs.append((fname2def(f***REMOVED***, 1***REMOVED******REMOVED***
            return 0
        else:
            return 1

    #use_msvc = config.check_decl("_MSC_VER"***REMOVED***

    if not check_funcs_once(MANDATORY_FUNCS***REMOVED***:
        raise SystemError("One of the required function to build numpy is not"
                " available (the list is %s***REMOVED***." % str(MANDATORY_FUNCS***REMOVED******REMOVED***

    # Standard functions which may not be available and for which we have a
    # replacement implementation. Note that some of these are C99 functions.

    # XXX: hack to circumvent cpp pollution from python: python put its
    # config.h in the public namespace, so we have a clash for the common
    # functions we test. We remove every function tested by python's
    # autoconf, hoping their own test are correct
    for f in OPTIONAL_STDFUNCS_MAYBE:
        if config.check_decl(fname2def(f***REMOVED***,
                    headers=["Python.h", "math.h"***REMOVED******REMOVED***:
            OPTIONAL_STDFUNCS.remove(f***REMOVED***

    check_funcs(OPTIONAL_STDFUNCS***REMOVED***

    for h in OPTIONAL_HEADERS:
        if config.check_func("", decl=False, call=False, headers=[h***REMOVED******REMOVED***:
            moredefs.append((fname2def(h***REMOVED***.replace(".", "_"***REMOVED***, 1***REMOVED******REMOVED***

    for tup in OPTIONAL_INTRINSICS:
        headers = None
        if len(tup***REMOVED*** == 2:
            f, args = tup
        else:
            f, args, headers = tup[0***REMOVED***, tup[1***REMOVED***, [tup[2***REMOVED******REMOVED***
        if config.check_func(f, decl=False, call=True, call_args=args,
                             headers=headers***REMOVED***:
            moredefs.append((fname2def(f***REMOVED***, 1***REMOVED******REMOVED***

    for dec, fn in OPTIONAL_FUNCTION_ATTRIBUTES:
        if config.check_gcc_function_attribute(dec, fn***REMOVED***:
            moredefs.append((fname2def(fn***REMOVED***, 1***REMOVED******REMOVED***

    for fn in OPTIONAL_VARIABLE_ATTRIBUTES:
        if config.check_gcc_variable_attribute(fn***REMOVED***:
            m = fn.replace("(", "_"***REMOVED***.replace("***REMOVED***", "_"***REMOVED***
            moredefs.append((fname2def(m***REMOVED***, 1***REMOVED******REMOVED***

    # C99 functions: float and long double versions
    check_funcs(C99_FUNCS_SINGLE***REMOVED***
    check_funcs(C99_FUNCS_EXTENDED***REMOVED***

def check_complex(config, mathlibs***REMOVED***:
    priv = [***REMOVED***
    pub = [***REMOVED***

    ***REMOVED***
        if os.uname(***REMOVED***[0***REMOVED*** == "Interix":
            warnings.warn("Disabling broken complex support. See #1365"***REMOVED***
            return priv, pub
    ***REMOVED***
        # os.uname not available on all platforms. blanket except ugly but safe
        pass

    # Check for complex support
    st = config.check_header('complex.h'***REMOVED***
    if st:
        priv.append(('HAVE_COMPLEX_H', 1***REMOVED******REMOVED***
        pub.append(('NPY_USE_C99_COMPLEX', 1***REMOVED******REMOVED***

        for t in C99_COMPLEX_TYPES:
            st = config.check_type(t, headers=["complex.h"***REMOVED******REMOVED***
            if st:
                pub.append(('NPY_HAVE_%s' % type2def(t***REMOVED***, 1***REMOVED******REMOVED***

        def check_prec(prec***REMOVED***:
            flist = [f + prec for f in C99_COMPLEX_FUNCS***REMOVED***
            decl = dict([(f, True***REMOVED*** for f in flist***REMOVED******REMOVED***
            if not config.check_funcs_once(flist, call=decl, decl=decl,
                                           libraries=mathlibs***REMOVED***:
                for f in flist:
                    if config.check_func(f, call=True, decl=True,
                                         libraries=mathlibs***REMOVED***:
                        priv.append((fname2def(f***REMOVED***, 1***REMOVED******REMOVED***
            else:
                priv.extend([(fname2def(f***REMOVED***, 1***REMOVED*** for f in flist***REMOVED******REMOVED***

        check_prec(''***REMOVED***
        check_prec('f'***REMOVED***
        check_prec('l'***REMOVED***

    return priv, pub

def check_ieee_macros(config***REMOVED***:
    priv = [***REMOVED***
    pub = [***REMOVED***

    macros = [***REMOVED***

    def _add_decl(f***REMOVED***:
        priv.append(fname2def("decl_%s" % f***REMOVED******REMOVED***
        pub.append('NPY_%s' % fname2def("decl_%s" % f***REMOVED******REMOVED***

    # XXX: hack to circumvent cpp pollution from python: python put its
    # config.h in the public namespace, so we have a clash for the common
    # functions we test. We remove every function tested by python's
    # autoconf, hoping their own test are correct
    _macros = ["isnan", "isinf", "signbit", "isfinite"***REMOVED***
    for f in _macros:
        py_symbol = fname2def("decl_%s" % f***REMOVED***
        already_declared = config.check_decl(py_symbol,
                headers=["Python.h", "math.h"***REMOVED******REMOVED***
        if already_declared:
            if config.check_macro_true(py_symbol,
                    headers=["Python.h", "math.h"***REMOVED******REMOVED***:
                pub.append('NPY_%s' % fname2def("decl_%s" % f***REMOVED******REMOVED***
        else:
            macros.append(f***REMOVED***
    # Normally, isnan and isinf are macro (C99***REMOVED***, but some platforms only have
    # func, or both func and macro version. Check for macro only, and define
    # replacement ones if not found.
    # Note: including Python.h is necessary because it modifies some math.h
    # definitions
    for f in macros:
        st = config.check_decl(f, headers=["Python.h", "math.h"***REMOVED******REMOVED***
        if st:
            _add_decl(f***REMOVED***

    return priv, pub

def check_types(config_cmd, ext, build_dir***REMOVED***:
    private_defines = [***REMOVED***
    public_defines = [***REMOVED***

    # Expected size (in number of bytes***REMOVED*** for each type. This is an
    # optimization: those are only hints, and an exhaustive search for the size
    # is done if the hints are wrong.
    expected = {'short': [2***REMOVED***, 'int': [4***REMOVED***, 'long': [8, 4***REMOVED***,
                'float': [4***REMOVED***, 'double': [8***REMOVED***, 'long double': [16, 12, 8***REMOVED***,
                'Py_intptr_t': [8, 4***REMOVED***, 'PY_LONG_LONG': [8***REMOVED***, 'long long': [8***REMOVED***,
                'off_t': [8, 4***REMOVED******REMOVED***

    # Check we have the python header (-dev* packages on Linux***REMOVED***
    result = config_cmd.check_header('Python.h'***REMOVED***
    if not result:
        raise SystemError(
                "Cannot compile 'Python.h'. Perhaps you need to "
                "install python-dev|python-devel."***REMOVED***
    res = config_cmd.check_header("endian.h"***REMOVED***
    if res:
        private_defines.append(('HAVE_ENDIAN_H', 1***REMOVED******REMOVED***
        public_defines.append(('NPY_HAVE_ENDIAN_H', 1***REMOVED******REMOVED***

    # Check basic types sizes
    for type in ('short', 'int', 'long'***REMOVED***:
        res = config_cmd.check_decl("SIZEOF_%s" % sym2def(type***REMOVED***, headers=["Python.h"***REMOVED******REMOVED***
        if res:
            public_defines.append(('NPY_SIZEOF_%s' % sym2def(type***REMOVED***, "SIZEOF_%s" % sym2def(type***REMOVED******REMOVED******REMOVED***
        else:
            res = config_cmd.check_type_size(type, expected=expected[type***REMOVED******REMOVED***
            if res >= 0:
                public_defines.append(('NPY_SIZEOF_%s' % sym2def(type***REMOVED***, '%d' % res***REMOVED******REMOVED***
            else:
                raise SystemError("Checking sizeof (%s***REMOVED*** failed !" % type***REMOVED***

    for type in ('float', 'double', 'long double'***REMOVED***:
        already_declared = config_cmd.check_decl("SIZEOF_%s" % sym2def(type***REMOVED***,
                                                 headers=["Python.h"***REMOVED******REMOVED***
        res = config_cmd.check_type_size(type, expected=expected[type***REMOVED******REMOVED***
        if res >= 0:
            public_defines.append(('NPY_SIZEOF_%s' % sym2def(type***REMOVED***, '%d' % res***REMOVED******REMOVED***
            if not already_declared and not type == 'long double':
                private_defines.append(('SIZEOF_%s' % sym2def(type***REMOVED***, '%d' % res***REMOVED******REMOVED***
        else:
            raise SystemError("Checking sizeof (%s***REMOVED*** failed !" % type***REMOVED***

        # Compute size of corresponding complex type: used to check that our
        # definition is binary compatible with C99 complex type (check done at
        # build time in npy_common.h***REMOVED***
        complex_def = "struct {%s __x; %s __y;***REMOVED***" % (type, type***REMOVED***
        res = config_cmd.check_type_size(complex_def,
                                         expected=[2 * x for x in expected[type***REMOVED******REMOVED******REMOVED***
        if res >= 0:
            public_defines.append(('NPY_SIZEOF_COMPLEX_%s' % sym2def(type***REMOVED***, '%d' % res***REMOVED******REMOVED***
        else:
            raise SystemError("Checking sizeof (%s***REMOVED*** failed !" % complex_def***REMOVED***

    for type in ('Py_intptr_t', 'off_t'***REMOVED***:
        res = config_cmd.check_type_size(type, headers=["Python.h"***REMOVED***,
                library_dirs=[pythonlib_dir(***REMOVED******REMOVED***,
                expected=expected[type***REMOVED******REMOVED***

        if res >= 0:
            private_defines.append(('SIZEOF_%s' % sym2def(type***REMOVED***, '%d' % res***REMOVED******REMOVED***
            public_defines.append(('NPY_SIZEOF_%s' % sym2def(type***REMOVED***, '%d' % res***REMOVED******REMOVED***
        else:
            raise SystemError("Checking sizeof (%s***REMOVED*** failed !" % type***REMOVED***

    # We check declaration AND type because that's how distutils does it.
    if config_cmd.check_decl('PY_LONG_LONG', headers=['Python.h'***REMOVED******REMOVED***:
        res = config_cmd.check_type_size('PY_LONG_LONG',  headers=['Python.h'***REMOVED***,
                library_dirs=[pythonlib_dir(***REMOVED******REMOVED***,
                expected=expected['PY_LONG_LONG'***REMOVED******REMOVED***
        if res >= 0:
            private_defines.append(('SIZEOF_%s' % sym2def('PY_LONG_LONG'***REMOVED***, '%d' % res***REMOVED******REMOVED***
            public_defines.append(('NPY_SIZEOF_%s' % sym2def('PY_LONG_LONG'***REMOVED***, '%d' % res***REMOVED******REMOVED***
        else:
            raise SystemError("Checking sizeof (%s***REMOVED*** failed !" % 'PY_LONG_LONG'***REMOVED***

        res = config_cmd.check_type_size('long long',
                expected=expected['long long'***REMOVED******REMOVED***
        if res >= 0:
            #private_defines.append(('SIZEOF_%s' % sym2def('long long'***REMOVED***, '%d' % res***REMOVED******REMOVED***
            public_defines.append(('NPY_SIZEOF_%s' % sym2def('long long'***REMOVED***, '%d' % res***REMOVED******REMOVED***
        else:
            raise SystemError("Checking sizeof (%s***REMOVED*** failed !" % 'long long'***REMOVED***

    if not config_cmd.check_decl('CHAR_BIT', headers=['Python.h'***REMOVED******REMOVED***:
        raise RuntimeError(
            "Config wo CHAR_BIT is not supported"
            ", please contact the maintainers"***REMOVED***

    return private_defines, public_defines

def check_mathlib(config_cmd***REMOVED***:
    # Testing the C math library
    mathlibs = [***REMOVED***
    mathlibs_choices = [[***REMOVED***, ['m'***REMOVED***, ['cpml'***REMOVED******REMOVED***
    mathlib = os.environ.get('MATHLIB'***REMOVED***
    if mathlib:
        mathlibs_choices.insert(0, mathlib.split(','***REMOVED******REMOVED***
    for libs in mathlibs_choices:
        if config_cmd.check_func("exp", libraries=libs, decl=True, call=True***REMOVED***:
            mathlibs = libs
            break
    else:
        raise EnvironmentError("math library missing; rerun "
                               "setup.py after setting the "
                               "MATHLIB env variable"***REMOVED***
    return mathlibs

def visibility_define(config***REMOVED***:
    ***REMOVED***Return the define value to use for NPY_VISIBILITY_HIDDEN (may be empty
    string***REMOVED***.***REMOVED***
    if config.check_compiler_gcc4(***REMOVED***:
        return '__attribute__((visibility("hidden"***REMOVED******REMOVED******REMOVED***'
    else:
        return ''

def configuration(parent_package='',top_path=None***REMOVED***:
    from numpy.distutils.misc_util import Configuration, dot_join
    from numpy.distutils.system_info import get_info

    config = Configuration('core', parent_package, top_path***REMOVED***
    local_dir = config.local_path
    codegen_dir = join(local_dir, 'code_generators'***REMOVED***

    if is_released(config***REMOVED***:
        warnings.simplefilter('error', MismatchCAPIWarning***REMOVED***

    # Check whether we have a mismatch between the set C API VERSION and the
    # actual C API VERSION
    check_api_version(C_API_VERSION, codegen_dir***REMOVED***

    generate_umath_py = join(codegen_dir, 'generate_umath.py'***REMOVED***
    n = dot_join(config.name, 'generate_umath'***REMOVED***
    generate_umath = npy_load_module('_'.join(n.split('.'***REMOVED******REMOVED***,
                                     generate_umath_py, ('.py', 'U', 1***REMOVED******REMOVED***

    header_dir = 'include/numpy'  # this is relative to config.path_in_package

    cocache = CallOnceOnly(***REMOVED***

    def generate_config_h(ext, build_dir***REMOVED***:
        target = join(build_dir, header_dir, 'config.h'***REMOVED***
        d = os.path.dirname(target***REMOVED***
        if not os.path.exists(d***REMOVED***:
            os.makedirs(d***REMOVED***

        if newer(__file__, target***REMOVED***:
            config_cmd = config.get_config_cmd(***REMOVED***
            log.info('Generating %s', target***REMOVED***

            # Check sizeof
            moredefs, ignored = cocache.check_types(config_cmd, ext, build_dir***REMOVED***

            # Check math library and C99 math funcs availability
            mathlibs = check_mathlib(config_cmd***REMOVED***
            moredefs.append(('MATHLIB', ','.join(mathlibs***REMOVED******REMOVED******REMOVED***

            check_math_capabilities(config_cmd, moredefs, mathlibs***REMOVED***
            moredefs.extend(cocache.check_ieee_macros(config_cmd***REMOVED***[0***REMOVED******REMOVED***
            moredefs.extend(cocache.check_complex(config_cmd, mathlibs***REMOVED***[0***REMOVED******REMOVED***

            # Signal check
            if is_npy_no_signal(***REMOVED***:
                moredefs.append('__NPY_PRIVATE_NO_SIGNAL'***REMOVED***

            # Windows checks
            if sys.platform == 'win32' or os.name == 'nt':
                win32_checks(moredefs***REMOVED***

            # C99 restrict keyword
            moredefs.append(('NPY_RESTRICT', config_cmd.check_restrict(***REMOVED******REMOVED******REMOVED***

            # Inline check
            inline = config_cmd.check_inline(***REMOVED***

            # Check whether we need our own wide character support
            if not config_cmd.check_decl('Py_UNICODE_WIDE', headers=['Python.h'***REMOVED******REMOVED***:
                PYTHON_HAS_UNICODE_WIDE = True
            else:
                PYTHON_HAS_UNICODE_WIDE = False

            if NPY_RELAXED_STRIDES_CHECKING:
                moredefs.append(('NPY_RELAXED_STRIDES_CHECKING', 1***REMOVED******REMOVED***

            # Get long double representation
            if sys.platform != 'darwin':
                rep = check_long_double_representation(config_cmd***REMOVED***
                if rep in ['INTEL_EXTENDED_12_BYTES_LE',
                           'INTEL_EXTENDED_16_BYTES_LE',
                           'MOTOROLA_EXTENDED_12_BYTES_BE',
                           'IEEE_QUAD_LE', 'IEEE_QUAD_BE',
                           'IEEE_DOUBLE_LE', 'IEEE_DOUBLE_BE',
                           'DOUBLE_DOUBLE_BE', 'DOUBLE_DOUBLE_LE'***REMOVED***:
                    moredefs.append(('HAVE_LDOUBLE_%s' % rep, 1***REMOVED******REMOVED***
                else:
                    raise ValueError("Unrecognized long double format: %s" % rep***REMOVED***

            # Py3K check
            if sys.version_info[0***REMOVED*** == 3:
                moredefs.append(('NPY_PY3K', 1***REMOVED******REMOVED***

            # Generate the config.h file from moredefs
            target_f = open(target, 'w'***REMOVED***
            for d in moredefs:
                if isinstance(d, str***REMOVED***:
                    target_f.write('#define %s\n' % (d***REMOVED******REMOVED***
                else:
                    target_f.write('#define %s %s\n' % (d[0***REMOVED***, d[1***REMOVED******REMOVED******REMOVED***

            # define inline to our keyword, or nothing
            target_f.write('#ifndef __cplusplus\n'***REMOVED***
            if inline == 'inline':
                target_f.write('/* #undef inline */\n'***REMOVED***
            else:
                target_f.write('#define inline %s\n' % inline***REMOVED***
            target_f.write('#endif\n'***REMOVED***

            # add the guard to make sure config.h is never included directly,
            # but always through npy_config.h
            target_f.write(***REMOVED***
#ifndef _NPY_NPY_CONFIG_H_
#error config.h should never be included directly, include npy_config.h instead
#endif
***REMOVED******REMOVED***

            target_f.close(***REMOVED***
            print('File:', target***REMOVED***
            target_f = open(target***REMOVED***
            print(target_f.read(***REMOVED******REMOVED***
            target_f.close(***REMOVED***
            print('EOF'***REMOVED***
        else:
            mathlibs = [***REMOVED***
            target_f = open(target***REMOVED***
            for line in target_f:
                s = '#define MATHLIB'
                if line.startswith(s***REMOVED***:
                    value = line[len(s***REMOVED***:***REMOVED***.strip(***REMOVED***
                    if value:
                        mathlibs.extend(value.split(','***REMOVED******REMOVED***
            target_f.close(***REMOVED***

        # Ugly: this can be called within a library and not an extension,
        # in which case there is no libraries attributes (and none is
        # needed***REMOVED***.
        if hasattr(ext, 'libraries'***REMOVED***:
            ext.libraries.extend(mathlibs***REMOVED***

        incl_dir = os.path.dirname(target***REMOVED***
        if incl_dir not in config.numpy_include_dirs:
            config.numpy_include_dirs.append(incl_dir***REMOVED***

        return target

    def generate_numpyconfig_h(ext, build_dir***REMOVED***:
        ***REMOVED***Depends on config.h: generate_config_h has to be called before !***REMOVED***
        # put private include directory in build_dir on search path
        # allows using code generation in headers headers
        config.add_include_dirs(join(build_dir, "src", "private"***REMOVED******REMOVED***

        target = join(build_dir, header_dir, '_numpyconfig.h'***REMOVED***
        d = os.path.dirname(target***REMOVED***
        if not os.path.exists(d***REMOVED***:
            os.makedirs(d***REMOVED***
        if newer(__file__, target***REMOVED***:
            config_cmd = config.get_config_cmd(***REMOVED***
            log.info('Generating %s', target***REMOVED***

            # Check sizeof
            ignored, moredefs = cocache.check_types(config_cmd, ext, build_dir***REMOVED***

            if is_npy_no_signal(***REMOVED***:
                moredefs.append(('NPY_NO_SIGNAL', 1***REMOVED******REMOVED***

            if is_npy_no_smp(***REMOVED***:
                moredefs.append(('NPY_NO_SMP', 1***REMOVED******REMOVED***
            else:
                moredefs.append(('NPY_NO_SMP', 0***REMOVED******REMOVED***

            mathlibs = check_mathlib(config_cmd***REMOVED***
            moredefs.extend(cocache.check_ieee_macros(config_cmd***REMOVED***[1***REMOVED******REMOVED***
            moredefs.extend(cocache.check_complex(config_cmd, mathlibs***REMOVED***[1***REMOVED******REMOVED***

            if NPY_RELAXED_STRIDES_CHECKING:
                moredefs.append(('NPY_RELAXED_STRIDES_CHECKING', 1***REMOVED******REMOVED***

            # Check wether we can use inttypes (C99***REMOVED*** formats
            if config_cmd.check_decl('PRIdPTR', headers=['inttypes.h'***REMOVED******REMOVED***:
                moredefs.append(('NPY_USE_C99_FORMATS', 1***REMOVED******REMOVED***

            # visibility check
            hidden_visibility = visibility_define(config_cmd***REMOVED***
            moredefs.append(('NPY_VISIBILITY_HIDDEN', hidden_visibility***REMOVED******REMOVED***

            # Add the C API/ABI versions
            moredefs.append(('NPY_ABI_VERSION', '0x%.8X' % C_ABI_VERSION***REMOVED******REMOVED***
            moredefs.append(('NPY_API_VERSION', '0x%.8X' % C_API_VERSION***REMOVED******REMOVED***

            # Add moredefs to header
            target_f = open(target, 'w'***REMOVED***
            for d in moredefs:
                if isinstance(d, str***REMOVED***:
                    target_f.write('#define %s\n' % (d***REMOVED******REMOVED***
                else:
                    target_f.write('#define %s %s\n' % (d[0***REMOVED***, d[1***REMOVED******REMOVED******REMOVED***

            # Define __STDC_FORMAT_MACROS
            target_f.write(***REMOVED***
#ifndef __STDC_FORMAT_MACROS
#define __STDC_FORMAT_MACROS 1
#endif
***REMOVED******REMOVED***
            target_f.close(***REMOVED***

            # Dump the numpyconfig.h header to stdout
            print('File: %s' % target***REMOVED***
            target_f = open(target***REMOVED***
            print(target_f.read(***REMOVED******REMOVED***
            target_f.close(***REMOVED***
            print('EOF'***REMOVED***
        config.add_data_files((header_dir, target***REMOVED******REMOVED***
        return target

    def generate_api_func(module_name***REMOVED***:
        def generate_api(ext, build_dir***REMOVED***:
            script = join(codegen_dir, module_name + '.py'***REMOVED***
            sys.path.insert(0, codegen_dir***REMOVED***
            ***REMOVED***
                m = __import__(module_name***REMOVED***
                log.info('executing %s', script***REMOVED***
                h_file, c_file, doc_file = m.generate_api(os.path.join(build_dir, header_dir***REMOVED******REMOVED***
            finally:
                del sys.path[0***REMOVED***
            config.add_data_files((header_dir, h_file***REMOVED***,
                                  (header_dir, doc_file***REMOVED******REMOVED***
            return (h_file,***REMOVED***
        return generate_api

    generate_numpy_api = generate_api_func('generate_numpy_api'***REMOVED***
    generate_ufunc_api = generate_api_func('generate_ufunc_api'***REMOVED***

    config.add_include_dirs(join(local_dir, "src", "private"***REMOVED******REMOVED***
    config.add_include_dirs(join(local_dir, "src"***REMOVED******REMOVED***
    config.add_include_dirs(join(local_dir***REMOVED******REMOVED***

    config.add_data_files('include/numpy/*.h'***REMOVED***
    config.add_include_dirs(join('src', 'npymath'***REMOVED******REMOVED***
    config.add_include_dirs(join('src', 'multiarray'***REMOVED******REMOVED***
    config.add_include_dirs(join('src', 'umath'***REMOVED******REMOVED***
    config.add_include_dirs(join('src', 'npysort'***REMOVED******REMOVED***

    config.add_define_macros([("HAVE_NPY_CONFIG_H", "1"***REMOVED******REMOVED******REMOVED***
    config.add_define_macros([("_FILE_OFFSET_BITS", "64"***REMOVED******REMOVED******REMOVED***
    config.add_define_macros([('_LARGEFILE_SOURCE', '1'***REMOVED******REMOVED******REMOVED***
    config.add_define_macros([('_LARGEFILE64_SOURCE', '1'***REMOVED******REMOVED******REMOVED***

    config.numpy_include_dirs.extend(config.paths('include'***REMOVED******REMOVED***

    deps = [join('src', 'npymath', '_signbit.c'***REMOVED***,
            join('include', 'numpy', '*object.h'***REMOVED***,
            join(codegen_dir, 'genapi.py'***REMOVED***,
            ***REMOVED***

    #######################################################################
    #                            dummy module                             #
    #######################################################################

    # npymath needs the config.h and numpyconfig.h files to be generated, but
    # build_clib cannot handle generate_config_h and generate_numpyconfig_h
    # (don't ask***REMOVED***. Because clib are generated before extensions, we have to
    # explicitly add an extension which has generate_config_h and
    # generate_numpyconfig_h as sources *before* adding npymath.

    config.add_extension('_dummy',
                         sources=[join('src', 'dummymodule.c'***REMOVED***,
                                  generate_config_h,
                                  generate_numpyconfig_h,
                                  generate_numpy_api***REMOVED***
                         ***REMOVED***

    #######################################################################
    #                          npymath library                            #
    #######################################################################

    subst_dict = dict([("sep", os.path.sep***REMOVED***, ("pkgname", "numpy.core"***REMOVED******REMOVED******REMOVED***

    def get_mathlib_info(*args***REMOVED***:
        # Another ugly hack: the mathlib info is known once build_src is run,
        # but we cannot use add_installed_pkg_config here either, so we only
        # update the substition dictionary during npymath build
        config_cmd = config.get_config_cmd(***REMOVED***

        # Check that the toolchain works, to fail early if it doesn't
        # (avoid late errors with MATHLIB which are confusing if the
        # compiler does not work***REMOVED***.
        st = config_cmd.try_link('int main(void***REMOVED*** { return 0;***REMOVED***'***REMOVED***
        if not st:
            raise RuntimeError("Broken toolchain: cannot link a simple C program"***REMOVED***
        mlibs = check_mathlib(config_cmd***REMOVED***

        posix_mlib = ' '.join(['-l%s' % l for l in mlibs***REMOVED******REMOVED***
        msvc_mlib = ' '.join(['%s.lib' % l for l in mlibs***REMOVED******REMOVED***
        subst_dict["posix_mathlib"***REMOVED*** = posix_mlib
        subst_dict["msvc_mathlib"***REMOVED*** = msvc_mlib

    npymath_sources = [join('src', 'npymath', 'npy_math.c.src'***REMOVED***,
                       join('src', 'npymath', 'ieee754.c.src'***REMOVED***,
                       join('src', 'npymath', 'npy_math_complex.c.src'***REMOVED***,
                       join('src', 'npymath', 'halffloat.c'***REMOVED***
                       ***REMOVED***
    config.add_installed_library('npymath',
            sources=npymath_sources + [get_mathlib_info***REMOVED***,
            install_dir='lib'***REMOVED***
    config.add_npy_pkg_config("npymath.ini.in", "lib/npy-pkg-config",
            subst_dict***REMOVED***
    config.add_npy_pkg_config("mlib.ini.in", "lib/npy-pkg-config",
            subst_dict***REMOVED***

    #######################################################################
    #                         npysort library                             #
    #######################################################################

    # This library is created for the build but it is not installed
    npysort_sources = [join('src', 'npysort', 'quicksort.c.src'***REMOVED***,
                       join('src', 'npysort', 'mergesort.c.src'***REMOVED***,
                       join('src', 'npysort', 'heapsort.c.src'***REMOVED***,
                       join('src', 'private', 'npy_partition.h.src'***REMOVED***,
                       join('src', 'npysort', 'selection.c.src'***REMOVED***,
                       join('src', 'private', 'npy_binsearch.h.src'***REMOVED***,
                       join('src', 'npysort', 'binsearch.c.src'***REMOVED***,
                       ***REMOVED***
    config.add_library('npysort',
                       sources=npysort_sources,
                       include_dirs=[***REMOVED******REMOVED***

    #######################################################################
    #                        multiarray module                            #
    #######################################################################

    # Multiarray version: this function is needed to build foo.c from foo.c.src
    # when foo.c is included in another file and as such not in the src
    # argument of build_ext command
    def generate_multiarray_templated_sources(ext, build_dir***REMOVED***:
        from numpy.distutils.misc_util import get_cmd

        subpath = join('src', 'multiarray'***REMOVED***
        sources = [join(local_dir, subpath, 'scalartypes.c.src'***REMOVED***,
                   join(local_dir, subpath, 'arraytypes.c.src'***REMOVED***,
                   join(local_dir, subpath, 'nditer_templ.c.src'***REMOVED***,
                   join(local_dir, subpath, 'lowlevel_strided_loops.c.src'***REMOVED***,
                   join(local_dir, subpath, 'einsum.c.src'***REMOVED***,
                   join(local_dir, 'src', 'private', 'templ_common.h.src'***REMOVED***
                   ***REMOVED***

        # numpy.distutils generate .c from .c.src in weird directories, we have
        # to add them there as they depend on the build_dir
        config.add_include_dirs(join(build_dir, subpath***REMOVED******REMOVED***
        cmd = get_cmd('build_src'***REMOVED***
        cmd.ensure_finalized(***REMOVED***
        cmd.template_sources(sources, ext***REMOVED***

    multiarray_deps = [
            join('src', 'multiarray', 'arrayobject.h'***REMOVED***,
            join('src', 'multiarray', 'arraytypes.h'***REMOVED***,
            join('src', 'multiarray', 'array_assign.h'***REMOVED***,
            join('src', 'multiarray', 'buffer.h'***REMOVED***,
            join('src', 'multiarray', 'calculation.h'***REMOVED***,
            join('src', 'multiarray', 'cblasfuncs.h'***REMOVED***,
            join('src', 'multiarray', 'common.h'***REMOVED***,
            join('src', 'multiarray', 'convert_datatype.h'***REMOVED***,
            join('src', 'multiarray', 'convert.h'***REMOVED***,
            join('src', 'multiarray', 'conversion_utils.h'***REMOVED***,
            join('src', 'multiarray', 'ctors.h'***REMOVED***,
            join('src', 'multiarray', 'descriptor.h'***REMOVED***,
            join('src', 'multiarray', 'getset.h'***REMOVED***,
            join('src', 'multiarray', 'hashdescr.h'***REMOVED***,
            join('src', 'multiarray', 'iterators.h'***REMOVED***,
            join('src', 'multiarray', 'mapping.h'***REMOVED***,
            join('src', 'multiarray', 'methods.h'***REMOVED***,
            join('src', 'multiarray', 'multiarraymodule.h'***REMOVED***,
            join('src', 'multiarray', 'nditer_impl.h'***REMOVED***,
            join('src', 'multiarray', 'numpymemoryview.h'***REMOVED***,
            join('src', 'multiarray', 'number.h'***REMOVED***,
            join('src', 'multiarray', 'numpyos.h'***REMOVED***,
            join('src', 'multiarray', 'refcount.h'***REMOVED***,
            join('src', 'multiarray', 'scalartypes.h'***REMOVED***,
            join('src', 'multiarray', 'sequence.h'***REMOVED***,
            join('src', 'multiarray', 'shape.h'***REMOVED***,
            join('src', 'multiarray', 'ucsnarrow.h'***REMOVED***,
            join('src', 'multiarray', 'usertypes.h'***REMOVED***,
            join('src', 'multiarray', 'vdot.h'***REMOVED***,
            join('src', 'private', 'npy_config.h'***REMOVED***,
            join('src', 'private', 'templ_common.h.src'***REMOVED***,
            join('src', 'private', 'lowlevel_strided_loops.h'***REMOVED***,
            join('src', 'private', 'mem_overlap.h'***REMOVED***,
            join('src', 'private', 'npy_extint128.h'***REMOVED***,
            join('include', 'numpy', 'arrayobject.h'***REMOVED***,
            join('include', 'numpy', '_neighborhood_iterator_imp.h'***REMOVED***,
            join('include', 'numpy', 'npy_endian.h'***REMOVED***,
            join('include', 'numpy', 'arrayscalars.h'***REMOVED***,
            join('include', 'numpy', 'noprefix.h'***REMOVED***,
            join('include', 'numpy', 'npy_interrupt.h'***REMOVED***,
            join('include', 'numpy', 'npy_3kcompat.h'***REMOVED***,
            join('include', 'numpy', 'npy_math.h'***REMOVED***,
            join('include', 'numpy', 'halffloat.h'***REMOVED***,
            join('include', 'numpy', 'npy_common.h'***REMOVED***,
            join('include', 'numpy', 'npy_os.h'***REMOVED***,
            join('include', 'numpy', 'utils.h'***REMOVED***,
            join('include', 'numpy', 'ndarrayobject.h'***REMOVED***,
            join('include', 'numpy', 'npy_cpu.h'***REMOVED***,
            join('include', 'numpy', 'numpyconfig.h'***REMOVED***,
            join('include', 'numpy', 'ndarraytypes.h'***REMOVED***,
            join('include', 'numpy', 'npy_1_7_deprecated_api.h'***REMOVED***,
            join('include', 'numpy', '_numpyconfig.h.in'***REMOVED***,
            # add library sources as distuils does not consider libraries
            # dependencies
            ***REMOVED*** + npysort_sources + npymath_sources

    multiarray_src = [
            join('src', 'multiarray', 'alloc.c'***REMOVED***,
            join('src', 'multiarray', 'arrayobject.c'***REMOVED***,
            join('src', 'multiarray', 'arraytypes.c.src'***REMOVED***,
            join('src', 'multiarray', 'array_assign.c'***REMOVED***,
            join('src', 'multiarray', 'array_assign_scalar.c'***REMOVED***,
            join('src', 'multiarray', 'array_assign_array.c'***REMOVED***,
            join('src', 'multiarray', 'buffer.c'***REMOVED***,
            join('src', 'multiarray', 'calculation.c'***REMOVED***,
            join('src', 'multiarray', 'compiled_base.c'***REMOVED***,
            join('src', 'multiarray', 'common.c'***REMOVED***,
            join('src', 'multiarray', 'convert.c'***REMOVED***,
            join('src', 'multiarray', 'convert_datatype.c'***REMOVED***,
            join('src', 'multiarray', 'conversion_utils.c'***REMOVED***,
            join('src', 'multiarray', 'ctors.c'***REMOVED***,
            join('src', 'multiarray', 'datetime.c'***REMOVED***,
            join('src', 'multiarray', 'datetime_strings.c'***REMOVED***,
            join('src', 'multiarray', 'datetime_busday.c'***REMOVED***,
            join('src', 'multiarray', 'datetime_busdaycal.c'***REMOVED***,
            join('src', 'multiarray', 'descriptor.c'***REMOVED***,
            join('src', 'multiarray', 'dtype_transfer.c'***REMOVED***,
            join('src', 'multiarray', 'einsum.c.src'***REMOVED***,
            join('src', 'multiarray', 'flagsobject.c'***REMOVED***,
            join('src', 'multiarray', 'getset.c'***REMOVED***,
            join('src', 'multiarray', 'hashdescr.c'***REMOVED***,
            join('src', 'multiarray', 'item_selection.c'***REMOVED***,
            join('src', 'multiarray', 'iterators.c'***REMOVED***,
            join('src', 'multiarray', 'lowlevel_strided_loops.c.src'***REMOVED***,
            join('src', 'multiarray', 'mapping.c'***REMOVED***,
            join('src', 'multiarray', 'methods.c'***REMOVED***,
            join('src', 'multiarray', 'multiarraymodule.c'***REMOVED***,
            join('src', 'multiarray', 'nditer_templ.c.src'***REMOVED***,
            join('src', 'multiarray', 'nditer_api.c'***REMOVED***,
            join('src', 'multiarray', 'nditer_constr.c'***REMOVED***,
            join('src', 'multiarray', 'nditer_pywrap.c'***REMOVED***,
            join('src', 'multiarray', 'number.c'***REMOVED***,
            join('src', 'multiarray', 'numpymemoryview.c'***REMOVED***,
            join('src', 'multiarray', 'numpyos.c'***REMOVED***,
            join('src', 'multiarray', 'refcount.c'***REMOVED***,
            join('src', 'multiarray', 'sequence.c'***REMOVED***,
            join('src', 'multiarray', 'shape.c'***REMOVED***,
            join('src', 'multiarray', 'scalarapi.c'***REMOVED***,
            join('src', 'multiarray', 'scalartypes.c.src'***REMOVED***,
            join('src', 'multiarray', 'usertypes.c'***REMOVED***,
            join('src', 'multiarray', 'ucsnarrow.c'***REMOVED***,
            join('src', 'multiarray', 'vdot.c'***REMOVED***,
            join('src', 'private', 'templ_common.h.src'***REMOVED***,
            join('src', 'private', 'mem_overlap.c'***REMOVED***,
            ***REMOVED***

    blas_info = get_info('blas_opt', 0***REMOVED***
    if blas_info and ('HAVE_CBLAS', None***REMOVED*** in blas_info.get('define_macros', [***REMOVED******REMOVED***:
        extra_info = blas_info
        # These files are also in MANIFEST.in so that they are always in
        # the source distribution independently of HAVE_CBLAS.
        multiarray_src.extend([join('src', 'multiarray', 'cblasfuncs.c'***REMOVED***,
                               join('src', 'multiarray', 'python_xerbla.c'***REMOVED***,
                               ***REMOVED******REMOVED***
        if uses_accelerate_framework(blas_info***REMOVED***:
            multiarray_src.extend(get_sgemv_fix(***REMOVED******REMOVED***
    else:
        extra_info = {***REMOVED***

    config.add_extension('multiarray',
                         sources=multiarray_src +
                                 [generate_config_h,
                                  generate_numpyconfig_h,
                                  generate_numpy_api,
                                  join(codegen_dir, 'generate_numpy_api.py'***REMOVED***,
                                  join('*.py'***REMOVED******REMOVED***,
                         depends=deps + multiarray_deps,
                         libraries=['npymath', 'npysort'***REMOVED***,
                         extra_info=extra_info***REMOVED***

    #######################################################################
    #                           umath module                              #
    #######################################################################

    # umath version: this function is needed to build foo.c from foo.c.src
    # when foo.c is included in another file and as such not in the src
    # argument of build_ext command
    def generate_umath_templated_sources(ext, build_dir***REMOVED***:
        from numpy.distutils.misc_util import get_cmd

        subpath = join('src', 'umath'***REMOVED***
        sources = [
            join(local_dir, subpath, 'loops.h.src'***REMOVED***,
            join(local_dir, subpath, 'loops.c.src'***REMOVED***,
            join(local_dir, subpath, 'scalarmath.c.src'***REMOVED***,
            join(local_dir, subpath, 'simd.inc.src'***REMOVED******REMOVED***

        # numpy.distutils generate .c from .c.src in weird directories, we have
        # to add them there as they depend on the build_dir
        config.add_include_dirs(join(build_dir, subpath***REMOVED******REMOVED***
        cmd = get_cmd('build_src'***REMOVED***
        cmd.ensure_finalized(***REMOVED***
        cmd.template_sources(sources, ext***REMOVED***

    def generate_umath_c(ext, build_dir***REMOVED***:
        target = join(build_dir, header_dir, '__umath_generated.c'***REMOVED***
        dir = os.path.dirname(target***REMOVED***
        if not os.path.exists(dir***REMOVED***:
            os.makedirs(dir***REMOVED***
        script = generate_umath_py
        if newer(script, target***REMOVED***:
            f = open(target, 'w'***REMOVED***
            f.write(generate_umath.make_code(generate_umath.defdict,
                                             generate_umath.__file__***REMOVED******REMOVED***
            f.close(***REMOVED***
        return [***REMOVED***

    umath_src = [
            join('src', 'umath', 'umathmodule.c'***REMOVED***,
            join('src', 'umath', 'reduction.c'***REMOVED***,
            join('src', 'umath', 'funcs.inc.src'***REMOVED***,
            join('src', 'umath', 'simd.inc.src'***REMOVED***,
            join('src', 'umath', 'loops.h.src'***REMOVED***,
            join('src', 'umath', 'loops.c.src'***REMOVED***,
            join('src', 'umath', 'ufunc_object.c'***REMOVED***,
            join('src', 'umath', 'scalarmath.c.src'***REMOVED***,
            join('src', 'umath', 'ufunc_type_resolution.c'***REMOVED******REMOVED***

    umath_deps = [
            generate_umath_py,
            join('include', 'numpy', 'npy_math.h'***REMOVED***,
            join('include', 'numpy', 'halffloat.h'***REMOVED***,
            join('src', 'multiarray', 'common.h'***REMOVED***,
            join('src', 'private', 'templ_common.h.src'***REMOVED***,
            join('src', 'umath', 'simd.inc.src'***REMOVED***,
            join(codegen_dir, 'generate_ufunc_api.py'***REMOVED***,
            join('src', 'private', 'ufunc_override.h'***REMOVED******REMOVED*** + npymath_sources

    config.add_extension('umath',
                         sources=umath_src +
                                 [generate_config_h,
                                 generate_numpyconfig_h,
                                 generate_umath_c,
                                 generate_ufunc_api***REMOVED***,
                         depends=deps + umath_deps,
                         libraries=['npymath'***REMOVED***,
                         ***REMOVED***

    #######################################################################
    #                        umath_tests module                           #
    #######################################################################

    config.add_extension('umath_tests',
                    sources=[join('src', 'umath', 'umath_tests.c.src'***REMOVED******REMOVED******REMOVED***

    #######################################################################
    #                   custom rational dtype module                      #
    #######################################################################

    config.add_extension('test_rational',
                    sources=[join('src', 'umath', 'test_rational.c.src'***REMOVED******REMOVED******REMOVED***

    #######################################################################
    #                        struct_ufunc_test module                     #
    #######################################################################

    config.add_extension('struct_ufunc_test',
                    sources=[join('src', 'umath', 'struct_ufunc_test.c.src'***REMOVED******REMOVED******REMOVED***

    #######################################################################
    #                     multiarray_tests module                         #
    #######################################################################

    config.add_extension('multiarray_tests',
                    sources=[join('src', 'multiarray', 'multiarray_tests.c.src'***REMOVED***,
                             join('src', 'private', 'mem_overlap.c'***REMOVED******REMOVED***,
                    depends=[join('src', 'private', 'mem_overlap.h'***REMOVED***,
                             join('src', 'private', 'npy_extint128.h'***REMOVED******REMOVED******REMOVED***

    #######################################################################
    #                        operand_flag_tests module                    #
    #######################################################################

    config.add_extension('operand_flag_tests',
                    sources=[join('src', 'umath', 'operand_flag_tests.c.src'***REMOVED******REMOVED******REMOVED***

    config.add_data_dir('tests'***REMOVED***
    config.add_data_dir('tests/data'***REMOVED***

    config.make_svn_version_py(***REMOVED***

    return config

if __name__ == '__main__':
    from numpy.distutils.core import setup
    setup(configuration=configuration***REMOVED***
