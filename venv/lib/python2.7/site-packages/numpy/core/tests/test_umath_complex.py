from __future__ import division, absolute_import, print_function

import sys
import platform

import numpy as np
import numpy.core.umath as ncu
from numpy.testing import (
    TestCase, run_module_suite, assert_equal, assert_array_equal,
    assert_almost_equal, dec
***REMOVED***

# TODO: branch cuts (use Pauli code***REMOVED***
# TODO: conj 'symmetry'
# TODO: FPU exceptions

# At least on Windows the results of many complex functions are not conforming
# to the C99 standard. See ticket 1574.
# Ditto for Solaris (ticket 1642***REMOVED*** and OS X on PowerPC.
with np.errstate(all='ignore'***REMOVED***:
    functions_seem_flaky = ((np.exp(complex(np.inf, 0***REMOVED******REMOVED***.imag != 0***REMOVED***
                            or (np.log(complex(np.NZERO, 0***REMOVED******REMOVED***.imag != np.pi***REMOVED******REMOVED***
# TODO: replace with a check on whether platform-provided C99 funcs are used
skip_complex_tests = (not sys.platform.startswith('linux'***REMOVED*** or functions_seem_flaky***REMOVED***

def platform_skip(func***REMOVED***:
    return dec.skipif(skip_complex_tests,
        "Numpy is using complex functions (e.g. sqrt***REMOVED*** provided by your"
        "platform's C library. However, they do not seem to behave according"
        "to C99 -- so C99 tests are skipped."***REMOVED***(func***REMOVED***


class TestCexp(object***REMOVED***:
    def test_simple(self***REMOVED***:
        check = check_complex_value
        f = np.exp

        yield check, f, 1, 0, np.exp(1***REMOVED***, 0, False
        yield check, f, 0, 1, np.cos(1***REMOVED***, np.sin(1***REMOVED***, False

        ref = np.exp(1***REMOVED*** * np.complex(np.cos(1***REMOVED***, np.sin(1***REMOVED******REMOVED***
        yield check, f, 1, 1, ref.real, ref.imag, False

    @platform_skip
    def test_special_values(self***REMOVED***:
        # C99: Section G 6.3.1

        check = check_complex_value
        f = np.exp

        # cexp(+-0 + 0i***REMOVED*** is 1 + 0i
        yield check, f, np.PZERO, 0, 1, 0, False
        yield check, f, np.NZERO, 0, 1, 0, False

        # cexp(x + infi***REMOVED*** is nan + nani for finite x and raises 'invalid' FPU
        # exception
        yield check, f,  1, np.inf, np.nan, np.nan
        yield check, f, -1, np.inf, np.nan, np.nan
        yield check, f,  0, np.inf, np.nan, np.nan

        # cexp(inf + 0i***REMOVED*** is inf + 0i
        yield check, f,  np.inf, 0, np.inf, 0

        # cexp(-inf + yi***REMOVED*** is +0 * (cos(y***REMOVED*** + i sin(y***REMOVED******REMOVED*** for finite y
        yield check, f,  -np.inf, 1, np.PZERO, np.PZERO
        yield check, f,  -np.inf, 0.75 * np.pi, np.NZERO, np.PZERO

        # cexp(inf + yi***REMOVED*** is +inf * (cos(y***REMOVED*** + i sin(y***REMOVED******REMOVED*** for finite y
        yield check, f,  np.inf, 1, np.inf, np.inf
        yield check, f,  np.inf, 0.75 * np.pi, -np.inf, np.inf

        # cexp(-inf + inf i***REMOVED*** is +-0 +- 0i (signs unspecified***REMOVED***
        def _check_ninf_inf(dummy***REMOVED***:
            msgform = "cexp(-inf, inf***REMOVED*** is (%f, %f***REMOVED***, expected (+-0, +-0***REMOVED***"
            with np.errstate(invalid='ignore'***REMOVED***:
                z = f(np.array(np.complex(-np.inf, np.inf***REMOVED******REMOVED******REMOVED***
                if z.real != 0 or z.imag != 0:
                    raise AssertionError(msgform % (z.real, z.imag***REMOVED******REMOVED***

        yield _check_ninf_inf, None

        # cexp(inf + inf i***REMOVED*** is +-inf + NaNi and raised invalid FPU ex.
        def _check_inf_inf(dummy***REMOVED***:
            msgform = "cexp(inf, inf***REMOVED*** is (%f, %f***REMOVED***, expected (+-inf, nan***REMOVED***"
            with np.errstate(invalid='ignore'***REMOVED***:
                z = f(np.array(np.complex(np.inf, np.inf***REMOVED******REMOVED******REMOVED***
                if not np.isinf(z.real***REMOVED*** or not np.isnan(z.imag***REMOVED***:
                    raise AssertionError(msgform % (z.real, z.imag***REMOVED******REMOVED***

        yield _check_inf_inf, None

        # cexp(-inf + nan i***REMOVED*** is +-0 +- 0i
        def _check_ninf_nan(dummy***REMOVED***:
            msgform = "cexp(-inf, nan***REMOVED*** is (%f, %f***REMOVED***, expected (+-0, +-0***REMOVED***"
            with np.errstate(invalid='ignore'***REMOVED***:
                z = f(np.array(np.complex(-np.inf, np.nan***REMOVED******REMOVED******REMOVED***
                if z.real != 0 or z.imag != 0:
                    raise AssertionError(msgform % (z.real, z.imag***REMOVED******REMOVED***

        yield _check_ninf_nan, None

        # cexp(inf + nan i***REMOVED*** is +-inf + nan
        def _check_inf_nan(dummy***REMOVED***:
            msgform = "cexp(-inf, nan***REMOVED*** is (%f, %f***REMOVED***, expected (+-inf, nan***REMOVED***"
            with np.errstate(invalid='ignore'***REMOVED***:
                z = f(np.array(np.complex(np.inf, np.nan***REMOVED******REMOVED******REMOVED***
                if not np.isinf(z.real***REMOVED*** or not np.isnan(z.imag***REMOVED***:
                    raise AssertionError(msgform % (z.real, z.imag***REMOVED******REMOVED***

        yield _check_inf_nan, None

        # cexp(nan + yi***REMOVED*** is nan + nani for y != 0 (optional: raises invalid FPU
        # ex***REMOVED***
        yield check, f, np.nan, 1, np.nan, np.nan
        yield check, f, np.nan, -1, np.nan, np.nan

        yield check, f, np.nan,  np.inf, np.nan, np.nan
        yield check, f, np.nan, -np.inf, np.nan, np.nan

        # cexp(nan + nani***REMOVED*** is nan + nani
        yield check, f, np.nan, np.nan, np.nan, np.nan

    @dec.knownfailureif(True, "cexp(nan + 0I***REMOVED*** is wrong on most implementations"***REMOVED***
    def test_special_values2(self***REMOVED***:
        # XXX: most implementations get it wrong here (including glibc <= 2.10***REMOVED***
        # cexp(nan + 0i***REMOVED*** is nan + 0i
        check = check_complex_value
        f = np.exp

        yield check, f, np.nan, 0, np.nan, 0

class TestClog(TestCase***REMOVED***:
    def test_simple(self***REMOVED***:
        x = np.array([1+0j, 1+2j***REMOVED******REMOVED***
        y_r = np.log(np.abs(x***REMOVED******REMOVED*** + 1j * np.angle(x***REMOVED***
        y = np.log(x***REMOVED***
        for i in range(len(x***REMOVED******REMOVED***:
            assert_almost_equal(y[i***REMOVED***, y_r[i***REMOVED******REMOVED***

    @platform_skip
    @dec.skipif(platform.machine(***REMOVED*** == "armv5tel", "See gh-413."***REMOVED***
    def test_special_values(self***REMOVED***:
        xl = [***REMOVED***
        yl = [***REMOVED***

        # From C99 std (Sec 6.3.2***REMOVED***
        # XXX: check exceptions raised
        # --- raise for invalid fails.

        # clog(-0 + i0***REMOVED*** returns -inf + i pi and raises the 'divide-by-zero'
        # floating-point exception.
        with np.errstate(divide='raise'***REMOVED***:
            x = np.array([np.NZERO***REMOVED***, dtype=np.complex***REMOVED***
            y = np.complex(-np.inf, np.pi***REMOVED***
            self.assertRaises(FloatingPointError, np.log, x***REMOVED***
        with np.errstate(divide='ignore'***REMOVED***:
            assert_almost_equal(np.log(x***REMOVED***, y***REMOVED***

        xl.append(x***REMOVED***
        yl.append(y***REMOVED***

        # clog(+0 + i0***REMOVED*** returns -inf + i0 and raises the 'divide-by-zero'
        # floating-point exception.
        with np.errstate(divide='raise'***REMOVED***:
            x = np.array([0***REMOVED***, dtype=np.complex***REMOVED***
            y = np.complex(-np.inf, 0***REMOVED***
            self.assertRaises(FloatingPointError, np.log, x***REMOVED***
        with np.errstate(divide='ignore'***REMOVED***:
            assert_almost_equal(np.log(x***REMOVED***, y***REMOVED***

        xl.append(x***REMOVED***
        yl.append(y***REMOVED***

        # clog(x + i inf returns +inf + i pi /2, for finite x.
        x = np.array([complex(1, np.inf***REMOVED******REMOVED***, dtype=np.complex***REMOVED***
        y = np.complex(np.inf, 0.5 * np.pi***REMOVED***
        assert_almost_equal(np.log(x***REMOVED***, y***REMOVED***
        xl.append(x***REMOVED***
        yl.append(y***REMOVED***

        x = np.array([complex(-1, np.inf***REMOVED******REMOVED***, dtype=np.complex***REMOVED***
        assert_almost_equal(np.log(x***REMOVED***, y***REMOVED***
        xl.append(x***REMOVED***
        yl.append(y***REMOVED***

        # clog(x + iNaN***REMOVED*** returns NaN + iNaN and optionally raises the
        # 'invalid' floating- point exception, for finite x.
        with np.errstate(invalid='raise'***REMOVED***:
            x = np.array([complex(1., np.nan***REMOVED******REMOVED***, dtype=np.complex***REMOVED***
            y = np.complex(np.nan, np.nan***REMOVED***
            #self.assertRaises(FloatingPointError, np.log, x***REMOVED***
        with np.errstate(invalid='ignore'***REMOVED***:
            assert_almost_equal(np.log(x***REMOVED***, y***REMOVED***

        xl.append(x***REMOVED***
        yl.append(y***REMOVED***

        with np.errstate(invalid='raise'***REMOVED***:
            x = np.array([np.inf + 1j * np.nan***REMOVED***, dtype=np.complex***REMOVED***
            #self.assertRaises(FloatingPointError, np.log, x***REMOVED***
        with np.errstate(invalid='ignore'***REMOVED***:
            assert_almost_equal(np.log(x***REMOVED***, y***REMOVED***

        xl.append(x***REMOVED***
        yl.append(y***REMOVED***

        # clog(- inf + iy***REMOVED*** returns +inf + ipi , for finite positive-signed y.
        x = np.array([-np.inf + 1j***REMOVED***, dtype=np.complex***REMOVED***
        y = np.complex(np.inf, np.pi***REMOVED***
        assert_almost_equal(np.log(x***REMOVED***, y***REMOVED***
        xl.append(x***REMOVED***
        yl.append(y***REMOVED***

        # clog(+ inf + iy***REMOVED*** returns +inf + i0, for finite positive-signed y.
        x = np.array([np.inf + 1j***REMOVED***, dtype=np.complex***REMOVED***
        y = np.complex(np.inf, 0***REMOVED***
        assert_almost_equal(np.log(x***REMOVED***, y***REMOVED***
        xl.append(x***REMOVED***
        yl.append(y***REMOVED***

        # clog(- inf + i inf***REMOVED*** returns +inf + i3pi /4.
        x = np.array([complex(-np.inf, np.inf***REMOVED******REMOVED***, dtype=np.complex***REMOVED***
        y = np.complex(np.inf, 0.75 * np.pi***REMOVED***
        assert_almost_equal(np.log(x***REMOVED***, y***REMOVED***
        xl.append(x***REMOVED***
        yl.append(y***REMOVED***

        # clog(+ inf + i inf***REMOVED*** returns +inf + ipi /4.
        x = np.array([complex(np.inf, np.inf***REMOVED******REMOVED***, dtype=np.complex***REMOVED***
        y = np.complex(np.inf, 0.25 * np.pi***REMOVED***
        assert_almost_equal(np.log(x***REMOVED***, y***REMOVED***
        xl.append(x***REMOVED***
        yl.append(y***REMOVED***

        # clog(+/- inf + iNaN***REMOVED*** returns +inf + iNaN.
        x = np.array([complex(np.inf, np.nan***REMOVED******REMOVED***, dtype=np.complex***REMOVED***
        y = np.complex(np.inf, np.nan***REMOVED***
        assert_almost_equal(np.log(x***REMOVED***, y***REMOVED***
        xl.append(x***REMOVED***
        yl.append(y***REMOVED***

        x = np.array([complex(-np.inf, np.nan***REMOVED******REMOVED***, dtype=np.complex***REMOVED***
        assert_almost_equal(np.log(x***REMOVED***, y***REMOVED***
        xl.append(x***REMOVED***
        yl.append(y***REMOVED***

        # clog(NaN + iy***REMOVED*** returns NaN + iNaN and optionally raises the
        # 'invalid' floating-point exception, for finite y.
        x = np.array([complex(np.nan, 1***REMOVED******REMOVED***, dtype=np.complex***REMOVED***
        y = np.complex(np.nan, np.nan***REMOVED***
        assert_almost_equal(np.log(x***REMOVED***, y***REMOVED***
        xl.append(x***REMOVED***
        yl.append(y***REMOVED***

        # clog(NaN + i inf***REMOVED*** returns +inf + iNaN.
        x = np.array([complex(np.nan, np.inf***REMOVED******REMOVED***, dtype=np.complex***REMOVED***
        y = np.complex(np.inf, np.nan***REMOVED***
        assert_almost_equal(np.log(x***REMOVED***, y***REMOVED***
        xl.append(x***REMOVED***
        yl.append(y***REMOVED***

        # clog(NaN + iNaN***REMOVED*** returns NaN + iNaN.
        x = np.array([complex(np.nan, np.nan***REMOVED******REMOVED***, dtype=np.complex***REMOVED***
        y = np.complex(np.nan, np.nan***REMOVED***
        assert_almost_equal(np.log(x***REMOVED***, y***REMOVED***
        xl.append(x***REMOVED***
        yl.append(y***REMOVED***

        # clog(conj(z***REMOVED******REMOVED*** = conj(clog(z***REMOVED******REMOVED***.
        xa = np.array(xl, dtype=np.complex***REMOVED***
        ya = np.array(yl, dtype=np.complex***REMOVED***
        with np.errstate(divide='ignore'***REMOVED***:
            for i in range(len(xa***REMOVED******REMOVED***:
                assert_almost_equal(np.log(xa[i***REMOVED***.conj(***REMOVED******REMOVED***, ya[i***REMOVED***.conj(***REMOVED******REMOVED***

class TestCsqrt(object***REMOVED***:

    def test_simple(self***REMOVED***:
        # sqrt(1***REMOVED***
        yield check_complex_value, np.sqrt, 1, 0, 1, 0

        # sqrt(1i***REMOVED***
        yield check_complex_value, np.sqrt, 0, 1, 0.5*np.sqrt(2***REMOVED***, 0.5*np.sqrt(2***REMOVED***, False

        # sqrt(-1***REMOVED***
        yield check_complex_value, np.sqrt, -1, 0, 0, 1

    def test_simple_conjugate(self***REMOVED***:
        ref = np.conj(np.sqrt(np.complex(1, 1***REMOVED******REMOVED******REMOVED***

        def f(z***REMOVED***:
            return np.sqrt(np.conj(z***REMOVED******REMOVED***
        yield check_complex_value, f, 1, 1, ref.real, ref.imag, False

    #def test_branch_cut(self***REMOVED***:
    #    _check_branch_cut(f, -1, 0, 1, -1***REMOVED***

    @platform_skip
    def test_special_values(self***REMOVED***:
        # C99: Sec G 6.4.2

        check = check_complex_value
        f = np.sqrt

        # csqrt(+-0 + 0i***REMOVED*** is 0 + 0i
        yield check, f, np.PZERO, 0, 0, 0
        yield check, f, np.NZERO, 0, 0, 0

        # csqrt(x + infi***REMOVED*** is inf + infi for any x (including NaN***REMOVED***
        yield check, f,  1, np.inf, np.inf, np.inf
        yield check, f, -1, np.inf, np.inf, np.inf

        yield check, f, np.PZERO, np.inf, np.inf, np.inf
        yield check, f, np.NZERO, np.inf, np.inf, np.inf
        yield check, f,   np.inf, np.inf, np.inf, np.inf
        yield check, f,  -np.inf, np.inf, np.inf, np.inf
        yield check, f,  -np.nan, np.inf, np.inf, np.inf

        # csqrt(x + nani***REMOVED*** is nan + nani for any finite x
        yield check, f,  1, np.nan, np.nan, np.nan
        yield check, f, -1, np.nan, np.nan, np.nan
        yield check, f,  0, np.nan, np.nan, np.nan

        # csqrt(-inf + yi***REMOVED*** is +0 + infi for any finite y > 0
        yield check, f, -np.inf, 1, np.PZERO, np.inf

        # csqrt(inf + yi***REMOVED*** is +inf + 0i for any finite y > 0
        yield check, f, np.inf, 1, np.inf, np.PZERO

        # csqrt(-inf + nani***REMOVED*** is nan +- infi (both +i infi are valid***REMOVED***
        def _check_ninf_nan(dummy***REMOVED***:
            msgform = "csqrt(-inf, nan***REMOVED*** is (%f, %f***REMOVED***, expected (nan, +-inf***REMOVED***"
            z = np.sqrt(np.array(np.complex(-np.inf, np.nan***REMOVED******REMOVED******REMOVED***
            #Fixme: ugly workaround for isinf bug.
            with np.errstate(invalid='ignore'***REMOVED***:
                if not (np.isnan(z.real***REMOVED*** and np.isinf(z.imag***REMOVED******REMOVED***:
                    raise AssertionError(msgform % (z.real, z.imag***REMOVED******REMOVED***

        yield _check_ninf_nan, None

        # csqrt(+inf + nani***REMOVED*** is inf + nani
        yield check, f, np.inf, np.nan, np.inf, np.nan

        # csqrt(nan + yi***REMOVED*** is nan + nani for any finite y (infinite handled in x
        # + nani***REMOVED***
        yield check, f, np.nan,       0, np.nan, np.nan
        yield check, f, np.nan,       1, np.nan, np.nan
        yield check, f, np.nan,  np.nan, np.nan, np.nan

        # XXX: check for conj(csqrt(z***REMOVED******REMOVED*** == csqrt(conj(z***REMOVED******REMOVED*** (need to fix branch
        # cuts first***REMOVED***

class TestCpow(TestCase***REMOVED***:
    def setUp(self***REMOVED***:
        self.olderr = np.seterr(invalid='ignore'***REMOVED***

    def tearDown(self***REMOVED***:
        np.seterr(**self.olderr***REMOVED***

    def test_simple(self***REMOVED***:
        x = np.array([1+1j, 0+2j, 1+2j, np.inf, np.nan***REMOVED******REMOVED***
        y_r = x ** 2
        y = np.power(x, 2***REMOVED***
        for i in range(len(x***REMOVED******REMOVED***:
            assert_almost_equal(y[i***REMOVED***, y_r[i***REMOVED******REMOVED***

    def test_scalar(self***REMOVED***:
        x = np.array([1, 1j,         2,  2.5+.37j, np.inf, np.nan***REMOVED******REMOVED***
        y = np.array([1, 1j, -0.5+1.5j, -0.5+1.5j,      2,      3***REMOVED******REMOVED***
        lx = list(range(len(x***REMOVED******REMOVED******REMOVED***
        # Compute the values for complex type in python
        p_r = [complex(x[i***REMOVED******REMOVED*** ** complex(y[i***REMOVED******REMOVED*** for i in lx***REMOVED***
        # Substitute a result allowed by C99 standard
        p_r[4***REMOVED*** = complex(np.inf, np.nan***REMOVED***
        # Do the same with numpy complex scalars
        n_r = [x[i***REMOVED*** ** y[i***REMOVED*** for i in lx***REMOVED***
        for i in lx:
            assert_almost_equal(n_r[i***REMOVED***, p_r[i***REMOVED***, err_msg='Loop %d\n' % i***REMOVED***

    def test_array(self***REMOVED***:
        x = np.array([1, 1j,         2,  2.5+.37j, np.inf, np.nan***REMOVED******REMOVED***
        y = np.array([1, 1j, -0.5+1.5j, -0.5+1.5j,      2,      3***REMOVED******REMOVED***
        lx = list(range(len(x***REMOVED******REMOVED******REMOVED***
        # Compute the values for complex type in python
        p_r = [complex(x[i***REMOVED******REMOVED*** ** complex(y[i***REMOVED******REMOVED*** for i in lx***REMOVED***
        # Substitute a result allowed by C99 standard
        p_r[4***REMOVED*** = complex(np.inf, np.nan***REMOVED***
        # Do the same with numpy arrays
        n_r = x ** y
        for i in lx:
            assert_almost_equal(n_r[i***REMOVED***, p_r[i***REMOVED***, err_msg='Loop %d\n' % i***REMOVED***

class TestCabs(object***REMOVED***:
    def setUp(self***REMOVED***:
        self.olderr = np.seterr(invalid='ignore'***REMOVED***

    def tearDown(self***REMOVED***:
        np.seterr(**self.olderr***REMOVED***

    def test_simple(self***REMOVED***:
        x = np.array([1+1j, 0+2j, 1+2j, np.inf, np.nan***REMOVED******REMOVED***
        y_r = np.array([np.sqrt(2.***REMOVED***, 2, np.sqrt(5***REMOVED***, np.inf, np.nan***REMOVED******REMOVED***
        y = np.abs(x***REMOVED***
        for i in range(len(x***REMOVED******REMOVED***:
            assert_almost_equal(y[i***REMOVED***, y_r[i***REMOVED******REMOVED***

    def test_fabs(self***REMOVED***:
        # Test that np.abs(x +- 0j***REMOVED*** == np.abs(x***REMOVED*** (as mandated by C99 for cabs***REMOVED***
        x = np.array([1+0j***REMOVED***, dtype=np.complex***REMOVED***
        assert_array_equal(np.abs(x***REMOVED***, np.real(x***REMOVED******REMOVED***

        x = np.array([complex(1, np.NZERO***REMOVED******REMOVED***, dtype=np.complex***REMOVED***
        assert_array_equal(np.abs(x***REMOVED***, np.real(x***REMOVED******REMOVED***

        x = np.array([complex(np.inf, np.NZERO***REMOVED******REMOVED***, dtype=np.complex***REMOVED***
        assert_array_equal(np.abs(x***REMOVED***, np.real(x***REMOVED******REMOVED***

        x = np.array([complex(np.nan, np.NZERO***REMOVED******REMOVED***, dtype=np.complex***REMOVED***
        assert_array_equal(np.abs(x***REMOVED***, np.real(x***REMOVED******REMOVED***

    def test_cabs_inf_nan(self***REMOVED***:
        x, y = [***REMOVED***, [***REMOVED***

        # cabs(+-nan + nani***REMOVED*** returns nan
        x.append(np.nan***REMOVED***
        y.append(np.nan***REMOVED***
        yield check_real_value, np.abs,  np.nan, np.nan, np.nan

        x.append(np.nan***REMOVED***
        y.append(-np.nan***REMOVED***
        yield check_real_value, np.abs, -np.nan, np.nan, np.nan

        # According to C99 standard, if exactly one of the real/part is inf and
        # the other nan, then cabs should return inf
        x.append(np.inf***REMOVED***
        y.append(np.nan***REMOVED***
        yield check_real_value, np.abs,  np.inf, np.nan, np.inf

        x.append(-np.inf***REMOVED***
        y.append(np.nan***REMOVED***
        yield check_real_value, np.abs, -np.inf, np.nan, np.inf

        # cabs(conj(z***REMOVED******REMOVED*** == conj(cabs(z***REMOVED******REMOVED*** (= cabs(z***REMOVED******REMOVED***
        def f(a***REMOVED***:
            return np.abs(np.conj(a***REMOVED******REMOVED***

        def g(a, b***REMOVED***:
            return np.abs(np.complex(a, b***REMOVED******REMOVED***

        xa = np.array(x, dtype=np.complex***REMOVED***
        for i in range(len(xa***REMOVED******REMOVED***:
            ref = g(x[i***REMOVED***, y[i***REMOVED******REMOVED***
            yield check_real_value, f, x[i***REMOVED***, y[i***REMOVED***, ref

class TestCarg(object***REMOVED***:
    def test_simple(self***REMOVED***:
        check_real_value(ncu._arg, 1, 0, 0, False***REMOVED***
        check_real_value(ncu._arg, 0, 1, 0.5*np.pi, False***REMOVED***

        check_real_value(ncu._arg, 1, 1, 0.25*np.pi, False***REMOVED***
        check_real_value(ncu._arg, np.PZERO, np.PZERO, np.PZERO***REMOVED***

    @dec.knownfailureif(True,
        "Complex arithmetic with signed zero is buggy on most implementation"***REMOVED***
    def test_zero(self***REMOVED***:
        # carg(-0 +- 0i***REMOVED*** returns +- pi
        yield check_real_value, ncu._arg, np.NZERO, np.PZERO,  np.pi, False
        yield check_real_value, ncu._arg, np.NZERO, np.NZERO, -np.pi, False

        # carg(+0 +- 0i***REMOVED*** returns +- 0
        yield check_real_value, ncu._arg, np.PZERO, np.PZERO, np.PZERO
        yield check_real_value, ncu._arg, np.PZERO, np.NZERO, np.NZERO

        # carg(x +- 0i***REMOVED*** returns +- 0 for x > 0
        yield check_real_value, ncu._arg, 1, np.PZERO, np.PZERO, False
        yield check_real_value, ncu._arg, 1, np.NZERO, np.NZERO, False

        # carg(x +- 0i***REMOVED*** returns +- pi for x < 0
        yield check_real_value, ncu._arg, -1, np.PZERO,  np.pi, False
        yield check_real_value, ncu._arg, -1, np.NZERO, -np.pi, False

        # carg(+- 0 + yi***REMOVED*** returns pi/2 for y > 0
        yield check_real_value, ncu._arg, np.PZERO, 1, 0.5 * np.pi, False
        yield check_real_value, ncu._arg, np.NZERO, 1, 0.5 * np.pi, False

        # carg(+- 0 + yi***REMOVED*** returns -pi/2 for y < 0
        yield check_real_value, ncu._arg, np.PZERO, -1, 0.5 * np.pi, False
        yield check_real_value, ncu._arg, np.NZERO, -1, -0.5 * np.pi, False

    #def test_branch_cuts(self***REMOVED***:
    #    _check_branch_cut(ncu._arg, -1, 1j, -1, 1***REMOVED***

    def test_special_values(self***REMOVED***:
        # carg(-np.inf +- yi***REMOVED*** returns +-pi for finite y > 0
        yield check_real_value, ncu._arg, -np.inf,  1,  np.pi, False
        yield check_real_value, ncu._arg, -np.inf, -1, -np.pi, False

        # carg(np.inf +- yi***REMOVED*** returns +-0 for finite y > 0
        yield check_real_value, ncu._arg, np.inf,  1, np.PZERO, False
        yield check_real_value, ncu._arg, np.inf, -1, np.NZERO, False

        # carg(x +- np.infi***REMOVED*** returns +-pi/2 for finite x
        yield check_real_value, ncu._arg, 1,  np.inf,  0.5 * np.pi, False
        yield check_real_value, ncu._arg, 1, -np.inf, -0.5 * np.pi, False

        # carg(-np.inf +- np.infi***REMOVED*** returns +-3pi/4
        yield check_real_value, ncu._arg, -np.inf,  np.inf,  0.75 * np.pi, False
        yield check_real_value, ncu._arg, -np.inf, -np.inf, -0.75 * np.pi, False

        # carg(np.inf +- np.infi***REMOVED*** returns +-pi/4
        yield check_real_value, ncu._arg, np.inf,  np.inf,  0.25 * np.pi, False
        yield check_real_value, ncu._arg, np.inf, -np.inf, -0.25 * np.pi, False

        # carg(x + yi***REMOVED*** returns np.nan if x or y is nan
        yield check_real_value, ncu._arg, np.nan,      0, np.nan, False
        yield check_real_value, ncu._arg,      0, np.nan, np.nan, False

        yield check_real_value, ncu._arg, np.nan, np.inf, np.nan, False
        yield check_real_value, ncu._arg, np.inf, np.nan, np.nan, False

def check_real_value(f, x1, y1, x, exact=True***REMOVED***:
    z1 = np.array([complex(x1, y1***REMOVED******REMOVED******REMOVED***
    if exact:
        assert_equal(f(z1***REMOVED***, x***REMOVED***
    else:
        assert_almost_equal(f(z1***REMOVED***, x***REMOVED***

def check_complex_value(f, x1, y1, x2, y2, exact=True***REMOVED***:
    z1 = np.array([complex(x1, y1***REMOVED******REMOVED******REMOVED***
    z2 = np.complex(x2, y2***REMOVED***
    with np.errstate(invalid='ignore'***REMOVED***:
        if exact:
            assert_equal(f(z1***REMOVED***, z2***REMOVED***
        else:
            assert_almost_equal(f(z1***REMOVED***, z2***REMOVED***

if __name__ == "__main__":
    run_module_suite(***REMOVED***
