from __future__ import division, absolute_import, print_function

import sys
import warnings
import functools

import numpy as np
from numpy.core.multiarray_tests import array_indexing
from itertools import product
from numpy.testing import (
    TestCase, run_module_suite, assert_, assert_equal, assert_raises,
    assert_array_equal, assert_warns
***REMOVED***


***REMOVED***
    cdll = np.ctypeslib.load_library('multiarray', np.core.multiarray.__file__***REMOVED***
    _HAS_CTYPE = True
except ImportError:
    _HAS_CTYPE = False


class TestIndexing(TestCase***REMOVED***:
    def test_none_index(self***REMOVED***:
        # `None` index adds newaxis
        a = np.array([1, 2, 3***REMOVED******REMOVED***
        assert_equal(a[None***REMOVED***, a[np.newaxis***REMOVED******REMOVED***
        assert_equal(a[None***REMOVED***.ndim, a.ndim + 1***REMOVED***

    def test_empty_tuple_index(self***REMOVED***:
        # Empty tuple index creates a view
        a = np.array([1, 2, 3***REMOVED******REMOVED***
        assert_equal(a[(***REMOVED******REMOVED***, a***REMOVED***
        assert_(a[(***REMOVED******REMOVED***.base is a***REMOVED***
        a = np.array(0***REMOVED***
        assert_(isinstance(a[(***REMOVED******REMOVED***, np.int_***REMOVED******REMOVED***

        # Regression, it needs to fall through integer and fancy indexing
        # cases, so need the with statement to ignore the non-integer error.
        with warnings.catch_warnings(***REMOVED***:
            warnings.filterwarnings('ignore', '', DeprecationWarning***REMOVED***
            a = np.array([1.***REMOVED******REMOVED***
            assert_(isinstance(a[0.***REMOVED***, np.float_***REMOVED******REMOVED***

            a = np.array([np.array(1***REMOVED******REMOVED***, dtype=object***REMOVED***
            assert_(isinstance(a[0.***REMOVED***, np.ndarray***REMOVED******REMOVED***

    def test_same_kind_index_casting(self***REMOVED***:
        # Indexes should be cast with same-kind and not safe, even if
        # that is somewhat unsafe. So test various different code paths.
        index = np.arange(5***REMOVED***
        u_index = index.astype(np.uintp***REMOVED***
        arr = np.arange(10***REMOVED***

        assert_array_equal(arr[index***REMOVED***, arr[u_index***REMOVED******REMOVED***
        arr[u_index***REMOVED*** = np.arange(5***REMOVED***
        assert_array_equal(arr, np.arange(10***REMOVED******REMOVED***

        arr = np.arange(10***REMOVED***.reshape(5, 2***REMOVED***
        assert_array_equal(arr[index***REMOVED***, arr[u_index***REMOVED******REMOVED***

        arr[u_index***REMOVED*** = np.arange(5***REMOVED***[:,None***REMOVED***
        assert_array_equal(arr, np.arange(5***REMOVED***[:,None***REMOVED***.repeat(2, axis=1***REMOVED******REMOVED***

        arr = np.arange(25***REMOVED***.reshape(5, 5***REMOVED***
        assert_array_equal(arr[u_index, u_index***REMOVED***, arr[index, index***REMOVED******REMOVED***

    def test_empty_fancy_index(self***REMOVED***:
        # Empty list index creates an empty array
        # with the same dtype (but with weird shape***REMOVED***
        a = np.array([1, 2, 3***REMOVED******REMOVED***
        assert_equal(a[[***REMOVED******REMOVED***, [***REMOVED******REMOVED***
        assert_equal(a[[***REMOVED******REMOVED***.dtype, a.dtype***REMOVED***

        b = np.array([***REMOVED***, dtype=np.intp***REMOVED***
        assert_equal(a[[***REMOVED******REMOVED***, [***REMOVED******REMOVED***
        assert_equal(a[[***REMOVED******REMOVED***.dtype, a.dtype***REMOVED***

        b = np.array([***REMOVED******REMOVED***
        assert_raises(IndexError, a.__getitem__, b***REMOVED***

    def test_ellipsis_index(self***REMOVED***:
        # Ellipsis index does not create a view
        a = np.array([[1, 2, 3***REMOVED***,
                      [4, 5, 6***REMOVED***,
                      [7, 8, 9***REMOVED******REMOVED******REMOVED***
        assert_equal(a[...***REMOVED***, a***REMOVED***
        assert_(a[...***REMOVED***.base is a***REMOVED***  # `a[...***REMOVED***` was `a` in numpy <1.9.***REMOVED***

        # Slicing with ellipsis can skip an
        # arbitrary number of dimensions
        assert_equal(a[0, ...***REMOVED***, a[0***REMOVED******REMOVED***
        assert_equal(a[0, ...***REMOVED***, a[0,:***REMOVED******REMOVED***
        assert_equal(a[..., 0***REMOVED***, a[:, 0***REMOVED******REMOVED***

        # Slicing with ellipsis always results
        # in an array, not a scalar
        assert_equal(a[0, ..., 1***REMOVED***, np.array(2***REMOVED******REMOVED***

        # Assignment with `(Ellipsis,***REMOVED***` on 0-d arrays
        b = np.array(1***REMOVED***
        b[(Ellipsis,***REMOVED******REMOVED*** = 2
        assert_equal(b, 2***REMOVED***

    def test_single_int_index(self***REMOVED***:
        # Single integer index selects one row
        a = np.array([[1, 2, 3***REMOVED***,
                      [4, 5, 6***REMOVED***,
                      [7, 8, 9***REMOVED******REMOVED******REMOVED***

        assert_equal(a[0***REMOVED***, [1, 2, 3***REMOVED******REMOVED***
        assert_equal(a[-1***REMOVED***, [7, 8, 9***REMOVED******REMOVED***

        # Index out of bounds produces IndexError
        assert_raises(IndexError, a.__getitem__, 1 << 30***REMOVED***
        # Index overflow produces IndexError
        assert_raises(IndexError, a.__getitem__, 1 << 64***REMOVED***

    def test_single_bool_index(self***REMOVED***:
        # Single boolean index
        a = np.array([[1, 2, 3***REMOVED***,
                      [4, 5, 6***REMOVED***,
                      [7, 8, 9***REMOVED******REMOVED******REMOVED***

        # Python boolean converts to integer
        # These are being deprecated (and test in test_deprecations***REMOVED***
        #assert_equal(a[True***REMOVED***, a[1***REMOVED******REMOVED***
        #assert_equal(a[False***REMOVED***, a[0***REMOVED******REMOVED***

        # Same with NumPy boolean scalar
        # Before DEPRECATE, this is an error (as always, but telling about
        # future change***REMOVED***:
        assert_raises(IndexError, a.__getitem__, np.array(True***REMOVED******REMOVED***
        assert_raises(IndexError, a.__getitem__, np.array(False***REMOVED******REMOVED***
        # After DEPRECATE, this behaviour can be enabled:
        #assert_equal(a[np.array(True***REMOVED******REMOVED***, a[None***REMOVED******REMOVED***
        #assert_equal(a[np.array(False***REMOVED***, a[None***REMOVED***[0:0***REMOVED******REMOVED******REMOVED***

    def test_boolean_indexing_onedim(self***REMOVED***:
        # Indexing a 2-dimensional array with
        # boolean array of length one
        a = np.array([[ 0.,  0.,  0.***REMOVED******REMOVED******REMOVED***
        b = np.array([ True***REMOVED***, dtype=bool***REMOVED***
        assert_equal(a[b***REMOVED***, a***REMOVED***
        # boolean assignment
        a[b***REMOVED*** = 1.
        assert_equal(a, [[1., 1., 1.***REMOVED******REMOVED******REMOVED***

    def test_boolean_assignment_value_mismatch(self***REMOVED***:
        # A boolean assignment should fail when the shape of the values
        # cannot be broadcast to the subscription. (see also gh-3458***REMOVED***
        a = np.arange(4***REMOVED***

        def f(a, v***REMOVED***:
            a[a > -1***REMOVED*** = v

        assert_raises(ValueError, f, a, [***REMOVED******REMOVED***
        assert_raises(ValueError, f, a, [1, 2, 3***REMOVED******REMOVED***
        assert_raises(ValueError, f, a[:1***REMOVED***, [1, 2, 3***REMOVED******REMOVED***

    def test_boolean_assignment_needs_api(self***REMOVED***:
        # See also gh-7666
        # This caused a segfault on Python 2 due to the GIL not being
        # held when the iterator does not need it, but the transfer function
        # does
        arr = np.zeros(1000***REMOVED***
        indx = np.zeros(1000, dtype=bool***REMOVED***
        indx[:100***REMOVED*** = True
        arr[indx***REMOVED*** = np.ones(100, dtype=object***REMOVED***

        expected = np.zeros(1000***REMOVED***
        expected[:100***REMOVED*** = 1
        assert_array_equal(arr, expected***REMOVED***

    def test_boolean_indexing_twodim(self***REMOVED***:
        # Indexing a 2-dimensional array with
        # 2-dimensional boolean array
        a = np.array([[1, 2, 3***REMOVED***,
                      [4, 5, 6***REMOVED***,
                      [7, 8, 9***REMOVED******REMOVED******REMOVED***
        b = np.array([[ True, False,  True***REMOVED***,
                      [False,  True, False***REMOVED***,
                      [ True, False,  True***REMOVED******REMOVED******REMOVED***
        assert_equal(a[b***REMOVED***, [1, 3, 5, 7, 9***REMOVED******REMOVED***
        assert_equal(a[b[1***REMOVED******REMOVED***, [[4, 5, 6***REMOVED******REMOVED******REMOVED***
        assert_equal(a[b[0***REMOVED******REMOVED***, a[b[2***REMOVED******REMOVED******REMOVED***

        # boolean assignment
        a[b***REMOVED*** = 0
        assert_equal(a, [[0, 2, 0***REMOVED***,
                         [4, 0, 6***REMOVED***,
                         [0, 8, 0***REMOVED******REMOVED******REMOVED***

    def test_reverse_strides_and_subspace_bufferinit(self***REMOVED***:
        # This tests that the strides are not reversed for simple and
        # subspace fancy indexing.
        a = np.ones(5***REMOVED***
        b = np.zeros(5, dtype=np.intp***REMOVED***[::-1***REMOVED***
        c = np.arange(5***REMOVED***[::-1***REMOVED***

        a[b***REMOVED*** = c
        # If the strides are not reversed, the 0 in the arange comes last.
        assert_equal(a[0***REMOVED***, 0***REMOVED***

        # This also tests that the subspace buffer is initialized:
        a = np.ones((5, 2***REMOVED******REMOVED***
        c = np.arange(10***REMOVED***.reshape(5, 2***REMOVED***[::-1***REMOVED***
        a[b, :***REMOVED*** = c
        assert_equal(a[0***REMOVED***, [0, 1***REMOVED******REMOVED***

    def test_reversed_strides_result_allocation(self***REMOVED***:
        # Test a bug when calculating the output strides for a result array
        # when the subspace size was 1 (and test other cases as well***REMOVED***
        a = np.arange(10***REMOVED***[:, None***REMOVED***
        i = np.arange(10***REMOVED***[::-1***REMOVED***
        assert_array_equal(a[i***REMOVED***, a[i.copy('C'***REMOVED******REMOVED******REMOVED***

        a = np.arange(20***REMOVED***.reshape(-1, 2***REMOVED***

    def test_uncontiguous_subspace_assignment(self***REMOVED***:
        # During development there was a bug activating a skip logic
        # based on ndim instead of size.
        a = np.full((3, 4, 2***REMOVED***, -1***REMOVED***
        b = np.full((3, 4, 2***REMOVED***, -1***REMOVED***

        a[[0, 1***REMOVED******REMOVED*** = np.arange(2 * 4 * 2***REMOVED***.reshape(2, 4, 2***REMOVED***.T
        b[[0, 1***REMOVED******REMOVED*** = np.arange(2 * 4 * 2***REMOVED***.reshape(2, 4, 2***REMOVED***.T.copy(***REMOVED***

        assert_equal(a, b***REMOVED***

    def test_too_many_fancy_indices_special_case(self***REMOVED***:
        # Just documents behaviour, this is a small limitation.
        a = np.ones((1,***REMOVED*** * 32***REMOVED***  # 32 is NPY_MAXDIMS
        assert_raises(IndexError, a.__getitem__, (np.array([0***REMOVED******REMOVED***,***REMOVED*** * 32***REMOVED***

    def test_scalar_array_bool(self***REMOVED***:
        # Numpy bools can be used as boolean index (python ones as of yet not***REMOVED***
        a = np.array(1***REMOVED***
        assert_equal(a[np.bool_(True***REMOVED******REMOVED***, a[np.array(True***REMOVED******REMOVED******REMOVED***
        assert_equal(a[np.bool_(False***REMOVED******REMOVED***, a[np.array(False***REMOVED******REMOVED******REMOVED***

        # After deprecating bools as integers:
        #a = np.array([0,1,2***REMOVED******REMOVED***
        #assert_equal(a[True, :***REMOVED***, a[None, :***REMOVED******REMOVED***
        #assert_equal(a[:, True***REMOVED***, a[:, None***REMOVED******REMOVED***
        #
        #assert_(not np.may_share_memory(a, a[True, :***REMOVED******REMOVED******REMOVED***

    def test_everything_returns_views(self***REMOVED***:
        # Before `...` would return a itself.
        a = np.arange(5***REMOVED***

        assert_(a is not a[(***REMOVED******REMOVED******REMOVED***
        assert_(a is not a[...***REMOVED******REMOVED***
        assert_(a is not a[:***REMOVED******REMOVED***

    def test_broaderrors_indexing(self***REMOVED***:
        a = np.zeros((5, 5***REMOVED******REMOVED***
        assert_raises(IndexError, a.__getitem__, ([0, 1***REMOVED***, [0, 1, 2***REMOVED******REMOVED******REMOVED***
        assert_raises(IndexError, a.__setitem__, ([0, 1***REMOVED***, [0, 1, 2***REMOVED******REMOVED***, 0***REMOVED***

    def test_trivial_fancy_out_of_bounds(self***REMOVED***:
        a = np.zeros(5***REMOVED***
        ind = np.ones(20, dtype=np.intp***REMOVED***
        ind[-1***REMOVED*** = 10
        assert_raises(IndexError, a.__getitem__, ind***REMOVED***
        assert_raises(IndexError, a.__setitem__, ind, 0***REMOVED***
        ind = np.ones(20, dtype=np.intp***REMOVED***
        ind[0***REMOVED*** = 11
        assert_raises(IndexError, a.__getitem__, ind***REMOVED***
        assert_raises(IndexError, a.__setitem__, ind, 0***REMOVED***

    def test_nonbaseclass_values(self***REMOVED***:
        class SubClass(np.ndarray***REMOVED***:
            def __array_finalize__(self, old***REMOVED***:
                # Have array finalize do funny things
                self.fill(99***REMOVED***

        a = np.zeros((5, 5***REMOVED******REMOVED***
        s = a.copy(***REMOVED***.view(type=SubClass***REMOVED***
        s.fill(1***REMOVED***

        a[[0, 1, 2, 3, 4***REMOVED***, :***REMOVED*** = s
        assert_((a == 1***REMOVED***.all(***REMOVED******REMOVED***

        # Subspace is last, so transposing might want to finalize
        a[:, [0, 1, 2, 3, 4***REMOVED******REMOVED*** = s
        assert_((a == 1***REMOVED***.all(***REMOVED******REMOVED***

        a.fill(0***REMOVED***
        a[...***REMOVED*** = s
        assert_((a == 1***REMOVED***.all(***REMOVED******REMOVED***

    def test_subclass_writeable(self***REMOVED***:
        d = np.rec.array([('NGC1001', 11***REMOVED***, ('NGC1002', 1.***REMOVED***, ('NGC1003', 1.***REMOVED******REMOVED***,
                         dtype=[('target', 'S20'***REMOVED***, ('V_mag', '>f4'***REMOVED******REMOVED******REMOVED***
        ind = np.array([False,  True,  True***REMOVED***, dtype=bool***REMOVED***
        assert_(d[ind***REMOVED***.flags.writeable***REMOVED***
        ind = np.array([0, 1***REMOVED******REMOVED***
        assert_(d[ind***REMOVED***.flags.writeable***REMOVED***
        assert_(d[...***REMOVED***.flags.writeable***REMOVED***
        assert_(d[0***REMOVED***.flags.writeable***REMOVED***

    def test_memory_order(self***REMOVED***:
        # This is not necessary to preserve. Memory layouts for
        # more complex indices are not as simple.
        a = np.arange(10***REMOVED***
        b = np.arange(10***REMOVED***.reshape(5,2***REMOVED***.T
        assert_(a[b***REMOVED***.flags.f_contiguous***REMOVED***

        # Takes a different implementation branch:
        a = a.reshape(-1, 1***REMOVED***
        assert_(a[b, 0***REMOVED***.flags.f_contiguous***REMOVED***

    def test_scalar_return_type(self***REMOVED***:
        # Full scalar indices should return scalars and object
        # arrays should not call PyArray_Return on their items
        class Zero(object***REMOVED***:
            # The most basic valid indexing
            def __index__(self***REMOVED***:
                return 0

        z = Zero(***REMOVED***

        class ArrayLike(object***REMOVED***:
            # Simple array, should behave like the array
            def __array__(self***REMOVED***:
                return np.array(0***REMOVED***

        a = np.zeros((***REMOVED******REMOVED***
        assert_(isinstance(a[(***REMOVED******REMOVED***, np.float_***REMOVED******REMOVED***
        a = np.zeros(1***REMOVED***
        assert_(isinstance(a[z***REMOVED***, np.float_***REMOVED******REMOVED***
        a = np.zeros((1, 1***REMOVED******REMOVED***
        assert_(isinstance(a[z, np.array(0***REMOVED******REMOVED***, np.float_***REMOVED******REMOVED***
        assert_(isinstance(a[z, ArrayLike(***REMOVED******REMOVED***, np.float_***REMOVED******REMOVED***

        # And object arrays do not call it too often:
        b = np.array(0***REMOVED***
        a = np.array(0, dtype=object***REMOVED***
        a[(***REMOVED******REMOVED*** = b
        assert_(isinstance(a[(***REMOVED******REMOVED***, np.ndarray***REMOVED******REMOVED***
        a = np.array([b, None***REMOVED******REMOVED***
        assert_(isinstance(a[z***REMOVED***, np.ndarray***REMOVED******REMOVED***
        a = np.array([[b, None***REMOVED******REMOVED******REMOVED***
        assert_(isinstance(a[z, np.array(0***REMOVED******REMOVED***, np.ndarray***REMOVED******REMOVED***
        assert_(isinstance(a[z, ArrayLike(***REMOVED******REMOVED***, np.ndarray***REMOVED******REMOVED***

    def test_small_regressions(self***REMOVED***:
        # Reference count of intp for index checks
        a = np.array([0***REMOVED******REMOVED***
        refcount = sys.getrefcount(np.dtype(np.intp***REMOVED******REMOVED***
        # item setting always checks indices in separate function:
        a[np.array([0***REMOVED***, dtype=np.intp***REMOVED******REMOVED*** = 1
        a[np.array([0***REMOVED***, dtype=np.uint8***REMOVED******REMOVED*** = 1
        assert_raises(IndexError, a.__setitem__,
                      np.array([1***REMOVED***, dtype=np.intp***REMOVED***, 1***REMOVED***
        assert_raises(IndexError, a.__setitem__,
                      np.array([1***REMOVED***, dtype=np.uint8***REMOVED***, 1***REMOVED***

        assert_equal(sys.getrefcount(np.dtype(np.intp***REMOVED******REMOVED***, refcount***REMOVED***

    def test_unaligned(self***REMOVED***:
        v = (np.zeros(64, dtype=np.int8***REMOVED*** + ord('a'***REMOVED******REMOVED***[1:-7***REMOVED***
        d = v.view(np.dtype("S8"***REMOVED******REMOVED***
        # unaligned source
        x = (np.zeros(16, dtype=np.int8***REMOVED*** + ord('a'***REMOVED******REMOVED***[1:-7***REMOVED***
        x = x.view(np.dtype("S8"***REMOVED******REMOVED***
        x[...***REMOVED*** = np.array("b" * 8, dtype="S"***REMOVED***
        b = np.arange(d.size***REMOVED***
        #trivial
        assert_equal(d[b***REMOVED***, d***REMOVED***
        d[b***REMOVED*** = x
        # nontrivial
        # unaligned index array
        b = np.zeros(d.size + 1***REMOVED***.view(np.int8***REMOVED***[1:-(np.intp(0***REMOVED***.itemsize - 1***REMOVED******REMOVED***
        b = b.view(np.intp***REMOVED***[:d.size***REMOVED***
        b[...***REMOVED*** = np.arange(d.size***REMOVED***
        assert_equal(d[b.astype(np.int16***REMOVED******REMOVED***, d***REMOVED***
        d[b.astype(np.int16***REMOVED******REMOVED*** = x
        # boolean
        d[b % 2 == 0***REMOVED***
        d[b % 2 == 0***REMOVED*** = x[::2***REMOVED***

    def test_tuple_subclass(self***REMOVED***:
        arr = np.ones((5, 5***REMOVED******REMOVED***

        # A tuple subclass should also be an nd-index
        class TupleSubclass(tuple***REMOVED***:
            pass
        index = ([1***REMOVED***, [1***REMOVED******REMOVED***
        index = TupleSubclass(index***REMOVED***
        assert_(arr[index***REMOVED***.shape == (1,***REMOVED******REMOVED***
        # Unlike the non nd-index:
        assert_(arr[index,***REMOVED***.shape != (1,***REMOVED******REMOVED***

    def test_broken_sequence_not_nd_index(self***REMOVED***:
        # See gh-5063:
        # If we have an object which claims to be a sequence, but fails
        # on item getting, this should not be converted to an nd-index (tuple***REMOVED***
        # If this object happens to be a valid index otherwise, it should work
        # This object here is very dubious and probably bad though:
        class SequenceLike(object***REMOVED***:
            def __index__(self***REMOVED***:
                return 0

            def __len__(self***REMOVED***:
                return 1

            def __getitem__(self, item***REMOVED***:
                raise IndexError('Not possible'***REMOVED***

        arr = np.arange(10***REMOVED***
        assert_array_equal(arr[SequenceLike(***REMOVED******REMOVED***, arr[SequenceLike(***REMOVED***,***REMOVED******REMOVED***

        # also test that field indexing does not segfault
        # for a similar reason, by indexing a structured array
        arr = np.zeros((1,***REMOVED***, dtype=[('f1', 'i8'***REMOVED***, ('f2', 'i8'***REMOVED******REMOVED******REMOVED***
        assert_array_equal(arr[SequenceLike(***REMOVED******REMOVED***, arr[SequenceLike(***REMOVED***,***REMOVED******REMOVED***

    def test_indexing_array_weird_strides(self***REMOVED***:
        # See also gh-6221
        # the shapes used here come from the issue and create the correct
        # size for the iterator buffering size.
        x = np.ones(10***REMOVED***
        x2 = np.ones((10, 2***REMOVED******REMOVED***
        ind = np.arange(10***REMOVED***[:, None, None, None***REMOVED***
        ind = np.broadcast_to(ind, (10, 55, 4, 4***REMOVED******REMOVED***

        # single advanced index case
        assert_array_equal(x[ind***REMOVED***, x[ind.copy(***REMOVED******REMOVED******REMOVED***
        # higher dimensional advanced index
        zind = np.zeros(4, dtype=np.intp***REMOVED***
        assert_array_equal(x2[ind, zind***REMOVED***, x2[ind.copy(***REMOVED***, zind***REMOVED******REMOVED***


class TestFieldIndexing(TestCase***REMOVED***:
    def test_scalar_return_type(self***REMOVED***:
        # Field access on an array should return an array, even if it
        # is 0-d.
        a = np.zeros((***REMOVED***, [('a','f8'***REMOVED******REMOVED******REMOVED***
        assert_(isinstance(a['a'***REMOVED***, np.ndarray***REMOVED******REMOVED***
        assert_(isinstance(a[['a'***REMOVED******REMOVED***, np.ndarray***REMOVED******REMOVED***


class TestBroadcastedAssignments(TestCase***REMOVED***:
    def assign(self, a, ind, val***REMOVED***:
        a[ind***REMOVED*** = val
        return a

    def test_prepending_ones(self***REMOVED***:
        a = np.zeros((3, 2***REMOVED******REMOVED***

        a[...***REMOVED*** = np.ones((1, 3, 2***REMOVED******REMOVED***
        # Fancy with subspace with and without transpose
        a[[0, 1, 2***REMOVED***, :***REMOVED*** = np.ones((1, 3, 2***REMOVED******REMOVED***
        a[:, [0, 1***REMOVED******REMOVED*** = np.ones((1, 3, 2***REMOVED******REMOVED***
        # Fancy without subspace (with broadcasting***REMOVED***
        a[[[0***REMOVED***, [1***REMOVED***, [2***REMOVED******REMOVED***, [0, 1***REMOVED******REMOVED*** = np.ones((1, 3, 2***REMOVED******REMOVED***

    def test_prepend_not_one(self***REMOVED***:
        assign = self.assign
        s_ = np.s_

        a = np.zeros(5***REMOVED***

        # Too large and not only ones.
        assert_raises(ValueError, assign, a, s_[...***REMOVED***,  np.ones((2, 1***REMOVED******REMOVED******REMOVED***

        with warnings.catch_warnings(***REMOVED***:
            # Will be a ValueError as well.
            warnings.simplefilter("error", DeprecationWarning***REMOVED***
            assert_raises(DeprecationWarning, assign, a, s_[[1, 2, 3***REMOVED***,***REMOVED***,
                          np.ones((2, 1***REMOVED******REMOVED******REMOVED***
            assert_raises(DeprecationWarning, assign, a, s_[[[1***REMOVED***, [2***REMOVED******REMOVED***,***REMOVED***,
                          np.ones((2,2,1***REMOVED******REMOVED******REMOVED***

    def test_simple_broadcasting_errors(self***REMOVED***:
        assign = self.assign
        s_ = np.s_

        a = np.zeros((5, 1***REMOVED******REMOVED***
        assert_raises(ValueError, assign, a, s_[...***REMOVED***, np.zeros((5, 2***REMOVED******REMOVED******REMOVED***
        assert_raises(ValueError, assign, a, s_[...***REMOVED***, np.zeros((5, 0***REMOVED******REMOVED******REMOVED***

        assert_raises(ValueError, assign, a, s_[:, [0***REMOVED******REMOVED***, np.zeros((5, 2***REMOVED******REMOVED******REMOVED***
        assert_raises(ValueError, assign, a, s_[:, [0***REMOVED******REMOVED***, np.zeros((5, 0***REMOVED******REMOVED******REMOVED***

        assert_raises(ValueError, assign, a, s_[[0***REMOVED***, :***REMOVED***, np.zeros((2, 1***REMOVED******REMOVED******REMOVED***

    def test_index_is_larger(self***REMOVED***:
        # Simple case of fancy index broadcasting of the index.
        a = np.zeros((5, 5***REMOVED******REMOVED***
        a[[[0***REMOVED***, [1***REMOVED***, [2***REMOVED******REMOVED***, [0, 1, 2***REMOVED******REMOVED*** = [2, 3, 4***REMOVED***

        assert_((a[:3, :3***REMOVED*** == [2, 3, 4***REMOVED******REMOVED***.all(***REMOVED******REMOVED***

    def test_broadcast_subspace(self***REMOVED***:
        a = np.zeros((100, 100***REMOVED******REMOVED***
        v = np.arange(100***REMOVED***[:,None***REMOVED***
        b = np.arange(100***REMOVED***[::-1***REMOVED***
        a[b***REMOVED*** = v
        assert_((a[::-1***REMOVED*** == v***REMOVED***.all(***REMOVED******REMOVED***


class TestSubclasses(TestCase***REMOVED***:
    def test_basic(self***REMOVED***:
        class SubClass(np.ndarray***REMOVED***:
            pass

        s = np.arange(5***REMOVED***.view(SubClass***REMOVED***
        assert_(isinstance(s[:3***REMOVED***, SubClass***REMOVED******REMOVED***
        assert_(s[:3***REMOVED***.base is s***REMOVED***

        assert_(isinstance(s[[0, 1, 2***REMOVED******REMOVED***, SubClass***REMOVED******REMOVED***
        assert_(isinstance(s[s > 0***REMOVED***, SubClass***REMOVED******REMOVED***

    def test_matrix_fancy(self***REMOVED***:
        # The matrix class messes with the shape. While this is always
        # weird (getitem is not used, it does not have setitem nor knows
        # about fancy indexing***REMOVED***, this tests gh-3110
        m = np.matrix([[1, 2***REMOVED***, [3, 4***REMOVED******REMOVED******REMOVED***

        assert_(isinstance(m[[0,1,0***REMOVED***, :***REMOVED***, np.matrix***REMOVED******REMOVED***

        # gh-3110. Note the transpose currently because matrices do *not*
        # support dimension fixing for fancy indexing correctly.
        x = np.asmatrix(np.arange(50***REMOVED***.reshape(5,10***REMOVED******REMOVED***
        assert_equal(x[:2, np.array(-1***REMOVED******REMOVED***, x[:2, -1***REMOVED***.T***REMOVED***

    def test_finalize_gets_full_info(self***REMOVED***:
        # Array finalize should be called on the filled array.
        class SubClass(np.ndarray***REMOVED***:
            def __array_finalize__(self, old***REMOVED***:
                self.finalize_status = np.array(self***REMOVED***
                self.old = old

        s = np.arange(10***REMOVED***.view(SubClass***REMOVED***
        new_s = s[:3***REMOVED***
        assert_array_equal(new_s.finalize_status, new_s***REMOVED***
        assert_array_equal(new_s.old, s***REMOVED***

        new_s = s[[0,1,2,3***REMOVED******REMOVED***
        assert_array_equal(new_s.finalize_status, new_s***REMOVED***
        assert_array_equal(new_s.old, s***REMOVED***

        new_s = s[s > 0***REMOVED***
        assert_array_equal(new_s.finalize_status, new_s***REMOVED***
        assert_array_equal(new_s.old, s***REMOVED***

class TestFancingIndexingCast(TestCase***REMOVED***:
    def test_boolean_index_cast_assign(self***REMOVED***:
        # Setup the boolean index and float arrays.
        shape = (8, 63***REMOVED***
        bool_index = np.zeros(shape***REMOVED***.astype(bool***REMOVED***
        bool_index[0, 1***REMOVED*** = True
        zero_array = np.zeros(shape***REMOVED***

        # Assigning float is fine.
        zero_array[bool_index***REMOVED*** = np.array([1***REMOVED******REMOVED***
        assert_equal(zero_array[0, 1***REMOVED***, 1***REMOVED***

        # Fancy indexing works, although we get a cast warning.
        assert_warns(np.ComplexWarning,
                     zero_array.__setitem__, ([0***REMOVED***, [1***REMOVED******REMOVED***, np.array([2 + 1j***REMOVED******REMOVED******REMOVED***
        assert_equal(zero_array[0, 1***REMOVED***, 2***REMOVED***  # No complex part

        # Cast complex to float, throwing away the imaginary portion.
        assert_warns(np.ComplexWarning,
                     zero_array.__setitem__, bool_index, np.array([1j***REMOVED******REMOVED******REMOVED***
        assert_equal(zero_array[0, 1***REMOVED***, 0***REMOVED***

class TestFancyIndexingEquivalence(TestCase***REMOVED***:
    def test_object_assign(self***REMOVED***:
        # Check that the field and object special case using copyto is active.
        # The right hand side cannot be converted to an array here.
        a = np.arange(5, dtype=object***REMOVED***
        b = a.copy(***REMOVED***
        a[:3***REMOVED*** = [1, (1,2***REMOVED***, 3***REMOVED***
        b[[0, 1, 2***REMOVED******REMOVED*** = [1, (1,2***REMOVED***, 3***REMOVED***
        assert_array_equal(a, b***REMOVED***

        # test same for subspace fancy indexing
        b = np.arange(5, dtype=object***REMOVED***[None, :***REMOVED***
        b[[0***REMOVED***, :3***REMOVED*** = [[1, (1,2***REMOVED***, 3***REMOVED******REMOVED***
        assert_array_equal(a, b[0***REMOVED******REMOVED***

        # Check that swapping of axes works.
        # There was a bug that made the later assignment throw a ValueError
        # do to an incorrectly transposed temporary right hand side (gh-5714***REMOVED***
        b = b.T
        b[:3, [0***REMOVED******REMOVED*** = [[1***REMOVED***, [(1,2***REMOVED******REMOVED***, [3***REMOVED******REMOVED***
        assert_array_equal(a, b[:, 0***REMOVED******REMOVED***

        # Another test for the memory order of the subspace
        arr = np.ones((3, 4, 5***REMOVED***, dtype=object***REMOVED***
        # Equivalent slicing assignment for comparison
        cmp_arr = arr.copy(***REMOVED***
        cmp_arr[:1, ...***REMOVED*** = [[[1***REMOVED***, [2***REMOVED***, [3***REMOVED***, [4***REMOVED******REMOVED******REMOVED***
        arr[[0***REMOVED***, ...***REMOVED*** = [[[1***REMOVED***, [2***REMOVED***, [3***REMOVED***, [4***REMOVED******REMOVED******REMOVED***
        assert_array_equal(arr, cmp_arr***REMOVED***
        arr = arr.copy('F'***REMOVED***
        arr[[0***REMOVED***, ...***REMOVED*** = [[[1***REMOVED***, [2***REMOVED***, [3***REMOVED***, [4***REMOVED******REMOVED******REMOVED***
        assert_array_equal(arr, cmp_arr***REMOVED***

    def test_cast_equivalence(self***REMOVED***:
        # Yes, normal slicing uses unsafe casting.
        a = np.arange(5***REMOVED***
        b = a.copy(***REMOVED***

        a[:3***REMOVED*** = np.array(['2', '-3', '-1'***REMOVED******REMOVED***
        b[[0, 2, 1***REMOVED******REMOVED*** = np.array(['2', '-1', '-3'***REMOVED******REMOVED***
        assert_array_equal(a, b***REMOVED***

        # test the same for subspace fancy indexing
        b = np.arange(5***REMOVED***[None, :***REMOVED***
        b[[0***REMOVED***, :3***REMOVED*** = np.array([['2', '-3', '-1'***REMOVED******REMOVED******REMOVED***
        assert_array_equal(a, b[0***REMOVED******REMOVED***


class TestMultiIndexingAutomated(TestCase***REMOVED***:
    ***REMOVED***
     These test use code to mimic the C-Code indexing for selection.

     NOTE: * This still lacks tests for complex item setting.
           * If you change behavior of indexing, you might want to modify
             these tests to try more combinations.
           * Behavior was written to match numpy version 1.8. (though a
             first version matched 1.7.***REMOVED***
           * Only tuple indices are supported by the mimicking code.
             (and tested as of writing this***REMOVED***
           * Error types should match most of the time as long as there
             is only one error. For multiple errors, what gets raised
             will usually not be the same one. They are *not* tested.
    ***REMOVED***

    def setUp(self***REMOVED***:
        self.a = np.arange(np.prod([3, 1, 5, 6***REMOVED******REMOVED******REMOVED***.reshape(3, 1, 5, 6***REMOVED***
        self.b = np.empty((3, 0, 5, 6***REMOVED******REMOVED***
        self.complex_indices = ['skip', Ellipsis,
            0,
            # Boolean indices, up to 3-d for some special cases of eating up
            # dimensions, also need to test all False
            np.array(False***REMOVED***,
            np.array([True, False, False***REMOVED******REMOVED***,
            np.array([[True, False***REMOVED***, [False, True***REMOVED******REMOVED******REMOVED***,
            np.array([[[False, False***REMOVED***, [False, False***REMOVED******REMOVED******REMOVED******REMOVED***,
            # Some slices:
            slice(-5, 5, 2***REMOVED***,
            slice(1, 1, 100***REMOVED***,
            slice(4, -1, -2***REMOVED***,
            slice(None, None, -3***REMOVED***,
            # Some Fancy indexes:
            np.empty((0, 1, 1***REMOVED***, dtype=np.intp***REMOVED***,  # empty and can be broadcast
            np.array([0, 1, -2***REMOVED******REMOVED***,
            np.array([[2***REMOVED***, [0***REMOVED***, [1***REMOVED******REMOVED******REMOVED***,
            np.array([[0, -1***REMOVED***, [0, 1***REMOVED******REMOVED***, dtype=np.dtype('intp'***REMOVED***.newbyteorder(***REMOVED******REMOVED***,
            np.array([2, -1***REMOVED***, dtype=np.int8***REMOVED***,
            np.zeros([1***REMOVED****31, dtype=int***REMOVED***,  # trigger too large array.
            np.array([0., 1.***REMOVED******REMOVED******REMOVED***  # invalid datatype
        # Some simpler indices that still cover a bit more
        self.simple_indices = [Ellipsis, None, -1, [1***REMOVED***, np.array([True***REMOVED******REMOVED***, 'skip'***REMOVED***
        # Very simple ones to fill the rest:
        self.fill_indices = [slice(None, None***REMOVED***, 0***REMOVED***

    def _get_multi_index(self, arr, indices***REMOVED***:
        ***REMOVED***Mimic multi dimensional indexing.

        Parameters
        ----------
        arr : ndarray
            Array to be indexed.
        indices : tuple of index objects

        Returns
        -------
        out : ndarray
            An array equivalent to the indexing operation (but always a copy***REMOVED***.
            `arr[indices***REMOVED***` should be identical.
        no_copy : bool
            Whether the indexing operation requires a copy. If this is `True`,
            `np.may_share_memory(arr, arr[indicies***REMOVED******REMOVED***` should be `True` (with
            some exceptions for scalars and possibly 0-d arrays***REMOVED***.

        Notes
        -----
        While the function may mostly match the errors of normal indexing this
        is generally not the case.
        ***REMOVED***
        in_indices = list(indices***REMOVED***
        indices = [***REMOVED***
        # if False, this is a fancy or boolean index
        no_copy = True
        # number of fancy/scalar indexes that are not consecutive
        num_fancy = 0
        # number of dimensions indexed by a "fancy" index
        fancy_dim = 0
        # NOTE: This is a funny twist (and probably OK to change***REMOVED***.
        # The boolean array has illegal indexes, but this is
        # allowed if the broadcast fancy-indices are 0-sized.
        # This variable is to catch that case.
        error_unless_broadcast_to_empty = False

        # We need to handle Ellipsis and make arrays from indices, also
        # check if this is fancy indexing (set no_copy***REMOVED***.
        ndim = 0
        ellipsis_pos = None  # define here mostly to replace all but first.
        for i, indx in enumerate(in_indices***REMOVED***:
            if indx is None:
                continue
            if isinstance(indx, np.ndarray***REMOVED*** and indx.dtype == bool:
                no_copy = False
                if indx.ndim == 0:
                    raise IndexError
                # boolean indices can have higher dimensions
                ndim += indx.ndim
                fancy_dim += indx.ndim
                continue
            if indx is Ellipsis:
                if ellipsis_pos is None:
                    ellipsis_pos = i
                    continue  # do not increment ndim counter
                raise IndexError
            if isinstance(indx, slice***REMOVED***:
                ndim += 1
                continue
            if not isinstance(indx, np.ndarray***REMOVED***:
                # This could be open for changes in numpy.
                # numpy should maybe raise an error if casting to intp
                # is not safe. It rejects np.array([1., 2.***REMOVED******REMOVED*** but not
                # [1., 2.***REMOVED*** as index (same for ie. np.take***REMOVED***.
                # (Note the importance of empty lists if changing this here***REMOVED***
                indx = np.array(indx, dtype=np.intp***REMOVED***
                in_indices[i***REMOVED*** = indx
            elif indx.dtype.kind != 'b' and indx.dtype.kind != 'i':
                raise IndexError('arrays used as indices must be of integer (or boolean***REMOVED*** type'***REMOVED***
            if indx.ndim != 0:
                no_copy = False
            ndim += 1
            fancy_dim += 1

        if arr.ndim - ndim < 0:
            # we can't take more dimensions then we have, not even for 0-d arrays.
            # since a[(***REMOVED******REMOVED*** makes sense, but not a[(***REMOVED***,***REMOVED***. We will raise an error
            # later on, unless a broadcasting error occurs first.
            raise IndexError

        if ndim == 0 and None not in in_indices:
            # Well we have no indexes or one Ellipsis. This is legal.
            return arr.copy(***REMOVED***, no_copy

        if ellipsis_pos is not None:
            in_indices[ellipsis_pos:ellipsis_pos+1***REMOVED*** = [slice(None, None***REMOVED******REMOVED*** * (arr.ndim - ndim***REMOVED***

        for ax, indx in enumerate(in_indices***REMOVED***:
            if isinstance(indx, slice***REMOVED***:
                # convert to an index array
                indx = np.arange(*indx.indices(arr.shape[ax***REMOVED******REMOVED******REMOVED***
                indices.append(['s', indx***REMOVED******REMOVED***
                continue
            elif indx is None:
                # this is like taking a slice with one element from a new axis:
                indices.append(['n', np.array([0***REMOVED***, dtype=np.intp***REMOVED******REMOVED******REMOVED***
                arr = arr.reshape((arr.shape[:ax***REMOVED*** + (1,***REMOVED*** + arr.shape[ax:***REMOVED******REMOVED******REMOVED***
                continue
            if isinstance(indx, np.ndarray***REMOVED*** and indx.dtype == bool:
                if indx.shape != arr.shape[ax:ax+indx.ndim***REMOVED***:
                    raise IndexError

                ***REMOVED***
                    flat_indx = np.ravel_multi_index(np.nonzero(indx***REMOVED***,
                                    arr.shape[ax:ax+indx.ndim***REMOVED***, mode='raise'***REMOVED***
                ***REMOVED***
                    error_unless_broadcast_to_empty = True
                    # fill with 0s instead, and raise error later
                    flat_indx = np.array([0***REMOVED****indx.sum(***REMOVED***, dtype=np.intp***REMOVED***
                # concatenate axis into a single one:
                if indx.ndim != 0:
                    arr = arr.reshape((arr.shape[:ax***REMOVED***
                                  + (np.prod(arr.shape[ax:ax+indx.ndim***REMOVED******REMOVED***,***REMOVED***
                                  + arr.shape[ax+indx.ndim:***REMOVED******REMOVED******REMOVED***
                    indx = flat_indx
                else:
                    # This could be changed, a 0-d boolean index can
                    # make sense (even outside the 0-d indexed array case***REMOVED***
                    # Note that originally this is could be interpreted as
                    # integer in the full integer special case.
                    raise IndexError
            else:
                # If the index is a singleton, the bounds check is done
                # before the broadcasting. This used to be different in <1.9
                if indx.ndim == 0:
                    if indx >= arr.shape[ax***REMOVED*** or indx < -arr.shape[ax***REMOVED***:
                        raise IndexError
            if indx.ndim == 0:
                # The index is a scalar. This used to be two fold, but if fancy
                # indexing was active, the check was done later, possibly
                # after broadcasting it away (1.7. or earlier***REMOVED***. Now it is always
                # done.
                if indx >= arr.shape[ax***REMOVED*** or indx < - arr.shape[ax***REMOVED***:
                    raise IndexError
            if len(indices***REMOVED*** > 0 and indices[-1***REMOVED***[0***REMOVED*** == 'f' and ax != ellipsis_pos:
                # NOTE: There could still have been a 0-sized Ellipsis
                # between them. Checked that with ellipsis_pos.
                indices[-1***REMOVED***.append(indx***REMOVED***
            else:
                # We have a fancy index that is not after an existing one.
                # NOTE: A 0-d array triggers this as well, while
                # one may expect it to not trigger it, since a scalar
                # would not be considered fancy indexing.
                num_fancy += 1
                indices.append(['f', indx***REMOVED******REMOVED***

        if num_fancy > 1 and not no_copy:
            # We have to flush the fancy indexes left
            new_indices = indices[:***REMOVED***
            axes = list(range(arr.ndim***REMOVED******REMOVED***
            fancy_axes = [***REMOVED***
            new_indices.insert(0, ['f'***REMOVED******REMOVED***
            ni = 0
            ai = 0
            for indx in indices:
                ni += 1
                if indx[0***REMOVED*** == 'f':
                    new_indices[0***REMOVED***.extend(indx[1:***REMOVED******REMOVED***
                    del new_indices[ni***REMOVED***
                    ni -= 1
                    for ax in range(ai, ai + len(indx[1:***REMOVED******REMOVED******REMOVED***:
                        fancy_axes.append(ax***REMOVED***
                        axes.remove(ax***REMOVED***
                ai += len(indx***REMOVED*** - 1  # axis we are at
            indices = new_indices
            # and now we need to transpose arr:
            arr = arr.transpose(*(fancy_axes + axes***REMOVED******REMOVED***

        # We only have one 'f' index now and arr is transposed accordingly.
        # Now handle newaxis by reshaping...
        ax = 0
        for indx in indices:
            if indx[0***REMOVED*** == 'f':
                if len(indx***REMOVED*** == 1:
                    continue
                # First of all, reshape arr to combine fancy axes into one:
                orig_shape = arr.shape
                orig_slice = orig_shape[ax:ax + len(indx[1:***REMOVED******REMOVED******REMOVED***
                arr = arr.reshape((arr.shape[:ax***REMOVED***
                                    + (np.prod(orig_slice***REMOVED***.astype(int***REMOVED***,***REMOVED***
                                    + arr.shape[ax + len(indx[1:***REMOVED******REMOVED***:***REMOVED******REMOVED******REMOVED***

                # Check if broadcasting works
                res = np.broadcast(*indx[1:***REMOVED******REMOVED***
                # unfortunately the indices might be out of bounds. So check
                # that first, and use mode='wrap' then. However only if
                # there are any indices...
                if res.size != 0:
                    if error_unless_broadcast_to_empty:
                        raise IndexError
                    for _indx, _size in zip(indx[1:***REMOVED***, orig_slice***REMOVED***:
                        if _indx.size == 0:
                            continue
                        if np.any(_indx >= _size***REMOVED*** or np.any(_indx < -_size***REMOVED***:
                                raise IndexError
                if len(indx[1:***REMOVED******REMOVED*** == len(orig_slice***REMOVED***:
                    if np.product(orig_slice***REMOVED*** == 0:
                        # Work around for a crash or IndexError with 'wrap'
                        # in some 0-sized cases.
                        ***REMOVED***
                            mi = np.ravel_multi_index(indx[1:***REMOVED***, orig_slice, mode='raise'***REMOVED***
                        ***REMOVED***
                            # This happens with 0-sized orig_slice (sometimes?***REMOVED***
                            # here it is a ValueError, but indexing gives a:
                            raise IndexError('invalid index into 0-sized'***REMOVED***
                    else:
                        mi = np.ravel_multi_index(indx[1:***REMOVED***, orig_slice, mode='wrap'***REMOVED***
                else:
                    # Maybe never happens...
                    raise ValueError
                arr = arr.take(mi.ravel(***REMOVED***, axis=ax***REMOVED***
                arr = arr.reshape((arr.shape[:ax***REMOVED***
                                    + mi.shape
                                    + arr.shape[ax+1:***REMOVED******REMOVED******REMOVED***
                ax += mi.ndim
                continue

            # If we are here, we have a 1D array for take:
            arr = arr.take(indx[1***REMOVED***, axis=ax***REMOVED***
            ax += 1

        return arr, no_copy

    def _check_multi_index(self, arr, index***REMOVED***:
        ***REMOVED***Check a multi index item getting and simple setting.

        Parameters
        ----------
        arr : ndarray
            Array to be indexed, must be a reshaped arange.
        index : tuple of indexing objects
            Index being tested.
        ***REMOVED***
        # Test item getting
        ***REMOVED***
            mimic_get, no_copy = self._get_multi_index(arr, index***REMOVED***
        except Exception:
            prev_refcount = sys.getrefcount(arr***REMOVED***
            assert_raises(Exception, arr.__getitem__, index***REMOVED***
            assert_raises(Exception, arr.__setitem__, index, 0***REMOVED***
            assert_equal(prev_refcount, sys.getrefcount(arr***REMOVED******REMOVED***
            return

        self._compare_index_result(arr, index, mimic_get, no_copy***REMOVED***

    def _check_single_index(self, arr, index***REMOVED***:
        ***REMOVED***Check a single index item getting and simple setting.

        Parameters
        ----------
        arr : ndarray
            Array to be indexed, must be an arange.
        index : indexing object
            Index being tested. Must be a single index and not a tuple
            of indexing objects (see also `_check_multi_index`***REMOVED***.
        ***REMOVED***
        ***REMOVED***
            mimic_get, no_copy = self._get_multi_index(arr, (index,***REMOVED******REMOVED***
        except Exception:
            prev_refcount = sys.getrefcount(arr***REMOVED***
            assert_raises(Exception, arr.__getitem__, index***REMOVED***
            assert_raises(Exception, arr.__setitem__, index, 0***REMOVED***
            assert_equal(prev_refcount, sys.getrefcount(arr***REMOVED******REMOVED***
            return

        self._compare_index_result(arr, index, mimic_get, no_copy***REMOVED***

    def _compare_index_result(self, arr, index, mimic_get, no_copy***REMOVED***:
        ***REMOVED***Compare mimicked result to indexing result.
        ***REMOVED***
        arr = arr.copy(***REMOVED***
        indexed_arr = arr[index***REMOVED***
        assert_array_equal(indexed_arr, mimic_get***REMOVED***
        # Check if we got a view, unless its a 0-sized or 0-d array.
        # (then its not a view, and that does not matter***REMOVED***
        if indexed_arr.size != 0 and indexed_arr.ndim != 0:
            assert_(np.may_share_memory(indexed_arr, arr***REMOVED*** == no_copy***REMOVED***
            # Check reference count of the original array
            if no_copy:
                # refcount increases by one:
                assert_equal(sys.getrefcount(arr***REMOVED***, 3***REMOVED***
            else:
                assert_equal(sys.getrefcount(arr***REMOVED***, 2***REMOVED***

        # Test non-broadcast setitem:
        b = arr.copy(***REMOVED***
        b[index***REMOVED*** = mimic_get + 1000
        if b.size == 0:
            return  # nothing to compare here...
        if no_copy and indexed_arr.ndim != 0:
            # change indexed_arr in-place to manipulate original:
            indexed_arr += 1000
            assert_array_equal(arr, b***REMOVED***
            return
        # Use the fact that the array is originally an arange:
        arr.flat[indexed_arr.ravel(***REMOVED******REMOVED*** += 1000
        assert_array_equal(arr, b***REMOVED***

    def test_boolean(self***REMOVED***:
        a = np.array(5***REMOVED***
        assert_equal(a[np.array(True***REMOVED******REMOVED***, 5***REMOVED***
        a[np.array(True***REMOVED******REMOVED*** = 1
        assert_equal(a, 1***REMOVED***
        # NOTE: This is different from normal broadcasting, as
        # arr[boolean_array***REMOVED*** works like in a multi index. Which means
        # it is aligned to the left. This is probably correct for
        # consistency with arr[boolean_array,***REMOVED*** also no broadcasting
        # is done at all
        self._check_multi_index(self.a, (np.zeros_like(self.a, dtype=bool***REMOVED***,***REMOVED******REMOVED***
        self._check_multi_index(self.a, (np.zeros_like(self.a, dtype=bool***REMOVED***[..., 0***REMOVED***,***REMOVED******REMOVED***
        self._check_multi_index(self.a, (np.zeros_like(self.a, dtype=bool***REMOVED***[None, ...***REMOVED***,***REMOVED******REMOVED***

    def test_multidim(self***REMOVED***:
        # Automatically test combinations with complex indexes on 2nd (or 1st***REMOVED***
        # spot and the simple ones in one other spot.
        with warnings.catch_warnings(***REMOVED***:
            # This is so that np.array(True***REMOVED*** is not accepted in a full integer
            # index, when running the file separately.
            warnings.filterwarnings('error', '', DeprecationWarning***REMOVED***
            warnings.filterwarnings('error', '', np.VisibleDeprecationWarning***REMOVED***

            def isskip(idx***REMOVED***:
                return isinstance(idx, str***REMOVED*** and idx == "skip"

            for simple_pos in [0, 2, 3***REMOVED***:
                tocheck = [self.fill_indices, self.complex_indices,
                           self.fill_indices, self.fill_indices***REMOVED***
                tocheck[simple_pos***REMOVED*** = self.simple_indices
                for index in product(*tocheck***REMOVED***:
                    index = tuple(i for i in index if not isskip(i***REMOVED******REMOVED***
                    self._check_multi_index(self.a, index***REMOVED***
                    self._check_multi_index(self.b, index***REMOVED***

        # Check very simple item getting:
        self._check_multi_index(self.a, (0, 0, 0, 0***REMOVED******REMOVED***
        self._check_multi_index(self.b, (0, 0, 0, 0***REMOVED******REMOVED***
        # Also check (simple cases of***REMOVED*** too many indices:
        assert_raises(IndexError, self.a.__getitem__, (0, 0, 0, 0, 0***REMOVED******REMOVED***
        assert_raises(IndexError, self.a.__setitem__, (0, 0, 0, 0, 0***REMOVED***, 0***REMOVED***
        assert_raises(IndexError, self.a.__getitem__, (0, 0, [1***REMOVED***, 0, 0***REMOVED******REMOVED***
        assert_raises(IndexError, self.a.__setitem__, (0, 0, [1***REMOVED***, 0, 0***REMOVED***, 0***REMOVED***

    def test_1d(self***REMOVED***:
        a = np.arange(10***REMOVED***
        with warnings.catch_warnings(***REMOVED***:
            warnings.filterwarnings('error', '', np.VisibleDeprecationWarning***REMOVED***
            for index in self.complex_indices:
                self._check_single_index(a, index***REMOVED***


class TestCApiAccess(TestCase***REMOVED***:
    def test_getitem(self***REMOVED***:
        subscript = functools.partial(array_indexing, 0***REMOVED***

        # 0-d arrays don't work:
        assert_raises(IndexError, subscript, np.ones((***REMOVED******REMOVED***, 0***REMOVED***
        # Out of bound values:
        assert_raises(IndexError, subscript, np.ones(10***REMOVED***, 11***REMOVED***
        assert_raises(IndexError, subscript, np.ones(10***REMOVED***, -11***REMOVED***
        assert_raises(IndexError, subscript, np.ones((10, 10***REMOVED******REMOVED***, 11***REMOVED***
        assert_raises(IndexError, subscript, np.ones((10, 10***REMOVED******REMOVED***, -11***REMOVED***

        a = np.arange(10***REMOVED***
        assert_array_equal(a[4***REMOVED***, subscript(a, 4***REMOVED******REMOVED***
        a = a.reshape(5, 2***REMOVED***
        assert_array_equal(a[-4***REMOVED***, subscript(a, -4***REMOVED******REMOVED***

    def test_setitem(self***REMOVED***:
        assign = functools.partial(array_indexing, 1***REMOVED***

        # Deletion is impossible:
        assert_raises(ValueError, assign, np.ones(10***REMOVED***, 0***REMOVED***
        # 0-d arrays don't work:
        assert_raises(IndexError, assign, np.ones((***REMOVED******REMOVED***, 0, 0***REMOVED***
        # Out of bound values:
        assert_raises(IndexError, assign, np.ones(10***REMOVED***, 11, 0***REMOVED***
        assert_raises(IndexError, assign, np.ones(10***REMOVED***, -11, 0***REMOVED***
        assert_raises(IndexError, assign, np.ones((10, 10***REMOVED******REMOVED***, 11, 0***REMOVED***
        assert_raises(IndexError, assign, np.ones((10, 10***REMOVED******REMOVED***, -11, 0***REMOVED***

        a = np.arange(10***REMOVED***
        assign(a, 4, 10***REMOVED***
        assert_(a[4***REMOVED*** == 10***REMOVED***

        a = a.reshape(5, 2***REMOVED***
        assign(a, 4, 10***REMOVED***
        assert_array_equal(a[-1***REMOVED***, [10, 10***REMOVED******REMOVED***


if __name__ == "__main__":
    run_module_suite(***REMOVED***
