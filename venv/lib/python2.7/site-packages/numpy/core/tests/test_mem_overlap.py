from __future__ import division, absolute_import, print_function

import sys
import itertools

import numpy as np
from numpy.testing import run_module_suite, assert_, assert_raises, assert_equal

from numpy.core.multiarray_tests import solve_diophantine, internal_overlap
from numpy.lib.stride_tricks import as_strided
from numpy.compat import long

if sys.version_info[0***REMOVED*** >= 3:
    xrange = range


ndims = 2
size = 10
shape = tuple([size***REMOVED*** * ndims***REMOVED***

MAY_SHARE_BOUNDS = 0
MAY_SHARE_EXACT = -1


def _indices_for_nelems(nelems***REMOVED***:
    ***REMOVED***Returns slices of length nelems, from start onwards, in direction sign.***REMOVED***

    if nelems == 0:
        return [size // 2***REMOVED***  # int index

    res = [***REMOVED***
    for step in (1, 2***REMOVED***:
        for sign in (-1, 1***REMOVED***:
            start = size // 2 - nelems * step * sign // 2
            stop = start + nelems * step * sign
            res.append(slice(start, stop, step * sign***REMOVED******REMOVED***

    return res


def _indices_for_axis(***REMOVED***:
    ***REMOVED***Returns (src, dst***REMOVED*** pairs of indices.***REMOVED***

    res = [***REMOVED***
    for nelems in (0, 2, 3***REMOVED***:
        ind = _indices_for_nelems(nelems***REMOVED***

        # no itertools.product available in Py2.4
        res.extend([(a, b***REMOVED*** for a in ind for b in ind***REMOVED******REMOVED***  # all assignments of size "nelems"

    return res


def _indices(ndims***REMOVED***:
    ***REMOVED***Returns ((axis0_src, axis0_dst***REMOVED***, (axis1_src, axis1_dst***REMOVED***, ... ***REMOVED*** index pairs.***REMOVED***

    ind = _indices_for_axis(***REMOVED***

    # no itertools.product available in Py2.4

    res = [[***REMOVED******REMOVED***
    for i in range(ndims***REMOVED***:
        newres = [***REMOVED***
        for elem in ind:
            for others in res:
                newres.append([elem***REMOVED*** + others***REMOVED***
        res = newres

    return res


def _check_assignment(srcidx, dstidx***REMOVED***:
    ***REMOVED***Check assignment arr[dstidx***REMOVED*** = arr[srcidx***REMOVED*** works.***REMOVED***

    arr = np.arange(np.product(shape***REMOVED******REMOVED***.reshape(shape***REMOVED***

    cpy = arr.copy(***REMOVED***

    cpy[dstidx***REMOVED*** = arr[srcidx***REMOVED***
    arr[dstidx***REMOVED*** = arr[srcidx***REMOVED***

    assert_(np.all(arr == cpy***REMOVED***,
            'assigning arr[%s***REMOVED*** = arr[%s***REMOVED***' % (dstidx, srcidx***REMOVED******REMOVED***


def test_overlapping_assignments(***REMOVED***:
    ***REMOVED***Test automatically generated assignments which overlap in memory.***REMOVED***

    inds = _indices(ndims***REMOVED***

    for ind in inds:
        srcidx = tuple([a[0***REMOVED*** for a in ind***REMOVED******REMOVED***
        dstidx = tuple([a[1***REMOVED*** for a in ind***REMOVED******REMOVED***

        yield _check_assignment, srcidx, dstidx


def test_diophantine_fuzz(***REMOVED***:
    # Fuzz test the diophantine solver
    rng = np.random.RandomState(1234***REMOVED***

    max_int = np.iinfo(np.intp***REMOVED***.max

    for ndim in range(10***REMOVED***:
        feasible_count = 0
        infeasible_count = 0

        min_count = 500//(ndim + 1***REMOVED***

        numbers = [***REMOVED***
        while min(feasible_count, infeasible_count***REMOVED*** < min_count:
            # Ensure big and small integer problems
            A_max = 1 + rng.randint(0, 11, dtype=np.intp***REMOVED*****6
            U_max = rng.randint(0, 11, dtype=np.intp***REMOVED*****6

            A_max = min(max_int, A_max***REMOVED***
            U_max = min(max_int-1, U_max***REMOVED***

            A = tuple(int(rng.randint(1, A_max+1, dtype=np.intp***REMOVED******REMOVED***
                      for j in range(ndim***REMOVED******REMOVED***
            U = tuple(int(rng.randint(0, U_max+2, dtype=np.intp***REMOVED******REMOVED***
                      for j in range(ndim***REMOVED******REMOVED***

            b_ub = min(max_int-2, sum(a*ub for a, ub in zip(A, U***REMOVED******REMOVED******REMOVED***
            b = rng.randint(-1, b_ub+2, dtype=np.intp***REMOVED***

            if ndim == 0 and feasible_count < min_count:
                b = 0

            X = solve_diophantine(A, U, b***REMOVED***

            if X is None:
                # Check the simplified decision problem agrees
                X_simplified = solve_diophantine(A, U, b, simplify=1***REMOVED***
                assert_(X_simplified is None, (A, U, b, X_simplified***REMOVED******REMOVED***

                # Check no solution exists (provided the problem is
                # small enough so that brute force checking doesn't
                # take too long***REMOVED***
                ***REMOVED***
                    ranges = tuple(xrange(0, a*ub+1, a***REMOVED*** for a, ub in zip(A, U***REMOVED******REMOVED***
                except OverflowError:
                    # xrange on 32-bit Python 2 may overflow
                    continue

                size = 1
                for r in ranges:
                    size *= len(r***REMOVED***
                if size < 100000:
                    assert_(not any(sum(w***REMOVED*** == b for w in itertools.product(*ranges***REMOVED******REMOVED******REMOVED***
                    infeasible_count += 1
            else:
                # Check the simplified decision problem agrees
                X_simplified = solve_diophantine(A, U, b, simplify=1***REMOVED***
                assert_(X_simplified is not None, (A, U, b, X_simplified***REMOVED******REMOVED***

                # Check validity
                assert_(sum(a*x for a, x in zip(A, X***REMOVED******REMOVED*** == b***REMOVED***
                assert_(all(0 <= x <= ub for x, ub in zip(X, U***REMOVED******REMOVED******REMOVED***
                feasible_count += 1


def test_diophantine_overflow(***REMOVED***:
    # Smoke test integer overflow detection
    max_intp = np.iinfo(np.intp***REMOVED***.max
    max_int64 = np.iinfo(np.int64***REMOVED***.max

    if max_int64 <= max_intp:
        # Check that the algorithm works internally in 128-bit;
        # solving this problem requires large intermediate numbers
        A = (max_int64//2, max_int64//2 - 10***REMOVED***
        U = (max_int64//2, max_int64//2 - 10***REMOVED***
        b = 2*(max_int64//2***REMOVED*** - 10

        assert_equal(solve_diophantine(A, U, b***REMOVED***, (1, 1***REMOVED******REMOVED***


def check_may_share_memory_exact(a, b***REMOVED***:
    got = np.may_share_memory(a, b, max_work=MAY_SHARE_EXACT***REMOVED***

    assert_equal(np.may_share_memory(a, b***REMOVED***,
                 np.may_share_memory(a, b, max_work=MAY_SHARE_BOUNDS***REMOVED******REMOVED***

    a.fill(0***REMOVED***
    b.fill(0***REMOVED***
    a.fill(1***REMOVED***
    exact = b.any(***REMOVED***

    err_msg = ""
    if got != exact:
        err_msg = "    " + "\n    ".join([
            "base_a - base_b = %r" % (a.__array_interface__['data'***REMOVED***[0***REMOVED*** - b.__array_interface__['data'***REMOVED***[0***REMOVED***,***REMOVED***,
            "shape_a = %r" % (a.shape,***REMOVED***,
            "shape_b = %r" % (b.shape,***REMOVED***,
            "strides_a = %r" % (a.strides,***REMOVED***,
            "strides_b = %r" % (b.strides,***REMOVED***,
            "size_a = %r" % (a.size,***REMOVED***,
            "size_b = %r" % (b.size,***REMOVED***
        ***REMOVED******REMOVED***

    assert_equal(got, exact, err_msg=err_msg***REMOVED***


def test_may_share_memory_manual(***REMOVED***:
    # Manual test cases for may_share_memory

    # Base arrays
    xs0 = [
        np.zeros([13, 21, 23, 22***REMOVED***, dtype=np.int8***REMOVED***,
        np.zeros([13, 21, 23*2, 22***REMOVED***, dtype=np.int8***REMOVED***[:,:,::2,:***REMOVED***
    ***REMOVED***

    # Generate all negative stride combinations
    xs = [***REMOVED***
    for x in xs0:
        for ss in itertools.product(*(([slice(None***REMOVED***, slice(None, None, -1***REMOVED******REMOVED***,***REMOVED****4***REMOVED******REMOVED***:
            xp = x[ss***REMOVED***
            xs.append(xp***REMOVED***

    for x in xs:
        # The default is a simple extent check
        assert_(np.may_share_memory(x[:,0,:***REMOVED***, x[:,1,:***REMOVED******REMOVED******REMOVED***
        assert_(np.may_share_memory(x[:,0,:***REMOVED***, x[:,1,:***REMOVED***, max_work=None***REMOVED******REMOVED***

        # Exact checks
        check_may_share_memory_exact(x[:,0,:***REMOVED***, x[:,1,:***REMOVED******REMOVED***
        check_may_share_memory_exact(x[:,::7***REMOVED***, x[:,3::3***REMOVED******REMOVED***

        ***REMOVED***
            xp = x.ravel(***REMOVED***
            if xp.flags.owndata:
                continue
            xp = xp.view(np.int16***REMOVED***
        except ValueError:
            continue

        # 0-size arrays cannot overlap
        check_may_share_memory_exact(x.ravel(***REMOVED***[6:6***REMOVED***,
                                     xp.reshape(13, 21, 23, 11***REMOVED***[:,::7***REMOVED******REMOVED***

        # Test itemsize is dealt with
        check_may_share_memory_exact(x[:,::7***REMOVED***,
                                     xp.reshape(13, 21, 23, 11***REMOVED******REMOVED***
        check_may_share_memory_exact(x[:,::7***REMOVED***,
                                     xp.reshape(13, 21, 23, 11***REMOVED***[:,3::3***REMOVED******REMOVED***
        check_may_share_memory_exact(x.ravel(***REMOVED***[6:7***REMOVED***,
                                     xp.reshape(13, 21, 23, 11***REMOVED***[:,::7***REMOVED******REMOVED***

    # Check unit size
    x = np.zeros([1***REMOVED***, dtype=np.int8***REMOVED***
    check_may_share_memory_exact(x, x***REMOVED***
    check_may_share_memory_exact(x, x.copy(***REMOVED******REMOVED***


def check_may_share_memory_easy_fuzz(get_max_work, same_steps, min_count***REMOVED***:
    # Check that overlap problems with common strides are solved with
    # little work.
    x = np.zeros([17,34,71,97***REMOVED***, dtype=np.int16***REMOVED***

    rng = np.random.RandomState(1234***REMOVED***

    def random_slice(n, step***REMOVED***:
        start = rng.randint(0, n+1, dtype=np.intp***REMOVED***
        stop = rng.randint(start, n+1, dtype=np.intp***REMOVED***
        if rng.randint(0, 2, dtype=np.intp***REMOVED*** == 0:
            stop, start = start, stop
            step *= -1
        return slice(start, stop, step***REMOVED***

    feasible = 0
    infeasible = 0

    while min(feasible, infeasible***REMOVED*** < min_count:
        steps = tuple(rng.randint(1, 11, dtype=np.intp***REMOVED***
                      if rng.randint(0, 5, dtype=np.intp***REMOVED*** == 0 else 1
                      for j in range(x.ndim***REMOVED******REMOVED***
        if same_steps:
            steps2 = steps
        else:
            steps2 = tuple(rng.randint(1, 11, dtype=np.intp***REMOVED***
                           if rng.randint(0, 5, dtype=np.intp***REMOVED*** == 0 else 1
                           for j in range(x.ndim***REMOVED******REMOVED***

        t1 = np.arange(x.ndim***REMOVED***
        rng.shuffle(t1***REMOVED***

        t2 = np.arange(x.ndim***REMOVED***
        rng.shuffle(t2***REMOVED***

        s1 = tuple(random_slice(p, s***REMOVED*** for p, s in zip(x.shape, steps***REMOVED******REMOVED***
        s2 = tuple(random_slice(p, s***REMOVED*** for p, s in zip(x.shape, steps2***REMOVED******REMOVED***
        a = x[s1***REMOVED***.transpose(t1***REMOVED***
        b = x[s2***REMOVED***.transpose(t2***REMOVED***

        bounds_overlap = np.may_share_memory(a, b***REMOVED***
        may_share_answer = np.may_share_memory(a, b***REMOVED***
        easy_answer = np.may_share_memory(a, b, max_work=get_max_work(a, b***REMOVED******REMOVED***
        exact_answer = np.may_share_memory(a, b, max_work=MAY_SHARE_EXACT***REMOVED***

        if easy_answer != exact_answer:
            # assert_equal is slow...
            assert_equal(easy_answer, exact_answer, err_msg=repr((s1, s2***REMOVED******REMOVED******REMOVED***

        if may_share_answer != bounds_overlap:
            assert_equal(may_share_answer, bounds_overlap,
                         err_msg=repr((s1, s2***REMOVED******REMOVED******REMOVED***

        if bounds_overlap:
            if exact_answer:
                feasible += 1
            else:
                infeasible += 1


def test_may_share_memory_easy_fuzz(***REMOVED***:
    # Check that overlap problems with common strides are always
    # solved with little work.

    check_may_share_memory_easy_fuzz(get_max_work=lambda a, b: 1,
                                     same_steps=True,
                                     min_count=2000***REMOVED***


def test_may_share_memory_harder_fuzz(***REMOVED***:
    # Overlap problems with not necessarily common strides take more
    # work.
    #
    # The work bound below can't be reduced much. Harder problems can
    # also exist but not be detected here, as the set of problems
    # comes from RNG.

    check_may_share_memory_easy_fuzz(get_max_work=lambda a, b: max(a.size, b.size***REMOVED***//2,
                                     same_steps=False,
                                     min_count=2000***REMOVED***


def test_shares_memory_api(***REMOVED***:
    x = np.zeros([4, 5, 6***REMOVED***, dtype=np.int8***REMOVED***

    assert_equal(np.shares_memory(x, x***REMOVED***, True***REMOVED***
    assert_equal(np.shares_memory(x, x.copy(***REMOVED******REMOVED***, False***REMOVED***

    a = x[:,::2,::3***REMOVED***
    b = x[:,::3,::2***REMOVED***
    assert_equal(np.shares_memory(a, b***REMOVED***, True***REMOVED***
    assert_equal(np.shares_memory(a, b, max_work=None***REMOVED***, True***REMOVED***
    assert_raises(np.TooHardError, np.shares_memory, a, b, max_work=1***REMOVED***
    assert_raises(np.TooHardError, np.shares_memory, a, b, max_work=long(1***REMOVED******REMOVED***


def test_internal_overlap_diophantine(***REMOVED***:
    def check(A, U, exists=None***REMOVED***:
        X = solve_diophantine(A, U, 0, require_ub_nontrivial=1***REMOVED***

        if exists is None:
            exists = (X is not None***REMOVED***

        if X is not None:
            assert_(sum(a*x for a, x in zip(A, X***REMOVED******REMOVED*** == sum(a*u//2 for a, u in zip(A, U***REMOVED******REMOVED******REMOVED***
            assert_(all(0 <= x <= u for x, u in zip(X, U***REMOVED******REMOVED******REMOVED***
            assert_(any(x != u//2 for x, u in zip(X, U***REMOVED******REMOVED******REMOVED***

        if exists:
            assert_(X is not None, repr(X***REMOVED******REMOVED***
        else:
            assert_(X is None, repr(X***REMOVED******REMOVED***

    # Smoke tests
    check((3, 2***REMOVED***, (2*2, 3*2***REMOVED***, exists=True***REMOVED***
    check((3*2, 2***REMOVED***, (15*2, (3-1***REMOVED****2***REMOVED***, exists=False***REMOVED***


def test_internal_overlap_slices(***REMOVED***:
    # Slicing an array never generates internal overlap

    x = np.zeros([17,34,71,97***REMOVED***, dtype=np.int16***REMOVED***

    rng = np.random.RandomState(1234***REMOVED***

    def random_slice(n, step***REMOVED***:
        start = rng.randint(0, n+1, dtype=np.intp***REMOVED***
        stop = rng.randint(start, n+1, dtype=np.intp***REMOVED***
        if rng.randint(0, 2, dtype=np.intp***REMOVED*** == 0:
            stop, start = start, stop
            step *= -1
        return slice(start, stop, step***REMOVED***

    cases = 0
    min_count = 5000

    while cases < min_count:
        steps = tuple(rng.randint(1, 11, dtype=np.intp***REMOVED***
                      if rng.randint(0, 5, dtype=np.intp***REMOVED*** == 0 else 1
                      for j in range(x.ndim***REMOVED******REMOVED***
        t1 = np.arange(x.ndim***REMOVED***
        rng.shuffle(t1***REMOVED***
        s1 = tuple(random_slice(p, s***REMOVED*** for p, s in zip(x.shape, steps***REMOVED******REMOVED***
        a = x[s1***REMOVED***.transpose(t1***REMOVED***

        assert_(not internal_overlap(a***REMOVED******REMOVED***
        cases += 1


def check_internal_overlap(a, manual_expected=None***REMOVED***:
    got = internal_overlap(a***REMOVED***

    # Brute-force check
    m = set(***REMOVED***
    ranges = tuple(xrange(n***REMOVED*** for n in a.shape***REMOVED***
    for v in itertools.product(*ranges***REMOVED***:
        offset = sum(s*w for s, w in zip(a.strides, v***REMOVED******REMOVED***
        if offset in m:
            expected = True
            break
        else:
            m.add(offset***REMOVED***
    else:
        expected = False

    # Compare
    if got != expected:
        assert_equal(got, expected, err_msg=repr((a.strides, a.shape***REMOVED******REMOVED******REMOVED***
    if manual_expected is not None and expected != manual_expected:
        assert_equal(expected, manual_expected***REMOVED***
    return got


def test_internal_overlap_manual(***REMOVED***:
    # Stride tricks can construct arrays with internal overlap

    # We don't care about memory bounds, the array is not
    # read/write accessed
    x = np.arange(1***REMOVED***.astype(np.int8***REMOVED***

    # Check low-dimensional special cases

    check_internal_overlap(x, False***REMOVED*** # 1-dim
    check_internal_overlap(x.reshape([***REMOVED******REMOVED***, False***REMOVED*** # 0-dim

    a = as_strided(x, strides=(3, 4***REMOVED***, shape=(4, 4***REMOVED******REMOVED***
    check_internal_overlap(a, False***REMOVED***

    a = as_strided(x, strides=(3, 4***REMOVED***, shape=(5, 4***REMOVED******REMOVED***
    check_internal_overlap(a, True***REMOVED***

    a = as_strided(x, strides=(0,***REMOVED***, shape=(0,***REMOVED******REMOVED***
    check_internal_overlap(a, False***REMOVED***

    a = as_strided(x, strides=(0,***REMOVED***, shape=(1,***REMOVED******REMOVED***
    check_internal_overlap(a, False***REMOVED***

    a = as_strided(x, strides=(0,***REMOVED***, shape=(2,***REMOVED******REMOVED***
    check_internal_overlap(a, True***REMOVED***

    a = as_strided(x, strides=(0, -9993***REMOVED***, shape=(87, 22***REMOVED******REMOVED***
    check_internal_overlap(a, True***REMOVED***

    a = as_strided(x, strides=(0, -9993***REMOVED***, shape=(1, 22***REMOVED******REMOVED***
    check_internal_overlap(a, False***REMOVED***

    a = as_strided(x, strides=(0, -9993***REMOVED***, shape=(0, 22***REMOVED******REMOVED***
    check_internal_overlap(a, False***REMOVED***


def test_internal_overlap_fuzz(***REMOVED***:
    # Fuzz check; the brute-force check is fairly slow

    x = np.arange(1***REMOVED***.astype(np.int8***REMOVED***

    overlap = 0
    no_overlap = 0
    min_count = 100

    rng = np.random.RandomState(1234***REMOVED***

    while min(overlap, no_overlap***REMOVED*** < min_count:
        ndim = rng.randint(1, 4, dtype=np.intp***REMOVED***

        strides = tuple(rng.randint(-1000, 1000, dtype=np.intp***REMOVED***
                        for j in range(ndim***REMOVED******REMOVED***
        shape = tuple(rng.randint(1, 30, dtype=np.intp***REMOVED***
                      for j in range(ndim***REMOVED******REMOVED***

        a = as_strided(x, strides=strides, shape=shape***REMOVED***
        result = check_internal_overlap(a***REMOVED***

        if result:
            overlap += 1
        else:
            no_overlap += 1


def test_non_ndarray_inputs(***REMOVED***:
    # Regression check for gh-5604

    class MyArray(object***REMOVED***:
        def __init__(self, data***REMOVED***:
            self.data = data

        @property
        def __array_interface__(self***REMOVED***:
            return self.data.__array_interface__

    class MyArray2(object***REMOVED***:
        def __init__(self, data***REMOVED***:
            self.data = data

        def __array__(self***REMOVED***:
            return self.data

    for cls in [MyArray, MyArray2***REMOVED***:
        x = np.arange(5***REMOVED***

        assert_(np.may_share_memory(cls(x[::2***REMOVED******REMOVED***, x[1::2***REMOVED******REMOVED******REMOVED***
        assert_(not np.shares_memory(cls(x[::2***REMOVED******REMOVED***, x[1::2***REMOVED******REMOVED******REMOVED***

        assert_(np.shares_memory(cls(x[1::3***REMOVED******REMOVED***, x[::2***REMOVED******REMOVED******REMOVED***
        assert_(np.may_share_memory(cls(x[1::3***REMOVED******REMOVED***, x[::2***REMOVED******REMOVED******REMOVED***


if __name__ == "__main__":
    run_module_suite(***REMOVED***
