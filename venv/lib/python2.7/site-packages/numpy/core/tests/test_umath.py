from __future__ import division, absolute_import, print_function

import sys
import platform
import warnings
import itertools

from numpy.testing.utils import _gen_alignment_data
import numpy.core.umath as ncu
import numpy as np
from numpy.testing import (
    TestCase, run_module_suite, assert_, assert_equal, assert_raises,
    assert_array_equal, assert_almost_equal, assert_array_almost_equal,
    dec, assert_allclose, assert_no_warnings
***REMOVED***


def on_powerpc(***REMOVED***:
    ***REMOVED*** True if we are running on a Power PC platform.***REMOVED***
    return platform.processor(***REMOVED*** == 'powerpc' or \
           platform.machine(***REMOVED***.startswith('ppc'***REMOVED***


class _FilterInvalids(object***REMOVED***:
    def setUp(self***REMOVED***:
        self.olderr = np.seterr(invalid='ignore'***REMOVED***

    def tearDown(self***REMOVED***:
        np.seterr(**self.olderr***REMOVED***


class TestConstants(TestCase***REMOVED***:
    def test_pi(self***REMOVED***:
        assert_allclose(ncu.pi, 3.141592653589793, 1e-15***REMOVED***

    def test_e(self***REMOVED***:
        assert_allclose(ncu.e, 2.718281828459045, 1e-15***REMOVED***

    def test_euler_gamma(self***REMOVED***:
        assert_allclose(ncu.euler_gamma, 0.5772156649015329, 1e-15***REMOVED***


class TestOut(TestCase***REMOVED***:
    def test_out_subok(self***REMOVED***:
        for subok in (True, False***REMOVED***:
            a = np.array(0.5***REMOVED***
            o = np.empty((***REMOVED******REMOVED***

            r = np.add(a, 2, o, subok=subok***REMOVED***
            assert_(r is o***REMOVED***
            r = np.add(a, 2, out=o, subok=subok***REMOVED***
            assert_(r is o***REMOVED***
            r = np.add(a, 2, out=(o,***REMOVED***, subok=subok***REMOVED***
            assert_(r is o***REMOVED***

            d = np.array(5.7***REMOVED***
            o1 = np.empty((***REMOVED******REMOVED***
            o2 = np.empty((***REMOVED***, dtype=np.int32***REMOVED***

            r1, r2 = np.frexp(d, o1, None, subok=subok***REMOVED***
            assert_(r1 is o1***REMOVED***
            r1, r2 = np.frexp(d, None, o2, subok=subok***REMOVED***
            assert_(r2 is o2***REMOVED***
            r1, r2 = np.frexp(d, o1, o2, subok=subok***REMOVED***
            assert_(r1 is o1***REMOVED***
            assert_(r2 is o2***REMOVED***

            r1, r2 = np.frexp(d, out=(o1, None***REMOVED***, subok=subok***REMOVED***
            assert_(r1 is o1***REMOVED***
            r1, r2 = np.frexp(d, out=(None, o2***REMOVED***, subok=subok***REMOVED***
            assert_(r2 is o2***REMOVED***
            r1, r2 = np.frexp(d, out=(o1, o2***REMOVED***, subok=subok***REMOVED***
            assert_(r1 is o1***REMOVED***
            assert_(r2 is o2***REMOVED***

            with warnings.catch_warnings(record=True***REMOVED*** as w:
                warnings.filterwarnings('always', '', DeprecationWarning***REMOVED***
                r1, r2 = np.frexp(d, out=o1, subok=subok***REMOVED***
                assert_(r1 is o1***REMOVED***
                assert_(w[0***REMOVED***.category is DeprecationWarning***REMOVED***

            assert_raises(ValueError, np.add, a, 2, o, o, subok=subok***REMOVED***
            assert_raises(ValueError, np.add, a, 2, o, out=o, subok=subok***REMOVED***
            assert_raises(ValueError, np.add, a, 2, None, out=o, subok=subok***REMOVED***
            assert_raises(ValueError, np.add, a, 2, out=(o, o***REMOVED***, subok=subok***REMOVED***
            assert_raises(ValueError, np.add, a, 2, out=(***REMOVED***, subok=subok***REMOVED***
            assert_raises(TypeError, np.add, a, 2, [***REMOVED***, subok=subok***REMOVED***
            assert_raises(TypeError, np.add, a, 2, out=[***REMOVED***, subok=subok***REMOVED***
            assert_raises(TypeError, np.add, a, 2, out=([***REMOVED***,***REMOVED***, subok=subok***REMOVED***
            o.flags.writeable = False
            assert_raises(ValueError, np.add, a, 2, o, subok=subok***REMOVED***
            assert_raises(ValueError, np.add, a, 2, out=o, subok=subok***REMOVED***
            assert_raises(ValueError, np.add, a, 2, out=(o,***REMOVED***, subok=subok***REMOVED***

    def test_out_wrap_subok(self***REMOVED***:
        class ArrayWrap(np.ndarray***REMOVED***:
            __array_priority__ = 10

            def __new__(cls, arr***REMOVED***:
                return np.asarray(arr***REMOVED***.view(cls***REMOVED***.copy(***REMOVED***

            def __array_wrap__(self, arr, context***REMOVED***:
                return arr.view(type(self***REMOVED******REMOVED***

        for subok in (True, False***REMOVED***:
            a = ArrayWrap([0.5***REMOVED******REMOVED***

            r = np.add(a, 2, subok=subok***REMOVED***
            if subok:
                assert_(isinstance(r, ArrayWrap***REMOVED******REMOVED***
            else:
                assert_(type(r***REMOVED*** == np.ndarray***REMOVED***

            r = np.add(a, 2, None, subok=subok***REMOVED***
            if subok:
                assert_(isinstance(r, ArrayWrap***REMOVED******REMOVED***
            else:
                assert_(type(r***REMOVED*** == np.ndarray***REMOVED***

            r = np.add(a, 2, out=None, subok=subok***REMOVED***
            if subok:
                assert_(isinstance(r, ArrayWrap***REMOVED******REMOVED***
            else:
                assert_(type(r***REMOVED*** == np.ndarray***REMOVED***

            r = np.add(a, 2, out=(None,***REMOVED***, subok=subok***REMOVED***
            if subok:
                assert_(isinstance(r, ArrayWrap***REMOVED******REMOVED***
            else:
                assert_(type(r***REMOVED*** == np.ndarray***REMOVED***

            d = ArrayWrap([5.7***REMOVED******REMOVED***
            o1 = np.empty((1,***REMOVED******REMOVED***
            o2 = np.empty((1,***REMOVED***, dtype=np.int32***REMOVED***

            r1, r2 = np.frexp(d, o1, subok=subok***REMOVED***
            if subok:
                assert_(isinstance(r2, ArrayWrap***REMOVED******REMOVED***
            else:
                assert_(type(r2***REMOVED*** == np.ndarray***REMOVED***

            r1, r2 = np.frexp(d, o1, None, subok=subok***REMOVED***
            if subok:
                assert_(isinstance(r2, ArrayWrap***REMOVED******REMOVED***
            else:
                assert_(type(r2***REMOVED*** == np.ndarray***REMOVED***

            r1, r2 = np.frexp(d, None, o2, subok=subok***REMOVED***
            if subok:
                assert_(isinstance(r1, ArrayWrap***REMOVED******REMOVED***
            else:
                assert_(type(r1***REMOVED*** == np.ndarray***REMOVED***

            r1, r2 = np.frexp(d, out=(o1, None***REMOVED***, subok=subok***REMOVED***
            if subok:
                assert_(isinstance(r2, ArrayWrap***REMOVED******REMOVED***
            else:
                assert_(type(r2***REMOVED*** == np.ndarray***REMOVED***

            r1, r2 = np.frexp(d, out=(None, o2***REMOVED***, subok=subok***REMOVED***
            if subok:
                assert_(isinstance(r1, ArrayWrap***REMOVED******REMOVED***
            else:
                assert_(type(r1***REMOVED*** == np.ndarray***REMOVED***

            with warnings.catch_warnings(record=True***REMOVED*** as w:
                warnings.filterwarnings('always', '', DeprecationWarning***REMOVED***
                r1, r2 = np.frexp(d, out=o1, subok=subok***REMOVED***
                if subok:
                    assert_(isinstance(r2, ArrayWrap***REMOVED******REMOVED***
                else:
                    assert_(type(r2***REMOVED*** == np.ndarray***REMOVED***
                assert_(w[0***REMOVED***.category is DeprecationWarning***REMOVED***


class TestDivision(TestCase***REMOVED***:
    def test_division_int(self***REMOVED***:
        # int division should follow Python
        x = np.array([5, 10, 90, 100, -5, -10, -90, -100, -120***REMOVED******REMOVED***
        if 5 / 10 == 0.5:
            assert_equal(x / 100, [0.05, 0.1, 0.9, 1,
                                   -0.05, -0.1, -0.9, -1, -1.2***REMOVED******REMOVED***
        else:
            assert_equal(x / 100, [0, 0, 0, 1, -1, -1, -1, -1, -2***REMOVED******REMOVED***
        assert_equal(x // 100, [0, 0, 0, 1, -1, -1, -1, -1, -2***REMOVED******REMOVED***
        assert_equal(x % 100, [5, 10, 90, 0, 95, 90, 10, 0, 80***REMOVED******REMOVED***

    def test_division_complex(self***REMOVED***:
        # check that implementation is correct
        msg = "Complex division implementation check"
        x = np.array([1. + 1.*1j, 1. + .5*1j, 1. + 2.*1j***REMOVED***, dtype=np.complex128***REMOVED***
        assert_almost_equal(x**2/x, x, err_msg=msg***REMOVED***
        # check overflow, underflow
        msg = "Complex division overflow/underflow check"
        x = np.array([1.e+110, 1.e-110***REMOVED***, dtype=np.complex128***REMOVED***
        y = x**2/x
        assert_almost_equal(y/x, [1, 1***REMOVED***, err_msg=msg***REMOVED***

    def test_zero_division_complex(self***REMOVED***:
        with np.errstate(invalid="ignore", divide="ignore"***REMOVED***:
            x = np.array([0.0***REMOVED***, dtype=np.complex128***REMOVED***
            y = 1.0/x
            assert_(np.isinf(y***REMOVED***[0***REMOVED******REMOVED***
            y = complex(np.inf, np.nan***REMOVED***/x
            assert_(np.isinf(y***REMOVED***[0***REMOVED******REMOVED***
            y = complex(np.nan, np.inf***REMOVED***/x
            assert_(np.isinf(y***REMOVED***[0***REMOVED******REMOVED***
            y = complex(np.inf, np.inf***REMOVED***/x
            assert_(np.isinf(y***REMOVED***[0***REMOVED******REMOVED***
            y = 0.0/x
            assert_(np.isnan(y***REMOVED***[0***REMOVED******REMOVED***

    def test_floor_division_complex(self***REMOVED***:
        # check that implementation is correct
        msg = "Complex floor division implementation check"
        x = np.array([.9 + 1j, -.1 + 1j, .9 + .5*1j, .9 + 2.*1j***REMOVED***, dtype=np.complex128***REMOVED***
        y = np.array([0., -1., 0., 0.***REMOVED***, dtype=np.complex128***REMOVED***
        assert_equal(np.floor_divide(x**2, x***REMOVED***, y, err_msg=msg***REMOVED***
        # check overflow, underflow
        msg = "Complex floor division overflow/underflow check"
        x = np.array([1.e+110, 1.e-110***REMOVED***, dtype=np.complex128***REMOVED***
        y = np.floor_divide(x**2, x***REMOVED***
        assert_equal(y, [1.e+110, 0***REMOVED***, err_msg=msg***REMOVED***


class TestRemainder(TestCase***REMOVED***:

    def test_remainder_basic(self***REMOVED***:
        dt = np.typecodes['AllInteger'***REMOVED*** + np.typecodes['Float'***REMOVED***
        for dt1, dt2 in itertools.product(dt, dt***REMOVED***:
            for sg1, sg2 in itertools.product((+1, -1***REMOVED***, (+1, -1***REMOVED******REMOVED***:
                if sg1 == -1 and dt1 in np.typecodes['UnsignedInteger'***REMOVED***:
                    continue
                if sg2 == -1 and dt2 in np.typecodes['UnsignedInteger'***REMOVED***:
                    continue
                fmt = 'dt1: %s, dt2: %s, sg1: %s, sg2: %s'
                msg = fmt % (dt1, dt2, sg1, sg2***REMOVED***
                a = np.array(sg1*71, dtype=dt1***REMOVED***
                b = np.array(sg2*19, dtype=dt2***REMOVED***
                div = np.floor_divide(a, b***REMOVED***
                rem = np.remainder(a, b***REMOVED***
                assert_equal(div*b + rem, a, err_msg=msg***REMOVED***
                if sg2 == -1:
                    assert_(b < rem <= 0, msg***REMOVED***
                else:
                    assert_(b > rem >= 0, msg***REMOVED***

    def test_float_remainder_exact(self***REMOVED***:
        # test that float results are exact for small integers. This also
        # holds for the same integers scaled by powers of two.
        nlst = list(range(-127, 0***REMOVED******REMOVED***
        plst = list(range(1, 128***REMOVED******REMOVED***
        dividend = nlst + [0***REMOVED*** + plst
        divisor = nlst + plst
        arg = list(itertools.product(dividend, divisor***REMOVED******REMOVED***
        tgt = list(divmod(*t***REMOVED*** for t in arg***REMOVED***

        a, b = np.array(arg, dtype=int***REMOVED***.T
        # convert exact integer results from Python to float so that
        # signed zero can be used, it is checked.
        tgtdiv, tgtrem = np.array(tgt, dtype=float***REMOVED***.T
        tgtdiv = np.where((tgtdiv == 0.0***REMOVED*** & ((b < 0***REMOVED*** ^ (a < 0***REMOVED******REMOVED***, -0.0, tgtdiv***REMOVED***
        tgtrem = np.where((tgtrem == 0.0***REMOVED*** & (b < 0***REMOVED***, -0.0, tgtrem***REMOVED***

        for dt in np.typecodes['Float'***REMOVED***:
            msg = 'dtype: %s' % (dt,***REMOVED***
            fa = a.astype(dt***REMOVED***
            fb = b.astype(dt***REMOVED***
            div = np.floor_divide(fa, fb***REMOVED***
            rem = np.remainder(fa, fb***REMOVED***
            assert_equal(div, tgtdiv, err_msg=msg***REMOVED***
            assert_equal(rem, tgtrem, err_msg=msg***REMOVED***

    def test_float_remainder_roundoff(self***REMOVED***:
        # gh-6127
        dt = np.typecodes['Float'***REMOVED***
        for dt1, dt2 in itertools.product(dt, dt***REMOVED***:
            for sg1, sg2 in itertools.product((+1, -1***REMOVED***, (+1, -1***REMOVED******REMOVED***:
                fmt = 'dt1: %s, dt2: %s, sg1: %s, sg2: %s'
                msg = fmt % (dt1, dt2, sg1, sg2***REMOVED***
                a = np.array(sg1*78*6e-8, dtype=dt1***REMOVED***
                b = np.array(sg2*6e-8, dtype=dt2***REMOVED***
                div = np.floor_divide(a, b***REMOVED***
                rem = np.remainder(a, b***REMOVED***
                # Equal assertion should hold when fmod is used
                assert_equal(div*b + rem, a, err_msg=msg***REMOVED***
                if sg2 == -1:
                    assert_(b < rem <= 0, msg***REMOVED***
                else:
                    assert_(b > rem >= 0, msg***REMOVED***

    def test_float_remainder_corner_cases(self***REMOVED***:
        # Check remainder magnitude.
        for dt in np.typecodes['Float'***REMOVED***:
            b = np.array(1.0, dtype=dt***REMOVED***
            a = np.nextafter(np.array(0.0, dtype=dt***REMOVED***, -b***REMOVED***
            rem = np.remainder(a, b***REMOVED***
            assert_(rem <= b, 'dt: %s' % dt***REMOVED***
            rem = np.remainder(-a, -b***REMOVED***
            assert_(rem >= -b, 'dt: %s' % dt***REMOVED***

        # Check nans, inf
        with warnings.catch_warnings(***REMOVED***:
            warnings.simplefilter('always'***REMOVED***
            warnings.simplefilter('ignore', RuntimeWarning***REMOVED***
            for dt in np.typecodes['Float'***REMOVED***:
                fone = np.array(1.0, dtype=dt***REMOVED***
                fzer = np.array(0.0, dtype=dt***REMOVED***
                finf = np.array(np.inf, dtype=dt***REMOVED***
                fnan = np.array(np.nan, dtype=dt***REMOVED***
                rem = np.remainder(fone, fzer***REMOVED***
                assert_(np.isnan(rem***REMOVED***, 'dt: %s, rem: %s' % (dt, rem***REMOVED******REMOVED***
                # MSVC 2008 returns NaN here, so disable the check.
                #rem = np.remainder(fone, finf***REMOVED***
                #assert_(rem == fone, 'dt: %s, rem: %s' % (dt, rem***REMOVED******REMOVED***
                rem = np.remainder(fone, fnan***REMOVED***
                assert_(np.isnan(rem***REMOVED***, 'dt: %s, rem: %s' % (dt, rem***REMOVED******REMOVED***
                rem = np.remainder(finf, fone***REMOVED***
                assert_(np.isnan(rem***REMOVED***, 'dt: %s, rem: %s' % (dt, rem***REMOVED******REMOVED***


class TestCbrt(TestCase***REMOVED***:
    def test_cbrt_scalar(self***REMOVED***:
        assert_almost_equal((np.cbrt(np.float32(-2.5***REMOVED*****3***REMOVED******REMOVED***, -2.5***REMOVED***

    def test_cbrt(self***REMOVED***:
        x = np.array([1., 2., -3., np.inf, -np.inf***REMOVED******REMOVED***
        assert_almost_equal(np.cbrt(x**3***REMOVED***, x***REMOVED***

        assert_(np.isnan(np.cbrt(np.nan***REMOVED******REMOVED******REMOVED***
        assert_equal(np.cbrt(np.inf***REMOVED***, np.inf***REMOVED***
        assert_equal(np.cbrt(-np.inf***REMOVED***, -np.inf***REMOVED***


class TestPower(TestCase***REMOVED***:
    def test_power_float(self***REMOVED***:
        x = np.array([1., 2., 3.***REMOVED******REMOVED***
        assert_equal(x**0, [1., 1., 1.***REMOVED******REMOVED***
        assert_equal(x**1, x***REMOVED***
        assert_equal(x**2, [1., 4., 9.***REMOVED******REMOVED***
        y = x.copy(***REMOVED***
        y **= 2
        assert_equal(y, [1., 4., 9.***REMOVED******REMOVED***
        assert_almost_equal(x**(-1***REMOVED***, [1., 0.5, 1./3***REMOVED******REMOVED***
        assert_almost_equal(x**(0.5***REMOVED***, [1., ncu.sqrt(2***REMOVED***, ncu.sqrt(3***REMOVED******REMOVED******REMOVED***

        for out, inp, msg in _gen_alignment_data(dtype=np.float32,
                                                 type='unary',
                                                 max_size=11***REMOVED***:
            exp = [ncu.sqrt(i***REMOVED*** for i in inp***REMOVED***
            assert_almost_equal(inp**(0.5***REMOVED***, exp, err_msg=msg***REMOVED***
            np.sqrt(inp, out=out***REMOVED***
            assert_equal(out, exp, err_msg=msg***REMOVED***

        for out, inp, msg in _gen_alignment_data(dtype=np.float64,
                                                 type='unary',
                                                 max_size=7***REMOVED***:
            exp = [ncu.sqrt(i***REMOVED*** for i in inp***REMOVED***
            assert_almost_equal(inp**(0.5***REMOVED***, exp, err_msg=msg***REMOVED***
            np.sqrt(inp, out=out***REMOVED***
            assert_equal(out, exp, err_msg=msg***REMOVED***

    def test_power_complex(self***REMOVED***:
        x = np.array([1+2j, 2+3j, 3+4j***REMOVED******REMOVED***
        assert_equal(x**0, [1., 1., 1.***REMOVED******REMOVED***
        assert_equal(x**1, x***REMOVED***
        assert_almost_equal(x**2, [-3+4j, -5+12j, -7+24j***REMOVED******REMOVED***
        assert_almost_equal(x**3, [(1+2j***REMOVED*****3, (2+3j***REMOVED*****3, (3+4j***REMOVED*****3***REMOVED******REMOVED***
        assert_almost_equal(x**4, [(1+2j***REMOVED*****4, (2+3j***REMOVED*****4, (3+4j***REMOVED*****4***REMOVED******REMOVED***
        assert_almost_equal(x**(-1***REMOVED***, [1/(1+2j***REMOVED***, 1/(2+3j***REMOVED***, 1/(3+4j***REMOVED******REMOVED******REMOVED***
        assert_almost_equal(x**(-2***REMOVED***, [1/(1+2j***REMOVED*****2, 1/(2+3j***REMOVED*****2, 1/(3+4j***REMOVED*****2***REMOVED******REMOVED***
        assert_almost_equal(x**(-3***REMOVED***, [(-11+2j***REMOVED***/125, (-46-9j***REMOVED***/2197,
                                      (-117-44j***REMOVED***/15625***REMOVED******REMOVED***
        assert_almost_equal(x**(0.5***REMOVED***, [ncu.sqrt(1+2j***REMOVED***, ncu.sqrt(2+3j***REMOVED***,
                                       ncu.sqrt(3+4j***REMOVED******REMOVED******REMOVED***
        norm = 1./((x**14***REMOVED***[0***REMOVED******REMOVED***
        assert_almost_equal(x**14 * norm,
                [i * norm for i in [-76443+16124j, 23161315+58317492j,
                                    5583548873 + 2465133864j***REMOVED******REMOVED******REMOVED***

        # Ticket #836
        def assert_complex_equal(x, y***REMOVED***:
            assert_array_equal(x.real, y.real***REMOVED***
            assert_array_equal(x.imag, y.imag***REMOVED***

        for z in [complex(0, np.inf***REMOVED***, complex(1, np.inf***REMOVED******REMOVED***:
            z = np.array([z***REMOVED***, dtype=np.complex_***REMOVED***
            with np.errstate(invalid="ignore"***REMOVED***:
                assert_complex_equal(z**1, z***REMOVED***
                assert_complex_equal(z**2, z*z***REMOVED***
                assert_complex_equal(z**3, z*z*z***REMOVED***

    def test_power_zero(self***REMOVED***:
        # ticket #1271
        zero = np.array([0j***REMOVED******REMOVED***
        one = np.array([1+0j***REMOVED******REMOVED***
        cnan = np.array([complex(np.nan, np.nan***REMOVED******REMOVED******REMOVED***
        # FIXME cinf not tested.
        #cinf = np.array([complex(np.inf, 0***REMOVED******REMOVED******REMOVED***

        def assert_complex_equal(x, y***REMOVED***:
            x, y = np.asarray(x***REMOVED***, np.asarray(y***REMOVED***
            assert_array_equal(x.real, y.real***REMOVED***
            assert_array_equal(x.imag, y.imag***REMOVED***

        # positive powers
        for p in [0.33, 0.5, 1, 1.5, 2, 3, 4, 5, 6.6***REMOVED***:
            assert_complex_equal(np.power(zero, p***REMOVED***, zero***REMOVED***

        # zero power
        assert_complex_equal(np.power(zero, 0***REMOVED***, one***REMOVED***
        with np.errstate(invalid="ignore"***REMOVED***:
            assert_complex_equal(np.power(zero, 0+1j***REMOVED***, cnan***REMOVED***

            # negative power
            for p in [0.33, 0.5, 1, 1.5, 2, 3, 4, 5, 6.6***REMOVED***:
                assert_complex_equal(np.power(zero, -p***REMOVED***, cnan***REMOVED***
            assert_complex_equal(np.power(zero, -1+0.2j***REMOVED***, cnan***REMOVED***

    def test_fast_power(self***REMOVED***:
        x = np.array([1, 2, 3***REMOVED***, np.int16***REMOVED***
        assert_((x**2.00001***REMOVED***.dtype is (x**2.0***REMOVED***.dtype***REMOVED***

        # Check that the fast path ignores 1-element not 0-d arrays
        res = x ** np.array([[[2***REMOVED******REMOVED******REMOVED******REMOVED***
        assert_equal(res.shape, (1, 1, 3***REMOVED******REMOVED***


class TestLog2(TestCase***REMOVED***:
    def test_log2_values(self***REMOVED***:
        x = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024***REMOVED***
        y = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10***REMOVED***
        for dt in ['f', 'd', 'g'***REMOVED***:
            xf = np.array(x, dtype=dt***REMOVED***
            yf = np.array(y, dtype=dt***REMOVED***
            assert_almost_equal(np.log2(xf***REMOVED***, yf***REMOVED***

    def test_log2_ints(self***REMOVED***:
        # a good log2 implementation should provide this,
        # might fail on OS with bad libm
        for i in range(1, 65***REMOVED***:
            v = np.log2(2.**i***REMOVED***
            assert_equal(v, float(i***REMOVED***, err_msg='at exponent %d' % i***REMOVED***

    def test_log2_special(self***REMOVED***:
        assert_equal(np.log2(1.***REMOVED***, 0.***REMOVED***
        assert_equal(np.log2(np.inf***REMOVED***, np.inf***REMOVED***
        assert_(np.isnan(np.log2(np.nan***REMOVED******REMOVED******REMOVED***

        with warnings.catch_warnings(record=True***REMOVED*** as w:
            warnings.filterwarnings('always', '', RuntimeWarning***REMOVED***
            assert_(np.isnan(np.log2(-1.***REMOVED******REMOVED******REMOVED***
            assert_(np.isnan(np.log2(-np.inf***REMOVED******REMOVED******REMOVED***
            assert_equal(np.log2(0.***REMOVED***, -np.inf***REMOVED***
            assert_(w[0***REMOVED***.category is RuntimeWarning***REMOVED***
            assert_(w[1***REMOVED***.category is RuntimeWarning***REMOVED***
            assert_(w[2***REMOVED***.category is RuntimeWarning***REMOVED***


class TestExp2(TestCase***REMOVED***:
    def test_exp2_values(self***REMOVED***:
        x = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024***REMOVED***
        y = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10***REMOVED***
        for dt in ['f', 'd', 'g'***REMOVED***:
            xf = np.array(x, dtype=dt***REMOVED***
            yf = np.array(y, dtype=dt***REMOVED***
            assert_almost_equal(np.exp2(yf***REMOVED***, xf***REMOVED***


class TestLogAddExp2(_FilterInvalids***REMOVED***:
    # Need test for intermediate precisions
    def test_logaddexp2_values(self***REMOVED***:
        x = [1, 2, 3, 4, 5***REMOVED***
        y = [5, 4, 3, 2, 1***REMOVED***
        z = [6, 6, 6, 6, 6***REMOVED***
        for dt, dec_ in zip(['f', 'd', 'g'***REMOVED***, [6, 15, 15***REMOVED******REMOVED***:
            xf = np.log2(np.array(x, dtype=dt***REMOVED******REMOVED***
            yf = np.log2(np.array(y, dtype=dt***REMOVED******REMOVED***
            zf = np.log2(np.array(z, dtype=dt***REMOVED******REMOVED***
            assert_almost_equal(np.logaddexp2(xf, yf***REMOVED***, zf, decimal=dec_***REMOVED***

    def test_logaddexp2_range(self***REMOVED***:
        x = [1000000, -1000000, 1000200, -1000200***REMOVED***
        y = [1000200, -1000200, 1000000, -1000000***REMOVED***
        z = [1000200, -1000000, 1000200, -1000000***REMOVED***
        for dt in ['f', 'd', 'g'***REMOVED***:
            logxf = np.array(x, dtype=dt***REMOVED***
            logyf = np.array(y, dtype=dt***REMOVED***
            logzf = np.array(z, dtype=dt***REMOVED***
            assert_almost_equal(np.logaddexp2(logxf, logyf***REMOVED***, logzf***REMOVED***

    def test_inf(self***REMOVED***:
        inf = np.inf
        x = [inf, -inf,  inf, -inf, inf, 1,  -inf,  1***REMOVED***
        y = [inf,  inf, -inf, -inf, 1,   inf, 1,   -inf***REMOVED***
        z = [inf,  inf,  inf, -inf, inf, inf, 1,    1***REMOVED***
        with np.errstate(invalid='raise'***REMOVED***:
            for dt in ['f', 'd', 'g'***REMOVED***:
                logxf = np.array(x, dtype=dt***REMOVED***
                logyf = np.array(y, dtype=dt***REMOVED***
                logzf = np.array(z, dtype=dt***REMOVED***
                assert_equal(np.logaddexp2(logxf, logyf***REMOVED***, logzf***REMOVED***

    def test_nan(self***REMOVED***:
        assert_(np.isnan(np.logaddexp2(np.nan, np.inf***REMOVED******REMOVED******REMOVED***
        assert_(np.isnan(np.logaddexp2(np.inf, np.nan***REMOVED******REMOVED******REMOVED***
        assert_(np.isnan(np.logaddexp2(np.nan, 0***REMOVED******REMOVED******REMOVED***
        assert_(np.isnan(np.logaddexp2(0, np.nan***REMOVED******REMOVED******REMOVED***
        assert_(np.isnan(np.logaddexp2(np.nan, np.nan***REMOVED******REMOVED******REMOVED***


class TestLog(TestCase***REMOVED***:
    def test_log_values(self***REMOVED***:
        x = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024***REMOVED***
        y = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10***REMOVED***
        for dt in ['f', 'd', 'g'***REMOVED***:
            log2_ = 0.69314718055994530943
            xf = np.array(x, dtype=dt***REMOVED***
            yf = np.array(y, dtype=dt***REMOVED****log2_
            assert_almost_equal(np.log(xf***REMOVED***, yf***REMOVED***


class TestExp(TestCase***REMOVED***:
    def test_exp_values(self***REMOVED***:
        x = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024***REMOVED***
        y = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10***REMOVED***
        for dt in ['f', 'd', 'g'***REMOVED***:
            log2_ = 0.69314718055994530943
            xf = np.array(x, dtype=dt***REMOVED***
            yf = np.array(y, dtype=dt***REMOVED****log2_
            assert_almost_equal(np.exp(yf***REMOVED***, xf***REMOVED***


class TestLogAddExp(_FilterInvalids***REMOVED***:
    def test_logaddexp_values(self***REMOVED***:
        x = [1, 2, 3, 4, 5***REMOVED***
        y = [5, 4, 3, 2, 1***REMOVED***
        z = [6, 6, 6, 6, 6***REMOVED***
        for dt, dec_ in zip(['f', 'd', 'g'***REMOVED***, [6, 15, 15***REMOVED******REMOVED***:
            xf = np.log(np.array(x, dtype=dt***REMOVED******REMOVED***
            yf = np.log(np.array(y, dtype=dt***REMOVED******REMOVED***
            zf = np.log(np.array(z, dtype=dt***REMOVED******REMOVED***
            assert_almost_equal(np.logaddexp(xf, yf***REMOVED***, zf, decimal=dec_***REMOVED***

    def test_logaddexp_range(self***REMOVED***:
        x = [1000000, -1000000, 1000200, -1000200***REMOVED***
        y = [1000200, -1000200, 1000000, -1000000***REMOVED***
        z = [1000200, -1000000, 1000200, -1000000***REMOVED***
        for dt in ['f', 'd', 'g'***REMOVED***:
            logxf = np.array(x, dtype=dt***REMOVED***
            logyf = np.array(y, dtype=dt***REMOVED***
            logzf = np.array(z, dtype=dt***REMOVED***
            assert_almost_equal(np.logaddexp(logxf, logyf***REMOVED***, logzf***REMOVED***

    def test_inf(self***REMOVED***:
        inf = np.inf
        x = [inf, -inf,  inf, -inf, inf, 1,  -inf,  1***REMOVED***
        y = [inf,  inf, -inf, -inf, 1,   inf, 1,   -inf***REMOVED***
        z = [inf,  inf,  inf, -inf, inf, inf, 1,    1***REMOVED***
        with np.errstate(invalid='raise'***REMOVED***:
            for dt in ['f', 'd', 'g'***REMOVED***:
                logxf = np.array(x, dtype=dt***REMOVED***
                logyf = np.array(y, dtype=dt***REMOVED***
                logzf = np.array(z, dtype=dt***REMOVED***
                assert_equal(np.logaddexp(logxf, logyf***REMOVED***, logzf***REMOVED***

    def test_nan(self***REMOVED***:
        assert_(np.isnan(np.logaddexp(np.nan, np.inf***REMOVED******REMOVED******REMOVED***
        assert_(np.isnan(np.logaddexp(np.inf, np.nan***REMOVED******REMOVED******REMOVED***
        assert_(np.isnan(np.logaddexp(np.nan, 0***REMOVED******REMOVED******REMOVED***
        assert_(np.isnan(np.logaddexp(0, np.nan***REMOVED******REMOVED******REMOVED***
        assert_(np.isnan(np.logaddexp(np.nan, np.nan***REMOVED******REMOVED******REMOVED***


class TestLog1p(TestCase***REMOVED***:
    def test_log1p(self***REMOVED***:
        assert_almost_equal(ncu.log1p(0.2***REMOVED***, ncu.log(1.2***REMOVED******REMOVED***
        assert_almost_equal(ncu.log1p(1e-6***REMOVED***, ncu.log(1+1e-6***REMOVED******REMOVED***

    def test_special(self***REMOVED***:
        with np.errstate(invalid="ignore", divide="ignore"***REMOVED***:
            assert_equal(ncu.log1p(np.nan***REMOVED***, np.nan***REMOVED***
            assert_equal(ncu.log1p(np.inf***REMOVED***, np.inf***REMOVED***
            assert_equal(ncu.log1p(-1.***REMOVED***, -np.inf***REMOVED***
            assert_equal(ncu.log1p(-2.***REMOVED***, np.nan***REMOVED***
            assert_equal(ncu.log1p(-np.inf***REMOVED***, np.nan***REMOVED***


class TestExpm1(TestCase***REMOVED***:
    def test_expm1(self***REMOVED***:
        assert_almost_equal(ncu.expm1(0.2***REMOVED***, ncu.exp(0.2***REMOVED***-1***REMOVED***
        assert_almost_equal(ncu.expm1(1e-6***REMOVED***, ncu.exp(1e-6***REMOVED***-1***REMOVED***

    def test_special(self***REMOVED***:
        assert_equal(ncu.expm1(np.inf***REMOVED***, np.inf***REMOVED***
        assert_equal(ncu.expm1(0.***REMOVED***, 0.***REMOVED***
        assert_equal(ncu.expm1(-0.***REMOVED***, -0.***REMOVED***
        assert_equal(ncu.expm1(np.inf***REMOVED***, np.inf***REMOVED***
        assert_equal(ncu.expm1(-np.inf***REMOVED***, -1.***REMOVED***


class TestHypot(TestCase, object***REMOVED***:
    def test_simple(self***REMOVED***:
        assert_almost_equal(ncu.hypot(1, 1***REMOVED***, ncu.sqrt(2***REMOVED******REMOVED***
        assert_almost_equal(ncu.hypot(0, 0***REMOVED***, 0***REMOVED***


def assert_hypot_isnan(x, y***REMOVED***:
    with np.errstate(invalid='ignore'***REMOVED***:
        assert_(np.isnan(ncu.hypot(x, y***REMOVED******REMOVED***,
                "hypot(%s, %s***REMOVED*** is %s, not nan" % (x, y, ncu.hypot(x, y***REMOVED******REMOVED******REMOVED***


def assert_hypot_isinf(x, y***REMOVED***:
    with np.errstate(invalid='ignore'***REMOVED***:
        assert_(np.isinf(ncu.hypot(x, y***REMOVED******REMOVED***,
                "hypot(%s, %s***REMOVED*** is %s, not inf" % (x, y, ncu.hypot(x, y***REMOVED******REMOVED******REMOVED***


class TestHypotSpecialValues(TestCase***REMOVED***:
    def test_nan_outputs(self***REMOVED***:
        assert_hypot_isnan(np.nan, np.nan***REMOVED***
        assert_hypot_isnan(np.nan, 1***REMOVED***

    def test_nan_outputs2(self***REMOVED***:
        assert_hypot_isinf(np.nan, np.inf***REMOVED***
        assert_hypot_isinf(np.inf, np.nan***REMOVED***
        assert_hypot_isinf(np.inf, 0***REMOVED***
        assert_hypot_isinf(0, np.inf***REMOVED***
        assert_hypot_isinf(np.inf, np.inf***REMOVED***
        assert_hypot_isinf(np.inf, 23.0***REMOVED***

    def test_no_fpe(self***REMOVED***:
        assert_no_warnings(ncu.hypot, np.inf, 0***REMOVED***


def assert_arctan2_isnan(x, y***REMOVED***:
    assert_(np.isnan(ncu.arctan2(x, y***REMOVED******REMOVED***, "arctan(%s, %s***REMOVED*** is %s, not nan" % (x, y, ncu.arctan2(x, y***REMOVED******REMOVED******REMOVED***


def assert_arctan2_ispinf(x, y***REMOVED***:
    assert_((np.isinf(ncu.arctan2(x, y***REMOVED******REMOVED*** and ncu.arctan2(x, y***REMOVED*** > 0***REMOVED***, "arctan(%s, %s***REMOVED*** is %s, not +inf" % (x, y, ncu.arctan2(x, y***REMOVED******REMOVED******REMOVED***


def assert_arctan2_isninf(x, y***REMOVED***:
    assert_((np.isinf(ncu.arctan2(x, y***REMOVED******REMOVED*** and ncu.arctan2(x, y***REMOVED*** < 0***REMOVED***, "arctan(%s, %s***REMOVED*** is %s, not -inf" % (x, y, ncu.arctan2(x, y***REMOVED******REMOVED******REMOVED***


def assert_arctan2_ispzero(x, y***REMOVED***:
    assert_((ncu.arctan2(x, y***REMOVED*** == 0 and not np.signbit(ncu.arctan2(x, y***REMOVED******REMOVED******REMOVED***, "arctan(%s, %s***REMOVED*** is %s, not +0" % (x, y, ncu.arctan2(x, y***REMOVED******REMOVED******REMOVED***


def assert_arctan2_isnzero(x, y***REMOVED***:
    assert_((ncu.arctan2(x, y***REMOVED*** == 0 and np.signbit(ncu.arctan2(x, y***REMOVED******REMOVED******REMOVED***, "arctan(%s, %s***REMOVED*** is %s, not -0" % (x, y, ncu.arctan2(x, y***REMOVED******REMOVED******REMOVED***


class TestArctan2SpecialValues(TestCase***REMOVED***:
    def test_one_one(self***REMOVED***:
        # atan2(1, 1***REMOVED*** returns pi/4.
        assert_almost_equal(ncu.arctan2(1, 1***REMOVED***, 0.25 * np.pi***REMOVED***
        assert_almost_equal(ncu.arctan2(-1, 1***REMOVED***, -0.25 * np.pi***REMOVED***
        assert_almost_equal(ncu.arctan2(1, -1***REMOVED***, 0.75 * np.pi***REMOVED***

    def test_zero_nzero(self***REMOVED***:
        # atan2(+-0, -0***REMOVED*** returns +-pi.
        assert_almost_equal(ncu.arctan2(np.PZERO, np.NZERO***REMOVED***, np.pi***REMOVED***
        assert_almost_equal(ncu.arctan2(np.NZERO, np.NZERO***REMOVED***, -np.pi***REMOVED***

    def test_zero_pzero(self***REMOVED***:
        # atan2(+-0, +0***REMOVED*** returns +-0.
        assert_arctan2_ispzero(np.PZERO, np.PZERO***REMOVED***
        assert_arctan2_isnzero(np.NZERO, np.PZERO***REMOVED***

    def test_zero_negative(self***REMOVED***:
        # atan2(+-0, x***REMOVED*** returns +-pi for x < 0.
        assert_almost_equal(ncu.arctan2(np.PZERO, -1***REMOVED***, np.pi***REMOVED***
        assert_almost_equal(ncu.arctan2(np.NZERO, -1***REMOVED***, -np.pi***REMOVED***

    def test_zero_positive(self***REMOVED***:
        # atan2(+-0, x***REMOVED*** returns +-0 for x > 0.
        assert_arctan2_ispzero(np.PZERO, 1***REMOVED***
        assert_arctan2_isnzero(np.NZERO, 1***REMOVED***

    def test_positive_zero(self***REMOVED***:
        # atan2(y, +-0***REMOVED*** returns +pi/2 for y > 0.
        assert_almost_equal(ncu.arctan2(1, np.PZERO***REMOVED***, 0.5 * np.pi***REMOVED***
        assert_almost_equal(ncu.arctan2(1, np.NZERO***REMOVED***, 0.5 * np.pi***REMOVED***

    def test_negative_zero(self***REMOVED***:
        # atan2(y, +-0***REMOVED*** returns -pi/2 for y < 0.
        assert_almost_equal(ncu.arctan2(-1, np.PZERO***REMOVED***, -0.5 * np.pi***REMOVED***
        assert_almost_equal(ncu.arctan2(-1, np.NZERO***REMOVED***, -0.5 * np.pi***REMOVED***

    def test_any_ninf(self***REMOVED***:
        # atan2(+-y, -infinity***REMOVED*** returns +-pi for finite y > 0.
        assert_almost_equal(ncu.arctan2(1, np.NINF***REMOVED***,  np.pi***REMOVED***
        assert_almost_equal(ncu.arctan2(-1, np.NINF***REMOVED***, -np.pi***REMOVED***

    def test_any_pinf(self***REMOVED***:
        # atan2(+-y, +infinity***REMOVED*** returns +-0 for finite y > 0.
        assert_arctan2_ispzero(1, np.inf***REMOVED***
        assert_arctan2_isnzero(-1, np.inf***REMOVED***

    def test_inf_any(self***REMOVED***:
        # atan2(+-infinity, x***REMOVED*** returns +-pi/2 for finite x.
        assert_almost_equal(ncu.arctan2( np.inf, 1***REMOVED***,  0.5 * np.pi***REMOVED***
        assert_almost_equal(ncu.arctan2(-np.inf, 1***REMOVED***, -0.5 * np.pi***REMOVED***

    def test_inf_ninf(self***REMOVED***:
        # atan2(+-infinity, -infinity***REMOVED*** returns +-3*pi/4.
        assert_almost_equal(ncu.arctan2( np.inf, -np.inf***REMOVED***,  0.75 * np.pi***REMOVED***
        assert_almost_equal(ncu.arctan2(-np.inf, -np.inf***REMOVED***, -0.75 * np.pi***REMOVED***

    def test_inf_pinf(self***REMOVED***:
        # atan2(+-infinity, +infinity***REMOVED*** returns +-pi/4.
        assert_almost_equal(ncu.arctan2( np.inf, np.inf***REMOVED***,  0.25 * np.pi***REMOVED***
        assert_almost_equal(ncu.arctan2(-np.inf, np.inf***REMOVED***, -0.25 * np.pi***REMOVED***

    def test_nan_any(self***REMOVED***:
        # atan2(nan, x***REMOVED*** returns nan for any x, including inf
        assert_arctan2_isnan(np.nan, np.inf***REMOVED***
        assert_arctan2_isnan(np.inf, np.nan***REMOVED***
        assert_arctan2_isnan(np.nan, np.nan***REMOVED***


class TestLdexp(TestCase***REMOVED***:
    def _check_ldexp(self, tp***REMOVED***:
        assert_almost_equal(ncu.ldexp(np.array(2., np.float32***REMOVED***,
                                      np.array(3, tp***REMOVED******REMOVED***, 16.***REMOVED***
        assert_almost_equal(ncu.ldexp(np.array(2., np.float64***REMOVED***,
                                      np.array(3, tp***REMOVED******REMOVED***, 16.***REMOVED***
        assert_almost_equal(ncu.ldexp(np.array(2., np.longdouble***REMOVED***,
                                      np.array(3, tp***REMOVED******REMOVED***, 16.***REMOVED***

    def test_ldexp(self***REMOVED***:
        # The default Python int type should work
        assert_almost_equal(ncu.ldexp(2., 3***REMOVED***,  16.***REMOVED***
        # The following int types should all be accepted
        self._check_ldexp(np.int8***REMOVED***
        self._check_ldexp(np.int16***REMOVED***
        self._check_ldexp(np.int32***REMOVED***
        self._check_ldexp('i'***REMOVED***
        self._check_ldexp('l'***REMOVED***

    def test_ldexp_overflow(self***REMOVED***:
        # silence warning emitted on overflow
        with np.errstate(over="ignore"***REMOVED***:
            imax = np.iinfo(np.dtype('l'***REMOVED******REMOVED***.max
            imin = np.iinfo(np.dtype('l'***REMOVED******REMOVED***.min
            assert_equal(ncu.ldexp(2., imax***REMOVED***, np.inf***REMOVED***
            assert_equal(ncu.ldexp(2., imin***REMOVED***, 0***REMOVED***


class TestMaximum(_FilterInvalids***REMOVED***:
    def test_reduce(self***REMOVED***:
        dflt = np.typecodes['AllFloat'***REMOVED***
        dint = np.typecodes['AllInteger'***REMOVED***
        seq1 = np.arange(11***REMOVED***
        seq2 = seq1[::-1***REMOVED***
        func = np.maximum.reduce
        for dt in dint:
            tmp1 = seq1.astype(dt***REMOVED***
            tmp2 = seq2.astype(dt***REMOVED***
            assert_equal(func(tmp1***REMOVED***, 10***REMOVED***
            assert_equal(func(tmp2***REMOVED***, 10***REMOVED***
        for dt in dflt:
            tmp1 = seq1.astype(dt***REMOVED***
            tmp2 = seq2.astype(dt***REMOVED***
            assert_equal(func(tmp1***REMOVED***, 10***REMOVED***
            assert_equal(func(tmp2***REMOVED***, 10***REMOVED***
            tmp1[::2***REMOVED*** = np.nan
            tmp2[::2***REMOVED*** = np.nan
            assert_equal(func(tmp1***REMOVED***, np.nan***REMOVED***
            assert_equal(func(tmp2***REMOVED***, np.nan***REMOVED***

    def test_reduce_complex(self***REMOVED***:
        assert_equal(np.maximum.reduce([1, 2j***REMOVED******REMOVED***, 1***REMOVED***
        assert_equal(np.maximum.reduce([1+3j, 2j***REMOVED******REMOVED***, 1+3j***REMOVED***

    def test_float_nans(self***REMOVED***:
        nan = np.nan
        arg1 = np.array([0,   nan, nan***REMOVED******REMOVED***
        arg2 = np.array([nan, 0,   nan***REMOVED******REMOVED***
        out = np.array([nan, nan, nan***REMOVED******REMOVED***
        assert_equal(np.maximum(arg1, arg2***REMOVED***, out***REMOVED***

    def test_object_nans(self***REMOVED***:
        # Multiple checks to give this a chance to
        # fail if cmp is used instead of rich compare.
        # Failure cannot be guaranteed.
        for i in range(1***REMOVED***:
            x = np.array(float('nan'***REMOVED***, np.object***REMOVED***
            y = 1.0
            z = np.array(float('nan'***REMOVED***, np.object***REMOVED***
            assert_(np.maximum(x, y***REMOVED*** == 1.0***REMOVED***
            assert_(np.maximum(z, y***REMOVED*** == 1.0***REMOVED***

    def test_complex_nans(self***REMOVED***:
        nan = np.nan
        for cnan in [complex(nan, 0***REMOVED***, complex(0, nan***REMOVED***, complex(nan, nan***REMOVED******REMOVED***:
            arg1 = np.array([0, cnan, cnan***REMOVED***, dtype=np.complex***REMOVED***
            arg2 = np.array([cnan, 0, cnan***REMOVED***, dtype=np.complex***REMOVED***
            out = np.array([nan, nan, nan***REMOVED***, dtype=np.complex***REMOVED***
            assert_equal(np.maximum(arg1, arg2***REMOVED***, out***REMOVED***

    def test_object_array(self***REMOVED***:
        arg1 = np.arange(5, dtype=np.object***REMOVED***
        arg2 = arg1 + 1
        assert_equal(np.maximum(arg1, arg2***REMOVED***, arg2***REMOVED***


class TestMinimum(_FilterInvalids***REMOVED***:
    def test_reduce(self***REMOVED***:
        dflt = np.typecodes['AllFloat'***REMOVED***
        dint = np.typecodes['AllInteger'***REMOVED***
        seq1 = np.arange(11***REMOVED***
        seq2 = seq1[::-1***REMOVED***
        func = np.minimum.reduce
        for dt in dint:
            tmp1 = seq1.astype(dt***REMOVED***
            tmp2 = seq2.astype(dt***REMOVED***
            assert_equal(func(tmp1***REMOVED***, 0***REMOVED***
            assert_equal(func(tmp2***REMOVED***, 0***REMOVED***
        for dt in dflt:
            tmp1 = seq1.astype(dt***REMOVED***
            tmp2 = seq2.astype(dt***REMOVED***
            assert_equal(func(tmp1***REMOVED***, 0***REMOVED***
            assert_equal(func(tmp2***REMOVED***, 0***REMOVED***
            tmp1[::2***REMOVED*** = np.nan
            tmp2[::2***REMOVED*** = np.nan
            assert_equal(func(tmp1***REMOVED***, np.nan***REMOVED***
            assert_equal(func(tmp2***REMOVED***, np.nan***REMOVED***

    def test_reduce_complex(self***REMOVED***:
        assert_equal(np.minimum.reduce([1, 2j***REMOVED******REMOVED***, 2j***REMOVED***
        assert_equal(np.minimum.reduce([1+3j, 2j***REMOVED******REMOVED***, 2j***REMOVED***

    def test_float_nans(self***REMOVED***:
        nan = np.nan
        arg1 = np.array([0,   nan, nan***REMOVED******REMOVED***
        arg2 = np.array([nan, 0,   nan***REMOVED******REMOVED***
        out = np.array([nan, nan, nan***REMOVED******REMOVED***
        assert_equal(np.minimum(arg1, arg2***REMOVED***, out***REMOVED***

    def test_object_nans(self***REMOVED***:
        # Multiple checks to give this a chance to
        # fail if cmp is used instead of rich compare.
        # Failure cannot be guaranteed.
        for i in range(1***REMOVED***:
            x = np.array(float('nan'***REMOVED***, np.object***REMOVED***
            y = 1.0
            z = np.array(float('nan'***REMOVED***, np.object***REMOVED***
            assert_(np.minimum(x, y***REMOVED*** == 1.0***REMOVED***
            assert_(np.minimum(z, y***REMOVED*** == 1.0***REMOVED***

    def test_complex_nans(self***REMOVED***:
        nan = np.nan
        for cnan in [complex(nan, 0***REMOVED***, complex(0, nan***REMOVED***, complex(nan, nan***REMOVED******REMOVED***:
            arg1 = np.array([0, cnan, cnan***REMOVED***, dtype=np.complex***REMOVED***
            arg2 = np.array([cnan, 0, cnan***REMOVED***, dtype=np.complex***REMOVED***
            out = np.array([nan, nan, nan***REMOVED***, dtype=np.complex***REMOVED***
            assert_equal(np.minimum(arg1, arg2***REMOVED***, out***REMOVED***

    def test_object_array(self***REMOVED***:
        arg1 = np.arange(5, dtype=np.object***REMOVED***
        arg2 = arg1 + 1
        assert_equal(np.minimum(arg1, arg2***REMOVED***, arg1***REMOVED***


class TestFmax(_FilterInvalids***REMOVED***:
    def test_reduce(self***REMOVED***:
        dflt = np.typecodes['AllFloat'***REMOVED***
        dint = np.typecodes['AllInteger'***REMOVED***
        seq1 = np.arange(11***REMOVED***
        seq2 = seq1[::-1***REMOVED***
        func = np.fmax.reduce
        for dt in dint:
            tmp1 = seq1.astype(dt***REMOVED***
            tmp2 = seq2.astype(dt***REMOVED***
            assert_equal(func(tmp1***REMOVED***, 10***REMOVED***
            assert_equal(func(tmp2***REMOVED***, 10***REMOVED***
        for dt in dflt:
            tmp1 = seq1.astype(dt***REMOVED***
            tmp2 = seq2.astype(dt***REMOVED***
            assert_equal(func(tmp1***REMOVED***, 10***REMOVED***
            assert_equal(func(tmp2***REMOVED***, 10***REMOVED***
            tmp1[::2***REMOVED*** = np.nan
            tmp2[::2***REMOVED*** = np.nan
            assert_equal(func(tmp1***REMOVED***, 9***REMOVED***
            assert_equal(func(tmp2***REMOVED***, 9***REMOVED***

    def test_reduce_complex(self***REMOVED***:
        assert_equal(np.fmax.reduce([1, 2j***REMOVED******REMOVED***, 1***REMOVED***
        assert_equal(np.fmax.reduce([1+3j, 2j***REMOVED******REMOVED***, 1+3j***REMOVED***

    def test_float_nans(self***REMOVED***:
        nan = np.nan
        arg1 = np.array([0,   nan, nan***REMOVED******REMOVED***
        arg2 = np.array([nan, 0,   nan***REMOVED******REMOVED***
        out = np.array([0,   0,   nan***REMOVED******REMOVED***
        assert_equal(np.fmax(arg1, arg2***REMOVED***, out***REMOVED***

    def test_complex_nans(self***REMOVED***:
        nan = np.nan
        for cnan in [complex(nan, 0***REMOVED***, complex(0, nan***REMOVED***, complex(nan, nan***REMOVED******REMOVED***:
            arg1 = np.array([0, cnan, cnan***REMOVED***, dtype=np.complex***REMOVED***
            arg2 = np.array([cnan, 0, cnan***REMOVED***, dtype=np.complex***REMOVED***
            out = np.array([0,    0, nan***REMOVED***, dtype=np.complex***REMOVED***
            assert_equal(np.fmax(arg1, arg2***REMOVED***, out***REMOVED***


class TestFmin(_FilterInvalids***REMOVED***:
    def test_reduce(self***REMOVED***:
        dflt = np.typecodes['AllFloat'***REMOVED***
        dint = np.typecodes['AllInteger'***REMOVED***
        seq1 = np.arange(11***REMOVED***
        seq2 = seq1[::-1***REMOVED***
        func = np.fmin.reduce
        for dt in dint:
            tmp1 = seq1.astype(dt***REMOVED***
            tmp2 = seq2.astype(dt***REMOVED***
            assert_equal(func(tmp1***REMOVED***, 0***REMOVED***
            assert_equal(func(tmp2***REMOVED***, 0***REMOVED***
        for dt in dflt:
            tmp1 = seq1.astype(dt***REMOVED***
            tmp2 = seq2.astype(dt***REMOVED***
            assert_equal(func(tmp1***REMOVED***, 0***REMOVED***
            assert_equal(func(tmp2***REMOVED***, 0***REMOVED***
            tmp1[::2***REMOVED*** = np.nan
            tmp2[::2***REMOVED*** = np.nan
            assert_equal(func(tmp1***REMOVED***, 1***REMOVED***
            assert_equal(func(tmp2***REMOVED***, 1***REMOVED***

    def test_reduce_complex(self***REMOVED***:
        assert_equal(np.fmin.reduce([1, 2j***REMOVED******REMOVED***, 2j***REMOVED***
        assert_equal(np.fmin.reduce([1+3j, 2j***REMOVED******REMOVED***, 2j***REMOVED***

    def test_float_nans(self***REMOVED***:
        nan = np.nan
        arg1 = np.array([0,   nan, nan***REMOVED******REMOVED***
        arg2 = np.array([nan, 0,   nan***REMOVED******REMOVED***
        out = np.array([0,   0,   nan***REMOVED******REMOVED***
        assert_equal(np.fmin(arg1, arg2***REMOVED***, out***REMOVED***

    def test_complex_nans(self***REMOVED***:
        nan = np.nan
        for cnan in [complex(nan, 0***REMOVED***, complex(0, nan***REMOVED***, complex(nan, nan***REMOVED******REMOVED***:
            arg1 = np.array([0, cnan, cnan***REMOVED***, dtype=np.complex***REMOVED***
            arg2 = np.array([cnan, 0, cnan***REMOVED***, dtype=np.complex***REMOVED***
            out = np.array([0,    0, nan***REMOVED***, dtype=np.complex***REMOVED***
            assert_equal(np.fmin(arg1, arg2***REMOVED***, out***REMOVED***


class TestBool(TestCase***REMOVED***:
    def test_truth_table_logical(self***REMOVED***:
        # 2, 3 and 4 serves as true values
        input1 = [0, 0, 3, 2***REMOVED***
        input2 = [0, 4, 0, 2***REMOVED***

        typecodes = (np.typecodes['AllFloat'***REMOVED***
                     + np.typecodes['AllInteger'***REMOVED***
                     + '?'***REMOVED***     # boolean
        for dtype in map(np.dtype, typecodes***REMOVED***:
            arg1 = np.asarray(input1, dtype=dtype***REMOVED***
            arg2 = np.asarray(input2, dtype=dtype***REMOVED***

            # OR
            out = [False, True, True, True***REMOVED***
            for func in (np.logical_or, np.maximum***REMOVED***:
                assert_equal(func(arg1, arg2***REMOVED***.astype(bool***REMOVED***, out***REMOVED***
            # AND
            out = [False, False, False, True***REMOVED***
            for func in (np.logical_and, np.minimum***REMOVED***:
                assert_equal(func(arg1, arg2***REMOVED***.astype(bool***REMOVED***, out***REMOVED***
            # XOR
            out = [False, True, True, False***REMOVED***
            for func in (np.logical_xor, np.not_equal***REMOVED***:
                assert_equal(func(arg1, arg2***REMOVED***.astype(bool***REMOVED***, out***REMOVED***

    def test_truth_table_bitwise(self***REMOVED***:
        arg1 = [False, False, True, True***REMOVED***
        arg2 = [False, True, False, True***REMOVED***

        out = [False, True, True, True***REMOVED***
        assert_equal(np.bitwise_or(arg1, arg2***REMOVED***, out***REMOVED***

        out = [False, False, False, True***REMOVED***
        assert_equal(np.bitwise_and(arg1, arg2***REMOVED***, out***REMOVED***

        out = [False, True, True, False***REMOVED***
        assert_equal(np.bitwise_xor(arg1, arg2***REMOVED***, out***REMOVED***


class TestInt(TestCase***REMOVED***:
    def test_logical_not(self***REMOVED***:
        x = np.ones(10, dtype=np.int16***REMOVED***
        o = np.ones(10 * 2, dtype=np.bool***REMOVED***
        tgt = o.copy(***REMOVED***
        tgt[::2***REMOVED*** = False
        os = o[::2***REMOVED***
        assert_array_equal(np.logical_not(x, out=os***REMOVED***, False***REMOVED***
        assert_array_equal(o, tgt***REMOVED***


class TestFloatingPoint(TestCase***REMOVED***:
    def test_floating_point(self***REMOVED***:
        assert_equal(ncu.FLOATING_POINT_SUPPORT, 1***REMOVED***


class TestDegrees(TestCase***REMOVED***:
    def test_degrees(self***REMOVED***:
        assert_almost_equal(ncu.degrees(np.pi***REMOVED***, 180.0***REMOVED***
        assert_almost_equal(ncu.degrees(-0.5*np.pi***REMOVED***, -90.0***REMOVED***


class TestRadians(TestCase***REMOVED***:
    def test_radians(self***REMOVED***:
        assert_almost_equal(ncu.radians(180.0***REMOVED***, np.pi***REMOVED***
        assert_almost_equal(ncu.radians(-90.0***REMOVED***, -0.5*np.pi***REMOVED***


class TestSign(TestCase***REMOVED***:
    def test_sign(self***REMOVED***:
        a = np.array([np.inf, -np.inf, np.nan, 0.0, 3.0, -3.0***REMOVED******REMOVED***
        out = np.zeros(a.shape***REMOVED***
        tgt = np.array([1., -1., np.nan, 0.0, 1.0, -1.0***REMOVED******REMOVED***

        with np.errstate(invalid='ignore'***REMOVED***:
            res = ncu.sign(a***REMOVED***
            assert_equal(res, tgt***REMOVED***
            res = ncu.sign(a, out***REMOVED***
            assert_equal(res, tgt***REMOVED***
            assert_equal(out, tgt***REMOVED***

    def test_sign_dtype_object(self***REMOVED***:
        # In reference to github issue #6229

        foo = np.array([-.1, 0, .1***REMOVED******REMOVED***
        a = np.sign(foo.astype(np.object***REMOVED******REMOVED***
        b = np.sign(foo***REMOVED***

        assert_array_equal(a, b***REMOVED***

    def test_sign_dtype_nan_object(self***REMOVED***:
        # In reference to github issue #6229
        def test_nan(***REMOVED***:
            foo = np.array([np.nan***REMOVED******REMOVED***
            a = np.sign(foo.astype(np.object***REMOVED******REMOVED***

        assert_raises(TypeError, test_nan***REMOVED***

class TestMinMax(TestCase***REMOVED***:
    def test_minmax_blocked(self***REMOVED***:
        # simd tests on max/min, test all alignments, slow but important
        # for 2 * vz + 2 * (vs - 1***REMOVED*** + 1 (unrolled once***REMOVED***
        for dt, sz in [(np.float32, 15***REMOVED***, (np.float64, 7***REMOVED******REMOVED***:
            for out, inp, msg in _gen_alignment_data(dtype=dt, type='unary',
                                                     max_size=sz***REMOVED***:
                for i in range(inp.size***REMOVED***:
                    inp[:***REMOVED*** = np.arange(inp.size, dtype=dt***REMOVED***
                    inp[i***REMOVED*** = np.nan
                    emsg = lambda: '%r\n%s' % (inp, msg***REMOVED***
                    assert_(np.isnan(inp.max(***REMOVED******REMOVED***, msg=emsg***REMOVED***
                    assert_(np.isnan(inp.min(***REMOVED******REMOVED***, msg=emsg***REMOVED***

                    inp[i***REMOVED*** = 1e10
                    assert_equal(inp.max(***REMOVED***, 1e10, err_msg=msg***REMOVED***
                    inp[i***REMOVED*** = -1e10
                    assert_equal(inp.min(***REMOVED***, -1e10, err_msg=msg***REMOVED***

    def test_lower_align(self***REMOVED***:
        # check data that is not aligned to element size
        # i.e doubles are aligned to 4 bytes on i386
        d = np.zeros(23 * 8, dtype=np.int8***REMOVED***[4:-4***REMOVED***.view(np.float64***REMOVED***
        assert_equal(d.max(***REMOVED***, d[0***REMOVED******REMOVED***
        assert_equal(d.min(***REMOVED***, d[0***REMOVED******REMOVED***


class TestAbsoluteNegative(TestCase***REMOVED***:
    def test_abs_neg_blocked(self***REMOVED***:
        # simd tests on abs, test all alignments for vz + 2 * (vs - 1***REMOVED*** + 1
        for dt, sz in [(np.float32, 11***REMOVED***, (np.float64, 5***REMOVED******REMOVED***:
            for out, inp, msg in _gen_alignment_data(dtype=dt, type='unary',
                                                     max_size=sz***REMOVED***:
                tgt = [ncu.absolute(i***REMOVED*** for i in inp***REMOVED***
                np.absolute(inp, out=out***REMOVED***
                assert_equal(out, tgt, err_msg=msg***REMOVED***
                self.assertTrue((out >= 0***REMOVED***.all(***REMOVED******REMOVED***

                tgt = [-1*(i***REMOVED*** for i in inp***REMOVED***
                np.negative(inp, out=out***REMOVED***
                assert_equal(out, tgt, err_msg=msg***REMOVED***

                # will throw invalid flag depending on compiler optimizations
                with np.errstate(invalid='ignore'***REMOVED***:
                    for v in [np.nan, -np.inf, np.inf***REMOVED***:
                        for i in range(inp.size***REMOVED***:
                            d = np.arange(inp.size, dtype=dt***REMOVED***
                            inp[:***REMOVED*** = -d
                            inp[i***REMOVED*** = v
                            d[i***REMOVED*** = -v if v == -np.inf else v
                            assert_array_equal(np.abs(inp***REMOVED***, d, err_msg=msg***REMOVED***
                            np.abs(inp, out=out***REMOVED***
                            assert_array_equal(out, d, err_msg=msg***REMOVED***

                            assert_array_equal(-inp, -1*inp, err_msg=msg***REMOVED***
                            np.negative(inp, out=out***REMOVED***
                            assert_array_equal(out, -1*inp, err_msg=msg***REMOVED***

    def test_lower_align(self***REMOVED***:
        # check data that is not aligned to element size
        # i.e doubles are aligned to 4 bytes on i386
        d = np.zeros(23 * 8, dtype=np.int8***REMOVED***[4:-4***REMOVED***.view(np.float64***REMOVED***
        assert_equal(np.abs(d***REMOVED***, d***REMOVED***
        assert_equal(np.negative(d***REMOVED***, -d***REMOVED***
        np.negative(d, out=d***REMOVED***
        np.negative(np.ones_like(d***REMOVED***, out=d***REMOVED***
        np.abs(d, out=d***REMOVED***
        np.abs(np.ones_like(d***REMOVED***, out=d***REMOVED***


class TestSpecialMethods(TestCase***REMOVED***:
    def test_wrap(self***REMOVED***:

        class with_wrap(object***REMOVED***:
            def __array__(self***REMOVED***:
                return np.zeros(1***REMOVED***

            def __array_wrap__(self, arr, context***REMOVED***:
                r = with_wrap(***REMOVED***
                r.arr = arr
                r.context = context
                return r

        a = with_wrap(***REMOVED***
        x = ncu.minimum(a, a***REMOVED***
        assert_equal(x.arr, np.zeros(1***REMOVED******REMOVED***
        func, args, i = x.context
        self.assertTrue(func is ncu.minimum***REMOVED***
        self.assertEqual(len(args***REMOVED***, 2***REMOVED***
        assert_equal(args[0***REMOVED***, a***REMOVED***
        assert_equal(args[1***REMOVED***, a***REMOVED***
        self.assertEqual(i, 0***REMOVED***

    def test_wrap_with_iterable(self***REMOVED***:
        # test fix for bug #1026:

        class with_wrap(np.ndarray***REMOVED***:
            __array_priority__ = 10

            def __new__(cls***REMOVED***:
                return np.asarray(1***REMOVED***.view(cls***REMOVED***.copy(***REMOVED***

            def __array_wrap__(self, arr, context***REMOVED***:
                return arr.view(type(self***REMOVED******REMOVED***

        a = with_wrap(***REMOVED***
        x = ncu.multiply(a, (1, 2, 3***REMOVED******REMOVED***
        self.assertTrue(isinstance(x, with_wrap***REMOVED******REMOVED***
        assert_array_equal(x, np.array((1, 2, 3***REMOVED******REMOVED******REMOVED***

    def test_priority_with_scalar(self***REMOVED***:
        # test fix for bug #826:

        class A(np.ndarray***REMOVED***:
            __array_priority__ = 10

            def __new__(cls***REMOVED***:
                return np.asarray(1.0, 'float64'***REMOVED***.view(cls***REMOVED***.copy(***REMOVED***

        a = A(***REMOVED***
        x = np.float64(1***REMOVED****a
        self.assertTrue(isinstance(x, A***REMOVED******REMOVED***
        assert_array_equal(x, np.array(1***REMOVED******REMOVED***

    def test_old_wrap(self***REMOVED***:

        class with_wrap(object***REMOVED***:
            def __array__(self***REMOVED***:
                return np.zeros(1***REMOVED***

            def __array_wrap__(self, arr***REMOVED***:
                r = with_wrap(***REMOVED***
                r.arr = arr
                return r

        a = with_wrap(***REMOVED***
        x = ncu.minimum(a, a***REMOVED***
        assert_equal(x.arr, np.zeros(1***REMOVED******REMOVED***

    def test_priority(self***REMOVED***:

        class A(object***REMOVED***:
            def __array__(self***REMOVED***:
                return np.zeros(1***REMOVED***

            def __array_wrap__(self, arr, context***REMOVED***:
                r = type(self***REMOVED***(***REMOVED***
                r.arr = arr
                r.context = context
                return r

        class B(A***REMOVED***:
            __array_priority__ = 20.

        class C(A***REMOVED***:
            __array_priority__ = 40.

        x = np.zeros(1***REMOVED***
        a = A(***REMOVED***
        b = B(***REMOVED***
        c = C(***REMOVED***
        f = ncu.minimum
        self.assertTrue(type(f(x, x***REMOVED******REMOVED*** is np.ndarray***REMOVED***
        self.assertTrue(type(f(x, a***REMOVED******REMOVED*** is A***REMOVED***
        self.assertTrue(type(f(x, b***REMOVED******REMOVED*** is B***REMOVED***
        self.assertTrue(type(f(x, c***REMOVED******REMOVED*** is C***REMOVED***
        self.assertTrue(type(f(a, x***REMOVED******REMOVED*** is A***REMOVED***
        self.assertTrue(type(f(b, x***REMOVED******REMOVED*** is B***REMOVED***
        self.assertTrue(type(f(c, x***REMOVED******REMOVED*** is C***REMOVED***

        self.assertTrue(type(f(a, a***REMOVED******REMOVED*** is A***REMOVED***
        self.assertTrue(type(f(a, b***REMOVED******REMOVED*** is B***REMOVED***
        self.assertTrue(type(f(b, a***REMOVED******REMOVED*** is B***REMOVED***
        self.assertTrue(type(f(b, b***REMOVED******REMOVED*** is B***REMOVED***
        self.assertTrue(type(f(b, c***REMOVED******REMOVED*** is C***REMOVED***
        self.assertTrue(type(f(c, b***REMOVED******REMOVED*** is C***REMOVED***
        self.assertTrue(type(f(c, c***REMOVED******REMOVED*** is C***REMOVED***

        self.assertTrue(type(ncu.exp(a***REMOVED*** is A***REMOVED******REMOVED***
        self.assertTrue(type(ncu.exp(b***REMOVED*** is B***REMOVED******REMOVED***
        self.assertTrue(type(ncu.exp(c***REMOVED*** is C***REMOVED******REMOVED***

    def test_failing_wrap(self***REMOVED***:

        class A(object***REMOVED***:
            def __array__(self***REMOVED***:
                return np.zeros(1***REMOVED***

            def __array_wrap__(self, arr, context***REMOVED***:
                raise RuntimeError

        a = A(***REMOVED***
        self.assertRaises(RuntimeError, ncu.maximum, a, a***REMOVED***

    def test_default_prepare(self***REMOVED***:

        class with_wrap(object***REMOVED***:
            __array_priority__ = 10

            def __array__(self***REMOVED***:
                return np.zeros(1***REMOVED***

            def __array_wrap__(self, arr, context***REMOVED***:
                return arr

        a = with_wrap(***REMOVED***
        x = ncu.minimum(a, a***REMOVED***
        assert_equal(x, np.zeros(1***REMOVED******REMOVED***
        assert_equal(type(x***REMOVED***, np.ndarray***REMOVED***

    def test_prepare(self***REMOVED***:

        class with_prepare(np.ndarray***REMOVED***:
            __array_priority__ = 10

            def __array_prepare__(self, arr, context***REMOVED***:
                # make sure we can return a new
                return np.array(arr***REMOVED***.view(type=with_prepare***REMOVED***

        a = np.array(1***REMOVED***.view(type=with_prepare***REMOVED***
        x = np.add(a, a***REMOVED***
        assert_equal(x, np.array(2***REMOVED******REMOVED***
        assert_equal(type(x***REMOVED***, with_prepare***REMOVED***

    def test_failing_prepare(self***REMOVED***:

        class A(object***REMOVED***:
            def __array__(self***REMOVED***:
                return np.zeros(1***REMOVED***

            def __array_prepare__(self, arr, context=None***REMOVED***:
                raise RuntimeError

        a = A(***REMOVED***
        self.assertRaises(RuntimeError, ncu.maximum, a, a***REMOVED***

    def test_array_with_context(self***REMOVED***:

        class A(object***REMOVED***:
            def __array__(self, dtype=None, context=None***REMOVED***:
                func, args, i = context
                self.func = func
                self.args = args
                self.i = i
                return np.zeros(1***REMOVED***

        class B(object***REMOVED***:
            def __array__(self, dtype=None***REMOVED***:
                return np.zeros(1, dtype***REMOVED***

        class C(object***REMOVED***:
            def __array__(self***REMOVED***:
                return np.zeros(1***REMOVED***

        a = A(***REMOVED***
        ncu.maximum(np.zeros(1***REMOVED***, a***REMOVED***
        self.assertTrue(a.func is ncu.maximum***REMOVED***
        assert_equal(a.args[0***REMOVED***, 0***REMOVED***
        self.assertTrue(a.args[1***REMOVED*** is a***REMOVED***
        self.assertTrue(a.i == 1***REMOVED***
        assert_equal(ncu.maximum(a, B(***REMOVED******REMOVED***, 0***REMOVED***
        assert_equal(ncu.maximum(a, C(***REMOVED******REMOVED***, 0***REMOVED***

    def test_ufunc_override_disabled(self***REMOVED***:
        # 2016-01-29: NUMPY_UFUNC_DISABLED
        # This test should be removed when __numpy_ufunc__ is re-enabled.

        class MyArray(object***REMOVED***:
            def __numpy_ufunc__(self, *args, **kwargs***REMOVED***:
                self._numpy_ufunc_called = True

        my_array = MyArray(***REMOVED***
        real_array = np.ones(10***REMOVED***
        assert_raises(TypeError, lambda: real_array + my_array***REMOVED***
        assert_raises(TypeError, np.add, real_array, my_array***REMOVED***
        assert not hasattr(my_array, "_numpy_ufunc_called"***REMOVED***


    def test_ufunc_override(self***REMOVED***:
        # 2016-01-29: NUMPY_UFUNC_DISABLED
        return

        class A(object***REMOVED***:
            def __numpy_ufunc__(self, func, method, pos, inputs, **kwargs***REMOVED***:
                return self, func, method, pos, inputs, kwargs

        a = A(***REMOVED***
        b = np.matrix([1***REMOVED******REMOVED***
        res0 = np.multiply(a, b***REMOVED***
        res1 = np.dot(a, b***REMOVED***

        # self
        assert_equal(res0[0***REMOVED***, a***REMOVED***
        assert_equal(res1[0***REMOVED***, a***REMOVED***
        assert_equal(res0[1***REMOVED***, np.multiply***REMOVED***
        assert_equal(res1[1***REMOVED***, np.dot***REMOVED***
        assert_equal(res0[2***REMOVED***, '__call__'***REMOVED***
        assert_equal(res1[2***REMOVED***, '__call__'***REMOVED***
        assert_equal(res0[3***REMOVED***, 0***REMOVED***
        assert_equal(res1[3***REMOVED***, 0***REMOVED***
        assert_equal(res0[4***REMOVED***, (a, b***REMOVED******REMOVED***
        assert_equal(res1[4***REMOVED***, (a, b***REMOVED******REMOVED***
        assert_equal(res0[5***REMOVED***, {***REMOVED******REMOVED***
        assert_equal(res1[5***REMOVED***, {***REMOVED******REMOVED***

    def test_ufunc_override_mro(self***REMOVED***:
        # 2016-01-29: NUMPY_UFUNC_DISABLED
        return

        # Some multi arg functions for testing.
        def tres_mul(a, b, c***REMOVED***:
            return a * b * c

        def quatro_mul(a, b, c, d***REMOVED***:
            return a * b * c * d

        # Make these into ufuncs.
        three_mul_ufunc = np.frompyfunc(tres_mul, 3, 1***REMOVED***
        four_mul_ufunc = np.frompyfunc(quatro_mul, 4, 1***REMOVED***

        class A(object***REMOVED***:
            def __numpy_ufunc__(self, func, method, pos, inputs, **kwargs***REMOVED***:
                return "A"

        class ASub(A***REMOVED***:
            def __numpy_ufunc__(self, func, method, pos, inputs, **kwargs***REMOVED***:
                return "ASub"

        class B(object***REMOVED***:
            def __numpy_ufunc__(self, func, method, pos, inputs, **kwargs***REMOVED***:
                return "B"

        class C(object***REMOVED***:
            def __numpy_ufunc__(self, func, method, pos, inputs, **kwargs***REMOVED***:
                return NotImplemented

        class CSub(object***REMOVED***:
            def __numpy_ufunc__(self, func, method, pos, inputs, **kwargs***REMOVED***:
                return NotImplemented

        a = A(***REMOVED***
        a_sub = ASub(***REMOVED***
        b = B(***REMOVED***
        c = C(***REMOVED***
        c_sub = CSub(***REMOVED***

        # Standard
        res = np.multiply(a, a_sub***REMOVED***
        assert_equal(res, "ASub"***REMOVED***
        res = np.multiply(a_sub, b***REMOVED***
        assert_equal(res, "ASub"***REMOVED***

        # With 1 NotImplemented
        res = np.multiply(c, a***REMOVED***
        assert_equal(res, "A"***REMOVED***

        # Both NotImplemented.
        assert_raises(TypeError, np.multiply, c, c_sub***REMOVED***
        assert_raises(TypeError, np.multiply, c_sub, c***REMOVED***
        assert_raises(TypeError, np.multiply, 2, c***REMOVED***

        # Ternary testing.
        assert_equal(three_mul_ufunc(a, 1, 2***REMOVED***, "A"***REMOVED***
        assert_equal(three_mul_ufunc(1, a, 2***REMOVED***, "A"***REMOVED***
        assert_equal(three_mul_ufunc(1, 2, a***REMOVED***, "A"***REMOVED***

        assert_equal(three_mul_ufunc(a, a, 6***REMOVED***, "A"***REMOVED***
        assert_equal(three_mul_ufunc(a, 2, a***REMOVED***, "A"***REMOVED***
        assert_equal(three_mul_ufunc(a, 2, b***REMOVED***, "A"***REMOVED***
        assert_equal(three_mul_ufunc(a, 2, a_sub***REMOVED***, "ASub"***REMOVED***
        assert_equal(three_mul_ufunc(a, a_sub, 3***REMOVED***, "ASub"***REMOVED***
        assert_equal(three_mul_ufunc(c, a_sub, 3***REMOVED***, "ASub"***REMOVED***
        assert_equal(three_mul_ufunc(1, a_sub, c***REMOVED***, "ASub"***REMOVED***

        assert_equal(three_mul_ufunc(a, b, c***REMOVED***, "A"***REMOVED***
        assert_equal(three_mul_ufunc(a, b, c_sub***REMOVED***, "A"***REMOVED***
        assert_equal(three_mul_ufunc(1, 2, b***REMOVED***, "B"***REMOVED***

        assert_raises(TypeError, three_mul_ufunc, 1, 2, c***REMOVED***
        assert_raises(TypeError, three_mul_ufunc, c_sub, 2, c***REMOVED***
        assert_raises(TypeError, three_mul_ufunc, c_sub, 2, 3***REMOVED***

        # Quaternary testing.
        assert_equal(four_mul_ufunc(a, 1, 2, 3***REMOVED***, "A"***REMOVED***
        assert_equal(four_mul_ufunc(1, a, 2, 3***REMOVED***, "A"***REMOVED***
        assert_equal(four_mul_ufunc(1, 1, a, 3***REMOVED***, "A"***REMOVED***
        assert_equal(four_mul_ufunc(1, 1, 2, a***REMOVED***, "A"***REMOVED***

        assert_equal(four_mul_ufunc(a, b, 2, 3***REMOVED***, "A"***REMOVED***
        assert_equal(four_mul_ufunc(1, a, 2, b***REMOVED***, "A"***REMOVED***
        assert_equal(four_mul_ufunc(b, 1, a, 3***REMOVED***, "B"***REMOVED***
        assert_equal(four_mul_ufunc(a_sub, 1, 2, a***REMOVED***, "ASub"***REMOVED***
        assert_equal(four_mul_ufunc(a, 1, 2, a_sub***REMOVED***, "ASub"***REMOVED***

        assert_raises(TypeError, four_mul_ufunc, 1, 2, 3, c***REMOVED***
        assert_raises(TypeError, four_mul_ufunc, 1, 2, c_sub, c***REMOVED***
        assert_raises(TypeError, four_mul_ufunc, 1, c, c_sub, c***REMOVED***

    def test_ufunc_override_methods(self***REMOVED***:
        # 2016-01-29: NUMPY_UFUNC_DISABLED
        return

        class A(object***REMOVED***:
            def __numpy_ufunc__(self, ufunc, method, pos, inputs, **kwargs***REMOVED***:
                return self, ufunc, method, pos, inputs, kwargs

        # __call__
        a = A(***REMOVED***
        res = np.multiply.__call__(1, a, foo='bar', answer=42***REMOVED***
        assert_equal(res[0***REMOVED***, a***REMOVED***
        assert_equal(res[1***REMOVED***, np.multiply***REMOVED***
        assert_equal(res[2***REMOVED***, '__call__'***REMOVED***
        assert_equal(res[3***REMOVED***, 1***REMOVED***
        assert_equal(res[4***REMOVED***, (1, a***REMOVED******REMOVED***
        assert_equal(res[5***REMOVED***, {'foo': 'bar', 'answer': 42***REMOVED******REMOVED***

        # reduce, positional args
        res = np.multiply.reduce(a, 'axis0', 'dtype0', 'out0', 'keep0'***REMOVED***
        assert_equal(res[0***REMOVED***, a***REMOVED***
        assert_equal(res[1***REMOVED***, np.multiply***REMOVED***
        assert_equal(res[2***REMOVED***, 'reduce'***REMOVED***
        assert_equal(res[3***REMOVED***, 0***REMOVED***
        assert_equal(res[4***REMOVED***, (a,***REMOVED******REMOVED***
        assert_equal(res[5***REMOVED***, {'dtype':'dtype0',
                               'out': 'out0',
                               'keepdims': 'keep0',
                               'axis': 'axis0'***REMOVED******REMOVED***

        # reduce, kwargs
        res = np.multiply.reduce(a, axis='axis0', dtype='dtype0', out='out0',
                                 keepdims='keep0'***REMOVED***
        assert_equal(res[0***REMOVED***, a***REMOVED***
        assert_equal(res[1***REMOVED***, np.multiply***REMOVED***
        assert_equal(res[2***REMOVED***, 'reduce'***REMOVED***
        assert_equal(res[3***REMOVED***, 0***REMOVED***
        assert_equal(res[4***REMOVED***, (a,***REMOVED******REMOVED***
        assert_equal(res[5***REMOVED***, {'dtype':'dtype0',
                               'out': 'out0',
                               'keepdims': 'keep0',
                               'axis': 'axis0'***REMOVED******REMOVED***

        # accumulate, pos args
        res = np.multiply.accumulate(a, 'axis0', 'dtype0', 'out0'***REMOVED***
        assert_equal(res[0***REMOVED***, a***REMOVED***
        assert_equal(res[1***REMOVED***, np.multiply***REMOVED***
        assert_equal(res[2***REMOVED***, 'accumulate'***REMOVED***
        assert_equal(res[3***REMOVED***, 0***REMOVED***
        assert_equal(res[4***REMOVED***, (a,***REMOVED******REMOVED***
        assert_equal(res[5***REMOVED***, {'dtype':'dtype0',
                               'out': 'out0',
                               'axis': 'axis0'***REMOVED******REMOVED***

        # accumulate, kwargs
        res = np.multiply.accumulate(a, axis='axis0', dtype='dtype0',
                                     out='out0'***REMOVED***
        assert_equal(res[0***REMOVED***, a***REMOVED***
        assert_equal(res[1***REMOVED***, np.multiply***REMOVED***
        assert_equal(res[2***REMOVED***, 'accumulate'***REMOVED***
        assert_equal(res[3***REMOVED***, 0***REMOVED***
        assert_equal(res[4***REMOVED***, (a,***REMOVED******REMOVED***
        assert_equal(res[5***REMOVED***, {'dtype':'dtype0',
                               'out': 'out0',
                               'axis': 'axis0'***REMOVED******REMOVED***

        # reduceat, pos args
        res = np.multiply.reduceat(a, [4, 2***REMOVED***, 'axis0', 'dtype0', 'out0'***REMOVED***
        assert_equal(res[0***REMOVED***, a***REMOVED***
        assert_equal(res[1***REMOVED***, np.multiply***REMOVED***
        assert_equal(res[2***REMOVED***, 'reduceat'***REMOVED***
        assert_equal(res[3***REMOVED***, 0***REMOVED***
        assert_equal(res[4***REMOVED***, (a, [4, 2***REMOVED******REMOVED******REMOVED***
        assert_equal(res[5***REMOVED***, {'dtype':'dtype0',
                               'out': 'out0',
                               'axis': 'axis0'***REMOVED******REMOVED***

        # reduceat, kwargs
        res = np.multiply.reduceat(a, [4, 2***REMOVED***, axis='axis0', dtype='dtype0',
                                   out='out0'***REMOVED***
        assert_equal(res[0***REMOVED***, a***REMOVED***
        assert_equal(res[1***REMOVED***, np.multiply***REMOVED***
        assert_equal(res[2***REMOVED***, 'reduceat'***REMOVED***
        assert_equal(res[3***REMOVED***, 0***REMOVED***
        assert_equal(res[4***REMOVED***, (a, [4, 2***REMOVED******REMOVED******REMOVED***
        assert_equal(res[5***REMOVED***, {'dtype':'dtype0',
                               'out': 'out0',
                               'axis': 'axis0'***REMOVED******REMOVED***

        # outer
        res = np.multiply.outer(a, 42***REMOVED***
        assert_equal(res[0***REMOVED***, a***REMOVED***
        assert_equal(res[1***REMOVED***, np.multiply***REMOVED***
        assert_equal(res[2***REMOVED***, 'outer'***REMOVED***
        assert_equal(res[3***REMOVED***, 0***REMOVED***
        assert_equal(res[4***REMOVED***, (a, 42***REMOVED******REMOVED***
        assert_equal(res[5***REMOVED***, {***REMOVED******REMOVED***

        # at
        res = np.multiply.at(a, [4, 2***REMOVED***, 'b0'***REMOVED***
        assert_equal(res[0***REMOVED***, a***REMOVED***
        assert_equal(res[1***REMOVED***, np.multiply***REMOVED***
        assert_equal(res[2***REMOVED***, 'at'***REMOVED***
        assert_equal(res[3***REMOVED***, 0***REMOVED***
        assert_equal(res[4***REMOVED***, (a, [4, 2***REMOVED***, 'b0'***REMOVED******REMOVED***

    def test_ufunc_override_out(self***REMOVED***:
        # 2016-01-29: NUMPY_UFUNC_DISABLED
        return

        class A(object***REMOVED***:
            def __numpy_ufunc__(self, ufunc, method, pos, inputs, **kwargs***REMOVED***:
                return kwargs

        class B(object***REMOVED***:
            def __numpy_ufunc__(self, ufunc, method, pos, inputs, **kwargs***REMOVED***:
                return kwargs

        a = A(***REMOVED***
        b = B(***REMOVED***
        res0 = np.multiply(a, b, 'out_arg'***REMOVED***
        res1 = np.multiply(a, b, out='out_arg'***REMOVED***
        res2 = np.multiply(2, b, 'out_arg'***REMOVED***
        res3 = np.multiply(3, b, out='out_arg'***REMOVED***
        res4 = np.multiply(a, 4, 'out_arg'***REMOVED***
        res5 = np.multiply(a, 5, out='out_arg'***REMOVED***

        assert_equal(res0['out'***REMOVED***, 'out_arg'***REMOVED***
        assert_equal(res1['out'***REMOVED***, 'out_arg'***REMOVED***
        assert_equal(res2['out'***REMOVED***, 'out_arg'***REMOVED***
        assert_equal(res3['out'***REMOVED***, 'out_arg'***REMOVED***
        assert_equal(res4['out'***REMOVED***, 'out_arg'***REMOVED***
        assert_equal(res5['out'***REMOVED***, 'out_arg'***REMOVED***

        # ufuncs with multiple output modf and frexp.
        res6 = np.modf(a, 'out0', 'out1'***REMOVED***
        res7 = np.frexp(a, 'out0', 'out1'***REMOVED***
        assert_equal(res6['out'***REMOVED***[0***REMOVED***, 'out0'***REMOVED***
        assert_equal(res6['out'***REMOVED***[1***REMOVED***, 'out1'***REMOVED***
        assert_equal(res7['out'***REMOVED***[0***REMOVED***, 'out0'***REMOVED***
        assert_equal(res7['out'***REMOVED***[1***REMOVED***, 'out1'***REMOVED***

    def test_ufunc_override_exception(self***REMOVED***:
        # 2016-01-29: NUMPY_UFUNC_DISABLED
        return

        class A(object***REMOVED***:
            def __numpy_ufunc__(self, *a, **kwargs***REMOVED***:
                raise ValueError("oops"***REMOVED***

        a = A(***REMOVED***
        for func in [np.divide, np.dot***REMOVED***:
            assert_raises(ValueError, func, a, a***REMOVED***

class TestChoose(TestCase***REMOVED***:
    def test_mixed(self***REMOVED***:
        c = np.array([True, True***REMOVED******REMOVED***
        a = np.array([True, True***REMOVED******REMOVED***
        assert_equal(np.choose(c, (a, 1***REMOVED******REMOVED***, np.array([1, 1***REMOVED******REMOVED******REMOVED***


def is_longdouble_finfo_bogus(***REMOVED***:
    info = np.finfo(np.longcomplex***REMOVED***
    return not np.isfinite(np.log10(info.tiny/info.eps***REMOVED******REMOVED***


class TestComplexFunctions(object***REMOVED***:
    funcs = [np.arcsin,  np.arccos,  np.arctan, np.arcsinh, np.arccosh,
             np.arctanh, np.sin,     np.cos,    np.tan,     np.exp,
             np.exp2,    np.log,     np.sqrt,   np.log10,   np.log2,
             np.log1p***REMOVED***

    def test_it(self***REMOVED***:
        for f in self.funcs:
            if f is np.arccosh:
                x = 1.5
            else:
                x = .5
            fr = f(x***REMOVED***
            fz = f(np.complex(x***REMOVED******REMOVED***
            assert_almost_equal(fz.real, fr, err_msg='real part %s' % f***REMOVED***
            assert_almost_equal(fz.imag, 0., err_msg='imag part %s' % f***REMOVED***

    def test_precisions_consistent(self***REMOVED***:
        z = 1 + 1j
        for f in self.funcs:
            fcf = f(np.csingle(z***REMOVED******REMOVED***
            fcd = f(np.cdouble(z***REMOVED******REMOVED***
            fcl = f(np.clongdouble(z***REMOVED******REMOVED***
            assert_almost_equal(fcf, fcd, decimal=6, err_msg='fch-fcd %s' % f***REMOVED***
            assert_almost_equal(fcl, fcd, decimal=15, err_msg='fch-fcl %s' % f***REMOVED***

    def test_branch_cuts(self***REMOVED***:
        # check branch cuts and continuity on them
        yield _check_branch_cut, np.log,   -0.5, 1j, 1, -1, True
        yield _check_branch_cut, np.log2,  -0.5, 1j, 1, -1, True
        yield _check_branch_cut, np.log10, -0.5, 1j, 1, -1, True
        yield _check_branch_cut, np.log1p, -1.5, 1j, 1, -1, True
        yield _check_branch_cut, np.sqrt,  -0.5, 1j, 1, -1, True

        yield _check_branch_cut, np.arcsin, [ -2, 2***REMOVED***,   [1j, 1j***REMOVED***, 1, -1, True
        yield _check_branch_cut, np.arccos, [ -2, 2***REMOVED***,   [1j, 1j***REMOVED***, 1, -1, True
        yield _check_branch_cut, np.arctan, [0-2j, 2j***REMOVED***,  [1,  1***REMOVED***, -1, 1, True

        yield _check_branch_cut, np.arcsinh, [0-2j,  2j***REMOVED***, [1,   1***REMOVED***, -1, 1, True
        yield _check_branch_cut, np.arccosh, [ -1, 0.5***REMOVED***, [1j,  1j***REMOVED***, 1, -1, True
        yield _check_branch_cut, np.arctanh, [ -2,   2***REMOVED***, [1j, 1j***REMOVED***, 1, -1, True

        # check against bogus branch cuts: assert continuity between quadrants
        yield _check_branch_cut, np.arcsin, [0-2j, 2j***REMOVED***, [ 1,  1***REMOVED***, 1, 1
        yield _check_branch_cut, np.arccos, [0-2j, 2j***REMOVED***, [ 1,  1***REMOVED***, 1, 1
        yield _check_branch_cut, np.arctan, [ -2,  2***REMOVED***, [1j, 1j***REMOVED***, 1, 1

        yield _check_branch_cut, np.arcsinh, [ -2,  2, 0***REMOVED***, [1j, 1j, 1***REMOVED***, 1, 1
        yield _check_branch_cut, np.arccosh, [0-2j, 2j, 2***REMOVED***, [1,  1,  1j***REMOVED***, 1, 1
        yield _check_branch_cut, np.arctanh, [0-2j, 2j, 0***REMOVED***, [1,  1,  1j***REMOVED***, 1, 1

    def test_branch_cuts_complex64(self***REMOVED***:
        # check branch cuts and continuity on them
        yield _check_branch_cut, np.log,   -0.5, 1j, 1, -1, True, np.complex64
        yield _check_branch_cut, np.log2,  -0.5, 1j, 1, -1, True, np.complex64
        yield _check_branch_cut, np.log10, -0.5, 1j, 1, -1, True, np.complex64
        yield _check_branch_cut, np.log1p, -1.5, 1j, 1, -1, True, np.complex64
        yield _check_branch_cut, np.sqrt,  -0.5, 1j, 1, -1, True, np.complex64

        yield _check_branch_cut, np.arcsin, [ -2, 2***REMOVED***,   [1j, 1j***REMOVED***, 1, -1, True, np.complex64
        yield _check_branch_cut, np.arccos, [ -2, 2***REMOVED***,   [1j, 1j***REMOVED***, 1, -1, True, np.complex64
        yield _check_branch_cut, np.arctan, [0-2j, 2j***REMOVED***,  [1,  1***REMOVED***, -1, 1, True, np.complex64

        yield _check_branch_cut, np.arcsinh, [0-2j,  2j***REMOVED***, [1,   1***REMOVED***, -1, 1, True, np.complex64
        yield _check_branch_cut, np.arccosh, [ -1, 0.5***REMOVED***, [1j,  1j***REMOVED***, 1, -1, True, np.complex64
        yield _check_branch_cut, np.arctanh, [ -2,   2***REMOVED***, [1j, 1j***REMOVED***, 1, -1, True, np.complex64

        # check against bogus branch cuts: assert continuity between quadrants
        yield _check_branch_cut, np.arcsin, [0-2j, 2j***REMOVED***, [ 1,  1***REMOVED***, 1, 1, False, np.complex64
        yield _check_branch_cut, np.arccos, [0-2j, 2j***REMOVED***, [ 1,  1***REMOVED***, 1, 1, False, np.complex64
        yield _check_branch_cut, np.arctan, [ -2,  2***REMOVED***, [1j, 1j***REMOVED***, 1, 1, False, np.complex64

        yield _check_branch_cut, np.arcsinh, [ -2,  2, 0***REMOVED***, [1j, 1j, 1***REMOVED***, 1, 1, False, np.complex64
        yield _check_branch_cut, np.arccosh, [0-2j, 2j, 2***REMOVED***, [1,  1,  1j***REMOVED***, 1, 1, False, np.complex64
        yield _check_branch_cut, np.arctanh, [0-2j, 2j, 0***REMOVED***, [1,  1,  1j***REMOVED***, 1, 1, False, np.complex64

    def test_against_cmath(self***REMOVED***:
        import cmath

        points = [-1-1j, -1+1j, +1-1j, +1+1j***REMOVED***
        name_map = {'arcsin': 'asin', 'arccos': 'acos', 'arctan': 'atan',
                    'arcsinh': 'asinh', 'arccosh': 'acosh', 'arctanh': 'atanh'***REMOVED***
        atol = 4*np.finfo(np.complex***REMOVED***.eps
        for func in self.funcs:
            fname = func.__name__.split('.'***REMOVED***[-1***REMOVED***
            cname = name_map.get(fname, fname***REMOVED***
            ***REMOVED***
                cfunc = getattr(cmath, cname***REMOVED***
            except AttributeError:
                continue
            for p in points:
                a = complex(func(np.complex_(p***REMOVED******REMOVED******REMOVED***
                b = cfunc(p***REMOVED***
                assert_(abs(a - b***REMOVED*** < atol, "%s %s: %s; cmath: %s" % (fname, p, a, b***REMOVED******REMOVED***

    def check_loss_of_precision(self, dtype***REMOVED***:
        ***REMOVED***Check loss of precision in complex arc* functions***REMOVED***

        # Check against known-good functions

        info = np.finfo(dtype***REMOVED***
        real_dtype = dtype(0.***REMOVED***.real.dtype
        eps = info.eps

        def check(x, rtol***REMOVED***:
            x = x.astype(real_dtype***REMOVED***

            z = x.astype(dtype***REMOVED***
            d = np.absolute(np.arcsinh(x***REMOVED***/np.arcsinh(z***REMOVED***.real - 1***REMOVED***
            assert_(np.all(d < rtol***REMOVED***, (np.argmax(d***REMOVED***, x[np.argmax(d***REMOVED******REMOVED***, d.max(***REMOVED***,
                                      'arcsinh'***REMOVED******REMOVED***

            z = (1j*x***REMOVED***.astype(dtype***REMOVED***
            d = np.absolute(np.arcsinh(x***REMOVED***/np.arcsin(z***REMOVED***.imag - 1***REMOVED***
            assert_(np.all(d < rtol***REMOVED***, (np.argmax(d***REMOVED***, x[np.argmax(d***REMOVED******REMOVED***, d.max(***REMOVED***,
                                      'arcsin'***REMOVED******REMOVED***

            z = x.astype(dtype***REMOVED***
            d = np.absolute(np.arctanh(x***REMOVED***/np.arctanh(z***REMOVED***.real - 1***REMOVED***
            assert_(np.all(d < rtol***REMOVED***, (np.argmax(d***REMOVED***, x[np.argmax(d***REMOVED******REMOVED***, d.max(***REMOVED***,
                                      'arctanh'***REMOVED******REMOVED***

            z = (1j*x***REMOVED***.astype(dtype***REMOVED***
            d = np.absolute(np.arctanh(x***REMOVED***/np.arctan(z***REMOVED***.imag - 1***REMOVED***
            assert_(np.all(d < rtol***REMOVED***, (np.argmax(d***REMOVED***, x[np.argmax(d***REMOVED******REMOVED***, d.max(***REMOVED***,
                                      'arctan'***REMOVED******REMOVED***

        # The switchover was chosen as 1e-3; hence there can be up to
        # ~eps/1e-3 of relative cancellation error before it

        x_series = np.logspace(-20, -3.001, 200***REMOVED***
        x_basic = np.logspace(-2.999, 0, 10, endpoint=False***REMOVED***

        if dtype is np.longcomplex:
            # It's not guaranteed that the system-provided arc functions
            # are accurate down to a few epsilons. (Eg. on Linux 64-bit***REMOVED***
            # So, give more leeway for long complex tests here:
            check(x_series, 50*eps***REMOVED***
        else:
            check(x_series, 2.1*eps***REMOVED***
        check(x_basic, 2*eps/1e-3***REMOVED***

        # Check a few points

        z = np.array([1e-5*(1+1j***REMOVED******REMOVED***, dtype=dtype***REMOVED***
        p = 9.999999999333333333e-6 + 1.000000000066666666e-5j
        d = np.absolute(1-np.arctanh(z***REMOVED***/p***REMOVED***
        assert_(np.all(d < 1e-15***REMOVED******REMOVED***

        p = 1.0000000000333333333e-5 + 9.999999999666666667e-6j
        d = np.absolute(1-np.arcsinh(z***REMOVED***/p***REMOVED***
        assert_(np.all(d < 1e-15***REMOVED******REMOVED***

        p = 9.999999999333333333e-6j + 1.000000000066666666e-5
        d = np.absolute(1-np.arctan(z***REMOVED***/p***REMOVED***
        assert_(np.all(d < 1e-15***REMOVED******REMOVED***

        p = 1.0000000000333333333e-5j + 9.999999999666666667e-6
        d = np.absolute(1-np.arcsin(z***REMOVED***/p***REMOVED***
        assert_(np.all(d < 1e-15***REMOVED******REMOVED***

        # Check continuity across switchover points

        def check(func, z0, d=1***REMOVED***:
            z0 = np.asarray(z0, dtype=dtype***REMOVED***
            zp = z0 + abs(z0***REMOVED*** * d * eps * 2
            zm = z0 - abs(z0***REMOVED*** * d * eps * 2
            assert_(np.all(zp != zm***REMOVED***, (zp, zm***REMOVED******REMOVED***

            # NB: the cancellation error at the switchover is at least eps
            good = (abs(func(zp***REMOVED*** - func(zm***REMOVED******REMOVED*** < 2*eps***REMOVED***
            assert_(np.all(good***REMOVED***, (func, z0[~good***REMOVED******REMOVED******REMOVED***

        for func in (np.arcsinh, np.arcsinh, np.arcsin, np.arctanh, np.arctan***REMOVED***:
            pts = [rp+1j*ip for rp in (-1e-3, 0, 1e-3***REMOVED*** for ip in(-1e-3, 0, 1e-3***REMOVED***
                   if rp != 0 or ip != 0***REMOVED***
            check(func, pts, 1***REMOVED***
            check(func, pts, 1j***REMOVED***
            check(func, pts, 1+1j***REMOVED***

    def test_loss_of_precision(self***REMOVED***:
        for dtype in [np.complex64, np.complex_***REMOVED***:
            yield self.check_loss_of_precision, dtype

    @dec.knownfailureif(is_longdouble_finfo_bogus(***REMOVED***, "Bogus long double finfo"***REMOVED***
    def test_loss_of_precision_longcomplex(self***REMOVED***:
        self.check_loss_of_precision(np.longcomplex***REMOVED***


class TestAttributes(TestCase***REMOVED***:
    def test_attributes(self***REMOVED***:
        add = ncu.add
        assert_equal(add.__name__, 'add'***REMOVED***
        assert_(add.__doc__.startswith('add(x1, x2[, out***REMOVED******REMOVED***\n\n'***REMOVED******REMOVED***
        self.assertTrue(add.ntypes >= 18***REMOVED***  # don't fail if types added
        self.assertTrue('ii->i' in add.types***REMOVED***
        assert_equal(add.nin, 2***REMOVED***
        assert_equal(add.nout, 1***REMOVED***
        assert_equal(add.identity, 0***REMOVED***


class TestSubclass(TestCase***REMOVED***:

    def test_subclass_op(self***REMOVED***:

        class simple(np.ndarray***REMOVED***:
            def __new__(subtype, shape***REMOVED***:
                self = np.ndarray.__new__(subtype, shape, dtype=object***REMOVED***
                self.fill(0***REMOVED***
                return self

        a = simple((3, 4***REMOVED******REMOVED***
        assert_equal(a+a, a***REMOVED***

def _check_branch_cut(f, x0, dx, re_sign=1, im_sign=-1, sig_zero_ok=False,
                      dtype=np.complex***REMOVED***:
    ***REMOVED***
    Check for a branch cut in a function.

    Assert that `x0` lies on a branch cut of function `f` and `f` is
    continuous from the direction `dx`.

    Parameters
    ----------
    f : func
        Function to check
    x0 : array-like
        Point on branch cut
    dx : array-like
        Direction to check continuity in
    re_sign, im_sign : {1, -1***REMOVED***
        Change of sign of the real or imaginary part expected
    sig_zero_ok : bool
        Whether to check if the branch cut respects signed zero (if applicable***REMOVED***
    dtype : dtype
        Dtype to check (should be complex***REMOVED***

    ***REMOVED***
    x0 = np.atleast_1d(x0***REMOVED***.astype(dtype***REMOVED***
    dx = np.atleast_1d(dx***REMOVED***.astype(dtype***REMOVED***

    if np.dtype(dtype***REMOVED***.char == 'F':
        scale = np.finfo(dtype***REMOVED***.eps * 1e2
        atol = np.float32(1e-2***REMOVED***
    else:
        scale = np.finfo(dtype***REMOVED***.eps * 1e3
        atol = 1e-4

    y0 = f(x0***REMOVED***
    yp = f(x0 + dx*scale*np.absolute(x0***REMOVED***/np.absolute(dx***REMOVED******REMOVED***
    ym = f(x0 - dx*scale*np.absolute(x0***REMOVED***/np.absolute(dx***REMOVED******REMOVED***

    assert_(np.all(np.absolute(y0.real - yp.real***REMOVED*** < atol***REMOVED***, (y0, yp***REMOVED******REMOVED***
    assert_(np.all(np.absolute(y0.imag - yp.imag***REMOVED*** < atol***REMOVED***, (y0, yp***REMOVED******REMOVED***
    assert_(np.all(np.absolute(y0.real - ym.real*re_sign***REMOVED*** < atol***REMOVED***, (y0, ym***REMOVED******REMOVED***
    assert_(np.all(np.absolute(y0.imag - ym.imag*im_sign***REMOVED*** < atol***REMOVED***, (y0, ym***REMOVED******REMOVED***

    if sig_zero_ok:
        # check that signed zeros also work as a displacement
        jr = (x0.real == 0***REMOVED*** & (dx.real != 0***REMOVED***
        ji = (x0.imag == 0***REMOVED*** & (dx.imag != 0***REMOVED***
        if np.any(jr***REMOVED***:
            x = x0[jr***REMOVED***
            x.real = np.NZERO
            ym = f(x***REMOVED***
            assert_(np.all(np.absolute(y0[jr***REMOVED***.real - ym.real*re_sign***REMOVED*** < atol***REMOVED***, (y0[jr***REMOVED***, ym***REMOVED******REMOVED***
            assert_(np.all(np.absolute(y0[jr***REMOVED***.imag - ym.imag*im_sign***REMOVED*** < atol***REMOVED***, (y0[jr***REMOVED***, ym***REMOVED******REMOVED***

        if np.any(ji***REMOVED***:
            x = x0[ji***REMOVED***
            x.imag = np.NZERO
            ym = f(x***REMOVED***
            assert_(np.all(np.absolute(y0[ji***REMOVED***.real - ym.real*re_sign***REMOVED*** < atol***REMOVED***, (y0[ji***REMOVED***, ym***REMOVED******REMOVED***
            assert_(np.all(np.absolute(y0[ji***REMOVED***.imag - ym.imag*im_sign***REMOVED*** < atol***REMOVED***, (y0[ji***REMOVED***, ym***REMOVED******REMOVED***

def test_copysign(***REMOVED***:
    assert_(np.copysign(1, -1***REMOVED*** == -1***REMOVED***
    with np.errstate(divide="ignore"***REMOVED***:
        assert_(1 / np.copysign(0, -1***REMOVED*** < 0***REMOVED***
        assert_(1 / np.copysign(0, 1***REMOVED*** > 0***REMOVED***
    assert_(np.signbit(np.copysign(np.nan, -1***REMOVED******REMOVED******REMOVED***
    assert_(not np.signbit(np.copysign(np.nan, 1***REMOVED******REMOVED******REMOVED***

def _test_nextafter(t***REMOVED***:
    one = t(1***REMOVED***
    two = t(2***REMOVED***
    zero = t(0***REMOVED***
    eps = np.finfo(t***REMOVED***.eps
    assert_(np.nextafter(one, two***REMOVED*** - one == eps***REMOVED***
    assert_(np.nextafter(one, zero***REMOVED*** - one < 0***REMOVED***
    assert_(np.isnan(np.nextafter(np.nan, one***REMOVED******REMOVED******REMOVED***
    assert_(np.isnan(np.nextafter(one, np.nan***REMOVED******REMOVED******REMOVED***
    assert_(np.nextafter(one, one***REMOVED*** == one***REMOVED***

def test_nextafter(***REMOVED***:
    return _test_nextafter(np.float64***REMOVED***

def test_nextafterf(***REMOVED***:
    return _test_nextafter(np.float32***REMOVED***

@dec.knownfailureif(sys.platform == 'win32' or on_powerpc(***REMOVED***,
            "Long double support buggy on win32 and PPC, ticket 1664."***REMOVED***
def test_nextafterl(***REMOVED***:
    return _test_nextafter(np.longdouble***REMOVED***

def _test_spacing(t***REMOVED***:
    one = t(1***REMOVED***
    eps = np.finfo(t***REMOVED***.eps
    nan = t(np.nan***REMOVED***
    inf = t(np.inf***REMOVED***
    with np.errstate(invalid='ignore'***REMOVED***:
        assert_(np.spacing(one***REMOVED*** == eps***REMOVED***
        assert_(np.isnan(np.spacing(nan***REMOVED******REMOVED******REMOVED***
        assert_(np.isnan(np.spacing(inf***REMOVED******REMOVED******REMOVED***
        assert_(np.isnan(np.spacing(-inf***REMOVED******REMOVED******REMOVED***
        assert_(np.spacing(t(1e30***REMOVED******REMOVED*** != 0***REMOVED***

def test_spacing(***REMOVED***:
    return _test_spacing(np.float64***REMOVED***

def test_spacingf(***REMOVED***:
    return _test_spacing(np.float32***REMOVED***

@dec.knownfailureif(sys.platform == 'win32' or on_powerpc(***REMOVED***,
            "Long double support buggy on win32 and PPC, ticket 1664."***REMOVED***
def test_spacingl(***REMOVED***:
    return _test_spacing(np.longdouble***REMOVED***

def test_spacing_gfortran(***REMOVED***:
    # Reference from this fortran file, built with gfortran 4.3.3 on linux
    # 32bits:
    #       PROGRAM test_spacing
    #        INTEGER, PARAMETER :: SGL = SELECTED_REAL_KIND(p=6, r=37***REMOVED***
    #        INTEGER, PARAMETER :: DBL = SELECTED_REAL_KIND(p=13, r=200***REMOVED***
    #
    #        WRITE(*,****REMOVED*** spacing(0.00001_DBL***REMOVED***
    #        WRITE(*,****REMOVED*** spacing(1.0_DBL***REMOVED***
    #        WRITE(*,****REMOVED*** spacing(1000._DBL***REMOVED***
    #        WRITE(*,****REMOVED*** spacing(10500._DBL***REMOVED***
    #
    #        WRITE(*,****REMOVED*** spacing(0.00001_SGL***REMOVED***
    #        WRITE(*,****REMOVED*** spacing(1.0_SGL***REMOVED***
    #        WRITE(*,****REMOVED*** spacing(1000._SGL***REMOVED***
    #        WRITE(*,****REMOVED*** spacing(10500._SGL***REMOVED***
    #       END PROGRAM
    ref = {np.float64: [1.69406589450860068E-021,
                        2.22044604925031308E-016,
                        1.13686837721616030E-013,
                        1.81898940354585648E-012***REMOVED***,
           np.float32: [9.09494702E-13,
                        1.19209290E-07,
                        6.10351563E-05,
                        9.76562500E-04***REMOVED******REMOVED***

    for dt, dec_ in zip([np.float32, np.float64***REMOVED***, (10, 20***REMOVED******REMOVED***:
        x = np.array([1e-5, 1, 1000, 10500***REMOVED***, dtype=dt***REMOVED***
        assert_array_almost_equal(np.spacing(x***REMOVED***, ref[dt***REMOVED***, decimal=dec_***REMOVED***

def test_nextafter_vs_spacing(***REMOVED***:
    # XXX: spacing does not handle long double yet
    for t in [np.float32, np.float64***REMOVED***:
        for _f in [1, 1e-5, 1000***REMOVED***:
            f = t(_f***REMOVED***
            f1 = t(_f + 1***REMOVED***
            assert_(np.nextafter(f, f1***REMOVED*** - f == np.spacing(f***REMOVED******REMOVED***

def test_pos_nan(***REMOVED***:
    ***REMOVED***Check np.nan is a positive nan.***REMOVED***
    assert_(np.signbit(np.nan***REMOVED*** == 0***REMOVED***

def test_reduceat(***REMOVED***:
    ***REMOVED***Test bug in reduceat when structured arrays are not copied.***REMOVED***
    db = np.dtype([('name', 'S11'***REMOVED***, ('time', np.int64***REMOVED***, ('value', np.float32***REMOVED******REMOVED******REMOVED***
    a = np.empty([100***REMOVED***, dtype=db***REMOVED***
    a['name'***REMOVED*** = 'Simple'
    a['time'***REMOVED*** = 10
    a['value'***REMOVED*** = 100
    indx = [0, 7, 15, 25***REMOVED***

    h2 = [***REMOVED***
    val1 = indx[0***REMOVED***
    for val2 in indx[1:***REMOVED***:
        h2.append(np.add.reduce(a['value'***REMOVED***[val1:val2***REMOVED******REMOVED******REMOVED***
        val1 = val2
    h2.append(np.add.reduce(a['value'***REMOVED***[val1:***REMOVED******REMOVED******REMOVED***
    h2 = np.array(h2***REMOVED***

    # test buffered -- this should work
    h1 = np.add.reduceat(a['value'***REMOVED***, indx***REMOVED***
    assert_array_almost_equal(h1, h2***REMOVED***

    # This is when the error occurs.
    # test no buffer
    np.setbufsize(32***REMOVED***
    h1 = np.add.reduceat(a['value'***REMOVED***, indx***REMOVED***
    np.setbufsize(np.UFUNC_BUFSIZE_DEFAULT***REMOVED***
    assert_array_almost_equal(h1, h2***REMOVED***

def test_reduceat_empty(***REMOVED***:
    ***REMOVED***Reduceat should work with empty arrays***REMOVED***
    indices = np.array([***REMOVED***, 'i4'***REMOVED***
    x = np.array([***REMOVED***, 'f8'***REMOVED***
    result = np.add.reduceat(x, indices***REMOVED***
    assert_equal(result.dtype, x.dtype***REMOVED***
    assert_equal(result.shape, (0,***REMOVED******REMOVED***
    # Another case with a slightly different zero-sized shape
    x = np.ones((5, 2***REMOVED******REMOVED***
    result = np.add.reduceat(x, [***REMOVED***, axis=0***REMOVED***
    assert_equal(result.dtype, x.dtype***REMOVED***
    assert_equal(result.shape, (0, 2***REMOVED******REMOVED***
    result = np.add.reduceat(x, [***REMOVED***, axis=1***REMOVED***
    assert_equal(result.dtype, x.dtype***REMOVED***
    assert_equal(result.shape, (5, 0***REMOVED******REMOVED***

def test_complex_nan_comparisons(***REMOVED***:
    nans = [complex(np.nan, 0***REMOVED***, complex(0, np.nan***REMOVED***, complex(np.nan, np.nan***REMOVED******REMOVED***
    fins = [complex(1, 0***REMOVED***, complex(-1, 0***REMOVED***, complex(0, 1***REMOVED***, complex(0, -1***REMOVED***,
            complex(1, 1***REMOVED***, complex(-1, -1***REMOVED***, complex(0, 0***REMOVED******REMOVED***

    with np.errstate(invalid='ignore'***REMOVED***:
        for x in nans + fins:
            x = np.array([x***REMOVED******REMOVED***
            for y in nans + fins:
                y = np.array([y***REMOVED******REMOVED***

                if np.isfinite(x***REMOVED*** and np.isfinite(y***REMOVED***:
                    continue

                assert_equal(x < y, False, err_msg="%r < %r" % (x, y***REMOVED******REMOVED***
                assert_equal(x > y, False, err_msg="%r > %r" % (x, y***REMOVED******REMOVED***
                assert_equal(x <= y, False, err_msg="%r <= %r" % (x, y***REMOVED******REMOVED***
                assert_equal(x >= y, False, err_msg="%r >= %r" % (x, y***REMOVED******REMOVED***
                assert_equal(x == y, False, err_msg="%r == %r" % (x, y***REMOVED******REMOVED***


def test_rint_big_int(***REMOVED***:
    # np.rint bug for large integer values on Windows 32-bit and MKL
    # https://github.com/numpy/numpy/issues/6685
    val = 4607998452777363968
    # This is exactly representable in floating point
    assert_equal(val, int(float(val***REMOVED******REMOVED******REMOVED***
    # Rint should not change the value
    assert_equal(val, np.rint(val***REMOVED******REMOVED***


if __name__ == "__main__":
    run_module_suite(***REMOVED***
