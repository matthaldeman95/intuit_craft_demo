from __future__ import division, absolute_import, print_function

import numpy as np
import numpy.core.umath_tests as umt
import numpy.core.operand_flag_tests as opflag_tests
from numpy.compat import asbytes
from numpy.core.test_rational import rational, test_add, test_add_rationals
from numpy.testing import (
    TestCase, run_module_suite, assert_, assert_equal, assert_raises,
    assert_array_equal, assert_almost_equal, assert_array_almost_equal,
    assert_no_warnings
***REMOVED***


class TestUfuncKwargs(TestCase***REMOVED***:
    def test_kwarg_exact(self***REMOVED***:
        assert_raises(TypeError, np.add, 1, 2, castingx='safe'***REMOVED***
        assert_raises(TypeError, np.add, 1, 2, dtypex=np.int***REMOVED***
        assert_raises(TypeError, np.add, 1, 2, extobjx=[4096***REMOVED******REMOVED***
        assert_raises(TypeError, np.add, 1, 2, outx=None***REMOVED***
        assert_raises(TypeError, np.add, 1, 2, sigx='ii->i'***REMOVED***
        assert_raises(TypeError, np.add, 1, 2, signaturex='ii->i'***REMOVED***
        assert_raises(TypeError, np.add, 1, 2, subokx=False***REMOVED***
        assert_raises(TypeError, np.add, 1, 2, wherex=[True***REMOVED******REMOVED***

    def test_sig_signature(self***REMOVED***:
        assert_raises(ValueError, np.add, 1, 2, sig='ii->i',
                      signature='ii->i'***REMOVED***

    def test_sig_dtype(self***REMOVED***:
        assert_raises(RuntimeError, np.add, 1, 2, sig='ii->i',
                      dtype=np.int***REMOVED***
        assert_raises(RuntimeError, np.add, 1, 2, signature='ii->i',
                      dtype=np.int***REMOVED***


class TestUfunc(TestCase***REMOVED***:
    def test_pickle(self***REMOVED***:
        import pickle
        assert_(pickle.loads(pickle.dumps(np.sin***REMOVED******REMOVED*** is np.sin***REMOVED***

        # Check that ufunc not defined in the top level numpy namespace such as
        # numpy.core.test_rational.test_add can also be pickled
        assert_(pickle.loads(pickle.dumps(test_add***REMOVED******REMOVED*** is test_add***REMOVED***

    def test_pickle_withstring(self***REMOVED***:
        import pickle
        astring = asbytes("cnumpy.core\n_ufunc_reconstruct\np0\n"
                "(S'numpy.core.umath'\np1\nS'cos'\np2\ntp3\nRp4\n."***REMOVED***
        assert_(pickle.loads(astring***REMOVED*** is np.cos***REMOVED***

    def test_reduceat_shifting_sum(self***REMOVED***:
        L = 6
        x = np.arange(L***REMOVED***
        idx = np.array(list(zip(np.arange(L - 2***REMOVED***, np.arange(L - 2***REMOVED*** + 2***REMOVED******REMOVED******REMOVED***.ravel(***REMOVED***
        assert_array_equal(np.add.reduceat(x, idx***REMOVED***[::2***REMOVED***, [1, 3, 5, 7***REMOVED******REMOVED***

    def test_generic_loops(self***REMOVED***:
        ***REMOVED***Test generic loops.

        The loops to be tested are:

            PyUFunc_ff_f_As_dd_d
            PyUFunc_ff_f
            PyUFunc_dd_d
            PyUFunc_gg_g
            PyUFunc_FF_F_As_DD_D
            PyUFunc_DD_D
            PyUFunc_FF_F
            PyUFunc_GG_G
            PyUFunc_OO_O
            PyUFunc_OO_O_method
            PyUFunc_f_f_As_d_d
            PyUFunc_d_d
            PyUFunc_f_f
            PyUFunc_g_g
            PyUFunc_F_F_As_D_D
            PyUFunc_F_F
            PyUFunc_D_D
            PyUFunc_G_G
            PyUFunc_O_O
            PyUFunc_O_O_method
            PyUFunc_On_Om

        Where:

            f -- float
            d -- double
            g -- long double
            F -- complex float
            D -- complex double
            G -- complex long double
            O -- python object

        It is difficult to assure that each of these loops is entered from the
        Python level as the special cased loops are a moving target and the
        corresponding types are architecture dependent. We probably need to
        define C level testing ufuncs to get at them. For the time being, I've
        just looked at the signatures registered in the build directory to find
        relevant functions.

        Fixme, currently untested:

            PyUFunc_ff_f_As_dd_d
            PyUFunc_FF_F_As_DD_D
            PyUFunc_f_f_As_d_d
            PyUFunc_F_F_As_D_D
            PyUFunc_On_Om

        ***REMOVED***
        fone = np.exp
        ftwo = lambda x, y: x**y
        fone_val = 1
        ftwo_val = 1
        # check unary PyUFunc_f_f.
        msg = "PyUFunc_f_f"
        x = np.zeros(10, dtype=np.single***REMOVED***[0::2***REMOVED***
        assert_almost_equal(fone(x***REMOVED***, fone_val, err_msg=msg***REMOVED***
        # check unary PyUFunc_d_d.
        msg = "PyUFunc_d_d"
        x = np.zeros(10, dtype=np.double***REMOVED***[0::2***REMOVED***
        assert_almost_equal(fone(x***REMOVED***, fone_val, err_msg=msg***REMOVED***
        # check unary PyUFunc_g_g.
        msg = "PyUFunc_g_g"
        x = np.zeros(10, dtype=np.longdouble***REMOVED***[0::2***REMOVED***
        assert_almost_equal(fone(x***REMOVED***, fone_val, err_msg=msg***REMOVED***
        # check unary PyUFunc_F_F.
        msg = "PyUFunc_F_F"
        x = np.zeros(10, dtype=np.csingle***REMOVED***[0::2***REMOVED***
        assert_almost_equal(fone(x***REMOVED***, fone_val, err_msg=msg***REMOVED***
        # check unary PyUFunc_D_D.
        msg = "PyUFunc_D_D"
        x = np.zeros(10, dtype=np.cdouble***REMOVED***[0::2***REMOVED***
        assert_almost_equal(fone(x***REMOVED***, fone_val, err_msg=msg***REMOVED***
        # check unary PyUFunc_G_G.
        msg = "PyUFunc_G_G"
        x = np.zeros(10, dtype=np.clongdouble***REMOVED***[0::2***REMOVED***
        assert_almost_equal(fone(x***REMOVED***, fone_val, err_msg=msg***REMOVED***

        # check binary PyUFunc_ff_f.
        msg = "PyUFunc_ff_f"
        x = np.ones(10, dtype=np.single***REMOVED***[0::2***REMOVED***
        assert_almost_equal(ftwo(x, x***REMOVED***, ftwo_val, err_msg=msg***REMOVED***
        # check binary PyUFunc_dd_d.
        msg = "PyUFunc_dd_d"
        x = np.ones(10, dtype=np.double***REMOVED***[0::2***REMOVED***
        assert_almost_equal(ftwo(x, x***REMOVED***, ftwo_val, err_msg=msg***REMOVED***
        # check binary PyUFunc_gg_g.
        msg = "PyUFunc_gg_g"
        x = np.ones(10, dtype=np.longdouble***REMOVED***[0::2***REMOVED***
        assert_almost_equal(ftwo(x, x***REMOVED***, ftwo_val, err_msg=msg***REMOVED***
        # check binary PyUFunc_FF_F.
        msg = "PyUFunc_FF_F"
        x = np.ones(10, dtype=np.csingle***REMOVED***[0::2***REMOVED***
        assert_almost_equal(ftwo(x, x***REMOVED***, ftwo_val, err_msg=msg***REMOVED***
        # check binary PyUFunc_DD_D.
        msg = "PyUFunc_DD_D"
        x = np.ones(10, dtype=np.cdouble***REMOVED***[0::2***REMOVED***
        assert_almost_equal(ftwo(x, x***REMOVED***, ftwo_val, err_msg=msg***REMOVED***
        # check binary PyUFunc_GG_G.
        msg = "PyUFunc_GG_G"
        x = np.ones(10, dtype=np.clongdouble***REMOVED***[0::2***REMOVED***
        assert_almost_equal(ftwo(x, x***REMOVED***, ftwo_val, err_msg=msg***REMOVED***

        # class to use in testing object method loops
        class foo(object***REMOVED***:
            def conjugate(self***REMOVED***:
                return np.bool_(1***REMOVED***

            def logical_xor(self, obj***REMOVED***:
                return np.bool_(1***REMOVED***

        # check unary PyUFunc_O_O
        msg = "PyUFunc_O_O"
        x = np.ones(10, dtype=np.object***REMOVED***[0::2***REMOVED***
        assert_(np.all(np.abs(x***REMOVED*** == 1***REMOVED***, msg***REMOVED***
        # check unary PyUFunc_O_O_method
        msg = "PyUFunc_O_O_method"
        x = np.zeros(10, dtype=np.object***REMOVED***[0::2***REMOVED***
        for i in range(len(x***REMOVED******REMOVED***:
            x[i***REMOVED*** = foo(***REMOVED***
        assert_(np.all(np.conjugate(x***REMOVED*** == True***REMOVED***, msg***REMOVED***

        # check binary PyUFunc_OO_O
        msg = "PyUFunc_OO_O"
        x = np.ones(10, dtype=np.object***REMOVED***[0::2***REMOVED***
        assert_(np.all(np.add(x, x***REMOVED*** == 2***REMOVED***, msg***REMOVED***
        # check binary PyUFunc_OO_O_method
        msg = "PyUFunc_OO_O_method"
        x = np.zeros(10, dtype=np.object***REMOVED***[0::2***REMOVED***
        for i in range(len(x***REMOVED******REMOVED***:
            x[i***REMOVED*** = foo(***REMOVED***
        assert_(np.all(np.logical_xor(x, x***REMOVED******REMOVED***, msg***REMOVED***

        # check PyUFunc_On_Om
        # fixme -- I don't know how to do this yet

    def test_all_ufunc(self***REMOVED***:
        ***REMOVED***Try to check presence and results of all ufuncs.

        The list of ufuncs comes from generate_umath.py and is as follows:

        =====  ====  =============  ===============  ========================
        done   args   function        types                notes
        =====  ====  =============  ===============  ========================
        n      1     conjugate      nums + O
        n      1     absolute       nums + O         complex -> real
        n      1     negative       nums + O
        n      1     sign           nums + O         -> int
        n      1     invert         bool + ints + O  flts raise an error
        n      1     degrees        real + M         cmplx raise an error
        n      1     radians        real + M         cmplx raise an error
        n      1     arccos         flts + M
        n      1     arccosh        flts + M
        n      1     arcsin         flts + M
        n      1     arcsinh        flts + M
        n      1     arctan         flts + M
        n      1     arctanh        flts + M
        n      1     cos            flts + M
        n      1     sin            flts + M
        n      1     tan            flts + M
        n      1     cosh           flts + M
        n      1     sinh           flts + M
        n      1     tanh           flts + M
        n      1     exp            flts + M
        n      1     expm1          flts + M
        n      1     log            flts + M
        n      1     log10          flts + M
        n      1     log1p          flts + M
        n      1     sqrt           flts + M         real x < 0 raises error
        n      1     ceil           real + M
        n      1     trunc          real + M
        n      1     floor          real + M
        n      1     fabs           real + M
        n      1     rint           flts + M
        n      1     isnan          flts             -> bool
        n      1     isinf          flts             -> bool
        n      1     isfinite       flts             -> bool
        n      1     signbit        real             -> bool
        n      1     modf           real             -> (frac, int***REMOVED***
        n      1     logical_not    bool + nums + M  -> bool
        n      2     left_shift     ints + O         flts raise an error
        n      2     right_shift    ints + O         flts raise an error
        n      2     add            bool + nums + O  boolean + is ||
        n      2     subtract       bool + nums + O  boolean - is ^
        n      2     multiply       bool + nums + O  boolean * is &
        n      2     divide         nums + O
        n      2     floor_divide   nums + O
        n      2     true_divide    nums + O         bBhH -> f, iIlLqQ -> d
        n      2     fmod           nums + M
        n      2     power          nums + O
        n      2     greater        bool + nums + O  -> bool
        n      2     greater_equal  bool + nums + O  -> bool
        n      2     less           bool + nums + O  -> bool
        n      2     less_equal     bool + nums + O  -> bool
        n      2     equal          bool + nums + O  -> bool
        n      2     not_equal      bool + nums + O  -> bool
        n      2     logical_and    bool + nums + M  -> bool
        n      2     logical_or     bool + nums + M  -> bool
        n      2     logical_xor    bool + nums + M  -> bool
        n      2     maximum        bool + nums + O
        n      2     minimum        bool + nums + O
        n      2     bitwise_and    bool + ints + O  flts raise an error
        n      2     bitwise_or     bool + ints + O  flts raise an error
        n      2     bitwise_xor    bool + ints + O  flts raise an error
        n      2     arctan2        real + M
        n      2     remainder      ints + real + O
        n      2     hypot          real + M
        =====  ====  =============  ===============  ========================

        Types other than those listed will be accepted, but they are cast to
        the smallest compatible type for which the function is defined. The
        casting rules are:

        bool -> int8 -> float32
        ints -> double

        ***REMOVED***
        pass

    def test_signature(self***REMOVED***:
        # the arguments to test_signature are: nin, nout, core_signature
        # pass
        assert_equal(umt.test_signature(2, 1, "(i***REMOVED***,(i***REMOVED***->(***REMOVED***"***REMOVED***, 1***REMOVED***

        # pass. empty core signature; treat as plain ufunc (with trivial core***REMOVED***
        assert_equal(umt.test_signature(2, 1, "(***REMOVED***,(***REMOVED***->(***REMOVED***"***REMOVED***, 0***REMOVED***

        # in the following calls, a ValueError should be raised because
        # of error in core signature
        # FIXME These should be using assert_raises

        # error: extra parenthesis
        msg = "core_sig: extra parenthesis"
        ***REMOVED***
            ret = umt.test_signature(2, 1, "((i***REMOVED******REMOVED***,(i***REMOVED***->(***REMOVED***"***REMOVED***
            assert_equal(ret, None, err_msg=msg***REMOVED***
        except ValueError:
            pass

        # error: parenthesis matching
        msg = "core_sig: parenthesis matching"
        ***REMOVED***
            ret = umt.test_signature(2, 1, "(i***REMOVED***,***REMOVED***i(->(***REMOVED***"***REMOVED***
            assert_equal(ret, None, err_msg=msg***REMOVED***
        except ValueError:
            pass

        # error: incomplete signature. letters outside of parenthesis are ignored
        msg = "core_sig: incomplete signature"
        ***REMOVED***
            ret = umt.test_signature(2, 1, "(i***REMOVED***,->(***REMOVED***"***REMOVED***
            assert_equal(ret, None, err_msg=msg***REMOVED***
        except ValueError:
            pass

        # error: incomplete signature. 2 output arguments are specified
        msg = "core_sig: incomplete signature"
        ***REMOVED***
            ret = umt.test_signature(2, 2, "(i***REMOVED***,(i***REMOVED***->(***REMOVED***"***REMOVED***
            assert_equal(ret, None, err_msg=msg***REMOVED***
        except ValueError:
            pass

        # more complicated names for variables
        assert_equal(umt.test_signature(2, 1, "(i1,i2***REMOVED***,(J_1***REMOVED***->(_kAB***REMOVED***"***REMOVED***, 1***REMOVED***

    def test_get_signature(self***REMOVED***:
        assert_equal(umt.inner1d.signature, "(i***REMOVED***,(i***REMOVED***->(***REMOVED***"***REMOVED***

    def test_forced_sig(self***REMOVED***:
        a = 0.5*np.arange(3, dtype='f8'***REMOVED***
        assert_equal(np.add(a, 0.5***REMOVED***, [0.5, 1, 1.5***REMOVED******REMOVED***
        assert_equal(np.add(a, 0.5, sig='i', casting='unsafe'***REMOVED***, [0, 0, 1***REMOVED******REMOVED***
        assert_equal(np.add(a, 0.5, sig='ii->i', casting='unsafe'***REMOVED***, [0, 0, 1***REMOVED******REMOVED***
        assert_equal(np.add(a, 0.5, sig=('i4',***REMOVED***, casting='unsafe'***REMOVED***, [0, 0, 1***REMOVED******REMOVED***
        assert_equal(np.add(a, 0.5, sig=('i4', 'i4', 'i4'***REMOVED***,
                                            casting='unsafe'***REMOVED***, [0, 0, 1***REMOVED******REMOVED***

        b = np.zeros((3,***REMOVED***, dtype='f8'***REMOVED***
        np.add(a, 0.5, out=b***REMOVED***
        assert_equal(b, [0.5, 1, 1.5***REMOVED******REMOVED***
        b[:***REMOVED*** = 0
        np.add(a, 0.5, sig='i', out=b, casting='unsafe'***REMOVED***
        assert_equal(b, [0, 0, 1***REMOVED******REMOVED***
        b[:***REMOVED*** = 0
        np.add(a, 0.5, sig='ii->i', out=b, casting='unsafe'***REMOVED***
        assert_equal(b, [0, 0, 1***REMOVED******REMOVED***
        b[:***REMOVED*** = 0
        np.add(a, 0.5, sig=('i4',***REMOVED***, out=b, casting='unsafe'***REMOVED***
        assert_equal(b, [0, 0, 1***REMOVED******REMOVED***
        b[:***REMOVED*** = 0
        np.add(a, 0.5, sig=('i4', 'i4', 'i4'***REMOVED***, out=b, casting='unsafe'***REMOVED***
        assert_equal(b, [0, 0, 1***REMOVED******REMOVED***

    def test_true_divide(self***REMOVED***:
        # True_divide has a non uniform signature, see #3484.
        # This also tests type_tuple_type_resolver.
        a = np.full(5, 12.5***REMOVED***
        b = np.full(5, 10.0***REMOVED***
        tgt = np.full(5, 1.25***REMOVED***
        assert_almost_equal(np.true_divide(a, b, dtype=np.float64***REMOVED***, tgt***REMOVED***
        assert_almost_equal(np.true_divide(a, b, dtype=np.float32***REMOVED***, tgt***REMOVED***
        assert_raises(TypeError, np.true_divide, a, b, dtype=np.int***REMOVED***

    def test_sum_stability(self***REMOVED***:
        a = np.ones(500, dtype=np.float32***REMOVED***
        assert_almost_equal((a / 10.***REMOVED***.sum(***REMOVED*** - a.size / 10., 0, 4***REMOVED***

        a = np.ones(500, dtype=np.float64***REMOVED***
        assert_almost_equal((a / 10.***REMOVED***.sum(***REMOVED*** - a.size / 10., 0, 13***REMOVED***

    def test_sum(self***REMOVED***:
        for dt in (np.int, np.float16, np.float32, np.float64, np.longdouble***REMOVED***:
            for v in (0, 1, 2, 7, 8, 9, 15, 16, 19, 127,
                      128, 1024, 1235***REMOVED***:
                tgt = dt(v * (v + 1***REMOVED*** / 2***REMOVED***
                d = np.arange(1, v + 1, dtype=dt***REMOVED***
                assert_almost_equal(np.sum(d***REMOVED***, tgt***REMOVED***
                assert_almost_equal(np.sum(d[::-1***REMOVED******REMOVED***, tgt***REMOVED***

            d = np.ones(500, dtype=dt***REMOVED***
            assert_almost_equal(np.sum(d[::2***REMOVED******REMOVED***, 250.***REMOVED***
            assert_almost_equal(np.sum(d[1::2***REMOVED******REMOVED***, 250.***REMOVED***
            assert_almost_equal(np.sum(d[::3***REMOVED******REMOVED***, 167.***REMOVED***
            assert_almost_equal(np.sum(d[1::3***REMOVED******REMOVED***, 167.***REMOVED***
            assert_almost_equal(np.sum(d[::-2***REMOVED******REMOVED***, 250.***REMOVED***
            assert_almost_equal(np.sum(d[-1::-2***REMOVED******REMOVED***, 250.***REMOVED***
            assert_almost_equal(np.sum(d[::-3***REMOVED******REMOVED***, 167.***REMOVED***
            assert_almost_equal(np.sum(d[-1::-3***REMOVED******REMOVED***, 167.***REMOVED***
            # sum with first reduction entry != 0
            d = np.ones((1,***REMOVED***, dtype=dt***REMOVED***
            d += d
            assert_almost_equal(d, 2.***REMOVED***

    def test_sum_complex(self***REMOVED***:
        for dt in (np.complex64, np.complex128, np.clongdouble***REMOVED***:
            for v in (0, 1, 2, 7, 8, 9, 15, 16, 19, 127,
                      128, 1024, 1235***REMOVED***:
                tgt = dt(v * (v + 1***REMOVED*** / 2***REMOVED*** - dt((v * (v + 1***REMOVED*** / 2***REMOVED*** * 1j***REMOVED***
                d = np.empty(v, dtype=dt***REMOVED***
                d.real = np.arange(1, v + 1***REMOVED***
                d.imag = -np.arange(1, v + 1***REMOVED***
                assert_almost_equal(np.sum(d***REMOVED***, tgt***REMOVED***
                assert_almost_equal(np.sum(d[::-1***REMOVED******REMOVED***, tgt***REMOVED***

            d = np.ones(500, dtype=dt***REMOVED*** + 1j
            assert_almost_equal(np.sum(d[::2***REMOVED******REMOVED***, 250. + 250j***REMOVED***
            assert_almost_equal(np.sum(d[1::2***REMOVED******REMOVED***, 250. + 250j***REMOVED***
            assert_almost_equal(np.sum(d[::3***REMOVED******REMOVED***, 167. + 167j***REMOVED***
            assert_almost_equal(np.sum(d[1::3***REMOVED******REMOVED***, 167. + 167j***REMOVED***
            assert_almost_equal(np.sum(d[::-2***REMOVED******REMOVED***, 250. + 250j***REMOVED***
            assert_almost_equal(np.sum(d[-1::-2***REMOVED******REMOVED***, 250. + 250j***REMOVED***
            assert_almost_equal(np.sum(d[::-3***REMOVED******REMOVED***, 167. + 167j***REMOVED***
            assert_almost_equal(np.sum(d[-1::-3***REMOVED******REMOVED***, 167. + 167j***REMOVED***
            # sum with first reduction entry != 0
            d = np.ones((1,***REMOVED***, dtype=dt***REMOVED*** + 1j
            d += d
            assert_almost_equal(d, 2. + 2j***REMOVED***

    def test_inner1d(self***REMOVED***:
        a = np.arange(6***REMOVED***.reshape((2, 3***REMOVED******REMOVED***
        assert_array_equal(umt.inner1d(a, a***REMOVED***, np.sum(a*a, axis=-1***REMOVED******REMOVED***
        a = np.arange(6***REMOVED***
        assert_array_equal(umt.inner1d(a, a***REMOVED***, np.sum(a*a***REMOVED******REMOVED***

    def test_broadcast(self***REMOVED***:
        msg = "broadcast"
        a = np.arange(4***REMOVED***.reshape((2, 1, 2***REMOVED******REMOVED***
        b = np.arange(4***REMOVED***.reshape((1, 2, 2***REMOVED******REMOVED***
        assert_array_equal(umt.inner1d(a, b***REMOVED***, np.sum(a*b, axis=-1***REMOVED***, err_msg=msg***REMOVED***
        msg = "extend & broadcast loop dimensions"
        b = np.arange(4***REMOVED***.reshape((2, 2***REMOVED******REMOVED***
        assert_array_equal(umt.inner1d(a, b***REMOVED***, np.sum(a*b, axis=-1***REMOVED***, err_msg=msg***REMOVED***
        # Broadcast in core dimensions should fail
        a = np.arange(8***REMOVED***.reshape((4, 2***REMOVED******REMOVED***
        b = np.arange(4***REMOVED***.reshape((4, 1***REMOVED******REMOVED***
        assert_raises(ValueError, umt.inner1d, a, b***REMOVED***
        # Extend core dimensions should fail
        a = np.arange(8***REMOVED***.reshape((4, 2***REMOVED******REMOVED***
        b = np.array(7***REMOVED***
        assert_raises(ValueError, umt.inner1d, a, b***REMOVED***
        # Broadcast should fail
        a = np.arange(2***REMOVED***.reshape((2, 1, 1***REMOVED******REMOVED***
        b = np.arange(3***REMOVED***.reshape((3, 1, 1***REMOVED******REMOVED***
        assert_raises(ValueError, umt.inner1d, a, b***REMOVED***

    def test_type_cast(self***REMOVED***:
        msg = "type cast"
        a = np.arange(6, dtype='short'***REMOVED***.reshape((2, 3***REMOVED******REMOVED***
        assert_array_equal(umt.inner1d(a, a***REMOVED***, np.sum(a*a, axis=-1***REMOVED***,
                           err_msg=msg***REMOVED***
        msg = "type cast on one argument"
        a = np.arange(6***REMOVED***.reshape((2, 3***REMOVED******REMOVED***
        b = a + 0.1
        assert_array_almost_equal(umt.inner1d(a, b***REMOVED***, np.sum(a*b, axis=-1***REMOVED***,
                                  err_msg=msg***REMOVED***

    def test_endian(self***REMOVED***:
        msg = "big endian"
        a = np.arange(6, dtype='>i4'***REMOVED***.reshape((2, 3***REMOVED******REMOVED***
        assert_array_equal(umt.inner1d(a, a***REMOVED***, np.sum(a*a, axis=-1***REMOVED***,
                           err_msg=msg***REMOVED***
        msg = "little endian"
        a = np.arange(6, dtype='<i4'***REMOVED***.reshape((2, 3***REMOVED******REMOVED***
        assert_array_equal(umt.inner1d(a, a***REMOVED***, np.sum(a*a, axis=-1***REMOVED***,
                           err_msg=msg***REMOVED***

        # Output should always be native-endian
        Ba = np.arange(1, dtype='>f8'***REMOVED***
        La = np.arange(1, dtype='<f8'***REMOVED***
        assert_equal((Ba+Ba***REMOVED***.dtype, np.dtype('f8'***REMOVED******REMOVED***
        assert_equal((Ba+La***REMOVED***.dtype, np.dtype('f8'***REMOVED******REMOVED***
        assert_equal((La+Ba***REMOVED***.dtype, np.dtype('f8'***REMOVED******REMOVED***
        assert_equal((La+La***REMOVED***.dtype, np.dtype('f8'***REMOVED******REMOVED***

        assert_equal(np.absolute(La***REMOVED***.dtype, np.dtype('f8'***REMOVED******REMOVED***
        assert_equal(np.absolute(Ba***REMOVED***.dtype, np.dtype('f8'***REMOVED******REMOVED***
        assert_equal(np.negative(La***REMOVED***.dtype, np.dtype('f8'***REMOVED******REMOVED***
        assert_equal(np.negative(Ba***REMOVED***.dtype, np.dtype('f8'***REMOVED******REMOVED***

    def test_incontiguous_array(self***REMOVED***:
        msg = "incontiguous memory layout of array"
        x = np.arange(64***REMOVED***.reshape((2, 2, 2, 2, 2, 2***REMOVED******REMOVED***
        a = x[:, 0,:, 0,:, 0***REMOVED***
        b = x[:, 1,:, 1,:, 1***REMOVED***
        a[0, 0, 0***REMOVED*** = -1
        msg2 = "make sure it references to the original array"
        assert_equal(x[0, 0, 0, 0, 0, 0***REMOVED***, -1, err_msg=msg2***REMOVED***
        assert_array_equal(umt.inner1d(a, b***REMOVED***, np.sum(a*b, axis=-1***REMOVED***, err_msg=msg***REMOVED***
        x = np.arange(24***REMOVED***.reshape(2, 3, 4***REMOVED***
        a = x.T
        b = x.T
        a[0, 0, 0***REMOVED*** = -1
        assert_equal(x[0, 0, 0***REMOVED***, -1, err_msg=msg2***REMOVED***
        assert_array_equal(umt.inner1d(a, b***REMOVED***, np.sum(a*b, axis=-1***REMOVED***, err_msg=msg***REMOVED***

    def test_output_argument(self***REMOVED***:
        msg = "output argument"
        a = np.arange(12***REMOVED***.reshape((2, 3, 2***REMOVED******REMOVED***
        b = np.arange(4***REMOVED***.reshape((2, 1, 2***REMOVED******REMOVED*** + 1
        c = np.zeros((2, 3***REMOVED***, dtype='int'***REMOVED***
        umt.inner1d(a, b, c***REMOVED***
        assert_array_equal(c, np.sum(a*b, axis=-1***REMOVED***, err_msg=msg***REMOVED***
        c[:***REMOVED*** = -1
        umt.inner1d(a, b, out=c***REMOVED***
        assert_array_equal(c, np.sum(a*b, axis=-1***REMOVED***, err_msg=msg***REMOVED***

        msg = "output argument with type cast"
        c = np.zeros((2, 3***REMOVED***, dtype='int16'***REMOVED***
        umt.inner1d(a, b, c***REMOVED***
        assert_array_equal(c, np.sum(a*b, axis=-1***REMOVED***, err_msg=msg***REMOVED***
        c[:***REMOVED*** = -1
        umt.inner1d(a, b, out=c***REMOVED***
        assert_array_equal(c, np.sum(a*b, axis=-1***REMOVED***, err_msg=msg***REMOVED***

        msg = "output argument with incontiguous layout"
        c = np.zeros((2, 3, 4***REMOVED***, dtype='int16'***REMOVED***
        umt.inner1d(a, b, c[..., 0***REMOVED******REMOVED***
        assert_array_equal(c[..., 0***REMOVED***, np.sum(a*b, axis=-1***REMOVED***, err_msg=msg***REMOVED***
        c[:***REMOVED*** = -1
        umt.inner1d(a, b, out=c[..., 0***REMOVED******REMOVED***
        assert_array_equal(c[..., 0***REMOVED***, np.sum(a*b, axis=-1***REMOVED***, err_msg=msg***REMOVED***

    def test_innerwt(self***REMOVED***:
        a = np.arange(6***REMOVED***.reshape((2, 3***REMOVED******REMOVED***
        b = np.arange(10, 16***REMOVED***.reshape((2, 3***REMOVED******REMOVED***
        w = np.arange(20, 26***REMOVED***.reshape((2, 3***REMOVED******REMOVED***
        assert_array_equal(umt.innerwt(a, b, w***REMOVED***, np.sum(a*b*w, axis=-1***REMOVED******REMOVED***
        a = np.arange(100, 124***REMOVED***.reshape((2, 3, 4***REMOVED******REMOVED***
        b = np.arange(200, 224***REMOVED***.reshape((2, 3, 4***REMOVED******REMOVED***
        w = np.arange(300, 324***REMOVED***.reshape((2, 3, 4***REMOVED******REMOVED***
        assert_array_equal(umt.innerwt(a, b, w***REMOVED***, np.sum(a*b*w, axis=-1***REMOVED******REMOVED***

    def test_innerwt_empty(self***REMOVED***:
        ***REMOVED***Test generalized ufunc with zero-sized operands***REMOVED***
        a = np.array([***REMOVED***, dtype='f8'***REMOVED***
        b = np.array([***REMOVED***, dtype='f8'***REMOVED***
        w = np.array([***REMOVED***, dtype='f8'***REMOVED***
        assert_array_equal(umt.innerwt(a, b, w***REMOVED***, np.sum(a*b*w, axis=-1***REMOVED******REMOVED***

    def test_matrix_multiply(self***REMOVED***:
        self.compare_matrix_multiply_results(np.long***REMOVED***
        self.compare_matrix_multiply_results(np.double***REMOVED***

    def compare_matrix_multiply_results(self, tp***REMOVED***:
        d1 = np.array(np.random.rand(2, 3, 4***REMOVED***, dtype=tp***REMOVED***
        d2 = np.array(np.random.rand(2, 3, 4***REMOVED***, dtype=tp***REMOVED***
        msg = "matrix multiply on type %s" % d1.dtype.name

        def permute_n(n***REMOVED***:
            if n == 1:
                return ([0***REMOVED***,***REMOVED***
            ret = (***REMOVED***
            base = permute_n(n-1***REMOVED***
            for perm in base:
                for i in range(n***REMOVED***:
                    new = perm + [n-1***REMOVED***
                    new[n-1***REMOVED*** = new[i***REMOVED***
                    new[i***REMOVED*** = n-1
                    ret += (new,***REMOVED***
            return ret

        def slice_n(n***REMOVED***:
            if n == 0:
                return ((***REMOVED***,***REMOVED***
            ret = (***REMOVED***
            base = slice_n(n-1***REMOVED***
            for sl in base:
                ret += (sl+(slice(None***REMOVED***,***REMOVED***,***REMOVED***
                ret += (sl+(slice(0, 1***REMOVED***,***REMOVED***,***REMOVED***
            return ret

        def broadcastable(s1, s2***REMOVED***:
            return s1 == s2 or s1 == 1 or s2 == 1

        permute_3 = permute_n(3***REMOVED***
        slice_3 = slice_n(3***REMOVED*** + ((slice(None, None, -1***REMOVED***,***REMOVED****3,***REMOVED***

        ref = True
        for p1 in permute_3:
            for p2 in permute_3:
                for s1 in slice_3:
                    for s2 in slice_3:
                        a1 = d1.transpose(p1***REMOVED***[s1***REMOVED***
                        a2 = d2.transpose(p2***REMOVED***[s2***REMOVED***
                        ref = ref and a1.base is not None
                        ref = ref and a2.base is not None
                        if (a1.shape[-1***REMOVED*** == a2.shape[-2***REMOVED*** and
                                broadcastable(a1.shape[0***REMOVED***, a2.shape[0***REMOVED******REMOVED******REMOVED***:
                            assert_array_almost_equal(
                                umt.matrix_multiply(a1, a2***REMOVED***,
                                np.sum(a2[..., np.newaxis***REMOVED***.swapaxes(-3, -1***REMOVED*** *
                                       a1[..., np.newaxis,:***REMOVED***, axis=-1***REMOVED***,
                                err_msg=msg + ' %s %s' % (str(a1.shape***REMOVED***,
                                                          str(a2.shape***REMOVED******REMOVED******REMOVED***

        assert_equal(ref, True, err_msg="reference check"***REMOVED***

    def test_euclidean_pdist(self***REMOVED***:
        a = np.arange(12, dtype=np.float***REMOVED***.reshape(4, 3***REMOVED***
        out = np.empty((a.shape[0***REMOVED*** * (a.shape[0***REMOVED*** - 1***REMOVED*** // 2,***REMOVED***, dtype=a.dtype***REMOVED***
        umt.euclidean_pdist(a, out***REMOVED***
        b = np.sqrt(np.sum((a[:, None***REMOVED*** - a***REMOVED*****2, axis=-1***REMOVED******REMOVED***
        b = b[~np.tri(a.shape[0***REMOVED***, dtype=bool***REMOVED******REMOVED***
        assert_almost_equal(out, b***REMOVED***
        # An output array is required to determine p with signature (n,d***REMOVED***->(p***REMOVED***
        assert_raises(ValueError, umt.euclidean_pdist, a***REMOVED***

    def test_object_logical(self***REMOVED***:
        a = np.array([3, None, True, False, "test", ""***REMOVED***, dtype=object***REMOVED***
        assert_equal(np.logical_or(a, None***REMOVED***,
                        np.array([x or None for x in a***REMOVED***, dtype=object***REMOVED******REMOVED***
        assert_equal(np.logical_or(a, True***REMOVED***,
                        np.array([x or True for x in a***REMOVED***, dtype=object***REMOVED******REMOVED***
        assert_equal(np.logical_or(a, 12***REMOVED***,
                        np.array([x or 12 for x in a***REMOVED***, dtype=object***REMOVED******REMOVED***
        assert_equal(np.logical_or(a, "blah"***REMOVED***,
                        np.array([x or "blah" for x in a***REMOVED***, dtype=object***REMOVED******REMOVED***

        assert_equal(np.logical_and(a, None***REMOVED***,
                        np.array([x and None for x in a***REMOVED***, dtype=object***REMOVED******REMOVED***
        assert_equal(np.logical_and(a, True***REMOVED***,
                        np.array([x and True for x in a***REMOVED***, dtype=object***REMOVED******REMOVED***
        assert_equal(np.logical_and(a, 12***REMOVED***,
                        np.array([x and 12 for x in a***REMOVED***, dtype=object***REMOVED******REMOVED***
        assert_equal(np.logical_and(a, "blah"***REMOVED***,
                        np.array([x and "blah" for x in a***REMOVED***, dtype=object***REMOVED******REMOVED***

        assert_equal(np.logical_not(a***REMOVED***,
                        np.array([not x for x in a***REMOVED***, dtype=object***REMOVED******REMOVED***

        assert_equal(np.logical_or.reduce(a***REMOVED***, 3***REMOVED***
        assert_equal(np.logical_and.reduce(a***REMOVED***, None***REMOVED***

    def test_object_array_reduction(self***REMOVED***:
        # Reductions on object arrays
        a = np.array(['a', 'b', 'c'***REMOVED***, dtype=object***REMOVED***
        assert_equal(np.sum(a***REMOVED***, 'abc'***REMOVED***
        assert_equal(np.max(a***REMOVED***, 'c'***REMOVED***
        assert_equal(np.min(a***REMOVED***, 'a'***REMOVED***
        a = np.array([True, False, True***REMOVED***, dtype=object***REMOVED***
        assert_equal(np.sum(a***REMOVED***, 2***REMOVED***
        assert_equal(np.prod(a***REMOVED***, 0***REMOVED***
        assert_equal(np.any(a***REMOVED***, True***REMOVED***
        assert_equal(np.all(a***REMOVED***, False***REMOVED***
        assert_equal(np.max(a***REMOVED***, True***REMOVED***
        assert_equal(np.min(a***REMOVED***, False***REMOVED***
        assert_equal(np.array([[1***REMOVED******REMOVED***, dtype=object***REMOVED***.sum(***REMOVED***, 1***REMOVED***
        assert_equal(np.array([[[1, 2***REMOVED******REMOVED******REMOVED***, dtype=object***REMOVED***.sum((0, 1***REMOVED******REMOVED***, [1, 2***REMOVED******REMOVED***

    def test_object_array_accumulate_inplace(self***REMOVED***:
        # Checks that in-place accumulates work, see also gh-7402
        arr = np.ones(4, dtype=object***REMOVED***
        arr[:***REMOVED*** = [[1***REMOVED*** for i in range(4***REMOVED******REMOVED***
        # Twice reproduced also for tuples:
        np.add.accumulate(arr, out=arr***REMOVED***
        np.add.accumulate(arr, out=arr***REMOVED***
        assert_array_equal(arr, np.array([[1***REMOVED****i for i in [1, 3, 6, 10***REMOVED******REMOVED******REMOVED******REMOVED***

        # And the same if the axis argument is used
        arr = np.ones((2, 4***REMOVED***, dtype=object***REMOVED***
        arr[0, :***REMOVED*** = [[2***REMOVED*** for i in range(4***REMOVED******REMOVED***
        np.add.accumulate(arr, out=arr, axis=-1***REMOVED***
        np.add.accumulate(arr, out=arr, axis=-1***REMOVED***
        assert_array_equal(arr[0, :***REMOVED***, np.array([[2***REMOVED****i for i in [1, 3, 6, 10***REMOVED******REMOVED******REMOVED******REMOVED***

    def test_object_scalar_multiply(self***REMOVED***:
        # Tickets #2469 and #4482
        arr = np.matrix([1, 2***REMOVED***, dtype=object***REMOVED***
        desired = np.matrix([[3, 6***REMOVED******REMOVED***, dtype=object***REMOVED***
        assert_equal(np.multiply(arr, 3***REMOVED***, desired***REMOVED***
        assert_equal(np.multiply(3, arr***REMOVED***, desired***REMOVED***

    def test_zerosize_reduction(self***REMOVED***:
        # Test with default dtype and object dtype
        for a in [[***REMOVED***, np.array([***REMOVED***, dtype=object***REMOVED******REMOVED***:
            assert_equal(np.sum(a***REMOVED***, 0***REMOVED***
            assert_equal(np.prod(a***REMOVED***, 1***REMOVED***
            assert_equal(np.any(a***REMOVED***, False***REMOVED***
            assert_equal(np.all(a***REMOVED***, True***REMOVED***
            assert_raises(ValueError, np.max, a***REMOVED***
            assert_raises(ValueError, np.min, a***REMOVED***

    def test_axis_out_of_bounds(self***REMOVED***:
        a = np.array([False, False***REMOVED******REMOVED***
        assert_raises(ValueError, a.all, axis=1***REMOVED***
        a = np.array([False, False***REMOVED******REMOVED***
        assert_raises(ValueError, a.all, axis=-2***REMOVED***

        a = np.array([False, False***REMOVED******REMOVED***
        assert_raises(ValueError, a.any, axis=1***REMOVED***
        a = np.array([False, False***REMOVED******REMOVED***
        assert_raises(ValueError, a.any, axis=-2***REMOVED***

    def test_scalar_reduction(self***REMOVED***:
        # The functions 'sum', 'prod', etc allow specifying axis=0
        # even for scalars
        assert_equal(np.sum(3, axis=0***REMOVED***, 3***REMOVED***
        assert_equal(np.prod(3.5, axis=0***REMOVED***, 3.5***REMOVED***
        assert_equal(np.any(True, axis=0***REMOVED***, True***REMOVED***
        assert_equal(np.all(False, axis=0***REMOVED***, False***REMOVED***
        assert_equal(np.max(3, axis=0***REMOVED***, 3***REMOVED***
        assert_equal(np.min(2.5, axis=0***REMOVED***, 2.5***REMOVED***

        # Check scalar behaviour for ufuncs without an identity
        assert_equal(np.power.reduce(3***REMOVED***, 3***REMOVED***

        # Make sure that scalars are coming out from this operation
        assert_(type(np.prod(np.float32(2.5***REMOVED***, axis=0***REMOVED******REMOVED*** is np.float32***REMOVED***
        assert_(type(np.sum(np.float32(2.5***REMOVED***, axis=0***REMOVED******REMOVED*** is np.float32***REMOVED***
        assert_(type(np.max(np.float32(2.5***REMOVED***, axis=0***REMOVED******REMOVED*** is np.float32***REMOVED***
        assert_(type(np.min(np.float32(2.5***REMOVED***, axis=0***REMOVED******REMOVED*** is np.float32***REMOVED***

        # check if scalars/0-d arrays get cast
        assert_(type(np.any(0, axis=0***REMOVED******REMOVED*** is np.bool_***REMOVED***

        # assert that 0-d arrays get wrapped
        class MyArray(np.ndarray***REMOVED***:
            pass
        a = np.array(1***REMOVED***.view(MyArray***REMOVED***
        assert_(type(np.any(a***REMOVED******REMOVED*** is MyArray***REMOVED***

    def test_casting_out_param(self***REMOVED***:
        # Test that it's possible to do casts on output
        a = np.ones((200, 100***REMOVED***, np.int64***REMOVED***
        b = np.ones((200, 100***REMOVED***, np.int64***REMOVED***
        c = np.ones((200, 100***REMOVED***, np.float64***REMOVED***
        np.add(a, b, out=c***REMOVED***
        assert_equal(c, 2***REMOVED***

        a = np.zeros(65536***REMOVED***
        b = np.zeros(65536, dtype=np.float32***REMOVED***
        np.subtract(a, 0, out=b***REMOVED***
        assert_equal(b, 0***REMOVED***

    def test_where_param(self***REMOVED***:
        # Test that the where= ufunc parameter works with regular arrays
        a = np.arange(7***REMOVED***
        b = np.ones(7***REMOVED***
        c = np.zeros(7***REMOVED***
        np.add(a, b, out=c, where=(a % 2 == 1***REMOVED******REMOVED***
        assert_equal(c, [0, 2, 0, 4, 0, 6, 0***REMOVED******REMOVED***

        a = np.arange(4***REMOVED***.reshape(2, 2***REMOVED*** + 2
        np.power(a, [2, 3***REMOVED***, out=a, where=[[0, 1***REMOVED***, [1, 0***REMOVED******REMOVED******REMOVED***
        assert_equal(a, [[2, 27***REMOVED***, [16, 5***REMOVED******REMOVED******REMOVED***
        # Broadcasting the where= parameter
        np.subtract(a, 2, out=a, where=[True, False***REMOVED******REMOVED***
        assert_equal(a, [[0, 27***REMOVED***, [14, 5***REMOVED******REMOVED******REMOVED***

    def test_where_param_buffer_output(self***REMOVED***:
        # This test is temporarily skipped because it requires
        # adding masking features to the nditer to work properly

        # With casting on output
        a = np.ones(10, np.int64***REMOVED***
        b = np.ones(10, np.int64***REMOVED***
        c = 1.5 * np.ones(10, np.float64***REMOVED***
        np.add(a, b, out=c, where=[1, 0, 0, 1, 0, 0, 1, 1, 1, 0***REMOVED******REMOVED***
        assert_equal(c, [2, 1.5, 1.5, 2, 1.5, 1.5, 2, 2, 2, 1.5***REMOVED******REMOVED***

    def check_identityless_reduction(self, a***REMOVED***:
        # np.minimum.reduce is a identityless reduction

        # Verify that it sees the zero at various positions
        a[...***REMOVED*** = 1
        a[1, 0, 0***REMOVED*** = 0
        assert_equal(np.minimum.reduce(a, axis=None***REMOVED***, 0***REMOVED***
        assert_equal(np.minimum.reduce(a, axis=(0, 1***REMOVED******REMOVED***, [0, 1, 1, 1***REMOVED******REMOVED***
        assert_equal(np.minimum.reduce(a, axis=(0, 2***REMOVED******REMOVED***, [0, 1, 1***REMOVED******REMOVED***
        assert_equal(np.minimum.reduce(a, axis=(1, 2***REMOVED******REMOVED***, [1, 0***REMOVED******REMOVED***
        assert_equal(np.minimum.reduce(a, axis=0***REMOVED***,
                                    [[0, 1, 1, 1***REMOVED***, [1, 1, 1, 1***REMOVED***, [1, 1, 1, 1***REMOVED******REMOVED******REMOVED***
        assert_equal(np.minimum.reduce(a, axis=1***REMOVED***,
                                    [[1, 1, 1, 1***REMOVED***, [0, 1, 1, 1***REMOVED******REMOVED******REMOVED***
        assert_equal(np.minimum.reduce(a, axis=2***REMOVED***,
                                    [[1, 1, 1***REMOVED***, [0, 1, 1***REMOVED******REMOVED******REMOVED***
        assert_equal(np.minimum.reduce(a, axis=(***REMOVED******REMOVED***, a***REMOVED***

        a[...***REMOVED*** = 1
        a[0, 1, 0***REMOVED*** = 0
        assert_equal(np.minimum.reduce(a, axis=None***REMOVED***, 0***REMOVED***
        assert_equal(np.minimum.reduce(a, axis=(0, 1***REMOVED******REMOVED***, [0, 1, 1, 1***REMOVED******REMOVED***
        assert_equal(np.minimum.reduce(a, axis=(0, 2***REMOVED******REMOVED***, [1, 0, 1***REMOVED******REMOVED***
        assert_equal(np.minimum.reduce(a, axis=(1, 2***REMOVED******REMOVED***, [0, 1***REMOVED******REMOVED***
        assert_equal(np.minimum.reduce(a, axis=0***REMOVED***,
                                    [[1, 1, 1, 1***REMOVED***, [0, 1, 1, 1***REMOVED***, [1, 1, 1, 1***REMOVED******REMOVED******REMOVED***
        assert_equal(np.minimum.reduce(a, axis=1***REMOVED***,
                                    [[0, 1, 1, 1***REMOVED***, [1, 1, 1, 1***REMOVED******REMOVED******REMOVED***
        assert_equal(np.minimum.reduce(a, axis=2***REMOVED***,
                                    [[1, 0, 1***REMOVED***, [1, 1, 1***REMOVED******REMOVED******REMOVED***
        assert_equal(np.minimum.reduce(a, axis=(***REMOVED******REMOVED***, a***REMOVED***

        a[...***REMOVED*** = 1
        a[0, 0, 1***REMOVED*** = 0
        assert_equal(np.minimum.reduce(a, axis=None***REMOVED***, 0***REMOVED***
        assert_equal(np.minimum.reduce(a, axis=(0, 1***REMOVED******REMOVED***, [1, 0, 1, 1***REMOVED******REMOVED***
        assert_equal(np.minimum.reduce(a, axis=(0, 2***REMOVED******REMOVED***, [0, 1, 1***REMOVED******REMOVED***
        assert_equal(np.minimum.reduce(a, axis=(1, 2***REMOVED******REMOVED***, [0, 1***REMOVED******REMOVED***
        assert_equal(np.minimum.reduce(a, axis=0***REMOVED***,
                                    [[1, 0, 1, 1***REMOVED***, [1, 1, 1, 1***REMOVED***, [1, 1, 1, 1***REMOVED******REMOVED******REMOVED***
        assert_equal(np.minimum.reduce(a, axis=1***REMOVED***,
                                    [[1, 0, 1, 1***REMOVED***, [1, 1, 1, 1***REMOVED******REMOVED******REMOVED***
        assert_equal(np.minimum.reduce(a, axis=2***REMOVED***,
                                    [[0, 1, 1***REMOVED***, [1, 1, 1***REMOVED******REMOVED******REMOVED***
        assert_equal(np.minimum.reduce(a, axis=(***REMOVED******REMOVED***, a***REMOVED***

    def test_identityless_reduction_corder(self***REMOVED***:
        a = np.empty((2, 3, 4***REMOVED***, order='C'***REMOVED***
        self.check_identityless_reduction(a***REMOVED***

    def test_identityless_reduction_forder(self***REMOVED***:
        a = np.empty((2, 3, 4***REMOVED***, order='F'***REMOVED***
        self.check_identityless_reduction(a***REMOVED***

    def test_identityless_reduction_otherorder(self***REMOVED***:
        a = np.empty((2, 4, 3***REMOVED***, order='C'***REMOVED***.swapaxes(1, 2***REMOVED***
        self.check_identityless_reduction(a***REMOVED***

    def test_identityless_reduction_noncontig(self***REMOVED***:
        a = np.empty((3, 5, 4***REMOVED***, order='C'***REMOVED***.swapaxes(1, 2***REMOVED***
        a = a[1:, 1:, 1:***REMOVED***
        self.check_identityless_reduction(a***REMOVED***

    def test_identityless_reduction_noncontig_unaligned(self***REMOVED***:
        a = np.empty((3*4*5*8 + 1,***REMOVED***, dtype='i1'***REMOVED***
        a = a[1:***REMOVED***.view(dtype='f8'***REMOVED***
        a.shape = (3, 4, 5***REMOVED***
        a = a[1:, 1:, 1:***REMOVED***
        self.check_identityless_reduction(a***REMOVED***

    def test_identityless_reduction_nonreorderable(self***REMOVED***:
        a = np.array([[8.0, 2.0, 2.0***REMOVED***, [1.0, 0.5, 0.25***REMOVED******REMOVED******REMOVED***

        res = np.divide.reduce(a, axis=0***REMOVED***
        assert_equal(res, [8.0, 4.0, 8.0***REMOVED******REMOVED***

        res = np.divide.reduce(a, axis=1***REMOVED***
        assert_equal(res, [2.0, 8.0***REMOVED******REMOVED***

        res = np.divide.reduce(a, axis=(***REMOVED******REMOVED***
        assert_equal(res, a***REMOVED***

        assert_raises(ValueError, np.divide.reduce, a, axis=(0, 1***REMOVED******REMOVED***

    def test_reduce_zero_axis(self***REMOVED***:
        # If we have a n x m array and do a reduction with axis=1, then we are
        # doing n reductions, and each reduction takes an m-element array. For
        # a reduction operation without an identity, then:
        #   n > 0, m > 0: fine
        #   n = 0, m > 0: fine, doing 0 reductions of m-element arrays
        #   n > 0, m = 0: can't reduce a 0-element array, ValueError
        #   n = 0, m = 0: can't reduce a 0-element array, ValueError (for
        #     consistency with the above case***REMOVED***
        # This test doesn't actually look at return values, it just checks to
        # make sure that error we get an error in exactly those cases where we
        # expect one, and assumes the calculations themselves are done
        # correctly.

        def ok(f, *args, **kwargs***REMOVED***:
            f(*args, **kwargs***REMOVED***

        def err(f, *args, **kwargs***REMOVED***:
            assert_raises(ValueError, f, *args, **kwargs***REMOVED***

        def t(expect, func, n, m***REMOVED***:
            expect(func, np.zeros((n, m***REMOVED******REMOVED***, axis=1***REMOVED***
            expect(func, np.zeros((m, n***REMOVED******REMOVED***, axis=0***REMOVED***
            expect(func, np.zeros((n // 2, n // 2, m***REMOVED******REMOVED***, axis=2***REMOVED***
            expect(func, np.zeros((n // 2, m, n // 2***REMOVED******REMOVED***, axis=1***REMOVED***
            expect(func, np.zeros((n, m // 2, m // 2***REMOVED******REMOVED***, axis=(1, 2***REMOVED******REMOVED***
            expect(func, np.zeros((m // 2, n, m // 2***REMOVED******REMOVED***, axis=(0, 2***REMOVED******REMOVED***
            expect(func, np.zeros((m // 3, m // 3, m // 3,
                                  n // 2, n // 2***REMOVED******REMOVED***,
                                 axis=(0, 1, 2***REMOVED******REMOVED***
            # Check what happens if the inner (resp. outer***REMOVED*** dimensions are a
            # mix of zero and non-zero:
            expect(func, np.zeros((10, m, n***REMOVED******REMOVED***, axis=(0, 1***REMOVED******REMOVED***
            expect(func, np.zeros((10, n, m***REMOVED******REMOVED***, axis=(0, 2***REMOVED******REMOVED***
            expect(func, np.zeros((m, 10, n***REMOVED******REMOVED***, axis=0***REMOVED***
            expect(func, np.zeros((10, m, n***REMOVED******REMOVED***, axis=1***REMOVED***
            expect(func, np.zeros((10, n, m***REMOVED******REMOVED***, axis=2***REMOVED***

        # np.maximum is just an arbitrary ufunc with no reduction identity
        assert_equal(np.maximum.identity, None***REMOVED***
        t(ok, np.maximum.reduce, 30, 30***REMOVED***
        t(ok, np.maximum.reduce, 0, 30***REMOVED***
        t(err, np.maximum.reduce, 30, 0***REMOVED***
        t(err, np.maximum.reduce, 0, 0***REMOVED***
        err(np.maximum.reduce, [***REMOVED******REMOVED***
        np.maximum.reduce(np.zeros((0, 0***REMOVED******REMOVED***, axis=(***REMOVED******REMOVED***

        # all of the combinations are fine for a reduction that has an
        # identity
        t(ok, np.add.reduce, 30, 30***REMOVED***
        t(ok, np.add.reduce, 0, 30***REMOVED***
        t(ok, np.add.reduce, 30, 0***REMOVED***
        t(ok, np.add.reduce, 0, 0***REMOVED***
        np.add.reduce([***REMOVED******REMOVED***
        np.add.reduce(np.zeros((0, 0***REMOVED******REMOVED***, axis=(***REMOVED******REMOVED***

        # OTOH, accumulate always makes sense for any combination of n and m,
        # because it maps an m-element array to an m-element array. These
        # tests are simpler because accumulate doesn't accept multiple axes.
        for uf in (np.maximum, np.add***REMOVED***:
            uf.accumulate(np.zeros((30, 0***REMOVED******REMOVED***, axis=0***REMOVED***
            uf.accumulate(np.zeros((0, 30***REMOVED******REMOVED***, axis=0***REMOVED***
            uf.accumulate(np.zeros((30, 30***REMOVED******REMOVED***, axis=0***REMOVED***
            uf.accumulate(np.zeros((0, 0***REMOVED******REMOVED***, axis=0***REMOVED***

    def test_safe_casting(self***REMOVED***:
        # In old versions of numpy, in-place operations used the 'unsafe'
        # casting rules. In versions >= 1.10, 'same_kind' is the
        # default and an exception is raised instead of a warning.
        # when 'same_kind' is not satisfied.
        a = np.array([1, 2, 3***REMOVED***, dtype=int***REMOVED***
        # Non-in-place addition is fine
        assert_array_equal(assert_no_warnings(np.add, a, 1.1***REMOVED***,
                           [2.1, 3.1, 4.1***REMOVED******REMOVED***
        assert_raises(TypeError, np.add, a, 1.1, out=a***REMOVED***

        def add_inplace(a, b***REMOVED***:
            a += b

        assert_raises(TypeError, add_inplace, a, 1.1***REMOVED***
        # Make sure that explicitly overriding the exception is allowed:
        assert_no_warnings(np.add, a, 1.1, out=a, casting="unsafe"***REMOVED***
        assert_array_equal(a, [2, 3, 4***REMOVED******REMOVED***

    def test_ufunc_custom_out(self***REMOVED***:
        # Test ufunc with built in input types and custom output type

        a = np.array([0, 1, 2***REMOVED***, dtype='i8'***REMOVED***
        b = np.array([0, 1, 2***REMOVED***, dtype='i8'***REMOVED***
        c = np.empty(3, dtype=rational***REMOVED***

        # Output must be specified so numpy knows what
        # ufunc signature to look for
        result = test_add(a, b, c***REMOVED***
        assert_equal(result, np.array([0, 2, 4***REMOVED***, dtype=rational***REMOVED******REMOVED***

        # no output type should raise TypeError
        assert_raises(TypeError, test_add, a, b***REMOVED***

    def test_operand_flags(self***REMOVED***:
        a = np.arange(16, dtype='l'***REMOVED***.reshape(4, 4***REMOVED***
        b = np.arange(9, dtype='l'***REMOVED***.reshape(3, 3***REMOVED***
        opflag_tests.inplace_add(a[:-1, :-1***REMOVED***, b***REMOVED***
        assert_equal(a, np.array([[0, 2, 4, 3***REMOVED***, [7, 9, 11, 7***REMOVED***,
            [14, 16, 18, 11***REMOVED***, [12, 13, 14, 15***REMOVED******REMOVED***, dtype='l'***REMOVED******REMOVED***

        a = np.array(0***REMOVED***
        opflag_tests.inplace_add(a, 3***REMOVED***
        assert_equal(a, 3***REMOVED***
        opflag_tests.inplace_add(a, [3, 4***REMOVED******REMOVED***
        assert_equal(a, 10***REMOVED***

    def test_struct_ufunc(self***REMOVED***:
        import numpy.core.struct_ufunc_test as struct_ufunc

        a = np.array([(1, 2, 3***REMOVED******REMOVED***, dtype='u8,u8,u8'***REMOVED***
        b = np.array([(1, 2, 3***REMOVED******REMOVED***, dtype='u8,u8,u8'***REMOVED***

        result = struct_ufunc.add_triplet(a, b***REMOVED***
        assert_equal(result, np.array([(2, 4, 6***REMOVED******REMOVED***, dtype='u8,u8,u8'***REMOVED******REMOVED***

    def test_custom_ufunc(self***REMOVED***:
        a = np.array([rational(1, 2***REMOVED***, rational(1, 3***REMOVED***, rational(1, 4***REMOVED******REMOVED***,
            dtype=rational***REMOVED***
        b = np.array([rational(1, 2***REMOVED***, rational(1, 3***REMOVED***, rational(1, 4***REMOVED******REMOVED***,
            dtype=rational***REMOVED***

        result = test_add_rationals(a, b***REMOVED***
        expected = np.array([rational(1***REMOVED***, rational(2, 3***REMOVED***, rational(1, 2***REMOVED******REMOVED***,
            dtype=rational***REMOVED***
        assert_equal(result, expected***REMOVED***

    def test_custom_array_like(self***REMOVED***:

        class MyThing(object***REMOVED***:
            __array_priority__ = 1000

            rmul_count = 0
            getitem_count = 0

            def __init__(self, shape***REMOVED***:
                self.shape = shape

            def __len__(self***REMOVED***:
                return self.shape[0***REMOVED***

            def __getitem__(self, i***REMOVED***:
                MyThing.getitem_count += 1
                if not isinstance(i, tuple***REMOVED***:
                    i = (i,***REMOVED***
                if len(i***REMOVED*** > len(self.shape***REMOVED***:
                    raise IndexError("boo"***REMOVED***

                return MyThing(self.shape[len(i***REMOVED***:***REMOVED******REMOVED***

            def __rmul__(self, other***REMOVED***:
                MyThing.rmul_count += 1
                return self

        np.float64(5***REMOVED****MyThing((3, 3***REMOVED******REMOVED***
        assert_(MyThing.rmul_count == 1, MyThing.rmul_count***REMOVED***
        assert_(MyThing.getitem_count <= 2, MyThing.getitem_count***REMOVED***

    def test_inplace_fancy_indexing(self***REMOVED***:

        a = np.arange(10***REMOVED***
        np.add.at(a, [2, 5, 2***REMOVED***, 1***REMOVED***
        assert_equal(a, [0, 1, 4, 3, 4, 6, 6, 7, 8, 9***REMOVED******REMOVED***

        a = np.arange(10***REMOVED***
        b = np.array([100, 100, 100***REMOVED******REMOVED***
        np.add.at(a, [2, 5, 2***REMOVED***, b***REMOVED***
        assert_equal(a, [0, 1, 202, 3, 4, 105, 6, 7, 8, 9***REMOVED******REMOVED***

        a = np.arange(9***REMOVED***.reshape(3, 3***REMOVED***
        b = np.array([[100, 100, 100***REMOVED***, [200, 200, 200***REMOVED***, [300, 300, 300***REMOVED******REMOVED******REMOVED***
        np.add.at(a, (slice(None***REMOVED***, [1, 2, 1***REMOVED******REMOVED***, b***REMOVED***
        assert_equal(a, [[0, 201, 102***REMOVED***, [3, 404, 205***REMOVED***, [6, 607, 308***REMOVED******REMOVED******REMOVED***

        a = np.arange(27***REMOVED***.reshape(3, 3, 3***REMOVED***
        b = np.array([100, 200, 300***REMOVED******REMOVED***
        np.add.at(a, (slice(None***REMOVED***, slice(None***REMOVED***, [1, 2, 1***REMOVED******REMOVED***, b***REMOVED***
        assert_equal(a,
            [[[0, 401, 202***REMOVED***,
              [3, 404, 205***REMOVED***,
              [6, 407, 208***REMOVED******REMOVED***,

             [[9, 410, 211***REMOVED***,
              [12, 413, 214***REMOVED***,
              [15, 416, 217***REMOVED******REMOVED***,

             [[18, 419, 220***REMOVED***,
              [21, 422, 223***REMOVED***,
              [24, 425, 226***REMOVED******REMOVED******REMOVED******REMOVED***

        a = np.arange(9***REMOVED***.reshape(3, 3***REMOVED***
        b = np.array([[100, 100, 100***REMOVED***, [200, 200, 200***REMOVED***, [300, 300, 300***REMOVED******REMOVED******REMOVED***
        np.add.at(a, ([1, 2, 1***REMOVED***, slice(None***REMOVED******REMOVED***, b***REMOVED***
        assert_equal(a, [[0, 1, 2***REMOVED***, [403, 404, 405***REMOVED***, [206, 207, 208***REMOVED******REMOVED******REMOVED***

        a = np.arange(27***REMOVED***.reshape(3, 3, 3***REMOVED***
        b = np.array([100, 200, 300***REMOVED******REMOVED***
        np.add.at(a, (slice(None***REMOVED***, [1, 2, 1***REMOVED***, slice(None***REMOVED******REMOVED***, b***REMOVED***
        assert_equal(a,
            [[[0,  1,  2***REMOVED***,
              [203, 404, 605***REMOVED***,
              [106, 207, 308***REMOVED******REMOVED***,

             [[9,  10, 11***REMOVED***,
              [212, 413, 614***REMOVED***,
              [115, 216, 317***REMOVED******REMOVED***,

             [[18, 19, 20***REMOVED***,
              [221, 422, 623***REMOVED***,
              [124, 225, 326***REMOVED******REMOVED******REMOVED******REMOVED***

        a = np.arange(9***REMOVED***.reshape(3, 3***REMOVED***
        b = np.array([100, 200, 300***REMOVED******REMOVED***
        np.add.at(a, (0, [1, 2, 1***REMOVED******REMOVED***, b***REMOVED***
        assert_equal(a, [[0, 401, 202***REMOVED***, [3, 4, 5***REMOVED***, [6, 7, 8***REMOVED******REMOVED******REMOVED***

        a = np.arange(27***REMOVED***.reshape(3, 3, 3***REMOVED***
        b = np.array([100, 200, 300***REMOVED******REMOVED***
        np.add.at(a, ([1, 2, 1***REMOVED***, 0, slice(None***REMOVED******REMOVED***, b***REMOVED***
        assert_equal(a,
            [[[0,  1,  2***REMOVED***,
              [3,  4,  5***REMOVED***,
              [6,  7,  8***REMOVED******REMOVED***,

             [[209, 410, 611***REMOVED***,
              [12,  13, 14***REMOVED***,
              [15,  16, 17***REMOVED******REMOVED***,

             [[118, 219, 320***REMOVED***,
              [21,  22, 23***REMOVED***,
              [24,  25, 26***REMOVED******REMOVED******REMOVED******REMOVED***

        a = np.arange(27***REMOVED***.reshape(3, 3, 3***REMOVED***
        b = np.array([100, 200, 300***REMOVED******REMOVED***
        np.add.at(a, (slice(None***REMOVED***, slice(None***REMOVED***, slice(None***REMOVED******REMOVED***, b***REMOVED***
        assert_equal(a,
            [[[100, 201, 302***REMOVED***,
              [103, 204, 305***REMOVED***,
              [106, 207, 308***REMOVED******REMOVED***,

             [[109, 210, 311***REMOVED***,
              [112, 213, 314***REMOVED***,
              [115, 216, 317***REMOVED******REMOVED***,

             [[118, 219, 320***REMOVED***,
              [121, 222, 323***REMOVED***,
              [124, 225, 326***REMOVED******REMOVED******REMOVED******REMOVED***

        a = np.arange(10***REMOVED***
        np.negative.at(a, [2, 5, 2***REMOVED******REMOVED***
        assert_equal(a, [0, 1, 2, 3, 4, -5, 6, 7, 8, 9***REMOVED******REMOVED***

        # Test 0-dim array
        a = np.array(0***REMOVED***
        np.add.at(a, (***REMOVED***, 1***REMOVED***
        assert_equal(a, 1***REMOVED***

        assert_raises(IndexError, np.add.at, a, 0, 1***REMOVED***
        assert_raises(IndexError, np.add.at, a, [***REMOVED***, 1***REMOVED***

        # Test mixed dtypes
        a = np.arange(10***REMOVED***
        np.power.at(a, [1, 2, 3, 2***REMOVED***, 3.5***REMOVED***
        assert_equal(a, np.array([0, 1, 4414, 46, 4, 5, 6, 7, 8, 9***REMOVED******REMOVED******REMOVED***

        # Test boolean indexing and boolean ufuncs
        a = np.arange(10***REMOVED***
        index = a % 2 == 0
        np.equal.at(a, index, [0, 2, 4, 6, 8***REMOVED******REMOVED***
        assert_equal(a, [1, 1, 1, 3, 1, 5, 1, 7, 1, 9***REMOVED******REMOVED***

        # Test unary operator
        a = np.arange(10, dtype='u4'***REMOVED***
        np.invert.at(a, [2, 5, 2***REMOVED******REMOVED***
        assert_equal(a, [0, 1, 2, 3, 4, 5 ^ 0xffffffff, 6, 7, 8, 9***REMOVED******REMOVED***

        # Test empty subspace
        orig = np.arange(4***REMOVED***
        a = orig[:, None***REMOVED***[:, 0:0***REMOVED***
        np.add.at(a, [0, 1***REMOVED***, 3***REMOVED***
        assert_array_equal(orig, np.arange(4***REMOVED******REMOVED***

        # Test with swapped byte order
        index = np.array([1, 2, 1***REMOVED***, np.dtype('i'***REMOVED***.newbyteorder(***REMOVED******REMOVED***
        values = np.array([1, 2, 3, 4***REMOVED***, np.dtype('f'***REMOVED***.newbyteorder(***REMOVED******REMOVED***
        np.add.at(values, index, 3***REMOVED***
        assert_array_equal(values, [1, 8, 6, 4***REMOVED******REMOVED***

        # Test exception thrown
        values = np.array(['a', 1***REMOVED***, dtype=np.object***REMOVED***
        self.assertRaises(TypeError, np.add.at, values, [0, 1***REMOVED***, 1***REMOVED***
        assert_array_equal(values, np.array(['a', 1***REMOVED***, dtype=np.object***REMOVED******REMOVED***

        # Test multiple output ufuncs raise error, gh-5665
        assert_raises(ValueError, np.modf.at, np.arange(10***REMOVED***, [1***REMOVED******REMOVED***

    def test_reduce_arguments(self***REMOVED***:
        f = np.add.reduce
        d = np.ones((5,2***REMOVED***, dtype=int***REMOVED***
        o = np.ones((2,***REMOVED***, dtype=d.dtype***REMOVED***
        r = o * 5
        assert_equal(f(d***REMOVED***, r***REMOVED***
        # a, axis=0, dtype=None, out=None, keepdims=False
        assert_equal(f(d, axis=0***REMOVED***, r***REMOVED***
        assert_equal(f(d, 0***REMOVED***, r***REMOVED***
        assert_equal(f(d, 0, dtype=None***REMOVED***, r***REMOVED***
        assert_equal(f(d, 0, dtype='i'***REMOVED***, r***REMOVED***
        assert_equal(f(d, 0, 'i'***REMOVED***, r***REMOVED***
        assert_equal(f(d, 0, None***REMOVED***, r***REMOVED***
        assert_equal(f(d, 0, None, out=None***REMOVED***, r***REMOVED***
        assert_equal(f(d, 0, None, out=o***REMOVED***, r***REMOVED***
        assert_equal(f(d, 0, None, o***REMOVED***, r***REMOVED***
        assert_equal(f(d, 0, None, None***REMOVED***, r***REMOVED***
        assert_equal(f(d, 0, None, None, keepdims=False***REMOVED***, r***REMOVED***
        assert_equal(f(d, 0, None, None, True***REMOVED***, r.reshape((1,***REMOVED*** + r.shape***REMOVED******REMOVED***
        # multiple keywords
        assert_equal(f(d, axis=0, dtype=None, out=None, keepdims=False***REMOVED***, r***REMOVED***
        assert_equal(f(d, 0, dtype=None, out=None, keepdims=False***REMOVED***, r***REMOVED***
        assert_equal(f(d, 0, None, out=None, keepdims=False***REMOVED***, r***REMOVED***

        # too little
        assert_raises(TypeError, f***REMOVED***
        # too much
        assert_raises(TypeError, f, d, 0, None, None, False, 1***REMOVED***
        # invalid axis
        assert_raises(TypeError, f, d, "invalid"***REMOVED***
        assert_raises(TypeError, f, d, axis="invalid"***REMOVED***
        assert_raises(TypeError, f, d, axis="invalid", dtype=None,
                      keepdims=True***REMOVED***
        # invalid dtype
        assert_raises(TypeError, f, d, 0, "invalid"***REMOVED***
        assert_raises(TypeError, f, d, dtype="invalid"***REMOVED***
        assert_raises(TypeError, f, d, dtype="invalid", out=None***REMOVED***
        # invalid out
        assert_raises(TypeError, f, d, 0, None, "invalid"***REMOVED***
        assert_raises(TypeError, f, d, out="invalid"***REMOVED***
        assert_raises(TypeError, f, d, out="invalid", dtype=None***REMOVED***
        # keepdims boolean, no invalid value
        # assert_raises(TypeError, f, d, 0, None, None, "invalid"***REMOVED***
        # assert_raises(TypeError, f, d, keepdims="invalid", axis=0, dtype=None***REMOVED***
        # invalid mix
        assert_raises(TypeError, f, d, 0, keepdims="invalid", dtype="invalid",
                     out=None***REMOVED***

        # invalid keyord
        assert_raises(TypeError, f, d, axis=0, dtype=None, invalid=0***REMOVED***
        assert_raises(TypeError, f, d, invalid=0***REMOVED***
        assert_raises(TypeError, f, d, 0, keepdims=True, invalid="invalid",
                      out=None***REMOVED***
        assert_raises(TypeError, f, d, axis=0, dtype=None, keepdims=True,
                      out=None, invalid=0***REMOVED***
        assert_raises(TypeError, f, d, axis=0, dtype=None,
                      out=None, invalid=0***REMOVED***

    def test_structured_equal(self***REMOVED***:
        # https://github.com/numpy/numpy/issues/4855

        class MyA(np.ndarray***REMOVED***:
            def __numpy_ufunc__(self, ufunc, method, i, inputs, **kwargs***REMOVED***:
                return getattr(ufunc, method***REMOVED***(*(input.view(np.ndarray***REMOVED***
                                              for input in inputs***REMOVED***, **kwargs***REMOVED***
        a = np.arange(12.***REMOVED***.reshape(4,3***REMOVED***
        ra = a.view(dtype=('f8,f8,f8'***REMOVED******REMOVED***.squeeze(***REMOVED***
        mra = ra.view(MyA***REMOVED***

        target = np.array([ True, False, False, False***REMOVED***, dtype=bool***REMOVED***
        assert_equal(np.all(target == (mra == ra[0***REMOVED******REMOVED******REMOVED***, True***REMOVED***

    def test_NotImplemented_not_returned(self***REMOVED***:
        # See gh-5964 and gh-2091. Some of these functions are not operator
        # related and were fixed for other reasons in the past.
        binary_funcs = [
            np.power, np.add, np.subtract, np.multiply, np.divide,
            np.true_divide, np.floor_divide, np.bitwise_and, np.bitwise_or,
            np.bitwise_xor, np.left_shift, np.right_shift, np.fmax,
            np.fmin, np.fmod, np.hypot, np.logaddexp, np.logaddexp2,
            np.logical_and, np.logical_or, np.logical_xor, np.maximum,
            np.minimum, np.mod
            ***REMOVED***

        # These functions still return NotImplemented. Will be fixed in
        # future.
        # bad = [np.greater, np.greater_equal, np.less, np.less_equal, np.not_equal***REMOVED***

        a = np.array('1'***REMOVED***
        b = 1
        for f in binary_funcs:
            assert_raises(TypeError, f, a, b***REMOVED***

    def test_reduce_noncontig_output(self***REMOVED***:
        # Check that reduction deals with non-contiguous output arrays
        # appropriately.
        #
        # gh-8036

        x = np.arange(7*13*8, dtype=np.int16***REMOVED***.reshape(7, 13, 8***REMOVED***
        x = x[4:6,1:11:6,1:5***REMOVED***.transpose(1, 2, 0***REMOVED***
        y_base = np.arange(4*4, dtype=np.int16***REMOVED***.reshape(4, 4***REMOVED***
        y = y_base[::2,:***REMOVED***

        y_base_copy = y_base.copy(***REMOVED***

        r0 = np.add.reduce(x, out=y.copy(***REMOVED***, axis=2***REMOVED***
        r1 = np.add.reduce(x, out=y, axis=2***REMOVED***

        # The results should match, and y_base shouldn't get clobbered
        assert_equal(r0, r1***REMOVED***
        assert_equal(y_base[1,:***REMOVED***, y_base_copy[1,:***REMOVED******REMOVED***
        assert_equal(y_base[3,:***REMOVED***, y_base_copy[3,:***REMOVED******REMOVED***


if __name__ == "__main__":
    run_module_suite(***REMOVED***
