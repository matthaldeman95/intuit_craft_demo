from __future__ import division, absolute_import, print_function

import sys

import numpy as np
from numpy.compat import asbytes, unicode, sixu
from numpy.testing import TestCase, run_module_suite, assert_equal

# Guess the UCS length for this python interpreter
if sys.version_info[:2***REMOVED*** >= (3, 3***REMOVED***:
    # Python 3.3 uses a flexible string representation
    ucs4 = False

    def buffer_length(arr***REMOVED***:
        if isinstance(arr, unicode***REMOVED***:
            arr = str(arr***REMOVED***
            return (sys.getsizeof(arr+"a"***REMOVED*** - sys.getsizeof(arr***REMOVED******REMOVED*** * len(arr***REMOVED***
        v = memoryview(arr***REMOVED***
        if v.shape is None:
            return len(v***REMOVED*** * v.itemsize
        else:
            return np.prod(v.shape***REMOVED*** * v.itemsize
elif sys.version_info[0***REMOVED*** >= 3:
    import array as _array

    ucs4 = (_array.array('u'***REMOVED***.itemsize == 4***REMOVED***

    def buffer_length(arr***REMOVED***:
        if isinstance(arr, unicode***REMOVED***:
            return _array.array('u'***REMOVED***.itemsize * len(arr***REMOVED***
        v = memoryview(arr***REMOVED***
        if v.shape is None:
            return len(v***REMOVED*** * v.itemsize
        else:
            return np.prod(v.shape***REMOVED*** * v.itemsize
else:
    if len(buffer(sixu('u'***REMOVED******REMOVED******REMOVED*** == 4:
        ucs4 = True
    else:
        ucs4 = False

    def buffer_length(arr***REMOVED***:
        if isinstance(arr, np.ndarray***REMOVED***:
            return len(arr.data***REMOVED***
        return len(buffer(arr***REMOVED******REMOVED***

# In both cases below we need to make sure that the byte swapped value (as
# UCS4***REMOVED*** is still a valid unicode:
# Value that can be represented in UCS2 interpreters
ucs2_value = sixu('\u0900'***REMOVED***
# Value that cannot be represented in UCS2 interpreters (but can in UCS4***REMOVED***
ucs4_value = sixu('\U00100900'***REMOVED***


############################################################
#    Creation tests
############################################################

class create_zeros(object***REMOVED***:
    ***REMOVED***Check the creation of zero-valued arrays***REMOVED***

    def content_check(self, ua, ua_scalar, nbytes***REMOVED***:

        # Check the length of the unicode base type
        self.assertTrue(int(ua.dtype.str[2:***REMOVED******REMOVED*** == self.ulen***REMOVED***
        # Check the length of the data buffer
        self.assertTrue(buffer_length(ua***REMOVED*** == nbytes***REMOVED***
        # Small check that data in array element is ok
        self.assertTrue(ua_scalar == sixu(''***REMOVED******REMOVED***
        # Encode to ascii and double check
        self.assertTrue(ua_scalar.encode('ascii'***REMOVED*** == asbytes(''***REMOVED******REMOVED***
        # Check buffer lengths for scalars
        if ucs4:
            self.assertTrue(buffer_length(ua_scalar***REMOVED*** == 0***REMOVED***
        else:
            self.assertTrue(buffer_length(ua_scalar***REMOVED*** == 0***REMOVED***

    def test_zeros0D(self***REMOVED***:
        # Check creation of 0-dimensional objects
        ua = np.zeros((***REMOVED***, dtype='U%s' % self.ulen***REMOVED***
        self.content_check(ua, ua[(***REMOVED******REMOVED***, 4*self.ulen***REMOVED***

    def test_zerosSD(self***REMOVED***:
        # Check creation of single-dimensional objects
        ua = np.zeros((2,***REMOVED***, dtype='U%s' % self.ulen***REMOVED***
        self.content_check(ua, ua[0***REMOVED***, 4*self.ulen*2***REMOVED***
        self.content_check(ua, ua[1***REMOVED***, 4*self.ulen*2***REMOVED***

    def test_zerosMD(self***REMOVED***:
        # Check creation of multi-dimensional objects
        ua = np.zeros((2, 3, 4***REMOVED***, dtype='U%s' % self.ulen***REMOVED***
        self.content_check(ua, ua[0, 0, 0***REMOVED***, 4*self.ulen*2*3*4***REMOVED***
        self.content_check(ua, ua[-1, -1, -1***REMOVED***, 4*self.ulen*2*3*4***REMOVED***


class test_create_zeros_1(create_zeros, TestCase***REMOVED***:
    ***REMOVED***Check the creation of zero-valued arrays (size 1***REMOVED******REMOVED***
    ulen = 1


class test_create_zeros_2(create_zeros, TestCase***REMOVED***:
    ***REMOVED***Check the creation of zero-valued arrays (size 2***REMOVED******REMOVED***
    ulen = 2


class test_create_zeros_1009(create_zeros, TestCase***REMOVED***:
    ***REMOVED***Check the creation of zero-valued arrays (size 1009***REMOVED******REMOVED***
    ulen = 1009


class create_values(object***REMOVED***:
    ***REMOVED***Check the creation of unicode arrays with values***REMOVED***

    def content_check(self, ua, ua_scalar, nbytes***REMOVED***:

        # Check the length of the unicode base type
        self.assertTrue(int(ua.dtype.str[2:***REMOVED******REMOVED*** == self.ulen***REMOVED***
        # Check the length of the data buffer
        self.assertTrue(buffer_length(ua***REMOVED*** == nbytes***REMOVED***
        # Small check that data in array element is ok
        self.assertTrue(ua_scalar == self.ucs_value*self.ulen***REMOVED***
        # Encode to UTF-8 and double check
        self.assertTrue(ua_scalar.encode('utf-8'***REMOVED*** ==
                        (self.ucs_value*self.ulen***REMOVED***.encode('utf-8'***REMOVED******REMOVED***
        # Check buffer lengths for scalars
        if ucs4:
            self.assertTrue(buffer_length(ua_scalar***REMOVED*** == 4*self.ulen***REMOVED***
        else:
            if self.ucs_value == ucs4_value:
                # In UCS2, the \U0010FFFF will be represented using a
                # surrogate *pair*
                self.assertTrue(buffer_length(ua_scalar***REMOVED*** == 2*2*self.ulen***REMOVED***
            else:
                # In UCS2, the \uFFFF will be represented using a
                # regular 2-byte word
                self.assertTrue(buffer_length(ua_scalar***REMOVED*** == 2*self.ulen***REMOVED***

    def test_values0D(self***REMOVED***:
        # Check creation of 0-dimensional objects with values
        ua = np.array(self.ucs_value*self.ulen, dtype='U%s' % self.ulen***REMOVED***
        self.content_check(ua, ua[(***REMOVED******REMOVED***, 4*self.ulen***REMOVED***

    def test_valuesSD(self***REMOVED***:
        # Check creation of single-dimensional objects with values
        ua = np.array([self.ucs_value*self.ulen***REMOVED****2, dtype='U%s' % self.ulen***REMOVED***
        self.content_check(ua, ua[0***REMOVED***, 4*self.ulen*2***REMOVED***
        self.content_check(ua, ua[1***REMOVED***, 4*self.ulen*2***REMOVED***

    def test_valuesMD(self***REMOVED***:
        # Check creation of multi-dimensional objects with values
        ua = np.array([[[self.ucs_value*self.ulen***REMOVED****2***REMOVED****3***REMOVED****4, dtype='U%s' % self.ulen***REMOVED***
        self.content_check(ua, ua[0, 0, 0***REMOVED***, 4*self.ulen*2*3*4***REMOVED***
        self.content_check(ua, ua[-1, -1, -1***REMOVED***, 4*self.ulen*2*3*4***REMOVED***


class test_create_values_1_ucs2(create_values, TestCase***REMOVED***:
    ***REMOVED***Check the creation of valued arrays (size 1, UCS2 values***REMOVED******REMOVED***
    ulen = 1
    ucs_value = ucs2_value


class test_create_values_1_ucs4(create_values, TestCase***REMOVED***:
    ***REMOVED***Check the creation of valued arrays (size 1, UCS4 values***REMOVED******REMOVED***
    ulen = 1
    ucs_value = ucs4_value


class test_create_values_2_ucs2(create_values, TestCase***REMOVED***:
    ***REMOVED***Check the creation of valued arrays (size 2, UCS2 values***REMOVED******REMOVED***
    ulen = 2
    ucs_value = ucs2_value


class test_create_values_2_ucs4(create_values, TestCase***REMOVED***:
    ***REMOVED***Check the creation of valued arrays (size 2, UCS4 values***REMOVED******REMOVED***
    ulen = 2
    ucs_value = ucs4_value


class test_create_values_1009_ucs2(create_values, TestCase***REMOVED***:
    ***REMOVED***Check the creation of valued arrays (size 1009, UCS2 values***REMOVED******REMOVED***
    ulen = 1009
    ucs_value = ucs2_value


class test_create_values_1009_ucs4(create_values, TestCase***REMOVED***:
    ***REMOVED***Check the creation of valued arrays (size 1009, UCS4 values***REMOVED******REMOVED***
    ulen = 1009
    ucs_value = ucs4_value


############################################################
#    Assignment tests
############################################################

class assign_values(object***REMOVED***:
    ***REMOVED***Check the assignment of unicode arrays with values***REMOVED***

    def content_check(self, ua, ua_scalar, nbytes***REMOVED***:

        # Check the length of the unicode base type
        self.assertTrue(int(ua.dtype.str[2:***REMOVED******REMOVED*** == self.ulen***REMOVED***
        # Check the length of the data buffer
        self.assertTrue(buffer_length(ua***REMOVED*** == nbytes***REMOVED***
        # Small check that data in array element is ok
        self.assertTrue(ua_scalar == self.ucs_value*self.ulen***REMOVED***
        # Encode to UTF-8 and double check
        self.assertTrue(ua_scalar.encode('utf-8'***REMOVED*** ==
                        (self.ucs_value*self.ulen***REMOVED***.encode('utf-8'***REMOVED******REMOVED***
        # Check buffer lengths for scalars
        if ucs4:
            self.assertTrue(buffer_length(ua_scalar***REMOVED*** == 4*self.ulen***REMOVED***
        else:
            if self.ucs_value == ucs4_value:
                # In UCS2, the \U0010FFFF will be represented using a
                # surrogate *pair*
                self.assertTrue(buffer_length(ua_scalar***REMOVED*** == 2*2*self.ulen***REMOVED***
            else:
                # In UCS2, the \uFFFF will be represented using a
                # regular 2-byte word
                self.assertTrue(buffer_length(ua_scalar***REMOVED*** == 2*self.ulen***REMOVED***

    def test_values0D(self***REMOVED***:
        # Check assignment of 0-dimensional objects with values
        ua = np.zeros((***REMOVED***, dtype='U%s' % self.ulen***REMOVED***
        ua[(***REMOVED******REMOVED*** = self.ucs_value*self.ulen
        self.content_check(ua, ua[(***REMOVED******REMOVED***, 4*self.ulen***REMOVED***

    def test_valuesSD(self***REMOVED***:
        # Check assignment of single-dimensional objects with values
        ua = np.zeros((2,***REMOVED***, dtype='U%s' % self.ulen***REMOVED***
        ua[0***REMOVED*** = self.ucs_value*self.ulen
        self.content_check(ua, ua[0***REMOVED***, 4*self.ulen*2***REMOVED***
        ua[1***REMOVED*** = self.ucs_value*self.ulen
        self.content_check(ua, ua[1***REMOVED***, 4*self.ulen*2***REMOVED***

    def test_valuesMD(self***REMOVED***:
        # Check assignment of multi-dimensional objects with values
        ua = np.zeros((2, 3, 4***REMOVED***, dtype='U%s' % self.ulen***REMOVED***
        ua[0, 0, 0***REMOVED*** = self.ucs_value*self.ulen
        self.content_check(ua, ua[0, 0, 0***REMOVED***, 4*self.ulen*2*3*4***REMOVED***
        ua[-1, -1, -1***REMOVED*** = self.ucs_value*self.ulen
        self.content_check(ua, ua[-1, -1, -1***REMOVED***, 4*self.ulen*2*3*4***REMOVED***


class test_assign_values_1_ucs2(assign_values, TestCase***REMOVED***:
    ***REMOVED***Check the assignment of valued arrays (size 1, UCS2 values***REMOVED******REMOVED***
    ulen = 1
    ucs_value = ucs2_value


class test_assign_values_1_ucs4(assign_values, TestCase***REMOVED***:
    ***REMOVED***Check the assignment of valued arrays (size 1, UCS4 values***REMOVED******REMOVED***
    ulen = 1
    ucs_value = ucs4_value


class test_assign_values_2_ucs2(assign_values, TestCase***REMOVED***:
    ***REMOVED***Check the assignment of valued arrays (size 2, UCS2 values***REMOVED******REMOVED***
    ulen = 2
    ucs_value = ucs2_value


class test_assign_values_2_ucs4(assign_values, TestCase***REMOVED***:
    ***REMOVED***Check the assignment of valued arrays (size 2, UCS4 values***REMOVED******REMOVED***
    ulen = 2
    ucs_value = ucs4_value


class test_assign_values_1009_ucs2(assign_values, TestCase***REMOVED***:
    ***REMOVED***Check the assignment of valued arrays (size 1009, UCS2 values***REMOVED******REMOVED***
    ulen = 1009
    ucs_value = ucs2_value


class test_assign_values_1009_ucs4(assign_values, TestCase***REMOVED***:
    ***REMOVED***Check the assignment of valued arrays (size 1009, UCS4 values***REMOVED******REMOVED***
    ulen = 1009
    ucs_value = ucs4_value


############################################################
#    Byteorder tests
############################################################

class byteorder_values:
    ***REMOVED***Check the byteorder of unicode arrays in round-trip conversions***REMOVED***

    def test_values0D(self***REMOVED***:
        # Check byteorder of 0-dimensional objects
        ua = np.array(self.ucs_value*self.ulen, dtype='U%s' % self.ulen***REMOVED***
        ua2 = ua.newbyteorder(***REMOVED***
        # This changes the interpretation of the data region (but not the
        #  actual data***REMOVED***, therefore the returned scalars are not
        #  the same (they are byte-swapped versions of each other***REMOVED***.
        self.assertTrue(ua[(***REMOVED******REMOVED*** != ua2[(***REMOVED******REMOVED******REMOVED***
        ua3 = ua2.newbyteorder(***REMOVED***
        # Arrays must be equal after the round-trip
        assert_equal(ua, ua3***REMOVED***

    def test_valuesSD(self***REMOVED***:
        # Check byteorder of single-dimensional objects
        ua = np.array([self.ucs_value*self.ulen***REMOVED****2, dtype='U%s' % self.ulen***REMOVED***
        ua2 = ua.newbyteorder(***REMOVED***
        self.assertTrue(ua[0***REMOVED*** != ua2[0***REMOVED******REMOVED***
        self.assertTrue(ua[-1***REMOVED*** != ua2[-1***REMOVED******REMOVED***
        ua3 = ua2.newbyteorder(***REMOVED***
        # Arrays must be equal after the round-trip
        assert_equal(ua, ua3***REMOVED***

    def test_valuesMD(self***REMOVED***:
        # Check byteorder of multi-dimensional objects
        ua = np.array([[[self.ucs_value*self.ulen***REMOVED****2***REMOVED****3***REMOVED****4,
                   dtype='U%s' % self.ulen***REMOVED***
        ua2 = ua.newbyteorder(***REMOVED***
        self.assertTrue(ua[0, 0, 0***REMOVED*** != ua2[0, 0, 0***REMOVED******REMOVED***
        self.assertTrue(ua[-1, -1, -1***REMOVED*** != ua2[-1, -1, -1***REMOVED******REMOVED***
        ua3 = ua2.newbyteorder(***REMOVED***
        # Arrays must be equal after the round-trip
        assert_equal(ua, ua3***REMOVED***


class test_byteorder_1_ucs2(byteorder_values, TestCase***REMOVED***:
    ***REMOVED***Check the byteorder in unicode (size 1, UCS2 values***REMOVED******REMOVED***
    ulen = 1
    ucs_value = ucs2_value


class test_byteorder_1_ucs4(byteorder_values, TestCase***REMOVED***:
    ***REMOVED***Check the byteorder in unicode (size 1, UCS4 values***REMOVED******REMOVED***
    ulen = 1
    ucs_value = ucs4_value


class test_byteorder_2_ucs2(byteorder_values, TestCase***REMOVED***:
    ***REMOVED***Check the byteorder in unicode (size 2, UCS2 values***REMOVED******REMOVED***
    ulen = 2
    ucs_value = ucs2_value


class test_byteorder_2_ucs4(byteorder_values, TestCase***REMOVED***:
    ***REMOVED***Check the byteorder in unicode (size 2, UCS4 values***REMOVED******REMOVED***
    ulen = 2
    ucs_value = ucs4_value


class test_byteorder_1009_ucs2(byteorder_values, TestCase***REMOVED***:
    ***REMOVED***Check the byteorder in unicode (size 1009, UCS2 values***REMOVED******REMOVED***
    ulen = 1009
    ucs_value = ucs2_value


class test_byteorder_1009_ucs4(byteorder_values, TestCase***REMOVED***:
    ***REMOVED***Check the byteorder in unicode (size 1009, UCS4 values***REMOVED******REMOVED***
    ulen = 1009
    ucs_value = ucs4_value


if __name__ == "__main__":
    run_module_suite(***REMOVED***
