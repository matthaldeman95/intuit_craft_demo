from __future__ import division, absolute_import, print_function

import sys
import itertools
import warnings
import operator

import numpy as np
from numpy.testing.utils import _gen_alignment_data
from numpy.testing import (
    TestCase, run_module_suite, assert_, assert_equal, assert_raises,
    assert_almost_equal, assert_allclose
***REMOVED***

types = [np.bool_, np.byte, np.ubyte, np.short, np.ushort, np.intc, np.uintc,
         np.int_, np.uint, np.longlong, np.ulonglong,
         np.single, np.double, np.longdouble, np.csingle,
         np.cdouble, np.clongdouble***REMOVED***

floating_types = np.floating.__subclasses__(***REMOVED***


# This compares scalarmath against ufuncs.

class TestTypes(TestCase***REMOVED***:
    def test_types(self, level=1***REMOVED***:
        for atype in types:
            a = atype(1***REMOVED***
            assert_(a == 1, "error with %r: got %r" % (atype, a***REMOVED******REMOVED***

    def test_type_add(self, level=1***REMOVED***:
        # list of types
        for k, atype in enumerate(types***REMOVED***:
            a_scalar = atype(3***REMOVED***
            a_array = np.array([3***REMOVED***, dtype=atype***REMOVED***
            for l, btype in enumerate(types***REMOVED***:
                b_scalar = btype(1***REMOVED***
                b_array = np.array([1***REMOVED***, dtype=btype***REMOVED***
                c_scalar = a_scalar + b_scalar
                c_array = a_array + b_array
                # It was comparing the type numbers, but the new ufunc
                # function-finding mechanism finds the lowest function
                # to which both inputs can be cast - which produces 'l'
                # when you do 'q' + 'b'.  The old function finding mechanism
                # skipped ahead based on the first argument, but that
                # does not produce properly symmetric results...
                assert_equal(c_scalar.dtype, c_array.dtype,
                           "error with types (%d/'%c' + %d/'%c'***REMOVED***" %
                            (k, np.dtype(atype***REMOVED***.char, l, np.dtype(btype***REMOVED***.char***REMOVED******REMOVED***

    def test_type_create(self, level=1***REMOVED***:
        for k, atype in enumerate(types***REMOVED***:
            a = np.array([1, 2, 3***REMOVED***, atype***REMOVED***
            b = atype([1, 2, 3***REMOVED******REMOVED***
            assert_equal(a, b***REMOVED***

    def test_leak(self***REMOVED***:
        # test leak of scalar objects
        # a leak would show up in valgrind as still-reachable of ~2.6MB
        for i in range(200000***REMOVED***:
            np.add(1, 1***REMOVED***


class TestBaseMath(TestCase***REMOVED***:
    def test_blocked(self***REMOVED***:
        # test alignments offsets for simd instructions
        # alignments for vz + 2 * (vs - 1***REMOVED*** + 1
        for dt, sz in [(np.float32, 11***REMOVED***, (np.float64, 7***REMOVED******REMOVED***:
            for out, inp1, inp2, msg in _gen_alignment_data(dtype=dt,
                                                            type='binary',
                                                            max_size=sz***REMOVED***:
                exp1 = np.ones_like(inp1***REMOVED***
                inp1[...***REMOVED*** = np.ones_like(inp1***REMOVED***
                inp2[...***REMOVED*** = np.zeros_like(inp2***REMOVED***
                assert_almost_equal(np.add(inp1, inp2***REMOVED***, exp1, err_msg=msg***REMOVED***
                assert_almost_equal(np.add(inp1, 1***REMOVED***, exp1 + 1, err_msg=msg***REMOVED***
                assert_almost_equal(np.add(1, inp2***REMOVED***, exp1, err_msg=msg***REMOVED***

                np.add(inp1, inp2, out=out***REMOVED***
                assert_almost_equal(out, exp1, err_msg=msg***REMOVED***

                inp2[...***REMOVED*** += np.arange(inp2.size, dtype=dt***REMOVED*** + 1
                assert_almost_equal(np.square(inp2***REMOVED***,
                                    np.multiply(inp2, inp2***REMOVED***,  err_msg=msg***REMOVED***
                assert_almost_equal(np.reciprocal(inp2***REMOVED***,
                                    np.divide(1, inp2***REMOVED***,  err_msg=msg***REMOVED***

                inp1[...***REMOVED*** = np.ones_like(inp1***REMOVED***
                inp2[...***REMOVED*** = np.zeros_like(inp2***REMOVED***
                np.add(inp1, 1, out=out***REMOVED***
                assert_almost_equal(out, exp1 + 1, err_msg=msg***REMOVED***
                np.add(1, inp2, out=out***REMOVED***
                assert_almost_equal(out, exp1, err_msg=msg***REMOVED***

    def test_lower_align(self***REMOVED***:
        # check data that is not aligned to element size
        # i.e doubles are aligned to 4 bytes on i386
        d = np.zeros(23 * 8, dtype=np.int8***REMOVED***[4:-4***REMOVED***.view(np.float64***REMOVED***
        o = np.zeros(23 * 8, dtype=np.int8***REMOVED***[4:-4***REMOVED***.view(np.float64***REMOVED***
        assert_almost_equal(d + d, d * 2***REMOVED***
        np.add(d, d, out=o***REMOVED***
        np.add(np.ones_like(d***REMOVED***, d, out=o***REMOVED***
        np.add(d, np.ones_like(d***REMOVED***, out=o***REMOVED***
        np.add(np.ones_like(d***REMOVED***, d***REMOVED***
        np.add(d, np.ones_like(d***REMOVED******REMOVED***


class TestPower(TestCase***REMOVED***:
    def test_small_types(self***REMOVED***:
        for t in [np.int8, np.int16, np.float16***REMOVED***:
            a = t(3***REMOVED***
            b = a ** 4
            assert_(b == 81, "error with %r: got %r" % (t, b***REMOVED******REMOVED***

    def test_large_types(self***REMOVED***:
        for t in [np.int32, np.int64, np.float32, np.float64, np.longdouble***REMOVED***:
            a = t(51***REMOVED***
            b = a ** 4
            msg = "error with %r: got %r" % (t, b***REMOVED***
            if np.issubdtype(t, np.integer***REMOVED***:
                assert_(b == 6765201, msg***REMOVED***
            else:
                assert_almost_equal(b, 6765201, err_msg=msg***REMOVED***

    def test_mixed_types(self***REMOVED***:
        typelist = [np.int8, np.int16, np.float16,
                    np.float32, np.float64, np.int8,
                    np.int16, np.int32, np.int64***REMOVED***
        for t1 in typelist:
            for t2 in typelist:
                a = t1(3***REMOVED***
                b = t2(2***REMOVED***
                result = a**b
                msg = ("error with %r and %r:"
                       "got %r, expected %r"***REMOVED*** % (t1, t2, result, 9***REMOVED***
                if np.issubdtype(np.dtype(result***REMOVED***, np.integer***REMOVED***:
                    assert_(result == 9, msg***REMOVED***
                else:
                    assert_almost_equal(result, 9, err_msg=msg***REMOVED***


class TestModulus(TestCase***REMOVED***:

    floordiv = operator.floordiv
    mod = operator.mod

    def test_modulus_basic(self***REMOVED***:
        dt = np.typecodes['AllInteger'***REMOVED*** + np.typecodes['Float'***REMOVED***
        for dt1, dt2 in itertools.product(dt, dt***REMOVED***:
            for sg1, sg2 in itertools.product((+1, -1***REMOVED***, (+1, -1***REMOVED******REMOVED***:
                if sg1 == -1 and dt1 in np.typecodes['UnsignedInteger'***REMOVED***:
                    continue
                if sg2 == -1 and dt2 in np.typecodes['UnsignedInteger'***REMOVED***:
                    continue
                fmt = 'dt1: %s, dt2: %s, sg1: %s, sg2: %s'
                msg = fmt % (dt1, dt2, sg1, sg2***REMOVED***
                a = np.array(sg1*71, dtype=dt1***REMOVED***[(***REMOVED******REMOVED***
                b = np.array(sg2*19, dtype=dt2***REMOVED***[(***REMOVED******REMOVED***
                div = self.floordiv(a, b***REMOVED***
                rem = self.mod(a, b***REMOVED***
                assert_equal(div*b + rem, a, err_msg=msg***REMOVED***
                if sg2 == -1:
                    assert_(b < rem <= 0, msg***REMOVED***
                else:
                    assert_(b > rem >= 0, msg***REMOVED***

    def test_float_modulus_exact(self***REMOVED***:
        # test that float results are exact for small integers. This also
        # holds for the same integers scaled by powers of two.
        nlst = list(range(-127, 0***REMOVED******REMOVED***
        plst = list(range(1, 128***REMOVED******REMOVED***
        dividend = nlst + [0***REMOVED*** + plst
        divisor = nlst + plst
        arg = list(itertools.product(dividend, divisor***REMOVED******REMOVED***
        tgt = list(divmod(*t***REMOVED*** for t in arg***REMOVED***

        a, b = np.array(arg, dtype=int***REMOVED***.T
        # convert exact integer results from Python to float so that
        # signed zero can be used, it is checked.
        tgtdiv, tgtrem = np.array(tgt, dtype=float***REMOVED***.T
        tgtdiv = np.where((tgtdiv == 0.0***REMOVED*** & ((b < 0***REMOVED*** ^ (a < 0***REMOVED******REMOVED***, -0.0, tgtdiv***REMOVED***
        tgtrem = np.where((tgtrem == 0.0***REMOVED*** & (b < 0***REMOVED***, -0.0, tgtrem***REMOVED***

        for dt in np.typecodes['Float'***REMOVED***:
            msg = 'dtype: %s' % (dt,***REMOVED***
            fa = a.astype(dt***REMOVED***
            fb = b.astype(dt***REMOVED***
            # use list comprehension so a_ and b_ are scalars
            div = [self.floordiv(a_, b_***REMOVED*** for  a_, b_ in zip(fa, fb***REMOVED******REMOVED***
            rem = [self.mod(a_, b_***REMOVED*** for a_, b_ in zip(fa, fb***REMOVED******REMOVED***
            assert_equal(div, tgtdiv, err_msg=msg***REMOVED***
            assert_equal(rem, tgtrem, err_msg=msg***REMOVED***

    def test_float_modulus_roundoff(self***REMOVED***:
        # gh-6127
        dt = np.typecodes['Float'***REMOVED***
        for dt1, dt2 in itertools.product(dt, dt***REMOVED***:
            for sg1, sg2 in itertools.product((+1, -1***REMOVED***, (+1, -1***REMOVED******REMOVED***:
                fmt = 'dt1: %s, dt2: %s, sg1: %s, sg2: %s'
                msg = fmt % (dt1, dt2, sg1, sg2***REMOVED***
                a = np.array(sg1*78*6e-8, dtype=dt1***REMOVED***[(***REMOVED******REMOVED***
                b = np.array(sg2*6e-8, dtype=dt2***REMOVED***[(***REMOVED******REMOVED***
                div = self.floordiv(a, b***REMOVED***
                rem = self.mod(a, b***REMOVED***
                # Equal assertion should hold when fmod is used
                assert_equal(div*b + rem, a, err_msg=msg***REMOVED***
                if sg2 == -1:
                    assert_(b < rem <= 0, msg***REMOVED***
                else:
                    assert_(b > rem >= 0, msg***REMOVED***

    def test_float_modulus_corner_cases(self***REMOVED***:
        # Check remainder magnitude.
        for dt in np.typecodes['Float'***REMOVED***:
            b = np.array(1.0, dtype=dt***REMOVED***
            a = np.nextafter(np.array(0.0, dtype=dt***REMOVED***, -b***REMOVED***
            rem = self.mod(a, b***REMOVED***
            assert_(rem <= b, 'dt: %s' % dt***REMOVED***
            rem = self.mod(-a, -b***REMOVED***
            assert_(rem >= -b, 'dt: %s' % dt***REMOVED***

        # Check nans, inf
        with warnings.catch_warnings(***REMOVED***:
            warnings.simplefilter('always'***REMOVED***
            warnings.simplefilter('ignore', RuntimeWarning***REMOVED***
            for dt in np.typecodes['Float'***REMOVED***:
                fone = np.array(1.0, dtype=dt***REMOVED***
                fzer = np.array(0.0, dtype=dt***REMOVED***
                finf = np.array(np.inf, dtype=dt***REMOVED***
                fnan = np.array(np.nan, dtype=dt***REMOVED***
                rem = self.mod(fone, fzer***REMOVED***
                assert_(np.isnan(rem***REMOVED***, 'dt: %s' % dt***REMOVED***
                # MSVC 2008 returns NaN here, so disable the check.
                #rem = self.mod(fone, finf***REMOVED***
                #assert_(rem == fone, 'dt: %s' % dt***REMOVED***
                rem = self.mod(fone, fnan***REMOVED***
                assert_(np.isnan(rem***REMOVED***, 'dt: %s' % dt***REMOVED***
                rem = self.mod(finf, fone***REMOVED***
                assert_(np.isnan(rem***REMOVED***, 'dt: %s' % dt***REMOVED***


class TestComplexDivision(TestCase***REMOVED***:
    def test_zero_division(self***REMOVED***:
        with np.errstate(all="ignore"***REMOVED***:
            for t in [np.complex64, np.complex128***REMOVED***:
                a = t(0.0***REMOVED***
                b = t(1.0***REMOVED***
                assert_(np.isinf(b/a***REMOVED******REMOVED***
                b = t(complex(np.inf, np.inf***REMOVED******REMOVED***
                assert_(np.isinf(b/a***REMOVED******REMOVED***
                b = t(complex(np.inf, np.nan***REMOVED******REMOVED***
                assert_(np.isinf(b/a***REMOVED******REMOVED***
                b = t(complex(np.nan, np.inf***REMOVED******REMOVED***
                assert_(np.isinf(b/a***REMOVED******REMOVED***
                b = t(complex(np.nan, np.nan***REMOVED******REMOVED***
                assert_(np.isnan(b/a***REMOVED******REMOVED***
                b = t(0.***REMOVED***
                assert_(np.isnan(b/a***REMOVED******REMOVED***

    def test_signed_zeros(self***REMOVED***:
        with np.errstate(all="ignore"***REMOVED***:
            for t in [np.complex64, np.complex128***REMOVED***:
                # tupled (numerator, denominator, expected***REMOVED***
                # for testing as expected == numerator/denominator
                data = (
                    (( 0.0,-1.0***REMOVED***, ( 0.0, 1.0***REMOVED***, (-1.0,-0.0***REMOVED******REMOVED***,
                    (( 0.0,-1.0***REMOVED***, ( 0.0,-1.0***REMOVED***, ( 1.0,-0.0***REMOVED******REMOVED***,
                    (( 0.0,-1.0***REMOVED***, (-0.0,-1.0***REMOVED***, ( 1.0, 0.0***REMOVED******REMOVED***,
                    (( 0.0,-1.0***REMOVED***, (-0.0, 1.0***REMOVED***, (-1.0, 0.0***REMOVED******REMOVED***,
                    (( 0.0, 1.0***REMOVED***, ( 0.0,-1.0***REMOVED***, (-1.0, 0.0***REMOVED******REMOVED***,
                    (( 0.0,-1.0***REMOVED***, ( 0.0,-1.0***REMOVED***, ( 1.0,-0.0***REMOVED******REMOVED***,
                    ((-0.0,-1.0***REMOVED***, ( 0.0,-1.0***REMOVED***, ( 1.0,-0.0***REMOVED******REMOVED***,
                    ((-0.0, 1.0***REMOVED***, ( 0.0,-1.0***REMOVED***, (-1.0,-0.0***REMOVED******REMOVED***
                ***REMOVED***
                for cases in data:
                    n = cases[0***REMOVED***
                    d = cases[1***REMOVED***
                    ex = cases[2***REMOVED***
                    result = t(complex(n[0***REMOVED***, n[1***REMOVED******REMOVED******REMOVED*** / t(complex(d[0***REMOVED***, d[1***REMOVED******REMOVED******REMOVED***
                    # check real and imag parts separately to avoid comparison
                    # in array context, which does not account for signed zeros
                    assert_equal(result.real, ex[0***REMOVED******REMOVED***
                    assert_equal(result.imag, ex[1***REMOVED******REMOVED***

    def test_branches(self***REMOVED***:
        with np.errstate(all="ignore"***REMOVED***:
            for t in [np.complex64, np.complex128***REMOVED***:
                # tupled (numerator, denominator, expected***REMOVED***
                # for testing as expected == numerator/denominator
                data = list(***REMOVED***

                # trigger branch: real(fabs(denom***REMOVED******REMOVED*** > imag(fabs(denom***REMOVED******REMOVED***
                # followed by else condition as neither are == 0
                data.append((( 2.0, 1.0***REMOVED***, ( 2.0, 1.0***REMOVED***, (1.0, 0.0***REMOVED******REMOVED******REMOVED***

                # trigger branch: real(fabs(denom***REMOVED******REMOVED*** > imag(fabs(denom***REMOVED******REMOVED***
                # followed by if condition as both are == 0
                # is performed in test_zero_division(***REMOVED***, so this is skipped

                # trigger else if branch: real(fabs(denom***REMOVED******REMOVED*** < imag(fabs(denom***REMOVED******REMOVED***
                data.append((( 1.0, 2.0***REMOVED***, ( 1.0, 2.0***REMOVED***, (1.0, 0.0***REMOVED******REMOVED******REMOVED***

                for cases in data:
                    n = cases[0***REMOVED***
                    d = cases[1***REMOVED***
                    ex = cases[2***REMOVED***
                    result = t(complex(n[0***REMOVED***, n[1***REMOVED******REMOVED******REMOVED*** / t(complex(d[0***REMOVED***, d[1***REMOVED******REMOVED******REMOVED***
                    # check real and imag parts separately to avoid comparison
                    # in array context, which does not account for signed zeros
                    assert_equal(result.real, ex[0***REMOVED******REMOVED***
                    assert_equal(result.imag, ex[1***REMOVED******REMOVED***


class TestConversion(TestCase***REMOVED***:
    def test_int_from_long(self***REMOVED***:
        l = [1e6, 1e12, 1e18, -1e6, -1e12, -1e18***REMOVED***
        li = [10**6, 10**12, 10**18, -10**6, -10**12, -10**18***REMOVED***
        for T in [None, np.float64, np.int64***REMOVED***:
            a = np.array(l, dtype=T***REMOVED***
            assert_equal([int(_m***REMOVED*** for _m in a***REMOVED***, li***REMOVED***

        a = np.array(l[:3***REMOVED***, dtype=np.uint64***REMOVED***
        assert_equal([int(_m***REMOVED*** for _m in a***REMOVED***, li[:3***REMOVED******REMOVED***

    def test_iinfo_long_values(self***REMOVED***:
        for code in 'bBhH':
            res = np.array(np.iinfo(code***REMOVED***.max + 1, dtype=code***REMOVED***
            tgt = np.iinfo(code***REMOVED***.min
            assert_(res == tgt***REMOVED***

        for code in np.typecodes['AllInteger'***REMOVED***:
            res = np.array(np.iinfo(code***REMOVED***.max, dtype=code***REMOVED***
            tgt = np.iinfo(code***REMOVED***.max
            assert_(res == tgt***REMOVED***

        for code in np.typecodes['AllInteger'***REMOVED***:
            res = np.typeDict[code***REMOVED***(np.iinfo(code***REMOVED***.max***REMOVED***
            tgt = np.iinfo(code***REMOVED***.max
            assert_(res == tgt***REMOVED***

    def test_int_raise_behaviour(self***REMOVED***:
        def overflow_error_func(dtype***REMOVED***:
            np.typeDict[dtype***REMOVED***(np.iinfo(dtype***REMOVED***.max + 1***REMOVED***

        for code in 'lLqQ':
            assert_raises(OverflowError, overflow_error_func, code***REMOVED***

    def test_longdouble_int(self***REMOVED***:
        # gh-627
        x = np.longdouble(np.inf***REMOVED***
        assert_raises(OverflowError, x.__int__***REMOVED***
        x = np.clongdouble(np.inf***REMOVED***
        assert_raises(OverflowError, x.__int__***REMOVED***

    def test_numpy_scalar_relational_operators(self***REMOVED***:
        # All integer
        for dt1 in np.typecodes['AllInteger'***REMOVED***:
            assert_(1 > np.array(0, dtype=dt1***REMOVED***[(***REMOVED******REMOVED***, "type %s failed" % (dt1,***REMOVED******REMOVED***
            assert_(not 1 < np.array(0, dtype=dt1***REMOVED***[(***REMOVED******REMOVED***, "type %s failed" % (dt1,***REMOVED******REMOVED***

            for dt2 in np.typecodes['AllInteger'***REMOVED***:
                assert_(np.array(1, dtype=dt1***REMOVED***[(***REMOVED******REMOVED*** > np.array(0, dtype=dt2***REMOVED***[(***REMOVED******REMOVED***,
                        "type %s and %s failed" % (dt1, dt2***REMOVED******REMOVED***
                assert_(not np.array(1, dtype=dt1***REMOVED***[(***REMOVED******REMOVED*** < np.array(0, dtype=dt2***REMOVED***[(***REMOVED******REMOVED***,
                        "type %s and %s failed" % (dt1, dt2***REMOVED******REMOVED***

        #Unsigned integers
        for dt1 in 'BHILQP':
            assert_(-1 < np.array(1, dtype=dt1***REMOVED***[(***REMOVED******REMOVED***, "type %s failed" % (dt1,***REMOVED******REMOVED***
            assert_(not -1 > np.array(1, dtype=dt1***REMOVED***[(***REMOVED******REMOVED***, "type %s failed" % (dt1,***REMOVED******REMOVED***
            assert_(-1 != np.array(1, dtype=dt1***REMOVED***[(***REMOVED******REMOVED***, "type %s failed" % (dt1,***REMOVED******REMOVED***

            #unsigned vs signed
            for dt2 in 'bhilqp':
                assert_(np.array(1, dtype=dt1***REMOVED***[(***REMOVED******REMOVED*** > np.array(-1, dtype=dt2***REMOVED***[(***REMOVED******REMOVED***,
                        "type %s and %s failed" % (dt1, dt2***REMOVED******REMOVED***
                assert_(not np.array(1, dtype=dt1***REMOVED***[(***REMOVED******REMOVED*** < np.array(-1, dtype=dt2***REMOVED***[(***REMOVED******REMOVED***,
                        "type %s and %s failed" % (dt1, dt2***REMOVED******REMOVED***
                assert_(np.array(1, dtype=dt1***REMOVED***[(***REMOVED******REMOVED*** != np.array(-1, dtype=dt2***REMOVED***[(***REMOVED******REMOVED***,
                        "type %s and %s failed" % (dt1, dt2***REMOVED******REMOVED***

        #Signed integers and floats
        for dt1 in 'bhlqp' + np.typecodes['Float'***REMOVED***:
            assert_(1 > np.array(-1, dtype=dt1***REMOVED***[(***REMOVED******REMOVED***, "type %s failed" % (dt1,***REMOVED******REMOVED***
            assert_(not 1 < np.array(-1, dtype=dt1***REMOVED***[(***REMOVED******REMOVED***, "type %s failed" % (dt1,***REMOVED******REMOVED***
            assert_(-1 == np.array(-1, dtype=dt1***REMOVED***[(***REMOVED******REMOVED***, "type %s failed" % (dt1,***REMOVED******REMOVED***

            for dt2 in 'bhlqp' + np.typecodes['Float'***REMOVED***:
                assert_(np.array(1, dtype=dt1***REMOVED***[(***REMOVED******REMOVED*** > np.array(-1, dtype=dt2***REMOVED***[(***REMOVED******REMOVED***,
                        "type %s and %s failed" % (dt1, dt2***REMOVED******REMOVED***
                assert_(not np.array(1, dtype=dt1***REMOVED***[(***REMOVED******REMOVED*** < np.array(-1, dtype=dt2***REMOVED***[(***REMOVED******REMOVED***,
                        "type %s and %s failed" % (dt1, dt2***REMOVED******REMOVED***
                assert_(np.array(-1, dtype=dt1***REMOVED***[(***REMOVED******REMOVED*** == np.array(-1, dtype=dt2***REMOVED***[(***REMOVED******REMOVED***,
                        "type %s and %s failed" % (dt1, dt2***REMOVED******REMOVED***


#class TestRepr(TestCase***REMOVED***:
#    def test_repr(self***REMOVED***:
#        for t in types:
#            val = t(1197346475.0137341***REMOVED***
#            val_repr = repr(val***REMOVED***
#            val2 = eval(val_repr***REMOVED***
#            assert_equal( val, val2 ***REMOVED***


class TestRepr(object***REMOVED***:
    def _test_type_repr(self, t***REMOVED***:
        finfo = np.finfo(t***REMOVED***
        last_fraction_bit_idx = finfo.nexp + finfo.nmant
        last_exponent_bit_idx = finfo.nexp
        storage_bytes = np.dtype(t***REMOVED***.itemsize*8
        # could add some more types to the list below
        for which in ['small denorm', 'small norm'***REMOVED***:
            # Values from http://en.wikipedia.org/wiki/IEEE_754
            constr = np.array([0x00***REMOVED****storage_bytes, dtype=np.uint8***REMOVED***
            if which == 'small denorm':
                byte = last_fraction_bit_idx // 8
                bytebit = 7-(last_fraction_bit_idx % 8***REMOVED***
                constr[byte***REMOVED*** = 1 << bytebit
            elif which == 'small norm':
                byte = last_exponent_bit_idx // 8
                bytebit = 7-(last_exponent_bit_idx % 8***REMOVED***
                constr[byte***REMOVED*** = 1 << bytebit
            else:
                raise ValueError('hmm'***REMOVED***
            val = constr.view(t***REMOVED***[0***REMOVED***
            val_repr = repr(val***REMOVED***
            val2 = t(eval(val_repr***REMOVED******REMOVED***
            if not (val2 == 0 and val < 1e-100***REMOVED***:
                assert_equal(val, val2***REMOVED***

    def test_float_repr(self***REMOVED***:
        # long double test cannot work, because eval goes through a python
        # float
        for t in [np.float32, np.float64***REMOVED***:
            yield self._test_type_repr, t


class TestSizeOf(TestCase***REMOVED***:

    def test_equal_nbytes(self***REMOVED***:
        for type in types:
            x = type(0***REMOVED***
            assert_(sys.getsizeof(x***REMOVED*** > x.nbytes***REMOVED***

    def test_error(self***REMOVED***:
        d = np.float32(***REMOVED***
        assert_raises(TypeError, d.__sizeof__, "a"***REMOVED***


class TestAbs(TestCase***REMOVED***:

    def _test_abs_func(self, absfunc***REMOVED***:
        for tp in floating_types:
            x = tp(-1.5***REMOVED***
            assert_equal(absfunc(x***REMOVED***, 1.5***REMOVED***
            x = tp(0.0***REMOVED***
            res = absfunc(x***REMOVED***
            # assert_equal(***REMOVED*** checks zero signedness
            assert_equal(res, 0.0***REMOVED***
            x = tp(-0.0***REMOVED***
            res = absfunc(x***REMOVED***
            assert_equal(res, 0.0***REMOVED***

    def test_builtin_abs(self***REMOVED***:
        self._test_abs_func(abs***REMOVED***

    def test_numpy_abs(self***REMOVED***:
        self._test_abs_func(np.abs***REMOVED***


if __name__ == "__main__":
    run_module_suite(***REMOVED***
