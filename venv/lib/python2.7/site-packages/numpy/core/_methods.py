***REMOVED***
Array methods which are called by both the C-code for the method
and the Python code for the NumPy-namespace function

***REMOVED***
from __future__ import division, absolute_import, print_function

import warnings

from numpy.core import multiarray as mu
from numpy.core import umath as um
from numpy.core.numeric import asanyarray
from numpy.core import numerictypes as nt

# save those O(100***REMOVED*** nanoseconds!
umr_maximum = um.maximum.reduce
umr_minimum = um.minimum.reduce
umr_sum = um.add.reduce
umr_prod = um.multiply.reduce
umr_any = um.logical_or.reduce
umr_all = um.logical_and.reduce

# avoid keyword arguments to speed up parsing, saves about 15%-20% for very
# small reductions
def _amax(a, axis=None, out=None, keepdims=False***REMOVED***:
    return umr_maximum(a, axis, None, out, keepdims***REMOVED***

def _amin(a, axis=None, out=None, keepdims=False***REMOVED***:
    return umr_minimum(a, axis, None, out, keepdims***REMOVED***

def _sum(a, axis=None, dtype=None, out=None, keepdims=False***REMOVED***:
    return umr_sum(a, axis, dtype, out, keepdims***REMOVED***

def _prod(a, axis=None, dtype=None, out=None, keepdims=False***REMOVED***:
    return umr_prod(a, axis, dtype, out, keepdims***REMOVED***

def _any(a, axis=None, dtype=None, out=None, keepdims=False***REMOVED***:
    return umr_any(a, axis, dtype, out, keepdims***REMOVED***

def _all(a, axis=None, dtype=None, out=None, keepdims=False***REMOVED***:
    return umr_all(a, axis, dtype, out, keepdims***REMOVED***

def _count_reduce_items(arr, axis***REMOVED***:
    if axis is None:
        axis = tuple(range(arr.ndim***REMOVED******REMOVED***
    if not isinstance(axis, tuple***REMOVED***:
        axis = (axis,***REMOVED***
    items = 1
    for ax in axis:
        items *= arr.shape[ax***REMOVED***
    return items

def _mean(a, axis=None, dtype=None, out=None, keepdims=False***REMOVED***:
    arr = asanyarray(a***REMOVED***

    rcount = _count_reduce_items(arr, axis***REMOVED***
    # Make this warning show up first
    if rcount == 0:
        warnings.warn("Mean of empty slice.", RuntimeWarning***REMOVED***

    # Cast bool, unsigned int, and int to float64 by default
    if dtype is None and issubclass(arr.dtype.type, (nt.integer, nt.bool_***REMOVED******REMOVED***:
        dtype = mu.dtype('f8'***REMOVED***

    ret = umr_sum(arr, axis, dtype, out, keepdims***REMOVED***
    if isinstance(ret, mu.ndarray***REMOVED***:
        ret = um.true_divide(
                ret, rcount, out=ret, casting='unsafe', subok=False***REMOVED***
    elif hasattr(ret, 'dtype'***REMOVED***:
        ret = ret.dtype.type(ret / rcount***REMOVED***
    else:
        ret = ret / rcount

    return ret

def _var(a, axis=None, dtype=None, out=None, ddof=0, keepdims=False***REMOVED***:
    arr = asanyarray(a***REMOVED***

    rcount = _count_reduce_items(arr, axis***REMOVED***
    # Make this warning show up on top.
    if ddof >= rcount:
        warnings.warn("Degrees of freedom <= 0 for slice", RuntimeWarning***REMOVED***

    # Cast bool, unsigned int, and int to float64 by default
    if dtype is None and issubclass(arr.dtype.type, (nt.integer, nt.bool_***REMOVED******REMOVED***:
        dtype = mu.dtype('f8'***REMOVED***

    # Compute the mean.
    # Note that if dtype is not of inexact type then arraymean will
    # not be either.
    arrmean = umr_sum(arr, axis, dtype, keepdims=True***REMOVED***
    if isinstance(arrmean, mu.ndarray***REMOVED***:
        arrmean = um.true_divide(
                arrmean, rcount, out=arrmean, casting='unsafe', subok=False***REMOVED***
    else:
        arrmean = arrmean.dtype.type(arrmean / rcount***REMOVED***

    # Compute sum of squared deviations from mean
    # Note that x may not be inexact and that we need it to be an array,
    # not a scalar.
    x = asanyarray(arr - arrmean***REMOVED***
    if issubclass(arr.dtype.type, nt.complexfloating***REMOVED***:
        x = um.multiply(x, um.conjugate(x***REMOVED***, out=x***REMOVED***.real
    else:
        x = um.multiply(x, x, out=x***REMOVED***
    ret = umr_sum(x, axis, dtype, out, keepdims***REMOVED***

    # Compute degrees of freedom and make sure it is not negative.
    rcount = max([rcount - ddof, 0***REMOVED******REMOVED***

    # divide by degrees of freedom
    if isinstance(ret, mu.ndarray***REMOVED***:
        ret = um.true_divide(
                ret, rcount, out=ret, casting='unsafe', subok=False***REMOVED***
    elif hasattr(ret, 'dtype'***REMOVED***:
        ret = ret.dtype.type(ret / rcount***REMOVED***
    else:
        ret = ret / rcount

    return ret

def _std(a, axis=None, dtype=None, out=None, ddof=0, keepdims=False***REMOVED***:
    ret = _var(a, axis=axis, dtype=dtype, out=out, ddof=ddof,
               keepdims=keepdims***REMOVED***

    if isinstance(ret, mu.ndarray***REMOVED***:
        ret = um.sqrt(ret, out=ret***REMOVED***
    elif hasattr(ret, 'dtype'***REMOVED***:
        ret = ret.dtype.type(um.sqrt(ret***REMOVED******REMOVED***
    else:
        ret = um.sqrt(ret***REMOVED***

    return ret
