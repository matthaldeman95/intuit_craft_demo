from __future__ import division, absolute_import, print_function

__all__ = ['atleast_1d', 'atleast_2d', 'atleast_3d', 'vstack', 'hstack',
           'stack'***REMOVED***

from . import numeric as _nx
from .numeric import asanyarray, newaxis

def atleast_1d(*arys***REMOVED***:
    ***REMOVED***
    Convert inputs to arrays with at least one dimension.

    Scalar inputs are converted to 1-dimensional arrays, whilst
    higher-dimensional inputs are preserved.

    Parameters
    ----------
    arys1, arys2, ... : array_like
        One or more input arrays.

    Returns
    -------
    ret : ndarray
        An array, or sequence of arrays, each with ``a.ndim >= 1``.
        Copies are made only if necessary.

    See Also
    --------
    atleast_2d, atleast_3d

    Examples
    --------
    >>> np.atleast_1d(1.0***REMOVED***
    array([ 1.***REMOVED******REMOVED***

    >>> x = np.arange(9.0***REMOVED***.reshape(3,3***REMOVED***
    >>> np.atleast_1d(x***REMOVED***
    array([[ 0.,  1.,  2.***REMOVED***,
           [ 3.,  4.,  5.***REMOVED***,
           [ 6.,  7.,  8.***REMOVED******REMOVED******REMOVED***
    >>> np.atleast_1d(x***REMOVED*** is x
    True

    >>> np.atleast_1d(1, [3, 4***REMOVED******REMOVED***
    [array([1***REMOVED******REMOVED***, array([3, 4***REMOVED******REMOVED******REMOVED***

    ***REMOVED***
    res = [***REMOVED***
    for ary in arys:
        ary = asanyarray(ary***REMOVED***
        if len(ary.shape***REMOVED*** == 0:
            result = ary.reshape(1***REMOVED***
        else:
            result = ary
        res.append(result***REMOVED***
    if len(res***REMOVED*** == 1:
        return res[0***REMOVED***
    else:
        return res

def atleast_2d(*arys***REMOVED***:
    ***REMOVED***
    View inputs as arrays with at least two dimensions.

    Parameters
    ----------
    arys1, arys2, ... : array_like
        One or more array-like sequences.  Non-array inputs are converted
        to arrays.  Arrays that already have two or more dimensions are
        preserved.

    Returns
    -------
    res, res2, ... : ndarray
        An array, or tuple of arrays, each with ``a.ndim >= 2``.
        Copies are avoided where possible, and views with two or more
        dimensions are returned.

    See Also
    --------
    atleast_1d, atleast_3d

    Examples
    --------
    >>> np.atleast_2d(3.0***REMOVED***
    array([[ 3.***REMOVED******REMOVED******REMOVED***

    >>> x = np.arange(3.0***REMOVED***
    >>> np.atleast_2d(x***REMOVED***
    array([[ 0.,  1.,  2.***REMOVED******REMOVED******REMOVED***
    >>> np.atleast_2d(x***REMOVED***.base is x
    True

    >>> np.atleast_2d(1, [1, 2***REMOVED***, [[1, 2***REMOVED******REMOVED******REMOVED***
    [array([[1***REMOVED******REMOVED******REMOVED***, array([[1, 2***REMOVED******REMOVED******REMOVED***, array([[1, 2***REMOVED******REMOVED******REMOVED******REMOVED***

    ***REMOVED***
    res = [***REMOVED***
    for ary in arys:
        ary = asanyarray(ary***REMOVED***
        if len(ary.shape***REMOVED*** == 0:
            result = ary.reshape(1, 1***REMOVED***
        elif len(ary.shape***REMOVED*** == 1:
            result = ary[newaxis,:***REMOVED***
        else:
            result = ary
        res.append(result***REMOVED***
    if len(res***REMOVED*** == 1:
        return res[0***REMOVED***
    else:
        return res

def atleast_3d(*arys***REMOVED***:
    ***REMOVED***
    View inputs as arrays with at least three dimensions.

    Parameters
    ----------
    arys1, arys2, ... : array_like
        One or more array-like sequences.  Non-array inputs are converted to
        arrays.  Arrays that already have three or more dimensions are
        preserved.

    Returns
    -------
    res1, res2, ... : ndarray
        An array, or tuple of arrays, each with ``a.ndim >= 3``.  Copies are
        avoided where possible, and views with three or more dimensions are
        returned.  For example, a 1-D array of shape ``(N,***REMOVED***`` becomes a view
        of shape ``(1, N, 1***REMOVED***``, and a 2-D array of shape ``(M, N***REMOVED***`` becomes a
        view of shape ``(M, N, 1***REMOVED***``.

    See Also
    --------
    atleast_1d, atleast_2d

    Examples
    --------
    >>> np.atleast_3d(3.0***REMOVED***
    array([[[ 3.***REMOVED******REMOVED******REMOVED******REMOVED***

    >>> x = np.arange(3.0***REMOVED***
    >>> np.atleast_3d(x***REMOVED***.shape
    (1, 3, 1***REMOVED***

    >>> x = np.arange(12.0***REMOVED***.reshape(4,3***REMOVED***
    >>> np.atleast_3d(x***REMOVED***.shape
    (4, 3, 1***REMOVED***
    >>> np.atleast_3d(x***REMOVED***.base is x
    True

    >>> for arr in np.atleast_3d([1, 2***REMOVED***, [[1, 2***REMOVED******REMOVED***, [[[1, 2***REMOVED******REMOVED******REMOVED******REMOVED***:
    ...     print(arr, arr.shape***REMOVED***
    ...
    [[[1***REMOVED***
      [2***REMOVED******REMOVED******REMOVED*** (1, 2, 1***REMOVED***
    [[[1***REMOVED***
      [2***REMOVED******REMOVED******REMOVED*** (1, 2, 1***REMOVED***
    [[[1 2***REMOVED******REMOVED******REMOVED*** (1, 1, 2***REMOVED***

    ***REMOVED***
    res = [***REMOVED***
    for ary in arys:
        ary = asanyarray(ary***REMOVED***
        if len(ary.shape***REMOVED*** == 0:
            result = ary.reshape(1, 1, 1***REMOVED***
        elif len(ary.shape***REMOVED*** == 1:
            result = ary[newaxis,:, newaxis***REMOVED***
        elif len(ary.shape***REMOVED*** == 2:
            result = ary[:,:, newaxis***REMOVED***
        else:
            result = ary
        res.append(result***REMOVED***
    if len(res***REMOVED*** == 1:
        return res[0***REMOVED***
    else:
        return res


def vstack(tup***REMOVED***:
    ***REMOVED***
    Stack arrays in sequence vertically (row wise***REMOVED***.

    Take a sequence of arrays and stack them vertically to make a single
    array. Rebuild arrays divided by `vsplit`.

    Parameters
    ----------
    tup : sequence of ndarrays
        Tuple containing arrays to be stacked. The arrays must have the same
        shape along all but the first axis.

    Returns
    -------
    stacked : ndarray
        The array formed by stacking the given arrays.

    See Also
    --------
    stack : Join a sequence of arrays along a new axis.
    hstack : Stack arrays in sequence horizontally (column wise***REMOVED***.
    dstack : Stack arrays in sequence depth wise (along third dimension***REMOVED***.
    concatenate : Join a sequence of arrays along an existing axis.
    vsplit : Split array into a list of multiple sub-arrays vertically.

    Notes
    -----
    Equivalent to ``np.concatenate(tup, axis=0***REMOVED***`` if `tup` contains arrays that
    are at least 2-dimensional.

    Examples
    --------
    >>> a = np.array([1, 2, 3***REMOVED******REMOVED***
    >>> b = np.array([2, 3, 4***REMOVED******REMOVED***
    >>> np.vstack((a,b***REMOVED******REMOVED***
    array([[1, 2, 3***REMOVED***,
           [2, 3, 4***REMOVED******REMOVED******REMOVED***

    >>> a = np.array([[1***REMOVED***, [2***REMOVED***, [3***REMOVED******REMOVED******REMOVED***
    >>> b = np.array([[2***REMOVED***, [3***REMOVED***, [4***REMOVED******REMOVED******REMOVED***
    >>> np.vstack((a,b***REMOVED******REMOVED***
    array([[1***REMOVED***,
           [2***REMOVED***,
           [3***REMOVED***,
           [2***REMOVED***,
           [3***REMOVED***,
           [4***REMOVED******REMOVED******REMOVED***

    ***REMOVED***
    return _nx.concatenate([atleast_2d(_m***REMOVED*** for _m in tup***REMOVED***, 0***REMOVED***

def hstack(tup***REMOVED***:
    ***REMOVED***
    Stack arrays in sequence horizontally (column wise***REMOVED***.

    Take a sequence of arrays and stack them horizontally to make
    a single array. Rebuild arrays divided by `hsplit`.

    Parameters
    ----------
    tup : sequence of ndarrays
        All arrays must have the same shape along all but the second axis.

    Returns
    -------
    stacked : ndarray
        The array formed by stacking the given arrays.

    See Also
    --------
    stack : Join a sequence of arrays along a new axis.
    vstack : Stack arrays in sequence vertically (row wise***REMOVED***.
    dstack : Stack arrays in sequence depth wise (along third axis***REMOVED***.
    concatenate : Join a sequence of arrays along an existing axis.
    hsplit : Split array along second axis.

    Notes
    -----
    Equivalent to ``np.concatenate(tup, axis=1***REMOVED***``

    Examples
    --------
    >>> a = np.array((1,2,3***REMOVED******REMOVED***
    >>> b = np.array((2,3,4***REMOVED******REMOVED***
    >>> np.hstack((a,b***REMOVED******REMOVED***
    array([1, 2, 3, 2, 3, 4***REMOVED******REMOVED***
    >>> a = np.array([[1***REMOVED***,[2***REMOVED***,[3***REMOVED******REMOVED******REMOVED***
    >>> b = np.array([[2***REMOVED***,[3***REMOVED***,[4***REMOVED******REMOVED******REMOVED***
    >>> np.hstack((a,b***REMOVED******REMOVED***
    array([[1, 2***REMOVED***,
           [2, 3***REMOVED***,
           [3, 4***REMOVED******REMOVED******REMOVED***

    ***REMOVED***
    arrs = [atleast_1d(_m***REMOVED*** for _m in tup***REMOVED***
    # As a special case, dimension 0 of 1-dimensional arrays is "horizontal"
    if arrs[0***REMOVED***.ndim == 1:
        return _nx.concatenate(arrs, 0***REMOVED***
    else:
        return _nx.concatenate(arrs, 1***REMOVED***

def stack(arrays, axis=0***REMOVED***:
    ***REMOVED***
    Join a sequence of arrays along a new axis.

    The `axis` parameter specifies the index of the new axis in the dimensions
    of the result. For example, if ``axis=0`` it will be the first dimension
    and if ``axis=-1`` it will be the last dimension.

    .. versionadded:: 1.10.0

    Parameters
    ----------
    arrays : sequence of array_like
        Each array must have the same shape.
    axis : int, optional
        The axis in the result array along which the input arrays are stacked.

    Returns
    -------
    stacked : ndarray
        The stacked array has one more dimension than the input arrays.

    See Also
    --------
    concatenate : Join a sequence of arrays along an existing axis.
    split : Split array into a list of multiple sub-arrays of equal size.

    Examples
    --------
    >>> arrays = [np.random.randn(3, 4***REMOVED*** for _ in range(10***REMOVED******REMOVED***
    >>> np.stack(arrays, axis=0***REMOVED***.shape
    (10, 3, 4***REMOVED***

    >>> np.stack(arrays, axis=1***REMOVED***.shape
    (3, 10, 4***REMOVED***

    >>> np.stack(arrays, axis=2***REMOVED***.shape
    (3, 4, 10***REMOVED***

    >>> a = np.array([1, 2, 3***REMOVED******REMOVED***
    >>> b = np.array([2, 3, 4***REMOVED******REMOVED***
    >>> np.stack((a, b***REMOVED******REMOVED***
    array([[1, 2, 3***REMOVED***,
           [2, 3, 4***REMOVED******REMOVED******REMOVED***

    >>> np.stack((a, b***REMOVED***, axis=-1***REMOVED***
    array([[1, 2***REMOVED***,
           [2, 3***REMOVED***,
           [3, 4***REMOVED******REMOVED******REMOVED***

    ***REMOVED***
    arrays = [asanyarray(arr***REMOVED*** for arr in arrays***REMOVED***
    if not arrays:
        raise ValueError('need at least one array to stack'***REMOVED***

    shapes = set(arr.shape for arr in arrays***REMOVED***
    if len(shapes***REMOVED*** != 1:
        raise ValueError('all input arrays must have the same shape'***REMOVED***

    result_ndim = arrays[0***REMOVED***.ndim + 1
    if not -result_ndim <= axis < result_ndim:
        msg = 'axis {0***REMOVED*** out of bounds [-{1***REMOVED***, {1***REMOVED******REMOVED***'.format(axis, result_ndim***REMOVED***
        raise IndexError(msg***REMOVED***
    if axis < 0:
        axis += result_ndim

    sl = (slice(None***REMOVED***,***REMOVED*** * axis + (_nx.newaxis,***REMOVED***
    expanded_arrays = [arr[sl***REMOVED*** for arr in arrays***REMOVED***
    return _nx.concatenate(expanded_arrays, axis=axis***REMOVED***
