***REMOVED***Array printing function

$Id: arrayprint.py,v 1.9 2005/09/13 13:58:44 teoliphant Exp $

***REMOVED***
from __future__ import division, absolute_import, print_function

__all__ = ["array2string", "set_printoptions", "get_printoptions"***REMOVED***
__docformat__ = 'restructuredtext'

#
# Written by Konrad Hinsen <hinsenk@ere.umontreal.ca>
# last revision: 1996-3-13
# modified by Jim Hugunin 1997-3-3 for repr's and str's (and other details***REMOVED***
# and by Perry Greenfield 2000-4-1 for numarray
# and by Travis Oliphant  2005-8-22 for numpy

import sys
from functools import reduce
from . import numerictypes as _nt
from .umath import maximum, minimum, absolute, not_equal, isnan, isinf
from .multiarray import (array, format_longfloat, datetime_as_string,
                         datetime_data***REMOVED***
from .fromnumeric import ravel
from .numeric import asarray

if sys.version_info[0***REMOVED*** >= 3:
    _MAXINT = sys.maxsize
    _MININT = -sys.maxsize - 1
else:
    _MAXINT = sys.maxint
    _MININT = -sys.maxint - 1

def product(x, y***REMOVED***:
    return x*y

_summaryEdgeItems = 3     # repr N leading and trailing items of each dimension
_summaryThreshold = 1000  # total items > triggers array summarization

_float_output_precision = 8
_float_output_suppress_small = False
_line_width = 75
_nan_str = 'nan'
_inf_str = 'inf'
_formatter = None  # formatting function for array elements


def set_printoptions(precision=None, threshold=None, edgeitems=None,
                     linewidth=None, suppress=None,
                     nanstr=None, infstr=None,
                     formatter=None***REMOVED***:
    ***REMOVED***
    Set printing options.

    These options determine the way floating point numbers, arrays and
    other NumPy objects are displayed.

    Parameters
    ----------
    precision : int, optional
        Number of digits of precision for floating point output (default 8***REMOVED***.
    threshold : int, optional
        Total number of array elements which trigger summarization
        rather than full repr (default 1000***REMOVED***.
    edgeitems : int, optional
        Number of array items in summary at beginning and end of
        each dimension (default 3***REMOVED***.
    linewidth : int, optional
        The number of characters per line for the purpose of inserting
        line breaks (default 75***REMOVED***.
    suppress : bool, optional
        Whether or not suppress printing of small floating point values
        using scientific notation (default False***REMOVED***.
    nanstr : str, optional
        String representation of floating point not-a-number (default nan***REMOVED***.
    infstr : str, optional
        String representation of floating point infinity (default inf***REMOVED***.
    formatter : dict of callables, optional
        If not None, the keys should indicate the type(s***REMOVED*** that the respective
        formatting function applies to.  Callables should return a string.
        Types that are not specified (by their corresponding keys***REMOVED*** are handled
        by the default formatters.  Individual types for which a formatter
        can be set are::

            - 'bool'
            - 'int'
            - 'timedelta' : a `numpy.timedelta64`
            - 'datetime' : a `numpy.datetime64`
            - 'float'
            - 'longfloat' : 128-bit floats
            - 'complexfloat'
            - 'longcomplexfloat' : composed of two 128-bit floats
            - 'numpy_str' : types `numpy.string_` and `numpy.unicode_`
            - 'str' : all other strings

        Other keys that can be used to set a group of types at once are::

            - 'all' : sets all types
            - 'int_kind' : sets 'int'
            - 'float_kind' : sets 'float' and 'longfloat'
            - 'complex_kind' : sets 'complexfloat' and 'longcomplexfloat'
            - 'str_kind' : sets 'str' and 'numpystr'

    See Also
    --------
    get_printoptions, set_string_function, array2string

    Notes
    -----
    `formatter` is always reset with a call to `set_printoptions`.

    Examples
    --------
    Floating point precision can be set:

    >>> np.set_printoptions(precision=4***REMOVED***
    >>> print(np.array([1.123456789***REMOVED******REMOVED******REMOVED***
    [ 1.1235***REMOVED***

    Long arrays can be summarised:

    >>> np.set_printoptions(threshold=5***REMOVED***
    >>> print(np.arange(10***REMOVED******REMOVED***
    [0 1 2 ..., 7 8 9***REMOVED***

    Small results can be suppressed:

    >>> eps = np.finfo(float***REMOVED***.eps
    >>> x = np.arange(4.***REMOVED***
    >>> x**2 - (x + eps***REMOVED*****2
    array([ -4.9304e-32,  -4.4409e-16,   0.0000e+00,   0.0000e+00***REMOVED******REMOVED***
    >>> np.set_printoptions(suppress=True***REMOVED***
    >>> x**2 - (x + eps***REMOVED*****2
    array([-0., -0.,  0.,  0.***REMOVED******REMOVED***

    A custom formatter can be used to display array elements as desired:

    >>> np.set_printoptions(formatter={'all':lambda x: 'int: '+str(-x***REMOVED******REMOVED******REMOVED***
    >>> x = np.arange(3***REMOVED***
    >>> x
    array([int: 0, int: -1, int: -2***REMOVED******REMOVED***
    >>> np.set_printoptions(***REMOVED***  # formatter gets reset
    >>> x
    array([0, 1, 2***REMOVED******REMOVED***

    To put back the default options, you can use:

    >>> np.set_printoptions(edgeitems=3,infstr='inf',
    ... linewidth=75, nanstr='nan', precision=8,
    ... suppress=False, threshold=1000, formatter=None***REMOVED***
    ***REMOVED***

    global _summaryThreshold, _summaryEdgeItems, _float_output_precision
    global _line_width, _float_output_suppress_small, _nan_str, _inf_str
    global _formatter

    if linewidth is not None:
        _line_width = linewidth
    if threshold is not None:
        _summaryThreshold = threshold
    if edgeitems is not None:
        _summaryEdgeItems = edgeitems
    if precision is not None:
        _float_output_precision = precision
    if suppress is not None:
        _float_output_suppress_small = not not suppress
    if nanstr is not None:
        _nan_str = nanstr
    if infstr is not None:
        _inf_str = infstr
    _formatter = formatter

def get_printoptions(***REMOVED***:
    ***REMOVED***
    Return the current print options.

    Returns
    -------
    print_opts : dict
        Dictionary of current print options with keys

          - precision : int
          - threshold : int
          - edgeitems : int
          - linewidth : int
          - suppress : bool
          - nanstr : str
          - infstr : str
          - formatter : dict of callables

        For a full description of these options, see `set_printoptions`.

    See Also
    --------
    set_printoptions, set_string_function

    ***REMOVED***
    d = dict(precision=_float_output_precision,
             threshold=_summaryThreshold,
             edgeitems=_summaryEdgeItems,
             linewidth=_line_width,
             suppress=_float_output_suppress_small,
             nanstr=_nan_str,
             infstr=_inf_str,
             formatter=_formatter***REMOVED***
    return d

def _leading_trailing(a***REMOVED***:
    from . import numeric as _nc
    if a.ndim == 1:
        if len(a***REMOVED*** > 2*_summaryEdgeItems:
            b = _nc.concatenate((a[:_summaryEdgeItems***REMOVED***,
                                     a[-_summaryEdgeItems:***REMOVED******REMOVED******REMOVED***
        else:
            b = a
    else:
        if len(a***REMOVED*** > 2*_summaryEdgeItems:
            l = [_leading_trailing(a[i***REMOVED******REMOVED*** for i in range(
                min(len(a***REMOVED***, _summaryEdgeItems***REMOVED******REMOVED******REMOVED***
            l.extend([_leading_trailing(a[-i***REMOVED******REMOVED*** for i in range(
                min(len(a***REMOVED***, _summaryEdgeItems***REMOVED***, 0, -1***REMOVED******REMOVED******REMOVED***
        else:
            l = [_leading_trailing(a[i***REMOVED******REMOVED*** for i in range(0, len(a***REMOVED******REMOVED******REMOVED***
        b = _nc.concatenate(tuple(l***REMOVED******REMOVED***
    return b

def _boolFormatter(x***REMOVED***:
    if x:
        return ' True'
    else:
        return 'False'


def repr_format(x***REMOVED***:
    return repr(x***REMOVED***

def _array2string(a, max_line_width, precision, suppress_small, separator=' ',
                  prefix="", formatter=None***REMOVED***:

    if max_line_width is None:
        max_line_width = _line_width

    if precision is None:
        precision = _float_output_precision

    if suppress_small is None:
        suppress_small = _float_output_suppress_small

    if formatter is None:
        formatter = _formatter

    if a.size > _summaryThreshold:
        summary_insert = "..., "
        data = _leading_trailing(a***REMOVED***
    else:
        summary_insert = ""
        data = ravel(asarray(a***REMOVED******REMOVED***

    formatdict = {'bool': _boolFormatter,
                  'int': IntegerFormat(data***REMOVED***,
                  'float': FloatFormat(data, precision, suppress_small***REMOVED***,
                  'longfloat': LongFloatFormat(precision***REMOVED***,
                  'complexfloat': ComplexFormat(data, precision,
                                                 suppress_small***REMOVED***,
                  'longcomplexfloat': LongComplexFormat(precision***REMOVED***,
                  'datetime': DatetimeFormat(data***REMOVED***,
                  'timedelta': TimedeltaFormat(data***REMOVED***,
                  'numpystr': repr_format,
                  'str': str***REMOVED***

    if formatter is not None:
        fkeys = [k for k in formatter.keys(***REMOVED*** if formatter[k***REMOVED*** is not None***REMOVED***
        if 'all' in fkeys:
            for key in formatdict.keys(***REMOVED***:
                formatdict[key***REMOVED*** = formatter['all'***REMOVED***
        if 'int_kind' in fkeys:
            for key in ['int'***REMOVED***:
                formatdict[key***REMOVED*** = formatter['int_kind'***REMOVED***
        if 'float_kind' in fkeys:
            for key in ['float', 'longfloat'***REMOVED***:
                formatdict[key***REMOVED*** = formatter['float_kind'***REMOVED***
        if 'complex_kind' in fkeys:
            for key in ['complexfloat', 'longcomplexfloat'***REMOVED***:
                formatdict[key***REMOVED*** = formatter['complex_kind'***REMOVED***
        if 'str_kind' in fkeys:
            for key in ['numpystr', 'str'***REMOVED***:
                formatdict[key***REMOVED*** = formatter['str_kind'***REMOVED***
        for key in formatdict.keys(***REMOVED***:
            if key in fkeys:
                formatdict[key***REMOVED*** = formatter[key***REMOVED***

    # find the right formatting function for the array
    dtypeobj = a.dtype.type
    if issubclass(dtypeobj, _nt.bool_***REMOVED***:
        format_function = formatdict['bool'***REMOVED***
    elif issubclass(dtypeobj, _nt.integer***REMOVED***:
        if issubclass(dtypeobj, _nt.timedelta64***REMOVED***:
            format_function = formatdict['timedelta'***REMOVED***
        else:
            format_function = formatdict['int'***REMOVED***
    elif issubclass(dtypeobj, _nt.floating***REMOVED***:
        if issubclass(dtypeobj, _nt.longfloat***REMOVED***:
            format_function = formatdict['longfloat'***REMOVED***
        else:
            format_function = formatdict['float'***REMOVED***
    elif issubclass(dtypeobj, _nt.complexfloating***REMOVED***:
        if issubclass(dtypeobj, _nt.clongfloat***REMOVED***:
            format_function = formatdict['longcomplexfloat'***REMOVED***
        else:
            format_function = formatdict['complexfloat'***REMOVED***
    elif issubclass(dtypeobj, (_nt.unicode_, _nt.string_***REMOVED******REMOVED***:
        format_function = formatdict['numpystr'***REMOVED***
    elif issubclass(dtypeobj, _nt.datetime64***REMOVED***:
        format_function = formatdict['datetime'***REMOVED***
    else:
        format_function = formatdict['numpystr'***REMOVED***

    # skip over "["
    next_line_prefix = " "
    # skip over array(
    next_line_prefix += " "*len(prefix***REMOVED***

    lst = _formatArray(a, format_function, len(a.shape***REMOVED***, max_line_width,
                       next_line_prefix, separator,
                       _summaryEdgeItems, summary_insert***REMOVED***[:-1***REMOVED***
    return lst

def _convert_arrays(obj***REMOVED***:
    from . import numeric as _nc
    newtup = [***REMOVED***
    for k in obj:
        if isinstance(k, _nc.ndarray***REMOVED***:
            k = k.tolist(***REMOVED***
        elif isinstance(k, tuple***REMOVED***:
            k = _convert_arrays(k***REMOVED***
        newtup.append(k***REMOVED***
    return tuple(newtup***REMOVED***


def array2string(a, max_line_width=None, precision=None,
                 suppress_small=None, separator=' ', prefix="",
                 style=repr, formatter=None***REMOVED***:
    ***REMOVED***
    Return a string representation of an array.

    Parameters
    ----------
    a : ndarray
        Input array.
    max_line_width : int, optional
        The maximum number of columns the string should span. Newline
        characters splits the string appropriately after array elements.
    precision : int, optional
        Floating point precision. Default is the current printing
        precision (usually 8***REMOVED***, which can be altered using `set_printoptions`.
    suppress_small : bool, optional
        Represent very small numbers as zero. A number is "very small" if it
        is smaller than the current printing precision.
    separator : str, optional
        Inserted between elements.
    prefix : str, optional
        An array is typically printed as::

          'prefix(' + array2string(a***REMOVED*** + '***REMOVED***'

        The length of the prefix string is used to align the
        output correctly.
    style : function, optional
        A function that accepts an ndarray and returns a string.  Used only
        when the shape of `a` is equal to ``(***REMOVED***``, i.e. for 0-D arrays.
    formatter : dict of callables, optional
        If not None, the keys should indicate the type(s***REMOVED*** that the respective
        formatting function applies to.  Callables should return a string.
        Types that are not specified (by their corresponding keys***REMOVED*** are handled
        by the default formatters.  Individual types for which a formatter
        can be set are::

            - 'bool'
            - 'int'
            - 'timedelta' : a `numpy.timedelta64`
            - 'datetime' : a `numpy.datetime64`
            - 'float'
            - 'longfloat' : 128-bit floats
            - 'complexfloat'
            - 'longcomplexfloat' : composed of two 128-bit floats
            - 'numpy_str' : types `numpy.string_` and `numpy.unicode_`
            - 'str' : all other strings

        Other keys that can be used to set a group of types at once are::

            - 'all' : sets all types
            - 'int_kind' : sets 'int'
            - 'float_kind' : sets 'float' and 'longfloat'
            - 'complex_kind' : sets 'complexfloat' and 'longcomplexfloat'
            - 'str_kind' : sets 'str' and 'numpystr'

    Returns
    -------
    array_str : str
        String representation of the array.

    Raises
    ------
    TypeError
        if a callable in `formatter` does not return a string.

    See Also
    --------
    array_str, array_repr, set_printoptions, get_printoptions

    Notes
    -----
    If a formatter is specified for a certain type, the `precision` keyword is
    ignored for that type.

    This is a very flexible function; `array_repr` and `array_str` are using
    `array2string` internally so keywords with the same name should work
    identically in all three functions.

    Examples
    --------
    >>> x = np.array([1e-16,1,2,3***REMOVED******REMOVED***
    >>> print(np.array2string(x, precision=2, separator=',',
    ...                       suppress_small=True***REMOVED******REMOVED***
    [ 0., 1., 2., 3.***REMOVED***

    >>> x  = np.arange(3.***REMOVED***
    >>> np.array2string(x, formatter={'float_kind':lambda x: "%.2f" % x***REMOVED******REMOVED***
    '[0.00 1.00 2.00***REMOVED***'

    >>> x  = np.arange(3***REMOVED***
    >>> np.array2string(x, formatter={'int':lambda x: hex(x***REMOVED******REMOVED******REMOVED***
    '[0x0L 0x1L 0x2L***REMOVED***'

    ***REMOVED***

    if a.shape == (***REMOVED***:
        x = a.item(***REMOVED***
        if isinstance(x, tuple***REMOVED***:
            x = _convert_arrays(x***REMOVED***
        lst = style(x***REMOVED***
    elif reduce(product, a.shape***REMOVED*** == 0:
        # treat as a null array if any of shape elements == 0
        lst = "[***REMOVED***"
    else:
        lst = _array2string(a, max_line_width, precision, suppress_small,
                            separator, prefix, formatter=formatter***REMOVED***
    return lst

def _extendLine(s, line, word, max_line_len, next_line_prefix***REMOVED***:
    if len(line.rstrip(***REMOVED******REMOVED*** + len(word.rstrip(***REMOVED******REMOVED*** >= max_line_len:
        s += line.rstrip(***REMOVED*** + "\n"
        line = next_line_prefix
    line += word
    return s, line


def _formatArray(a, format_function, rank, max_line_len,
                 next_line_prefix, separator, edge_items, summary_insert***REMOVED***:
    ***REMOVED***formatArray is designed for two modes of operation:

    1. Full output

    2. Summarized output

    ***REMOVED***
    if rank == 0:
        obj = a.item(***REMOVED***
        if isinstance(obj, tuple***REMOVED***:
            obj = _convert_arrays(obj***REMOVED***
        return str(obj***REMOVED***

    if summary_insert and 2*edge_items < len(a***REMOVED***:
        leading_items = edge_items
        trailing_items = edge_items
        summary_insert1 = summary_insert
    else:
        leading_items = 0
        trailing_items = len(a***REMOVED***
        summary_insert1 = ""

    if rank == 1:
        s = ""
        line = next_line_prefix
        for i in range(leading_items***REMOVED***:
            word = format_function(a[i***REMOVED******REMOVED*** + separator
            s, line = _extendLine(s, line, word, max_line_len, next_line_prefix***REMOVED***

        if summary_insert1:
            s, line = _extendLine(s, line, summary_insert1, max_line_len, next_line_prefix***REMOVED***

        for i in range(trailing_items, 1, -1***REMOVED***:
            word = format_function(a[-i***REMOVED******REMOVED*** + separator
            s, line = _extendLine(s, line, word, max_line_len, next_line_prefix***REMOVED***

        word = format_function(a[-1***REMOVED******REMOVED***
        s, line = _extendLine(s, line, word, max_line_len, next_line_prefix***REMOVED***
        s += line + "***REMOVED***\n"
        s = '[' + s[len(next_line_prefix***REMOVED***:***REMOVED***
    else:
        s = '['
        sep = separator.rstrip(***REMOVED***
        for i in range(leading_items***REMOVED***:
            if i > 0:
                s += next_line_prefix
            s += _formatArray(a[i***REMOVED***, format_function, rank-1, max_line_len,
                              " " + next_line_prefix, separator, edge_items,
                              summary_insert***REMOVED***
            s = s.rstrip(***REMOVED*** + sep.rstrip(***REMOVED*** + '\n'*max(rank-1, 1***REMOVED***

        if summary_insert1:
            s += next_line_prefix + summary_insert1 + "\n"

        for i in range(trailing_items, 1, -1***REMOVED***:
            if leading_items or i != trailing_items:
                s += next_line_prefix
            s += _formatArray(a[-i***REMOVED***, format_function, rank-1, max_line_len,
                              " " + next_line_prefix, separator, edge_items,
                              summary_insert***REMOVED***
            s = s.rstrip(***REMOVED*** + sep.rstrip(***REMOVED*** + '\n'*max(rank-1, 1***REMOVED***
        if leading_items or trailing_items > 1:
            s += next_line_prefix
        s += _formatArray(a[-1***REMOVED***, format_function, rank-1, max_line_len,
                          " " + next_line_prefix, separator, edge_items,
                          summary_insert***REMOVED***.rstrip(***REMOVED***+'***REMOVED***\n'
    return s

class FloatFormat(object***REMOVED***:
    def __init__(self, data, precision, suppress_small, sign=False***REMOVED***:
        self.precision = precision
        self.suppress_small = suppress_small
        self.sign = sign
        self.exp_format = False
        self.large_exponent = False
        self.max_str_len = 0
        ***REMOVED***
            self.fillFormat(data***REMOVED***
        except (TypeError, NotImplementedError***REMOVED***:
            # if reduce(data***REMOVED*** fails, this instance will not be called, just
            # instantiated in formatdict.
            pass

    def fillFormat(self, data***REMOVED***:
        from . import numeric as _nc

        with _nc.errstate(all='ignore'***REMOVED***:
            special = isnan(data***REMOVED*** | isinf(data***REMOVED***
            valid = not_equal(data, 0***REMOVED*** & ~special
            non_zero = absolute(data.compress(valid***REMOVED******REMOVED***
            if len(non_zero***REMOVED*** == 0:
                max_val = 0.
                min_val = 0.
            else:
                max_val = maximum.reduce(non_zero***REMOVED***
                min_val = minimum.reduce(non_zero***REMOVED***
                if max_val >= 1.e8:
                    self.exp_format = True
                if not self.suppress_small and (min_val < 0.0001
                                           or max_val/min_val > 1000.***REMOVED***:
                    self.exp_format = True

        if self.exp_format:
            self.large_exponent = 0 < min_val < 1e-99 or max_val >= 1e100
            self.max_str_len = 8 + self.precision
            if self.large_exponent:
                self.max_str_len += 1
            if self.sign:
                format = '%+'
            else:
                format = '%'
            format = format + '%d.%de' % (self.max_str_len, self.precision***REMOVED***
        else:
            format = '%%.%df' % (self.precision,***REMOVED***
            if len(non_zero***REMOVED***:
                precision = max([_digits(x, self.precision, format***REMOVED***
                                 for x in non_zero***REMOVED******REMOVED***
            else:
                precision = 0
            precision = min(self.precision, precision***REMOVED***
            self.max_str_len = len(str(int(max_val***REMOVED******REMOVED******REMOVED*** + precision + 2
            if _nc.any(special***REMOVED***:
                self.max_str_len = max(self.max_str_len,
                                       len(_nan_str***REMOVED***,
                                       len(_inf_str***REMOVED***+1***REMOVED***
            if self.sign:
                format = '%#+'
            else:
                format = '%#'
            format = format + '%d.%df' % (self.max_str_len, precision***REMOVED***

        self.special_fmt = '%%%ds' % (self.max_str_len,***REMOVED***
        self.format = format

    def __call__(self, x, strip_zeros=True***REMOVED***:
        from . import numeric as _nc

        with _nc.errstate(invalid='ignore'***REMOVED***:
            if isnan(x***REMOVED***:
                if self.sign:
                    return self.special_fmt % ('+' + _nan_str,***REMOVED***
                else:
                    return self.special_fmt % (_nan_str,***REMOVED***
            elif isinf(x***REMOVED***:
                if x > 0:
                    if self.sign:
                        return self.special_fmt % ('+' + _inf_str,***REMOVED***
                    else:
                        return self.special_fmt % (_inf_str,***REMOVED***
                else:
                    return self.special_fmt % ('-' + _inf_str,***REMOVED***

        s = self.format % x
        if self.large_exponent:
            # 3-digit exponent
            expsign = s[-3***REMOVED***
            if expsign == '+' or expsign == '-':
                s = s[1:-2***REMOVED*** + '0' + s[-2:***REMOVED***
        elif self.exp_format:
            # 2-digit exponent
            if s[-3***REMOVED*** == '0':
                s = ' ' + s[:-3***REMOVED*** + s[-2:***REMOVED***
        elif strip_zeros:
            z = s.rstrip('0'***REMOVED***
            s = z + ' '*(len(s***REMOVED***-len(z***REMOVED******REMOVED***
        return s


def _digits(x, precision, format***REMOVED***:
    s = format % x
    z = s.rstrip('0'***REMOVED***
    return precision - len(s***REMOVED*** + len(z***REMOVED***


class IntegerFormat(object***REMOVED***:
    def __init__(self, data***REMOVED***:
        ***REMOVED***
            max_str_len = max(len(str(maximum.reduce(data***REMOVED******REMOVED******REMOVED***,
                              len(str(minimum.reduce(data***REMOVED******REMOVED******REMOVED******REMOVED***
            self.format = '%' + str(max_str_len***REMOVED*** + 'd'
        except (TypeError, NotImplementedError***REMOVED***:
            # if reduce(data***REMOVED*** fails, this instance will not be called, just
            # instantiated in formatdict.
            pass
        except ValueError:
            # this occurs when everything is NA
            pass

    def __call__(self, x***REMOVED***:
        if _MININT < x < _MAXINT:
            return self.format % x
        else:
            return "%s" % x

class LongFloatFormat(object***REMOVED***:
    # XXX Have to add something to determine the width to use a la FloatFormat
    # Right now, things won't line up properly
    def __init__(self, precision, sign=False***REMOVED***:
        self.precision = precision
        self.sign = sign

    def __call__(self, x***REMOVED***:
        if isnan(x***REMOVED***:
            if self.sign:
                return '+' + _nan_str
            else:
                return ' ' + _nan_str
        elif isinf(x***REMOVED***:
            if x > 0:
                if self.sign:
                    return '+' + _inf_str
                else:
                    return ' ' + _inf_str
            else:
                return '-' + _inf_str
        elif x >= 0:
            if self.sign:
                return '+' + format_longfloat(x, self.precision***REMOVED***
            else:
                return ' ' + format_longfloat(x, self.precision***REMOVED***
        else:
            return format_longfloat(x, self.precision***REMOVED***


class LongComplexFormat(object***REMOVED***:
    def __init__(self, precision***REMOVED***:
        self.real_format = LongFloatFormat(precision***REMOVED***
        self.imag_format = LongFloatFormat(precision, sign=True***REMOVED***

    def __call__(self, x***REMOVED***:
        r = self.real_format(x.real***REMOVED***
        i = self.imag_format(x.imag***REMOVED***
        return r + i + 'j'


class ComplexFormat(object***REMOVED***:
    def __init__(self, x, precision, suppress_small***REMOVED***:
        self.real_format = FloatFormat(x.real, precision, suppress_small***REMOVED***
        self.imag_format = FloatFormat(x.imag, precision, suppress_small,
                                       sign=True***REMOVED***

    def __call__(self, x***REMOVED***:
        r = self.real_format(x.real, strip_zeros=False***REMOVED***
        i = self.imag_format(x.imag, strip_zeros=False***REMOVED***
        if not self.imag_format.exp_format:
            z = i.rstrip('0'***REMOVED***
            i = z + 'j' + ' '*(len(i***REMOVED***-len(z***REMOVED******REMOVED***
        else:
            i = i + 'j'
        return r + i


class DatetimeFormat(object***REMOVED***:
    def __init__(self, x, unit=None, timezone=None, casting='same_kind'***REMOVED***:
        # Get the unit from the dtype
        if unit is None:
            if x.dtype.kind == 'M':
                unit = datetime_data(x.dtype***REMOVED***[0***REMOVED***
            else:
                unit = 's'

        if timezone is None:
            timezone = 'naive'
        self.timezone = timezone
        self.unit = unit
        self.casting = casting

    def __call__(self, x***REMOVED***:
        return "'%s'" % datetime_as_string(x,
                                    unit=self.unit,
                                    timezone=self.timezone,
                                    casting=self.casting***REMOVED***

class TimedeltaFormat(object***REMOVED***:
    def __init__(self, data***REMOVED***:
        if data.dtype.kind == 'm':
            nat_value = array(['NaT'***REMOVED***, dtype=data.dtype***REMOVED***[0***REMOVED***
            v = data[not_equal(data, nat_value***REMOVED******REMOVED***.view('i8'***REMOVED***
            if len(v***REMOVED*** > 0:
                # Max str length of non-NaT elements
                max_str_len = max(len(str(maximum.reduce(v***REMOVED******REMOVED******REMOVED***,
                                  len(str(minimum.reduce(v***REMOVED******REMOVED******REMOVED******REMOVED***
            else:
                max_str_len = 0
            if len(v***REMOVED*** < len(data***REMOVED***:
                # data contains a NaT
                max_str_len = max(max_str_len, 5***REMOVED***
            self.format = '%' + str(max_str_len***REMOVED*** + 'd'
            self._nat = "'NaT'".rjust(max_str_len***REMOVED***

    def __call__(self, x***REMOVED***:
        if x + 1 == x:
            return self._nat
        else:
            return self.format % x.astype('i8'***REMOVED***
