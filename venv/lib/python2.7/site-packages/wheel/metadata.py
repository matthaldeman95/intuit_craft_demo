***REMOVED***
Tools for converting old- to new-style metadata.
***REMOVED***

from collections import namedtuple
from .pkginfo import read_pkg_info
from .util import OrderedDefaultDict
***REMOVED***
    from collections import OrderedDict
except ImportError:
    OrderedDict = dict

import re
***REMOVED***.path
import textwrap
import pkg_resources
import email.parser

from . import __version__ as wheel_version

METADATA_VERSION = "2.0"

PLURAL_FIELDS = { "classifier" : "classifiers",
                  "provides_dist" : "provides",
                  "provides_extra" : "extras" ***REMOVED***

SKIP_FIELDS = set(***REMOVED***

CONTACT_FIELDS = (({"email":"author_email", "name": "author"***REMOVED***,
                    "author"***REMOVED***,
                  ({"email":"maintainer_email", "name": "maintainer"***REMOVED***,
                    "maintainer"***REMOVED******REMOVED***

# commonly filled out as "UNKNOWN" by distutils:
UNKNOWN_FIELDS = set(("author", "author_email", "platform", "home_page",
                      "license"***REMOVED******REMOVED***

# Wheel itself is probably the only program that uses non-extras markers
# in METADATA/PKG-INFO. Support its syntax with the extra at the end only.
EXTRA_RE = re.compile(***REMOVED***^(?P<package>.*?***REMOVED***(;\s*(?P<condition>.*?***REMOVED***(extra == '(?P<extra>.*?***REMOVED***'***REMOVED***?***REMOVED***$***REMOVED******REMOVED***
KEYWORDS_RE = re.compile("[\0-,***REMOVED***+"***REMOVED***

MayRequiresKey = namedtuple('MayRequiresKey', ('condition', 'extra'***REMOVED******REMOVED***

def unique(iterable***REMOVED***:
    ***REMOVED***
    Yield unique values in iterable, preserving order.
    ***REMOVED***
    seen = set(***REMOVED***
    for value in iterable:
        if not value in seen:
            seen.add(value***REMOVED***
            yield value


def handle_requires(metadata, pkg_info, key***REMOVED***:
    ***REMOVED***
    Place the runtime requirements from pkg_info into metadata.
    ***REMOVED***
    may_requires = OrderedDefaultDict(list***REMOVED***
    for value in sorted(pkg_info.get_all(key***REMOVED******REMOVED***:
        extra_match = EXTRA_RE.search(value***REMOVED***
        if extra_match:
            groupdict = extra_match.groupdict(***REMOVED***
            condition = groupdict['condition'***REMOVED***
            extra = groupdict['extra'***REMOVED***
            package = groupdict['package'***REMOVED***
            if condition.endswith(' and '***REMOVED***:
                condition = condition[:-5***REMOVED***
        else:
            condition, extra = None, None
            package = value
        key = MayRequiresKey(condition, extra***REMOVED***
        may_requires[key***REMOVED***.append(package***REMOVED***

    if may_requires:
        metadata['run_requires'***REMOVED*** = [***REMOVED***
        def sort_key(item***REMOVED***:
            # Both condition and extra could be None, which can't be compared
            # against strings in Python 3.
            key, value = item
            if key.condition is None:
                return ''
            return key.condition
        for key, value in sorted(may_requires.items(***REMOVED***, key=sort_key***REMOVED***:
            may_requirement = OrderedDict((('requires', value***REMOVED***,***REMOVED******REMOVED***
            if key.extra:
                may_requirement['extra'***REMOVED*** = key.extra
            if key.condition:
                may_requirement['environment'***REMOVED*** = key.condition
            metadata['run_requires'***REMOVED***.append(may_requirement***REMOVED***

        if not 'extras' in metadata:
            metadata['extras'***REMOVED*** = [***REMOVED***
        metadata['extras'***REMOVED***.extend([key.extra for key in may_requires.keys(***REMOVED*** if key.extra***REMOVED******REMOVED***


def pkginfo_to_dict(path, distribution=None***REMOVED***:
    ***REMOVED***
    Convert PKG-INFO to a prototype Metadata 2.0 (PEP 426***REMOVED*** dict.

    The description is included under the key ['description'***REMOVED*** rather than
    being written to a separate file.

    path: path to PKG-INFO file
    distribution: optional distutils Distribution(***REMOVED***
    ***REMOVED***

    metadata = OrderedDefaultDict(lambda: OrderedDefaultDict(lambda: OrderedDefaultDict(OrderedDict***REMOVED******REMOVED******REMOVED***
    metadata["generator"***REMOVED*** = "bdist_wheel (" + wheel_version + "***REMOVED***"
    ***REMOVED***
        unicode
        pkg_info = read_pkg_info(path***REMOVED***
    except NameError:
        with open(path, 'rb'***REMOVED*** as pkg_info_file:
            pkg_info = email.parser.Parser(***REMOVED***.parsestr(pkg_info_file.read(***REMOVED***.decode('utf-8'***REMOVED******REMOVED***
    description = None

    if pkg_info['Summary'***REMOVED***:
        metadata['summary'***REMOVED*** = pkginfo_unicode(pkg_info, 'Summary'***REMOVED***
        del pkg_info['Summary'***REMOVED***

    if pkg_info['Description'***REMOVED***:
        description = dedent_description(pkg_info***REMOVED***
        del pkg_info['Description'***REMOVED***
    else:
        payload = pkg_info.get_payload(***REMOVED***
        if isinstance(payload, bytes***REMOVED***:
            # Avoid a Python 2 Unicode error.
            # We still suffer ? glyphs on Python 3.
            payload = payload.decode('utf-8'***REMOVED***
        if payload:
            description = payload

    if description:
        pkg_info['description'***REMOVED*** = description

    for key in sorted(unique(k.lower(***REMOVED*** for k in pkg_info.keys(***REMOVED******REMOVED******REMOVED***:
        low_key = key.replace('-', '_'***REMOVED***

        if low_key in SKIP_FIELDS:
            continue

        if low_key in UNKNOWN_FIELDS and pkg_info.get(key***REMOVED*** == 'UNKNOWN':
            continue

        if low_key in sorted(PLURAL_FIELDS***REMOVED***:
            metadata[PLURAL_FIELDS[low_key***REMOVED******REMOVED*** = pkg_info.get_all(key***REMOVED***

        elif low_key == "requires_dist":
            handle_requires(metadata, pkg_info, key***REMOVED***

        elif low_key == 'provides_extra':
            if not 'extras' in metadata:
                metadata['extras'***REMOVED*** = [***REMOVED***
            metadata['extras'***REMOVED***.extend(pkg_info.get_all(key***REMOVED******REMOVED***

        elif low_key == 'home_page':
            metadata['extensions'***REMOVED***['python.details'***REMOVED***['project_urls'***REMOVED*** = {'Home':pkg_info[key***REMOVED******REMOVED***

        elif low_key == 'keywords':
            metadata['keywords'***REMOVED*** = KEYWORDS_RE.split(pkg_info[key***REMOVED******REMOVED***

        else:
            metadata[low_key***REMOVED*** = pkg_info[key***REMOVED***

    metadata['metadata_version'***REMOVED*** = METADATA_VERSION

    if 'extras' in metadata:
        metadata['extras'***REMOVED*** = sorted(set(metadata['extras'***REMOVED******REMOVED******REMOVED***

    # include more information if distribution is available
    if distribution:
        for requires, attr in (('test_requires', 'tests_require'***REMOVED***,***REMOVED***:
            ***REMOVED***
                requirements = getattr(distribution, attr***REMOVED***
                if isinstance(requirements, list***REMOVED***:
                    new_requirements = sorted(convert_requirements(requirements***REMOVED******REMOVED***
                    metadata[requires***REMOVED*** = [{'requires':new_requirements***REMOVED******REMOVED***
            except AttributeError:
                pass

    # handle contacts
    contacts = [***REMOVED***
    for contact_type, role in CONTACT_FIELDS:
        contact = OrderedDict(***REMOVED***
        for key in sorted(contact_type***REMOVED***:
            if contact_type[key***REMOVED*** in metadata:
                contact[key***REMOVED*** = metadata.pop(contact_type[key***REMOVED******REMOVED***
        if contact:
            contact['role'***REMOVED*** = role
            contacts.append(contact***REMOVED***
    if contacts:
        metadata['extensions'***REMOVED***['python.details'***REMOVED***['contacts'***REMOVED*** = contacts

    # convert entry points to exports
    ***REMOVED***
        with open(os.path.join(os.path.dirname(path***REMOVED***, "entry_points.txt"***REMOVED***, "r"***REMOVED*** as ep_file:
            ep_map = pkg_resources.EntryPoint.parse_map(ep_file.read(***REMOVED******REMOVED***
        exports = OrderedDict(***REMOVED***
        for group, items in sorted(ep_map.items(***REMOVED******REMOVED***:
            exports[group***REMOVED*** = OrderedDict(***REMOVED***
            for item in sorted(map(str, items.values(***REMOVED******REMOVED******REMOVED***:
                name, export = item.split(' = ', 1***REMOVED***
                exports[group***REMOVED***[name***REMOVED*** = export
        if exports:
            metadata['extensions'***REMOVED***['python.exports'***REMOVED*** = exports
    except IOError:
        pass

    # copy console_scripts entry points to commands
    if 'python.exports' in metadata['extensions'***REMOVED***:
        for (ep_script, wrap_script***REMOVED*** in (('console_scripts', 'wrap_console'***REMOVED***,
                                         ('gui_scripts', 'wrap_gui'***REMOVED******REMOVED***:
            if ep_script in metadata['extensions'***REMOVED***['python.exports'***REMOVED***:
                metadata['extensions'***REMOVED***['python.commands'***REMOVED***[wrap_script***REMOVED*** = \
                    metadata['extensions'***REMOVED***['python.exports'***REMOVED***[ep_script***REMOVED***

    return metadata

def requires_to_requires_dist(requirement***REMOVED***:
    ***REMOVED***Compose the version predicates for requirement in PEP 345 fashion.***REMOVED***
    requires_dist = [***REMOVED***
    for op, ver in requirement.specs:
        requires_dist.append(op + ver***REMOVED***
    if not requires_dist:
        return ''
    return " (%s***REMOVED***" % ','.join(requires_dist***REMOVED***

def convert_requirements(requirements***REMOVED***:
    ***REMOVED***Yield Requires-Dist: strings for parsed requirements strings.***REMOVED***
    for req in requirements:
        parsed_requirement = pkg_resources.Requirement.parse(req***REMOVED***
        spec = requires_to_requires_dist(parsed_requirement***REMOVED***
        extras = ",".join(parsed_requirement.extras***REMOVED***
        if extras:
            extras = "[%s***REMOVED***" % extras
        yield (parsed_requirement.project_name + extras + spec***REMOVED***

def generate_requirements(extras_require***REMOVED***:
    ***REMOVED***
    Convert requirements from a setup(***REMOVED***-style dictionary to ('Requires-Dist', 'requirement'***REMOVED***
    and ('Provides-Extra', 'extra'***REMOVED*** tuples.

    extras_require is a dictionary of {extra: [requirements***REMOVED******REMOVED*** as passed to setup(***REMOVED***,
    using the empty extra {'': [requirements***REMOVED******REMOVED*** to hold install_requires.
    ***REMOVED***
    for extra, depends in extras_require.items(***REMOVED***:
        condition = ''
        if extra and ':' in extra:  # setuptools extra:condition syntax
            extra, condition = extra.split(':', 1***REMOVED***
            extra = pkg_resources.safe_extra(extra***REMOVED***
        if extra:
            yield ('Provides-Extra', extra***REMOVED***
            if condition:
                condition += " and "
            condition += "extra == '%s'" % extra
        if condition:
            condition = '; ' + condition
        for new_req in convert_requirements(depends***REMOVED***:
            yield ('Requires-Dist', new_req + condition***REMOVED***

def pkginfo_to_metadata(egg_info_path, pkginfo_path***REMOVED***:
    ***REMOVED***
    Convert .egg-info directory with PKG-INFO to the Metadata 1.3 aka
    old-draft Metadata 2.0 format.
    ***REMOVED***
    pkg_info = read_pkg_info(pkginfo_path***REMOVED***
    pkg_info.replace_header('Metadata-Version', '2.0'***REMOVED***
    requires_path = os.path.join(egg_info_path, 'requires.txt'***REMOVED***
    if os.path.exists(requires_path***REMOVED***:
        with open(requires_path***REMOVED*** as requires_file:
            requires = requires_file.read(***REMOVED***
        for extra, reqs in sorted(pkg_resources.split_sections(requires***REMOVED***,
                                  key=lambda x: x[0***REMOVED*** or ''***REMOVED***:
            for item in generate_requirements({extra: reqs***REMOVED******REMOVED***:
                pkg_info[item[0***REMOVED******REMOVED*** = item[1***REMOVED***

    description = pkg_info['Description'***REMOVED***
    if description:
        pkg_info.set_payload(dedent_description(pkg_info***REMOVED******REMOVED***
        del pkg_info['Description'***REMOVED***

    return pkg_info


def pkginfo_unicode(pkg_info, field***REMOVED***:
    ***REMOVED***Hack to coax Unicode out of an email Message(***REMOVED*** - Python 3.3+***REMOVED***
    text = pkg_info[field***REMOVED***
    field = field.lower(***REMOVED***
    if not isinstance(text, str***REMOVED***:
        if not hasattr(pkg_info, 'raw_items'***REMOVED***:  # Python 3.2
            return str(text***REMOVED***
        for item in pkg_info.raw_items(***REMOVED***:
            if item[0***REMOVED***.lower(***REMOVED*** == field:
                text = item[1***REMOVED***.encode('ascii', 'surrogateescape'***REMOVED***\
                                      .decode('utf-8'***REMOVED***
                break

    return text


def dedent_description(pkg_info***REMOVED***:
    ***REMOVED***
    Dedent and convert pkg_info['Description'***REMOVED*** to Unicode.
    ***REMOVED***
    description = pkg_info['Description'***REMOVED***

    # Python 3 Unicode handling, sorta.
    surrogates = False
    if not isinstance(description, str***REMOVED***:
        surrogates = True
        description = pkginfo_unicode(pkg_info, 'Description'***REMOVED***

    description_lines = description.splitlines(***REMOVED***
    description_dedent = '\n'.join(
            # if the first line of long_description is blank,
            # the first line here will be indented.
            (description_lines[0***REMOVED***.lstrip(***REMOVED***,
             textwrap.dedent('\n'.join(description_lines[1:***REMOVED******REMOVED******REMOVED***,
             '\n'***REMOVED******REMOVED***

    if surrogates:
        description_dedent = description_dedent\
                .encode("utf8"***REMOVED***\
                .decode("ascii", "surrogateescape"***REMOVED***

    return description_dedent


if __name__ == "__main__":
    import sys, pprint
    pprint.pprint(pkginfo_to_dict(sys.argv[1***REMOVED******REMOVED******REMOVED***
