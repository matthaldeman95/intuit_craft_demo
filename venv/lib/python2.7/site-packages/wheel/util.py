***REMOVED***Utility functions.***REMOVED***

import sys
***REMOVED***
import base64
import json
import hashlib
***REMOVED***
    from collections import OrderedDict
except ImportError:
    OrderedDict = dict

__all__ = ['urlsafe_b64encode', 'urlsafe_b64decode', 'utf8',
           'to_json', 'from_json', 'matches_requirement'***REMOVED***

def urlsafe_b64encode(data***REMOVED***:
    ***REMOVED***urlsafe_b64encode without padding***REMOVED***
    return base64.urlsafe_b64encode(data***REMOVED***.rstrip(binary('='***REMOVED******REMOVED***


def urlsafe_b64decode(data***REMOVED***:
    ***REMOVED***urlsafe_b64decode without padding***REMOVED***
    pad = b'=' * (4 - (len(data***REMOVED*** & 3***REMOVED******REMOVED***
    return base64.urlsafe_b64decode(data + pad***REMOVED***


def to_json(o***REMOVED***:
    '''Convert given data to JSON.'''
    return json.dumps(o, sort_keys=True***REMOVED***


def from_json(j***REMOVED***:
    '''Decode a JSON payload.'''
    return json.loads(j***REMOVED***

def open_for_csv(name, mode***REMOVED***:
    if sys.version_info[0***REMOVED*** < 3:
        nl = {***REMOVED***
        bin = 'b'
    else:
        nl = { 'newline': '' ***REMOVED***
        bin = ''
    return open(name, mode + bin, **nl***REMOVED***

***REMOVED***
    unicode

    def utf8(data***REMOVED***:
        '''Utf-8 encode data.'''
        if isinstance(data, unicode***REMOVED***:
            return data.encode('utf-8'***REMOVED***
        return data
except NameError:
    def utf8(data***REMOVED***:
        '''Utf-8 encode data.'''
        if isinstance(data, str***REMOVED***:
            return data.encode('utf-8'***REMOVED***
        return data


***REMOVED***
    # For encoding ascii back and forth between bytestrings, as is repeatedly
    # necessary in JSON-based crypto under Python 3
    unicode
    def native(s***REMOVED***:
        return s
    def binary(s***REMOVED***:
        if isinstance(s, unicode***REMOVED***:
            return s.encode('ascii'***REMOVED***
        return s
except NameError:
    def native(s***REMOVED***:
        if isinstance(s, bytes***REMOVED***:
            return s.decode('ascii'***REMOVED***
        return s
    def binary(s***REMOVED***:
        if isinstance(s, str***REMOVED***:
            return s.encode('ascii'***REMOVED***

class HashingFile(object***REMOVED***:
    def __init__(self, fd, hashtype='sha256'***REMOVED***:
        self.fd = fd
        self.hashtype = hashtype
        self.hash = hashlib.new(hashtype***REMOVED***
        self.length = 0
    def write(self, data***REMOVED***:
        self.hash.update(data***REMOVED***
        self.length += len(data***REMOVED***
        self.fd.write(data***REMOVED***
    def close(self***REMOVED***:
        self.fd.close(***REMOVED***
    def digest(self***REMOVED***:
        if self.hashtype == 'md5':
            return self.hash.hexdigest(***REMOVED***
        digest = self.hash.digest(***REMOVED***
        return self.hashtype + '=' + native(urlsafe_b64encode(digest***REMOVED******REMOVED***

class OrderedDefaultDict(OrderedDict***REMOVED***:
    def __init__(self, *args, **kwargs***REMOVED***:
        if not args:
            self.default_factory = None
        else:
            if not (args[0***REMOVED*** is None or callable(args[0***REMOVED******REMOVED******REMOVED***:
                raise TypeError('first argument must be callable or None'***REMOVED***
            self.default_factory = args[0***REMOVED***
            args = args[1:***REMOVED***
        super(OrderedDefaultDict, self***REMOVED***.__init__(*args, **kwargs***REMOVED***

    def __missing__ (self, key***REMOVED***:
        if self.default_factory is None:
            raise KeyError(key***REMOVED***
        self[key***REMOVED*** = default = self.default_factory(***REMOVED***
        return default

if sys.platform == 'win32':
    import ctypes.wintypes
    # CSIDL_APPDATA for reference - not used here for compatibility with
    # dirspec, which uses LOCAL_APPDATA and COMMON_APPDATA in that order
    csidl = dict(CSIDL_APPDATA=26, CSIDL_LOCAL_APPDATA=28,
            CSIDL_COMMON_APPDATA=35***REMOVED***
    def get_path(name***REMOVED***:
        SHGFP_TYPE_CURRENT = 0
        buf = ctypes.create_unicode_buffer(ctypes.wintypes.MAX_PATH***REMOVED***
        ctypes.windll.shell32.SHGetFolderPathW(0, csidl[name***REMOVED***, 0, SHGFP_TYPE_CURRENT, buf***REMOVED***
        return buf.value

    def save_config_path(*resource***REMOVED***:
        appdata = get_path("CSIDL_LOCAL_APPDATA"***REMOVED***
        path = os.path.join(appdata, *resource***REMOVED***
        if not os.path.isdir(path***REMOVED***:
            os.makedirs(path***REMOVED***
        return path
    def load_config_paths(*resource***REMOVED***:
        ids = ["CSIDL_LOCAL_APPDATA", "CSIDL_COMMON_APPDATA"***REMOVED***
        for id in ids:
            base = get_path(id***REMOVED***
            path = os.path.join(base, *resource***REMOVED***
            if os.path.exists(path***REMOVED***:
                yield path
else:
    def save_config_path(*resource***REMOVED***:
        import xdg.BaseDirectory
        return xdg.BaseDirectory.save_config_path(*resource***REMOVED***
    def load_config_paths(*resource***REMOVED***:
        import xdg.BaseDirectory
        return xdg.BaseDirectory.load_config_paths(*resource***REMOVED***

def matches_requirement(req, wheels***REMOVED***:
    ***REMOVED***List of wheels matching a requirement.

    :param req: The requirement to satisfy
    :param wheels: List of wheels to search.
    ***REMOVED***
    ***REMOVED***
        from pkg_resources import Distribution, Requirement
    except ImportError:
        raise RuntimeError("Cannot use requirements without pkg_resources"***REMOVED***

    req = Requirement.parse(req***REMOVED***

    selected = [***REMOVED***
    for wf in wheels:
        f = wf.parsed_filename
        dist = Distribution(project_name=f.group("name"***REMOVED***, version=f.group("ver"***REMOVED******REMOVED***
        if dist in req:
            selected.append(wf***REMOVED***
    return selected
