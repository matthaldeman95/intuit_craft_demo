***REMOVED***
Create a wheel (.whl***REMOVED*** distribution.

A wheel is a built archive format.
***REMOVED***

import csv
import hashlib
***REMOVED***
import subprocess
import warnings
import shutil
import json
import sys
import re

***REMOVED***
    import sysconfig
except ImportError:  # pragma nocover
    # Python < 2.7
    import distutils.sysconfig as sysconfig

import pkg_resources

safe_name = pkg_resources.safe_name
safe_version = pkg_resources.safe_version

from shutil import rmtree
from email.generator import Generator

from distutils.core import Command
from distutils.sysconfig import get_python_version

from distutils import log as logger

from .pep425tags import get_abbr_impl, get_impl_ver, get_abi_tag, get_platform
from .util import native, open_for_csv
from .archive import archive_wheelfile
from .pkginfo import read_pkg_info, write_pkg_info
from .metadata import pkginfo_to_dict
from . import pep425tags, metadata
from . import __version__ as wheel_version

PY_LIMITED_API_PATTERN = r'cp3\d'

def safer_name(name***REMOVED***:
    return safe_name(name***REMOVED***.replace('-', '_'***REMOVED***

def safer_version(version***REMOVED***:
    return safe_version(version***REMOVED***.replace('-', '_'***REMOVED***

class bdist_wheel(Command***REMOVED***:

    description = 'create a wheel distribution'

    user_options = [('bdist-dir=', 'b',
                     "temporary directory for creating the distribution"***REMOVED***,
                    ('plat-name=', 'p',
                     "platform name to embed in generated filenames "
                     "(default: %s***REMOVED***" % get_platform(***REMOVED******REMOVED***,
                    ('keep-temp', 'k',
                     "keep the pseudo-installation tree around after " +
                     "creating the distribution archive"***REMOVED***,
                    ('dist-dir=', 'd',
                     "directory to put final built distributions in"***REMOVED***,
                    ('skip-build', None,
                     "skip rebuilding everything (for testing/debugging***REMOVED***"***REMOVED***,
                    ('relative', None,
                     "build the archive using relative paths"
                     "(default: false***REMOVED***"***REMOVED***,
                    ('owner=', 'u',
                     "Owner name used when creating a tar file"
                     " [default: current user***REMOVED***"***REMOVED***,
                    ('group=', 'g',
                     "Group name used when creating a tar file"
                     " [default: current group***REMOVED***"***REMOVED***,
                    ('universal', None,
                     "make a universal wheel"
                     " (default: false***REMOVED***"***REMOVED***,
                    ('python-tag=', None,
                     "Python implementation compatibility tag"
                     " (default: py%s***REMOVED***" % get_impl_ver(***REMOVED***[0***REMOVED******REMOVED***,
                    ('py-limited-api=', None,
                     "Python tag (cp32|cp33|cpNN***REMOVED*** for abi3 wheel tag"
                     " (default: false***REMOVED***"***REMOVED***,
                    ***REMOVED***

    boolean_options = ['keep-temp', 'skip-build', 'relative', 'universal'***REMOVED***

    def initialize_options(self***REMOVED***:
        self.bdist_dir = None
        self.data_dir = None
        self.plat_name = None
        self.plat_tag = None
        self.format = 'zip'
        self.keep_temp = False
        self.dist_dir = None
        self.distinfo_dir = None
        self.egginfo_dir = None
        self.root_is_pure = None
        self.skip_build = None
        self.relative = False
        self.owner = None
        self.group = None
        self.universal = False
        self.python_tag = 'py' + get_impl_ver(***REMOVED***[0***REMOVED***
        self.py_limited_api = False
        self.plat_name_supplied = False

    def finalize_options(self***REMOVED***:
        if self.bdist_dir is None:
            bdist_base = self.get_finalized_command('bdist'***REMOVED***.bdist_base
            self.bdist_dir = os.path.join(bdist_base, 'wheel'***REMOVED***

        self.data_dir = self.wheel_dist_name + '.data'
        self.plat_name_supplied = self.plat_name is not None

        need_options = ('dist_dir', 'plat_name', 'skip_build'***REMOVED***

        self.set_undefined_options('bdist',
                                   *zip(need_options, need_options***REMOVED******REMOVED***

        self.root_is_pure = not (self.distribution.has_ext_modules(***REMOVED***
                                 or self.distribution.has_c_libraries(***REMOVED******REMOVED***

        if self.py_limited_api and not re.match(PY_LIMITED_API_PATTERN, self.py_limited_api***REMOVED***:
            raise ValueError("py-limited-api must match '%s'" % PY_LIMITED_API_PATTERN***REMOVED***

        # Support legacy [wheel***REMOVED*** section for setting universal
        wheel = self.distribution.get_option_dict('wheel'***REMOVED***
        if 'universal' in wheel:
            # please don't define this in your global configs
            val = wheel['universal'***REMOVED***[1***REMOVED***.strip(***REMOVED***
            if val.lower(***REMOVED*** in ('1', 'true', 'yes'***REMOVED***:
                self.universal = True

    @property
    def wheel_dist_name(self***REMOVED***:
        ***REMOVED***Return distribution full name with - replaced with _***REMOVED***
        return '-'.join((safer_name(self.distribution.get_name(***REMOVED******REMOVED***,
                         safer_version(self.distribution.get_version(***REMOVED******REMOVED******REMOVED******REMOVED***

    def get_tag(self***REMOVED***:
        # bdist sets self.plat_name if unset, we should only use it for purepy
        # wheels if the user supplied it.
        if self.plat_name_supplied:
            plat_name = self.plat_name
        elif self.root_is_pure:
            plat_name = 'any'
        else:
            plat_name = self.plat_name or get_platform(***REMOVED***
            if plat_name in ('linux-x86_64', 'linux_x86_64'***REMOVED*** and sys.maxsize == 2147483647:
                plat_name = 'linux_i686'
        plat_name = plat_name.replace('-', '_'***REMOVED***.replace('.', '_'***REMOVED***


        if self.root_is_pure:
            if self.universal:
                impl = 'py2.py3'
            else:
                impl = self.python_tag
            tag = (impl, 'none', plat_name***REMOVED***
        else:
            impl_name = get_abbr_impl(***REMOVED***
            impl_ver = get_impl_ver(***REMOVED***
            impl = impl_name + impl_ver
            # We don't work on CPython 3.1, 3.0.
            if self.py_limited_api and (impl_name + impl_ver***REMOVED***.startswith('cp3'***REMOVED***:
                impl = self.py_limited_api
                abi_tag = 'abi3'
            else:
                abi_tag = str(get_abi_tag(***REMOVED******REMOVED***.lower(***REMOVED***
            tag = (impl, abi_tag, plat_name***REMOVED***
            supported_tags = pep425tags.get_supported(
                supplied_platform=plat_name if self.plat_name_supplied else None***REMOVED***
            # XXX switch to this alternate implementation for non-pure:
            if not self.py_limited_api:
                assert tag == supported_tags[0***REMOVED***, "%s != %s" % (tag, supported_tags[0***REMOVED******REMOVED***
            assert tag in supported_tags, "would build wheel with unsupported tag %s" % tag
        return tag

    def get_archive_basename(self***REMOVED***:
        ***REMOVED***Return archive name without extension***REMOVED***

        impl_tag, abi_tag, plat_tag = self.get_tag(***REMOVED***

        archive_basename = "%s-%s-%s-%s" % (
            self.wheel_dist_name,
            impl_tag,
            abi_tag,
            plat_tag***REMOVED***
        return archive_basename

    def run(self***REMOVED***:
        build_scripts = self.reinitialize_command('build_scripts'***REMOVED***
        build_scripts.executable = 'python'

        if not self.skip_build:
            self.run_command('build'***REMOVED***

        install = self.reinitialize_command('install',
                                            reinit_subcommands=True***REMOVED***
        install.root = self.bdist_dir
        install.compile = False
        install.skip_build = self.skip_build
        install.warn_dir = False

        # A wheel without setuptools scripts is more cross-platform.
        # Use the (undocumented***REMOVED*** `no_ep` option to setuptools'
        # install_scripts command to avoid creating entry point scripts.
        install_scripts = self.reinitialize_command('install_scripts'***REMOVED***
        install_scripts.no_ep = True

        # Use a custom scheme for the archive, because we have to decide
        # at installation time which scheme to use.
        for key in ('headers', 'scripts', 'data', 'purelib', 'platlib'***REMOVED***:
            setattr(install,
                    'install_' + key,
                    os.path.join(self.data_dir, key***REMOVED******REMOVED***

        basedir_observed = ''

        if os.name == 'nt':
            # win32 barfs if any of these are ''; could be '.'?
            # (distutils.command.install:change_roots bug***REMOVED***
            basedir_observed = os.path.normpath(os.path.join(self.data_dir, '..'***REMOVED******REMOVED***
            self.install_libbase = self.install_lib = basedir_observed

        setattr(install,
                'install_purelib' if self.root_is_pure else 'install_platlib',
                basedir_observed***REMOVED***

        logger.info("installing to %s", self.bdist_dir***REMOVED***

        self.run_command('install'***REMOVED***

        archive_basename = self.get_archive_basename(***REMOVED***

        pseudoinstall_root = os.path.join(self.dist_dir, archive_basename***REMOVED***
        if not self.relative:
            archive_root = self.bdist_dir
        else:
            archive_root = os.path.join(
                self.bdist_dir,
                self._ensure_relative(install.install_base***REMOVED******REMOVED***

        self.set_undefined_options(
            'install_egg_info', ('target', 'egginfo_dir'***REMOVED******REMOVED***
        self.distinfo_dir = os.path.join(self.bdist_dir,
                                         '%s.dist-info' % self.wheel_dist_name***REMOVED***
        self.egg2dist(self.egginfo_dir,
                      self.distinfo_dir***REMOVED***

        self.write_wheelfile(self.distinfo_dir***REMOVED***

        self.write_record(self.bdist_dir, self.distinfo_dir***REMOVED***

        # Make the archive
        if not os.path.exists(self.dist_dir***REMOVED***:
            os.makedirs(self.dist_dir***REMOVED***
        wheel_name = archive_wheelfile(pseudoinstall_root, archive_root***REMOVED***

        # Sign the archive
        if 'WHEEL_TOOL' in os.environ:
            subprocess.call([os.environ['WHEEL_TOOL'***REMOVED***, 'sign', wheel_name***REMOVED******REMOVED***

        # Add to 'Distribution.dist_files' so that the "upload" command works
        getattr(self.distribution, 'dist_files', [***REMOVED******REMOVED***.append(
            ('bdist_wheel', get_python_version(***REMOVED***, wheel_name***REMOVED******REMOVED***

        if not self.keep_temp:
            if self.dry_run:
                logger.info('removing %s', self.bdist_dir***REMOVED***
            else:
                rmtree(self.bdist_dir***REMOVED***

    def write_wheelfile(self, wheelfile_base, generator='bdist_wheel (' + wheel_version + '***REMOVED***'***REMOVED***:
        from email.message import Message
        msg = Message(***REMOVED***
        msg['Wheel-Version'***REMOVED*** = '1.0'  # of the spec
        msg['Generator'***REMOVED*** = generator
        msg['Root-Is-Purelib'***REMOVED*** = str(self.root_is_pure***REMOVED***.lower(***REMOVED***

        # Doesn't work for bdist_wininst
        impl_tag, abi_tag, plat_tag = self.get_tag(***REMOVED***
        for impl in impl_tag.split('.'***REMOVED***:
            for abi in abi_tag.split('.'***REMOVED***:
                for plat in plat_tag.split('.'***REMOVED***:
                    msg['Tag'***REMOVED*** = '-'.join((impl, abi, plat***REMOVED******REMOVED***

        wheelfile_path = os.path.join(wheelfile_base, 'WHEEL'***REMOVED***
        logger.info('creating %s', wheelfile_path***REMOVED***
        with open(wheelfile_path, 'w'***REMOVED*** as f:
            Generator(f, maxheaderlen=0***REMOVED***.flatten(msg***REMOVED***

    def _ensure_relative(self, path***REMOVED***:
        # copied from dir_util, deleted
        drive, path = os.path.splitdrive(path***REMOVED***
        if path[0:1***REMOVED*** == os.sep:
            path = drive + path[1:***REMOVED***
        return path

    def _pkginfo_to_metadata(self, egg_info_path, pkginfo_path***REMOVED***:
        return metadata.pkginfo_to_metadata(egg_info_path, pkginfo_path***REMOVED***

    def license_file(self***REMOVED***:
        ***REMOVED***Return license filename from a license-file key in setup.cfg, or None.***REMOVED***
        metadata = self.distribution.get_option_dict('metadata'***REMOVED***
        if not 'license_file' in metadata:
            return None
        return metadata['license_file'***REMOVED***[1***REMOVED***

    def setupcfg_requirements(self***REMOVED***:
        ***REMOVED***Generate requirements from setup.cfg as
        ('Requires-Dist', 'requirement; qualifier'***REMOVED*** tuples. From a metadata
        section in setup.cfg:

        [metadata***REMOVED***
        provides-extra = extra1
            extra2
        requires-dist = requirement; qualifier
            another; qualifier2
            unqualified

        Yields

        ('Provides-Extra', 'extra1'***REMOVED***,
        ('Provides-Extra', 'extra2'***REMOVED***,
        ('Requires-Dist', 'requirement; qualifier'***REMOVED***,
        ('Requires-Dist', 'another; qualifier2'***REMOVED***,
        ('Requires-Dist', 'unqualified'***REMOVED***
        ***REMOVED***
        metadata = self.distribution.get_option_dict('metadata'***REMOVED***

        # our .ini parser folds - to _ in key names:
        for key, title in (('provides_extra', 'Provides-Extra'***REMOVED***,
                           ('requires_dist', 'Requires-Dist'***REMOVED******REMOVED***:
            if not key in metadata:
                continue
            field = metadata[key***REMOVED***
            for line in field[1***REMOVED***.splitlines(***REMOVED***:
                line = line.strip(***REMOVED***
                if not line:
                    continue
                yield (title, line***REMOVED***

    def add_requirements(self, metadata_path***REMOVED***:
        ***REMOVED***Add additional requirements from setup.cfg to file metadata_path***REMOVED***
        additional = list(self.setupcfg_requirements(***REMOVED******REMOVED***
        if not additional: return
        pkg_info = read_pkg_info(metadata_path***REMOVED***
        if 'Provides-Extra' in pkg_info or 'Requires-Dist' in pkg_info:
            warnings.warn('setup.cfg requirements overwrite values from setup.py'***REMOVED***
            del pkg_info['Provides-Extra'***REMOVED***
            del pkg_info['Requires-Dist'***REMOVED***
        for k, v in additional:
            pkg_info[k***REMOVED*** = v
        write_pkg_info(metadata_path, pkg_info***REMOVED***

    def egg2dist(self, egginfo_path, distinfo_path***REMOVED***:
        ***REMOVED***Convert an .egg-info directory into a .dist-info directory***REMOVED***
        def adios(p***REMOVED***:
            ***REMOVED***Appropriately delete directory, file or link.***REMOVED***
            if os.path.exists(p***REMOVED*** and not os.path.islink(p***REMOVED*** and os.path.isdir(p***REMOVED***:
                shutil.rmtree(p***REMOVED***
            elif os.path.exists(p***REMOVED***:
                os.unlink(p***REMOVED***

        adios(distinfo_path***REMOVED***

        if not os.path.exists(egginfo_path***REMOVED***:
            # There is no egg-info. This is probably because the egg-info
            # file/directory is not named matching the distribution name used
            # to name the archive file. Check for this case and report
            # accordingly.
            import glob
            pat = os.path.join(os.path.dirname(egginfo_path***REMOVED***, '*.egg-info'***REMOVED***
            possible = glob.glob(pat***REMOVED***
            err = "Egg metadata expected at %s but not found" % (egginfo_path,***REMOVED***
            if possible:
                alt = os.path.basename(possible[0***REMOVED******REMOVED***
                err += " (%s found - possible misnamed archive file?***REMOVED***" % (alt,***REMOVED***

            raise ValueError(err***REMOVED***

        if os.path.isfile(egginfo_path***REMOVED***:
            # .egg-info is a single file
            pkginfo_path = egginfo_path
            pkg_info = self._pkginfo_to_metadata(egginfo_path, egginfo_path***REMOVED***
            os.mkdir(distinfo_path***REMOVED***
        else:
            # .egg-info is a directory
            pkginfo_path = os.path.join(egginfo_path, 'PKG-INFO'***REMOVED***
            pkg_info = self._pkginfo_to_metadata(egginfo_path, pkginfo_path***REMOVED***

            # ignore common egg metadata that is useless to wheel
            shutil.copytree(egginfo_path, distinfo_path,
                            ignore=lambda x, y: set(('PKG-INFO',
                                                     'requires.txt',
                                                     'SOURCES.txt',
                                                     'not-zip-safe',***REMOVED******REMOVED******REMOVED***

            # delete dependency_links if it is only whitespace
            dependency_links_path = os.path.join(distinfo_path, 'dependency_links.txt'***REMOVED***
            with open(dependency_links_path, 'r'***REMOVED*** as dependency_links_file:
                dependency_links = dependency_links_file.read(***REMOVED***.strip(***REMOVED***
            if not dependency_links:
                adios(dependency_links_path***REMOVED***

        write_pkg_info(os.path.join(distinfo_path, 'METADATA'***REMOVED***, pkg_info***REMOVED***

        # XXX deprecated. Still useful for current distribute/setuptools.
        metadata_path = os.path.join(distinfo_path, 'METADATA'***REMOVED***
        self.add_requirements(metadata_path***REMOVED***

        # XXX intentionally a different path than the PEP.
        metadata_json_path = os.path.join(distinfo_path, 'metadata.json'***REMOVED***
        pymeta = pkginfo_to_dict(metadata_path,
                                 distribution=self.distribution***REMOVED***

        if 'description' in pymeta:
            description_filename = 'DESCRIPTION.rst'
            description_text = pymeta.pop('description'***REMOVED***
            description_path = os.path.join(distinfo_path,
                                            description_filename***REMOVED***
            with open(description_path, "wb"***REMOVED*** as description_file:
                description_file.write(description_text.encode('utf-8'***REMOVED******REMOVED***
            pymeta['extensions'***REMOVED***['python.details'***REMOVED***['document_names'***REMOVED***['description'***REMOVED*** = description_filename

        # XXX heuristically copy any LICENSE/LICENSE.txt?
        license = self.license_file(***REMOVED***
        if license:
            license_filename = 'LICENSE.txt'
            shutil.copy(license, os.path.join(self.distinfo_dir, license_filename***REMOVED******REMOVED***
            pymeta['extensions'***REMOVED***['python.details'***REMOVED***['document_names'***REMOVED***['license'***REMOVED*** = license_filename

        with open(metadata_json_path, "w"***REMOVED*** as metadata_json:
            json.dump(pymeta, metadata_json, sort_keys=True***REMOVED***

        adios(egginfo_path***REMOVED***

    def write_record(self, bdist_dir, distinfo_dir***REMOVED***:
        from .util import urlsafe_b64encode

        record_path = os.path.join(distinfo_dir, 'RECORD'***REMOVED***
        record_relpath = os.path.relpath(record_path, bdist_dir***REMOVED***

        def walk(***REMOVED***:
            for dir, dirs, files in os.walk(bdist_dir***REMOVED***:
                dirs.sort(***REMOVED***
                for f in sorted(files***REMOVED***:
                    yield os.path.join(dir, f***REMOVED***

        def skip(path***REMOVED***:
            ***REMOVED***Wheel hashes every possible file.***REMOVED***
            return (path == record_relpath***REMOVED***

        with open_for_csv(record_path, 'w+'***REMOVED*** as record_file:
            writer = csv.writer(record_file***REMOVED***
            for path in walk(***REMOVED***:
                relpath = os.path.relpath(path, bdist_dir***REMOVED***
                if skip(relpath***REMOVED***:
                    hash = ''
                    size = ''
                else:
                    with open(path, 'rb'***REMOVED*** as f:
                        data = f.read(***REMOVED***
                    digest = hashlib.sha256(data***REMOVED***.digest(***REMOVED***
                    hash = 'sha256=' + native(urlsafe_b64encode(digest***REMOVED******REMOVED***
                    size = len(data***REMOVED***
                record_path = os.path.relpath(
                    path, bdist_dir***REMOVED***.replace(os.path.sep, '/'***REMOVED***
                writer.writerow((record_path, hash, size***REMOVED******REMOVED***
