# Ed25519 digital signatures
# Based on http://ed25519.cr.yp.to/python/ed25519.py
# See also http://ed25519.cr.yp.to/software.html
# Adapted by Ron Garret
# Sped up considerably using coordinate transforms found on:
# http://www.hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
# Specifically add-2008-hwcd-4 and dbl-2008-hwcd

***REMOVED*** # pragma nocover
    unicode
    PY3 = False
    def asbytes(b***REMOVED***:
        ***REMOVED***Convert array of integers to byte string***REMOVED***
        return ''.join(chr(x***REMOVED*** for x in b***REMOVED***
    def joinbytes(b***REMOVED***:
        ***REMOVED***Convert array of bytes to byte string***REMOVED***
        return ''.join(b***REMOVED***
    def bit(h, i***REMOVED***:
        ***REMOVED***Return i'th bit of bytestring h***REMOVED***
        return (ord(h[i//8***REMOVED******REMOVED*** >> (i%8***REMOVED******REMOVED*** & 1

except NameError: # pragma nocover
    PY3 = True
    asbytes = bytes
    joinbytes = bytes
    def bit(h, i***REMOVED***:
        return (h[i//8***REMOVED*** >> (i%8***REMOVED******REMOVED*** & 1

import hashlib

b = 256
q = 2**255 - 19
l = 2**252 + 27742317777372353535851937790883648493

def H(m***REMOVED***:
    return hashlib.sha512(m***REMOVED***.digest(***REMOVED***

def expmod(b, e, m***REMOVED***:
    if e == 0: return 1
    t = expmod(b, e // 2, m***REMOVED*** ** 2 % m
    if e & 1: t = (t * b***REMOVED*** % m
    return t

# Can probably get some extra speedup here by replacing this with
# an extended-euclidean, but performance seems OK without that
def inv(x***REMOVED***:
    return expmod(x, q-2, q***REMOVED***

d = -121665 * inv(121666***REMOVED***
I = expmod(2,(q-1***REMOVED***//4,q***REMOVED***

def xrecover(y***REMOVED***:
    xx = (y*y-1***REMOVED*** * inv(d*y*y+1***REMOVED***
    x = expmod(xx,(q+3***REMOVED***//8,q***REMOVED***
    if (x*x - xx***REMOVED*** % q != 0: x = (x*I***REMOVED*** % q
    if x % 2 != 0: x = q-x
    return x

By = 4 * inv(5***REMOVED***
Bx = xrecover(By***REMOVED***
B = [Bx % q,By % q***REMOVED***

#def edwards(P,Q***REMOVED***:
#    x1 = P[0***REMOVED***
#    y1 = P[1***REMOVED***
#    x2 = Q[0***REMOVED***
#    y2 = Q[1***REMOVED***
#    x3 = (x1*y2+x2*y1***REMOVED*** * inv(1+d*x1*x2*y1*y2***REMOVED***
#    y3 = (y1*y2+x1*x2***REMOVED*** * inv(1-d*x1*x2*y1*y2***REMOVED***
#    return (x3 % q,y3 % q***REMOVED***

#def scalarmult(P,e***REMOVED***:
#    if e == 0: return [0,1***REMOVED***
#    Q = scalarmult(P,e/2***REMOVED***
#    Q = edwards(Q,Q***REMOVED***
#    if e & 1: Q = edwards(Q,P***REMOVED***
#    return Q

# Faster (!***REMOVED*** version based on:
# http://www.hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html

def xpt_add(pt1, pt2***REMOVED***:
    (X1, Y1, Z1, T1***REMOVED*** = pt1
    (X2, Y2, Z2, T2***REMOVED*** = pt2
    A = ((Y1-X1***REMOVED****(Y2+X2***REMOVED******REMOVED*** % q
    B = ((Y1+X1***REMOVED****(Y2-X2***REMOVED******REMOVED*** % q
    C = (Z1*2*T2***REMOVED*** % q
    D = (T1*2*Z2***REMOVED*** % q
    E = (D+C***REMOVED*** % q
    F = (B-A***REMOVED*** % q
    G = (B+A***REMOVED*** % q
    H = (D-C***REMOVED*** % q
    X3 = (E*F***REMOVED*** % q
    Y3 = (G*H***REMOVED*** % q
    Z3 = (F*G***REMOVED*** % q
    T3 = (E*H***REMOVED*** % q
    return (X3, Y3, Z3, T3***REMOVED***

def xpt_double (pt***REMOVED***:
    (X1, Y1, Z1, _***REMOVED*** = pt
    A = (X1*X1***REMOVED***
    B = (Y1*Y1***REMOVED***
    C = (2*Z1*Z1***REMOVED***
    D = (-A***REMOVED*** % q
    J = (X1+Y1***REMOVED*** % q
    E = (J*J-A-B***REMOVED*** % q
    G = (D+B***REMOVED*** % q
    F = (G-C***REMOVED*** % q
    H = (D-B***REMOVED*** % q
    X3 = (E*F***REMOVED*** % q
    Y3 = (G*H***REMOVED*** % q
    Z3 = (F*G***REMOVED*** % q
    T3 = (E*H***REMOVED*** % q
    return (X3, Y3, Z3, T3***REMOVED***

def pt_xform (pt***REMOVED***:
    (x, y***REMOVED*** = pt
    return (x, y, 1, (x*y***REMOVED***%q***REMOVED***

def pt_unxform (pt***REMOVED***:
    (x, y, z, _***REMOVED*** = pt
    return ((x*inv(z***REMOVED******REMOVED***%q, (y*inv(z***REMOVED******REMOVED***%q***REMOVED***

def xpt_mult (pt, n***REMOVED***:
    if n==0: return pt_xform((0,1***REMOVED******REMOVED***
    _ = xpt_double(xpt_mult(pt, n>>1***REMOVED******REMOVED***
    return xpt_add(_, pt***REMOVED*** if n&1 else _

def scalarmult(pt, e***REMOVED***:
    return pt_unxform(xpt_mult(pt_xform(pt***REMOVED***, e***REMOVED******REMOVED***

def encodeint(y***REMOVED***:
    bits = [(y >> i***REMOVED*** & 1 for i in range(b***REMOVED******REMOVED***
    e = [(sum([bits[i * 8 + j***REMOVED*** << j for j in range(8***REMOVED******REMOVED******REMOVED******REMOVED***
                                    for i in range(b//8***REMOVED******REMOVED***
    return asbytes(e***REMOVED***

def encodepoint(P***REMOVED***:
    x = P[0***REMOVED***
    y = P[1***REMOVED***
    bits = [(y >> i***REMOVED*** & 1 for i in range(b - 1***REMOVED******REMOVED*** + [x & 1***REMOVED***
    e = [(sum([bits[i * 8 + j***REMOVED*** << j for j in range(8***REMOVED******REMOVED******REMOVED******REMOVED***
                                    for i in range(b//8***REMOVED******REMOVED***
    return asbytes(e***REMOVED***
    
def publickey(sk***REMOVED***:
    h = H(sk***REMOVED***
    a = 2**(b-2***REMOVED*** + sum(2**i * bit(h,i***REMOVED*** for i in range(3,b-2***REMOVED******REMOVED***
    A = scalarmult(B,a***REMOVED***
    return encodepoint(A***REMOVED***

def Hint(m***REMOVED***:
    h = H(m***REMOVED***
    return sum(2**i * bit(h,i***REMOVED*** for i in range(2*b***REMOVED******REMOVED***

def signature(m,sk,pk***REMOVED***:
    h = H(sk***REMOVED***
    a = 2**(b-2***REMOVED*** + sum(2**i * bit(h,i***REMOVED*** for i in range(3,b-2***REMOVED******REMOVED***
    inter = joinbytes([h[i***REMOVED*** for i in range(b//8,b//4***REMOVED******REMOVED******REMOVED***
    r = Hint(inter + m***REMOVED***
    R = scalarmult(B,r***REMOVED***
    S = (r + Hint(encodepoint(R***REMOVED*** + pk + m***REMOVED*** * a***REMOVED*** % l
    return encodepoint(R***REMOVED*** + encodeint(S***REMOVED***

def isoncurve(P***REMOVED***:
    x = P[0***REMOVED***
    y = P[1***REMOVED***
    return (-x*x + y*y - 1 - d*x*x*y*y***REMOVED*** % q == 0

def decodeint(s***REMOVED***:
    return sum(2**i * bit(s,i***REMOVED*** for i in range(0,b***REMOVED******REMOVED***

def decodepoint(s***REMOVED***:
    y = sum(2**i * bit(s,i***REMOVED*** for i in range(0,b-1***REMOVED******REMOVED***
    x = xrecover(y***REMOVED***
    if x & 1 != bit(s,b-1***REMOVED***: x = q-x
    P = [x,y***REMOVED***
    if not isoncurve(P***REMOVED***: raise Exception("decoding point that is not on curve"***REMOVED***
    return P

def checkvalid(s, m, pk***REMOVED***:
    if len(s***REMOVED*** != b//4: raise Exception("signature length is wrong"***REMOVED***
    if len(pk***REMOVED*** != b//8: raise Exception("public-key length is wrong"***REMOVED***
    R = decodepoint(s[0:b//8***REMOVED******REMOVED***
    A = decodepoint(pk***REMOVED***
    S = decodeint(s[b//8:b//4***REMOVED******REMOVED***
    h = Hint(encodepoint(R***REMOVED*** + pk + m***REMOVED***
    v1 = scalarmult(B,S***REMOVED***
#  v2 = edwards(R,scalarmult(A,h***REMOVED******REMOVED***
    v2 = pt_unxform(xpt_add(pt_xform(R***REMOVED***, pt_xform(scalarmult(A, h***REMOVED******REMOVED******REMOVED******REMOVED***
    return v1==v2

##########################################################
#
# Curve25519 reference implementation by Matthew Dempsky, from:
# http://cr.yp.to/highspeed/naclcrypto-20090310.pdf

# P = 2 ** 255 - 19
P = q
A = 486662

#def expmod(b, e, m***REMOVED***:
#    if e == 0: return 1
#    t = expmod(b, e / 2, m***REMOVED*** ** 2 % m
#    if e & 1: t = (t * b***REMOVED*** % m
#    return t

# def inv(x***REMOVED***: return expmod(x, P - 2, P***REMOVED***

def add(n, m, d***REMOVED***:
    (xn, zn***REMOVED*** = n
    (xm, zm***REMOVED*** = m 
    (xd, zd***REMOVED*** = d
    x = 4 * (xm * xn - zm * zn***REMOVED*** ** 2 * zd
    z = 4 * (xm * zn - zm * xn***REMOVED*** ** 2 * xd
    return (x % P, z % P***REMOVED***

def double(n***REMOVED***:
    (xn, zn***REMOVED*** = n
    x = (xn ** 2 - zn ** 2***REMOVED*** ** 2
    z = 4 * xn * zn * (xn ** 2 + A * xn * zn + zn ** 2***REMOVED***
    return (x % P, z % P***REMOVED***

def curve25519(n, base=9***REMOVED***:
    one = (base,1***REMOVED***
    two = double(one***REMOVED***
    # f(m***REMOVED*** evaluates to a tuple
    # containing the mth multiple and the
    # (m+1***REMOVED***th multiple of base.
    def f(m***REMOVED***:
        if m == 1: return (one, two***REMOVED***
        (pm, pm1***REMOVED*** = f(m // 2***REMOVED***
        if (m & 1***REMOVED***:
            return (add(pm, pm1, one***REMOVED***, double(pm1***REMOVED******REMOVED***
        return (double(pm***REMOVED***, add(pm, pm1, one***REMOVED******REMOVED***
    ((x,z***REMOVED***, _***REMOVED*** = f(n***REMOVED***
    return (x * inv(z***REMOVED******REMOVED*** % P

import random

def genkey(n=0***REMOVED***:
    n = n or random.randint(0,P***REMOVED***
    n &= ~7
    n &= ~(128 << 8 * 31***REMOVED***
    n |= 64 << 8 * 31
    return n

#def str2int(s***REMOVED***:
#    return int(hexlify(s***REMOVED***, 16***REMOVED***
#    # return sum(ord(s[i***REMOVED******REMOVED*** << (8 * i***REMOVED*** for i in range(32***REMOVED******REMOVED***
#
#def int2str(n***REMOVED***:
#    return unhexlify("%x" % n***REMOVED***
#    # return ''.join([chr((n >> (8 * i***REMOVED******REMOVED*** & 255***REMOVED*** for i in range(32***REMOVED******REMOVED******REMOVED***

#################################################

def dsa_test(***REMOVED***:
    ***REMOVED***
    msg = str(random.randint(q,q+q***REMOVED******REMOVED***.encode('utf-8'***REMOVED***
    sk = os.urandom(32***REMOVED***
    pk = publickey(sk***REMOVED***
    sig = signature(msg, sk, pk***REMOVED***
    return checkvalid(sig, msg, pk***REMOVED***

def dh_test(***REMOVED***:
    sk1 = genkey(***REMOVED***
    sk2 = genkey(***REMOVED***
    return curve25519(sk1, curve25519(sk2***REMOVED******REMOVED*** == curve25519(sk2, curve25519(sk1***REMOVED******REMOVED***

