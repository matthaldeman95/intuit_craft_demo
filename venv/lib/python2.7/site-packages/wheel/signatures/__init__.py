***REMOVED***
Create and verify jws-js format Ed25519 signatures.
***REMOVED***

__all__ = [ 'sign', 'verify' ***REMOVED***

import json
from ..util import urlsafe_b64decode, urlsafe_b64encode, native, binary

ed25519ll = None

ALG = "Ed25519"

def get_ed25519ll(***REMOVED***:
    ***REMOVED***Lazy import-and-test of ed25519 module***REMOVED***
    global ed25519ll
    
    if not ed25519ll:
        ***REMOVED***
            import ed25519ll # fast (thousands / s***REMOVED***
        except (ImportError, OSError***REMOVED***: # pragma nocover
            from . import ed25519py as ed25519ll # pure Python (hundreds / s***REMOVED***
        test(***REMOVED***
    
    return ed25519ll

def sign(payload, keypair***REMOVED***:
    ***REMOVED***Return a JWS-JS format signature given a JSON-serializable payload and 
    an Ed25519 keypair.***REMOVED***
    get_ed25519ll(***REMOVED***
    #
    header = {
                "alg": ALG,
                "jwk": {
                    "kty": ALG, # alg -> kty in jwk-08.
                    "vk": native(urlsafe_b64encode(keypair.vk***REMOVED******REMOVED***
            ***REMOVED***
         ***REMOVED***
    
    encoded_header = urlsafe_b64encode(binary(json.dumps(header, sort_keys=True***REMOVED******REMOVED******REMOVED***
    encoded_payload = urlsafe_b64encode(binary(json.dumps(payload, sort_keys=True***REMOVED******REMOVED******REMOVED***
    secured_input = b".".join((encoded_header, encoded_payload***REMOVED******REMOVED***
    sig_msg = ed25519ll.crypto_sign(secured_input, keypair.sk***REMOVED***
    signature = sig_msg[:ed25519ll.SIGNATUREBYTES***REMOVED***
    encoded_signature = urlsafe_b64encode(signature***REMOVED***
    
    return {"recipients": 
            [{"header":native(encoded_header***REMOVED***,
             "signature":native(encoded_signature***REMOVED******REMOVED******REMOVED***,
            "payload": native(encoded_payload***REMOVED******REMOVED***

def assertTrue(condition, message=""***REMOVED***:
    if not condition:
        raise ValueError(message***REMOVED***
    
def verify(jwsjs***REMOVED***:
    ***REMOVED***Return (decoded headers, payload***REMOVED*** if all signatures in jwsjs are
    consistent, else raise ValueError.
    
    Caller must decide whether the keys are actually trusted.***REMOVED***
    get_ed25519ll(***REMOVED***    
    # XXX forbid duplicate keys in JSON input using object_pairs_hook (2.7+***REMOVED***
    recipients = jwsjs["recipients"***REMOVED***
    encoded_payload = binary(jwsjs["payload"***REMOVED******REMOVED***
    headers = [***REMOVED***
    for recipient in recipients:
        assertTrue(len(recipient***REMOVED*** == 2, "Unknown recipient key {0***REMOVED***".format(recipient***REMOVED******REMOVED***
        h = binary(recipient["header"***REMOVED******REMOVED***
        s = binary(recipient["signature"***REMOVED******REMOVED***
        header = json.loads(native(urlsafe_b64decode(h***REMOVED******REMOVED******REMOVED***
        assertTrue(header["alg"***REMOVED*** == ALG, 
                "Unexpected algorithm {0***REMOVED***".format(header["alg"***REMOVED******REMOVED******REMOVED***
        if "alg" in header["jwk"***REMOVED*** and not "kty" in header["jwk"***REMOVED***:
            header["jwk"***REMOVED***["kty"***REMOVED*** = header["jwk"***REMOVED***["alg"***REMOVED*** # b/w for JWK < -08
        assertTrue(header["jwk"***REMOVED***["kty"***REMOVED*** == ALG, # true for Ed25519
                "Unexpected key type {0***REMOVED***".format(header["jwk"***REMOVED***["kty"***REMOVED******REMOVED******REMOVED***
        vk = urlsafe_b64decode(binary(header["jwk"***REMOVED***["vk"***REMOVED******REMOVED******REMOVED***
        secured_input = b".".join((h, encoded_payload***REMOVED******REMOVED***
        sig = urlsafe_b64decode(s***REMOVED***
        sig_msg = sig+secured_input
        verified_input = native(ed25519ll.crypto_sign_open(sig_msg, vk***REMOVED******REMOVED***
        verified_header, verified_payload = verified_input.split('.'***REMOVED***
        verified_header = binary(verified_header***REMOVED***
        decoded_header = native(urlsafe_b64decode(verified_header***REMOVED******REMOVED***
        headers.append(json.loads(decoded_header***REMOVED******REMOVED***

    verified_payload = binary(verified_payload***REMOVED***

    # only return header, payload that have passed through the crypto library.
    payload = json.loads(native(urlsafe_b64decode(verified_payload***REMOVED******REMOVED******REMOVED***

    return headers, payload

def test(***REMOVED***:
    kp = ed25519ll.crypto_sign_keypair(***REMOVED***
    payload = {'test': 'onstartup'***REMOVED***
    jwsjs = json.loads(json.dumps(sign(payload, kp***REMOVED******REMOVED******REMOVED***
    verify(jwsjs***REMOVED***
    jwsjs['payload'***REMOVED*** += 'x'
    ***REMOVED***
        verify(jwsjs***REMOVED***
    except ValueError:
        pass
    else: # pragma no cover
        raise RuntimeError("No error from bad wheel.signatures payload."***REMOVED***

