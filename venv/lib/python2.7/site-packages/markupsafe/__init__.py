# -*- coding: utf-8 -*-
***REMOVED***
    markupsafe
    ~~~~~~~~~~

    Implements a Markup string.

    :copyright: (c***REMOVED*** 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
***REMOVED***
import re
import string
from collections import Mapping
from markupsafe._compat import text_type, string_types, int_types, \
     unichr, iteritems, PY2


__all__ = ['Markup', 'soft_unicode', 'escape', 'escape_silent'***REMOVED***


_striptags_re = re.compile(r'(<!--.*?-->|<[^>***REMOVED****>***REMOVED***'***REMOVED***
_entity_re = re.compile(r'&([^;***REMOVED***+***REMOVED***;'***REMOVED***


class Markup(text_type***REMOVED***:
    r***REMOVED***Marks a string as being safe for inclusion in HTML/XML output without
    needing to be escaped.  This implements the `__html__` interface a couple
    of frameworks and web applications use.  :class:`Markup` is a direct
    subclass of `unicode` and provides all the methods of `unicode` just that
    it escapes arguments passed and always returns `Markup`.

    The `escape` function returns markup objects so that double escaping can't
    happen.

    The constructor of the :class:`Markup` class can be used for three
    different things:  When passed an unicode object it's assumed to be safe,
    when passed an object with an HTML representation (has an `__html__`
    method***REMOVED*** that representation is used, otherwise the object passed is
    converted into a unicode string and then assumed to be safe:

    >>> Markup("Hello <em>World</em>!"***REMOVED***
    Markup(u'Hello <em>World</em>!'***REMOVED***
    >>> class Foo(object***REMOVED***:
    ...  def __html__(self***REMOVED***:
    ...   return '<a href="#">foo</a>'
    ...
    >>> Markup(Foo(***REMOVED******REMOVED***
    Markup(u'<a href="#">foo</a>'***REMOVED***

    If you want object passed being always treated as unsafe you can use the
    :meth:`escape` classmethod to create a :class:`Markup` object:

    >>> Markup.escape("Hello <em>World</em>!"***REMOVED***
    Markup(u'Hello &lt;em&gt;World&lt;/em&gt;!'***REMOVED***

    Operations on a markup string are markup aware which means that all
    arguments are passed through the :func:`escape` function:

    >>> em = Markup("<em>%s</em>"***REMOVED***
    >>> em % "foo & bar"
    Markup(u'<em>foo &amp; bar</em>'***REMOVED***
    >>> strong = Markup("<strong>%(text***REMOVED***s</strong>"***REMOVED***
    >>> strong % {'text': '<blink>hacker here</blink>'***REMOVED***
    Markup(u'<strong>&lt;blink&gt;hacker here&lt;/blink&gt;</strong>'***REMOVED***
    >>> Markup("<em>Hello</em> "***REMOVED*** + "<foo>"
    Markup(u'<em>Hello</em> &lt;foo&gt;'***REMOVED***
    ***REMOVED***
    __slots__ = (***REMOVED***

    def __new__(cls, base=u'', encoding=None, errors='strict'***REMOVED***:
        if hasattr(base, '__html__'***REMOVED***:
            base = base.__html__(***REMOVED***
        if encoding is None:
            return text_type.__new__(cls, base***REMOVED***
        return text_type.__new__(cls, base, encoding, errors***REMOVED***

    def __html__(self***REMOVED***:
        return self

    def __add__(self, other***REMOVED***:
        if isinstance(other, string_types***REMOVED*** or hasattr(other, '__html__'***REMOVED***:
            return self.__class__(super(Markup, self***REMOVED***.__add__(self.escape(other***REMOVED******REMOVED******REMOVED***
        return NotImplemented

    def __radd__(self, other***REMOVED***:
        if hasattr(other, '__html__'***REMOVED*** or isinstance(other, string_types***REMOVED***:
            return self.escape(other***REMOVED***.__add__(self***REMOVED***
        return NotImplemented

    def __mul__(self, num***REMOVED***:
        if isinstance(num, int_types***REMOVED***:
            return self.__class__(text_type.__mul__(self, num***REMOVED******REMOVED***
        return NotImplemented
    __rmul__ = __mul__

    def __mod__(self, arg***REMOVED***:
        if isinstance(arg, tuple***REMOVED***:
            arg = tuple(_MarkupEscapeHelper(x, self.escape***REMOVED*** for x in arg***REMOVED***
        else:
            arg = _MarkupEscapeHelper(arg, self.escape***REMOVED***
        return self.__class__(text_type.__mod__(self, arg***REMOVED******REMOVED***

    def __repr__(self***REMOVED***:
        return '%s(%s***REMOVED***' % (
            self.__class__.__name__,
            text_type.__repr__(self***REMOVED***
        ***REMOVED***

    def join(self, seq***REMOVED***:
        return self.__class__(text_type.join(self, map(self.escape, seq***REMOVED******REMOVED******REMOVED***
    join.__doc__ = text_type.join.__doc__

    def split(self, *args, **kwargs***REMOVED***:
        return list(map(self.__class__, text_type.split(self, *args, **kwargs***REMOVED******REMOVED******REMOVED***
    split.__doc__ = text_type.split.__doc__

    def rsplit(self, *args, **kwargs***REMOVED***:
        return list(map(self.__class__, text_type.rsplit(self, *args, **kwargs***REMOVED******REMOVED******REMOVED***
    rsplit.__doc__ = text_type.rsplit.__doc__

    def splitlines(self, *args, **kwargs***REMOVED***:
        return list(map(self.__class__, text_type.splitlines(
            self, *args, **kwargs***REMOVED******REMOVED******REMOVED***
    splitlines.__doc__ = text_type.splitlines.__doc__

    def unescape(self***REMOVED***:
        r***REMOVED***Unescape markup again into an text_type string.  This also resolves
        known HTML4 and XHTML entities:

        >>> Markup("Main &raquo; <em>About</em>"***REMOVED***.unescape(***REMOVED***
        u'Main \xbb <em>About</em>'
        ***REMOVED***
        from markupsafe._constants import HTML_ENTITIES
        def handle_match(m***REMOVED***:
            name = m.group(1***REMOVED***
            if name in HTML_ENTITIES:
                return unichr(HTML_ENTITIES[name***REMOVED******REMOVED***
            ***REMOVED***
                if name[:2***REMOVED*** in ('#x', '#X'***REMOVED***:
                    return unichr(int(name[2:***REMOVED***, 16***REMOVED******REMOVED***
                elif name.startswith('#'***REMOVED***:
                    return unichr(int(name[1:***REMOVED******REMOVED******REMOVED***
            except ValueError:
                pass
            return u''
        return _entity_re.sub(handle_match, text_type(self***REMOVED******REMOVED***

    def striptags(self***REMOVED***:
        r***REMOVED***Unescape markup into an text_type string and strip all tags.  This
        also resolves known HTML4 and XHTML entities.  Whitespace is
        normalized to one:

        >>> Markup("Main &raquo;  <em>About</em>"***REMOVED***.striptags(***REMOVED***
        u'Main \xbb About'
        ***REMOVED***
        stripped = u' '.join(_striptags_re.sub('', self***REMOVED***.split(***REMOVED******REMOVED***
        return Markup(stripped***REMOVED***.unescape(***REMOVED***

    @classmethod
    def escape(cls, s***REMOVED***:
        ***REMOVED***Escape the string.  Works like :func:`escape` with the difference
        that for subclasses of :class:`Markup` this function would return the
        correct subclass.
        ***REMOVED***
        rv = escape(s***REMOVED***
        if rv.__class__ is not cls:
            return cls(rv***REMOVED***
        return rv

    def make_simple_escaping_wrapper(name***REMOVED***:
        orig = getattr(text_type, name***REMOVED***
        def func(self, *args, **kwargs***REMOVED***:
            args = _escape_argspec(list(args***REMOVED***, enumerate(args***REMOVED***, self.escape***REMOVED***
            _escape_argspec(kwargs, iteritems(kwargs***REMOVED***, self.escape***REMOVED***
            return self.__class__(orig(self, *args, **kwargs***REMOVED******REMOVED***
        func.__name__ = orig.__name__
        func.__doc__ = orig.__doc__
        return func

    for method in '__getitem__', 'capitalize', \
                  'title', 'lower', 'upper', 'replace', 'ljust', \
                  'rjust', 'lstrip', 'rstrip', 'center', 'strip', \
                  'translate', 'expandtabs', 'swapcase', 'zfill':
        locals(***REMOVED***[method***REMOVED*** = make_simple_escaping_wrapper(method***REMOVED***

    # new in python 2.5
    if hasattr(text_type, 'partition'***REMOVED***:
        def partition(self, sep***REMOVED***:
            return tuple(map(self.__class__,
                             text_type.partition(self, self.escape(sep***REMOVED******REMOVED******REMOVED******REMOVED***
        def rpartition(self, sep***REMOVED***:
            return tuple(map(self.__class__,
                             text_type.rpartition(self, self.escape(sep***REMOVED******REMOVED******REMOVED******REMOVED***

    # new in python 2.6
    if hasattr(text_type, 'format'***REMOVED***:
        def format(*args, **kwargs***REMOVED***:
            self, args = args[0***REMOVED***, args[1:***REMOVED***
            formatter = EscapeFormatter(self.escape***REMOVED***
            kwargs = _MagicFormatMapping(args, kwargs***REMOVED***
            return self.__class__(formatter.vformat(self, args, kwargs***REMOVED******REMOVED***

        def __html_format__(self, format_spec***REMOVED***:
            if format_spec:
                raise ValueError('Unsupported format specification '
                                 'for Markup.'***REMOVED***
            return self

    # not in python 3
    if hasattr(text_type, '__getslice__'***REMOVED***:
        __getslice__ = make_simple_escaping_wrapper('__getslice__'***REMOVED***

    del method, make_simple_escaping_wrapper


class _MagicFormatMapping(Mapping***REMOVED***:
    ***REMOVED***This class implements a dummy wrapper to fix a bug in the Python
    standard library for string formatting.

    See http://bugs.python.org/issue13598 for information about why
    this is necessary.
    ***REMOVED***

    def __init__(self, args, kwargs***REMOVED***:
        self._args = args
        self._kwargs = kwargs
        self._last_index = 0

    def __getitem__(self, key***REMOVED***:
        if key == '':
            idx = self._last_index
            self._last_index += 1
            ***REMOVED***
                return self._args[idx***REMOVED***
            except LookupError:
                pass
            key = str(idx***REMOVED***
        return self._kwargs[key***REMOVED***

    def __iter__(self***REMOVED***:
        return iter(self._kwargs***REMOVED***

    def __len__(self***REMOVED***:
        return len(self._kwargs***REMOVED***


if hasattr(text_type, 'format'***REMOVED***:
    class EscapeFormatter(string.Formatter***REMOVED***:

        def __init__(self, escape***REMOVED***:
            self.escape = escape

        def format_field(self, value, format_spec***REMOVED***:
            if hasattr(value, '__html_format__'***REMOVED***:
                rv = value.__html_format__(format_spec***REMOVED***
            elif hasattr(value, '__html__'***REMOVED***:
                if format_spec:
                    raise ValueError('No format specification allowed '
                                     'when formatting an object with '
                                     'its __html__ method.'***REMOVED***
                rv = value.__html__(***REMOVED***
            else:
                rv = string.Formatter.format_field(self, value, format_spec***REMOVED***
            return text_type(self.escape(rv***REMOVED******REMOVED***


def _escape_argspec(obj, iterable, escape***REMOVED***:
    ***REMOVED***Helper for various string-wrapped functions.***REMOVED***
    for key, value in iterable:
        if hasattr(value, '__html__'***REMOVED*** or isinstance(value, string_types***REMOVED***:
            obj[key***REMOVED*** = escape(value***REMOVED***
    return obj


class _MarkupEscapeHelper(object***REMOVED***:
    ***REMOVED***Helper for Markup.__mod__***REMOVED***

    def __init__(self, obj, escape***REMOVED***:
        self.obj = obj
        self.escape = escape

    __getitem__ = lambda s, x: _MarkupEscapeHelper(s.obj[x***REMOVED***, s.escape***REMOVED***
    __unicode__ = __str__ = lambda s: text_type(s.escape(s.obj***REMOVED******REMOVED***
    __repr__ = lambda s: str(s.escape(repr(s.obj***REMOVED******REMOVED******REMOVED***
    __int__ = lambda s: int(s.obj***REMOVED***
    __float__ = lambda s: float(s.obj***REMOVED***


# we have to import it down here as the speedups and native
# modules imports the markup type which is define above.
***REMOVED***
    from markupsafe._speedups import escape, escape_silent, soft_unicode
except ImportError:
    from markupsafe._native import escape, escape_silent, soft_unicode

if not PY2:
    soft_str = soft_unicode
    __all__.append('soft_str'***REMOVED***
