# -*- coding: utf-8 -*-
import gc
import sys
import unittest
from markupsafe import Markup, escape, escape_silent
from markupsafe._compat import text_type


class MarkupTestCase(unittest.TestCase***REMOVED***:

    def test_adding(self***REMOVED***:
        # adding two strings should escape the unsafe one
        unsafe = '<script type="application/x-some-script">alert("foo"***REMOVED***;</script>'
        safe = Markup('<em>username</em>'***REMOVED***
        assert unsafe + safe == text_type(escape(unsafe***REMOVED******REMOVED*** + text_type(safe***REMOVED***

    def test_string_interpolation(self***REMOVED***:
        # string interpolations are safe to use too
        assert Markup('<em>%s</em>'***REMOVED*** % '<bad user>' == \
               '<em>&lt;bad user&gt;</em>'
        assert Markup('<em>%(username***REMOVED***s</em>'***REMOVED*** % {
            'username': '<bad user>'
    ***REMOVED*** == '<em>&lt;bad user&gt;</em>'

        assert Markup('%i'***REMOVED*** % 3.14 == '3'
        assert Markup('%.2f'***REMOVED*** % 3.14 == '3.14'

    def test_type_behavior(self***REMOVED***:
        # an escaped object is markup too
        assert type(Markup('foo'***REMOVED*** + 'bar'***REMOVED*** is Markup

        # and it implements __html__ by returning itself
        x = Markup("foo"***REMOVED***
        assert x.__html__(***REMOVED*** is x

    def test_html_interop(self***REMOVED***:
        # it also knows how to treat __html__ objects
        class Foo(object***REMOVED***:
            def __html__(self***REMOVED***:
                return '<em>awesome</em>'
            def __unicode__(self***REMOVED***:
                return 'awesome'
            __str__ = __unicode__
        assert Markup(Foo(***REMOVED******REMOVED*** == '<em>awesome</em>'
        assert Markup('<strong>%s</strong>'***REMOVED*** % Foo(***REMOVED*** == \
            '<strong><em>awesome</em></strong>'

    def test_tuple_interpol(self***REMOVED***:
        self.assertEqual(Markup('<em>%s:%s</em>'***REMOVED*** % (
            '<foo>',
            '<bar>',
        ***REMOVED***, Markup(u'<em>&lt;foo&gt;:&lt;bar&gt;</em>'***REMOVED******REMOVED***

    def test_dict_interpol(self***REMOVED***:
        self.assertEqual(Markup('<em>%(foo***REMOVED***s</em>'***REMOVED*** % {
            'foo': '<foo>',
***REMOVED*** Markup(u'<em>&lt;foo&gt;</em>'***REMOVED******REMOVED***
        self.assertEqual(Markup('<em>%(foo***REMOVED***s:%(bar***REMOVED***s</em>'***REMOVED*** % {
            'foo': '<foo>',
            'bar': '<bar>',
***REMOVED*** Markup(u'<em>&lt;foo&gt;:&lt;bar&gt;</em>'***REMOVED******REMOVED***

    def test_escaping(self***REMOVED***:
        # escaping and unescaping
        assert escape('"<>&\''***REMOVED*** == '&#34;&lt;&gt;&amp;&#39;'
        assert Markup("<em>Foo &amp; Bar</em>"***REMOVED***.striptags(***REMOVED*** == "Foo & Bar"
        assert Markup("&lt;test&gt;"***REMOVED***.unescape(***REMOVED*** == "<test>"

    def test_formatting(self***REMOVED***:
        for actual, expected in (
            (Markup('%i'***REMOVED*** % 3.14, '3'***REMOVED***,
            (Markup('%.2f'***REMOVED*** % 3.14159, '3.14'***REMOVED***,
            (Markup('%s %s %s'***REMOVED*** % ('<', 123, '>'***REMOVED***, '&lt; 123 &gt;'***REMOVED***,
            (Markup('<em>{awesome***REMOVED***</em>'***REMOVED***.format(awesome='<awesome>'***REMOVED***,
             '<em>&lt;awesome&gt;</em>'***REMOVED***,
            (Markup('{0[1***REMOVED***[bar***REMOVED******REMOVED***'***REMOVED***.format([0, {'bar': '<bar/>'***REMOVED******REMOVED******REMOVED***,
             '&lt;bar/&gt;'***REMOVED***,
            (Markup('{0[1***REMOVED***[bar***REMOVED******REMOVED***'***REMOVED***.format([0, {'bar': Markup('<bar/>'***REMOVED******REMOVED******REMOVED******REMOVED***,
             '<bar/>'***REMOVED******REMOVED***:
            assert actual == expected, "%r should be %r!" % (actual, expected***REMOVED***

    # This is new in 2.7
    if sys.version_info >= (2, 7***REMOVED***:
        def test_formatting_empty(self***REMOVED***:
            formatted = Markup('{***REMOVED***'***REMOVED***.format(0***REMOVED***
            assert formatted == Markup('0'***REMOVED***

    def test_custom_formatting(self***REMOVED***:
        class HasHTMLOnly(object***REMOVED***:
            def __html__(self***REMOVED***:
                return Markup('<foo>'***REMOVED***

        class HasHTMLAndFormat(object***REMOVED***:
            def __html__(self***REMOVED***:
                return Markup('<foo>'***REMOVED***
            def __html_format__(self, spec***REMOVED***:
                return Markup('<FORMAT>'***REMOVED***

        assert Markup('{0***REMOVED***'***REMOVED***.format(HasHTMLOnly(***REMOVED******REMOVED*** == Markup('<foo>'***REMOVED***
        assert Markup('{0***REMOVED***'***REMOVED***.format(HasHTMLAndFormat(***REMOVED******REMOVED*** == Markup('<FORMAT>'***REMOVED***

    def test_complex_custom_formatting(self***REMOVED***:
        class User(object***REMOVED***:
            def __init__(self, id, username***REMOVED***:
                self.id = id
                self.username = username
            def __html_format__(self, format_spec***REMOVED***:
                if format_spec == 'link':
                    return Markup('<a href="/user/{0***REMOVED***">{1***REMOVED***</a>'***REMOVED***.format(
                        self.id,
                        self.__html__(***REMOVED***,
                    ***REMOVED***
                elif format_spec:
                    raise ValueError('Invalid format spec'***REMOVED***
                return self.__html__(***REMOVED***
            def __html__(self***REMOVED***:
                return Markup('<span class=user>{0***REMOVED***</span>'***REMOVED***.format(self.username***REMOVED***

        user = User(1, 'foo'***REMOVED***
        assert Markup('<p>User: {0:link***REMOVED***'***REMOVED***.format(user***REMOVED*** == \
            Markup('<p>User: <a href="/user/1"><span class=user>foo</span></a>'***REMOVED***

    def test_all_set(self***REMOVED***:
        import markupsafe as markup
        for item in markup.__all__:
            getattr(markup, item***REMOVED***

    def test_escape_silent(self***REMOVED***:
        assert escape_silent(None***REMOVED*** == Markup(***REMOVED***
        assert escape(None***REMOVED*** == Markup(None***REMOVED***
        assert escape_silent('<foo>'***REMOVED*** == Markup(u'&lt;foo&gt;'***REMOVED***

    def test_splitting(self***REMOVED***:
        self.assertEqual(Markup('a b'***REMOVED***.split(***REMOVED***, [
            Markup('a'***REMOVED***,
            Markup('b'***REMOVED***
        ***REMOVED******REMOVED***
        self.assertEqual(Markup('a b'***REMOVED***.rsplit(***REMOVED***, [
            Markup('a'***REMOVED***,
            Markup('b'***REMOVED***
        ***REMOVED******REMOVED***
        self.assertEqual(Markup('a\nb'***REMOVED***.splitlines(***REMOVED***, [
            Markup('a'***REMOVED***,
            Markup('b'***REMOVED***
        ***REMOVED******REMOVED***

    def test_mul(self***REMOVED***:
        self.assertEqual(Markup('a'***REMOVED*** * 3, Markup('aaa'***REMOVED******REMOVED***


class MarkupLeakTestCase(unittest.TestCase***REMOVED***:

    def test_markup_leaks(self***REMOVED***:
        counts = set(***REMOVED***
        for count in range(20***REMOVED***:
            for item in range(1000***REMOVED***:
                escape("foo"***REMOVED***
                escape("<foo>"***REMOVED***
                escape(u"foo"***REMOVED***
                escape(u"<foo>"***REMOVED***
            counts.add(len(gc.get_objects(***REMOVED******REMOVED******REMOVED***
        assert len(counts***REMOVED*** == 1, 'ouch, c extension seems to leak objects'


def suite(***REMOVED***:
    suite = unittest.TestSuite(***REMOVED***
    suite.addTest(unittest.makeSuite(MarkupTestCase***REMOVED******REMOVED***

    # this test only tests the c extension
    if not hasattr(escape, 'func_code'***REMOVED***:
        suite.addTest(unittest.makeSuite(MarkupLeakTestCase***REMOVED******REMOVED***

    return suite


if __name__ == '__main__':
    unittest.main(defaultTest='suite'***REMOVED***

# vim:sts=4:sw=4:et:
