/**
 * markupsafe._speedups
 * ~~~~~~~~~~~~~~~~~~~~
 *
 * This module implements functions for automatic escaping in C for better
 * performance.
 *
 * :copyright: (c***REMOVED*** 2010 by Armin Ronacher.
 * :license: BSD.
 */

#include <Python.h>

#define ESCAPED_CHARS_TABLE_SIZE 63
#define UNICHR(x***REMOVED*** (PyUnicode_AS_UNICODE((PyUnicodeObject****REMOVED***PyUnicode_DecodeASCII(x, strlen(x***REMOVED***, NULL***REMOVED******REMOVED******REMOVED***;

#if PY_VERSION_HEX < 0x02050000 && !defined(PY_SSIZE_T_MIN***REMOVED***
typedef int Py_ssize_t;
#define PY_SSIZE_T_MAX INT_MAX
#define PY_SSIZE_T_MIN INT_MIN
#endif


static PyObject* markup;
static Py_ssize_t escaped_chars_delta_len[ESCAPED_CHARS_TABLE_SIZE***REMOVED***;
static Py_UNICODE *escaped_chars_repl[ESCAPED_CHARS_TABLE_SIZE***REMOVED***;

static int
init_constants(void***REMOVED***
{
	PyObject *module;
	/* happing of characters to replace */
	escaped_chars_repl['"'***REMOVED*** = UNICHR("&#34;"***REMOVED***;
	escaped_chars_repl['\''***REMOVED*** = UNICHR("&#39;"***REMOVED***;
	escaped_chars_repl['&'***REMOVED*** = UNICHR("&amp;"***REMOVED***;
	escaped_chars_repl['<'***REMOVED*** = UNICHR("&lt;"***REMOVED***;
	escaped_chars_repl['>'***REMOVED*** = UNICHR("&gt;"***REMOVED***;

	/* lengths of those characters when replaced - 1 */
	memset(escaped_chars_delta_len, 0, sizeof (escaped_chars_delta_len***REMOVED******REMOVED***;
	escaped_chars_delta_len['"'***REMOVED*** = escaped_chars_delta_len['\''***REMOVED*** = \
		escaped_chars_delta_len['&'***REMOVED*** = 4;
	escaped_chars_delta_len['<'***REMOVED*** = escaped_chars_delta_len['>'***REMOVED*** = 3;
	
	/* import markup type so that we can mark the return value */
	module = PyImport_ImportModule("markupsafe"***REMOVED***;
	if (!module***REMOVED***
		return 0;
	markup = PyObject_GetAttrString(module, "Markup"***REMOVED***;
	Py_DECREF(module***REMOVED***;

	return 1;
***REMOVED***

static PyObject*
escape_unicode(PyUnicodeObject *in***REMOVED***
{
	PyUnicodeObject *out;
	Py_UNICODE *inp = PyUnicode_AS_UNICODE(in***REMOVED***;
	const Py_UNICODE *inp_end = PyUnicode_AS_UNICODE(in***REMOVED*** + PyUnicode_GET_SIZE(in***REMOVED***;
	Py_UNICODE *next_escp;
	Py_UNICODE *outp;
	Py_ssize_t delta=0, erepl=0, delta_len=0;

	/* First we need to figure out how long the escaped string will be */
	while (*(inp***REMOVED*** || inp < inp_end***REMOVED*** {
		if (*inp < ESCAPED_CHARS_TABLE_SIZE***REMOVED*** {
			delta += escaped_chars_delta_len[*inp***REMOVED***;
			erepl += !!escaped_chars_delta_len[*inp***REMOVED***;
		***REMOVED***
		++inp;
	***REMOVED***

	/* Do we need to escape anything at all? */
	if (!erepl***REMOVED*** {
		Py_INCREF(in***REMOVED***;
		return (PyObject****REMOVED***in;
	***REMOVED***

	out = (PyUnicodeObject****REMOVED***PyUnicode_FromUnicode(NULL, PyUnicode_GET_SIZE(in***REMOVED*** + delta***REMOVED***;
	if (!out***REMOVED***
		return NULL;

	outp = PyUnicode_AS_UNICODE(out***REMOVED***;
	inp = PyUnicode_AS_UNICODE(in***REMOVED***;
	while (erepl-- > 0***REMOVED*** {
		/* look for the next substitution */
		next_escp = inp;
		while (next_escp < inp_end***REMOVED*** {
			if (*next_escp < ESCAPED_CHARS_TABLE_SIZE &&
			    (delta_len = escaped_chars_delta_len[*next_escp***REMOVED******REMOVED******REMOVED*** {
				++delta_len;
				break;
			***REMOVED***
			++next_escp;
		***REMOVED***
		
		if (next_escp > inp***REMOVED*** {
			/* copy unescaped chars between inp and next_escp */
			Py_UNICODE_COPY(outp, inp, next_escp-inp***REMOVED***;
			outp += next_escp - inp;
		***REMOVED***

		/* escape 'next_escp' */
		Py_UNICODE_COPY(outp, escaped_chars_repl[*next_escp***REMOVED***, delta_len***REMOVED***;
		outp += delta_len;

		inp = next_escp + 1;
	***REMOVED***
	if (inp < inp_end***REMOVED***
		Py_UNICODE_COPY(outp, inp, PyUnicode_GET_SIZE(in***REMOVED*** - (inp - PyUnicode_AS_UNICODE(in***REMOVED******REMOVED******REMOVED***;

	return (PyObject****REMOVED***out;
***REMOVED***


static PyObject*
escape(PyObject *self, PyObject *text***REMOVED***
{
	PyObject *s = NULL, *rv = NULL, *html;

	/* we don't have to escape integers, bools or floats */
	if (PyLong_CheckExact(text***REMOVED*** ||
#if PY_MAJOR_VERSION < 3
	    PyInt_CheckExact(text***REMOVED*** ||
#endif
	    PyFloat_CheckExact(text***REMOVED*** || PyBool_Check(text***REMOVED*** ||
	    text == Py_None***REMOVED***
		return PyObject_CallFunctionObjArgs(markup, text, NULL***REMOVED***;

	/* if the object has an __html__ method that performs the escaping */
	html = PyObject_GetAttrString(text, "__html__"***REMOVED***;
	if (html***REMOVED*** {
		rv = PyObject_CallObject(html, NULL***REMOVED***;
		Py_DECREF(html***REMOVED***;
		return rv;
	***REMOVED***

	/* otherwise make the object unicode if it isn't, then escape */
	PyErr_Clear(***REMOVED***;
	if (!PyUnicode_Check(text***REMOVED******REMOVED*** {
#if PY_MAJOR_VERSION < 3
		PyObject *unicode = PyObject_Unicode(text***REMOVED***;
#else
		PyObject *unicode = PyObject_Str(text***REMOVED***;
#endif
		if (!unicode***REMOVED***
			return NULL;
		s = escape_unicode((PyUnicodeObject****REMOVED***unicode***REMOVED***;
		Py_DECREF(unicode***REMOVED***;
	***REMOVED***
	else
		s = escape_unicode((PyUnicodeObject****REMOVED***text***REMOVED***;

	/* convert the unicode string into a markup object. */
	rv = PyObject_CallFunctionObjArgs(markup, (PyObject****REMOVED***s, NULL***REMOVED***;
	Py_DECREF(s***REMOVED***;
	return rv;
***REMOVED***


static PyObject*
escape_silent(PyObject *self, PyObject *text***REMOVED***
{
	if (text != Py_None***REMOVED***
		return escape(self, text***REMOVED***;
	return PyObject_CallFunctionObjArgs(markup, NULL***REMOVED***;
***REMOVED***


static PyObject*
soft_unicode(PyObject *self, PyObject *s***REMOVED***
{
	if (!PyUnicode_Check(s***REMOVED******REMOVED***
#if PY_MAJOR_VERSION < 3
		return PyObject_Unicode(s***REMOVED***;
#else
		return PyObject_Str(s***REMOVED***;
#endif
	Py_INCREF(s***REMOVED***;
	return s;
***REMOVED***


static PyMethodDef module_methods[***REMOVED*** = {
	{"escape", (PyCFunction***REMOVED***escape, METH_O,
	 "escape(s***REMOVED*** -> markup\n\n"
	 "Convert the characters &, <, >, ', and \" in string s to HTML-safe\n"
	 "sequences.  Use this if you need to display text that might contain\n"
	 "such characters in HTML.  Marks return value as markup string."***REMOVED***,
	{"escape_silent", (PyCFunction***REMOVED***escape_silent, METH_O,
	 "escape_silent(s***REMOVED*** -> markup\n\n"
	 "Like escape but converts None to an empty string."***REMOVED***,
	{"soft_unicode", (PyCFunction***REMOVED***soft_unicode, METH_O,
	 "soft_unicode(object***REMOVED*** -> string\n\n"
         "Make a string unicode if it isn't already.  That way a markup\n"
         "string is not converted back to unicode."***REMOVED***,
	{NULL, NULL, 0, NULL***REMOVED***		/* Sentinel */
***REMOVED***;


#if PY_MAJOR_VERSION < 3

#ifndef PyMODINIT_FUNC	/* declarations for DLL import/export */
#define PyMODINIT_FUNC void
#endif
PyMODINIT_FUNC
init_speedups(void***REMOVED***
{
	if (!init_constants(***REMOVED******REMOVED***
		return;

	Py_InitModule3("markupsafe._speedups", module_methods, ""***REMOVED***;
***REMOVED***

#else /* Python 3.x module initialization */

static struct PyModuleDef module_definition = {
        PyModuleDef_HEAD_INIT,
	"markupsafe._speedups",
	NULL,
	-1,
	module_methods,
	NULL,
	NULL,
	NULL,
	NULL
***REMOVED***;

PyMODINIT_FUNC
PyInit__speedups(void***REMOVED***
{
	if (!init_constants(***REMOVED******REMOVED***
		return NULL;

	return PyModule_Create(&module_definition***REMOVED***;
***REMOVED***

#endif
